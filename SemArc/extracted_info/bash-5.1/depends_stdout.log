Start parsing files...
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\alias.c...
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\chartypes.h...
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashansi.h...
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\command.h...
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\stdc.h...
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\general.h...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\stdc.h...skip
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashtypes.h...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\chartypes.h...skip
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\xmalloc.h...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\stdc.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashansi.h...skip
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\externs.h...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\stdc.h...skip
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\alias.h...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\stdc.h...skip
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\hashlib.h...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\stdc.h...skip
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\array.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashansi.h...skip
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\shell.h...
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashjmp.h...
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\posixjmp.h...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\command.h...skip
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\syntax.h...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\general.h...skip
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\error.h...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\stdc.h...skip
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.h...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\stdc.h...skip
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\array.h...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\stdc.h...skip
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\assoc.h...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\stdc.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\hashlib.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\hashlib.h...skip
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\conftypes.h...
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\arrayfunc.h...
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\quit.h...
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\sig.h...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\stdc.h...skip
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\maxpath.h...
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\unwind_prot.h...
parsing error 
extern void uwp_init PARAMS((void));
warning: parse error extern void uwp_init PARAMS((void));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\unwind_prot.h:33
parsing error 
extern void begin_unwind_frame PARAMS((char *));
warning: parse error extern void begin_unwind_frame PARAMS((char *));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\unwind_prot.h:36
parsing error 
extern void discard_unwind_frame PARAMS((char *));
warning: parse error extern void discard_unwind_frame PARAMS((char *));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\unwind_prot.h:37
parsing error 
extern void run_unwind_frame PARAMS((char *));
warning: parse error extern void run_unwind_frame PARAMS((char *));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\unwind_prot.h:38
parsing error 
extern void remove_unwind_protect PARAMS((void));
warning: parse error extern void remove_unwind_protect PARAMS((void));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\unwind_prot.h:40
parsing error 
extern void run_unwind_protects PARAMS((void));
warning: parse error extern void run_unwind_protects PARAMS((void));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\unwind_prot.h:41
parsing error 
extern void clear_unwind_protect_list PARAMS((int));
warning: parse error extern void clear_unwind_protect_list PARAMS((int));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\unwind_prot.h:42
parsing error 
extern int have_unwind_protects PARAMS((void));
warning: parse error extern int have_unwind_protects PARAMS((void));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\unwind_prot.h:43
parsing error 
extern int unwind_protect_tag_on_stack PARAMS((const char *));
warning: parse error extern int unwind_protect_tag_on_stack PARAMS((const char *));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\unwind_prot.h:44
parsing error 
extern void uwp_init PARAMS((void));
warning: parse error extern void uwp_init PARAMS((void));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\unwind_prot.h:45
parsing error 
extern void unwind_protect_mem PARAMS((char *, int));
warning: parse error extern void unwind_protect_mem PARAMS((char *, int));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\unwind_prot.h:52
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\dispose_cmd.h...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\stdc.h...skip
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\make_cmd.h...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\stdc.h...skip
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\ocache.h...
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.h...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\stdc.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\sig.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\externs.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\array.h...skip
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\common.h...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\stdc.h...skip
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\arrayfunc.c...
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashintl.h...
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\gettext.h...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\shell.h...skip
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\execute_cmd.h...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\stdc.h...skip
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\pathexp.h...
parsing error 
extern int unquoted_glob_pattern_p PARAMS((char *));
warning: parse error extern int unquoted_glob_pattern_p PARAMS((char *));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\pathexp.h:64
parsing error 
extern char *quote_string_for_globbing PARAMS((const char *, int));
warning: parse error extern char *quote_string_for_globbing PARAMS((const char *, int));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\pathexp.h:76
parsing error 
extern int glob_char_p PARAMS((const char *));
warning: parse error extern int glob_char_p PARAMS((const char *));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\pathexp.h:78
parsing error 
extern char *quote_globbing_chars PARAMS((const char *));
warning: parse error extern char *quote_globbing_chars PARAMS((const char *));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\pathexp.h:79
parsing error 
extern char **shell_glob_filename PARAMS((const char *, int));
warning: parse error extern char **shell_glob_filename PARAMS((const char *, int));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\pathexp.h:84
parsing error 
typedef int sh_iv_item_func_t PARAMS((struct ign *));
warning: parse error typedef int sh_iv_item_func_t PARAMS((struct ign *));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\pathexp.h:100
parsing error 
extern void setup_ignore_patterns PARAMS((struct ignorevar *));
warning: parse error extern void setup_ignore_patterns PARAMS((struct ignorevar *));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\pathexp.h:110
parsing error 
extern void setup_glob_ignore PARAMS((char *));
warning: parse error extern void setup_glob_ignore PARAMS((char *));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\pathexp.h:112
parsing error 
extern int should_ignore_glob_matches PARAMS((void));
warning: parse error extern int should_ignore_glob_matches PARAMS((void));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\pathexp.h:113
parsing error 
extern void ignore_glob_matches PARAMS((char **));
warning: parse error extern void ignore_glob_matches PARAMS((char **));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\pathexp.h:114
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\shmbutil.h...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\stdc.h...skip
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\shmbchar.h...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\common.h...skip
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\assoc.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashansi.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\shell.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\array.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\assoc.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\common.h...skip
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashhist.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashtypes.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashansi.h...skip
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\posixstat.h...
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\filecntl.h...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashintl.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\shell.h...skip
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\flags.h...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\stdc.h...skip
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\parser.h...
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\input.h...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\stdc.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\parser.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\pathexp.h...skip
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashhist.h...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\stdc.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\common.h...skip
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\history.h...
parsing error 
int private;
warning: parse error int private;Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\history.h:59
parsing error 
extern void using_history PARAMS((void));
warning: parse error extern void using_history PARAMS((void));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\history.h:81
parsing error 
extern HISTORY_STATE *history_get_history_state PARAMS((void));
warning: parse error extern HISTORY_STATE *history_get_history_state PARAMS((void));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\history.h:84
parsing error 
extern void history_set_history_state PARAMS((HISTORY_STATE *));
warning: parse error extern void history_set_history_state PARAMS((HISTORY_STATE *));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\history.h:87
parsing error 
extern void add_history PARAMS((const char *));
warning: parse error extern void add_history PARAMS((const char *));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\history.h:93
parsing error 
extern void add_private_history PARAMS((const char *));
warning: parse error extern void add_private_history PARAMS((const char *));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\history.h:94
parsing error 
extern void add_history_time PARAMS((const char *));
warning: parse error extern void add_history_time PARAMS((const char *));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\history.h:98
parsing error 
extern HIST_ENTRY *remove_history PARAMS((int));
warning: parse error extern HIST_ENTRY *remove_history PARAMS((int));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\history.h:102
parsing error 
extern HIST_ENTRY **remove_history_range PARAMS((int, int));
warning: parse error extern HIST_ENTRY **remove_history_range PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\history.h:105
parsing error 
extern HIST_ENTRY *alloc_history_entry PARAMS((char *, char *));
warning: parse error extern HIST_ENTRY *alloc_history_entry PARAMS((char *, char *));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\history.h:109
parsing error 
extern HIST_ENTRY *copy_history_entry PARAMS((HIST_ENTRY *));
warning: parse error extern HIST_ENTRY *copy_history_entry PARAMS((HIST_ENTRY *));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\history.h:112
parsing error 
extern histdata_t free_history_entry PARAMS((HIST_ENTRY *));
warning: parse error extern histdata_t free_history_entry PARAMS((HIST_ENTRY *));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\history.h:116
parsing error 
extern HIST_ENTRY *replace_history_entry PARAMS((int, const char *, histdata_t));
warning: parse error extern HIST_ENTRY *replace_history_entry PARAMS((int, const char *, histdata_t));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\history.h:121
parsing error 
extern void clear_history PARAMS((void));
warning: parse error extern void clear_history PARAMS((void));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\history.h:124
parsing error 
extern void stifle_history PARAMS((int));
warning: parse error extern void stifle_history PARAMS((int));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\history.h:127
parsing error 
extern int unstifle_history PARAMS((void));
warning: parse error extern int unstifle_history PARAMS((void));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\history.h:132
parsing error 
extern int history_is_stifled PARAMS((void));
warning: parse error extern int history_is_stifled PARAMS((void));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\history.h:135
parsing error 
extern HIST_ENTRY **history_list PARAMS((void));
warning: parse error extern HIST_ENTRY **history_list PARAMS((void));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\history.h:142
parsing error 
extern int where_history PARAMS((void));
warning: parse error extern int where_history PARAMS((void));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\history.h:146
parsing error 
extern HIST_ENTRY *current_history PARAMS((void));
warning: parse error extern HIST_ENTRY *current_history PARAMS((void));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\history.h:150
parsing error 
extern HIST_ENTRY *history_get PARAMS((int));
warning: parse error extern HIST_ENTRY *history_get PARAMS((int));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\history.h:154
parsing error 
extern time_t history_get_time PARAMS((HIST_ENTRY *));
warning: parse error extern time_t history_get_time PARAMS((HIST_ENTRY *));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\history.h:158
parsing error 
extern int history_total_bytes PARAMS((void));
warning: parse error extern int history_total_bytes PARAMS((void));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\history.h:162
parsing error 
extern int history_set_pos PARAMS((int));
warning: parse error extern int history_set_pos PARAMS((int));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\history.h:167
parsing error 
extern HIST_ENTRY *previous_history PARAMS((void));
warning: parse error extern HIST_ENTRY *previous_history PARAMS((void));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\history.h:172
parsing error 
extern HIST_ENTRY *next_history PARAMS((void));
warning: parse error extern HIST_ENTRY *next_history PARAMS((void));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\history.h:177
parsing error 
extern int history_search PARAMS((const char *, int));
warning: parse error extern int history_search PARAMS((const char *, int));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\history.h:187
parsing error 
extern int history_search_prefix PARAMS((const char *, int));
warning: parse error extern int history_search_prefix PARAMS((const char *, int));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\history.h:192
parsing error 
extern int history_search_pos PARAMS((const char *, int, int));
warning: parse error extern int history_search_pos PARAMS((const char *, int, int));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\history.h:199
parsing error 
extern int read_history PARAMS((const char *));
warning: parse error extern int read_history PARAMS((const char *));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\history.h:206
parsing error 
extern int read_history_range PARAMS((const char *, int, int));
warning: parse error extern int read_history_range PARAMS((const char *, int, int));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\history.h:213
parsing error 
extern int write_history PARAMS((const char *));
warning: parse error extern int write_history PARAMS((const char *));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\history.h:218
parsing error 
extern int append_history PARAMS((int, const char *));
warning: parse error extern int append_history PARAMS((int, const char *));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\history.h:222
parsing error 
extern int history_truncate_file PARAMS((const char *, int));
warning: parse error extern int history_truncate_file PARAMS((const char *, int));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\history.h:225
parsing error 
extern int history_expand PARAMS((char *, char **));
warning: parse error extern int history_expand PARAMS((char *, char **));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\history.h:241
parsing error 
extern char *history_arg_extract PARAMS((int, int, const char *));
warning: parse error extern char *history_arg_extract PARAMS((int, int, const char *));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\history.h:246
parsing error 
extern char *get_history_event PARAMS((const char *, int *, int));
warning: parse error extern char *get_history_event PARAMS((const char *, int *, int));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\history.h:254
parsing error 
extern char **history_tokenize PARAMS((const char *));
warning: parse error extern char **history_tokenize PARAMS((const char *));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\history.h:258
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\glob\glob.h...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\stdc.h...skip
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\glob\strmatch.h...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\stdc.h...skip
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashline.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashtypes.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\posixstat.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\chartypes.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashansi.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashintl.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\shell.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\input.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\parser.h...skip
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins.h...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\command.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\general.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\alias.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashhist.h...skip
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashline.h...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\stdc.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\execute_cmd.h...skip
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\findcmd.h...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\stdc.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\pathexp.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\shmbutil.h...skip
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\trap.h...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\stdc.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashtypes.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\flags.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\common.h...skip
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\rlconf.h...
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h...
parsing error 
extern int rl_digit_argument PARAMS((int, int));
warning: parse error extern int rl_digit_argument PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:91
parsing error 
extern int rl_universal_argument PARAMS((int, int));
warning: parse error extern int rl_universal_argument PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:92
parsing error 
extern int rl_forward_byte PARAMS((int, int));
warning: parse error extern int rl_forward_byte PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:95
parsing error 
extern int rl_forward_char PARAMS((int, int));
warning: parse error extern int rl_forward_char PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:96
parsing error 
extern int rl_forward PARAMS((int, int));
warning: parse error extern int rl_forward PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:97
parsing error 
extern int rl_backward_byte PARAMS((int, int));
warning: parse error extern int rl_backward_byte PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:98
parsing error 
extern int rl_backward_char PARAMS((int, int));
warning: parse error extern int rl_backward_char PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:99
parsing error 
extern int rl_backward PARAMS((int, int));
warning: parse error extern int rl_backward PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:100
parsing error 
extern int rl_beg_of_line PARAMS((int, int));
warning: parse error extern int rl_beg_of_line PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:101
parsing error 
extern int rl_end_of_line PARAMS((int, int));
warning: parse error extern int rl_end_of_line PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:102
parsing error 
extern int rl_forward_word PARAMS((int, int));
warning: parse error extern int rl_forward_word PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:103
parsing error 
extern int rl_backward_word PARAMS((int, int));
warning: parse error extern int rl_backward_word PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:104
parsing error 
extern int rl_refresh_line PARAMS((int, int));
warning: parse error extern int rl_refresh_line PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:105
parsing error 
extern int rl_clear_screen PARAMS((int, int));
warning: parse error extern int rl_clear_screen PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:106
parsing error 
extern int rl_clear_display PARAMS((int, int));
warning: parse error extern int rl_clear_display PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:107
parsing error 
extern int rl_skip_csi_sequence PARAMS((int, int));
warning: parse error extern int rl_skip_csi_sequence PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:108
parsing error 
extern int rl_arrow_keys PARAMS((int, int));
warning: parse error extern int rl_arrow_keys PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:109
parsing error 
extern int rl_previous_screen_line PARAMS((int, int));
warning: parse error extern int rl_previous_screen_line PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:111
parsing error 
extern int rl_next_screen_line PARAMS((int, int));
warning: parse error extern int rl_next_screen_line PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:112
parsing error 
extern int rl_insert PARAMS((int, int));
warning: parse error extern int rl_insert PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:115
parsing error 
extern int rl_quoted_insert PARAMS((int, int));
warning: parse error extern int rl_quoted_insert PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:116
parsing error 
extern int rl_tab_insert PARAMS((int, int));
warning: parse error extern int rl_tab_insert PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:117
parsing error 
extern int rl_newline PARAMS((int, int));
warning: parse error extern int rl_newline PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:118
parsing error 
extern int rl_do_lowercase_version PARAMS((int, int));
warning: parse error extern int rl_do_lowercase_version PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:119
parsing error 
extern int rl_rubout PARAMS((int, int));
warning: parse error extern int rl_rubout PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:120
parsing error 
extern int rl_delete PARAMS((int, int));
warning: parse error extern int rl_delete PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:121
parsing error 
extern int rl_rubout_or_delete PARAMS((int, int));
warning: parse error extern int rl_rubout_or_delete PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:122
parsing error 
extern int rl_delete_horizontal_space PARAMS((int, int));
warning: parse error extern int rl_delete_horizontal_space PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:123
parsing error 
extern int rl_delete_or_show_completions PARAMS((int, int));
warning: parse error extern int rl_delete_or_show_completions PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:124
parsing error 
extern int rl_insert_comment PARAMS((int, int));
warning: parse error extern int rl_insert_comment PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:125
parsing error 
extern int rl_upcase_word PARAMS((int, int));
warning: parse error extern int rl_upcase_word PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:128
parsing error 
extern int rl_downcase_word PARAMS((int, int));
warning: parse error extern int rl_downcase_word PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:129
parsing error 
extern int rl_capitalize_word PARAMS((int, int));
warning: parse error extern int rl_capitalize_word PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:130
parsing error 
extern int rl_transpose_words PARAMS((int, int));
warning: parse error extern int rl_transpose_words PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:133
parsing error 
extern int rl_transpose_chars PARAMS((int, int));
warning: parse error extern int rl_transpose_chars PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:134
parsing error 
extern int rl_char_search PARAMS((int, int));
warning: parse error extern int rl_char_search PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:137
parsing error 
extern int rl_backward_char_search PARAMS((int, int));
warning: parse error extern int rl_backward_char_search PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:138
parsing error 
extern int rl_beginning_of_history PARAMS((int, int));
warning: parse error extern int rl_beginning_of_history PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:141
parsing error 
extern int rl_end_of_history PARAMS((int, int));
warning: parse error extern int rl_end_of_history PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:142
parsing error 
extern int rl_get_next_history PARAMS((int, int));
warning: parse error extern int rl_get_next_history PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:143
parsing error 
extern int rl_get_previous_history PARAMS((int, int));
warning: parse error extern int rl_get_previous_history PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:144
parsing error 
extern int rl_operate_and_get_next PARAMS((int, int));
warning: parse error extern int rl_operate_and_get_next PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:145
parsing error 
extern int rl_set_mark PARAMS((int, int));
warning: parse error extern int rl_set_mark PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:148
parsing error 
extern int rl_exchange_point_and_mark PARAMS((int, int));
warning: parse error extern int rl_exchange_point_and_mark PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:149
parsing error 
extern int rl_vi_editing_mode PARAMS((int, int));
warning: parse error extern int rl_vi_editing_mode PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:152
parsing error 
extern int rl_emacs_editing_mode PARAMS((int, int));
warning: parse error extern int rl_emacs_editing_mode PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:153
parsing error 
extern int rl_overwrite_mode PARAMS((int, int));
warning: parse error extern int rl_overwrite_mode PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:156
parsing error 
extern int rl_re_read_init_file PARAMS((int, int));
warning: parse error extern int rl_re_read_init_file PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:159
parsing error 
extern int rl_dump_functions PARAMS((int, int));
warning: parse error extern int rl_dump_functions PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:160
parsing error 
extern int rl_dump_macros PARAMS((int, int));
warning: parse error extern int rl_dump_macros PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:161
parsing error 
extern int rl_dump_variables PARAMS((int, int));
warning: parse error extern int rl_dump_variables PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:162
parsing error 
extern int rl_complete PARAMS((int, int));
warning: parse error extern int rl_complete PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:165
parsing error 
extern int rl_possible_completions PARAMS((int, int));
warning: parse error extern int rl_possible_completions PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:166
parsing error 
extern int rl_insert_completions PARAMS((int, int));
warning: parse error extern int rl_insert_completions PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:167
parsing error 
extern int rl_old_menu_complete PARAMS((int, int));
warning: parse error extern int rl_old_menu_complete PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:168
parsing error 
extern int rl_menu_complete PARAMS((int, int));
warning: parse error extern int rl_menu_complete PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:169
parsing error 
extern int rl_backward_menu_complete PARAMS((int, int));
warning: parse error extern int rl_backward_menu_complete PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:170
parsing error 
extern int rl_kill_word PARAMS((int, int));
warning: parse error extern int rl_kill_word PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:173
parsing error 
extern int rl_backward_kill_word PARAMS((int, int));
warning: parse error extern int rl_backward_kill_word PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:174
parsing error 
extern int rl_kill_line PARAMS((int, int));
warning: parse error extern int rl_kill_line PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:175
parsing error 
extern int rl_backward_kill_line PARAMS((int, int));
warning: parse error extern int rl_backward_kill_line PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:176
parsing error 
extern int rl_kill_full_line PARAMS((int, int));
warning: parse error extern int rl_kill_full_line PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:177
parsing error 
extern int rl_unix_word_rubout PARAMS((int, int));
warning: parse error extern int rl_unix_word_rubout PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:178
parsing error 
extern int rl_unix_filename_rubout PARAMS((int, int));
warning: parse error extern int rl_unix_filename_rubout PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:179
parsing error 
extern int rl_unix_line_discard PARAMS((int, int));
warning: parse error extern int rl_unix_line_discard PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:180
parsing error 
extern int rl_copy_region_to_kill PARAMS((int, int));
warning: parse error extern int rl_copy_region_to_kill PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:181
parsing error 
extern int rl_kill_region PARAMS((int, int));
warning: parse error extern int rl_kill_region PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:182
parsing error 
extern int rl_copy_forward_word PARAMS((int, int));
warning: parse error extern int rl_copy_forward_word PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:183
parsing error 
extern int rl_copy_backward_word PARAMS((int, int));
warning: parse error extern int rl_copy_backward_word PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:184
parsing error 
extern int rl_yank PARAMS((int, int));
warning: parse error extern int rl_yank PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:185
parsing error 
extern int rl_yank_pop PARAMS((int, int));
warning: parse error extern int rl_yank_pop PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:186
parsing error 
extern int rl_yank_nth_arg PARAMS((int, int));
warning: parse error extern int rl_yank_nth_arg PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:187
parsing error 
extern int rl_yank_last_arg PARAMS((int, int));
warning: parse error extern int rl_yank_last_arg PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:188
parsing error 
extern int rl_bracketed_paste_begin PARAMS((int, int));
warning: parse error extern int rl_bracketed_paste_begin PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:189
parsing error 
extern int rl_paste_from_clipboard PARAMS((int, int));
warning: parse error extern int rl_paste_from_clipboard PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:192
parsing error 
extern int rl_reverse_search_history PARAMS((int, int));
warning: parse error extern int rl_reverse_search_history PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:196
parsing error 
extern int rl_forward_search_history PARAMS((int, int));
warning: parse error extern int rl_forward_search_history PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:197
parsing error 
extern int rl_start_kbd_macro PARAMS((int, int));
warning: parse error extern int rl_start_kbd_macro PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:200
parsing error 
extern int rl_end_kbd_macro PARAMS((int, int));
warning: parse error extern int rl_end_kbd_macro PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:201
parsing error 
extern int rl_call_last_kbd_macro PARAMS((int, int));
warning: parse error extern int rl_call_last_kbd_macro PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:202
parsing error 
extern int rl_print_last_kbd_macro PARAMS((int, int));
warning: parse error extern int rl_print_last_kbd_macro PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:203
parsing error 
extern int rl_revert_line PARAMS((int, int));
warning: parse error extern int rl_revert_line PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:206
parsing error 
extern int rl_undo_command PARAMS((int, int));
warning: parse error extern int rl_undo_command PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:207
parsing error 
extern int rl_tilde_expand PARAMS((int, int));
warning: parse error extern int rl_tilde_expand PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:210
parsing error 
extern int rl_restart_output PARAMS((int, int));
warning: parse error extern int rl_restart_output PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:213
parsing error 
extern int rl_stop_output PARAMS((int, int));
warning: parse error extern int rl_stop_output PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:214
parsing error 
extern int rl_abort PARAMS((int, int));
warning: parse error extern int rl_abort PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:217
parsing error 
extern int rl_tty_status PARAMS((int, int));
warning: parse error extern int rl_tty_status PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:218
parsing error 
extern int rl_history_search_forward PARAMS((int, int));
warning: parse error extern int rl_history_search_forward PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:221
parsing error 
extern int rl_history_search_backward PARAMS((int, int));
warning: parse error extern int rl_history_search_backward PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:222
parsing error 
extern int rl_history_substr_search_forward PARAMS((int, int));
warning: parse error extern int rl_history_substr_search_forward PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:223
parsing error 
extern int rl_history_substr_search_backward PARAMS((int, int));
warning: parse error extern int rl_history_substr_search_backward PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:224
parsing error 
extern int rl_noninc_forward_search PARAMS((int, int));
warning: parse error extern int rl_noninc_forward_search PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:225
parsing error 
extern int rl_noninc_reverse_search PARAMS((int, int));
warning: parse error extern int rl_noninc_reverse_search PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:226
parsing error 
extern int rl_noninc_forward_search_again PARAMS((int, int));
warning: parse error extern int rl_noninc_forward_search_again PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:227
parsing error 
extern int rl_noninc_reverse_search_again PARAMS((int, int));
warning: parse error extern int rl_noninc_reverse_search_again PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:228
parsing error 
extern int rl_insert_close PARAMS((int, int));
warning: parse error extern int rl_insert_close PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:231
parsing error 
extern void rl_callback_handler_install PARAMS((const char *, rl_vcpfunc_t *));
warning: parse error extern void rl_callback_handler_install PARAMS((const char *, rl_vcpfunc_t *));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:234
parsing error 
extern void rl_callback_read_char PARAMS((void));
warning: parse error extern void rl_callback_read_char PARAMS((void));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:235
parsing error 
extern void rl_callback_handler_remove PARAMS((void));
warning: parse error extern void rl_callback_handler_remove PARAMS((void));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:236
parsing error 
extern void rl_callback_sigcleanup PARAMS((void));
warning: parse error extern void rl_callback_sigcleanup PARAMS((void));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:237
parsing error 
extern int rl_vi_redo PARAMS((int, int));
warning: parse error extern int rl_vi_redo PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:241
parsing error 
extern int rl_vi_undo PARAMS((int, int));
warning: parse error extern int rl_vi_undo PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:242
parsing error 
extern int rl_vi_yank_arg PARAMS((int, int));
warning: parse error extern int rl_vi_yank_arg PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:243
parsing error 
extern int rl_vi_fetch_history PARAMS((int, int));
warning: parse error extern int rl_vi_fetch_history PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:244
parsing error 
extern int rl_vi_search_again PARAMS((int, int));
warning: parse error extern int rl_vi_search_again PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:245
parsing error 
extern int rl_vi_search PARAMS((int, int));
warning: parse error extern int rl_vi_search PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:246
parsing error 
extern int rl_vi_complete PARAMS((int, int));
warning: parse error extern int rl_vi_complete PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:247
parsing error 
extern int rl_vi_tilde_expand PARAMS((int, int));
warning: parse error extern int rl_vi_tilde_expand PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:248
parsing error 
extern int rl_vi_prev_word PARAMS((int, int));
warning: parse error extern int rl_vi_prev_word PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:249
parsing error 
extern int rl_vi_next_word PARAMS((int, int));
warning: parse error extern int rl_vi_next_word PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:250
parsing error 
extern int rl_vi_end_word PARAMS((int, int));
warning: parse error extern int rl_vi_end_word PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:251
parsing error 
extern int rl_vi_insert_beg PARAMS((int, int));
warning: parse error extern int rl_vi_insert_beg PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:252
parsing error 
extern int rl_vi_append_mode PARAMS((int, int));
warning: parse error extern int rl_vi_append_mode PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:253
parsing error 
extern int rl_vi_append_eol PARAMS((int, int));
warning: parse error extern int rl_vi_append_eol PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:254
parsing error 
extern int rl_vi_eof_maybe PARAMS((int, int));
warning: parse error extern int rl_vi_eof_maybe PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:255
parsing error 
extern int rl_vi_insertion_mode PARAMS((int, int));
warning: parse error extern int rl_vi_insertion_mode PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:256
parsing error 
extern int rl_vi_insert_mode PARAMS((int, int));
warning: parse error extern int rl_vi_insert_mode PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:257
parsing error 
extern int rl_vi_movement_mode PARAMS((int, int));
warning: parse error extern int rl_vi_movement_mode PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:258
parsing error 
extern int rl_vi_arg_digit PARAMS((int, int));
warning: parse error extern int rl_vi_arg_digit PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:259
parsing error 
extern int rl_vi_change_case PARAMS((int, int));
warning: parse error extern int rl_vi_change_case PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:260
parsing error 
extern int rl_vi_put PARAMS((int, int));
warning: parse error extern int rl_vi_put PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:261
parsing error 
extern int rl_vi_column PARAMS((int, int));
warning: parse error extern int rl_vi_column PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:262
parsing error 
extern int rl_vi_delete_to PARAMS((int, int));
warning: parse error extern int rl_vi_delete_to PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:263
parsing error 
extern int rl_vi_change_to PARAMS((int, int));
warning: parse error extern int rl_vi_change_to PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:264
parsing error 
extern int rl_vi_yank_to PARAMS((int, int));
warning: parse error extern int rl_vi_yank_to PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:265
parsing error 
extern int rl_vi_yank_pop PARAMS((int, int));
warning: parse error extern int rl_vi_yank_pop PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:266
parsing error 
extern int rl_vi_rubout PARAMS((int, int));
warning: parse error extern int rl_vi_rubout PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:267
parsing error 
extern int rl_vi_delete PARAMS((int, int));
warning: parse error extern int rl_vi_delete PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:268
parsing error 
extern int rl_vi_back_to_indent PARAMS((int, int));
warning: parse error extern int rl_vi_back_to_indent PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:269
parsing error 
extern int rl_vi_unix_word_rubout PARAMS((int, int));
warning: parse error extern int rl_vi_unix_word_rubout PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:270
parsing error 
extern int rl_vi_first_print PARAMS((int, int));
warning: parse error extern int rl_vi_first_print PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:271
parsing error 
extern int rl_vi_char_search PARAMS((int, int));
warning: parse error extern int rl_vi_char_search PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:272
parsing error 
extern int rl_vi_match PARAMS((int, int));
warning: parse error extern int rl_vi_match PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:273
parsing error 
extern int rl_vi_change_char PARAMS((int, int));
warning: parse error extern int rl_vi_change_char PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:274
parsing error 
extern int rl_vi_subst PARAMS((int, int));
warning: parse error extern int rl_vi_subst PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:275
parsing error 
extern int rl_vi_overstrike PARAMS((int, int));
warning: parse error extern int rl_vi_overstrike PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:276
parsing error 
extern int rl_vi_overstrike_delete PARAMS((int, int));
warning: parse error extern int rl_vi_overstrike_delete PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:277
parsing error 
extern int rl_vi_replace PARAMS((int, int));
warning: parse error extern int rl_vi_replace PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:278
parsing error 
extern int rl_vi_set_mark PARAMS((int, int));
warning: parse error extern int rl_vi_set_mark PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:279
parsing error 
extern int rl_vi_goto_mark PARAMS((int, int));
warning: parse error extern int rl_vi_goto_mark PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:280
parsing error 
extern int rl_vi_check PARAMS((void));
warning: parse error extern int rl_vi_check PARAMS((void));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:283
parsing error 
extern int rl_vi_domove PARAMS((int, int *));
warning: parse error extern int rl_vi_domove PARAMS((int, int *));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:284
parsing error 
extern int rl_vi_bracktype PARAMS((int));
warning: parse error extern int rl_vi_bracktype PARAMS((int));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:285
parsing error 
extern void rl_vi_start_inserting PARAMS((int, int, int));
warning: parse error extern void rl_vi_start_inserting PARAMS((int, int, int));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:287
parsing error 
extern int rl_vi_fWord PARAMS((int, int));
warning: parse error extern int rl_vi_fWord PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:290
parsing error 
extern int rl_vi_bWord PARAMS((int, int));
warning: parse error extern int rl_vi_bWord PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:291
parsing error 
extern int rl_vi_eWord PARAMS((int, int));
warning: parse error extern int rl_vi_eWord PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:292
parsing error 
extern int rl_vi_fword PARAMS((int, int));
warning: parse error extern int rl_vi_fword PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:293
parsing error 
extern int rl_vi_bword PARAMS((int, int));
warning: parse error extern int rl_vi_bword PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:294
parsing error 
extern int rl_vi_eword PARAMS((int, int));
warning: parse error extern int rl_vi_eword PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:295
parsing error 
extern char *readline PARAMS((const char *));
warning: parse error extern char *readline PARAMS((const char *));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:305
parsing error 
extern int rl_set_prompt PARAMS((const char *));
warning: parse error extern int rl_set_prompt PARAMS((const char *));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:307
parsing error 
extern int rl_expand_prompt PARAMS((char *));
warning: parse error extern int rl_expand_prompt PARAMS((char *));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:308
parsing error 
extern int rl_initialize PARAMS((void));
warning: parse error extern int rl_initialize PARAMS((void));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:310
parsing error 
extern int rl_discard_argument PARAMS((void));
warning: parse error extern int rl_discard_argument PARAMS((void));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:313
parsing error 
extern int rl_add_defun PARAMS((const char *, rl_command_func_t *, int));
warning: parse error extern int rl_add_defun PARAMS((const char *, rl_command_func_t *, int));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:316
parsing error 
extern int rl_bind_key PARAMS((int, rl_command_func_t *));
warning: parse error extern int rl_bind_key PARAMS((int, rl_command_func_t *));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:317
parsing error 
extern int rl_bind_key_in_map PARAMS((int, rl_command_func_t *, Keymap));
warning: parse error extern int rl_bind_key_in_map PARAMS((int, rl_command_func_t *, Keymap));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:318
parsing error 
extern int rl_unbind_key PARAMS((int));
warning: parse error extern int rl_unbind_key PARAMS((int));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:319
parsing error 
extern int rl_unbind_key_in_map PARAMS((int, Keymap));
warning: parse error extern int rl_unbind_key_in_map PARAMS((int, Keymap));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:320
parsing error 
extern int rl_bind_key_if_unbound PARAMS((int, rl_command_func_t *));
warning: parse error extern int rl_bind_key_if_unbound PARAMS((int, rl_command_func_t *));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:321
parsing error 
extern int rl_bind_key_if_unbound_in_map PARAMS((int, rl_command_func_t *, Keymap));
warning: parse error extern int rl_bind_key_if_unbound_in_map PARAMS((int, rl_command_func_t *, Keymap));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:322
parsing error 
extern int rl_unbind_function_in_map PARAMS((rl_command_func_t *, Keymap));
warning: parse error extern int rl_unbind_function_in_map PARAMS((rl_command_func_t *, Keymap));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:323
parsing error 
extern int rl_unbind_command_in_map PARAMS((const char *, Keymap));
warning: parse error extern int rl_unbind_command_in_map PARAMS((const char *, Keymap));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:324
parsing error 
extern int rl_bind_keyseq PARAMS((const char *, rl_command_func_t *));
warning: parse error extern int rl_bind_keyseq PARAMS((const char *, rl_command_func_t *));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:325
parsing error 
extern int rl_bind_keyseq_in_map PARAMS((const char *, rl_command_func_t *, Keymap));
warning: parse error extern int rl_bind_keyseq_in_map PARAMS((const char *, rl_command_func_t *, Keymap));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:326
parsing error 
extern int rl_bind_keyseq_if_unbound PARAMS((const char *, rl_command_func_t *));
warning: parse error extern int rl_bind_keyseq_if_unbound PARAMS((const char *, rl_command_func_t *));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:327
parsing error 
extern int rl_bind_keyseq_if_unbound_in_map PARAMS((const char *, rl_command_func_t *, Keymap));
warning: parse error extern int rl_bind_keyseq_if_unbound_in_map PARAMS((const char *, rl_command_func_t *, Keymap));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:328
parsing error 
extern int rl_generic_bind PARAMS((int, const char *, char *, Keymap));
warning: parse error extern int rl_generic_bind PARAMS((int, const char *, char *, Keymap));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:329
parsing error 
extern char *rl_variable_value PARAMS((const char *));
warning: parse error extern char *rl_variable_value PARAMS((const char *));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:331
parsing error 
extern int rl_variable_bind PARAMS((const char *, const char *));
warning: parse error extern int rl_variable_bind PARAMS((const char *, const char *));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:332
parsing error 
extern int rl_set_key PARAMS((const char *, rl_command_func_t *, Keymap));
warning: parse error extern int rl_set_key PARAMS((const char *, rl_command_func_t *, Keymap));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:335
parsing error 
extern int rl_macro_bind PARAMS((const char *, const char *, Keymap));
warning: parse error extern int rl_macro_bind PARAMS((const char *, const char *, Keymap));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:338
parsing error 
extern int rl_translate_keyseq PARAMS((const char *, char *, int *));
warning: parse error extern int rl_translate_keyseq PARAMS((const char *, char *, int *));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:341
parsing error 
extern char *rl_untranslate_keyseq PARAMS((int));
warning: parse error extern char *rl_untranslate_keyseq PARAMS((int));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:342
parsing error 
extern rl_command_func_t *rl_named_function PARAMS((const char *));
warning: parse error extern rl_command_func_t *rl_named_function PARAMS((const char *));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:344
parsing error 
extern rl_command_func_t *rl_function_of_keyseq PARAMS((const char *, Keymap, int *));
warning: parse error extern rl_command_func_t *rl_function_of_keyseq PARAMS((const char *, Keymap, int *));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:345
parsing error 
extern rl_command_func_t *rl_function_of_keyseq_len PARAMS((const char *, size_t, Keymap, int *));
warning: parse error extern rl_command_func_t *rl_function_of_keyseq_len PARAMS((const char *, size_t, Keymap, int *));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:346
parsing error 
extern void rl_list_funmap_names PARAMS((void));
warning: parse error extern void rl_list_funmap_names PARAMS((void));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:348
parsing error 
extern char **rl_invoking_keyseqs_in_map PARAMS((rl_command_func_t *, Keymap));
warning: parse error extern char **rl_invoking_keyseqs_in_map PARAMS((rl_command_func_t *, Keymap));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:349
parsing error 
extern char **rl_invoking_keyseqs PARAMS((rl_command_func_t *));
warning: parse error extern char **rl_invoking_keyseqs PARAMS((rl_command_func_t *));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:350
parsing error 
extern void rl_function_dumper PARAMS((int));
warning: parse error extern void rl_function_dumper PARAMS((int));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:352
parsing error 
extern void rl_macro_dumper PARAMS((int));
warning: parse error extern void rl_macro_dumper PARAMS((int));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:353
parsing error 
extern void rl_variable_dumper PARAMS((int));
warning: parse error extern void rl_variable_dumper PARAMS((int));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:354
parsing error 
extern int rl_read_init_file PARAMS((const char *));
warning: parse error extern int rl_read_init_file PARAMS((const char *));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:356
parsing error 
extern int rl_parse_and_bind PARAMS((char *));
warning: parse error extern int rl_parse_and_bind PARAMS((char *));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:357
parsing error 
extern Keymap rl_make_bare_keymap PARAMS((void));
warning: parse error extern Keymap rl_make_bare_keymap PARAMS((void));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:360
parsing error 
extern int rl_empty_keymap PARAMS((Keymap));
warning: parse error extern int rl_empty_keymap PARAMS((Keymap));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:361
parsing error 
extern Keymap rl_copy_keymap PARAMS((Keymap));
warning: parse error extern Keymap rl_copy_keymap PARAMS((Keymap));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:362
parsing error 
extern Keymap rl_make_keymap PARAMS((void));
warning: parse error extern Keymap rl_make_keymap PARAMS((void));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:363
parsing error 
extern void rl_discard_keymap PARAMS((Keymap));
warning: parse error extern void rl_discard_keymap PARAMS((Keymap));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:364
parsing error 
extern void rl_free_keymap PARAMS((Keymap));
warning: parse error extern void rl_free_keymap PARAMS((Keymap));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:365
parsing error 
extern Keymap rl_get_keymap_by_name PARAMS((const char *));
warning: parse error extern Keymap rl_get_keymap_by_name PARAMS((const char *));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:367
parsing error 
extern char *rl_get_keymap_name PARAMS((Keymap));
warning: parse error extern char *rl_get_keymap_name PARAMS((Keymap));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:368
parsing error 
extern void rl_set_keymap PARAMS((Keymap));
warning: parse error extern void rl_set_keymap PARAMS((Keymap));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:369
parsing error 
extern Keymap rl_get_keymap PARAMS((void));
warning: parse error extern Keymap rl_get_keymap PARAMS((void));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:370
parsing error 
extern int rl_set_keymap_name PARAMS((const char *, Keymap));
warning: parse error extern int rl_set_keymap_name PARAMS((const char *, Keymap));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:372
parsing error 
extern void rl_set_keymap_from_edit_mode PARAMS((void));
warning: parse error extern void rl_set_keymap_from_edit_mode PARAMS((void));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:375
parsing error 
extern char *rl_get_keymap_name_from_edit_mode PARAMS((void));
warning: parse error extern char *rl_get_keymap_name_from_edit_mode PARAMS((void));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:376
parsing error 
extern int rl_add_funmap_entry PARAMS((const char *, rl_command_func_t *));
warning: parse error extern int rl_add_funmap_entry PARAMS((const char *, rl_command_func_t *));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:379
parsing error 
extern const char **rl_funmap_names PARAMS((void));
warning: parse error extern const char **rl_funmap_names PARAMS((void));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:380
parsing error 
extern void rl_initialize_funmap PARAMS((void));
warning: parse error extern void rl_initialize_funmap PARAMS((void));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:383
parsing error 
extern void rl_push_macro_input PARAMS((char *));
warning: parse error extern void rl_push_macro_input PARAMS((char *));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:386
parsing error 
extern void rl_add_undo PARAMS((enum undo_code, int, int, char *));
warning: parse error extern void rl_add_undo PARAMS((enum undo_code, int, int, char *));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:389
parsing error 
extern void rl_free_undo_list PARAMS((void));
warning: parse error extern void rl_free_undo_list PARAMS((void));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:390
parsing error 
extern int rl_do_undo PARAMS((void));
warning: parse error extern int rl_do_undo PARAMS((void));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:391
parsing error 
extern int rl_begin_undo_group PARAMS((void));
warning: parse error extern int rl_begin_undo_group PARAMS((void));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:392
parsing error 
extern int rl_end_undo_group PARAMS((void));
warning: parse error extern int rl_end_undo_group PARAMS((void));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:393
parsing error 
extern int rl_modifying PARAMS((int, int));
warning: parse error extern int rl_modifying PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:394
parsing error 
extern void rl_redisplay PARAMS((void));
warning: parse error extern void rl_redisplay PARAMS((void));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:397
parsing error 
extern int rl_on_new_line PARAMS((void));
warning: parse error extern int rl_on_new_line PARAMS((void));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:398
parsing error 
extern int rl_on_new_line_with_prompt PARAMS((void));
warning: parse error extern int rl_on_new_line_with_prompt PARAMS((void));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:399
parsing error 
extern int rl_forced_update_display PARAMS((void));
warning: parse error extern int rl_forced_update_display PARAMS((void));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:400
parsing error 
extern int rl_clear_visible_line PARAMS((void));
warning: parse error extern int rl_clear_visible_line PARAMS((void));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:401
parsing error 
extern int rl_clear_message PARAMS((void));
warning: parse error extern int rl_clear_message PARAMS((void));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:402
parsing error 
extern int rl_reset_line_state PARAMS((void));
warning: parse error extern int rl_reset_line_state PARAMS((void));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:403
parsing error 
extern int rl_crlf PARAMS((void));
warning: parse error extern int rl_crlf PARAMS((void));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:404
parsing error 
extern void rl_keep_mark_active PARAMS((void));
warning: parse error extern void rl_keep_mark_active PARAMS((void));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:408
parsing error 
extern void rl_activate_mark PARAMS((void));
warning: parse error extern void rl_activate_mark PARAMS((void));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:410
parsing error 
extern void rl_deactivate_mark PARAMS((void));
warning: parse error extern void rl_deactivate_mark PARAMS((void));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:411
parsing error 
extern int rl_mark_active_p PARAMS((void));
warning: parse error extern int rl_mark_active_p PARAMS((void));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:412
parsing error 
extern int rl_show_char PARAMS((int));
warning: parse error extern int rl_show_char PARAMS((int));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:420
parsing error 
extern int rl_character_len PARAMS((int, int));
warning: parse error extern int rl_character_len PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:423
parsing error 
extern void rl_redraw_prompt_last_line PARAMS((void));
warning: parse error extern void rl_redraw_prompt_last_line PARAMS((void));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:424
parsing error 
extern void rl_save_prompt PARAMS((void));
warning: parse error extern void rl_save_prompt PARAMS((void));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:427
parsing error 
extern void rl_restore_prompt PARAMS((void));
warning: parse error extern void rl_restore_prompt PARAMS((void));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:428
parsing error 
extern void rl_replace_line PARAMS((const char *, int));
warning: parse error extern void rl_replace_line PARAMS((const char *, int));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:431
parsing error 
extern int rl_insert_text PARAMS((const char *));
warning: parse error extern int rl_insert_text PARAMS((const char *));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:432
parsing error 
extern int rl_delete_text PARAMS((int, int));
warning: parse error extern int rl_delete_text PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:433
parsing error 
extern int rl_kill_text PARAMS((int, int));
warning: parse error extern int rl_kill_text PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:434
parsing error 
extern char *rl_copy_text PARAMS((int, int));
warning: parse error extern char *rl_copy_text PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:435
parsing error 
extern void rl_prep_terminal PARAMS((int));
warning: parse error extern void rl_prep_terminal PARAMS((int));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:438
parsing error 
extern void rl_deprep_terminal PARAMS((void));
warning: parse error extern void rl_deprep_terminal PARAMS((void));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:439
parsing error 
extern void rl_tty_set_default_bindings PARAMS((Keymap));
warning: parse error extern void rl_tty_set_default_bindings PARAMS((Keymap));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:440
parsing error 
extern void rl_tty_unset_default_bindings PARAMS((Keymap));
warning: parse error extern void rl_tty_unset_default_bindings PARAMS((Keymap));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:441
parsing error 
extern int rl_tty_set_echoing PARAMS((int));
warning: parse error extern int rl_tty_set_echoing PARAMS((int));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:443
parsing error 
extern int rl_reset_terminal PARAMS((const char *));
warning: parse error extern int rl_reset_terminal PARAMS((const char *));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:444
parsing error 
extern void rl_resize_terminal PARAMS((void));
warning: parse error extern void rl_resize_terminal PARAMS((void));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:445
parsing error 
extern void rl_set_screen_size PARAMS((int, int));
warning: parse error extern void rl_set_screen_size PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:446
parsing error 
extern void rl_get_screen_size PARAMS((int *, int *));
warning: parse error extern void rl_get_screen_size PARAMS((int *, int *));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:447
parsing error 
extern void rl_reset_screen_size PARAMS((void));
warning: parse error extern void rl_reset_screen_size PARAMS((void));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:448
parsing error 
extern char *rl_get_termcap PARAMS((const char *));
warning: parse error extern char *rl_get_termcap PARAMS((const char *));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:450
parsing error 
extern int rl_stuff_char PARAMS((int));
warning: parse error extern int rl_stuff_char PARAMS((int));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:453
parsing error 
extern int rl_execute_next PARAMS((int));
warning: parse error extern int rl_execute_next PARAMS((int));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:454
parsing error 
extern int rl_clear_pending_input PARAMS((void));
warning: parse error extern int rl_clear_pending_input PARAMS((void));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:455
parsing error 
extern int rl_read_key PARAMS((void));
warning: parse error extern int rl_read_key PARAMS((void));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:456
parsing error 
extern int rl_getc PARAMS((FILE *));
warning: parse error extern int rl_getc PARAMS((FILE *));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:457
parsing error 
extern int rl_set_keyboard_input_timeout PARAMS((int));
warning: parse error extern int rl_set_keyboard_input_timeout PARAMS((int));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:458
parsing error 
extern void rl_extend_line_buffer PARAMS((int));
warning: parse error extern void rl_extend_line_buffer PARAMS((int));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:461
parsing error 
extern int rl_ding PARAMS((void));
warning: parse error extern int rl_ding PARAMS((void));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:462
parsing error 
extern int rl_alphabetic PARAMS((int));
warning: parse error extern int rl_alphabetic PARAMS((int));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:463
parsing error 
extern void rl_free PARAMS((void *));
warning: parse error extern void rl_free PARAMS((void *));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:464
parsing error 
extern int rl_set_signals PARAMS((void));
warning: parse error extern int rl_set_signals PARAMS((void));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:467
parsing error 
extern int rl_clear_signals PARAMS((void));
warning: parse error extern int rl_clear_signals PARAMS((void));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:468
parsing error 
extern void rl_cleanup_after_signal PARAMS((void));
warning: parse error extern void rl_cleanup_after_signal PARAMS((void));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:469
parsing error 
extern void rl_reset_after_signal PARAMS((void));
warning: parse error extern void rl_reset_after_signal PARAMS((void));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:470
parsing error 
extern void rl_free_line_state PARAMS((void));
warning: parse error extern void rl_free_line_state PARAMS((void));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:471
parsing error 
extern int rl_pending_signal PARAMS((void));
warning: parse error extern int rl_pending_signal PARAMS((void));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:473
parsing error 
extern void rl_check_signals PARAMS((void));
warning: parse error extern void rl_check_signals PARAMS((void));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:474
parsing error 
extern void rl_echo_signal_char PARAMS((int));
warning: parse error extern void rl_echo_signal_char PARAMS((int));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:476
parsing error 
extern int rl_set_paren_blink_timeout PARAMS((int));
warning: parse error extern int rl_set_paren_blink_timeout PARAMS((int));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:478
parsing error 
extern void rl_clear_history PARAMS((void));
warning: parse error extern void rl_clear_history PARAMS((void));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:482
parsing error 
extern int rl_maybe_save_line PARAMS((void));
warning: parse error extern int rl_maybe_save_line PARAMS((void));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:485
parsing error 
extern int rl_maybe_unsave_line PARAMS((void));
warning: parse error extern int rl_maybe_unsave_line PARAMS((void));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:486
parsing error 
extern int rl_maybe_replace_line PARAMS((void));
warning: parse error extern int rl_maybe_replace_line PARAMS((void));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:487
parsing error 
extern int rl_complete_internal PARAMS((int));
warning: parse error extern int rl_complete_internal PARAMS((int));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:490
parsing error 
extern void rl_display_match_list PARAMS((char **, int, int));
warning: parse error extern void rl_display_match_list PARAMS((char **, int, int));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:491
parsing error 
extern char **rl_completion_matches PARAMS((const char *, rl_compentry_func_t *));
warning: parse error extern char **rl_completion_matches PARAMS((const char *, rl_compentry_func_t *));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:493
parsing error 
extern char *rl_username_completion_function PARAMS((const char *, int));
warning: parse error extern char *rl_username_completion_function PARAMS((const char *, int));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:494
parsing error 
extern char *rl_filename_completion_function PARAMS((const char *, int));
warning: parse error extern char *rl_filename_completion_function PARAMS((const char *, int));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:495
parsing error 
extern int rl_completion_mode PARAMS((rl_command_func_t *));
warning: parse error extern int rl_completion_mode PARAMS((rl_command_func_t *));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:497
parsing error 
extern void free_undo_list PARAMS((void));
warning: parse error extern void free_undo_list PARAMS((void));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:501
parsing error 
extern int maybe_save_line PARAMS((void));
warning: parse error extern int maybe_save_line PARAMS((void));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:502
parsing error 
extern int maybe_unsave_line PARAMS((void));
warning: parse error extern int maybe_unsave_line PARAMS((void));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:503
parsing error 
extern int maybe_replace_line PARAMS((void));
warning: parse error extern int maybe_replace_line PARAMS((void));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:504
parsing error 
extern int ding PARAMS((void));
warning: parse error extern int ding PARAMS((void));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:506
parsing error 
extern int alphabetic PARAMS((int));
warning: parse error extern int alphabetic PARAMS((int));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:507
parsing error 
extern int crlf PARAMS((void));
warning: parse error extern int crlf PARAMS((void));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:508
parsing error 
extern char **completion_matches PARAMS((char *, rl_compentry_func_t *));
warning: parse error extern char **completion_matches PARAMS((char *, rl_compentry_func_t *));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:510
parsing error 
extern char *username_completion_function PARAMS((const char *, int));
warning: parse error extern char *username_completion_function PARAMS((const char *, int));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:511
parsing error 
extern char *filename_completion_function PARAMS((const char *, int));
warning: parse error extern char *filename_completion_function PARAMS((const char *, int));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:512
parsing error 
extern int rl_save_state PARAMS((struct readline_state *));
warning: parse error extern int rl_save_state PARAMS((struct readline_state *));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:971
parsing error 
extern int rl_restore_state PARAMS((struct readline_state *));
warning: parse error extern int rl_restore_state PARAMS((struct readline_state *));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h:972
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\history.h...skip
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\rlmbutil.h...
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\rlstdc.h...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\glob\glob.h...skip
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bracecomp.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashansi.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\shmbutil.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\shell.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h...skip
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\braces.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashansi.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashintl.h...skip
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\typemax.h...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\general.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\shmbutil.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\chartypes.h...skip
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\bashgetopt.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashansi.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\chartypes.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\shell.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\common.h...skip
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\bashgetopt.h...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\stdc.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\bashgetopt.c:50
parsing error 
{
	register int c;
	register char *cp;
	int	plus;	/* nonzero means to handle +option */
	static char errstr[3] = { '-', '\0', '\0' };

	plus = *opts == '+';
	if (plus)
		opts++;

	if (list == 0) {
		list_optarg = (char *)NULL;
		loptend = (WORD_LIST *)NULL;	/* No non-option arguments */
		return -1;
	}

	if (list != lhead || lhead == 0) {
		/* Hmmm.... called with a different word list.  Reset. */
		sp = 1;
		lcurrent = lhead = list;
		loptend = (WORD_LIST *)NULL;
	}

	if (sp == 1) {
		if (lcurrent == 0 || NOTOPT(lcurrent->word->word)) {
		    	lhead = (WORD_LIST *)NULL;
		    	loptend = lcurrent;
			return(-1);
		} else if (ISHELP (lcurrent->word->word)) {
			lhead = (WORD_LIST *)NULL;
			loptend = lcurrent;
			return (GETOPT_HELP);
		} else if (lcurrent->word->word[0] == '-' &&
			   lcurrent->word->word[1] == '-' &&
			   lcurrent->word->word[2] == 0) {
			lhead = (WORD_LIST *)NULL;
			loptend = lcurrent->next;
			return(-1);
		}
		errstr[0] = list_opttype = lcurrent->word->word[0];
	}

	list_optopt = c = lcurrent->word->word[sp];

	if (c == ':' || (cp = strchr(opts, c)) == NULL) {
		errstr[1] = c;
		sh_invalidopt (errstr);		
		if (lcurrent->word->word[++sp] == '\0') {
			lcurrent = lcurrent->next;
			sp = 1;
		}
		list_optarg = NULL;
		if (lcurrent)
			loptend = lcurrent->next;
		return('?');
	}

	if (*++cp == ':' || *cp == ';') {
		/* `:': Option requires an argument. */
		/* `;': option argument may be missing */
		/* We allow -l2 as equivalent to -l 2 */
		if (lcurrent->word->word[sp+1]) {
			list_optarg = lcurrent->word->word + sp + 1;
			lcurrent = lcurrent->next;
		/* If the specifier is `;', don't set optarg if the next
		   argument looks like another option. */
#if 0
		} else if (lcurrent->next && (*cp == ':' || lcurrent->next->word->word[0] != '-')) {
#else
		} else if (lcurrent->next && (*cp == ':' || NOTOPT(lcurrent->next->word->word))) {
#endif
			lcurrent = lcurrent->next;
			list_optarg = lcurrent->word->word;
			lcurrent = lcurrent->next;
		} else if (*cp == ';') {
			list_optarg = (char *)NULL;
			lcurrent = lcurrent->next;
		} else {	/* lcurrent->next == NULL */
			errstr[1] = c;
			sh_needarg (errstr);
			sp = 1;
			list_optarg = (char *)NULL;
			return('?');
		}
		sp = 1;
	} else if (*cp == '#') {
		/* option requires a numeric argument */
		if (lcurrent->word->word[sp+1]) {
			if (DIGIT(lcurrent->word->word[sp+1])) {
				list_optarg = lcurrent->word->word + sp + 1;
				lcurrent = lcurrent->next;
			} else
				list_optarg = (char *)NULL;
		} else {
			if (lcurrent->next && legal_number(lcurrent->next->word->word, (intmax_t *)0)) {
				lcurrent = lcurrent->next;
				list_optarg = lcurrent->word->word;
				lcurrent = lcurrent->next;
			} else {
				errstr[1] = c;
				sh_neednumarg (errstr);
				sp = 1;
				list_optarg = (char *)NULL;
				return ('?');
			}
		}

	} else {
		/* No argument, just return the option. */
		if (lcurrent->word->word[++sp] == '\0') {
			sp = 1;
			lcurrent = lcurrent->next;
		}
		list_optarg = (char *)NULL;
	}

	return(c);
}
warning: parse error {
	register int c;
	register char *cp;
	int	plus;	/* nonzero means to handle +option */
	static char errstr[3] = { '-', '\0', '\0' };

	plus = *opts == '+';
	if (plus)
		opts++;

	if (list == 0) {
		list_optarg = (char *)NULL;
		loptend = (WORD_LIST *)NULL;	/* No non-option arguments */
		return -1;
	}

	if (list != lhead || lhead == 0) {
		/* Hmmm.... called with a different word list.  Reset. */
		sp = 1;
		lcurrent = lhead = list;
		loptend = (WORD_LIST *)NULL;
	}

	if (sp == 1) {
		if (lcurrent == 0 || NOTOPT(lcurrent->word->word)) {
		    	lhead = (WORD_LIST *)NULL;
		    	loptend = lcurrent;
			return(-1);
		} else if (ISHELP (lcurrent->word->word)) {
			lhead = (WORD_LIST *)NULL;
			loptend = lcurrent;
			return (GETOPT_HELP);
		} else if (lcurrent->word->word[0] == '-' &&
			   lcurrent->word->word[1] == '-' &&
			   lcurrent->word->word[2] == 0) {
			lhead = (WORD_LIST *)NULL;
			loptend = lcurrent->next;
			return(-1);
		}
		errstr[0] = list_opttype = lcurrent->word->word[0];
	}

	list_optopt = c = lcurrent->word->word[sp];

	if (c == ':' || (cp = strchr(opts, c)) == NULL) {
		errstr[1] = c;
		sh_invalidopt (errstr);		
		if (lcurrent->word->word[++sp] == '\0') {
			lcurrent = lcurrent->next;
			sp = 1;
		}
		list_optarg = NULL;
		if (lcurrent)
			loptend = lcurrent->next;
		return('?');
	}

	if (*++cp == ':' || *cp == ';') {
		/* `:': Option requires an argument. */
		/* `;': option argument may be missing */
		/* We allow -l2 as equivalent to -l 2 */
		if (lcurrent->word->word[sp+1]) {
			list_optarg = lcurrent->word->word + sp + 1;
			lcurrent = lcurrent->next;
		/* If the specifier is `;', don't set optarg if the next
		   argument looks like another option. */
#if 0
		} else if (lcurrent->next && (*cp == ':' || lcurrent->next->word->word[0] != '-')) {
#else
		} else if (lcurrent->next && (*cp == ':' || NOTOPT(lcurrent->next->word->word))) {
#endif
			lcurrent = lcurrent->next;
			list_optarg = lcurrent->word->word;
			lcurrent = lcurrent->next;
		} else if (*cp == ';') {
			list_optarg = (char *)NULL;
			lcurrent = lcurrent->next;
		} else {	/* lcurrent->next == NULL */
			errstr[1] = c;
			sh_needarg (errstr);
			sp = 1;
			list_optarg = (char *)NULL;
			return('?');
		}
		sp = 1;
	} else if (*cp == '#') {
		/* option requires a numeric argument */
		if (lcurrent->word->word[sp+1]) {
			if (DIGIT(lcurrent->word->word[sp+1])) {
				list_optarg = lcurrent->word->word + sp + 1;
				lcurrent = lcurrent->next;
			} else
				list_optarg = (char *)NULL;
		} else {
			if (lcurrent->next && legal_number(lcurrent->next->word->word, (intmax_t *)0)) {
				lcurrent = lcurrent->next;
				list_optarg = lcurrent->word->word;
				lcurrent = lcurrent->next;
			} else {
				errstr[1] = c;
				sh_neednumarg (errstr);
				sp = 1;
				list_optarg = (char *)NULL;
				return ('?');
			}
		}

	} else {
		/* No argument, just return the option. */
		if (lcurrent->word->word[++sp] == '\0') {
			sp = 1;
			lcurrent = lcurrent->next;
		}
		list_optarg = (char *)NULL;
	}

	return(c);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\bashgetopt.c:53
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\common.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\chartypes.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashtypes.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\posixstat.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashansi.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashintl.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\shell.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\maxpath.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\flags.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\parser.h...skip
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\jobs.h...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\quit.h...skip
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\siglist.h...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\stdc.h...skip
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\posixwait.h...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\input.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\execute_cmd.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\trap.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\bashgetopt.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\common.h...skip
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\tilde\tilde.h...
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\common.c:107
parsing error 
va_dcl
#endif
{
  va_list args;

  builtin_error_prolog ();

  SH_VA_START (args, format);

  vfprintf (stderr, format, args);
  va_end (args);
  fprintf (stderr, "\n");
}
warning: parse error va_dcl
#endif
{
  va_list args;

  builtin_error_prolog ();

  SH_VA_START (args, format);

  vfprintf (stderr, format, args);
  va_end (args);
  fprintf (stderr, "\n");
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\common.c:108
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\common.c:127
parsing error 
va_dcl
#endif
{
  va_list args;

  builtin_error_prolog ();
  fprintf (stderr, _("warning: "));

  SH_VA_START (args, format);

  vfprintf (stderr, format, args);
  va_end (args);
  fprintf (stderr, "\n");
}
warning: parse error va_dcl
#endif
{
  va_list args;

  builtin_error_prolog ();
  fprintf (stderr, _("warning: "));

  SH_VA_START (args, format);

  vfprintf (stderr, format, args);
  va_end (args);
  fprintf (stderr, "\n");
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\common.c:128
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\common.c:156
parsing error 
{
  if (list)
    {
      builtin_error (_("too many arguments"));
      top_level_cleanup ();
      jump_to_top_level (DISCARD);
    }
}
warning: parse error {
  if (list)
    {
      builtin_error (_("too many arguments"));
      top_level_cleanup ();
      jump_to_top_level (DISCARD);
    }
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\common.c:158
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\common.c:170
parsing error 
{
  int opt;

  reset_internal_getopt ();
  if ((opt = internal_getopt (list, "")) != -1)
    {
      if (opt == GETOPT_HELP)
	{
	  builtin_help ();
	  return (2);
	}
      builtin_usage ();
      return (1);
    }
  return (0);
}
warning: parse error {
  int opt;

  reset_internal_getopt ();
  if ((opt = internal_getopt (list, "")) != -1)
    {
      if (opt == GETOPT_HELP)
	{
	  builtin_help ();
	  return (2);
	}
      builtin_usage ();
      return (1);
    }
  return (0);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\common.c:172
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\common.c:190
parsing error 
{
  builtin_error (_("%s: option requires an argument"), s);
}
warning: parse error {
  builtin_error (_("%s: option requires an argument"), s);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\common.c:192
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\common.c:197
parsing error 
{
  builtin_error (_("%s: numeric argument required"), s);
}
warning: parse error {
  builtin_error (_("%s: numeric argument required"), s);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\common.c:199
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\common.c:204
parsing error 
{
  builtin_error (_("%s: not found"), s);
}
warning: parse error {
  builtin_error (_("%s: not found"), s);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\common.c:206
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\common.c:213
parsing error 
{
  builtin_error (_("%s: invalid option"), s);
}
warning: parse error {
  builtin_error (_("%s: invalid option"), s);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\common.c:215
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\common.c:220
parsing error 
{
  builtin_error (_("%s: invalid option name"), s);
}
warning: parse error {
  builtin_error (_("%s: invalid option name"), s);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\common.c:222
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\common.c:227
parsing error 
{
  builtin_error (_("`%s': not a valid identifier"), s);
}
warning: parse error {
  builtin_error (_("`%s': not a valid identifier"), s);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\common.c:229
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\common.c:234
parsing error 
{
  char *msg;

  if (*s == '0' && isdigit ((unsigned char)s[1]))
    msg = _("invalid octal number");
  else if (*s == '0' && s[1] == 'x')
    msg = _("invalid hex number");
  else
    msg = _("invalid number");
  builtin_error ("%s: %s", s, msg);
}
warning: parse error {
  char *msg;

  if (*s == '0' && isdigit ((unsigned char)s[1]))
    msg = _("invalid octal number");
  else if (*s == '0' && s[1] == 'x')
    msg = _("invalid hex number");
  else
    msg = _("invalid number");
  builtin_error ("%s: %s", s, msg);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\common.c:236
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\common.c:249
parsing error 
{
  builtin_error (_("%s: invalid signal specification"), s);
}
warning: parse error {
  builtin_error (_("%s: invalid signal specification"), s);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\common.c:251
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\common.c:256
parsing error 
{
  builtin_error (_("`%s': not a pid or valid job spec"), s);
}
warning: parse error {
  builtin_error (_("`%s': not a pid or valid job spec"), s);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\common.c:258
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\common.c:264
parsing error 
{
  builtin_error (_("%s: readonly variable"), s);
}
warning: parse error {
  builtin_error (_("%s: readonly variable"), s);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\common.c:265
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\common.c:270
parsing error 
{
  if (s)
    builtin_error (_("%s: %s out of range"), s, desc ? desc : _("argument"));
  else
    builtin_error (_("%s out of range"), desc ? desc : _("argument"));
}
warning: parse error {
  if (s)
    builtin_error (_("%s: %s out of range"), s, desc ? desc : _("argument"));
  else
    builtin_error (_("%s out of range"), desc ? desc : _("argument"));
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\common.c:272
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\common.c:311
parsing error 
{
  builtin_error (_("%s: not a shell builtin"), s);
}
warning: parse error {
  builtin_error (_("%s: not a shell builtin"), s);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\common.c:313
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\common.c:327
parsing error 
{
  if (set)
    builtin_error (_("error setting terminal attributes: %s"), strerror (errno));
  else
    builtin_error (_("error getting terminal attributes: %s"), strerror (errno));
}
warning: parse error {
  if (set)
    builtin_error (_("error setting terminal attributes: %s"), strerror (errno));
  else
    builtin_error (_("error getting terminal attributes: %s"), strerror (errno));
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\common.c:329
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\common.c:337
parsing error 
{
  QUIT;
  fflush (stdout);
  QUIT;
  if (ferror (stdout))
    {
      sh_wrerror ();
      fpurge (stdout);
      clearerr (stdout);
      return (EXECUTION_FAILURE);
    }
  return (s);
}
warning: parse error {
  QUIT;
  fflush (stdout);
  QUIT;
  if (ferror (stdout))
    {
      sh_wrerror ();
      fpurge (stdout);
      clearerr (stdout);
      return (EXECUTION_FAILURE);
    }
  return (s);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\common.c:339
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\common.c:363
parsing error 
{
  char **argv;

  argv = strvec_from_word_list (list, 0, 1, ip);
  argv[0] = this_command_name;
  return argv;
}
warning: parse error {
  char **argv;

  argv = strvec_from_word_list (list, 0, 1, ip);
  argv[0] = this_command_name;
  return argv;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\common.c:366
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\common.c:379
parsing error 
{
  register int i;

  posparam_count = 0;

  for (i = 1; i < 10; i++)
    {
      if ((destructive || list) && dollar_vars[i])
	{
	  free (dollar_vars[i]);
	  dollar_vars[i] = (char *)NULL;
	}

      if (list)
	{
	  dollar_vars[posparam_count = i] = savestring (list->word->word);
	  list = list->next;
	}
    }

  /* If arguments remain, assign them to REST_OF_ARGS.
     Note that copy_word_list (NULL) returns NULL, and
     that dispose_words (NULL) does nothing. */
  if (destructive || list)
    {
      dispose_words (rest_of_args);
      rest_of_args = copy_word_list (list);
      posparam_count += list_length (list);
    }

  if (destructive)
    set_dollar_vars_changed ();

  invalidate_cached_quoted_dollar_at ();
}
warning: parse error {
  register int i;

  posparam_count = 0;

  for (i = 1; i < 10; i++)
    {
      if ((destructive || list) && dollar_vars[i])
	{
	  free (dollar_vars[i]);
	  dollar_vars[i] = (char *)NULL;
	}

      if (list)
	{
	  dollar_vars[posparam_count = i] = savestring (list->word->word);
	  list = list->next;
	}
    }

  /* If arguments remain, assign them to REST_OF_ARGS.
     Note that copy_word_list (NULL) returns NULL, and
     that dispose_words (NULL) does nothing. */
  if (destructive || list)
    {
      dispose_words (rest_of_args);
      rest_of_args = copy_word_list (list);
      posparam_count += list_length (list);
    }

  if (destructive)
    set_dollar_vars_changed ();

  invalidate_cached_quoted_dollar_at ();
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\common.c:382
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\common.c:419
parsing error 
{
  WORD_LIST *temp;
  int count;

  if (times <= 0)		/* caller should check */
    return;

  while (times-- > 0)
    {
      if (dollar_vars[1])
	free (dollar_vars[1]);

      for (count = 1; count < 9; count++)
	dollar_vars[count] = dollar_vars[count + 1];

      if (rest_of_args)
	{
	  temp = rest_of_args;
	  dollar_vars[9] = savestring (temp->word->word);
	  rest_of_args = rest_of_args->next;
	  temp->next = (WORD_LIST *)NULL;
	  dispose_words (temp);
	}
      else
	dollar_vars[9] = (char *)NULL;

      posparam_count--;
    }
}
warning: parse error {
  WORD_LIST *temp;
  int count;

  if (times <= 0)		/* caller should check */
    return;

  while (times-- > 0)
    {
      if (dollar_vars[1])
	free (dollar_vars[1]);

      for (count = 1; count < 9; count++)
	dollar_vars[count] = dollar_vars[count + 1];

      if (rest_of_args)
	{
	  temp = rest_of_args;
	  dollar_vars[9] = savestring (temp->word->word);
	  rest_of_args = rest_of_args->next;
	  temp->next = (WORD_LIST *)NULL;
	  dispose_words (temp);
	}
      else
	dollar_vars[9] = (char *)NULL;

      posparam_count--;
    }
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\common.c:421
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\common.c:511
parsing error 
{
  char *arg;

  if (count)
    *count = 1;

  if (list && list->word && ISOPTION (list->word->word, '-'))
    list = list->next;

  if (list)
    {
      arg = list->word->word;
      if (arg == 0 || (legal_number (arg, count) == 0))
	{
	  sh_neednumarg (list->word->word ? list->word->word : "`'");
	  if (fatal == 0)
	    return 0;
	  else if (fatal == 1)		/* fatal == 1; abort */
	    throw_to_top_level ();
	  else				/* fatal == 2; discard current command */
	    {
	      top_level_cleanup ();
	      jump_to_top_level (DISCARD);
	    }
	}
      no_args (list->next);
    }

  return (1);
}
warning: parse error {
  char *arg;

  if (count)
    *count = 1;

  if (list && list->word && ISOPTION (list->word->word, '-'))
    list = list->next;

  if (list)
    {
      arg = list->word->word;
      if (arg == 0 || (legal_number (arg, count) == 0))
	{
	  sh_neednumarg (list->word->word ? list->word->word : "`'");
	  if (fatal == 0)
	    return 0;
	  else if (fatal == 1)		/* fatal == 1; abort */
	    throw_to_top_level ();
	  else				/* fatal == 2; discard current command */
	    {
	      top_level_cleanup ();
	      jump_to_top_level (DISCARD);
	    }
	}
      no_args (list->next);
    }

  return (1);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\common.c:515
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\common.c:548
parsing error 
{
  int status;
  intmax_t sval;
  char *arg;

  if (list && list->word && ISOPTION (list->word->word, '-'))
    list = list->next;

  if (list == 0)
    {
      /* If we're not running the DEBUG trap, the return builtin, when not
	 given any arguments, uses the value of $? before the trap ran.  If
	 given an argument, return uses it.  This means that the trap can't
	 change $?.  The DEBUG trap gets to change $?, though, since that is
	 part of its reason for existing, and because the extended debug mode
	 does things with the return value. */
      if (this_shell_builtin == return_builtin && running_trap > 0 && running_trap != DEBUG_TRAP+1)
	return (trap_saved_exit_value);
      return (last_command_exit_value);
    }

  arg = list->word->word;
  if (arg == 0 || legal_number (arg, &sval) == 0)
    {
      sh_neednumarg (list->word->word ? list->word->word : "`'");
      return EX_BADUSAGE;
    }
  no_args (list->next);

  status = sval & 255;
  return status;
}
warning: parse error {
  int status;
  intmax_t sval;
  char *arg;

  if (list && list->word && ISOPTION (list->word->word, '-'))
    list = list->next;

  if (list == 0)
    {
      /* If we're not running the DEBUG trap, the return builtin, when not
	 given any arguments, uses the value of $? before the trap ran.  If
	 given an argument, return uses it.  This means that the trap can't
	 change $?.  The DEBUG trap gets to change $?, though, since that is
	 part of its reason for existing, and because the extended debug mode
	 does things with the return value. */
      if (this_shell_builtin == return_builtin && running_trap > 0 && running_trap != DEBUG_TRAP+1)
	return (trap_saved_exit_value);
      return (last_command_exit_value);
    }

  arg = list->word->word;
  if (arg == 0 || legal_number (arg, &sval) == 0)
    {
      sh_neednumarg (list->word->word ? list->word->word : "`'");
      return EX_BADUSAGE;
    }
  no_args (list->next);

  status = sval & 255;
  return status;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\common.c:550
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\common.c:586
parsing error 
{
  int result, digits;

  result = digits = 0;
  while (*string && ISOCTAL (*string))
    {
      digits++;
      result = (result * 8) + (*string++ - '0');
      if (result > 07777)
	return -1;
    }

  if (digits == 0 || *string)
    result = -1;

  return (result);
}
warning: parse error {
  int result, digits;

  result = digits = 0;
  while (*string && ISOCTAL (*string))
    {
      digits++;
      result = (result * 8) + (*string++ - '0');
      if (result > 07777)
	return -1;
    }

  if (digits == 0 || *string)
    result = -1;

  return (result);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\common.c:588
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\common.c:617
parsing error 
{
  if (no_symbolic_links)
    {
      FREE (the_current_working_directory);
      the_current_working_directory = (char *)NULL;
    }

  if (the_current_working_directory == 0)
    {
#if defined (GETCWD_BROKEN)
      the_current_working_directory = getcwd (0, PATH_MAX);
#else
      the_current_working_directory = getcwd (0, 0);
#endif
      if (the_current_working_directory == 0)
	{
	  fprintf (stderr, _("%s: error retrieving current directory: %s: %s\n"),
		   (for_whom && *for_whom) ? for_whom : get_name_for_error (),
		   _(bash_getcwd_errstr), strerror (errno));
	  return (char *)NULL;
	}
    }

  return (savestring (the_current_working_directory));
}
warning: parse error {
  if (no_symbolic_links)
    {
      FREE (the_current_working_directory);
      the_current_working_directory = (char *)NULL;
    }

  if (the_current_working_directory == 0)
    {
#if defined (GETCWD_BROKEN)
      the_current_working_directory = getcwd (0, PATH_MAX);
#else
      the_current_working_directory = getcwd (0, 0);
#endif
      if (the_current_working_directory == 0)
	{
	  fprintf (stderr, _("%s: error retrieving current directory: %s: %s\n"),
		   (for_whom && *for_whom) ? for_whom : get_name_for_error (),
		   _(bash_getcwd_errstr), strerror (errno));
	  return (char *)NULL;
	}
    }

  return (savestring (the_current_working_directory));
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\common.c:619
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\common.c:647
parsing error 
{
  FREE (the_current_working_directory);
  the_current_working_directory = savestring (name);
}
warning: parse error {
  FREE (the_current_working_directory);
  the_current_working_directory = savestring (name);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\common.c:649
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\common.c:766
parsing error 
{
  register int i, column;
  char *name;
  int result, signum, dflags;
  intmax_t lsignum;

  result = EXECUTION_SUCCESS;
  if (!list)
    {
      for (i = 1, column = 0; i < NSIG; i++)
	{
	  name = signal_name (i);
	  if (STREQN (name, "SIGJUNK", 7) || STREQN (name, "Unknown", 7))
	    continue;

	  if (posixly_correct && !forcecols)
	    {
	      /* This is for the kill builtin.  POSIX.2 says the signal names
		 are displayed without the `SIG' prefix. */
	      if (STREQN (name, "SIG", 3))
		name += 3;
	      printf ("%s%s", name, (i == NSIG - 1) ? "" : " ");
	    }
	  else
	    {
	      printf ("%2d) %s", i, name);

	      if (++column < 5)
		printf ("\t");
	      else
		{
		  printf ("\n");
		  column = 0;
		}
	    }
	}

      if ((posixly_correct && !forcecols) || column != 0)
	printf ("\n");
      return result;
    }

  /* List individual signal names or numbers. */
  while (list)
    {
      if (legal_number (list->word->word, &lsignum))
	{
	  /* This is specified by Posix.2 so that exit statuses can be
	     mapped into signal numbers. */
	  if (lsignum > 128)
	    lsignum -= 128;
	  if (lsignum < 0 || lsignum >= NSIG)
	    {
	      sh_invalidsig (list->word->word);
	      result = EXECUTION_FAILURE;
	      list = list->next;
	      continue;
	    }

	  signum = lsignum;
	  name = signal_name (signum);
	  if (STREQN (name, "SIGJUNK", 7) || STREQN (name, "Unknown", 7))
	    {
	      list = list->next;
	      continue;
	    }
	  /* POSIX.2 says that `kill -l signum' prints the signal name without
	     the `SIG' prefix. */
	  printf ("%s\n", (this_shell_builtin == kill_builtin && signum > 0) ? name + 3 : name);
	}
      else
	{
	  dflags = DSIG_NOCASE;
	  if (posixly_correct == 0 || this_shell_builtin != kill_builtin)
	    dflags |= DSIG_SIGPREFIX;
	  signum = decode_signal (list->word->word, dflags);
	  if (signum == NO_SIG)
	    {
	      sh_invalidsig (list->word->word);
	      result = EXECUTION_FAILURE;
	      list = list->next;
	      continue;
	    }
	  printf ("%d\n", signum);
	}
      list = list->next;
    }
  return (result);
}
warning: parse error {
  register int i, column;
  char *name;
  int result, signum, dflags;
  intmax_t lsignum;

  result = EXECUTION_SUCCESS;
  if (!list)
    {
      for (i = 1, column = 0; i < NSIG; i++)
	{
	  name = signal_name (i);
	  if (STREQN (name, "SIGJUNK", 7) || STREQN (name, "Unknown", 7))
	    continue;

	  if (posixly_correct && !forcecols)
	    {
	      /* This is for the kill builtin.  POSIX.2 says the signal names
		 are displayed without the `SIG' prefix. */
	      if (STREQN (name, "SIG", 3))
		name += 3;
	      printf ("%s%s", name, (i == NSIG - 1) ? "" : " ");
	    }
	  else
	    {
	      printf ("%2d) %s", i, name);

	      if (++column < 5)
		printf ("\t");
	      else
		{
		  printf ("\n");
		  column = 0;
		}
	    }
	}

      if ((posixly_correct && !forcecols) || column != 0)
	printf ("\n");
      return result;
    }

  /* List individual signal names or numbers. */
  while (list)
    {
      if (legal_number (list->word->word, &lsignum))
	{
	  /* This is specified by Posix.2 so that exit statuses can be
	     mapped into signal numbers. */
	  if (lsignum > 128)
	    lsignum -= 128;
	  if (lsignum < 0 || lsignum >= NSIG)
	    {
	      sh_invalidsig (list->word->word);
	      result = EXECUTION_FAILURE;
	      list = list->next;
	      continue;
	    }

	  signum = lsignum;
	  name = signal_name (signum);
	  if (STREQN (name, "SIGJUNK", 7) || STREQN (name, "Unknown", 7))
	    {
	      list = list->next;
	      continue;
	    }
	  /* POSIX.2 says that `kill -l signum' prints the signal name without
	     the `SIG' prefix. */
	  printf ("%s\n", (this_shell_builtin == kill_builtin && signum > 0) ? name + 3 : name);
	}
      else
	{
	  dflags = DSIG_NOCASE;
	  if (posixly_correct == 0 || this_shell_builtin != kill_builtin)
	    dflags |= DSIG_SIGPREFIX;
	  signum = decode_signal (list->word->word, dflags);
	  if (signum == NO_SIG)
	    {
	      sh_invalidsig (list->word->word);
	      result = EXECUTION_FAILURE;
	      list = list->next;
	      continue;
	    }
	  printf ("%d\n", signum);
	}
      list = list->next;
    }
  return (result);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\common.c:769
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\common.c:871
parsing error 
{
  int hi, lo, mid, j;

  hi = num_shell_builtins - 1;
  lo = 0;

  while (lo <= hi)
    {
      mid = (lo + hi) / 2;

      j = shell_builtins[mid].name[0] - name[0];

      if (j == 0)
	j = strcmp (shell_builtins[mid].name, name);

      if (j == 0)
	{
	  /* It must have a function pointer.  It must be enabled, or we
	     must have explicitly allowed disabled functions to be found,
	     and it must not have been deleted. */
	  if (shell_builtins[mid].function &&
	      ((shell_builtins[mid].flags & BUILTIN_DELETED) == 0) &&
	      ((shell_builtins[mid].flags & BUILTIN_ENABLED) || disabled_okay))
	    return (&shell_builtins[mid]);
	  else
	    return ((struct builtin *)NULL);
	}
      if (j > 0)
	hi = mid - 1;
      else
	lo = mid + 1;
    }
  return ((struct builtin *)NULL);
}
warning: parse error {
  int hi, lo, mid, j;

  hi = num_shell_builtins - 1;
  lo = 0;

  while (lo <= hi)
    {
      mid = (lo + hi) / 2;

      j = shell_builtins[mid].name[0] - name[0];

      if (j == 0)
	j = strcmp (shell_builtins[mid].name, name);

      if (j == 0)
	{
	  /* It must have a function pointer.  It must be enabled, or we
	     must have explicitly allowed disabled functions to be found,
	     and it must not have been deleted. */
	  if (shell_builtins[mid].function &&
	      ((shell_builtins[mid].flags & BUILTIN_DELETED) == 0) &&
	      ((shell_builtins[mid].flags & BUILTIN_ENABLED) || disabled_okay))
	    return (&shell_builtins[mid]);
	  else
	    return ((struct builtin *)NULL);
	}
      if (j > 0)
	hi = mid - 1;
      else
	lo = mid + 1;
    }
  return ((struct builtin *)NULL);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\common.c:874
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\common.c:911
parsing error 
{
  current_builtin = builtin_address_internal (name, 0);
  return (current_builtin ? current_builtin->function : (sh_builtin_func_t *)NULL);
}
warning: parse error {
  current_builtin = builtin_address_internal (name, 0);
  return (current_builtin ? current_builtin->function : (sh_builtin_func_t *)NULL);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\common.c:913
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\common.c:920
parsing error 
{
  current_builtin = builtin_address_internal (name, 1);
  return (current_builtin ? current_builtin->function : (sh_builtin_func_t *)NULL);
}
warning: parse error {
  current_builtin = builtin_address_internal (name, 1);
  return (current_builtin ? current_builtin->function : (sh_builtin_func_t *)NULL);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\common.c:922
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\common.c:930
parsing error 
{
  current_builtin = builtin_address_internal (name, 0);
  return ((current_builtin && (current_builtin->flags & SPECIAL_BUILTIN)) ?
  			current_builtin->function :
  			(sh_builtin_func_t *)NULL);
}
warning: parse error {
  current_builtin = builtin_address_internal (name, 0);
  return ((current_builtin && (current_builtin->flags & SPECIAL_BUILTIN)) ?
  			current_builtin->function :
  			(sh_builtin_func_t *)NULL);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\common.c:932
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\common.c:940
parsing error 
{
  int result;

  if ((result = sbp1->name[0] - sbp2->name[0]) == 0)
    result = strcmp (sbp1->name, sbp2->name);

  return (result);
}
warning: parse error {
  int result;

  if ((result = sbp1->name[0] - sbp2->name[0]) == 0)
    result = strcmp (sbp1->name, sbp2->name);

  return (result);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\common.c:942
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\common.c:975
parsing error 
{
  SHELL_VAR *v;

#if defined (ARRAY_VARS)
  if (valid_array_reference (name, assoc_expand_once ? (VA_NOEXPAND|VA_ONEWORD) : 0) == 0)
    v = bind_variable (name, value, flags);
  else
    v = assign_array_element (name, value, flags | (assoc_expand_once ? ASS_NOEXPAND : 0));
#else /* !ARRAY_VARS */
  v = bind_variable (name, value, flags);
#endif /* !ARRAY_VARS */

  if (v && readonly_p (v) == 0 && noassign_p (v) == 0)
    VUNSETATTR (v, att_invisible);

  return v;
}
warning: parse error {
  SHELL_VAR *v;

#if defined (ARRAY_VARS)
  if (valid_array_reference (name, assoc_expand_once ? (VA_NOEXPAND|VA_ONEWORD) : 0) == 0)
    v = bind_variable (name, value, flags);
  else
    v = assign_array_element (name, value, flags | (assoc_expand_once ? ASS_NOEXPAND : 0));
#else /* !ARRAY_VARS */
  v = bind_variable (name, value, flags);
#endif /* !ARRAY_VARS */

  if (v && readonly_p (v) == 0 && noassign_p (v) == 0)
    VUNSETATTR (v, att_invisible);

  return v;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\common.c:979
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\common.c:1,001
parsing error 
{
  SHELL_VAR *v;

  v = find_variable (vname);
  if (v && readonly_p (v))
    {
      builtin_error (_("%s: cannot unset: readonly %s"), vname, "variable");
      return -2;
    }
  else if (v && non_unsettable_p (v))
    {
      builtin_error (_("%s: cannot unset"), vname);
      return -2;
    }
  return (unbind_variable (vname));
}
warning: parse error {
  SHELL_VAR *v;

  v = find_variable (vname);
  if (v && readonly_p (v))
    {
      builtin_error (_("%s: cannot unset: readonly %s"), vname, "variable");
      return -2;
    }
  else if (v && non_unsettable_p (v))
    {
      builtin_error (_("%s: cannot unset"), vname);
      return -2;
    }
  return (unbind_variable (vname));
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\common.c:1,002
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\evalfile.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashtypes.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\posixstat.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\filecntl.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashansi.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashintl.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\shell.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\parser.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\jobs.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\flags.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\input.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\execute_cmd.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\trap.h...skip
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\y.tab.h...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\typemax.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\common.h...skip
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\evalfile.c:77
parsing error 
{
  volatile int old_interactive;
  procenv_t old_return_catch;
  int return_val, fd, result, pflags, i, nnull;
  ssize_t nr;			/* return value from read(2) */
  char *string;
  struct stat finfo;
  size_t file_size;
  sh_vmsg_func_t *errfunc;
#if defined (ARRAY_VARS)
  SHELL_VAR *funcname_v, *bash_source_v, *bash_lineno_v;
  ARRAY *funcname_a, *bash_source_a, *bash_lineno_a;
  struct func_array_state *fa;
#  if defined (DEBUGGER)
  SHELL_VAR *bash_argv_v, *bash_argc_v;
  ARRAY *bash_argv_a, *bash_argc_a;
#  endif
  char *t, tt[2];
#endif

  USE_VAR(pflags);

#if defined (ARRAY_VARS)
  GET_ARRAY_FROM_VAR ("FUNCNAME", funcname_v, funcname_a);
  GET_ARRAY_FROM_VAR ("BASH_SOURCE", bash_source_v, bash_source_a);
  GET_ARRAY_FROM_VAR ("BASH_LINENO", bash_lineno_v, bash_lineno_a);
#  if defined (DEBUGGER)
  GET_ARRAY_FROM_VAR ("BASH_ARGV", bash_argv_v, bash_argv_a);
  GET_ARRAY_FROM_VAR ("BASH_ARGC", bash_argc_v, bash_argc_a);
#  endif
#endif

  fd = open (filename, O_RDONLY);

  if (fd < 0 || (fstat (fd, &finfo) == -1))
    {
      i = errno;
      if (fd >= 0)
	close (fd);
      errno = i;

file_error_and_exit:
      if (((flags & FEVAL_ENOENTOK) == 0) || errno != ENOENT)
	file_error (filename);

      if (flags & FEVAL_LONGJMP)
	{
	  last_command_exit_value = EXECUTION_FAILURE;
	  jump_to_top_level (EXITPROG);
	}

      return ((flags & FEVAL_BUILTIN) ? EXECUTION_FAILURE
      				      : ((errno == ENOENT && (flags & FEVAL_ENOENTOK) != 0) ? 0 : -1));
    }

  errfunc = ((flags & FEVAL_BUILTIN) ? builtin_error : internal_error);

  if (S_ISDIR (finfo.st_mode))
    {
      (*errfunc) (_("%s: is a directory"), filename);
      close (fd);
      return ((flags & FEVAL_BUILTIN) ? EXECUTION_FAILURE : -1);
    }
  else if ((flags & FEVAL_REGFILE) && S_ISREG (finfo.st_mode) == 0)
    {
      (*errfunc) (_("%s: not a regular file"), filename);
      close (fd);
      return ((flags & FEVAL_BUILTIN) ? EXECUTION_FAILURE : -1);
    }

  file_size = (size_t)finfo.st_size;
  /* Check for overflow with large files. */
  if (file_size != finfo.st_size || file_size + 1 < file_size)
    {
      (*errfunc) (_("%s: file is too large"), filename);
      close (fd);
      return ((flags & FEVAL_BUILTIN) ? EXECUTION_FAILURE : -1);
    }      

  if (S_ISREG (finfo.st_mode) && file_size <= SSIZE_MAX)
    {
      string = (char *)xmalloc (1 + file_size);
      nr = read (fd, string, file_size);
      if (nr >= 0)
	string[nr] = '\0';
    }
  else
    nr = zmapfd (fd, &string, 0);

  return_val = errno;
  close (fd);
  errno = return_val;

  if (nr < 0)		/* XXX was != file_size, not < 0 */
    {
      free (string);
      goto file_error_and_exit;
    }

  if (nr == 0)
    {
      free (string);
      return ((flags & FEVAL_BUILTIN) ? EXECUTION_SUCCESS : 1);
    }
      
  if ((flags & FEVAL_CHECKBINARY) && 
      check_binary_file (string, (nr > 80) ? 80 : nr))
    {
      free (string);
      (*errfunc) (_("%s: cannot execute binary file"), filename);
      return ((flags & FEVAL_BUILTIN) ? EX_BINARY_FILE : -1);
    }

  i = strlen (string);
  if (i < nr)
    {
      for (nnull = i = 0; i < nr; i++)
	if (string[i] == '\0')
          {
	    memmove (string+i, string+i+1, nr - i);
	    nr--;
	    /* Even if the `check binary' flag is not set, we want to avoid
	       sourcing files with more than 256 null characters -- that
	       probably indicates a binary file. */
	    if ((flags & FEVAL_BUILTIN) && ++nnull > 256)
	      {
		free (string);
		(*errfunc) (_("%s: cannot execute binary file"), filename);
		return ((flags & FEVAL_BUILTIN) ? EX_BINARY_FILE : -1);
	      }
          }
    }

  if (flags & FEVAL_UNWINDPROT)
    {
      begin_unwind_frame ("_evalfile");

      unwind_protect_int (return_catch_flag);
      unwind_protect_jmp_buf (return_catch);
      if (flags & FEVAL_NONINT)
	unwind_protect_int (interactive);
      unwind_protect_int (sourcelevel);
    }
  else
    {
      COPY_PROCENV (return_catch, old_return_catch);
      if (flags & FEVAL_NONINT)
	old_interactive = interactive;
    }

  if (flags & FEVAL_NONINT)
    interactive = 0;

  return_catch_flag++;
  sourcelevel++;

#if defined (ARRAY_VARS)
  array_push (bash_source_a, (char *)filename);
  t = itos (executing_line_number ());
  array_push (bash_lineno_a, t);
  free (t);
  array_push (funcname_a, "source");	/* not exactly right */

  fa = (struct func_array_state *)xmalloc (sizeof (struct func_array_state));
  fa->source_a = bash_source_a;
  fa->source_v = bash_source_v;
  fa->lineno_a = bash_lineno_a;
  fa->lineno_v = bash_lineno_v;
  fa->funcname_a = funcname_a;
  fa->funcname_v = funcname_v;
  if (flags & FEVAL_UNWINDPROT)
    add_unwind_protect (restore_funcarray_state, fa);

#  if defined (DEBUGGER)
  /* Have to figure out a better way to do this when `source' is supplied
     arguments */
  if ((flags & FEVAL_NOPUSHARGS) == 0)
    {
      if (shell_compatibility_level <= 44)
	init_bash_argv ();
      array_push (bash_argv_a, (char *)filename);	/* XXX - unconditionally? */
      tt[0] = '1'; tt[1] = '\0';
      array_push (bash_argc_a, tt);
      if (flags & FEVAL_UNWINDPROT)
	add_unwind_protect (pop_args, 0);
    }
#  endif
#endif

  /* set the flags to be passed to parse_and_execute */
  pflags = SEVAL_RESETLINE;
  pflags |= (flags & FEVAL_HISTORY) ? 0 : SEVAL_NOHIST;

  if (flags & FEVAL_BUILTIN)
    result = EXECUTION_SUCCESS;

  return_val = setjmp_nosigs (return_catch);

  /* If `return' was seen outside of a function, but in the script, then
     force parse_and_execute () to clean up. */
  if (return_val)
    {
      parse_and_execute_cleanup (-1);
      result = return_catch_value;
    }
  else
    result = parse_and_execute (string, filename, pflags);

  if (flags & FEVAL_UNWINDPROT)
    run_unwind_frame ("_evalfile");
  else
    {
      if (flags & FEVAL_NONINT)
	interactive = old_interactive;
#if defined (ARRAY_VARS)
      restore_funcarray_state (fa);
#  if defined (DEBUGGER)
      if ((flags & FEVAL_NOPUSHARGS) == 0)
	{
	  /* Don't need to call pop_args here until we do something better
	     when source is passed arguments (see above). */
	  array_pop (bash_argc_a);
	  array_pop (bash_argv_a);
	}
#  endif
#endif
      return_catch_flag--;
      sourcelevel--;
      COPY_PROCENV (old_return_catch, return_catch);
    }

  /* If we end up with EOF after sourcing a file, which can happen when the file
     doesn't end with a newline, pretend that it did. */
  if (current_token == yacc_EOF)
    push_token ('\n');		/* XXX */

  return ((flags & FEVAL_BUILTIN) ? result : 1);
}
warning: parse error {
  volatile int old_interactive;
  procenv_t old_return_catch;
  int return_val, fd, result, pflags, i, nnull;
  ssize_t nr;			/* return value from read(2) */
  char *string;
  struct stat finfo;
  size_t file_size;
  sh_vmsg_func_t *errfunc;
#if defined (ARRAY_VARS)
  SHELL_VAR *funcname_v, *bash_source_v, *bash_lineno_v;
  ARRAY *funcname_a, *bash_source_a, *bash_lineno_a;
  struct func_array_state *fa;
#  if defined (DEBUGGER)
  SHELL_VAR *bash_argv_v, *bash_argc_v;
  ARRAY *bash_argv_a, *bash_argc_a;
#  endif
  char *t, tt[2];
#endif

  USE_VAR(pflags);

#if defined (ARRAY_VARS)
  GET_ARRAY_FROM_VAR ("FUNCNAME", funcname_v, funcname_a);
  GET_ARRAY_FROM_VAR ("BASH_SOURCE", bash_source_v, bash_source_a);
  GET_ARRAY_FROM_VAR ("BASH_LINENO", bash_lineno_v, bash_lineno_a);
#  if defined (DEBUGGER)
  GET_ARRAY_FROM_VAR ("BASH_ARGV", bash_argv_v, bash_argv_a);
  GET_ARRAY_FROM_VAR ("BASH_ARGC", bash_argc_v, bash_argc_a);
#  endif
#endif

  fd = open (filename, O_RDONLY);

  if (fd < 0 || (fstat (fd, &finfo) == -1))
    {
      i = errno;
      if (fd >= 0)
	close (fd);
      errno = i;

file_error_and_exit:
      if (((flags & FEVAL_ENOENTOK) == 0) || errno != ENOENT)
	file_error (filename);

      if (flags & FEVAL_LONGJMP)
	{
	  last_command_exit_value = EXECUTION_FAILURE;
	  jump_to_top_level (EXITPROG);
	}

      return ((flags & FEVAL_BUILTIN) ? EXECUTION_FAILURE
      				      : ((errno == ENOENT && (flags & FEVAL_ENOENTOK) != 0) ? 0 : -1));
    }

  errfunc = ((flags & FEVAL_BUILTIN) ? builtin_error : internal_error);

  if (S_ISDIR (finfo.st_mode))
    {
      (*errfunc) (_("%s: is a directory"), filename);
      close (fd);
      return ((flags & FEVAL_BUILTIN) ? EXECUTION_FAILURE : -1);
    }
  else if ((flags & FEVAL_REGFILE) && S_ISREG (finfo.st_mode) == 0)
    {
      (*errfunc) (_("%s: not a regular file"), filename);
      close (fd);
      return ((flags & FEVAL_BUILTIN) ? EXECUTION_FAILURE : -1);
    }

  file_size = (size_t)finfo.st_size;
  /* Check for overflow with large files. */
  if (file_size != finfo.st_size || file_size + 1 < file_size)
    {
      (*errfunc) (_("%s: file is too large"), filename);
      close (fd);
      return ((flags & FEVAL_BUILTIN) ? EXECUTION_FAILURE : -1);
    }      

  if (S_ISREG (finfo.st_mode) && file_size <= SSIZE_MAX)
    {
      string = (char *)xmalloc (1 + file_size);
      nr = read (fd, string, file_size);
      if (nr >= 0)
	string[nr] = '\0';
    }
  else
    nr = zmapfd (fd, &string, 0);

  return_val = errno;
  close (fd);
  errno = return_val;

  if (nr < 0)		/* XXX was != file_size, not < 0 */
    {
      free (string);
      goto file_error_and_exit;
    }

  if (nr == 0)
    {
      free (string);
      return ((flags & FEVAL_BUILTIN) ? EXECUTION_SUCCESS : 1);
    }
      
  if ((flags & FEVAL_CHECKBINARY) && 
      check_binary_file (string, (nr > 80) ? 80 : nr))
    {
      free (string);
      (*errfunc) (_("%s: cannot execute binary file"), filename);
      return ((flags & FEVAL_BUILTIN) ? EX_BINARY_FILE : -1);
    }

  i = strlen (string);
  if (i < nr)
    {
      for (nnull = i = 0; i < nr; i++)
	if (string[i] == '\0')
          {
	    memmove (string+i, string+i+1, nr - i);
	    nr--;
	    /* Even if the `check binary' flag is not set, we want to avoid
	       sourcing files with more than 256 null characters -- that
	       probably indicates a binary file. */
	    if ((flags & FEVAL_BUILTIN) && ++nnull > 256)
	      {
		free (string);
		(*errfunc) (_("%s: cannot execute binary file"), filename);
		return ((flags & FEVAL_BUILTIN) ? EX_BINARY_FILE : -1);
	      }
          }
    }

  if (flags & FEVAL_UNWINDPROT)
    {
      begin_unwind_frame ("_evalfile");

      unwind_protect_int (return_catch_flag);
      unwind_protect_jmp_buf (return_catch);
      if (flags & FEVAL_NONINT)
	unwind_protect_int (interactive);
      unwind_protect_int (sourcelevel);
    }
  else
    {
      COPY_PROCENV (return_catch, old_return_catch);
      if (flags & FEVAL_NONINT)
	old_interactive = interactive;
    }

  if (flags & FEVAL_NONINT)
    interactive = 0;

  return_catch_flag++;
  sourcelevel++;

#if defined (ARRAY_VARS)
  array_push (bash_source_a, (char *)filename);
  t = itos (executing_line_number ());
  array_push (bash_lineno_a, t);
  free (t);
  array_push (funcname_a, "source");	/* not exactly right */

  fa = (struct func_array_state *)xmalloc (sizeof (struct func_array_state));
  fa->source_a = bash_source_a;
  fa->source_v = bash_source_v;
  fa->lineno_a = bash_lineno_a;
  fa->lineno_v = bash_lineno_v;
  fa->funcname_a = funcname_a;
  fa->funcname_v = funcname_v;
  if (flags & FEVAL_UNWINDPROT)
    add_unwind_protect (restore_funcarray_state, fa);

#  if defined (DEBUGGER)
  /* Have to figure out a better way to do this when `source' is supplied
     arguments */
  if ((flags & FEVAL_NOPUSHARGS) == 0)
    {
      if (shell_compatibility_level <= 44)
	init_bash_argv ();
      array_push (bash_argv_a, (char *)filename);	/* XXX - unconditionally? */
      tt[0] = '1'; tt[1] = '\0';
      array_push (bash_argc_a, tt);
      if (flags & FEVAL_UNWINDPROT)
	add_unwind_protect (pop_args, 0);
    }
#  endif
#endif

  /* set the flags to be passed to parse_and_execute */
  pflags = SEVAL_RESETLINE;
  pflags |= (flags & FEVAL_HISTORY) ? 0 : SEVAL_NOHIST;

  if (flags & FEVAL_BUILTIN)
    result = EXECUTION_SUCCESS;

  return_val = setjmp_nosigs (return_catch);

  /* If `return' was seen outside of a function, but in the script, then
     force parse_and_execute () to clean up. */
  if (return_val)
    {
      parse_and_execute_cleanup (-1);
      result = return_catch_value;
    }
  else
    result = parse_and_execute (string, filename, pflags);

  if (flags & FEVAL_UNWINDPROT)
    run_unwind_frame ("_evalfile");
  else
    {
      if (flags & FEVAL_NONINT)
	interactive = old_interactive;
#if defined (ARRAY_VARS)
      restore_funcarray_state (fa);
#  if defined (DEBUGGER)
      if ((flags & FEVAL_NOPUSHARGS) == 0)
	{
	  /* Don't need to call pop_args here until we do something better
	     when source is passed arguments (see above). */
	  array_pop (bash_argc_a);
	  array_pop (bash_argv_a);
	}
#  endif
#endif
      return_catch_flag--;
      sourcelevel--;
      COPY_PROCENV (old_return_catch, return_catch);
    }

  /* If we end up with EOF after sourcing a file, which can happen when the file
     doesn't end with a newline, pretend that it did. */
  if (current_token == yacc_EOF)
    push_token ('\n');		/* XXX */

  return ((flags & FEVAL_BUILTIN) ? result : 1);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\evalfile.c:79
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\evalfile.c:320
parsing error 
{
  char *filename;
  int result, flags;

  filename = bash_tilde_expand (fname, 0);
  flags = FEVAL_ENOENTOK;
  if (force_noninteractive)
    flags |= FEVAL_NONINT;
  result = _evalfile (filename, flags);
  free (filename);
  return result;
}
warning: parse error {
  char *filename;
  int result, flags;

  filename = bash_tilde_expand (fname, 0);
  flags = FEVAL_ENOENTOK;
  if (force_noninteractive)
    flags |= FEVAL_NONINT;
  result = _evalfile (filename, flags);
  free (filename);
  return result;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\evalfile.c:322
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\evalfile.c:337
parsing error 
{
  char *filename;
  int result, flags;

  filename = bash_tilde_expand (fname, 0);
  flags = 0;
  if (force_noninteractive)
    flags |= FEVAL_NONINT;
  result = _evalfile (filename, flags);
  free (filename);
  return result;
}
warning: parse error {
  char *filename;
  int result, flags;

  filename = bash_tilde_expand (fname, 0);
  flags = 0;
  if (force_noninteractive)
    flags |= FEVAL_NONINT;
  result = _evalfile (filename, flags);
  free (filename);
  return result;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\evalfile.c:339
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\evalfile.c:369
parsing error 
{
  int flags, rval;

  flags = FEVAL_BUILTIN|FEVAL_UNWINDPROT|FEVAL_NONINT;
  if (sflags)
    flags |= FEVAL_NOPUSHARGS;
  /* POSIX shells exit if non-interactive and file error. */
  if (posixly_correct && interactive_shell == 0 && executing_command_builtin == 0)
    flags |= FEVAL_LONGJMP;
  rval = _evalfile (filename, flags);

  run_return_trap ();
  return rval;
}
warning: parse error {
  int flags, rval;

  flags = FEVAL_BUILTIN|FEVAL_UNWINDPROT|FEVAL_NONINT;
  if (sflags)
    flags |= FEVAL_NOPUSHARGS;
  /* POSIX shells exit if non-interactive and file error. */
  if (posixly_correct && interactive_shell == 0 && executing_command_builtin == 0)
    flags |= FEVAL_LONGJMP;
  rval = _evalfile (filename, flags);

  run_return_trap ();
  return rval;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\evalfile.c:371
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\evalstring.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\filecntl.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashansi.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\shell.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\jobs.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\flags.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\parser.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\input.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\execute_cmd.h...skip
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\redir.h...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\stdc.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\trap.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashintl.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\y.tab.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\common.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\evalstring.c:80
parsing error 
{
  FREE (the_printed_command_except_trap);
  the_printed_command_except_trap = x;
}
warning: parse error {
  FREE (the_printed_command_except_trap);
  the_printed_command_except_trap = x;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\evalstring.c:82
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\evalstring.c:88
parsing error 
{
#if 0 /* TAG: bash-5.2 */
  int subshell;

  subshell = subshell_environment & SUBSHELL_PROCSUB;	/* salt to taste */
#endif
  return (startup_state == 2 && parse_and_execute_level == 1 &&
	  running_trap == 0 &&
	  *bash_input.location.string == '\0' &&
	  parser_expanding_alias () == 0 &&
	  command->type == cm_simple &&
	  signal_is_trapped (EXIT_TRAP) == 0 &&
	  signal_is_trapped (ERROR_TRAP) == 0 &&
	  any_signals_trapped () < 0 &&
#if 0 /* TAG: bash-5.2 */
	  (subshell || (command->redirects == 0 && command->value.Simple->redirects == 0)) &&
#else
	  command->redirects == 0 && command->value.Simple->redirects == 0 &&
#endif
	  ((command->flags & CMD_TIME_PIPELINE) == 0) &&
	  ((command->flags & CMD_INVERT_RETURN) == 0));
}
warning: parse error {
#if 0 /* TAG: bash-5.2 */
  int subshell;

  subshell = subshell_environment & SUBSHELL_PROCSUB;	/* salt to taste */
#endif
  return (startup_state == 2 && parse_and_execute_level == 1 &&
	  running_trap == 0 &&
	  *bash_input.location.string == '\0' &&
	  parser_expanding_alias () == 0 &&
	  command->type == cm_simple &&
	  signal_is_trapped (EXIT_TRAP) == 0 &&
	  signal_is_trapped (ERROR_TRAP) == 0 &&
	  any_signals_trapped () < 0 &&
#if 0 /* TAG: bash-5.2 */
	  (subshell || (command->redirects == 0 && command->value.Simple->redirects == 0)) &&
#else
	  command->redirects == 0 && command->value.Simple->redirects == 0 &&
#endif
	  ((command->flags & CMD_TIME_PIPELINE) == 0) &&
	  ((command->flags & CMD_INVERT_RETURN) == 0));
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\evalstring.c:90
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\evalstring.c:114
parsing error 
{
  return (*bash_input.location.string == '\0' &&
	  parser_expanding_alias () == 0 &&
	  (command->value.Connection->connector == AND_AND || command->value.Connection->connector == OR_OR || command->value.Connection->connector == ';') &&
	  command->value.Connection->second->type == cm_simple);
}
warning: parse error {
  return (*bash_input.location.string == '\0' &&
	  parser_expanding_alias () == 0 &&
	  (command->value.Connection->connector == AND_AND || command->value.Connection->connector == OR_OR || command->value.Connection->connector == ';') &&
	  command->value.Connection->second->type == cm_simple);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\evalstring.c:116
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\evalstring.c:124
parsing error 
{
  if (command->type == cm_connection &&
      (command->value.Connection->connector == AND_AND || command->value.Connection->connector == OR_OR || command->value.Connection->connector == ';') &&
      (command->value.Connection->second->flags & CMD_TRY_OPTIMIZING) &&
      should_suppress_fork (command->value.Connection->second))
    {
      command->value.Connection->second->flags |= CMD_NO_FORK;
      command->value.Connection->second->value.Simple->flags |= CMD_NO_FORK;
    }
}
warning: parse error {
  if (command->type == cm_connection &&
      (command->value.Connection->connector == AND_AND || command->value.Connection->connector == OR_OR || command->value.Connection->connector == ';') &&
      (command->value.Connection->second->flags & CMD_TRY_OPTIMIZING) &&
      should_suppress_fork (command->value.Connection->second))
    {
      command->value.Connection->second->flags |= CMD_NO_FORK;
      command->value.Connection->second->value.Simple->flags |= CMD_NO_FORK;
    }
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\evalstring.c:126
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\evalstring.c:138
parsing error 
{
  if (running_trap == 0 &&
      command->type == cm_simple &&
      signal_is_trapped (EXIT_TRAP) == 0 &&
      signal_is_trapped (ERROR_TRAP) == 0 &&
      any_signals_trapped () < 0 &&
      command->redirects == 0 && command->value.Simple->redirects == 0 &&
      ((command->flags & CMD_TIME_PIPELINE) == 0) &&
      ((command->flags & CMD_INVERT_RETURN) == 0))
    {
      command->flags |= CMD_NO_FORK;
      command->value.Simple->flags |= CMD_NO_FORK;
    }
  else if (command->type == cm_connection &&
	   (command->value.Connection->connector == AND_AND || command->value.Connection->connector == OR_OR))
    optimize_subshell_command (command->value.Connection->second);
}
warning: parse error {
  if (running_trap == 0 &&
      command->type == cm_simple &&
      signal_is_trapped (EXIT_TRAP) == 0 &&
      signal_is_trapped (ERROR_TRAP) == 0 &&
      any_signals_trapped () < 0 &&
      command->redirects == 0 && command->value.Simple->redirects == 0 &&
      ((command->flags & CMD_TIME_PIPELINE) == 0) &&
      ((command->flags & CMD_INVERT_RETURN) == 0))
    {
      command->flags |= CMD_NO_FORK;
      command->value.Simple->flags |= CMD_NO_FORK;
    }
  else if (command->type == cm_connection &&
	   (command->value.Connection->connector == AND_AND || command->value.Connection->connector == OR_OR))
    optimize_subshell_command (command->value.Connection->second);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\evalstring.c:140
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\evalstring.c:159
parsing error 
{
  COMMAND *fc;

  fc = (command->type == cm_group) ? command->value.Group->command : command;

  if (fc->type == cm_simple && should_suppress_fork (fc))
    {
      fc->flags |= CMD_NO_FORK;
      fc->value.Simple->flags |= CMD_NO_FORK;
    }
  else if (fc->type == cm_connection && can_optimize_connection (fc) && should_suppress_fork (fc->value.Connection->second))
    {
      fc->value.Connection->second->flags |= CMD_NO_FORK;
      fc->value.Connection->second->value.Simple->flags |= CMD_NO_FORK;
    }  
}
warning: parse error {
  COMMAND *fc;

  fc = (command->type == cm_group) ? command->value.Group->command : command;

  if (fc->type == cm_simple && should_suppress_fork (fc))
    {
      fc->flags |= CMD_NO_FORK;
      fc->value.Simple->flags |= CMD_NO_FORK;
    }
  else if (fc->type == cm_connection && can_optimize_connection (fc) && should_suppress_fork (fc->value.Connection->second))
    {
      fc->value.Connection->second->flags |= CMD_NO_FORK;
      fc->value.Connection->second->value.Simple->flags |= CMD_NO_FORK;
    }  
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\evalstring.c:161
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\evalstring.c:180
parsing error 
{
  if (running_trap > 0)
    {
      /* We assume if we have a different value for running_trap than when
	 we started (the only caller that cares is evalstring()), the
	 original caller will perform the cleanup, and we should not step
	 on them. */
      if (running_trap != old_running_trap)
	run_trap_cleanup (running_trap - 1);
      unfreeze_jobs_list ();
    }

  if (have_unwind_protects ())
     run_unwind_frame (PE_TAG);
  else
    parse_and_execute_level = 0;			/* XXX */
}
warning: parse error {
  if (running_trap > 0)
    {
      /* We assume if we have a different value for running_trap than when
	 we started (the only caller that cares is evalstring()), the
	 original caller will perform the cleanup, and we should not step
	 on them. */
      if (running_trap != old_running_trap)
	run_trap_cleanup (running_trap - 1);
      unfreeze_jobs_list ();
    }

  if (have_unwind_protects ())
     run_unwind_frame (PE_TAG);
  else
    parse_and_execute_level = 0;			/* XXX */
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\evalstring.c:182
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\evalstring.c:201
parsing error 
{
  char *orig_string, *lastcom;
  int x;

  orig_string = string;
  /* Unwind protect this invocation of parse_and_execute (). */
  begin_unwind_frame (tag);
  unwind_protect_int (parse_and_execute_level);
  unwind_protect_jmp_buf (top_level);
  unwind_protect_int (indirection_level);
  unwind_protect_int (line_number);
  unwind_protect_int (line_number_for_err_trap);
  unwind_protect_int (loop_level);
  unwind_protect_int (executing_list);
  unwind_protect_int (comsub_ignore_return);
  if (flags & (SEVAL_NONINT|SEVAL_INTERACT))
    unwind_protect_int (interactive);

#if defined (HISTORY)
  if (parse_and_execute_level == 0)
    add_unwind_protect (set_history_remembering, (char *)NULL);
  else
    unwind_protect_int (remember_on_history);	/* can be used in scripts */
#  if defined (BANG_HISTORY)
  unwind_protect_int (history_expansion_inhibited);
#  endif /* BANG_HISTORY */
#endif /* HISTORY */

  if (interactive_shell)
    {
      x = get_current_prompt_level ();
      add_unwind_protect (set_current_prompt_level, x);
    }

  if (the_printed_command_except_trap)
    {
      lastcom = savestring (the_printed_command_except_trap);
      add_unwind_protect (restore_lastcom, lastcom);
    }

  add_unwind_protect (pop_stream, (char *)NULL);
  if (parser_expanding_alias ())
    add_unwind_protect (parser_restore_alias, (char *)NULL);

  if (orig_string && ((flags & SEVAL_NOFREE) == 0))
    add_unwind_protect (xfree, orig_string);
  end_unwind_frame ();

  if (flags & (SEVAL_NONINT|SEVAL_INTERACT))
    interactive = (flags & SEVAL_NONINT) ? 0 : 1;

#if defined (HISTORY)
  if (flags & SEVAL_NOHIST)
    bash_history_disable ();
#  if defined (BANG_HISTORY)
  if (flags & SEVAL_NOHISTEXP)
    history_expansion_inhibited = 1;
#  endif /* BANG_HISTORY */
#endif /* HISTORY */
}
warning: parse error {
  char *orig_string, *lastcom;
  int x;

  orig_string = string;
  /* Unwind protect this invocation of parse_and_execute (). */
  begin_unwind_frame (tag);
  unwind_protect_int (parse_and_execute_level);
  unwind_protect_jmp_buf (top_level);
  unwind_protect_int (indirection_level);
  unwind_protect_int (line_number);
  unwind_protect_int (line_number_for_err_trap);
  unwind_protect_int (loop_level);
  unwind_protect_int (executing_list);
  unwind_protect_int (comsub_ignore_return);
  if (flags & (SEVAL_NONINT|SEVAL_INTERACT))
    unwind_protect_int (interactive);

#if defined (HISTORY)
  if (parse_and_execute_level == 0)
    add_unwind_protect (set_history_remembering, (char *)NULL);
  else
    unwind_protect_int (remember_on_history);	/* can be used in scripts */
#  if defined (BANG_HISTORY)
  unwind_protect_int (history_expansion_inhibited);
#  endif /* BANG_HISTORY */
#endif /* HISTORY */

  if (interactive_shell)
    {
      x = get_current_prompt_level ();
      add_unwind_protect (set_current_prompt_level, x);
    }

  if (the_printed_command_except_trap)
    {
      lastcom = savestring (the_printed_command_except_trap);
      add_unwind_protect (restore_lastcom, lastcom);
    }

  add_unwind_protect (pop_stream, (char *)NULL);
  if (parser_expanding_alias ())
    add_unwind_protect (parser_restore_alias, (char *)NULL);

  if (orig_string && ((flags & SEVAL_NOFREE) == 0))
    add_unwind_protect (xfree, orig_string);
  end_unwind_frame ();

  if (flags & (SEVAL_NONINT|SEVAL_INTERACT))
    interactive = (flags & SEVAL_NONINT) ? 0 : 1;

#if defined (HISTORY)
  if (flags & SEVAL_NOHIST)
    bash_history_disable ();
#  if defined (BANG_HISTORY)
  if (flags & SEVAL_NOHISTEXP)
    history_expansion_inhibited = 1;
#  endif /* BANG_HISTORY */
#endif /* HISTORY */
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\evalstring.c:205
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\evalstring.c:279
parsing error 
{
  int code, lreset;
  volatile int should_jump_to_top_level, last_result;
  COMMAND *volatile command;
  volatile sigset_t pe_sigmask;

  parse_prologue (string, flags, PE_TAG);

  parse_and_execute_level++;

  lreset = flags & SEVAL_RESETLINE;

#if defined (HAVE_POSIX_SIGNALS)
  /* If we longjmp and are going to go on, use this to restore signal mask */
  sigemptyset ((sigset_t *)&pe_sigmask);
  sigprocmask (SIG_BLOCK, (sigset_t *)NULL, (sigset_t *)&pe_sigmask);
#endif

  /* Reset the line number if the caller wants us to.  If we don't reset the
     line number, we have to subtract one, because we will add one just
     before executing the next command (resetting the line number sets it to
     0; the first line number is 1). */
  push_stream (lreset);
  if (parser_expanding_alias ())
    /* push current shell_input_line */
    parser_save_alias ();
  
  if (lreset == 0)
    line_number--;
    
  indirection_level++;

  code = should_jump_to_top_level = 0;
  last_result = EXECUTION_SUCCESS;

  /* We need to reset enough of the token state so we can start fresh. */
  if (current_token == yacc_EOF)
    current_token = '\n';		/* reset_parser() ? */

  with_input_from_string (string, from_file);
  clear_shell_input_line ();
  while (*(bash_input.location.string) || parser_expanding_alias ())
    {
      command = (COMMAND *)NULL;

      if (interrupt_state)
	{
	  last_result = EXECUTION_FAILURE;
	  break;
	}

      /* Provide a location for functions which `longjmp (top_level)' to
	 jump to.  This prevents errors in substitution from restarting
	 the reader loop directly, for example. */
      code = setjmp_nosigs (top_level);

      if (code)
	{
	  should_jump_to_top_level = 0;
	  switch (code)
	    {
	    case ERREXIT:
	      /* variable_context -> 0 is what eval.c:reader_loop() does in
		 these circumstances.  Don't bother with cleanup here because
		 we don't want to run the function execution cleanup stuff
		 that will cause pop_context and other functions to run.
		 XXX - change that if we want the function context to be
		 unwound. */
	      if (exit_immediately_on_error && variable_context)
	        {
	          discard_unwind_frame ("pe_dispose");
		  variable_context = 0;	/* not in a function */
	        }
	      should_jump_to_top_level = 1;
	      goto out;
	    case FORCE_EOF:	      
	    case EXITPROG:
	      if (command)
		run_unwind_frame ("pe_dispose");
	      /* Remember to call longjmp (top_level) after the old
		 value for it is restored. */
	      should_jump_to_top_level = 1;
	      goto out;

	    case DISCARD:
	      if (command)
		run_unwind_frame ("pe_dispose");
	      last_result = last_command_exit_value = EXECUTION_FAILURE; /* XXX */
	      set_pipestatus_from_exit (last_command_exit_value);
	      if (subshell_environment)
		{
		  should_jump_to_top_level = 1;
		  goto out;
		}
	      else
		{
#if 0
		  dispose_command (command);	/* pe_dispose does this */
#endif
#if defined (HAVE_POSIX_SIGNALS)
		  sigprocmask (SIG_SETMASK, (sigset_t *)&pe_sigmask, (sigset_t *)NULL);
#endif
		  continue;
		}

	    default:
	      command_error ("parse_and_execute", CMDERR_BADJUMP, code, 0);
	      break;
	    }
	}
	  
      if (parse_command () == 0)
	{
	  if ((flags & SEVAL_PARSEONLY) || (interactive_shell == 0 && read_but_dont_execute))
	    {
	      last_result = EXECUTION_SUCCESS;
	      dispose_command (global_command);
	      global_command = (COMMAND *)NULL;
	    }
	  else if (command = global_command)
	    {
	      struct fd_bitmap *bitmap;

	      if (flags & SEVAL_FUNCDEF)
		{
		  char *x;

		  /* If the command parses to something other than a straight
		     function definition, or if we have not consumed the entire
		     string, or if the parser has transformed the function
		     name (as parsing will if it begins or ends with shell
		     whitespace, for example), reject the attempt */
		  if (command->type != cm_function_def ||
		      ((x = parser_remaining_input ()) && *x) ||
		      (STREQ (from_file, command->value.Function_def->name->word) == 0))
		    {
		      internal_warning (_("%s: ignoring function definition attempt"), from_file);
		      should_jump_to_top_level = 0;
		      last_result = last_command_exit_value = EX_BADUSAGE;
		      set_pipestatus_from_exit (last_command_exit_value);
		      reset_parser ();
		      break;
		    }
		}

	      bitmap = new_fd_bitmap (FD_BITMAP_SIZE);
	      begin_unwind_frame ("pe_dispose");
	      add_unwind_protect (dispose_fd_bitmap, bitmap);
	      add_unwind_protect (dispose_command, command);	/* XXX */

	      global_command = (COMMAND *)NULL;

	      if ((subshell_environment & SUBSHELL_COMSUB) && comsub_ignore_return)
		command->flags |= CMD_IGNORE_RETURN;

#if defined (ONESHOT)
	      /*
	       * IF
	       *   we were invoked as `bash -c' (startup_state == 2) AND
	       *   parse_and_execute has not been called recursively AND
	       *   we're not running a trap AND
	       *   we have parsed the full command (string == '\0') AND
	       *   we're not going to run the exit trap AND
	       *   we have a simple command without redirections AND
	       *   the command is not being timed AND
	       *   the command's return status is not being inverted AND
	       *   there aren't any traps in effect
	       * THEN
	       *   tell the execution code that we don't need to fork
	       */
	      if (should_suppress_fork (command))
		{
		  command->flags |= CMD_NO_FORK;
		  command->value.Simple->flags |= CMD_NO_FORK;
		}

	      /* Can't optimize forks out here execept for simple commands.
		 This knows that the parser sets up commands as left-side heavy
		 (&& and || are left-associative) and after the single parse,
		 if we are at the end of the command string, the last in a
		 series of connection commands is
		 command->value.Connection->second. */
	      else if (command->type == cm_connection && can_optimize_connection (command))
		{
		  command->value.Connection->second->flags |= CMD_TRY_OPTIMIZING;
		  command->value.Connection->second->value.Simple->flags |= CMD_TRY_OPTIMIZING;
		}
#endif /* ONESHOT */

	      /* See if this is a candidate for $( <file ). */
	      if (startup_state == 2 &&
		  (subshell_environment & SUBSHELL_COMSUB) &&
		  *bash_input.location.string == '\0' &&
		  command->type == cm_simple && !command->redirects &&
		  (command->flags & CMD_TIME_PIPELINE) == 0 &&
		  command->value.Simple->words == 0 &&
		  command->value.Simple->redirects &&
		  command->value.Simple->redirects->next == 0 &&
		  command->value.Simple->redirects->instruction == r_input_direction &&
		  command->value.Simple->redirects->redirector.dest == 0)
		{
		  int r;
		  r = cat_file (command->value.Simple->redirects);
		  last_result = (r < 0) ? EXECUTION_FAILURE : EXECUTION_SUCCESS;
		}
	      else
		last_result = execute_command_internal
				(command, 0, NO_PIPE, NO_PIPE, bitmap);
	      dispose_command (command);
	      dispose_fd_bitmap (bitmap);
	      discard_unwind_frame ("pe_dispose");

	      if (flags & SEVAL_ONECMD)
		{
		  reset_parser ();
		  break;
		}
	    }
	}
      else
	{
	  last_result = EX_BADUSAGE;	/* was EXECUTION_FAILURE */

	  if (interactive_shell == 0 && this_shell_builtin &&
	      (this_shell_builtin == source_builtin || this_shell_builtin == eval_builtin) &&
	      last_command_exit_value == EX_BADSYNTAX && posixly_correct && executing_command_builtin == 0)
	    {
	      should_jump_to_top_level = 1;
	      code = ERREXIT;
	      last_command_exit_value = EX_BADUSAGE;
	    }

	  /* Since we are shell compatible, syntax errors in a script
	     abort the execution of the script.  Right? */
	  break;
	}
    }

 out:

  run_unwind_frame (PE_TAG);

  if (interrupt_state && parse_and_execute_level == 0)
    {
      /* An interrupt during non-interactive execution in an
	 interactive shell (e.g. via $PROMPT_COMMAND) should
	 not cause the shell to exit. */
      interactive = interactive_shell;
      throw_to_top_level ();
    }

  if (should_jump_to_top_level)
    jump_to_top_level (code);

  return (last_result);
}
warning: parse error {
  int code, lreset;
  volatile int should_jump_to_top_level, last_result;
  COMMAND *volatile command;
  volatile sigset_t pe_sigmask;

  parse_prologue (string, flags, PE_TAG);

  parse_and_execute_level++;

  lreset = flags & SEVAL_RESETLINE;

#if defined (HAVE_POSIX_SIGNALS)
  /* If we longjmp and are going to go on, use this to restore signal mask */
  sigemptyset ((sigset_t *)&pe_sigmask);
  sigprocmask (SIG_BLOCK, (sigset_t *)NULL, (sigset_t *)&pe_sigmask);
#endif

  /* Reset the line number if the caller wants us to.  If we don't reset the
     line number, we have to subtract one, because we will add one just
     before executing the next command (resetting the line number sets it to
     0; the first line number is 1). */
  push_stream (lreset);
  if (parser_expanding_alias ())
    /* push current shell_input_line */
    parser_save_alias ();
  
  if (lreset == 0)
    line_number--;
    
  indirection_level++;

  code = should_jump_to_top_level = 0;
  last_result = EXECUTION_SUCCESS;

  /* We need to reset enough of the token state so we can start fresh. */
  if (current_token == yacc_EOF)
    current_token = '\n';		/* reset_parser() ? */

  with_input_from_string (string, from_file);
  clear_shell_input_line ();
  while (*(bash_input.location.string) || parser_expanding_alias ())
    {
      command = (COMMAND *)NULL;

      if (interrupt_state)
	{
	  last_result = EXECUTION_FAILURE;
	  break;
	}

      /* Provide a location for functions which `longjmp (top_level)' to
	 jump to.  This prevents errors in substitution from restarting
	 the reader loop directly, for example. */
      code = setjmp_nosigs (top_level);

      if (code)
	{
	  should_jump_to_top_level = 0;
	  switch (code)
	    {
	    case ERREXIT:
	      /* variable_context -> 0 is what eval.c:reader_loop() does in
		 these circumstances.  Don't bother with cleanup here because
		 we don't want to run the function execution cleanup stuff
		 that will cause pop_context and other functions to run.
		 XXX - change that if we want the function context to be
		 unwound. */
	      if (exit_immediately_on_error && variable_context)
	        {
	          discard_unwind_frame ("pe_dispose");
		  variable_context = 0;	/* not in a function */
	        }
	      should_jump_to_top_level = 1;
	      goto out;
	    case FORCE_EOF:	      
	    case EXITPROG:
	      if (command)
		run_unwind_frame ("pe_dispose");
	      /* Remember to call longjmp (top_level) after the old
		 value for it is restored. */
	      should_jump_to_top_level = 1;
	      goto out;

	    case DISCARD:
	      if (command)
		run_unwind_frame ("pe_dispose");
	      last_result = last_command_exit_value = EXECUTION_FAILURE; /* XXX */
	      set_pipestatus_from_exit (last_command_exit_value);
	      if (subshell_environment)
		{
		  should_jump_to_top_level = 1;
		  goto out;
		}
	      else
		{
#if 0
		  dispose_command (command);	/* pe_dispose does this */
#endif
#if defined (HAVE_POSIX_SIGNALS)
		  sigprocmask (SIG_SETMASK, (sigset_t *)&pe_sigmask, (sigset_t *)NULL);
#endif
		  continue;
		}

	    default:
	      command_error ("parse_and_execute", CMDERR_BADJUMP, code, 0);
	      break;
	    }
	}
	  
      if (parse_command () == 0)
	{
	  if ((flags & SEVAL_PARSEONLY) || (interactive_shell == 0 && read_but_dont_execute))
	    {
	      last_result = EXECUTION_SUCCESS;
	      dispose_command (global_command);
	      global_command = (COMMAND *)NULL;
	    }
	  else if (command = global_command)
	    {
	      struct fd_bitmap *bitmap;

	      if (flags & SEVAL_FUNCDEF)
		{
		  char *x;

		  /* If the command parses to something other than a straight
		     function definition, or if we have not consumed the entire
		     string, or if the parser has transformed the function
		     name (as parsing will if it begins or ends with shell
		     whitespace, for example), reject the attempt */
		  if (command->type != cm_function_def ||
		      ((x = parser_remaining_input ()) && *x) ||
		      (STREQ (from_file, command->value.Function_def->name->word) == 0))
		    {
		      internal_warning (_("%s: ignoring function definition attempt"), from_file);
		      should_jump_to_top_level = 0;
		      last_result = last_command_exit_value = EX_BADUSAGE;
		      set_pipestatus_from_exit (last_command_exit_value);
		      reset_parser ();
		      break;
		    }
		}

	      bitmap = new_fd_bitmap (FD_BITMAP_SIZE);
	      begin_unwind_frame ("pe_dispose");
	      add_unwind_protect (dispose_fd_bitmap, bitmap);
	      add_unwind_protect (dispose_command, command);	/* XXX */

	      global_command = (COMMAND *)NULL;

	      if ((subshell_environment & SUBSHELL_COMSUB) && comsub_ignore_return)
		command->flags |= CMD_IGNORE_RETURN;

#if defined (ONESHOT)
	      /*
	       * IF
	       *   we were invoked as `bash -c' (startup_state == 2) AND
	       *   parse_and_execute has not been called recursively AND
	       *   we're not running a trap AND
	       *   we have parsed the full command (string == '\0') AND
	       *   we're not going to run the exit trap AND
	       *   we have a simple command without redirections AND
	       *   the command is not being timed AND
	       *   the command's return status is not being inverted AND
	       *   there aren't any traps in effect
	       * THEN
	       *   tell the execution code that we don't need to fork
	       */
	      if (should_suppress_fork (command))
		{
		  command->flags |= CMD_NO_FORK;
		  command->value.Simple->flags |= CMD_NO_FORK;
		}

	      /* Can't optimize forks out here execept for simple commands.
		 This knows that the parser sets up commands as left-side heavy
		 (&& and || are left-associative) and after the single parse,
		 if we are at the end of the command string, the last in a
		 series of connection commands is
		 command->value.Connection->second. */
	      else if (command->type == cm_connection && can_optimize_connection (command))
		{
		  command->value.Connection->second->flags |= CMD_TRY_OPTIMIZING;
		  command->value.Connection->second->value.Simple->flags |= CMD_TRY_OPTIMIZING;
		}
#endif /* ONESHOT */

	      /* See if this is a candidate for $( <file ). */
	      if (startup_state == 2 &&
		  (subshell_environment & SUBSHELL_COMSUB) &&
		  *bash_input.location.string == '\0' &&
		  command->type == cm_simple && !command->redirects &&
		  (command->flags & CMD_TIME_PIPELINE) == 0 &&
		  command->value.Simple->words == 0 &&
		  command->value.Simple->redirects &&
		  command->value.Simple->redirects->next == 0 &&
		  command->value.Simple->redirects->instruction == r_input_direction &&
		  command->value.Simple->redirects->redirector.dest == 0)
		{
		  int r;
		  r = cat_file (command->value.Simple->redirects);
		  last_result = (r < 0) ? EXECUTION_FAILURE : EXECUTION_SUCCESS;
		}
	      else
		last_result = execute_command_internal
				(command, 0, NO_PIPE, NO_PIPE, bitmap);
	      dispose_command (command);
	      dispose_fd_bitmap (bitmap);
	      discard_unwind_frame ("pe_dispose");

	      if (flags & SEVAL_ONECMD)
		{
		  reset_parser ();
		  break;
		}
	    }
	}
      else
	{
	  last_result = EX_BADUSAGE;	/* was EXECUTION_FAILURE */

	  if (interactive_shell == 0 && this_shell_builtin &&
	      (this_shell_builtin == source_builtin || this_shell_builtin == eval_builtin) &&
	      last_command_exit_value == EX_BADSYNTAX && posixly_correct && executing_command_builtin == 0)
	    {
	      should_jump_to_top_level = 1;
	      code = ERREXIT;
	      last_command_exit_value = EX_BADUSAGE;
	    }

	  /* Since we are shell compatible, syntax errors in a script
	     abort the execution of the script.  Right? */
	  break;
	}
    }

 out:

  run_unwind_frame (PE_TAG);

  if (interrupt_state && parse_and_execute_level == 0)
    {
      /* An interrupt during non-interactive execution in an
	 interactive shell (e.g. via $PROMPT_COMMAND) should
	 not cause the shell to exit. */
      interactive = interactive_shell;
      throw_to_top_level ();
    }

  if (should_jump_to_top_level)
    jump_to_top_level (code);

  return (last_result);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\evalstring.c:283
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\evalstring.c:546
parsing error 
{
  int code, nc;
  volatile int should_jump_to_top_level;
  COMMAND *volatile command, *oglobal;
  char *ostring;
  volatile sigset_t ps_sigmask;

  parse_prologue (string, flags, PS_TAG);

#if defined (HAVE_POSIX_SIGNALS)
  /* If we longjmp and are going to go on, use this to restore signal mask */
  sigemptyset ((sigset_t *)&ps_sigmask);
  sigprocmask (SIG_BLOCK, (sigset_t *)NULL, (sigset_t *)&ps_sigmask);
#endif

/*itrace("parse_string: `%s'", string);*/
  /* Reset the line number if the caller wants us to.  If we don't reset the
     line number, we have to subtract one, because we will add one just
     before executing the next command (resetting the line number sets it to
     0; the first line number is 1). */
  push_stream (0);
  if (parser_expanding_alias ())
    /* push current shell_input_line */
    parser_save_alias ();

  code = should_jump_to_top_level = 0;
  oglobal = global_command;
  ostring = string;

  with_input_from_string (string, from_file);
  while (*(bash_input.location.string))		/* XXX - parser_expanding_alias () ? */
    {
      command = (COMMAND *)NULL;

#if 0
      if (interrupt_state)
	break;
#endif

      /* Provide a location for functions which `longjmp (top_level)' to
	 jump to. */
      code = setjmp_nosigs (top_level);

      if (code)
	{
#if defined (DEBUG)
itrace("parse_string: longjmp executed: code = %d", code);
#endif
	  should_jump_to_top_level = 0;
	  switch (code)
	    {
	    case FORCE_EOF:
	    case ERREXIT:
	    case EXITPROG:
	    case DISCARD:		/* XXX */
	      if (command)
		dispose_command (command);
	      /* Remember to call longjmp (top_level) after the old
		 value for it is restored. */
	      should_jump_to_top_level = 1;
	      goto out;

	    default:
#if defined (HAVE_POSIX_SIGNALS)
	      sigprocmask (SIG_SETMASK, (sigset_t *)&ps_sigmask, (sigset_t *)NULL);
#endif
	      command_error ("parse_string", CMDERR_BADJUMP, code, 0);
	      break;
	    }
	}
	  
      if (parse_command () == 0)
	{
	  dispose_command (global_command);
	  global_command = (COMMAND *)NULL;
	}
      else
	{
	  if ((flags & SEVAL_NOLONGJMP) == 0)
	    {
	      should_jump_to_top_level = 1;
	      code = DISCARD;
	    }
	  else
	    reset_parser ();	/* XXX - sets token_to_read */
	  break;
	}

      if (current_token == yacc_EOF || current_token == shell_eof_token)
	  break;
    }

out:

  global_command = oglobal;
  nc = bash_input.location.string - ostring;
  if (endp)
    *endp = bash_input.location.string;

  run_unwind_frame (PS_TAG);

  /* If we return < 0, the caller (xparse_dolparen) will jump_to_top_level for
     us, after doing cleanup */
  if (should_jump_to_top_level)
    {
      if (parse_and_execute_level == 0)
	top_level_cleanup ();
      if (code == DISCARD)
	return -DISCARD;
      jump_to_top_level (code);
    }

  return (nc);
}
warning: parse error {
  int code, nc;
  volatile int should_jump_to_top_level;
  COMMAND *volatile command, *oglobal;
  char *ostring;
  volatile sigset_t ps_sigmask;

  parse_prologue (string, flags, PS_TAG);

#if defined (HAVE_POSIX_SIGNALS)
  /* If we longjmp and are going to go on, use this to restore signal mask */
  sigemptyset ((sigset_t *)&ps_sigmask);
  sigprocmask (SIG_BLOCK, (sigset_t *)NULL, (sigset_t *)&ps_sigmask);
#endif

/*itrace("parse_string: `%s'", string);*/
  /* Reset the line number if the caller wants us to.  If we don't reset the
     line number, we have to subtract one, because we will add one just
     before executing the next command (resetting the line number sets it to
     0; the first line number is 1). */
  push_stream (0);
  if (parser_expanding_alias ())
    /* push current shell_input_line */
    parser_save_alias ();

  code = should_jump_to_top_level = 0;
  oglobal = global_command;
  ostring = string;

  with_input_from_string (string, from_file);
  while (*(bash_input.location.string))		/* XXX - parser_expanding_alias () ? */
    {
      command = (COMMAND *)NULL;

#if 0
      if (interrupt_state)
	break;
#endif

      /* Provide a location for functions which `longjmp (top_level)' to
	 jump to. */
      code = setjmp_nosigs (top_level);

      if (code)
	{
#if defined (DEBUG)
itrace("parse_string: longjmp executed: code = %d", code);
#endif
	  should_jump_to_top_level = 0;
	  switch (code)
	    {
	    case FORCE_EOF:
	    case ERREXIT:
	    case EXITPROG:
	    case DISCARD:		/* XXX */
	      if (command)
		dispose_command (command);
	      /* Remember to call longjmp (top_level) after the old
		 value for it is restored. */
	      should_jump_to_top_level = 1;
	      goto out;

	    default:
#if defined (HAVE_POSIX_SIGNALS)
	      sigprocmask (SIG_SETMASK, (sigset_t *)&ps_sigmask, (sigset_t *)NULL);
#endif
	      command_error ("parse_string", CMDERR_BADJUMP, code, 0);
	      break;
	    }
	}
	  
      if (parse_command () == 0)
	{
	  dispose_command (global_command);
	  global_command = (COMMAND *)NULL;
	}
      else
	{
	  if ((flags & SEVAL_NOLONGJMP) == 0)
	    {
	      should_jump_to_top_level = 1;
	      code = DISCARD;
	    }
	  else
	    reset_parser ();	/* XXX - sets token_to_read */
	  break;
	}

      if (current_token == yacc_EOF || current_token == shell_eof_token)
	  break;
    }

out:

  global_command = oglobal;
  nc = bash_input.location.string - ostring;
  if (endp)
    *endp = bash_input.location.string;

  run_unwind_frame (PS_TAG);

  /* If we return < 0, the caller (xparse_dolparen) will jump_to_top_level for
     us, after doing cleanup */
  if (should_jump_to_top_level)
    {
      if (parse_and_execute_level == 0)
	top_level_cleanup ();
      if (code == DISCARD)
	return -DISCARD;
      jump_to_top_level (code);
    }

  return (nc);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\evalstring.c:551
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\evalstring.c:670
parsing error 
{
  char *fn;
  int fd, rval;

  if (r->instruction != r_input_direction)
    return -1;

  /* Get the filename. */
  if (posixly_correct && !interactive_shell)
    disallow_filename_globbing++;
  fn = redirection_expand (r->redirectee.filename);
  if (posixly_correct && !interactive_shell)
    disallow_filename_globbing--;

  if (fn == 0)
    {
      redirection_error (r, AMBIGUOUS_REDIRECT, fn);
      return -1;
    }

  fd = open(fn, O_RDONLY);
  if (fd < 0)
    {
      file_error (fn);
      free (fn);
      return -1;
    }

  rval = zcatfd (fd, 1, fn);

  free (fn);
  close (fd);

  return (rval);
}
warning: parse error {
  char *fn;
  int fd, rval;

  if (r->instruction != r_input_direction)
    return -1;

  /* Get the filename. */
  if (posixly_correct && !interactive_shell)
    disallow_filename_globbing++;
  fn = redirection_expand (r->redirectee.filename);
  if (posixly_correct && !interactive_shell)
    disallow_filename_globbing--;

  if (fn == 0)
    {
      redirection_error (r, AMBIGUOUS_REDIRECT, fn);
      return -1;
    }

  fd = open(fn, O_RDONLY);
  if (fd < 0)
    {
      file_error (fn);
      free (fn);
      return -1;
    }

  rval = zcatfd (fd, 1, fn);

  free (fn);
  close (fd);

  return (rval);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\evalstring.c:672
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\evalstring.c:709
parsing error 
{
  volatile int r, rflag, rcatch;
  volatile int was_trap;

  /* Are we running a trap when we execute this function? */
  was_trap = running_trap;

  rcatch = 0;
  rflag = return_catch_flag;
  /* If we are in a place where `return' is valid, we have to catch
     `eval "... return"' and make sure parse_and_execute cleans up. Then
     we can trampoline to the previous saved return_catch location. */
  if (rflag)
    {
      begin_unwind_frame ("evalstring");

      unwind_protect_int (return_catch_flag);
      unwind_protect_jmp_buf (return_catch);

      return_catch_flag++;	/* increment so we have a counter */
      rcatch = setjmp_nosigs (return_catch);
    }

  if (rcatch)
    {
      /* We care about whether or not we are running the same trap we were
	 when we entered this function. */
      parse_and_execute_cleanup (was_trap);
      r = return_catch_value;
    }
  else
    /* Note that parse_and_execute () frees the string it is passed. */
    r = parse_and_execute (string, from_file, flags);

  if (rflag)
    {
      run_unwind_frame ("evalstring");
      if (rcatch && return_catch_flag)
	{
	  return_catch_value = r;
	  sh_longjmp (return_catch, 1);
	}
    }
    
  return (r);
}
warning: parse error {
  volatile int r, rflag, rcatch;
  volatile int was_trap;

  /* Are we running a trap when we execute this function? */
  was_trap = running_trap;

  rcatch = 0;
  rflag = return_catch_flag;
  /* If we are in a place where `return' is valid, we have to catch
     `eval "... return"' and make sure parse_and_execute cleans up. Then
     we can trampoline to the previous saved return_catch location. */
  if (rflag)
    {
      begin_unwind_frame ("evalstring");

      unwind_protect_int (return_catch_flag);
      unwind_protect_jmp_buf (return_catch);

      return_catch_flag++;	/* increment so we have a counter */
      rcatch = setjmp_nosigs (return_catch);
    }

  if (rcatch)
    {
      /* We care about whether or not we are running the same trap we were
	 when we entered this function. */
      parse_and_execute_cleanup (was_trap);
      r = return_catch_value;
    }
  else
    /* Note that parse_and_execute () frees the string it is passed. */
    r = parse_and_execute (string, from_file, flags);

  if (rflag)
    {
      run_unwind_frame ("evalstring");
      if (rcatch && return_catch_flag)
	{
	  return_catch_value = r;
	  sh_longjmp (return_catch, 1);
	}
    }
    
  return (r);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\evalstring.c:713
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\gen-helpfiles.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\posixstat.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\filecntl.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashansi.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\stdc.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\gen-helpfiles.c:107
parsing error 
{
  int arg_index = 1;

  while (arg_index < argc && argv[arg_index][0] == '-')
    {
      char *arg = argv[arg_index++];

      if (strcmp (arg, "-noproduction") == 0)
	;
      else if (strcmp (arg, "-H") == 0)
	helpfile_directory = argv[arg_index++];
      else if (strcmp (arg, "-S") == 0)
	single_longdoc_strings = 0;
      else
	{
	  fprintf (stderr, "%s: Unknown flag %s.\n", argv[0], arg);
	  exit (2);
	}
    }

  write_helpfiles(shell_builtins);

  exit (0);
}
warning: parse error {
  int arg_index = 1;

  while (arg_index < argc && argv[arg_index][0] == '-')
    {
      char *arg = argv[arg_index++];

      if (strcmp (arg, "-noproduction") == 0)
	;
      else if (strcmp (arg, "-H") == 0)
	helpfile_directory = argv[arg_index++];
      else if (strcmp (arg, "-S") == 0)
	single_longdoc_strings = 0;
      else
	{
	  fprintf (stderr, "%s: Unknown flag %s.\n", argv[0], arg);
	  exit (2);
	}
    }

  write_helpfiles(shell_builtins);

  exit (0);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\gen-helpfiles.c:110
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\gen-helpfiles.c:140
parsing error 
{
  if (stream == 0)
    return;

  if (documentation)
    fprintf (stream, "%*s%s\n", indentation, " ", documentation);
}
warning: parse error {
  if (stream == 0)
    return;

  if (documentation)
    fprintf (stream, "%*s%s\n", indentation, " ", documentation);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\gen-helpfiles.c:144
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\gen-helpfiles.c:153
parsing error 
{
  char *helpfile, *bname, *fname;
  FILE *helpfp;
  int i, hdlen;
  struct builtin b;

  i = mkdir ("helpfiles", 0777);
  if (i < 0 && errno != EEXIST)
    {
      fprintf (stderr, "write_helpfiles: helpfiles: cannot create directory\n");
      return -1;
    }

  hdlen = strlen ("helpfiles/");
  for (i = 0; i < num_shell_builtins; i++)
    {
      b = builtins[i];

      fname = (char *)b.handle;
      helpfile = (char *)malloc (hdlen + strlen (fname) + 1);
      if (helpfile == 0)
	{
	  fprintf (stderr, "gen-helpfiles: cannot allocate memory\n");
	  exit (1);
	}
      sprintf (helpfile, "helpfiles/%s", fname);

      helpfp = fopen (helpfile, "w");
      if (helpfp == 0)
	{
	  fprintf (stderr, "write_helpfiles: cannot open %s\n", helpfile);
	  free (helpfile);
	  continue;
	}

      write_documentation (helpfp, b.long_doc[0], 4);

      fflush (helpfp);
      fclose (helpfp);
      free (helpfile);
    }
  return 0;
}
warning: parse error {
  char *helpfile, *bname, *fname;
  FILE *helpfp;
  int i, hdlen;
  struct builtin b;

  i = mkdir ("helpfiles", 0777);
  if (i < 0 && errno != EEXIST)
    {
      fprintf (stderr, "write_helpfiles: helpfiles: cannot create directory\n");
      return -1;
    }

  hdlen = strlen ("helpfiles/");
  for (i = 0; i < num_shell_builtins; i++)
    {
      b = builtins[i];

      fname = (char *)b.handle;
      helpfile = (char *)malloc (hdlen + strlen (fname) + 1);
      if (helpfile == 0)
	{
	  fprintf (stderr, "gen-helpfiles: cannot allocate memory\n");
	  exit (1);
	}
      sprintf (helpfile, "helpfiles/%s", fname);

      helpfp = fopen (helpfile, "w");
      if (helpfp == 0)
	{
	  fprintf (stderr, "write_helpfiles: cannot open %s\n", helpfile);
	  free (helpfile);
	  continue;
	}

      write_documentation (helpfp, b.long_doc[0], 4);

      fflush (helpfp);
      fclose (helpfp);
      free (helpfile);
    }
  return 0;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\gen-helpfiles.c:155
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\getopt.c...
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\memalloc.h...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashintl.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\shell.h...skip
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\getopt.h...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\stdc.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\getopt.c:114
parsing error 
{
  char c, *temp;

  sh_optarg = 0;

  if (sh_optind >= argc || sh_optind < 0)	/* XXX was sh_optind > argc */
    {
      sh_optind = argc;
      return (EOF);
    }

  /* Initialize the internal data when the first call is made.
     Start processing options with ARGV-element 1 (since ARGV-element 0
     is the program name); the sequence of previously skipped
     non-option ARGV-elements is empty.  */

  if (sh_optind == 0)
    {
      sh_optind = 1;
      nextchar = (char *)NULL;
    }

  if (nextchar == 0 || *nextchar == '\0')
    {
      /* If we have done all the ARGV-elements, stop the scan. */
      if (sh_optind >= argc)
	return EOF;

      temp = argv[sh_optind];

      /* Special ARGV-element `--' means premature end of options.
	 Skip it like a null option, and return EOF. */
      if (temp[0] == '-' && temp[1] == '-' && temp[2] == '\0')
	{
	  sh_optind++;
	  return EOF;
	}

      /* If we have come to a non-option, either stop the scan or describe
	 it to the caller and pass it by.  This makes the pseudo-option
	 `-' mean the end of options, but does not skip over it. */
      if (temp[0] != '-' || temp[1] == '\0')
	return EOF;

      /* We have found another option-ARGV-element.
	 Start decoding its characters.  */
      nextchar = argv[sh_curopt = sh_optind] + 1;
      sh_charindex = 1;
    }

  /* Look at and handle the next option-character.  */

  c = *nextchar++; sh_charindex++;
  temp = strchr (optstring, c);

  sh_optopt = c;

  /* Increment `sh_optind' when we start to process its last character.  */
  if (nextchar == 0 || *nextchar == '\0')
    {
      sh_optind++;
      nextchar = (char *)NULL;
    }

  if (sh_badopt = (temp == NULL || c == ':'))
    {
      if (sh_opterr)
	BADOPT (c);

      return '?';
    }

  if (temp[1] == ':')
    {
      if (nextchar && *nextchar)
	{
	  /* This is an option that requires an argument.  */
	  sh_optarg = nextchar;
	  /* If we end this ARGV-element by taking the rest as an arg,
	     we must advance to the next element now.  */
	  sh_optind++;
	}
      else if (sh_optind == argc)
	{
	  if (sh_opterr)
	    NEEDARG (c);

	  sh_optopt = c;
	  sh_optarg = "";	/* Needed by getopts. */
	  c = (optstring[0] == ':') ? ':' : '?';
	}
      else
	/* We already incremented `sh_optind' once;
	   increment it again when taking next ARGV-elt as argument.  */
	sh_optarg = argv[sh_optind++];
      nextchar = (char *)NULL;
    }
  return c;
}
warning: parse error {
  char c, *temp;

  sh_optarg = 0;

  if (sh_optind >= argc || sh_optind < 0)	/* XXX was sh_optind > argc */
    {
      sh_optind = argc;
      return (EOF);
    }

  /* Initialize the internal data when the first call is made.
     Start processing options with ARGV-element 1 (since ARGV-element 0
     is the program name); the sequence of previously skipped
     non-option ARGV-elements is empty.  */

  if (sh_optind == 0)
    {
      sh_optind = 1;
      nextchar = (char *)NULL;
    }

  if (nextchar == 0 || *nextchar == '\0')
    {
      /* If we have done all the ARGV-elements, stop the scan. */
      if (sh_optind >= argc)
	return EOF;

      temp = argv[sh_optind];

      /* Special ARGV-element `--' means premature end of options.
	 Skip it like a null option, and return EOF. */
      if (temp[0] == '-' && temp[1] == '-' && temp[2] == '\0')
	{
	  sh_optind++;
	  return EOF;
	}

      /* If we have come to a non-option, either stop the scan or describe
	 it to the caller and pass it by.  This makes the pseudo-option
	 `-' mean the end of options, but does not skip over it. */
      if (temp[0] != '-' || temp[1] == '\0')
	return EOF;

      /* We have found another option-ARGV-element.
	 Start decoding its characters.  */
      nextchar = argv[sh_curopt = sh_optind] + 1;
      sh_charindex = 1;
    }

  /* Look at and handle the next option-character.  */

  c = *nextchar++; sh_charindex++;
  temp = strchr (optstring, c);

  sh_optopt = c;

  /* Increment `sh_optind' when we start to process its last character.  */
  if (nextchar == 0 || *nextchar == '\0')
    {
      sh_optind++;
      nextchar = (char *)NULL;
    }

  if (sh_badopt = (temp == NULL || c == ':'))
    {
      if (sh_opterr)
	BADOPT (c);

      return '?';
    }

  if (temp[1] == ':')
    {
      if (nextchar && *nextchar)
	{
	  /* This is an option that requires an argument.  */
	  sh_optarg = nextchar;
	  /* If we end this ARGV-element by taking the rest as an arg,
	     we must advance to the next element now.  */
	  sh_optind++;
	}
      else if (sh_optind == argc)
	{
	  if (sh_opterr)
	    NEEDARG (c);

	  sh_optopt = c;
	  sh_optarg = "";	/* Needed by getopts. */
	  c = (optstring[0] == ':') ? ':' : '?';
	}
      else
	/* We already incremented `sh_optind' once;
	   increment it again when taking next ARGV-elt as argument.  */
	sh_optarg = argv[sh_optind++];
      nextchar = (char *)NULL;
    }
  return c;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\getopt.c:118
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\getopt.c:219
parsing error 
{
  if (nextchar)
    nextchar = argv[sh_curopt] + sh_charindex;
}
warning: parse error {
  if (nextchar)
    nextchar = argv[sh_curopt] + sh_charindex;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\getopt.c:221
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\getopt.c:236
parsing error 
{
  free (gs);
}
warning: parse error {
  free (gs);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\getopt.c:238
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\getopt.c:260
parsing error 
{
  sh_optarg = state->gs_optarg;
  sh_optind = state->gs_optind;
  sh_curopt = state->gs_curopt;
  nextchar = state->gs_nextchar;	/* XXX - probably not usable */
  sh_charindex = state->gs_charindex;

  sh_getopt_dispose_istate (state);
}
warning: parse error {
  sh_optarg = state->gs_optarg;
  sh_optind = state->gs_optind;
  sh_curopt = state->gs_curopt;
  nextchar = state->gs_nextchar;	/* XXX - probably not usable */
  sh_charindex = state->gs_charindex;

  sh_getopt_dispose_istate (state);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\getopt.c:262
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\mkbuiltins.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\posixstat.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\filecntl.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashansi.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\stdc.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\mkbuiltins.c:214
parsing error 
{
  int arg_index = 1;
  FILE *structfile, *externfile;
  char *documentation_filename, *temp_struct_filename;

  structfile = externfile = (FILE *)NULL;
  documentation_filename = DOCFILE;
  temp_struct_filename = (char *)NULL;

  while (arg_index < argc && argv[arg_index][0] == '-')
    {
      char *arg = argv[arg_index++];

      if (strcmp (arg, "-externfile") == 0)
	extern_filename = argv[arg_index++];
      else if (strcmp (arg, "-structfile") == 0)
	struct_filename = argv[arg_index++];
      else if (strcmp (arg, "-noproduction") == 0)
	inhibit_production = 1;
      else if (strcmp (arg, "-nofunctions") == 0)
	inhibit_functions = 1;
      else if (strcmp (arg, "-document") == 0)
	documentation_file = fopen (documentation_filename, "w");
      else if (strcmp (arg, "-D") == 0)
	{
	  int len;

	  if (error_directory)
	    free (error_directory);

	  error_directory = xmalloc (2 + strlen (argv[arg_index]));
	  strcpy (error_directory, argv[arg_index]);
	  len = strlen (error_directory);

	  if (len && error_directory[len - 1] != '/')
	    strcat (error_directory, "/");

	  arg_index++;
	}
      else if (strcmp (arg, "-documentonly") == 0)
	{
	  only_documentation = 1;
	  documentation_file = fopen (documentation_filename, "w");
	}
      else if (strcmp (arg, "-H") == 0)
        {
	  separate_helpfiles = 1;
	  helpfile_directory = argv[arg_index++];
        }
      else if (strcmp (arg, "-S") == 0)
	single_longdoc_strings = 0;
      else
	{
	  fprintf (stderr, "%s: Unknown flag %s.\n", argv[0], arg);
	  exit (2);
	}
    }

  /* If there are no files to process, just quit now. */
  if (arg_index == argc)
    exit (0);

  if (!only_documentation)
    {
      /* Open the files. */
      if (struct_filename)
	{
	  temp_struct_filename = xmalloc (15);
	  sprintf (temp_struct_filename, "mk-%ld", (long) getpid ());
	  structfile = fopen (temp_struct_filename, "w");

	  if (!structfile)
	    file_error (temp_struct_filename);
	}

      if (extern_filename)
	{
	  externfile = fopen (extern_filename, "w");

	  if (!externfile)
	    file_error (extern_filename);
	}

      /* Write out the headers. */
      write_file_headers (structfile, externfile);
    }

  if (documentation_file)
    {
      fprintf (documentation_file, "@c Table of builtins created with %s.\n",
	       argv[0]);
      fprintf (documentation_file, "@ftable @asis\n");
    }

  /* Process the .def files. */
  while (arg_index < argc)
    {
      register char *arg;

      arg = argv[arg_index++];

      extract_info (arg, structfile, externfile);
    }

  /* Close the files. */
  if (!only_documentation)
    {
      /* Write the footers. */
      write_file_footers (structfile, externfile);

      if (structfile)
	{
	  write_longdocs (structfile, saved_builtins);
	  fclose (structfile);
	  rename (temp_struct_filename, struct_filename);
	}

      if (externfile)
	fclose (externfile);
    }

#if 0
  /* This is now done by a different program */
  if (separate_helpfiles)
    {
      write_helpfiles (saved_builtins);
    }
#endif

  if (documentation_file)
    {
      fprintf (documentation_file, "@end ftable\n");
      fclose (documentation_file);
    }

  exit (0);
}
warning: parse error {
  int arg_index = 1;
  FILE *structfile, *externfile;
  char *documentation_filename, *temp_struct_filename;

  structfile = externfile = (FILE *)NULL;
  documentation_filename = DOCFILE;
  temp_struct_filename = (char *)NULL;

  while (arg_index < argc && argv[arg_index][0] == '-')
    {
      char *arg = argv[arg_index++];

      if (strcmp (arg, "-externfile") == 0)
	extern_filename = argv[arg_index++];
      else if (strcmp (arg, "-structfile") == 0)
	struct_filename = argv[arg_index++];
      else if (strcmp (arg, "-noproduction") == 0)
	inhibit_production = 1;
      else if (strcmp (arg, "-nofunctions") == 0)
	inhibit_functions = 1;
      else if (strcmp (arg, "-document") == 0)
	documentation_file = fopen (documentation_filename, "w");
      else if (strcmp (arg, "-D") == 0)
	{
	  int len;

	  if (error_directory)
	    free (error_directory);

	  error_directory = xmalloc (2 + strlen (argv[arg_index]));
	  strcpy (error_directory, argv[arg_index]);
	  len = strlen (error_directory);

	  if (len && error_directory[len - 1] != '/')
	    strcat (error_directory, "/");

	  arg_index++;
	}
      else if (strcmp (arg, "-documentonly") == 0)
	{
	  only_documentation = 1;
	  documentation_file = fopen (documentation_filename, "w");
	}
      else if (strcmp (arg, "-H") == 0)
        {
	  separate_helpfiles = 1;
	  helpfile_directory = argv[arg_index++];
        }
      else if (strcmp (arg, "-S") == 0)
	single_longdoc_strings = 0;
      else
	{
	  fprintf (stderr, "%s: Unknown flag %s.\n", argv[0], arg);
	  exit (2);
	}
    }

  /* If there are no files to process, just quit now. */
  if (arg_index == argc)
    exit (0);

  if (!only_documentation)
    {
      /* Open the files. */
      if (struct_filename)
	{
	  temp_struct_filename = xmalloc (15);
	  sprintf (temp_struct_filename, "mk-%ld", (long) getpid ());
	  structfile = fopen (temp_struct_filename, "w");

	  if (!structfile)
	    file_error (temp_struct_filename);
	}

      if (extern_filename)
	{
	  externfile = fopen (extern_filename, "w");

	  if (!externfile)
	    file_error (extern_filename);
	}

      /* Write out the headers. */
      write_file_headers (structfile, externfile);
    }

  if (documentation_file)
    {
      fprintf (documentation_file, "@c Table of builtins created with %s.\n",
	       argv[0]);
      fprintf (documentation_file, "@ftable @asis\n");
    }

  /* Process the .def files. */
  while (arg_index < argc)
    {
      register char *arg;

      arg = argv[arg_index++];

      extract_info (arg, structfile, externfile);
    }

  /* Close the files. */
  if (!only_documentation)
    {
      /* Write the footers. */
      write_file_footers (structfile, externfile);

      if (structfile)
	{
	  write_longdocs (structfile, saved_builtins);
	  fclose (structfile);
	  rename (temp_struct_filename, struct_filename);
	}

      if (externfile)
	fclose (externfile);
    }

#if 0
  /* This is now done by a different program */
  if (separate_helpfiles)
    {
      write_helpfiles (saved_builtins);
    }
#endif

  if (documentation_file)
    {
      fprintf (documentation_file, "@end ftable\n");
      fclose (documentation_file);
    }

  exit (0);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\mkbuiltins.c:217
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\mkbuiltins.c:364
parsing error 
{
  ARRAY *array;

  array = (ARRAY *)xmalloc (sizeof (ARRAY));
  array->size = 0;
  array->sindex = 0;
  array->width = width;

  /* Default to increasing size in units of 20. */
  array->growth_rate = 20;

  array->array = (char **)NULL;

  return (array);
}
warning: parse error {
  ARRAY *array;

  array = (ARRAY *)xmalloc (sizeof (ARRAY));
  array->size = 0;
  array->sindex = 0;
  array->width = width;

  /* Default to increasing size in units of 20. */
  array->growth_rate = 20;

  array->array = (char **)NULL;

  return (array);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\mkbuiltins.c:366
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\mkbuiltins.c:384
parsing error 
{
  register int i;
  ARRAY *copy;

  if (!array)
    return (ARRAY *)NULL;

  copy = array_create (sizeof (char *));

  copy->size = array->size;
  copy->sindex = array->sindex;
  copy->width = array->width;

  copy->array = (char **)xmalloc ((1 + array->sindex) * sizeof (char *));
  
  for (i = 0; i < array->sindex; i++)
    copy->array[i] = savestring (array->array[i]);

  copy->array[i] = (char *)NULL;

  return (copy);
}
warning: parse error {
  register int i;
  ARRAY *copy;

  if (!array)
    return (ARRAY *)NULL;

  copy = array_create (sizeof (char *));

  copy->size = array->size;
  copy->sindex = array->sindex;
  copy->width = array->width;

  copy->array = (char **)xmalloc ((1 + array->sindex) * sizeof (char *));
  
  for (i = 0; i < array->sindex; i++)
    copy->array[i] = savestring (array->array[i]);

  copy->array[i] = (char *)NULL;

  return (copy);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\mkbuiltins.c:386
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\mkbuiltins.c:411
parsing error 
{
  if (array->sindex + 2 > array->size)
    array->array = (char **)xrealloc
      (array->array, (array->size += array->growth_rate) * array->width);

  array->array[array->sindex++] = element;
  array->array[array->sindex] = (char *)NULL;
}
warning: parse error {
  if (array->sindex + 2 > array->size)
    array->array = (char **)xrealloc
      (array->array, (array->size += array->growth_rate) * array->width);

  array->array[array->sindex++] = element;
  array->array[array->sindex] = (char *)NULL;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\mkbuiltins.c:414
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\mkbuiltins.c:425
parsing error 
{
  if (array->array)
    free (array->array);

  free (array);
}
warning: parse error {
  if (array->array)
    free (array->array);

  free (array);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\mkbuiltins.c:427
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\mkbuiltins.c:474
parsing error 
{
  register int i;

  for (i = 0; handlers[i].directive; i++)
    if (strcmp (handlers[i].directive, directive) == 0)
      return (&handlers[i]);

  return ((HANDLER_ENTRY *)NULL);
}
warning: parse error {
  register int i;

  for (i = 0; handlers[i].directive; i++)
    if (strcmp (handlers[i].directive, directive) == 0)
      return (&handlers[i]);

  return ((HANDLER_ENTRY *)NULL);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\mkbuiltins.c:476
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\mkbuiltins.c:504
parsing error 
{
  register int i;
  DEF_FILE *defs;
  struct stat finfo;
  size_t file_size;
  char *buffer, *line;
  int fd, nr;

  if (stat (filename, &finfo) == -1)
    file_error (filename);

  fd = open (filename, O_RDONLY, 0666);

  if (fd == -1)
    file_error (filename);

  file_size = (size_t)finfo.st_size;
  buffer = xmalloc (1 + file_size);

  if ((nr = read (fd, buffer, file_size)) < 0)
    file_error (filename);

  /* This is needed on WIN32, and does not hurt on Unix. */
  if (nr < file_size)
    file_size = nr;

  close (fd);

  if (nr == 0)
    {
      fprintf (stderr, "mkbuiltins: %s: skipping zero-length file\n", filename);
      free (buffer);
      return;
    }

  /* Create and fill in the initial structure describing this file. */
  defs = (DEF_FILE *)xmalloc (sizeof (DEF_FILE));
  defs->filename = filename;
  defs->lines = array_create (sizeof (char *));
  defs->line_number = 0;
  defs->production = (char *)NULL;
  defs->output = (FILE *)NULL;
  defs->builtins = (ARRAY *)NULL;

  /* Build the array of lines. */
  i = 0;
  while (i < file_size)
    {
      array_add (&buffer[i], defs->lines);

      while (i < file_size && buffer[i] != '\n')
	i++;
      buffer[i++] = '\0';
    }

  /* Begin processing the input file.  We don't write any output
     until we have a file to write output to. */
  output_cpp_line_info = 1;

  /* Process each line in the array. */
  for (i = 0; line = defs->lines->array[i]; i++)
    {
      defs->line_number = i;

      if (*line == '$')
	{
	  register int j;
	  char *directive;
	  HANDLER_ENTRY *handler;

	  /* Isolate the directive. */
	  for (j = 0; line[j] && !whitespace (line[j]); j++);

	  directive = xmalloc (j);
	  strncpy (directive, line + 1, j - 1);
	  directive[j -1] = '\0';

	  /* Get the function handler and call it. */
	  handler = find_directive (directive);

	  if (!handler)
	    {
	      line_error (defs, "Unknown directive `%s'", directive);
	      free (directive);
	      continue;
	    }
	  else
	    {
	      /* Advance to the first non-whitespace character. */
	      while (whitespace (line[j]))
		j++;

	      /* Call the directive handler with the FILE, and ARGS. */
	      (*(handler->function)) (directive, defs, line + j);
	    }
	  free (directive);
	}
      else
	{
	  if (building_builtin)
	    add_documentation (defs, line);
	  else if (defs->output)
	    {
	      if (output_cpp_line_info)
		{
		  /* If we're handed an absolute pathname, don't prepend
		     the directory name. */
		  if (defs->filename[0] == '/')
		    fprintf (defs->output, "#line %d \"%s\"\n",
			     defs->line_number + 1, defs->filename);
		  else
		    fprintf (defs->output, "#line %d \"%s%s\"\n",
			     defs->line_number + 1,
			     error_directory ? error_directory : "./",
			     defs->filename);
		  output_cpp_line_info = 0;
		}

	      fprintf (defs->output, "%s\n", line);
	    }
	}
    }

  /* Close the production file. */
  if (defs->output)
    fclose (defs->output);

  /* The file has been processed.  Write the accumulated builtins to
     the builtins.c file, and write the extern definitions to the
     builtext.h file. */
  write_builtins (defs, structfile, externfile);

  free (buffer);
  free_defs (defs);
}
warning: parse error {
  register int i;
  DEF_FILE *defs;
  struct stat finfo;
  size_t file_size;
  char *buffer, *line;
  int fd, nr;

  if (stat (filename, &finfo) == -1)
    file_error (filename);

  fd = open (filename, O_RDONLY, 0666);

  if (fd == -1)
    file_error (filename);

  file_size = (size_t)finfo.st_size;
  buffer = xmalloc (1 + file_size);

  if ((nr = read (fd, buffer, file_size)) < 0)
    file_error (filename);

  /* This is needed on WIN32, and does not hurt on Unix. */
  if (nr < file_size)
    file_size = nr;

  close (fd);

  if (nr == 0)
    {
      fprintf (stderr, "mkbuiltins: %s: skipping zero-length file\n", filename);
      free (buffer);
      return;
    }

  /* Create and fill in the initial structure describing this file. */
  defs = (DEF_FILE *)xmalloc (sizeof (DEF_FILE));
  defs->filename = filename;
  defs->lines = array_create (sizeof (char *));
  defs->line_number = 0;
  defs->production = (char *)NULL;
  defs->output = (FILE *)NULL;
  defs->builtins = (ARRAY *)NULL;

  /* Build the array of lines. */
  i = 0;
  while (i < file_size)
    {
      array_add (&buffer[i], defs->lines);

      while (i < file_size && buffer[i] != '\n')
	i++;
      buffer[i++] = '\0';
    }

  /* Begin processing the input file.  We don't write any output
     until we have a file to write output to. */
  output_cpp_line_info = 1;

  /* Process each line in the array. */
  for (i = 0; line = defs->lines->array[i]; i++)
    {
      defs->line_number = i;

      if (*line == '$')
	{
	  register int j;
	  char *directive;
	  HANDLER_ENTRY *handler;

	  /* Isolate the directive. */
	  for (j = 0; line[j] && !whitespace (line[j]); j++);

	  directive = xmalloc (j);
	  strncpy (directive, line + 1, j - 1);
	  directive[j -1] = '\0';

	  /* Get the function handler and call it. */
	  handler = find_directive (directive);

	  if (!handler)
	    {
	      line_error (defs, "Unknown directive `%s'", directive);
	      free (directive);
	      continue;
	    }
	  else
	    {
	      /* Advance to the first non-whitespace character. */
	      while (whitespace (line[j]))
		j++;

	      /* Call the directive handler with the FILE, and ARGS. */
	      (*(handler->function)) (directive, defs, line + j);
	    }
	  free (directive);
	}
      else
	{
	  if (building_builtin)
	    add_documentation (defs, line);
	  else if (defs->output)
	    {
	      if (output_cpp_line_info)
		{
		  /* If we're handed an absolute pathname, don't prepend
		     the directory name. */
		  if (defs->filename[0] == '/')
		    fprintf (defs->output, "#line %d \"%s\"\n",
			     defs->line_number + 1, defs->filename);
		  else
		    fprintf (defs->output, "#line %d \"%s%s\"\n",
			     defs->line_number + 1,
			     error_directory ? error_directory : "./",
			     defs->filename);
		  output_cpp_line_info = 0;
		}

	      fprintf (defs->output, "%s\n", line);
	    }
	}
    }

  /* Close the production file. */
  if (defs->output)
    fclose (defs->output);

  /* The file has been processed.  Write the accumulated builtins to
     the builtins.c file, and write the extern definitions to the
     builtext.h file. */
  write_builtins (defs, structfile, externfile);

  free (buffer);
  free_defs (defs);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\mkbuiltins.c:507
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\mkbuiltins.c:646
parsing error 
{
  register int i;

  free_safely (builtin->name);
  free_safely (builtin->function);
  free_safely (builtin->shortdoc);
  free_safely (builtin->docname);

  if (builtin->longdoc)
    array_free (builtin->longdoc);

  if (builtin->dependencies)
    {
      for (i = 0; builtin->dependencies->array[i]; i++)
	free (builtin->dependencies->array[i]);
      array_free (builtin->dependencies);
    }
}
warning: parse error {
  register int i;

  free_safely (builtin->name);
  free_safely (builtin->function);
  free_safely (builtin->shortdoc);
  free_safely (builtin->docname);

  if (builtin->longdoc)
    array_free (builtin->longdoc);

  if (builtin->dependencies)
    {
      for (i = 0; builtin->dependencies->array[i]; i++)
	free (builtin->dependencies->array[i]);
      array_free (builtin->dependencies);
    }
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\mkbuiltins.c:648
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\mkbuiltins.c:669
parsing error 
{
  register int i;
  register BUILTIN_DESC *builtin;

  if (defs->production)
    free (defs->production);

  if (defs->lines)
    array_free (defs->lines);

  if (defs->builtins)
    {
      for (i = 0; builtin = (BUILTIN_DESC *)defs->builtins->array[i]; i++)
	{
	  free_builtin (builtin);
	  free (builtin);
	}
      array_free (defs->builtins);
    }
  free (defs);
}
warning: parse error {
  register int i;
  register BUILTIN_DESC *builtin;

  if (defs->production)
    free (defs->production);

  if (defs->lines)
    array_free (defs->lines);

  if (defs->builtins)
    {
      for (i = 0; builtin = (BUILTIN_DESC *)defs->builtins->array[i]; i++)
	{
	  free_builtin (builtin);
	  free (builtin);
	}
      array_free (defs->builtins);
    }
  free (defs);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\mkbuiltins.c:671
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\mkbuiltins.c:702
parsing error 
{
  while (whitespace (*string))
      string++;

  remove_trailing_whitespace (string);
  return (string);
}
warning: parse error {
  while (whitespace (*string))
      string++;

  remove_trailing_whitespace (string);
  return (string);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\mkbuiltins.c:704
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\mkbuiltins.c:714
parsing error 
{
  register int i;

  i = strlen (string) - 1;

  while (i > 0 && whitespace (string[i]))
    i--;

  string[++i] = '\0';
}
warning: parse error {
  register int i;

  i = strlen (string) - 1;

  while (i > 0 && whitespace (string[i]))
    i--;

  string[++i] = '\0';
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\mkbuiltins.c:716
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\mkbuiltins.c:732
parsing error 
{
  char *new;

  new = strip_whitespace (string);

  if (!*new)
    line_error (defs, "%s requires an argument", for_whom);

  return (savestring (new));
}
warning: parse error {
  char *new;

  new = strip_whitespace (string);

  if (!*new)
    line_error (defs, "%s requires an argument", for_whom);

  return (savestring (new));
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\mkbuiltins.c:735
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\mkbuiltins.c:748
parsing error 
{
  if (!building_builtin)
    line_error (defs, "%s must be inside of a $BUILTIN block", directive);
}
warning: parse error {
  if (!building_builtin)
    line_error (defs, "%s must be inside of a $BUILTIN block", directive);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\mkbuiltins.c:751
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\mkbuiltins.c:758
parsing error 
{
  must_be_building (directive, defs);
  if (defs->builtins)
    return ((BUILTIN_DESC *)defs->builtins->array[defs->builtins->sindex - 1]);
  else
    return ((BUILTIN_DESC *)NULL);
}
warning: parse error {
  must_be_building (directive, defs);
  if (defs->builtins)
    return ((BUILTIN_DESC *)defs->builtins->array[defs->builtins->sindex - 1]);
  else
    return ((BUILTIN_DESC *)NULL);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\mkbuiltins.c:761
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\mkbuiltins.c:772
parsing error 
{
  register BUILTIN_DESC *builtin;

  builtin = current_builtin ("(implied LONGDOC)", defs);

  remove_trailing_whitespace (line);

  if (!*line && !builtin->longdoc)
    return;

  if (!builtin->longdoc)
    builtin->longdoc = array_create (sizeof (char *));

  array_add (line, builtin->longdoc);
}
warning: parse error {
  register BUILTIN_DESC *builtin;

  builtin = current_builtin ("(implied LONGDOC)", defs);

  remove_trailing_whitespace (line);

  if (!*line && !builtin->longdoc)
    return;

  if (!builtin->longdoc)
    builtin->longdoc = array_create (sizeof (char *));

  array_add (line, builtin->longdoc);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\mkbuiltins.c:775
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\mkbuiltins.c:793
parsing error 
{
  BUILTIN_DESC *new;
  char *name;

  /* If we are already building a builtin, we cannot start a new one. */
  if (building_builtin)
    {
      line_error (defs, "%s found before $END", self);
      return (-1);
    }

  output_cpp_line_info++;

  /* Get the name of this builtin, and stick it in the array. */
  name = get_arg (self, defs, arg);

  /* If this is the first builtin, create the array to hold them. */
  if (!defs->builtins)
    defs->builtins = array_create (sizeof (BUILTIN_DESC *));

  new = (BUILTIN_DESC *)xmalloc (sizeof (BUILTIN_DESC));
  new->name = name;
  new->function = (char *)NULL;
  new->shortdoc = (char *)NULL;
  new->docname = (char *)NULL;
  new->longdoc = (ARRAY *)NULL;
  new->dependencies = (ARRAY *)NULL;
  new->flags = 0;

  if (is_special_builtin (name))
    new->flags |= BUILTIN_FLAG_SPECIAL;
  if (is_assignment_builtin (name))
    new->flags |= BUILTIN_FLAG_ASSIGNMENT;
  if (is_localvar_builtin (name))
    new->flags |= BUILTIN_FLAG_LOCALVAR;
  if (is_posix_builtin (name))
    new->flags |= BUILTIN_FLAG_POSIX_BUILTIN;

  array_add ((char *)new, defs->builtins);
  building_builtin = 1;

  return (0);
}
warning: parse error {
  BUILTIN_DESC *new;
  char *name;

  /* If we are already building a builtin, we cannot start a new one. */
  if (building_builtin)
    {
      line_error (defs, "%s found before $END", self);
      return (-1);
    }

  output_cpp_line_info++;

  /* Get the name of this builtin, and stick it in the array. */
  name = get_arg (self, defs, arg);

  /* If this is the first builtin, create the array to hold them. */
  if (!defs->builtins)
    defs->builtins = array_create (sizeof (BUILTIN_DESC *));

  new = (BUILTIN_DESC *)xmalloc (sizeof (BUILTIN_DESC));
  new->name = name;
  new->function = (char *)NULL;
  new->shortdoc = (char *)NULL;
  new->docname = (char *)NULL;
  new->longdoc = (ARRAY *)NULL;
  new->dependencies = (ARRAY *)NULL;
  new->flags = 0;

  if (is_special_builtin (name))
    new->flags |= BUILTIN_FLAG_SPECIAL;
  if (is_assignment_builtin (name))
    new->flags |= BUILTIN_FLAG_ASSIGNMENT;
  if (is_localvar_builtin (name))
    new->flags |= BUILTIN_FLAG_LOCALVAR;
  if (is_posix_builtin (name))
    new->flags |= BUILTIN_FLAG_POSIX_BUILTIN;

  array_add ((char *)new, defs->builtins);
  building_builtin = 1;

  return (0);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\mkbuiltins.c:797
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\mkbuiltins.c:843
parsing error 
{
  register BUILTIN_DESC *builtin;

  builtin = current_builtin (self, defs);

  if (builtin == 0)
    {
      line_error (defs, "syntax error: no current builtin for $FUNCTION directive");
      exit (1);
    }
  if (builtin->function)
    line_error (defs, "%s already has a function (%s)",
		builtin->name, builtin->function);
  else
    builtin->function = get_arg (self, defs, arg);

  return (0);
}
warning: parse error {
  register BUILTIN_DESC *builtin;

  builtin = current_builtin (self, defs);

  if (builtin == 0)
    {
      line_error (defs, "syntax error: no current builtin for $FUNCTION directive");
      exit (1);
    }
  if (builtin->function)
    line_error (defs, "%s already has a function (%s)",
		builtin->name, builtin->function);
  else
    builtin->function = get_arg (self, defs, arg);

  return (0);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\mkbuiltins.c:847
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\mkbuiltins.c:868
parsing error 
{
  register BUILTIN_DESC *builtin;

  builtin = current_builtin (self, defs);

  if (builtin->docname)
    line_error (defs, "%s already had a docname (%s)",
		builtin->name, builtin->docname);
  else
    builtin->docname = get_arg (self, defs, arg);

  return (0);
}
warning: parse error {
  register BUILTIN_DESC *builtin;

  builtin = current_builtin (self, defs);

  if (builtin->docname)
    line_error (defs, "%s already had a docname (%s)",
		builtin->name, builtin->docname);
  else
    builtin->docname = get_arg (self, defs, arg);

  return (0);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\mkbuiltins.c:872
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\mkbuiltins.c:888
parsing error 
{
  register BUILTIN_DESC *builtin;

  builtin = current_builtin (self, defs);

  if (builtin->shortdoc)
    line_error (defs, "%s already has short documentation (%s)",
		builtin->name, builtin->shortdoc);
  else
    builtin->shortdoc = get_arg (self, defs, arg);

  return (0);
}
warning: parse error {
  register BUILTIN_DESC *builtin;

  builtin = current_builtin (self, defs);

  if (builtin->shortdoc)
    line_error (defs, "%s already has short documentation (%s)",
		builtin->name, builtin->shortdoc);
  else
    builtin->shortdoc = get_arg (self, defs, arg);

  return (0);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\mkbuiltins.c:892
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\mkbuiltins.c:908
parsing error 
{
  return (0);
}
warning: parse error {
  return (0);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\mkbuiltins.c:912
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\mkbuiltins.c:918
parsing error 
{
  register BUILTIN_DESC *builtin;
  char *dependent;

  builtin = current_builtin (self, defs);
  dependent = get_arg (self, defs, arg);

  if (!builtin->dependencies)
    builtin->dependencies = array_create (sizeof (char *));

  array_add (dependent, builtin->dependencies);

  return (0);
}
warning: parse error {
  register BUILTIN_DESC *builtin;
  char *dependent;

  builtin = current_builtin (self, defs);
  dependent = get_arg (self, defs, arg);

  if (!builtin->dependencies)
    builtin->dependencies = array_create (sizeof (char *));

  array_add (dependent, builtin->dependencies);

  return (0);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\mkbuiltins.c:922
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\mkbuiltins.c:939
parsing error 
{
  /* If just hacking documentation, don't change any of the production
     files. */
  if (only_documentation)
    return (0);

  output_cpp_line_info++;

  if (defs->production)
    line_error (defs, "%s already has a %s definition", defs->filename, self);
  else
    {
      defs->production = get_arg (self, defs, arg);

      if (inhibit_production)
	return (0);

      defs->output = fopen (defs->production, "w");

      if (!defs->output)
	file_error (defs->production);

      fprintf (defs->output, "/* %s, created from %s. */\n",
	       defs->production, defs->filename);
    }
  return (0);
}
warning: parse error {
  /* If just hacking documentation, don't change any of the production
     files. */
  if (only_documentation)
    return (0);

  output_cpp_line_info++;

  if (defs->production)
    line_error (defs, "%s already has a %s definition", defs->filename, self);
  else
    {
      defs->production = get_arg (self, defs, arg);

      if (inhibit_production)
	return (0);

      defs->output = fopen (defs->production, "w");

      if (!defs->output)
	file_error (defs->production);

      fprintf (defs->output, "/* %s, created from %s. */\n",
	       defs->production, defs->filename);
    }
  return (0);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\mkbuiltins.c:943
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\mkbuiltins.c:973
parsing error 
{
  must_be_building (self, defs);
  building_builtin = 0;
  return (0);
}
warning: parse error {
  must_be_building (self, defs);
  building_builtin = 0;
  return (0);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\mkbuiltins.c:977
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\mkbuiltins.c:991
parsing error 
{
  if (defs->filename[0] != '/')
    fprintf (stderr, "%s", error_directory ? error_directory : "./");
  fprintf (stderr, "%s:%d:", defs->filename, defs->line_number + 1);
  fprintf (stderr, format, arg1, arg2);
  fprintf (stderr, "\n");
  fflush (stderr);
}
warning: parse error {
  if (defs->filename[0] != '/')
    fprintf (stderr, "%s", error_directory ? error_directory : "./");
  fprintf (stderr, "%s:%d:", defs->filename, defs->line_number + 1);
  fprintf (stderr, format, arg1, arg2);
  fprintf (stderr, "\n");
  fflush (stderr);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\mkbuiltins.c:994
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\mkbuiltins.c:1,005
parsing error 
{
  perror (filename);
  exit (2);
}
warning: parse error {
  perror (filename);
  exit (2);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\mkbuiltins.c:1,007
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\mkbuiltins.c:1,021
parsing error 
{
  char *temp = (char *)malloc (bytes);

  if (!temp)
    memory_error_and_abort ();
  return (temp);
}
warning: parse error {
  char *temp = (char *)malloc (bytes);

  if (!temp)
    memory_error_and_abort ();
  return (temp);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\mkbuiltins.c:1,023
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\mkbuiltins.c:1,032
parsing error 
{
  char *temp;

  if (!pointer)
    temp = (char *)malloc (bytes);
  else
    temp = (char *)realloc (pointer, bytes);

  if (!temp)
    memory_error_and_abort ();

  return (temp);
}
warning: parse error {
  char *temp;

  if (!pointer)
    temp = (char *)malloc (bytes);
  else
    temp = (char *)realloc (pointer, bytes);

  if (!temp)
    memory_error_and_abort ();

  return (temp);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\mkbuiltins.c:1,035
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\mkbuiltins.c:1,065
parsing error 
{
  BUILTIN_DESC *new;

  new = (BUILTIN_DESC *)xmalloc (sizeof (BUILTIN_DESC));

  new->name = savestring (builtin->name);
  new->shortdoc = savestring (builtin->shortdoc);
  new->longdoc = copy_string_array (builtin->longdoc);
  new->dependencies = copy_string_array (builtin->dependencies);

  new->function =
    builtin->function ? savestring (builtin->function) : (char *)NULL;
  new->docname =
    builtin->docname  ? savestring (builtin->docname)  : (char *)NULL;

  return (new);
}
warning: parse error {
  BUILTIN_DESC *new;

  new = (BUILTIN_DESC *)xmalloc (sizeof (BUILTIN_DESC));

  new->name = savestring (builtin->name);
  new->shortdoc = savestring (builtin->shortdoc);
  new->longdoc = copy_string_array (builtin->longdoc);
  new->dependencies = copy_string_array (builtin->dependencies);

  new->function =
    builtin->function ? savestring (builtin->function) : (char *)NULL;
  new->docname =
    builtin->docname  ? savestring (builtin->docname)  : (char *)NULL;

  return (new);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\mkbuiltins.c:1,067
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\mkbuiltins.c:1,087
parsing error 
{
  BUILTIN_DESC *newbuiltin;

  newbuiltin = copy_builtin (builtin);

  /* If this is the first builtin to be saved, create the array
     to hold it. */
  if (!saved_builtins)
      saved_builtins = array_create (sizeof (BUILTIN_DESC *));

  array_add ((char *)newbuiltin, saved_builtins);
}
warning: parse error {
  BUILTIN_DESC *newbuiltin;

  newbuiltin = copy_builtin (builtin);

  /* If this is the first builtin to be saved, create the array
     to hold it. */
  if (!saved_builtins)
      saved_builtins = array_create (sizeof (BUILTIN_DESC *));

  array_add ((char *)newbuiltin, saved_builtins);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\mkbuiltins.c:1,089
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\mkbuiltins.c:1,165
parsing error 
{
  register int i;

  if (structfile)
    {
      for (i = 0; structfile_header[i]; i++)
	fprintf (structfile, "%s\n", structfile_header[i]);

      fprintf (structfile, "#include \"%s\"\n",
	       extern_filename ? extern_filename : "builtext.h");

      fprintf (structfile, "#include \"bashintl.h\"\n");

      fprintf (structfile, "\nstruct builtin static_shell_builtins[] = {\n");
    }

  if (externfile)
    fprintf (externfile,
	     "/* %s - The list of builtins found in libbuiltins.a. */\n",
	     extern_filename ? extern_filename : "builtext.h");
}
warning: parse error {
  register int i;

  if (structfile)
    {
      for (i = 0; structfile_header[i]; i++)
	fprintf (structfile, "%s\n", structfile_header[i]);

      fprintf (structfile, "#include \"%s\"\n",
	       extern_filename ? extern_filename : "builtext.h");

      fprintf (structfile, "#include \"bashintl.h\"\n");

      fprintf (structfile, "\nstruct builtin static_shell_builtins[] = {\n");
    }

  if (externfile)
    fprintf (externfile,
	     "/* %s - The list of builtins found in libbuiltins.a. */\n",
	     extern_filename ? extern_filename : "builtext.h");
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\mkbuiltins.c:1,167
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\mkbuiltins.c:1,192
parsing error 
{
  register int i;

  /* Write out the footers. */
  if (structfile)
    {
      for (i = 0; structfile_footer[i]; i++)
	fprintf (structfile, "%s\n", structfile_footer[i]);
    }
}
warning: parse error {
  register int i;

  /* Write out the footers. */
  if (structfile)
    {
      for (i = 0; structfile_footer[i]; i++)
	fprintf (structfile, "%s\n", structfile_footer[i]);
    }
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\mkbuiltins.c:1,194
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\mkbuiltins.c:1,208
parsing error 
{
  register int i;

  /* Write out the information. */
  if (defs->builtins)
    {
      register BUILTIN_DESC *builtin;

      for (i = 0; i < defs->builtins->sindex; i++)
	{
	  builtin = (BUILTIN_DESC *)defs->builtins->array[i];

	  /* Write out any #ifdefs that may be there. */
	  if (!only_documentation)
	    {
	      if (builtin->dependencies)
		{
		  write_ifdefs (externfile, builtin->dependencies->array);
		  write_ifdefs (structfile, builtin->dependencies->array);
		}

	      /* Write the extern definition. */
	      if (externfile)
		{
		  if (builtin->function)
		    fprintf (externfile, "extern int %s PARAMS((WORD_LIST *));\n",
			     builtin->function);

		  fprintf (externfile, "extern char * const %s_doc[];\n",
			   document_name (builtin));
		}

	      /* Write the structure definition. */
	      if (structfile)
		{
		  fprintf (structfile, "  { \"%s\", ", builtin->name);

		  if (builtin->function && inhibit_functions == 0)
		    fprintf (structfile, "%s, ", builtin->function);
		  else
		    fprintf (structfile, "(sh_builtin_func_t *)0x0, ");

		  fprintf (structfile, "%s%s%s%s%s, %s_doc,\n",
		    "BUILTIN_ENABLED | STATIC_BUILTIN",
		    (builtin->flags & BUILTIN_FLAG_SPECIAL) ? " | SPECIAL_BUILTIN" : "",
		    (builtin->flags & BUILTIN_FLAG_ASSIGNMENT) ? " | ASSIGNMENT_BUILTIN" : "",
		    (builtin->flags & BUILTIN_FLAG_LOCALVAR) ? " | LOCALVAR_BUILTIN" : "",
		    (builtin->flags & BUILTIN_FLAG_POSIX_BUILTIN) ? " | POSIX_BUILTIN" : "",
		    document_name (builtin));

		  /* Don't translate short document summaries that are identical
		     to command names */
		  if (builtin->shortdoc && strcmp (builtin->name, builtin->shortdoc) == 0)
		    {
		      if (inhibit_functions)
			fprintf (structfile, "     \"%s\", \"%s\" },\n",
			  builtin->shortdoc ? builtin->shortdoc : builtin->name,
			  document_name (builtin));
		      else
			fprintf (structfile, "     \"%s\", (char *)NULL },\n",
			  builtin->shortdoc ? builtin->shortdoc : builtin->name);
		    }
		  else
		    {
		      if (inhibit_functions)
			fprintf (structfile, "     N_(\"%s\"), \"%s\" },\n",
			  builtin->shortdoc ? builtin->shortdoc : builtin->name,
			  document_name (builtin));
		      else
			fprintf (structfile, "     N_(\"%s\"), (char *)NULL },\n",
			  builtin->shortdoc ? builtin->shortdoc : builtin->name);
		    }
		}

	      if (structfile || separate_helpfiles)
		/* Save away this builtin for later writing of the
		   long documentation strings. */
		save_builtin (builtin);

	      /* Write out the matching #endif, if necessary. */
	      if (builtin->dependencies)
		{
		  if (externfile)
		    write_endifs (externfile, builtin->dependencies->array);

		  if (structfile)
		    write_endifs (structfile, builtin->dependencies->array);
		}
	    }

	  if (documentation_file)
	    {
	      fprintf (documentation_file, "@item %s\n", builtin->name);
	      write_documentation
		(documentation_file, builtin->longdoc->array, 0, TEXINFO);
	    }
	}
    }
}
warning: parse error {
  register int i;

  /* Write out the information. */
  if (defs->builtins)
    {
      register BUILTIN_DESC *builtin;

      for (i = 0; i < defs->builtins->sindex; i++)
	{
	  builtin = (BUILTIN_DESC *)defs->builtins->array[i];

	  /* Write out any #ifdefs that may be there. */
	  if (!only_documentation)
	    {
	      if (builtin->dependencies)
		{
		  write_ifdefs (externfile, builtin->dependencies->array);
		  write_ifdefs (structfile, builtin->dependencies->array);
		}

	      /* Write the extern definition. */
	      if (externfile)
		{
		  if (builtin->function)
		    fprintf (externfile, "extern int %s PARAMS((WORD_LIST *));\n",
			     builtin->function);

		  fprintf (externfile, "extern char * const %s_doc[];\n",
			   document_name (builtin));
		}

	      /* Write the structure definition. */
	      if (structfile)
		{
		  fprintf (structfile, "  { \"%s\", ", builtin->name);

		  if (builtin->function && inhibit_functions == 0)
		    fprintf (structfile, "%s, ", builtin->function);
		  else
		    fprintf (structfile, "(sh_builtin_func_t *)0x0, ");

		  fprintf (structfile, "%s%s%s%s%s, %s_doc,\n",
		    "BUILTIN_ENABLED | STATIC_BUILTIN",
		    (builtin->flags & BUILTIN_FLAG_SPECIAL) ? " | SPECIAL_BUILTIN" : "",
		    (builtin->flags & BUILTIN_FLAG_ASSIGNMENT) ? " | ASSIGNMENT_BUILTIN" : "",
		    (builtin->flags & BUILTIN_FLAG_LOCALVAR) ? " | LOCALVAR_BUILTIN" : "",
		    (builtin->flags & BUILTIN_FLAG_POSIX_BUILTIN) ? " | POSIX_BUILTIN" : "",
		    document_name (builtin));

		  /* Don't translate short document summaries that are identical
		     to command names */
		  if (builtin->shortdoc && strcmp (builtin->name, builtin->shortdoc) == 0)
		    {
		      if (inhibit_functions)
			fprintf (structfile, "     \"%s\", \"%s\" },\n",
			  builtin->shortdoc ? builtin->shortdoc : builtin->name,
			  document_name (builtin));
		      else
			fprintf (structfile, "     \"%s\", (char *)NULL },\n",
			  builtin->shortdoc ? builtin->shortdoc : builtin->name);
		    }
		  else
		    {
		      if (inhibit_functions)
			fprintf (structfile, "     N_(\"%s\"), \"%s\" },\n",
			  builtin->shortdoc ? builtin->shortdoc : builtin->name,
			  document_name (builtin));
		      else
			fprintf (structfile, "     N_(\"%s\"), (char *)NULL },\n",
			  builtin->shortdoc ? builtin->shortdoc : builtin->name);
		    }
		}

	      if (structfile || separate_helpfiles)
		/* Save away this builtin for later writing of the
		   long documentation strings. */
		save_builtin (builtin);

	      /* Write out the matching #endif, if necessary. */
	      if (builtin->dependencies)
		{
		  if (externfile)
		    write_endifs (externfile, builtin->dependencies->array);

		  if (structfile)
		    write_endifs (structfile, builtin->dependencies->array);
		}
	    }

	  if (documentation_file)
	    {
	      fprintf (documentation_file, "@item %s\n", builtin->name);
	      write_documentation
		(documentation_file, builtin->longdoc->array, 0, TEXINFO);
	    }
	}
    }
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\mkbuiltins.c:1,211
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\mkbuiltins.c:1,313
parsing error 
{
  register int i;
  register BUILTIN_DESC *builtin;
  char *dname;
  char *sarray[2];

  for (i = 0; i < builtins->sindex; i++)
    {
      builtin = (BUILTIN_DESC *)builtins->array[i];

      if (builtin->dependencies)
	write_ifdefs (stream, builtin->dependencies->array);

      /* Write the long documentation strings. */
      dname = document_name (builtin);
      fprintf (stream, "char * const %s_doc[] =", dname);

      if (separate_helpfiles)
	{
	  int l = strlen (helpfile_directory) + strlen (dname) + 1;
	  sarray[0] = (char *)xmalloc (l + 1);
	  sprintf (sarray[0], "%s/%s", helpfile_directory, dname);
	  sarray[1] = (char *)NULL;
	  write_documentation (stream, sarray, 0, STRING_ARRAY|HELPFILE);
	  free (sarray[0]);
	}
      else
	write_documentation (stream, builtin->longdoc->array, 0, STRING_ARRAY);

      if (builtin->dependencies)
	write_endifs (stream, builtin->dependencies->array);

    }
}
warning: parse error {
  register int i;
  register BUILTIN_DESC *builtin;
  char *dname;
  char *sarray[2];

  for (i = 0; i < builtins->sindex; i++)
    {
      builtin = (BUILTIN_DESC *)builtins->array[i];

      if (builtin->dependencies)
	write_ifdefs (stream, builtin->dependencies->array);

      /* Write the long documentation strings. */
      dname = document_name (builtin);
      fprintf (stream, "char * const %s_doc[] =", dname);

      if (separate_helpfiles)
	{
	  int l = strlen (helpfile_directory) + strlen (dname) + 1;
	  sarray[0] = (char *)xmalloc (l + 1);
	  sprintf (sarray[0], "%s/%s", helpfile_directory, dname);
	  sarray[1] = (char *)NULL;
	  write_documentation (stream, sarray, 0, STRING_ARRAY|HELPFILE);
	  free (sarray[0]);
	}
      else
	write_documentation (stream, builtin->longdoc->array, 0, STRING_ARRAY);

      if (builtin->dependencies)
	write_endifs (stream, builtin->dependencies->array);

    }
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\mkbuiltins.c:1,316
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\mkbuiltins.c:1,352
parsing error 
{
  register int i;
  BUILTIN_DESC *builtin;

  for (i = 0; structfile_header[i]; i++)
    fprintf (stream, "%s\n", structfile_header[i]);

  for (i = 0; i < builtins->sindex; i++)
    {
      builtin = (BUILTIN_DESC *)builtins->array[i];

      /* How to guarantee that no builtin is written more than once? */
      fprintf (stream, "int %s () { return (0); }\n", builtin->function);
    }
}
warning: parse error {
  register int i;
  BUILTIN_DESC *builtin;

  for (i = 0; structfile_header[i]; i++)
    fprintf (stream, "%s\n", structfile_header[i]);

  for (i = 0; i < builtins->sindex; i++)
    {
      builtin = (BUILTIN_DESC *)builtins->array[i];

      /* How to guarantee that no builtin is written more than once? */
      fprintf (stream, "int %s () { return (0); }\n", builtin->function);
    }
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\mkbuiltins.c:1,355
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\mkbuiltins.c:1,378
parsing error 
{
  register int i;

  if (!stream)
    return;

  fprintf (stream, "#if ");

  for (i = 0; defines[i]; i++)
    {
      char *def = defines[i];

      if (*def == '!')
	fprintf (stream, "!defined (%s)", def + 1);
      else
	fprintf (stream, "defined (%s)", def);

      if (defines[i + 1])
	fprintf (stream, " && ");
    }
  fprintf (stream, "\n");
}
warning: parse error {
  register int i;

  if (!stream)
    return;

  fprintf (stream, "#if ");

  for (i = 0; defines[i]; i++)
    {
      char *def = defines[i];

      if (*def == '!')
	fprintf (stream, "!defined (%s)", def + 1);
      else
	fprintf (stream, "defined (%s)", def);

      if (defines[i + 1])
	fprintf (stream, " && ");
    }
  fprintf (stream, "\n");
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\mkbuiltins.c:1,381
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\mkbuiltins.c:1,409
parsing error 
{
  register int i;

  if (!stream)
    return;

  fprintf (stream, "#endif /* ");

  for (i = 0; defines[i]; i++)
    {
      fprintf (stream, "%s", defines[i]);

      if (defines[i + 1])
	fprintf (stream, " && ");
    }

  fprintf (stream, " */\n");
}
warning: parse error {
  register int i;

  if (!stream)
    return;

  fprintf (stream, "#endif /* ");

  for (i = 0; defines[i]; i++)
    {
      fprintf (stream, "%s", defines[i]);

      if (defines[i + 1])
	fprintf (stream, " && ");
    }

  fprintf (stream, " */\n");
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\mkbuiltins.c:1,412
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\mkbuiltins.c:1,436
parsing error 
{
  register int i, j;
  register char *line;
  int string_array, texinfo, base_indent, filename_p;

  if (stream == 0)
    return;

  string_array = flags & STRING_ARRAY;
  filename_p = flags & HELPFILE;

  if (string_array)
    {
      fprintf (stream, " {\n#if defined (HELP_BUILTIN)\n");	/* } */
      if (single_longdoc_strings)
	{
	  if (filename_p == 0)
	    {
	      if (documentation && documentation[0] && documentation[0][0])
		fprintf (stream,  "N_(\"");
	      else
		fprintf (stream, "N_(\" ");		/* the empty string translates specially. */
	    }
	  else
	    fprintf (stream, "\"");
	}
    }

  base_indent = (string_array && single_longdoc_strings && filename_p == 0) ? BASE_INDENT : 0;

  for (i = 0, texinfo = (flags & TEXINFO); documentation && (line = documentation[i]); i++)
    {
      /* Allow #ifdef's to be written out verbatim, but don't put them into
	 separate help files. */
      if (*line == '#')
	{
	  if (string_array && filename_p == 0 && single_longdoc_strings == 0)
	    fprintf (stream, "%s\n", line);
	  continue;
	}

      /* prefix with N_( for gettext */
      if (string_array && single_longdoc_strings == 0)
	{
	  if (filename_p == 0)
	    {
	      if (line[0])	      
		fprintf (stream, "  N_(\"");
	      else
		fprintf (stream, "  N_(\" ");		/* the empty string translates specially. */
	    }
	  else
	    fprintf (stream, "  \"");
	}

      if (indentation)
	for (j = 0; j < indentation; j++)
	  fprintf (stream, " ");

      /* Don't indent the first line, because of how the help builtin works. */
      if (i == 0)
	indentation += base_indent;

      if (string_array)
	{
	  for (j = 0; line[j]; j++)
	    {
	      switch (line[j])
		{
		case '\\':
		case '"':
		  fprintf (stream, "\\%c", line[j]);
		  break;

		default:
		  fprintf (stream, "%c", line[j]);
		}
	    }

	  /* closing right paren for gettext */
	  if (single_longdoc_strings == 0)
	    {
	      if (filename_p == 0)
		fprintf (stream, "\"),\n");
	      else
		fprintf (stream, "\",\n");
	    }
	  else if (documentation[i+1])
	    /* don't add extra newline after last line */
	    fprintf (stream, "\\n\\\n");
	}
      else if (texinfo)
	{
	  for (j = 0; line[j]; j++)
	    {
	      switch (line[j])
		{
		case '@':
		case '{':
		case '}':
		  fprintf (stream, "@%c", line[j]);
		  break;

		default:
		  fprintf (stream, "%c", line[j]);
		}
	    }
	  fprintf (stream, "\n");
	}
      else
	fprintf (stream, "%s\n", line);
    }

  /* closing right paren for gettext */
  if (string_array && single_longdoc_strings)
    {
      if (filename_p == 0)
	fprintf (stream, "\"),\n");
      else
	fprintf (stream, "\",\n");
    }

  if (string_array)
    fprintf (stream, "#endif /* HELP_BUILTIN */\n  (char *)NULL\n};\n");
}
warning: parse error {
  register int i, j;
  register char *line;
  int string_array, texinfo, base_indent, filename_p;

  if (stream == 0)
    return;

  string_array = flags & STRING_ARRAY;
  filename_p = flags & HELPFILE;

  if (string_array)
    {
      fprintf (stream, " {\n#if defined (HELP_BUILTIN)\n");	/* } */
      if (single_longdoc_strings)
	{
	  if (filename_p == 0)
	    {
	      if (documentation && documentation[0] && documentation[0][0])
		fprintf (stream,  "N_(\"");
	      else
		fprintf (stream, "N_(\" ");		/* the empty string translates specially. */
	    }
	  else
	    fprintf (stream, "\"");
	}
    }

  base_indent = (string_array && single_longdoc_strings && filename_p == 0) ? BASE_INDENT : 0;

  for (i = 0, texinfo = (flags & TEXINFO); documentation && (line = documentation[i]); i++)
    {
      /* Allow #ifdef's to be written out verbatim, but don't put them into
	 separate help files. */
      if (*line == '#')
	{
	  if (string_array && filename_p == 0 && single_longdoc_strings == 0)
	    fprintf (stream, "%s\n", line);
	  continue;
	}

      /* prefix with N_( for gettext */
      if (string_array && single_longdoc_strings == 0)
	{
	  if (filename_p == 0)
	    {
	      if (line[0])	      
		fprintf (stream, "  N_(\"");
	      else
		fprintf (stream, "  N_(\" ");		/* the empty string translates specially. */
	    }
	  else
	    fprintf (stream, "  \"");
	}

      if (indentation)
	for (j = 0; j < indentation; j++)
	  fprintf (stream, " ");

      /* Don't indent the first line, because of how the help builtin works. */
      if (i == 0)
	indentation += base_indent;

      if (string_array)
	{
	  for (j = 0; line[j]; j++)
	    {
	      switch (line[j])
		{
		case '\\':
		case '"':
		  fprintf (stream, "\\%c", line[j]);
		  break;

		default:
		  fprintf (stream, "%c", line[j]);
		}
	    }

	  /* closing right paren for gettext */
	  if (single_longdoc_strings == 0)
	    {
	      if (filename_p == 0)
		fprintf (stream, "\"),\n");
	      else
		fprintf (stream, "\",\n");
	    }
	  else if (documentation[i+1])
	    /* don't add extra newline after last line */
	    fprintf (stream, "\\n\\\n");
	}
      else if (texinfo)
	{
	  for (j = 0; line[j]; j++)
	    {
	      switch (line[j])
		{
		case '@':
		case '{':
		case '}':
		  fprintf (stream, "@%c", line[j]);
		  break;

		default:
		  fprintf (stream, "%c", line[j]);
		}
	    }
	  fprintf (stream, "\n");
	}
      else
	fprintf (stream, "%s\n", line);
    }

  /* closing right paren for gettext */
  if (string_array && single_longdoc_strings)
    {
      if (filename_p == 0)
	fprintf (stream, "\"),\n");
      else
	fprintf (stream, "\",\n");
    }

  if (string_array)
    fprintf (stream, "#endif /* HELP_BUILTIN */\n  (char *)NULL\n};\n");
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\mkbuiltins.c:1,440
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\mkbuiltins.c:1,567
parsing error 
{
  char *helpfile, *bname;
  FILE *helpfp;
  int i, hdlen;
  BUILTIN_DESC *builtin;	

  i = mkdir ("helpfiles", 0777);
  if (i < 0 && errno != EEXIST)
    {
      fprintf (stderr, "write_helpfiles: helpfiles: cannot create directory\n");
      return -1;
    }

  hdlen = strlen ("helpfiles/");
  for (i = 0; i < builtins->sindex; i++)
    {
      builtin = (BUILTIN_DESC *)builtins->array[i];

      bname = document_name (builtin);
      helpfile = (char *)xmalloc (hdlen + strlen (bname) + 1);
      sprintf (helpfile, "helpfiles/%s", bname);

      helpfp = fopen (helpfile, "w");
      if (helpfp == 0)
	{
	  fprintf (stderr, "write_helpfiles: cannot open %s\n", helpfile);
	  free (helpfile);
	  continue;
	}

      write_documentation (helpfp, builtin->longdoc->array, 4, PLAINTEXT);

      fflush (helpfp);
      fclose (helpfp);
      free (helpfile);
    }
  return 0;
}
warning: parse error {
  char *helpfile, *bname;
  FILE *helpfp;
  int i, hdlen;
  BUILTIN_DESC *builtin;	

  i = mkdir ("helpfiles", 0777);
  if (i < 0 && errno != EEXIST)
    {
      fprintf (stderr, "write_helpfiles: helpfiles: cannot create directory\n");
      return -1;
    }

  hdlen = strlen ("helpfiles/");
  for (i = 0; i < builtins->sindex; i++)
    {
      builtin = (BUILTIN_DESC *)builtins->array[i];

      bname = document_name (builtin);
      helpfile = (char *)xmalloc (hdlen + strlen (bname) + 1);
      sprintf (helpfile, "helpfiles/%s", bname);

      helpfp = fopen (helpfile, "w");
      if (helpfp == 0)
	{
	  fprintf (stderr, "write_helpfiles: cannot open %s\n", helpfile);
	  free (helpfile);
	  continue;
	}

      write_documentation (helpfp, builtin->longdoc->array, 4, PLAINTEXT);

      fflush (helpfp);
      fclose (helpfp);
      free (helpfile);
    }
  return 0;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\mkbuiltins.c:1,569
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\mkbuiltins.c:1,609
parsing error 
{
  register int i;

  for (i = 0; name_table[i]; i++)
    if (strcmp (name, name_table[i]) == 0)
      return 1;
  return 0;
}
warning: parse error {
  register int i;

  for (i = 0; name_table[i]; i++)
    if (strcmp (name, name_table[i]) == 0)
      return 1;
  return 0;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\mkbuiltins.c:1,611
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\mkbuiltins.c:1,621
parsing error 
{
  return (_find_in_table (name, special_builtins));
}
warning: parse error {
  return (_find_in_table (name, special_builtins));
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\mkbuiltins.c:1,623
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\mkbuiltins.c:1,628
parsing error 
{
  return (_find_in_table (name, assignment_builtins));
}
warning: parse error {
  return (_find_in_table (name, assignment_builtins));
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\mkbuiltins.c:1,630
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\mkbuiltins.c:1,635
parsing error 
{
  return (_find_in_table (name, localvar_builtins));
}
warning: parse error {
  return (_find_in_table (name, localvar_builtins));
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\mkbuiltins.c:1,637
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\mkbuiltins.c:1,642
parsing error 
{
  return (_find_in_table (name, posix_builtins));
}
warning: parse error {
  return (_find_in_table (name, posix_builtins));
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\mkbuiltins.c:1,644
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\mkbuiltins.c:1,650
parsing error 
{
  unlink (to);
  if (link (from, to) < 0)
    return (-1);
  unlink (from);
  return (0);
}
warning: parse error {
  unlink (to);
  if (link (from, to) < 0)
    return (-1);
  unlink (from);
  return (0);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\mkbuiltins.c:1,652
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\psize.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashtypes.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\command.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\general.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\sig.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\psize.c:51
parsing error 
{
  fprintf (stderr, "%d\n", nw);
  exit (0);
}
warning: parse error {
  fprintf (stderr, "%d\n", nw);
  exit (0);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\psize.c:53
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\psize.c:59
parsing error 
{
  char buf[128];
  register int i;

  for (i = 0; i < 128; i++)
    buf[i] = ' ';

  signal (SIGPIPE, sigpipe);

  nw = 0;
  for (;;)
    {
      int n;
      n = write (1, buf, 128);
      nw += n;
    }
  return (0);
}
warning: parse error {
  char buf[128];
  register int i;

  for (i = 0; i < 128; i++)
    buf[i] = ' ';

  signal (SIGPIPE, sigpipe);

  nw = 0;
  for (;;)
    {
      int n;
      n = write (1, buf, 128);
      nw += n;
    }
  return (0);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\psize.c:62
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\copy_cmd.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashtypes.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\shell.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\copy_cmd.c:56
parsing error 
{
  WORD_DESC *new_word;

  new_word = make_bare_word (w->word);
  new_word->flags = w->flags;
  return (new_word);
}
warning: parse error {
  WORD_DESC *new_word;

  new_word = make_bare_word (w->word);
  new_word->flags = w->flags;
  return (new_word);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\copy_cmd.c:58
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\copy_cmd.c:69
parsing error 
{
  WORD_LIST *new_list, *tl;

  for (new_list = tl = (WORD_LIST *)NULL; list; list = list->next)
    {
      if (new_list == 0)
	new_list = tl = make_word_list (copy_word (list->word), new_list);
      else
	{
	  tl->next = make_word_list (copy_word (list->word), (WORD_LIST *)NULL);
	  tl = tl->next;
	}
    }

  return (new_list);
}
warning: parse error {
  WORD_LIST *new_list, *tl;

  for (new_list = tl = (WORD_LIST *)NULL; list; list = list->next)
    {
      if (new_list == 0)
	new_list = tl = make_word_list (copy_word (list->word), new_list);
      else
	{
	  tl->next = make_word_list (copy_word (list->word), (WORD_LIST *)NULL);
	  tl = tl->next;
	}
    }

  return (new_list);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\copy_cmd.c:71
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\copy_cmd.c:89
parsing error 
{
  PATTERN_LIST *new_clause;

  new_clause = (PATTERN_LIST *)xmalloc (sizeof (PATTERN_LIST));
  new_clause->patterns = copy_word_list (clause->patterns);
  new_clause->action = copy_command (clause->action);
  new_clause->flags = clause->flags;
  return (new_clause);
}
warning: parse error {
  PATTERN_LIST *new_clause;

  new_clause = (PATTERN_LIST *)xmalloc (sizeof (PATTERN_LIST));
  new_clause->patterns = copy_word_list (clause->patterns);
  new_clause->action = copy_command (clause->action);
  new_clause->flags = clause->flags;
  return (new_clause);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\copy_cmd.c:91
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\copy_cmd.c:102
parsing error 
{
  PATTERN_LIST *new_list, *new_clause;

  for (new_list = (PATTERN_LIST *)NULL; clauses; clauses = clauses->next)
    {
      new_clause = copy_case_clause (clauses);
      new_clause->next = new_list;
      new_list = new_clause;
    }
  return (REVERSE_LIST (new_list, PATTERN_LIST *));
}
warning: parse error {
  PATTERN_LIST *new_list, *new_clause;

  for (new_list = (PATTERN_LIST *)NULL; clauses; clauses = clauses->next)
    {
      new_clause = copy_case_clause (clauses);
      new_clause->next = new_list;
      new_list = new_clause;
    }
  return (REVERSE_LIST (new_list, PATTERN_LIST *));
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\copy_cmd.c:104
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\copy_cmd.c:118
parsing error 
{
  REDIRECT *new_redirect;

  new_redirect = (REDIRECT *)xmalloc (sizeof (REDIRECT));
#if 0
  FASTCOPY ((char *)redirect, (char *)new_redirect, (sizeof (REDIRECT)));
#else
  *new_redirect = *redirect;	/* let the compiler do the fast structure copy */
#endif

  if (redirect->rflags & REDIR_VARASSIGN)
    new_redirect->redirector.filename = copy_word (redirect->redirector.filename);

  switch (redirect->instruction)
    {
    case r_reading_until:
    case r_deblank_reading_until:
      new_redirect->here_doc_eof = redirect->here_doc_eof ? savestring (redirect->here_doc_eof) : 0;
      /*FALLTHROUGH*/
    case r_reading_string:
    case r_appending_to:
    case r_output_direction:
    case r_input_direction:
    case r_inputa_direction:
    case r_err_and_out:
    case r_append_err_and_out:
    case r_input_output:
    case r_output_force:
    case r_duplicating_input_word:
    case r_duplicating_output_word:
    case r_move_input_word:
    case r_move_output_word:
      new_redirect->redirectee.filename = copy_word (redirect->redirectee.filename);
      break;
    case r_duplicating_input:
    case r_duplicating_output:
    case r_move_input:
    case r_move_output:
    case r_close_this:
      break;
    }
  return (new_redirect);
}
warning: parse error {
  REDIRECT *new_redirect;

  new_redirect = (REDIRECT *)xmalloc (sizeof (REDIRECT));
#if 0
  FASTCOPY ((char *)redirect, (char *)new_redirect, (sizeof (REDIRECT)));
#else
  *new_redirect = *redirect;	/* let the compiler do the fast structure copy */
#endif

  if (redirect->rflags & REDIR_VARASSIGN)
    new_redirect->redirector.filename = copy_word (redirect->redirector.filename);

  switch (redirect->instruction)
    {
    case r_reading_until:
    case r_deblank_reading_until:
      new_redirect->here_doc_eof = redirect->here_doc_eof ? savestring (redirect->here_doc_eof) : 0;
      /*FALLTHROUGH*/
    case r_reading_string:
    case r_appending_to:
    case r_output_direction:
    case r_input_direction:
    case r_inputa_direction:
    case r_err_and_out:
    case r_append_err_and_out:
    case r_input_output:
    case r_output_force:
    case r_duplicating_input_word:
    case r_duplicating_output_word:
    case r_move_input_word:
    case r_move_output_word:
      new_redirect->redirectee.filename = copy_word (redirect->redirectee.filename);
      break;
    case r_duplicating_input:
    case r_duplicating_output:
    case r_move_input:
    case r_move_output:
    case r_close_this:
      break;
    }
  return (new_redirect);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\copy_cmd.c:120
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\copy_cmd.c:165
parsing error 
{
  REDIRECT *new_list, *temp;

  for (new_list = (REDIRECT *)NULL; list; list = list->next)
    {
      temp = copy_redirect (list);
      temp->next = new_list;
      new_list = temp;
    }
  return (REVERSE_LIST (new_list, REDIRECT *));
}
warning: parse error {
  REDIRECT *new_list, *temp;

  for (new_list = (REDIRECT *)NULL; list; list = list->next)
    {
      temp = copy_redirect (list);
      temp->next = new_list;
      new_list = temp;
    }
  return (REVERSE_LIST (new_list, REDIRECT *));
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\copy_cmd.c:167
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\copy_cmd.c:180
parsing error 
{
  FOR_COM *new_for;

  new_for = (FOR_COM *)xmalloc (sizeof (FOR_COM));
  new_for->flags = com->flags;
  new_for->line = com->line;
  new_for->name = copy_word (com->name);
  new_for->map_list = copy_word_list (com->map_list);
  new_for->action = copy_command (com->action);
  return (new_for);
}
warning: parse error {
  FOR_COM *new_for;

  new_for = (FOR_COM *)xmalloc (sizeof (FOR_COM));
  new_for->flags = com->flags;
  new_for->line = com->line;
  new_for->name = copy_word (com->name);
  new_for->map_list = copy_word_list (com->map_list);
  new_for->action = copy_command (com->action);
  return (new_for);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\copy_cmd.c:182
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\copy_cmd.c:213
parsing error 
{
  GROUP_COM *new_group;

  new_group = (GROUP_COM *)xmalloc (sizeof (GROUP_COM));
  new_group->command = copy_command (com->command);
  return (new_group);
}
warning: parse error {
  GROUP_COM *new_group;

  new_group = (GROUP_COM *)xmalloc (sizeof (GROUP_COM));
  new_group->command = copy_command (com->command);
  return (new_group);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\copy_cmd.c:215
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\copy_cmd.c:224
parsing error 
{
  SUBSHELL_COM *new_subshell;

  new_subshell = (SUBSHELL_COM *)xmalloc (sizeof (SUBSHELL_COM));
  new_subshell->command = copy_command (com->command);
  new_subshell->flags = com->flags;
  new_subshell->line = com->line;
  return (new_subshell);
}
warning: parse error {
  SUBSHELL_COM *new_subshell;

  new_subshell = (SUBSHELL_COM *)xmalloc (sizeof (SUBSHELL_COM));
  new_subshell->command = copy_command (com->command);
  new_subshell->flags = com->flags;
  new_subshell->line = com->line;
  return (new_subshell);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\copy_cmd.c:226
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\copy_cmd.c:237
parsing error 
{
  COPROC_COM *new_coproc;

  new_coproc = (COPROC_COM *)xmalloc (sizeof (COPROC_COM));
  new_coproc->name = savestring (com->name);
  new_coproc->command = copy_command (com->command);
  new_coproc->flags = com->flags;
  return (new_coproc);
}
warning: parse error {
  COPROC_COM *new_coproc;

  new_coproc = (COPROC_COM *)xmalloc (sizeof (COPROC_COM));
  new_coproc->name = savestring (com->name);
  new_coproc->command = copy_command (com->command);
  new_coproc->flags = com->flags;
  return (new_coproc);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\copy_cmd.c:239
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\copy_cmd.c:250
parsing error 
{
  CASE_COM *new_case;

  new_case = (CASE_COM *)xmalloc (sizeof (CASE_COM));
  new_case->flags = com->flags;
  new_case->line = com->line;
  new_case->word = copy_word (com->word);
  new_case->clauses = copy_case_clauses (com->clauses);
  return (new_case);
}
warning: parse error {
  CASE_COM *new_case;

  new_case = (CASE_COM *)xmalloc (sizeof (CASE_COM));
  new_case->flags = com->flags;
  new_case->line = com->line;
  new_case->word = copy_word (com->word);
  new_case->clauses = copy_case_clauses (com->clauses);
  return (new_case);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\copy_cmd.c:252
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\copy_cmd.c:264
parsing error 
{
  WHILE_COM *new_while;

  new_while = (WHILE_COM *)xmalloc (sizeof (WHILE_COM));
  new_while->flags = com->flags;
  new_while->test = copy_command (com->test);
  new_while->action = copy_command (com->action);
  return (new_while);
}
warning: parse error {
  WHILE_COM *new_while;

  new_while = (WHILE_COM *)xmalloc (sizeof (WHILE_COM));
  new_while->flags = com->flags;
  new_while->test = copy_command (com->test);
  new_while->action = copy_command (com->action);
  return (new_while);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\copy_cmd.c:266
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\copy_cmd.c:277
parsing error 
{
  IF_COM *new_if;

  new_if = (IF_COM *)xmalloc (sizeof (IF_COM));
  new_if->flags = com->flags;
  new_if->test = copy_command (com->test);
  new_if->true_case = copy_command (com->true_case);
  new_if->false_case = com->false_case ? copy_command (com->false_case) : com->false_case;
  return (new_if);
}
warning: parse error {
  IF_COM *new_if;

  new_if = (IF_COM *)xmalloc (sizeof (IF_COM));
  new_if->flags = com->flags;
  new_if->test = copy_command (com->test);
  new_if->true_case = copy_command (com->true_case);
  new_if->false_case = com->false_case ? copy_command (com->false_case) : com->false_case;
  return (new_if);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\copy_cmd.c:279
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\copy_cmd.c:326
parsing error 
{
  SIMPLE_COM *new_simple;

  new_simple = (SIMPLE_COM *)xmalloc (sizeof (SIMPLE_COM));
  new_simple->flags = com->flags;
  new_simple->words = copy_word_list (com->words);
  new_simple->redirects = com->redirects ? copy_redirects (com->redirects) : (REDIRECT *)NULL;
  new_simple->line = com->line;
  return (new_simple);
}
warning: parse error {
  SIMPLE_COM *new_simple;

  new_simple = (SIMPLE_COM *)xmalloc (sizeof (SIMPLE_COM));
  new_simple->flags = com->flags;
  new_simple->words = copy_word_list (com->words);
  new_simple->redirects = com->redirects ? copy_redirects (com->redirects) : (REDIRECT *)NULL;
  new_simple->line = com->line;
  return (new_simple);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\copy_cmd.c:328
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\copy_cmd.c:340
parsing error 
{
  new_def->name = copy_word (old->name);
  new_def->command = old->command ? copy_command (old->command) : old->command;
  new_def->flags = old->flags;
  new_def->line = old->line;
  new_def->source_file = old->source_file ? savestring (old->source_file) : old->source_file;
  return (new_def);
}
warning: parse error {
  new_def->name = copy_word (old->name);
  new_def->command = old->command ? copy_command (old->command) : old->command;
  new_def->flags = old->flags;
  new_def->line = old->line;
  new_def->source_file = old->source_file ? savestring (old->source_file) : old->source_file;
  return (new_def);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\copy_cmd.c:342
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\copy_cmd.c:352
parsing error 
{
  FUNCTION_DEF *new_def;

  new_def = (FUNCTION_DEF *)xmalloc (sizeof (FUNCTION_DEF));
  new_def = copy_function_def_contents (com, new_def);
  return (new_def);
}
warning: parse error {
  FUNCTION_DEF *new_def;

  new_def = (FUNCTION_DEF *)xmalloc (sizeof (FUNCTION_DEF));
  new_def = copy_function_def_contents (com, new_def);
  return (new_def);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\copy_cmd.c:354
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\copy_cmd.c:366
parsing error 
{
  COMMAND *new_command;

  if (command == NULL)
    return (command);

  new_command = (COMMAND *)xmalloc (sizeof (COMMAND));
  FASTCOPY ((char *)command, (char *)new_command, sizeof (COMMAND));
  new_command->flags = command->flags;
  new_command->line = command->line;

  if (command->redirects)
    new_command->redirects = copy_redirects (command->redirects);

  switch (command->type)
    {
      case cm_for:
	new_command->value.For = copy_for_command (command->value.For);
	break;

#if defined (ARITH_FOR_COMMAND)
      case cm_arith_for:
	new_command->value.ArithFor = copy_arith_for_command (command->value.ArithFor);
	break;
#endif

#if defined (SELECT_COMMAND)
      case cm_select:
	new_command->value.Select =
	  (SELECT_COM *)copy_for_command ((FOR_COM *)command->value.Select);
	break;
#endif

      case cm_group:
	new_command->value.Group = copy_group_command (command->value.Group);
	break;

      case cm_subshell:
	new_command->value.Subshell = copy_subshell_command (command->value.Subshell);
	break;

      case cm_coproc:
	new_command->value.Coproc = copy_coproc_command (command->value.Coproc);
	break;

      case cm_case:
	new_command->value.Case = copy_case_command (command->value.Case);
	break;

      case cm_until:
      case cm_while:
	new_command->value.While = copy_while_command (command->value.While);
	break;

      case cm_if:
	new_command->value.If = copy_if_command (command->value.If);
	break;

#if defined (DPAREN_ARITHMETIC)
      case cm_arith:
	new_command->value.Arith = copy_arith_command (command->value.Arith);
	break;
#endif

#if defined (COND_COMMAND)
      case cm_cond:
	new_command->value.Cond = copy_cond_command (command->value.Cond);
	break;
#endif

      case cm_simple:
	new_command->value.Simple = copy_simple_command (command->value.Simple);
	break;

      case cm_connection:
	{
	  CONNECTION *new_connection;

	  new_connection = (CONNECTION *)xmalloc (sizeof (CONNECTION));
	  new_connection->connector = command->value.Connection->connector;
	  new_connection->first = copy_command (command->value.Connection->first);
	  new_connection->second = copy_command (command->value.Connection->second);
	  new_command->value.Connection = new_connection;
	  break;
	}

      case cm_function_def:
	new_command->value.Function_def = copy_function_def (command->value.Function_def);
	break;
    }
  return (new_command);
}
warning: parse error {
  COMMAND *new_command;

  if (command == NULL)
    return (command);

  new_command = (COMMAND *)xmalloc (sizeof (COMMAND));
  FASTCOPY ((char *)command, (char *)new_command, sizeof (COMMAND));
  new_command->flags = command->flags;
  new_command->line = command->line;

  if (command->redirects)
    new_command->redirects = copy_redirects (command->redirects);

  switch (command->type)
    {
      case cm_for:
	new_command->value.For = copy_for_command (command->value.For);
	break;

#if defined (ARITH_FOR_COMMAND)
      case cm_arith_for:
	new_command->value.ArithFor = copy_arith_for_command (command->value.ArithFor);
	break;
#endif

#if defined (SELECT_COMMAND)
      case cm_select:
	new_command->value.Select =
	  (SELECT_COM *)copy_for_command ((FOR_COM *)command->value.Select);
	break;
#endif

      case cm_group:
	new_command->value.Group = copy_group_command (command->value.Group);
	break;

      case cm_subshell:
	new_command->value.Subshell = copy_subshell_command (command->value.Subshell);
	break;

      case cm_coproc:
	new_command->value.Coproc = copy_coproc_command (command->value.Coproc);
	break;

      case cm_case:
	new_command->value.Case = copy_case_command (command->value.Case);
	break;

      case cm_until:
      case cm_while:
	new_command->value.While = copy_while_command (command->value.While);
	break;

      case cm_if:
	new_command->value.If = copy_if_command (command->value.If);
	break;

#if defined (DPAREN_ARITHMETIC)
      case cm_arith:
	new_command->value.Arith = copy_arith_command (command->value.Arith);
	break;
#endif

#if defined (COND_COMMAND)
      case cm_cond:
	new_command->value.Cond = copy_cond_command (command->value.Cond);
	break;
#endif

      case cm_simple:
	new_command->value.Simple = copy_simple_command (command->value.Simple);
	break;

      case cm_connection:
	{
	  CONNECTION *new_connection;

	  new_connection = (CONNECTION *)xmalloc (sizeof (CONNECTION));
	  new_connection->connector = command->value.Connection->connector;
	  new_connection->first = copy_command (command->value.Connection->first);
	  new_connection->second = copy_command (command->value.Connection->second);
	  new_command->value.Connection = new_connection;
	  break;
	}

      case cm_function_def:
	new_command->value.Function_def = copy_function_def (command->value.Function_def);
	break;
    }
  return (new_command);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\copy_cmd.c:368
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\CWRU\misc\errlist.c...
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\CWRU\misc\errlist.c:31
parsing error 
{
	int	i, n;

	if (c == 1) {
		for (i = 1; i < sys_nerr; i++)
			printf("%d --> %s\n", i, strerror(i));
	} else {
		for (i = 1; i < c; i++) {
			n = atoi(v[i]);
			printf("%d --> %s\n", n, strerror(n));
		}
	}
	exit (0);
}
warning: parse error {
	int	i, n;

	if (c == 1) {
		for (i = 1; i < sys_nerr; i++)
			printf("%d --> %s\n", i, strerror(i));
	} else {
		for (i = 1; i < c; i++) {
			n = atoi(v[i]);
			printf("%d --> %s\n", n, strerror(n));
		}
	}
	exit (0);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\CWRU\misc\errlist.c:34
parsing error 
programming_error(a, b)
char	*a;
warning: parse error programming_error(a, b)
char	*a;Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\CWRU\misc\errlist.c:49
parsing error 
{
}
warning: parse error {
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\CWRU\misc\errlist.c:52
parsing error 
fatal_error()
{
}
warning: parse error fatal_error()
{
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\CWRU\misc\errlist.c:55
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\CWRU\misc\open-files.c...
parsing error 
main()
{
	register int	i;

	for (i = 0; i < getdtablesize(); i++) {
		if (fcntl(i, F_GETFD, 0) != -1)
			fprintf(stderr, "fd %d: open\n", i);
	}
	exit(0);
}
warning: parse error main()
{
	register int	i;

	for (i = 0; i < getdtablesize(); i++) {
		if (fcntl(i, F_GETFD, 0) != -1)
			fprintf(stderr, "fd %d: open\n", i);
	}
	exit(0);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\CWRU\misc\open-files.c:30
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\CWRU\misc\sigs.c...
parsing error 
main(argc, argv)
int	argc;
warning: parse error main(argc, argv)
int	argc;Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\CWRU\misc\sigs.c:28
parsing error 
{
	register int	i;
	sighandler	*h;

	for (i = 1; i < NSIG; i++) {
		h = signal(i, SIG_DFL);
		if (h != SIG_DFL) {
			if (h == SIG_IGN)
				fprintf(stderr, "%d: ignored (%s)\n", i, sys_siglist[i]);
			else
				fprintf(stderr, "%d: caught (%s)\n", i, sys_siglist[i]);
		}
	}
	exit(0);
}
warning: parse error {
	register int	i;
	sighandler	*h;

	for (i = 1; i < NSIG; i++) {
		h = signal(i, SIG_DFL);
		if (h != SIG_DFL) {
			if (h == SIG_IGN)
				fprintf(stderr, "%d: ignored (%s)\n", i, sys_siglist[i]);
			else
				fprintf(stderr, "%d: caught (%s)\n", i, sys_siglist[i]);
		}
	}
	exit(0);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\CWRU\misc\sigs.c:31
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\CWRU\misc\sigstat.c...
parsing error 
main(argc, argv)
int	argc;
warning: parse error main(argc, argv)
int	argc;Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\CWRU\misc\sigstat.c:37
parsing error 
{
	register int	i;
	char	*t;

	if (t = strrchr(argv[0], '/'))
		progname = ++t;
	else
		progname = argv[0];
	init_signames();
	if (argc == 1) {
		for (i = 1; i < NSIG; i++)
			sigstat(i);
		exit(0);
	}
	for (i = 1; i < argc; i++)
		sigstat(atoi(argv[i]));
	exit(0);
}
warning: parse error {
	register int	i;
	char	*t;

	if (t = strrchr(argv[0], '/'))
		progname = ++t;
	else
		progname = argv[0];
	init_signames();
	if (argc == 1) {
		for (i = 1; i < NSIG; i++)
			sigstat(i);
		exit(0);
	}
	for (i = 1; i < argc; i++)
		sigstat(atoi(argv[i]));
	exit(0);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\CWRU\misc\sigstat.c:40
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\CWRU\misc\sigstat.c:60
parsing error 
{
	struct sigaction oact;
	char *signame;
	sigset_t set, oset;
	int blocked;

	if (sig < 0 || sig >= NSIG) {
		fprintf(stderr, "%s: %d: signal out of range\n", progname, sig);
		return;
	}
	signame = signames[sig];
	sigemptyset(&oset);
	sigprocmask(SIG_BLOCK, (sigset_t *)NULL, &oset);
	if (sigismember(&oset, sig))
		printf("%s: signal is blocked\n", signame);
	sigaction(sig, (struct sigaction *)NULL, &oact);
	if (oact.sa_handler == SIG_IGN)
		printf("%s: signal is ignored\n", signame);
	else if (oact.sa_handler == SIG_DFL)
		printf("%s: signal is defaulted\n", signame);
	else
		printf("%s: signal is trapped (?)\n", signame);
}
warning: parse error {
	struct sigaction oact;
	char *signame;
	sigset_t set, oset;
	int blocked;

	if (sig < 0 || sig >= NSIG) {
		fprintf(stderr, "%s: %d: signal out of range\n", progname, sig);
		return;
	}
	signame = signames[sig];
	sigemptyset(&oset);
	sigprocmask(SIG_BLOCK, (sigset_t *)NULL, &oset);
	if (sigismember(&oset, sig))
		printf("%s: signal is blocked\n", signame);
	sigaction(sig, (struct sigaction *)NULL, &oact);
	if (oact.sa_handler == SIG_IGN)
		printf("%s: signal is ignored\n", signame);
	else if (oact.sa_handler == SIG_DFL)
		printf("%s: signal is defaulted\n", signame);
	else
		printf("%s: signal is trapped (?)\n", signame);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\CWRU\misc\sigstat.c:62
parsing error 
init_signames()
{
	register int i;
	bzero(signames, sizeof(signames));

#if defined (SIGHUP)		/* hangup */
  	signames[SIGHUP] = "SIGHUP";
#endif
#if defined (SIGINT)		/* interrupt */
  	signames[SIGINT] = "SIGINT";
#endif
#if defined (SIGQUIT)		/* quit */
  	signames[SIGQUIT] = "SIGQUIT";
#endif
#if defined (SIGILL)		/* illegal instruction (not reset when caught) */
  	signames[SIGILL] = "SIGILL";
#endif
#if defined (SIGTRAP)		/* trace trap (not reset when caught) */
  	signames[SIGTRAP] = "SIGTRAP";
#endif
#if defined (SIGABRT)		/*  */
  	signames[SIGABRT] = "SIGABRT";
#endif
#if defined (SIGIOT)		/* IOT instruction */
  	signames[SIGIOT] = "SIGIOT";
#endif
#if defined (SIGEMT)		/* EMT instruction */
  	signames[SIGEMT] = "SIGEMT";
#endif
#if defined (SIGFPE)		/* floating point exception */
  	signames[SIGFPE] = "SIGFPE";
#endif
#if defined (SIGKILL)		/* kill (cannot be caught or ignored) */
  	signames[SIGKILL] = "SIGKILL";
#endif
#if defined (SIGBUS)		/* bus error */
  	signames[SIGBUS] = "SIGBUS";
#endif
#if defined (SIGSEGV)		/* segmentation violation */
  	signames[SIGSEGV] = "SIGSEGV";
#endif
#if defined (SIGSYS)		/* bad argument to system call */
  	signames[SIGSYS] = "SIGSYS";
#endif
#if defined (SIGPIPE)		/* write on a pipe with no one to read it */
  	signames[SIGPIPE] = "SIGPIPE";
#endif
#if defined (SIGALRM)		/* alarm clock */
  	signames[SIGALRM] = "SIGALRM";
#endif
#if defined (SIGTERM)		/* software termination signal from kill */
  	signames[SIGTERM] = "SIGTERM";
#endif
#if defined (SIGCLD)		/* Like SIGCHLD.  */
  	signames[SIGCLD] = "SIGCLD";
#endif
#if defined (SIGPWR)		/* Magic thing for some machines. */
  	signames[SIGPWR] = "SIGPWR";
#endif
#if defined (SIGPOLL)		/* For keyboard input?  */
  	signames[SIGPOLL] = "SIGPOLL";
#endif
#if defined (SIGURG)		/* urgent condition on IO channel */
  	signames[SIGURG] = "SIGURG";
#endif
#if defined (SIGSTOP)		/* sendable stop signal not from tty */
  	signames[SIGSTOP] = "SIGSTOP";
#endif
#if defined (SIGTSTP)		/* stop signal from tty */
  	signames[SIGTSTP] = "SIGTSTP";
#endif
#if defined (SIGCONT)		/* continue a stopped process */
  	signames[SIGCONT] = "SIGCONT";
#endif
#if defined (SIGCHLD)		/* to parent on child stop or exit */
  	signames[SIGCHLD] = "SIGCHLD";
#endif
#if defined (SIGTTIN)		/* to readers pgrp upon background tty read */
  	signames[SIGTTIN] = "SIGTTIN";
#endif
#if defined (SIGTTOU)		/* like TTIN for output if (tp->t_local&LTOSTOP) */
  	signames[SIGTTOU] = "SIGTTOU";
#endif
#if defined (SIGIO)		/* input/output possible signal */
  	signames[SIGIO] = "SIGIO";
#endif
#if defined (SIGXCPU)		/* exceeded CPU time limit */
  	signames[SIGXCPU] = "SIGXCPU";
#endif
#if defined (SIGXFSZ)		/* exceeded file size limit */
  	signames[SIGXFSZ] = "SIGXFSZ";
#endif
#if defined (SIGVTALRM)		/* virtual time alarm */
  	signames[SIGVTALRM] = "SIGVTALRM";
#endif
#if defined (SIGPROF)		/* profiling time alarm */
  	signames[SIGPROF] = "SIGPROF";
#endif
#if defined (SIGWINCH)		/* window changed */
  	signames[SIGWINCH] = "SIGWINCH";
#endif
#if defined (SIGLOST)		/* resource lost (eg, record-lock lost) */
  	signames[SIGLOST] = "SIGLOST";
#endif
#if defined (SIGUSR1)		/* user defined signal 1 */
  	signames[SIGUSR1] = "SIGUSR1";
#endif
#if defined (SIGUSR2)		/* user defined signal 2 */
  	signames[SIGUSR2] = "SIGUSR2";
#endif
#if defined (SIGMSG)	/* HFT input data pending */
  	signames[SIGMSG] = "SIGMSG";
#endif
#if defined (SIGPWR)	/* power failure imminent (save your data) */
  	signames[SIGPWR] = "SIGPWR";
#endif
#if defined (SIGDANGER)	/* system crash imminent */
  	signames[SIGDANGER] = "SIGDANGER";
#endif
#if defined (SIGMIGRATE)	/* migrate process to another CPU */
  	signames[SIGMIGRATE] = "SIGMIGRATE";
#endif
#if defined (SIGPRE)	/* programming error */
  	signames[SIGPRE] = "SIGPRE";
#endif
#if defined (SIGGRANT)	/* HFT monitor mode granted */
  	signames[SIGGRANT] = "SIGGRANT";
#endif
#if defined (SIGRETRACT)	/* HFT monitor mode retracted */
  	signames[SIGRETRACT] = "SIGRETRACT";
#endif
#if defined (SIGSOUND)	/* HFT sound sequence has completed */
  	signames[SIGSOUND] = "SIGSOUND";
#endif

	for (i = 0; i < NSIG; i++)
		if (signames[i] == (char *)NULL) {
			signames[i] = (char *)malloc (16);;
			sprintf (signames[i], "signal %d", i);
	  	}
}
warning: parse error init_signames()
{
	register int i;
	bzero(signames, sizeof(signames));

#if defined (SIGHUP)		/* hangup */
  	signames[SIGHUP] = "SIGHUP";
#endif
#if defined (SIGINT)		/* interrupt */
  	signames[SIGINT] = "SIGINT";
#endif
#if defined (SIGQUIT)		/* quit */
  	signames[SIGQUIT] = "SIGQUIT";
#endif
#if defined (SIGILL)		/* illegal instruction (not reset when caught) */
  	signames[SIGILL] = "SIGILL";
#endif
#if defined (SIGTRAP)		/* trace trap (not reset when caught) */
  	signames[SIGTRAP] = "SIGTRAP";
#endif
#if defined (SIGABRT)		/*  */
  	signames[SIGABRT] = "SIGABRT";
#endif
#if defined (SIGIOT)		/* IOT instruction */
  	signames[SIGIOT] = "SIGIOT";
#endif
#if defined (SIGEMT)		/* EMT instruction */
  	signames[SIGEMT] = "SIGEMT";
#endif
#if defined (SIGFPE)		/* floating point exception */
  	signames[SIGFPE] = "SIGFPE";
#endif
#if defined (SIGKILL)		/* kill (cannot be caught or ignored) */
  	signames[SIGKILL] = "SIGKILL";
#endif
#if defined (SIGBUS)		/* bus error */
  	signames[SIGBUS] = "SIGBUS";
#endif
#if defined (SIGSEGV)		/* segmentation violation */
  	signames[SIGSEGV] = "SIGSEGV";
#endif
#if defined (SIGSYS)		/* bad argument to system call */
  	signames[SIGSYS] = "SIGSYS";
#endif
#if defined (SIGPIPE)		/* write on a pipe with no one to read it */
  	signames[SIGPIPE] = "SIGPIPE";
#endif
#if defined (SIGALRM)		/* alarm clock */
  	signames[SIGALRM] = "SIGALRM";
#endif
#if defined (SIGTERM)		/* software termination signal from kill */
  	signames[SIGTERM] = "SIGTERM";
#endif
#if defined (SIGCLD)		/* Like SIGCHLD.  */
  	signames[SIGCLD] = "SIGCLD";
#endif
#if defined (SIGPWR)		/* Magic thing for some machines. */
  	signames[SIGPWR] = "SIGPWR";
#endif
#if defined (SIGPOLL)		/* For keyboard input?  */
  	signames[SIGPOLL] = "SIGPOLL";
#endif
#if defined (SIGURG)		/* urgent condition on IO channel */
  	signames[SIGURG] = "SIGURG";
#endif
#if defined (SIGSTOP)		/* sendable stop signal not from tty */
  	signames[SIGSTOP] = "SIGSTOP";
#endif
#if defined (SIGTSTP)		/* stop signal from tty */
  	signames[SIGTSTP] = "SIGTSTP";
#endif
#if defined (SIGCONT)		/* continue a stopped process */
  	signames[SIGCONT] = "SIGCONT";
#endif
#if defined (SIGCHLD)		/* to parent on child stop or exit */
  	signames[SIGCHLD] = "SIGCHLD";
#endif
#if defined (SIGTTIN)		/* to readers pgrp upon background tty read */
  	signames[SIGTTIN] = "SIGTTIN";
#endif
#if defined (SIGTTOU)		/* like TTIN for output if (tp->t_local&LTOSTOP) */
  	signames[SIGTTOU] = "SIGTTOU";
#endif
#if defined (SIGIO)		/* input/output possible signal */
  	signames[SIGIO] = "SIGIO";
#endif
#if defined (SIGXCPU)		/* exceeded CPU time limit */
  	signames[SIGXCPU] = "SIGXCPU";
#endif
#if defined (SIGXFSZ)		/* exceeded file size limit */
  	signames[SIGXFSZ] = "SIGXFSZ";
#endif
#if defined (SIGVTALRM)		/* virtual time alarm */
  	signames[SIGVTALRM] = "SIGVTALRM";
#endif
#if defined (SIGPROF)		/* profiling time alarm */
  	signames[SIGPROF] = "SIGPROF";
#endif
#if defined (SIGWINCH)		/* window changed */
  	signames[SIGWINCH] = "SIGWINCH";
#endif
#if defined (SIGLOST)		/* resource lost (eg, record-lock lost) */
  	signames[SIGLOST] = "SIGLOST";
#endif
#if defined (SIGUSR1)		/* user defined signal 1 */
  	signames[SIGUSR1] = "SIGUSR1";
#endif
#if defined (SIGUSR2)		/* user defined signal 2 */
  	signames[SIGUSR2] = "SIGUSR2";
#endif
#if defined (SIGMSG)	/* HFT input data pending */
  	signames[SIGMSG] = "SIGMSG";
#endif
#if defined (SIGPWR)	/* power failure imminent (save your data) */
  	signames[SIGPWR] = "SIGPWR";
#endif
#if defined (SIGDANGER)	/* system crash imminent */
  	signames[SIGDANGER] = "SIGDANGER";
#endif
#if defined (SIGMIGRATE)	/* migrate process to another CPU */
  	signames[SIGMIGRATE] = "SIGMIGRATE";
#endif
#if defined (SIGPRE)	/* programming error */
  	signames[SIGPRE] = "SIGPRE";
#endif
#if defined (SIGGRANT)	/* HFT monitor mode granted */
  	signames[SIGGRANT] = "SIGGRANT";
#endif
#if defined (SIGRETRACT)	/* HFT monitor mode retracted */
  	signames[SIGRETRACT] = "SIGRETRACT";
#endif
#if defined (SIGSOUND)	/* HFT sound sequence has completed */
  	signames[SIGSOUND] = "SIGSOUND";
#endif

	for (i = 0; i < NSIG; i++)
		if (signames[i] == (char *)NULL) {
			signames[i] = (char *)malloc (16);;
			sprintf (signames[i], "signal %d", i);
	  	}
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\CWRU\misc\sigstat.c:86
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\dispose_cmd.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashtypes.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashansi.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\shell.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\dispose_cmd.c:36
parsing error 
{
  if (command == 0)
    return;

  if (command->redirects)
    dispose_redirects (command->redirects);

  switch (command->type)
    {
    case cm_for:
#if defined (SELECT_COMMAND)
    case cm_select:
#endif
      {
	register FOR_COM *c;
#if defined (SELECT_COMMAND)
	if (command->type == cm_select)
	  c = (FOR_COM *)command->value.Select;
	else
#endif
	c = command->value.For;
	dispose_word (c->name);
	dispose_words (c->map_list);
	dispose_command (c->action);
	free (c);
	break;
      }

#if defined (ARITH_FOR_COMMAND)
    case cm_arith_for:
      {
	register ARITH_FOR_COM *c;

	c = command->value.ArithFor;
	dispose_words (c->init);
	dispose_words (c->test);
	dispose_words (c->step);
	dispose_command (c->action);
	free (c);
	break;
      }
#endif /* ARITH_FOR_COMMAND */

    case cm_group:
      {
	dispose_command (command->value.Group->command);
	free (command->value.Group);
	break;
      }

    case cm_subshell:
      {
	dispose_command (command->value.Subshell->command);
	free (command->value.Subshell);
	break;
      }

    case cm_coproc:
      {
	free (command->value.Coproc->name);
	dispose_command (command->value.Coproc->command);
	free (command->value.Coproc);
	break;
      }

    case cm_case:
      {
	register CASE_COM *c;
	PATTERN_LIST *t, *p;

	c = command->value.Case;
	dispose_word (c->word);

	for (p = c->clauses; p; )
	  {
	    dispose_words (p->patterns);
	    dispose_command (p->action);
	    t = p;
	    p = p->next;
	    free (t);
	  }
	free (c);
	break;
      }

    case cm_until:
    case cm_while:
      {
	register WHILE_COM *c;

	c = command->value.While;
	dispose_command (c->test);
	dispose_command (c->action);
	free (c);
	break;
      }

    case cm_if:
      {
	register IF_COM *c;

	c = command->value.If;
	dispose_command (c->test);
	dispose_command (c->true_case);
	dispose_command (c->false_case);
	free (c);
	break;
      }

    case cm_simple:
      {
	register SIMPLE_COM *c;

	c = command->value.Simple;
	dispose_words (c->words);
	dispose_redirects (c->redirects);
	free (c);
	break;
      }

    case cm_connection:
      {
	register CONNECTION *c;

	c = command->value.Connection;
	dispose_command (c->first);
	dispose_command (c->second);
	free (c);
	break;
      }

#if defined (DPAREN_ARITHMETIC)
    case cm_arith:
      {
	register ARITH_COM *c;

	c = command->value.Arith;
	dispose_words (c->exp);
	free (c);
	break;
      }
#endif /* DPAREN_ARITHMETIC */

#if defined (COND_COMMAND)
    case cm_cond:
      {
	register COND_COM *c;

	c = command->value.Cond;
	dispose_cond_node (c);
	break;
      }
#endif /* COND_COMMAND */

    case cm_function_def:
      {
	register FUNCTION_DEF *c;

	c = command->value.Function_def;
	dispose_function_def (c);
	break;
      }

    default:
      command_error ("dispose_command", CMDERR_BADTYPE, command->type, 0);
      break;
    }
  free (command);
}
warning: parse error {
  if (command == 0)
    return;

  if (command->redirects)
    dispose_redirects (command->redirects);

  switch (command->type)
    {
    case cm_for:
#if defined (SELECT_COMMAND)
    case cm_select:
#endif
      {
	register FOR_COM *c;
#if defined (SELECT_COMMAND)
	if (command->type == cm_select)
	  c = (FOR_COM *)command->value.Select;
	else
#endif
	c = command->value.For;
	dispose_word (c->name);
	dispose_words (c->map_list);
	dispose_command (c->action);
	free (c);
	break;
      }

#if defined (ARITH_FOR_COMMAND)
    case cm_arith_for:
      {
	register ARITH_FOR_COM *c;

	c = command->value.ArithFor;
	dispose_words (c->init);
	dispose_words (c->test);
	dispose_words (c->step);
	dispose_command (c->action);
	free (c);
	break;
      }
#endif /* ARITH_FOR_COMMAND */

    case cm_group:
      {
	dispose_command (command->value.Group->command);
	free (command->value.Group);
	break;
      }

    case cm_subshell:
      {
	dispose_command (command->value.Subshell->command);
	free (command->value.Subshell);
	break;
      }

    case cm_coproc:
      {
	free (command->value.Coproc->name);
	dispose_command (command->value.Coproc->command);
	free (command->value.Coproc);
	break;
      }

    case cm_case:
      {
	register CASE_COM *c;
	PATTERN_LIST *t, *p;

	c = command->value.Case;
	dispose_word (c->word);

	for (p = c->clauses; p; )
	  {
	    dispose_words (p->patterns);
	    dispose_command (p->action);
	    t = p;
	    p = p->next;
	    free (t);
	  }
	free (c);
	break;
      }

    case cm_until:
    case cm_while:
      {
	register WHILE_COM *c;

	c = command->value.While;
	dispose_command (c->test);
	dispose_command (c->action);
	free (c);
	break;
      }

    case cm_if:
      {
	register IF_COM *c;

	c = command->value.If;
	dispose_command (c->test);
	dispose_command (c->true_case);
	dispose_command (c->false_case);
	free (c);
	break;
      }

    case cm_simple:
      {
	register SIMPLE_COM *c;

	c = command->value.Simple;
	dispose_words (c->words);
	dispose_redirects (c->redirects);
	free (c);
	break;
      }

    case cm_connection:
      {
	register CONNECTION *c;

	c = command->value.Connection;
	dispose_command (c->first);
	dispose_command (c->second);
	free (c);
	break;
      }

#if defined (DPAREN_ARITHMETIC)
    case cm_arith:
      {
	register ARITH_COM *c;

	c = command->value.Arith;
	dispose_words (c->exp);
	free (c);
	break;
      }
#endif /* DPAREN_ARITHMETIC */

#if defined (COND_COMMAND)
    case cm_cond:
      {
	register COND_COM *c;

	c = command->value.Cond;
	dispose_cond_node (c);
	break;
      }
#endif /* COND_COMMAND */

    case cm_function_def:
      {
	register FUNCTION_DEF *c;

	c = command->value.Function_def;
	dispose_function_def (c);
	break;
      }

    default:
      command_error ("dispose_command", CMDERR_BADTYPE, command->type, 0);
      break;
    }
  free (command);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\dispose_cmd.c:38
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\dispose_cmd.c:228
parsing error 
{
  dispose_word (c->name);
  dispose_command (c->command);
  FREE (c->source_file);
}
warning: parse error {
  dispose_word (c->name);
  dispose_command (c->command);
  FREE (c->source_file);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\dispose_cmd.c:230
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\dispose_cmd.c:237
parsing error 
{
  dispose_function_def_contents (c);
  free (c);
}
warning: parse error {
  dispose_function_def_contents (c);
  free (c);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\dispose_cmd.c:239
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\dispose_cmd.c:246
parsing error 
{
  FREE (w->word);
  ocache_free (wdcache, WORD_DESC, w);
}
warning: parse error {
  FREE (w->word);
  ocache_free (wdcache, WORD_DESC, w);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\dispose_cmd.c:248
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\dispose_cmd.c:255
parsing error 
{
  w->word = 0;
  ocache_free (wdcache, WORD_DESC, w);
}
warning: parse error {
  w->word = 0;
  ocache_free (wdcache, WORD_DESC, w);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\dispose_cmd.c:257
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\dispose_cmd.c:264
parsing error 
{
  WORD_LIST *t;

  while (list)
    {
      t = list;
      list = list->next;
      dispose_word (t->word);
#if 0
      free (t);
#else
      ocache_free (wlcache, WORD_LIST, t);
#endif
    }
}
warning: parse error {
  WORD_LIST *t;

  while (list)
    {
      t = list;
      list = list->next;
      dispose_word (t->word);
#if 0
      free (t);
#else
      ocache_free (wlcache, WORD_LIST, t);
#endif
    }
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\dispose_cmd.c:266
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\dispose_cmd.c:303
parsing error 
{
  register REDIRECT *t;

  while (list)
    {
      t = list;
      list = list->next;

      if (t->rflags & REDIR_VARASSIGN)
	dispose_word (t->redirector.filename);

      switch (t->instruction)
	{
	case r_reading_until:
	case r_deblank_reading_until:
	  free (t->here_doc_eof);
	/*FALLTHROUGH*/
	case r_reading_string:
	case r_output_direction:
	case r_input_direction:
	case r_inputa_direction:
	case r_appending_to:
	case r_err_and_out:
	case r_append_err_and_out:
	case r_input_output:
	case r_output_force:
	case r_duplicating_input_word:
	case r_duplicating_output_word:
	case r_move_input_word:
	case r_move_output_word:
	  dispose_word (t->redirectee.filename);
	  /* FALLTHROUGH */
	default:
	  break;
	}
      free (t);
    }
}
warning: parse error {
  register REDIRECT *t;

  while (list)
    {
      t = list;
      list = list->next;

      if (t->rflags & REDIR_VARASSIGN)
	dispose_word (t->redirector.filename);

      switch (t->instruction)
	{
	case r_reading_until:
	case r_deblank_reading_until:
	  free (t->here_doc_eof);
	/*FALLTHROUGH*/
	case r_reading_string:
	case r_output_direction:
	case r_input_direction:
	case r_inputa_direction:
	case r_appending_to:
	case r_err_and_out:
	case r_append_err_and_out:
	case r_input_output:
	case r_output_force:
	case r_duplicating_input_word:
	case r_duplicating_output_word:
	case r_move_input_word:
	case r_move_output_word:
	  dispose_word (t->redirectee.filename);
	  /* FALLTHROUGH */
	default:
	  break;
	}
      free (t);
    }
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\dispose_cmd.c:305
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\error.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashtypes.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashansi.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashintl.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\shell.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\execute_cmd.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\flags.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\input.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\error.c:79
parsing error 
{
  char *ename;
  int line;

  ename = get_name_for_error ();
  line = (print_lineno && interactive_shell == 0) ? executing_line_number () : -1;

  if (line > 0)
    fprintf (stderr, "%s:%s%d: ", ename, gnu_error_format ? "" : _(" line "), line);
  else
    fprintf (stderr, "%s: ", ename);
}
warning: parse error {
  char *ename;
  int line;

  ename = get_name_for_error ();
  line = (print_lineno && interactive_shell == 0) ? executing_line_number () : -1;

  if (line > 0)
    fprintf (stderr, "%s:%s%d: ", ename, gnu_error_format ? "" : _(" line "), line);
  else
    fprintf (stderr, "%s: ", ename);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\error.c:81
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\error.c:133
parsing error 
{
  report_error ("%s: %s", filename, strerror (errno));
}
warning: parse error {
  report_error ("%s: %s", filename, strerror (errno));
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\error.c:134
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\error.c:143
parsing error 
va_dcl
#endif
{
  va_list args;
  char *h;

#if defined (JOB_CONTROL)
  give_terminal_to (shell_pgrp, 0);
#endif /* JOB_CONTROL */

  SH_VA_START (args, format);

  vfprintf (stderr, format, args);
  fprintf (stderr, "\n");
  va_end (args);

#if defined (HISTORY)
  if (remember_on_history)
    {
      h = last_history_line ();
      fprintf (stderr, _("last command: %s\n"), h ? h : "(null)");
    }
#endif

#if 0
  fprintf (stderr, "Report this to %s\n", the_current_maintainer);
#endif

  fprintf (stderr, _("Aborting..."));
  fflush (stderr);

  abort ();
}
warning: parse error va_dcl
#endif
{
  va_list args;
  char *h;

#if defined (JOB_CONTROL)
  give_terminal_to (shell_pgrp, 0);
#endif /* JOB_CONTROL */

  SH_VA_START (args, format);

  vfprintf (stderr, format, args);
  fprintf (stderr, "\n");
  va_end (args);

#if defined (HISTORY)
  if (remember_on_history)
    {
      h = last_history_line ();
      fprintf (stderr, _("last command: %s\n"), h ? h : "(null)");
    }
#endif

#if 0
  fprintf (stderr, "Report this to %s\n", the_current_maintainer);
#endif

  fprintf (stderr, _("Aborting..."));
  fflush (stderr);

  abort ();
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\error.c:144
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\error.c:187
parsing error 
va_dcl
#endif
{
  va_list args;

  error_prolog (1);

  SH_VA_START (args, format);

  vfprintf (stderr, format, args);
  fprintf (stderr, "\n");

  va_end (args);
  if (exit_immediately_on_error)
    {
      if (last_command_exit_value == 0)
	last_command_exit_value = EXECUTION_FAILURE;
      exit_shell (last_command_exit_value);
    }
}
warning: parse error va_dcl
#endif
{
  va_list args;

  error_prolog (1);

  SH_VA_START (args, format);

  vfprintf (stderr, format, args);
  fprintf (stderr, "\n");

  va_end (args);
  if (exit_immediately_on_error)
    {
      if (last_command_exit_value == 0)
	last_command_exit_value = EXECUTION_FAILURE;
      exit_shell (last_command_exit_value);
    }
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\error.c:188
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\error.c:214
parsing error 
va_dcl
#endif
{
  va_list args;

  error_prolog (0);

  SH_VA_START (args, format);

  vfprintf (stderr, format, args);
  fprintf (stderr, "\n");

  va_end (args);
  sh_exit (2);
}
warning: parse error va_dcl
#endif
{
  va_list args;

  error_prolog (0);

  SH_VA_START (args, format);

  vfprintf (stderr, format, args);
  fprintf (stderr, "\n");

  va_end (args);
  sh_exit (2);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\error.c:215
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\error.c:236
parsing error 
va_dcl
#endif
{
  va_list args;

  error_prolog (1);

  SH_VA_START (args, format);

  vfprintf (stderr, format, args);
  fprintf (stderr, "\n");

  va_end (args);
}
warning: parse error va_dcl
#endif
{
  va_list args;

  error_prolog (1);

  SH_VA_START (args, format);

  vfprintf (stderr, format, args);
  fprintf (stderr, "\n");

  va_end (args);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\error.c:237
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\error.c:257
parsing error 
va_dcl
#endif
{
  va_list args;

  error_prolog (1);
  fprintf (stderr, _("warning: "));

  SH_VA_START (args, format);

  vfprintf (stderr, format, args);
  fprintf (stderr, "\n");

  va_end (args);
}
warning: parse error va_dcl
#endif
{
  va_list args;

  error_prolog (1);
  fprintf (stderr, _("warning: "));

  SH_VA_START (args, format);

  vfprintf (stderr, format, args);
  fprintf (stderr, "\n");

  va_end (args);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\error.c:258
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\error.c:279
parsing error 
va_dcl
#endif
{
  va_list args;

  error_prolog (1);
  /* TRANSLATORS: this is a prefix for informational messages. */
  fprintf (stderr, _("INFORM: "));

  SH_VA_START (args, format);

  vfprintf (stderr, format, args);
  fprintf (stderr, "\n");

  va_end (args);
}
warning: parse error va_dcl
#endif
{
  va_list args;

  error_prolog (1);
  /* TRANSLATORS: this is a prefix for informational messages. */
  fprintf (stderr, _("INFORM: "));

  SH_VA_START (args, format);

  vfprintf (stderr, format, args);
  fprintf (stderr, "\n");

  va_end (args);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\error.c:280
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\error.c:302
parsing error 
va_dcl
#endif
{
  int e;
  va_list args;

  e = errno;
  error_prolog (0);

  SH_VA_START (args, format);

  vfprintf (stderr, format, args);
  fprintf (stderr, ": %s\n", strerror (e));

  va_end (args);
}
warning: parse error va_dcl
#endif
{
  int e;
  va_list args;

  e = errno;
  error_prolog (0);

  SH_VA_START (args, format);

  vfprintf (stderr, format, args);
  fprintf (stderr, ": %s\n", strerror (e));

  va_end (args);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\error.c:303
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\error.c:332
parsing error 
va_dcl
#endif
{
  va_list args;
  char *ename, *iname;

  ename = get_name_for_error ();
  iname = yy_input_name ();

  if (interactive)
    fprintf (stderr, "%s: ", ename);
  else if (interactive_shell)
    fprintf (stderr, "%s: %s:%s%d: ", ename, iname, gnu_error_format ? "" : _(" line "), lineno);
  else if (STREQ (ename, iname))
    fprintf (stderr, "%s:%s%d: ", ename, gnu_error_format ? "" : _(" line "), lineno);
  else
    fprintf (stderr, "%s: %s:%s%d: ", ename, iname, gnu_error_format ? "" : _(" line "), lineno);

  SH_VA_START (args, format);

  vfprintf (stderr, format, args);
  fprintf (stderr, "\n");

  va_end (args);

  if (exit_immediately_on_error)
    exit_shell (last_command_exit_value = 2);
}
warning: parse error va_dcl
#endif
{
  va_list args;
  char *ename, *iname;

  ename = get_name_for_error ();
  iname = yy_input_name ();

  if (interactive)
    fprintf (stderr, "%s: ", ename);
  else if (interactive_shell)
    fprintf (stderr, "%s: %s:%s%d: ", ename, iname, gnu_error_format ? "" : _(" line "), lineno);
  else if (STREQ (ename, iname))
    fprintf (stderr, "%s:%s%d: ", ename, gnu_error_format ? "" : _(" line "), lineno);
  else
    fprintf (stderr, "%s: %s:%s%d: ", ename, iname, gnu_error_format ? "" : _(" line "), lineno);

  SH_VA_START (args, format);

  vfprintf (stderr, format, args);
  fprintf (stderr, "\n");

  va_end (args);

  if (exit_immediately_on_error)
    exit_shell (last_command_exit_value = 2);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\error.c:335
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\error.c:471
parsing error 
{
  if (code > CMDERR_LAST)
    code = CMDERR_DEFAULT;

  programming_error ("%s: %s: %d", func, _(cmd_error_table[code]), e);
}
warning: parse error {
  if (code > CMDERR_LAST)
    code = CMDERR_DEFAULT;

  programming_error ("%s: %s: %d", func, _(cmd_error_table[code]), e);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\error.c:473
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\error.c:481
parsing error 
{
  if (code > CMDERR_LAST)
    code = CMDERR_DEFAULT;

  return (_(cmd_error_table[code]));
}
warning: parse error {
  if (code > CMDERR_LAST)
    code = CMDERR_DEFAULT;

  return (_(cmd_error_table[code]));
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\error.c:483
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\error.c:501
parsing error 
{
  report_error (_("%s: unbound variable"), s);
}
warning: parse error {
  report_error (_("%s: unbound variable"), s);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\error.c:502
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\error.c:508
parsing error 
{
  report_error (_("%s: readonly variable"), s);
}
warning: parse error {
  report_error (_("%s: readonly variable"), s);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\error.c:509
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\eval.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashansi.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashintl.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\shell.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\parser.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\flags.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\trap.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\common.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\input.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\execute_cmd.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\eval.c:237
parsing error 
{
  char *msg;

  msg = _("\007timed out waiting for input: auto-logout\n");
  write (1, msg, strlen (msg));

  bash_logout ();	/* run ~/.bash_logout if this is a login shell */
  jump_to_top_level (EXITPROG);
  SIGRETURN (0);
}
warning: parse error {
  char *msg;

  msg = _("\007timed out waiting for input: auto-logout\n");
  write (1, msg, strlen (msg));

  bash_logout ();	/* run ~/.bash_logout if this is a login shell */
  jump_to_top_level (EXITPROG);
  SIGRETURN (0);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\eval.c:239
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\accept.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashtypes.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\typemax.h...skip
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\loadables.h...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\shell.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\bashgetopt.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\common.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\accept.c:44
parsing error 
{
  WORD_LIST *l;
  SHELL_VAR *v;
  intmax_t iport;
  int opt;
  char *tmoutarg, *fdvar, *rhostvar, *rhost;
  unsigned short uport;
  int servsock, clisock;
  struct sockaddr_in server, client;
  socklen_t clientlen;
  struct timeval timeval;
  struct linger linger = { 0, 0 };

  rhostvar = tmoutarg = fdvar = rhost = (char *)NULL;

  reset_internal_getopt ();
  while ((opt = internal_getopt (list, "r:t:v:")) != -1)
    {
      switch (opt)
	{
	case 'r':
	  rhostvar = list_optarg;
	  break;
	case 't':
	  tmoutarg = list_optarg;
	  break;
	case 'v':
	  fdvar = list_optarg;
	  break;
	CASE_HELPOPT;
	default:
	  builtin_usage ();
	  return (EX_USAGE);
	}
    }
  
  list = loptend;

  /* Validate input and variables */
  if (tmoutarg)
    {
      long ival, uval;
      opt = uconvert (tmoutarg, &ival, &uval, (char **)0);
      if (opt == 0 || ival < 0 || uval < 0)
	{
	  builtin_error ("%s: invalid timeout specification", tmoutarg);
	  return (EXECUTION_FAILURE);
	}
      timeval.tv_sec = ival;
      timeval.tv_usec = uval;
      /* XXX - should we warn if ival == uval == 0 ? */
    }

  if (list == 0)
    {
      builtin_usage ();
      return (EX_USAGE);
    }

  if (legal_number (list->word->word, &iport) == 0 || iport < 0 || iport > TYPE_MAXIMUM (unsigned short))
    {
      builtin_error ("%s: invalid port number", list->word->word);
      return (EXECUTION_FAILURE);
    }
  uport = (unsigned short)iport;

  if (fdvar == 0)
    fdvar = "ACCEPT_FD";

  unbind_variable (fdvar);
  if (rhostvar)
    unbind_variable (rhostvar);
    
  if ((servsock = socket (AF_INET, SOCK_STREAM, IPPROTO_IP)) < 0)
    {
      builtin_error ("cannot create socket: %s", strerror (errno));
      return (EXECUTION_FAILURE);
    }

  memset ((char *)&server, 0, sizeof (server));
  server.sin_family = AF_INET;
  server.sin_port = htons(uport);
  server.sin_addr.s_addr = htonl(INADDR_ANY);

  if (bind (servsock, (struct sockaddr *)&server, sizeof (server)) < 0)
    {
      builtin_error ("socket bind failure: %s", strerror (errno));
      close (servsock);
      return (EXECUTION_FAILURE);
    }

  opt = 1;
  setsockopt (servsock, SOL_SOCKET, SO_REUSEADDR, (void *)&opt, sizeof (opt));
  setsockopt (servsock, SOL_SOCKET, SO_LINGER, (void *)&linger, sizeof (linger));

  if (listen (servsock, 1) < 0)
    {
      builtin_error ("listen failure: %s", strerror (errno));
      close (servsock);
      return (EXECUTION_FAILURE);
    }

  if (tmoutarg)
    {
      fd_set iofds;

      FD_ZERO(&iofds);
      FD_SET(servsock, &iofds);

      opt = select (servsock+1, &iofds, 0, 0, &timeval);
      if (opt < 0)
        builtin_error ("select failure: %s", strerror (errno));
      if (opt <= 0)
        {
          close (servsock);
          return (EXECUTION_FAILURE);
        }
    }

  clientlen = sizeof (client);
  if ((clisock = accept (servsock, (struct sockaddr *)&client, &clientlen)) < 0)
    {
      builtin_error ("client accept failure: %s", strerror (errno));
      close (servsock);
      return (EXECUTION_FAILURE);
    }

  close (servsock);

  accept_bind_variable (fdvar, clisock);  
  if (rhostvar)
    {
      rhost = inet_ntoa (client.sin_addr);
      v = builtin_bind_variable (rhostvar, rhost, 0);
      if (v == 0 || readonly_p (v) || noassign_p (v))
	builtin_error ("%s: cannot set variable", rhostvar);
    }

  return (EXECUTION_SUCCESS);
}
warning: parse error {
  WORD_LIST *l;
  SHELL_VAR *v;
  intmax_t iport;
  int opt;
  char *tmoutarg, *fdvar, *rhostvar, *rhost;
  unsigned short uport;
  int servsock, clisock;
  struct sockaddr_in server, client;
  socklen_t clientlen;
  struct timeval timeval;
  struct linger linger = { 0, 0 };

  rhostvar = tmoutarg = fdvar = rhost = (char *)NULL;

  reset_internal_getopt ();
  while ((opt = internal_getopt (list, "r:t:v:")) != -1)
    {
      switch (opt)
	{
	case 'r':
	  rhostvar = list_optarg;
	  break;
	case 't':
	  tmoutarg = list_optarg;
	  break;
	case 'v':
	  fdvar = list_optarg;
	  break;
	CASE_HELPOPT;
	default:
	  builtin_usage ();
	  return (EX_USAGE);
	}
    }
  
  list = loptend;

  /* Validate input and variables */
  if (tmoutarg)
    {
      long ival, uval;
      opt = uconvert (tmoutarg, &ival, &uval, (char **)0);
      if (opt == 0 || ival < 0 || uval < 0)
	{
	  builtin_error ("%s: invalid timeout specification", tmoutarg);
	  return (EXECUTION_FAILURE);
	}
      timeval.tv_sec = ival;
      timeval.tv_usec = uval;
      /* XXX - should we warn if ival == uval == 0 ? */
    }

  if (list == 0)
    {
      builtin_usage ();
      return (EX_USAGE);
    }

  if (legal_number (list->word->word, &iport) == 0 || iport < 0 || iport > TYPE_MAXIMUM (unsigned short))
    {
      builtin_error ("%s: invalid port number", list->word->word);
      return (EXECUTION_FAILURE);
    }
  uport = (unsigned short)iport;

  if (fdvar == 0)
    fdvar = "ACCEPT_FD";

  unbind_variable (fdvar);
  if (rhostvar)
    unbind_variable (rhostvar);
    
  if ((servsock = socket (AF_INET, SOCK_STREAM, IPPROTO_IP)) < 0)
    {
      builtin_error ("cannot create socket: %s", strerror (errno));
      return (EXECUTION_FAILURE);
    }

  memset ((char *)&server, 0, sizeof (server));
  server.sin_family = AF_INET;
  server.sin_port = htons(uport);
  server.sin_addr.s_addr = htonl(INADDR_ANY);

  if (bind (servsock, (struct sockaddr *)&server, sizeof (server)) < 0)
    {
      builtin_error ("socket bind failure: %s", strerror (errno));
      close (servsock);
      return (EXECUTION_FAILURE);
    }

  opt = 1;
  setsockopt (servsock, SOL_SOCKET, SO_REUSEADDR, (void *)&opt, sizeof (opt));
  setsockopt (servsock, SOL_SOCKET, SO_LINGER, (void *)&linger, sizeof (linger));

  if (listen (servsock, 1) < 0)
    {
      builtin_error ("listen failure: %s", strerror (errno));
      close (servsock);
      return (EXECUTION_FAILURE);
    }

  if (tmoutarg)
    {
      fd_set iofds;

      FD_ZERO(&iofds);
      FD_SET(servsock, &iofds);

      opt = select (servsock+1, &iofds, 0, 0, &timeval);
      if (opt < 0)
        builtin_error ("select failure: %s", strerror (errno));
      if (opt <= 0)
        {
          close (servsock);
          return (EXECUTION_FAILURE);
        }
    }

  clientlen = sizeof (client);
  if ((clisock = accept (servsock, (struct sockaddr *)&client, &clientlen)) < 0)
    {
      builtin_error ("client accept failure: %s", strerror (errno));
      close (servsock);
      return (EXECUTION_FAILURE);
    }

  close (servsock);

  accept_bind_variable (fdvar, clisock);  
  if (rhostvar)
    {
      rhost = inet_ntoa (client.sin_addr);
      v = builtin_bind_variable (rhostvar, rhost, 0);
      if (v == 0 || readonly_p (v) || noassign_p (v))
	builtin_error ("%s: cannot set variable", rhostvar);
    }

  return (EXECUTION_SUCCESS);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\accept.c:46
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\accept.c:188
parsing error 
{
  SHELL_VAR *v;
  char ibuf[INT_STRLEN_BOUND (int) + 1], *p;

  p = fmtulong (intval, 10, ibuf, sizeof (ibuf), 0);
  v = builtin_bind_variable (varname, p, 0);
  if (v == 0 || readonly_p (v) || noassign_p (v))
    builtin_error ("%s: cannot set variable", varname);
  return (v != 0);
}
warning: parse error {
  SHELL_VAR *v;
  char ibuf[INT_STRLEN_BOUND (int) + 1], *p;

  p = fmtulong (intval, 10, ibuf, sizeof (ibuf), 0);
  v = builtin_bind_variable (varname, p, 0);
  if (v == 0 || readonly_p (v) || noassign_p (v))
    builtin_error ("%s: cannot set variable", varname);
  return (v != 0);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\accept.c:191
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\asort.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashtypes.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\shell.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\common.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\xmalloc.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\bashgetopt.h...skip
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\basename.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\shell.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\common.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\bashgetopt.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\basename.c:36
parsing error 
{
  int slen, sufflen, off;
  char *string, *suffix, *fn;

  if (no_options (list))
    return (EX_USAGE);
  list = loptend;
  if (list == 0)
    {
      builtin_usage ();
      return (EX_USAGE);
    }    

  string = list->word->word;
  suffix = (char *)NULL;
  if (list->next)
    {
      list = list->next;
      suffix = list->word->word;
    }

  if (list->next)
    {
      builtin_usage ();
      return (EX_USAGE);
    }

  slen = strlen (string);

  /* Strip trailing slashes */
  while (slen > 0 && string[slen - 1] == '/')
    slen--;

  /* (2) If string consists entirely of slash characters, string shall be
	 set to a single slash character.  In this case, skip steps (3)
	 through (5). */
  if (slen == 0)
    {
      fputs ("/\n", stdout);
      return (EXECUTION_SUCCESS);
    }

  /* (3) If there are any trailing slash characters in string, they
	 shall be removed. */
  string[slen] = '\0';

  /* (4) If there are any slash characters remaining in string, the prefix
	 of string up to an including the last slash character in string
	 shall be removed. */
  while (--slen >= 0)
    if (string[slen] == '/')
      break;

  fn = string + slen + 1;

  /* (5) If the suffix operand is present, is not identical to the
	 characters remaining in string, and is identical to a suffix
	 of the characters remaining in string, the suffix suffix
	 shall be removed from string.  Otherwise, string shall not be
	 modified by this step. */
  if (suffix)
    {
      sufflen = strlen (suffix);
      slen = strlen (fn);
      if (sufflen < slen)
        {
          off = slen - sufflen;
          if (strcmp (fn + off, suffix) == 0)
            fn[off] = '\0';
        }
    }
  printf ("%s\n", fn);
  return (EXECUTION_SUCCESS);
}
warning: parse error {
  int slen, sufflen, off;
  char *string, *suffix, *fn;

  if (no_options (list))
    return (EX_USAGE);
  list = loptend;
  if (list == 0)
    {
      builtin_usage ();
      return (EX_USAGE);
    }    

  string = list->word->word;
  suffix = (char *)NULL;
  if (list->next)
    {
      list = list->next;
      suffix = list->word->word;
    }

  if (list->next)
    {
      builtin_usage ();
      return (EX_USAGE);
    }

  slen = strlen (string);

  /* Strip trailing slashes */
  while (slen > 0 && string[slen - 1] == '/')
    slen--;

  /* (2) If string consists entirely of slash characters, string shall be
	 set to a single slash character.  In this case, skip steps (3)
	 through (5). */
  if (slen == 0)
    {
      fputs ("/\n", stdout);
      return (EXECUTION_SUCCESS);
    }

  /* (3) If there are any trailing slash characters in string, they
	 shall be removed. */
  string[slen] = '\0';

  /* (4) If there are any slash characters remaining in string, the prefix
	 of string up to an including the last slash character in string
	 shall be removed. */
  while (--slen >= 0)
    if (string[slen] == '/')
      break;

  fn = string + slen + 1;

  /* (5) If the suffix operand is present, is not identical to the
	 characters remaining in string, and is identical to a suffix
	 of the characters remaining in string, the suffix suffix
	 shall be removed from string.  Otherwise, string shall not be
	 modified by this step. */
  if (suffix)
    {
      sufflen = strlen (suffix);
      slen = strlen (fn);
      if (sufflen < slen)
        {
          off = slen - sufflen;
          if (strcmp (fn + off, suffix) == 0)
            fn[off] = '\0';
        }
    }
  printf ("%s\n", fn);
  return (EXECUTION_SUCCESS);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\basename.c:38
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\cat.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\shell.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\cat.c:39
parsing error 
{
	char	buf[1024], *s;
	int	n, w, e;

	while (n = read(fd, buf, sizeof (buf))) {
		w = write(1, buf, n);
		if (w != n) {
			e = errno;
			write(2, "cat: write error: ", 18);
			s = strerror(e);
			write(2, s, strlen(s));
			write(2, "\n", 1);
			return 1;
		}
	}
	return 0;
}
warning: parse error {
	char	buf[1024], *s;
	int	n, w, e;

	while (n = read(fd, buf, sizeof (buf))) {
		w = write(1, buf, n);
		if (w != n) {
			e = errno;
			write(2, "cat: write error: ", 18);
			s = strerror(e);
			write(2, s, strlen(s));
			write(2, "\n", 1);
			return 1;
		}
	}
	return 0;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\cat.c:41
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\cat.c:60
parsing error 
{
	int	i, fd, r;
	char	*s;

	if (argc == 1)
		return (fcopy(0));

	for (i = r = 1; i < argc; i++) {
		if (argv[i][0] == '-' && argv[i][1] == '\0')
			fd = 0;
		else {
			fd = open(argv[i], O_RDONLY, 0666);
			if (fd < 0) {
				s = strerror(errno);
				write(2, "cat: cannot open ", 17);
				write(2, argv[i], strlen(argv[i]));
				write(2, ": ", 2);
				write(2, s, strlen(s));
				write(2, "\n", 1);
				continue;
			}
		}
		r = fcopy(fd);
		if (fd != 0)
			close(fd);
	}
	return (r);
}
warning: parse error {
	int	i, fd, r;
	char	*s;

	if (argc == 1)
		return (fcopy(0));

	for (i = r = 1; i < argc; i++) {
		if (argv[i][0] == '-' && argv[i][1] == '\0')
			fd = 0;
		else {
			fd = open(argv[i], O_RDONLY, 0666);
			if (fd < 0) {
				s = strerror(errno);
				write(2, "cat: cannot open ", 17);
				write(2, argv[i], strlen(argv[i]));
				write(2, ": ", 2);
				write(2, s, strlen(s));
				write(2, "\n", 1);
				continue;
			}
		}
		r = fcopy(fd);
		if (fd != 0)
			close(fd);
	}
	return (r);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\cat.c:63
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\cat.c:93
parsing error 
{
	char	**v;
	int	c, r;

	v = make_builtin_argv(list, &c);
	r = cat_main(c, v);
	free(v);

	return r;
}
warning: parse error {
	char	**v;
	int	c, r;

	v = make_builtin_argv(list, &c);
	r = cat_main(c, v);
	free(v);

	return r;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\cat.c:95
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\csv.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashansi.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\loadables.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\csv.c:42
parsing error 
{
  arrayind_t ind;
  char *field, *prev, *buf, *xbuf;
  int delim, qstate;
  int b, rval;

  xbuf = 0;
  ind = 0;
  field = prev = line;

  do
    {
      if (*prev == '"')
	{
	  if (xbuf == 0)
	    xbuf = xmalloc (strlen (prev) + 1);
	  buf = xbuf;
	  b = 0;
	  qstate = DQUOTE;
	  for (field = ++prev; *field; field++)
	    {
	      if (qstate == DQUOTE && *field == '"' && field[1] == '"')
		buf[b++] = *field++;	/* skip double quote */
	      else if (qstate == DQUOTE && *field == '"')
	        qstate = NQUOTE;
	      else if (qstate == NQUOTE && *field == ',')
		break;
	      else
		/* This copies any text between a closing double quote and the
		   delimiter. If you want to change that, make sure to do the
		   copy only if qstate == DQUOTE. */
		buf[b++] = *field;
	    }
	  buf[b] = '\0';
	}
      else
	{
	  buf = prev;
	  field = prev + strcspn (prev, ",");
	}

      delim = *field;
      *field = '\0';

      bind_array_element (csv, ind, buf, 0);
      ind++;

      *field = delim;

      if (delim == ',')
	prev = field + 1;
    }
  while (delim == ',');

  if (xbuf)
    free (xbuf);

  return (rval = ind);				/* number of fields */
}
warning: parse error {
  arrayind_t ind;
  char *field, *prev, *buf, *xbuf;
  int delim, qstate;
  int b, rval;

  xbuf = 0;
  ind = 0;
  field = prev = line;

  do
    {
      if (*prev == '"')
	{
	  if (xbuf == 0)
	    xbuf = xmalloc (strlen (prev) + 1);
	  buf = xbuf;
	  b = 0;
	  qstate = DQUOTE;
	  for (field = ++prev; *field; field++)
	    {
	      if (qstate == DQUOTE && *field == '"' && field[1] == '"')
		buf[b++] = *field++;	/* skip double quote */
	      else if (qstate == DQUOTE && *field == '"')
	        qstate = NQUOTE;
	      else if (qstate == NQUOTE && *field == ',')
		break;
	      else
		/* This copies any text between a closing double quote and the
		   delimiter. If you want to change that, make sure to do the
		   copy only if qstate == DQUOTE. */
		buf[b++] = *field;
	    }
	  buf[b] = '\0';
	}
      else
	{
	  buf = prev;
	  field = prev + strcspn (prev, ",");
	}

      delim = *field;
      *field = '\0';

      bind_array_element (csv, ind, buf, 0);
      ind++;

      *field = delim;

      if (delim == ',')
	prev = field + 1;
    }
  while (delim == ',');

  if (xbuf)
    free (xbuf);

  return (rval = ind);				/* number of fields */
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\csv.c:45
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\csv.c:106
parsing error 
{
  int opt, rval;
  char *array_name, *csvstring;
  SHELL_VAR *v;

  array_name = 0;
  rval = EXECUTION_SUCCESS;

  reset_internal_getopt ();
  while ((opt = internal_getopt (list, "a:")) != -1)
    {
      switch (opt)
	{
	case 'a':
	  array_name = list_optarg;
	  break;
	CASE_HELPOPT;
	default:
	  builtin_usage ();
	  return (EX_USAGE);
	}
    }
  list = loptend;

  if (array_name == 0)
    array_name = CSV_ARRAY_DEFAULT;

  if (legal_identifier (array_name) == 0)
    {
      sh_invalidid (array_name);
      return (EXECUTION_FAILURE);
    }

  if (list == 0)
    {
      builtin_error ("csv string argument required");
      return (EX_USAGE);
    }

  v = find_or_make_array_variable (array_name, 1);
  if (v == 0 || readonly_p (v) || noassign_p (v))
    {
      if (v && readonly_p (v))
	err_readonly (array_name);
      return (EXECUTION_FAILURE);
    }
  else if (array_p (v) == 0)
    {
      builtin_error ("%s: not an indexed array", array_name);
      return (EXECUTION_FAILURE);
    }
  if (invisible_p (v))
    VUNSETATTR (v, att_invisible);
  array_flush (array_cell (v));

  csvstring = list->word->word;

  if (csvstring == 0 || *csvstring == 0)
    return (EXECUTION_SUCCESS);

  opt = csvsplit (v, csvstring);
  /* Maybe do something with OPT here, it's the number of fields */

  return (rval);
}
warning: parse error {
  int opt, rval;
  char *array_name, *csvstring;
  SHELL_VAR *v;

  array_name = 0;
  rval = EXECUTION_SUCCESS;

  reset_internal_getopt ();
  while ((opt = internal_getopt (list, "a:")) != -1)
    {
      switch (opt)
	{
	case 'a':
	  array_name = list_optarg;
	  break;
	CASE_HELPOPT;
	default:
	  builtin_usage ();
	  return (EX_USAGE);
	}
    }
  list = loptend;

  if (array_name == 0)
    array_name = CSV_ARRAY_DEFAULT;

  if (legal_identifier (array_name) == 0)
    {
      sh_invalidid (array_name);
      return (EXECUTION_FAILURE);
    }

  if (list == 0)
    {
      builtin_error ("csv string argument required");
      return (EX_USAGE);
    }

  v = find_or_make_array_variable (array_name, 1);
  if (v == 0 || readonly_p (v) || noassign_p (v))
    {
      if (v && readonly_p (v))
	err_readonly (array_name);
      return (EXECUTION_FAILURE);
    }
  else if (array_p (v) == 0)
    {
      builtin_error ("%s: not an indexed array", array_name);
      return (EXECUTION_FAILURE);
    }
  if (invisible_p (v))
    VUNSETATTR (v, att_invisible);
  array_flush (array_cell (v));

  csvstring = list->word->word;

  if (csvstring == 0 || *csvstring == 0)
    return (EXECUTION_SUCCESS);

  opt = csvsplit (v, csvstring);
  /* Maybe do something with OPT here, it's the number of fields */

  return (rval);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\csv.c:108
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\csv.c:177
parsing error 
{
  return (1);
}
warning: parse error {
  return (1);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\csv.c:179
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\csv.c:185
parsing error 
{
}
warning: parse error {
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\csv.c:187
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\cut.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashansi.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\loadables.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\shmbutil.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\cut.c:64
parsing error 
{
  struct cutpos *p1, *p2;

  p1 = (struct cutpos *)a;
  p2 = (struct cutpos *)b;
  return (p1->startpos - p2->startpos);
}
warning: parse error {
  struct cutpos *p1, *p2;

  p1 = (struct cutpos *)a;
  p2 = (struct cutpos *)b;
  return (p1->startpos - p2->startpos);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\cut.c:66
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\cut.c:75
parsing error 
{
  char *ntok, *ltok, *larg;
  int s, e;
  intmax_t num;
  struct cutpos *poslist;
  int npos, nsize;

  poslist = 0;
  nsize = npos = 0;
  s = e = 0;
  larg = arg;
  while (ltok = strsep (&larg, ","))
    {
      if (*ltok == 0)
        continue;

      ntok = strsep (&ltok, "-");
      if (*ntok == 0)
        s = BOL;
      else
	{
	  if (legal_number (ntok, &num) == 0 || (int)num != num || num <= 0)
	    {
	      builtin_error ("%s: invalid list value", ntok);
	      *opp = poslist;
	      return -1;
	    }
	  s = num;
	  s--;		/* fields are 1-based */
	}
      if (ltok == 0)
	e = NORANGE;
      else if (*ltok == 0)
	e = EOL;
      else
	{
	  if (legal_number (ltok, &num) == 0 || (int)num != num || num <= 0)
	    {
	      builtin_error ("%s: invalid list value", ltok);
	      *opp = poslist;
	      return -1;
	    }
	  e = num;
	  e--;
	  if (e == s)
	    e = NORANGE;
	}

      if (npos == nsize)
	{
	  nsize += 4;
	  poslist = (struct cutpos *)xrealloc (poslist, nsize * sizeof (struct cutpos));
	}
      poslist[npos].startpos = s;
      poslist[npos].endpos = e; 
      npos++;
    }
  if (npos == 0)
    {
      builtin_error ("missing list of positions");
      *opp = poslist;
      return -1;
    }

  qsort (poslist, npos, sizeof(poslist[0]), poscmp);
  *opp = poslist;

  return npos;
}
warning: parse error {
  char *ntok, *ltok, *larg;
  int s, e;
  intmax_t num;
  struct cutpos *poslist;
  int npos, nsize;

  poslist = 0;
  nsize = npos = 0;
  s = e = 0;
  larg = arg;
  while (ltok = strsep (&larg, ","))
    {
      if (*ltok == 0)
        continue;

      ntok = strsep (&ltok, "-");
      if (*ntok == 0)
        s = BOL;
      else
	{
	  if (legal_number (ntok, &num) == 0 || (int)num != num || num <= 0)
	    {
	      builtin_error ("%s: invalid list value", ntok);
	      *opp = poslist;
	      return -1;
	    }
	  s = num;
	  s--;		/* fields are 1-based */
	}
      if (ltok == 0)
	e = NORANGE;
      else if (*ltok == 0)
	e = EOL;
      else
	{
	  if (legal_number (ltok, &num) == 0 || (int)num != num || num <= 0)
	    {
	      builtin_error ("%s: invalid list value", ltok);
	      *opp = poslist;
	      return -1;
	    }
	  e = num;
	  e--;
	  if (e == s)
	    e = NORANGE;
	}

      if (npos == nsize)
	{
	  nsize += 4;
	  poslist = (struct cutpos *)xrealloc (poslist, nsize * sizeof (struct cutpos));
	}
      poslist[npos].startpos = s;
      poslist[npos].endpos = e; 
      npos++;
    }
  if (npos == 0)
    {
      builtin_error ("missing list of positions");
      *opp = poslist;
      return -1;
    }

  qsort (poslist, npos, sizeof(poslist[0]), poscmp);
  *opp = poslist;

  return npos;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\cut.c:78
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\cut.c:149
parsing error 
{
  arrayind_t ind;
  char *buf, *bmap;
  size_t llen;
  int i, b, n, s, e;

  llen = strlen (line);
  buf = xmalloc (llen + 1);
  bmap = xmalloc (llen + 1);
  memset (bmap, 0, llen);

  for (n = 0; n < ops->npos; n++)
    {
      s = ops->poslist[n].startpos;		/* no translation needed yet */
      e = ops->poslist[n].endpos;
      if (e == NORANGE)
        e = s;
      else if (e == EOL || e >= llen)
	e = llen - 1;
      /* even if a column is specified multiple times, it will only be printed
         once */
      for (i = s; i <= e; i++)
	bmap[i] = 1;
    }

  b = 0;
  for (i = 0; i < llen; i++)
    if (bmap[i])
      buf[b++] = line[i];
  buf[b] = 0; 

  if (v)
    {
      ind = 0;
      bind_array_element (v, ind, buf, 0);
      ind++;
    }
  else
    printf ("%s\n", buf);

  free (buf);
  free (bmap);

  return ind;
}
warning: parse error {
  arrayind_t ind;
  char *buf, *bmap;
  size_t llen;
  int i, b, n, s, e;

  llen = strlen (line);
  buf = xmalloc (llen + 1);
  bmap = xmalloc (llen + 1);
  memset (bmap, 0, llen);

  for (n = 0; n < ops->npos; n++)
    {
      s = ops->poslist[n].startpos;		/* no translation needed yet */
      e = ops->poslist[n].endpos;
      if (e == NORANGE)
        e = s;
      else if (e == EOL || e >= llen)
	e = llen - 1;
      /* even if a column is specified multiple times, it will only be printed
         once */
      for (i = s; i <= e; i++)
	bmap[i] = 1;
    }

  b = 0;
  for (i = 0; i < llen; i++)
    if (bmap[i])
      buf[b++] = line[i];
  buf[b] = 0; 

  if (v)
    {
      ind = 0;
      bind_array_element (v, ind, buf, 0);
      ind++;
    }
  else
    printf ("%s\n", buf);

  free (buf);
  free (bmap);

  return ind;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\cut.c:153
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\cut.c:200
parsing error 
{
  arrayind_t ind;
  char *buf, *bmap;
  wchar_t *wbuf, *wb2;
  size_t llen, wlen;
  int i, b, n, s, e;

  if (MB_CUR_MAX == 1)
    return (cutbytes (v, line, ops));
  if (locale_utf8locale && utf8_mbsmbchar (line) == 0)
    return (cutbytes (v, line, ops));

  llen = strlen (line);
  wbuf = (wchar_t *)xmalloc ((llen + 1) * sizeof (wchar_t));

  wlen = mbstowcs (wbuf, line, llen);
  if (MB_INVALIDCH (wlen))
    {
      free (wbuf);
      return (cutbytes (v, line, ops));
    }

  bmap = xmalloc (llen + 1);
  memset (bmap, 0, llen);
  
  for (n = 0; n < ops->npos; n++)
    {
      s = ops->poslist[n].startpos;		/* no translation needed yet */
      e = ops->poslist[n].endpos;
      if (e == NORANGE)
        e = s;
      else if (e == EOL || e >= wlen)
	e = wlen - 1;
      /* even if a column is specified multiple times, it will only be printed
         once */
      for (i = s; i <= e; i++)
	bmap[i] = 1;
    }

  wb2 = (wchar_t *)xmalloc ((wlen + 1) * sizeof (wchar_t));
  b = 0;
  for (i = 0; i < wlen; i++)
    if (bmap[i])
      wb2[b++] = wbuf[i];
  wb2[b] = 0;

  free (wbuf);

  buf = bmap;
  n = wcstombs (buf, wb2, llen);

  if (v)
    {
      ind = 0;
      bind_array_element (v, ind, buf, 0);
      ind++;
    }
  else
    printf ("%s\n", buf);

  free (buf);
  free (wb2);

  return ind;
}
warning: parse error {
  arrayind_t ind;
  char *buf, *bmap;
  wchar_t *wbuf, *wb2;
  size_t llen, wlen;
  int i, b, n, s, e;

  if (MB_CUR_MAX == 1)
    return (cutbytes (v, line, ops));
  if (locale_utf8locale && utf8_mbsmbchar (line) == 0)
    return (cutbytes (v, line, ops));

  llen = strlen (line);
  wbuf = (wchar_t *)xmalloc ((llen + 1) * sizeof (wchar_t));

  wlen = mbstowcs (wbuf, line, llen);
  if (MB_INVALIDCH (wlen))
    {
      free (wbuf);
      return (cutbytes (v, line, ops));
    }

  bmap = xmalloc (llen + 1);
  memset (bmap, 0, llen);
  
  for (n = 0; n < ops->npos; n++)
    {
      s = ops->poslist[n].startpos;		/* no translation needed yet */
      e = ops->poslist[n].endpos;
      if (e == NORANGE)
        e = s;
      else if (e == EOL || e >= wlen)
	e = wlen - 1;
      /* even if a column is specified multiple times, it will only be printed
         once */
      for (i = s; i <= e; i++)
	bmap[i] = 1;
    }

  wb2 = (wchar_t *)xmalloc ((wlen + 1) * sizeof (wchar_t));
  b = 0;
  for (i = 0; i < wlen; i++)
    if (bmap[i])
      wb2[b++] = wbuf[i];
  wb2[b] = 0;

  free (wbuf);

  buf = bmap;
  n = wcstombs (buf, wb2, llen);

  if (v)
    {
      ind = 0;
      bind_array_element (v, ind, buf, 0);
      ind++;
    }
  else
    printf ("%s\n", buf);

  free (buf);
  free (wb2);

  return ind;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\cut.c:204
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\cut.c:275
parsing error 
{
  arrayind_t ind;
  char *buf, *bmap, *field, **fields, delim[2];
  size_t llen, fsize;
  int i, b, n, s, e, nf;

  ind = 0;

  delim[0] = ops->delim;
  delim[1] = '\0';

  fields = 0;
  nf = 0;
  fsize = 0;

  field = buf = line;
  do
    {
      field = strsep (&buf, delim);	/* destructive */
      if (nf == fsize)
	{
	  fsize += 8;
	  fields = xrealloc (fields, fsize * sizeof (char *));
	}
      fields[nf] = field;
      if (field)
	nf++;
    }
  while (field);

  if (nf == 1)
    {
      free (fields);
      if (ops->flags & SFLAG)
	return ind;
      if (v)
	{
	  bind_array_element (v, ind, line, 0);
	  ind++;
	}
      else
	printf ("%s\n", line);
      return ind;
    }

  bmap = xmalloc (nf + 1);
  memset (bmap, 0, nf);

  for (n = 0; n < ops->npos; n++)
    {
      s = ops->poslist[n].startpos;		/* no translation needed yet */
      e = ops->poslist[n].endpos;
      if (e == NORANGE)
        e = s;
      else if (e == EOL || e >= nf)
	e = nf - 1;
      /* even if a column is specified multiple times, it will only be printed
         once */
      for (i = s; i <= e; i++)
	bmap[i] = 1;
    }

  for (i = 1, b = 0; b < nf; b++)
    {
      if (bmap[b] == 0)
	continue;
      if (v)
	{
	  bind_array_element (v, ind, fields[b], 0);
	  ind++;
	}
      else
	{
	  if (i == 0)
	    putchar (ops->delim);
	  printf ("%s", fields[b]);
	}
      i = 0;
    }
  if (v == 0)
    putchar ('\n');

  return nf;
}
warning: parse error {
  arrayind_t ind;
  char *buf, *bmap, *field, **fields, delim[2];
  size_t llen, fsize;
  int i, b, n, s, e, nf;

  ind = 0;

  delim[0] = ops->delim;
  delim[1] = '\0';

  fields = 0;
  nf = 0;
  fsize = 0;

  field = buf = line;
  do
    {
      field = strsep (&buf, delim);	/* destructive */
      if (nf == fsize)
	{
	  fsize += 8;
	  fields = xrealloc (fields, fsize * sizeof (char *));
	}
      fields[nf] = field;
      if (field)
	nf++;
    }
  while (field);

  if (nf == 1)
    {
      free (fields);
      if (ops->flags & SFLAG)
	return ind;
      if (v)
	{
	  bind_array_element (v, ind, line, 0);
	  ind++;
	}
      else
	printf ("%s\n", line);
      return ind;
    }

  bmap = xmalloc (nf + 1);
  memset (bmap, 0, nf);

  for (n = 0; n < ops->npos; n++)
    {
      s = ops->poslist[n].startpos;		/* no translation needed yet */
      e = ops->poslist[n].endpos;
      if (e == NORANGE)
        e = s;
      else if (e == EOL || e >= nf)
	e = nf - 1;
      /* even if a column is specified multiple times, it will only be printed
         once */
      for (i = s; i <= e; i++)
	bmap[i] = 1;
    }

  for (i = 1, b = 0; b < nf; b++)
    {
      if (bmap[b] == 0)
	continue;
      if (v)
	{
	  bind_array_element (v, ind, fields[b], 0);
	  ind++;
	}
      else
	{
	  if (i == 0)
	    putchar (ops->delim);
	  printf ("%s", fields[b]);
	}
      i = 0;
    }
  if (v == 0)
    putchar ('\n');

  return nf;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\cut.c:279
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\cut.c:365
parsing error 
{
  int rval;

  if (ops->flags & BFLAG)
    rval = cutbytes (v, line, ops);
  else if (ops->flags & CFLAG)
    rval = cutchars (v, line, ops);
  else
    rval = cutfields (v, line, ops);

  return (rval >= 0 ? EXECUTION_SUCCESS : EXECUTION_FAILURE);
}
warning: parse error {
  int rval;

  if (ops->flags & BFLAG)
    rval = cutbytes (v, line, ops);
  else if (ops->flags & CFLAG)
    rval = cutchars (v, line, ops);
  else
    rval = cutfields (v, line, ops);

  return (rval >= 0 ? EXECUTION_SUCCESS : EXECUTION_FAILURE);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\cut.c:369
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\cut.c:383
parsing error 
{
  int fd, unbuffered_read;
  char *line, *b;
  size_t llen;
  WORD_LIST *l;
  ssize_t n;

  line = 0;
  llen = 0;

  l = list;
  do
    {
      /* for each file */
      if (l == 0 || (l->word->word[0] == '-' && l->word->word[1] == '\0'))
	fd = 0;
      else
	fd = open (l->word->word, O_RDONLY);
      if (fd < 0)
	{
	  file_error (l->word->word);
	  return (EXECUTION_FAILURE);
	}

#ifndef __CYGWIN__
      unbuffered_read = (lseek (fd, 0L, SEEK_CUR) < 0) && (errno == ESPIPE);
#else
      unbuffered_read = 1;
#endif

      while ((n = zgetline (fd, &line, &llen, '\n', unbuffered_read)) != -1)
	  cutline (v, line, ops);		/* can modify line */
      if (fd > 0)
	close (fd);

      if (l)
	l = l->next;
    }
  while (l);

  free (line);
  return EXECUTION_SUCCESS;
}
warning: parse error {
  int fd, unbuffered_read;
  char *line, *b;
  size_t llen;
  WORD_LIST *l;
  ssize_t n;

  line = 0;
  llen = 0;

  l = list;
  do
    {
      /* for each file */
      if (l == 0 || (l->word->word[0] == '-' && l->word->word[1] == '\0'))
	fd = 0;
      else
	fd = open (l->word->word, O_RDONLY);
      if (fd < 0)
	{
	  file_error (l->word->word);
	  return (EXECUTION_FAILURE);
	}

#ifndef __CYGWIN__
      unbuffered_read = (lseek (fd, 0L, SEEK_CUR) < 0) && (errno == ESPIPE);
#else
      unbuffered_read = 1;
#endif

      while ((n = zgetline (fd, &line, &llen, '\n', unbuffered_read)) != -1)
	  cutline (v, line, ops);		/* can modify line */
      if (fd > 0)
	close (fd);

      if (l)
	l = l->next;
    }
  while (l);

  free (line);
  return EXECUTION_SUCCESS;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\cut.c:387
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\cut.c:434
parsing error 
{
  int opt, rval, cutflags, delim, npos;
  char *array_name, *cutstring, *list_arg;
  SHELL_VAR *v;
  struct cutop op;
  struct cutpos *poslist;

  v = 0;
  rval = EXECUTION_SUCCESS;

  cutflags = 0;
  array_name = 0;
  list_arg = 0;
  delim = '\t';

  reset_internal_getopt ();
  while ((opt = internal_getopt (list, "a:b:c:d:f:sn")) != -1)
    {
      switch (opt)
	{
	case 'a':
	  array_name = list_optarg;
	  break;
	case 'b':
	  cutflags |= BFLAG;
	  list_arg = list_optarg;
	  break;
	case 'c':
	  cutflags |= CFLAG;
	  list_arg = list_optarg;
	  break;
	case 'd':
	  cutflags |= DFLAG;
	  delim = list_optarg[0];
	  if (delim == 0 || list_optarg[1])
	    {
	      builtin_error ("delimiter must be a single non-null character");
	      return (EX_USAGE);
	    }
	  break;
	case 'f':
	  cutflags |= FFLAG;
	  list_arg = list_optarg;
	  break;
	case 'n':
	  break;
	case 's':
	  cutflags |= SFLAG;
	  break;
	CASE_HELPOPT;
	default:
	  builtin_usage ();
	  return (EX_USAGE);
	}
    }
  list = loptend;

  if (array_name && (legal_identifier (array_name) == 0))
    {
      sh_invalidid (array_name);
      return (EXECUTION_FAILURE);
    }

  if (list == 0 && which == 0)
    {
      builtin_error ("string argument required");
      return (EX_USAGE);
    }

  /* options are mutually exclusive and one is required */
  if ((OPTSET (BFLAG) + OPTSET (CFLAG) + OPTSET (FFLAG)) != 1)
    {
      builtin_usage ();
      return (EX_USAGE);
    }

  if ((npos = getlist (list_arg, &poslist)) < 0)
    {
      free (poslist);
      return (EXECUTION_FAILURE);
    }

  if (array_name)
    {      
      v = find_or_make_array_variable (array_name, 1);
      if (v == 0 || readonly_p (v) || noassign_p (v))
	{
	  if (v && readonly_p (v))
	    err_readonly (array_name);
	  return (EXECUTION_FAILURE);
	}
      else if (array_p (v) == 0)
	{
	  builtin_error ("%s: not an indexed array", array_name);
	  return (EXECUTION_FAILURE);
	}
      if (invisible_p (v))
	VUNSETATTR (v, att_invisible);
      array_flush (array_cell (v));
    }

  op.flags = cutflags;
  op.delim = delim;
  op.npos = npos;
  op.poslist = poslist;

  /* we implement cut as a builtin with a cutfile() function that opens each
     filename in LIST as a filename (or `-' for stdin) and runs cutline on
     every line in the file. */
  if (which == 0)
    {
      cutstring = list->word->word;
      if (cutstring == 0 || *cutstring == 0)
	{
	  free (poslist);
	  return (EXECUTION_SUCCESS);
	}
      rval = cutline (v, cutstring, &op);
    }
  else
    rval = cutfile (v, list, &op);

  return (rval);
}
warning: parse error {
  int opt, rval, cutflags, delim, npos;
  char *array_name, *cutstring, *list_arg;
  SHELL_VAR *v;
  struct cutop op;
  struct cutpos *poslist;

  v = 0;
  rval = EXECUTION_SUCCESS;

  cutflags = 0;
  array_name = 0;
  list_arg = 0;
  delim = '\t';

  reset_internal_getopt ();
  while ((opt = internal_getopt (list, "a:b:c:d:f:sn")) != -1)
    {
      switch (opt)
	{
	case 'a':
	  array_name = list_optarg;
	  break;
	case 'b':
	  cutflags |= BFLAG;
	  list_arg = list_optarg;
	  break;
	case 'c':
	  cutflags |= CFLAG;
	  list_arg = list_optarg;
	  break;
	case 'd':
	  cutflags |= DFLAG;
	  delim = list_optarg[0];
	  if (delim == 0 || list_optarg[1])
	    {
	      builtin_error ("delimiter must be a single non-null character");
	      return (EX_USAGE);
	    }
	  break;
	case 'f':
	  cutflags |= FFLAG;
	  list_arg = list_optarg;
	  break;
	case 'n':
	  break;
	case 's':
	  cutflags |= SFLAG;
	  break;
	CASE_HELPOPT;
	default:
	  builtin_usage ();
	  return (EX_USAGE);
	}
    }
  list = loptend;

  if (array_name && (legal_identifier (array_name) == 0))
    {
      sh_invalidid (array_name);
      return (EXECUTION_FAILURE);
    }

  if (list == 0 && which == 0)
    {
      builtin_error ("string argument required");
      return (EX_USAGE);
    }

  /* options are mutually exclusive and one is required */
  if ((OPTSET (BFLAG) + OPTSET (CFLAG) + OPTSET (FFLAG)) != 1)
    {
      builtin_usage ();
      return (EX_USAGE);
    }

  if ((npos = getlist (list_arg, &poslist)) < 0)
    {
      free (poslist);
      return (EXECUTION_FAILURE);
    }

  if (array_name)
    {      
      v = find_or_make_array_variable (array_name, 1);
      if (v == 0 || readonly_p (v) || noassign_p (v))
	{
	  if (v && readonly_p (v))
	    err_readonly (array_name);
	  return (EXECUTION_FAILURE);
	}
      else if (array_p (v) == 0)
	{
	  builtin_error ("%s: not an indexed array", array_name);
	  return (EXECUTION_FAILURE);
	}
      if (invisible_p (v))
	VUNSETATTR (v, att_invisible);
      array_flush (array_cell (v));
    }

  op.flags = cutflags;
  op.delim = delim;
  op.npos = npos;
  op.poslist = poslist;

  /* we implement cut as a builtin with a cutfile() function that opens each
     filename in LIST as a filename (or `-' for stdin) and runs cutline on
     every line in the file. */
  if (which == 0)
    {
      cutstring = list->word->word;
      if (cutstring == 0 || *cutstring == 0)
	{
	  free (poslist);
	  return (EXECUTION_SUCCESS);
	}
      rval = cutline (v, cutstring, &op);
    }
  else
    rval = cutfile (v, list, &op);

  return (rval);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\cut.c:437
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\cut.c:563
parsing error 
{
  return (cut_internal (0, list));
}
warning: parse error {
  return (cut_internal (0, list));
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\cut.c:565
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\cut.c:570
parsing error 
{
  return (cut_internal (1, list));
}
warning: parse error {
  return (cut_internal (1, list));
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\cut.c:572
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\dirname.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\shell.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\common.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\bashgetopt.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\dirname.c:36
parsing error 
{
  int slen;
  char *string;

  if (no_options (list))
    return (EX_USAGE);
  list = loptend;

  if (list == 0 || list->next)
    {
      builtin_usage ();
      return (EX_USAGE);
    }

  string = list->word->word;
  slen = strlen (string);

  /* Strip trailing slashes */
  while (slen > 0 && string[slen - 1] == '/')
    slen--;

  /* (2) If string consists entirely of slash characters, string shall be
	 set to a single slash character.  In this case, skip steps (3)
	 through (8). */
  if (slen == 0)
    {
      fputs ("/\n", stdout);
      return (EXECUTION_SUCCESS);
    }

  /* (3) If there are any trailing slash characters in string, they
	 shall be removed. */
  string[slen] = '\0';

  /* (4) If there are no slash characters remaining in string, string
	 shall be set to a single period character.  In this case, skip
	 steps (5) through (8).

     (5) If there are any trailing nonslash characters in string,
	 they shall be removed. */

  while (--slen >= 0)
    if (string[slen] == '/')
      break;

  if (slen < 0)
    {
      fputs (".\n", stdout);
      return (EXECUTION_SUCCESS);
    }

  /* (7) If there are any trailing slash characters in string, they
	 shall be removed. */
  while (--slen >= 0)
    if (string[slen] != '/')
      break;
  string[++slen] = '\0';

  /* (8) If the remaining string is empty, string shall be set to a single
	 slash character. */
  printf ("%s\n", (slen == 0) ? "/" : string);
  return (EXECUTION_SUCCESS);
}
warning: parse error {
  int slen;
  char *string;

  if (no_options (list))
    return (EX_USAGE);
  list = loptend;

  if (list == 0 || list->next)
    {
      builtin_usage ();
      return (EX_USAGE);
    }

  string = list->word->word;
  slen = strlen (string);

  /* Strip trailing slashes */
  while (slen > 0 && string[slen - 1] == '/')
    slen--;

  /* (2) If string consists entirely of slash characters, string shall be
	 set to a single slash character.  In this case, skip steps (3)
	 through (8). */
  if (slen == 0)
    {
      fputs ("/\n", stdout);
      return (EXECUTION_SUCCESS);
    }

  /* (3) If there are any trailing slash characters in string, they
	 shall be removed. */
  string[slen] = '\0';

  /* (4) If there are no slash characters remaining in string, string
	 shall be set to a single period character.  In this case, skip
	 steps (5) through (8).

     (5) If there are any trailing nonslash characters in string,
	 they shall be removed. */

  while (--slen >= 0)
    if (string[slen] == '/')
      break;

  if (slen < 0)
    {
      fputs (".\n", stdout);
      return (EXECUTION_SUCCESS);
    }

  /* (7) If there are any trailing slash characters in string, they
	 shall be removed. */
  while (--slen >= 0)
    if (string[slen] != '/')
      break;
  string[++slen] = '\0';

  /* (8) If the remaining string is empty, string shall be set to a single
	 slash character. */
  printf ("%s\n", (slen == 0) ? "/" : string);
  return (EXECUTION_SUCCESS);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\dirname.c:38
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\fdflags.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashansi.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\loadables.h...skip
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\finfo.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\posixstat.h...skip
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\posixtime.h...
parsing error 
extern int gettimeofday PARAMS((struct timeval *, void *));
warning: parse error extern int gettimeofday PARAMS((struct timeval *, void *));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\posixtime.h:67
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashansi.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\shell.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\common.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\getopt.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\finfo.c:94
parsing error 
{
	int	r;

	r = *s - '0';
	while (*++s >= '0' && *s <= '7')
		r = (r * 8) + (*s - '0');
	return r;
}
warning: parse error {
	int	r;

	r = *s - '0';
	while (*++s >= '0' && *s <= '7')
		r = (r * 8) + (*s - '0');
	return r;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\finfo.c:96
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\finfo.c:106
parsing error 
{
	register int	i;
	int	mode, flags, opt;

	sh_optind = 0;	/* XXX */
	prog = base_pathname(argv[0]);
	if (argc == 1) {
		builtin_usage();
		return(1);
	}
	flags = 0;
	while ((opt = sh_getopt(argc, argv, OPTIONS)) != EOF) {
		switch(opt) {
		case 'a': flags |= OPT_ATIME; break;
		case 'A': flags |= OPT_ATIME|OPT_ASCII; break;
		case 'c': flags |= OPT_CTIME; break;
		case 'C': flags |= OPT_CTIME|OPT_ASCII; break;
		case 'd': flags |= OPT_DEV; break;
		case 'i': flags |= OPT_INO; break;
		case 'f': flags |= OPT_FID; break;
		case 'g': flags |= OPT_GID; break;
		case 'G': flags |= OPT_GID|OPT_ASCII; break;
		case 'l': flags |= OPT_LNKNAM; break;
		case 'm': flags |= OPT_MTIME; break;
		case 'M': flags |= OPT_MTIME|OPT_ASCII; break;
		case 'n': flags |= OPT_NLINK; break;
		case 'o': flags |= OPT_OPERM; break;
		case 'p': flags |= OPT_PERM; break;
		case 'P': flags |= OPT_PMASK; pmask = octal(sh_optarg); break;
		case 's': flags |= OPT_SIZE; break;
		case 'u': flags |= OPT_UID; break;
		case 'U': flags |= OPT_UID|OPT_ASCII; break;
		default: builtin_usage (); return(1);
		}
	}

	argc -= sh_optind;
	argv += sh_optind;

	if (argc == 0) {
		builtin_usage();
		return(1);
	}

	for (i = 0; i < argc; i++)
		opt = flags ? printsome (argv[i], flags) : printfinfo(argv[i]);

	return(opt);
}
warning: parse error {
	register int	i;
	int	mode, flags, opt;

	sh_optind = 0;	/* XXX */
	prog = base_pathname(argv[0]);
	if (argc == 1) {
		builtin_usage();
		return(1);
	}
	flags = 0;
	while ((opt = sh_getopt(argc, argv, OPTIONS)) != EOF) {
		switch(opt) {
		case 'a': flags |= OPT_ATIME; break;
		case 'A': flags |= OPT_ATIME|OPT_ASCII; break;
		case 'c': flags |= OPT_CTIME; break;
		case 'C': flags |= OPT_CTIME|OPT_ASCII; break;
		case 'd': flags |= OPT_DEV; break;
		case 'i': flags |= OPT_INO; break;
		case 'f': flags |= OPT_FID; break;
		case 'g': flags |= OPT_GID; break;
		case 'G': flags |= OPT_GID|OPT_ASCII; break;
		case 'l': flags |= OPT_LNKNAM; break;
		case 'm': flags |= OPT_MTIME; break;
		case 'M': flags |= OPT_MTIME|OPT_ASCII; break;
		case 'n': flags |= OPT_NLINK; break;
		case 'o': flags |= OPT_OPERM; break;
		case 'p': flags |= OPT_PERM; break;
		case 'P': flags |= OPT_PMASK; pmask = octal(sh_optarg); break;
		case 's': flags |= OPT_SIZE; break;
		case 'u': flags |= OPT_UID; break;
		case 'U': flags |= OPT_UID|OPT_ASCII; break;
		default: builtin_usage (); return(1);
		}
	}

	argc -= sh_optind;
	argv += sh_optind;

	if (argc == 0) {
		builtin_usage();
		return(1);
	}

	for (i = 0; i < argc; i++)
		opt = flags ? printsome (argv[i], flags) : printfinfo(argv[i]);

	return(opt);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\finfo.c:109
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\finfo.c:160
parsing error 
{
	static struct stat st;
	int	fd, r;
	intmax_t lfd;

	if (strncmp(f, "/dev/fd/", 8) == 0) {
		if ((legal_number(f + 8, &lfd) == 0) || (int)lfd != lfd) {
			builtin_error("%s: invalid fd", f + 8);
			return ((struct stat *)0);
		}
		fd = lfd;
		r = fstat(fd, &st);
	} else
#ifdef HAVE_LSTAT
		r = lstat(f, &st);
#else
		r = stat(f, &st);
#endif
	if (r < 0) {
		builtin_error("%s: cannot stat: %s", f, strerror(errno));
		return ((struct stat *)0);
	}
	return (&st);
}
warning: parse error {
	static struct stat st;
	int	fd, r;
	intmax_t lfd;

	if (strncmp(f, "/dev/fd/", 8) == 0) {
		if ((legal_number(f + 8, &lfd) == 0) || (int)lfd != lfd) {
			builtin_error("%s: invalid fd", f + 8);
			return ((struct stat *)0);
		}
		fd = lfd;
		r = fstat(fd, &st);
	} else
#ifdef HAVE_LSTAT
		r = lstat(f, &st);
#else
		r = stat(f, &st);
#endif
	if (r < 0) {
		builtin_error("%s: cannot stat: %s", f, strerror(errno));
		return ((struct stat *)0);
	}
	return (&st);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\finfo.c:162
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\finfo.c:188
parsing error 
{
	struct stat *st;

	st = getstat(f);
	return (st ? printst(st) : 1);
}
warning: parse error {
	struct stat *st;

	st = getstat(f);
	return (st ? printst(st) : 1);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\finfo.c:190
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\finfo.c:198
parsing error 
{
	return (m & (S_IRWXU|S_IRWXG|S_IRWXO|S_ISUID|S_ISGID));
}
warning: parse error {
	return (m & (S_IRWXU|S_IRWXG|S_IRWXO|S_ISUID|S_ISGID));
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\finfo.c:200
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\finfo.c:205
parsing error 
{
	char ubits[4], gbits[4], obits[4];	/* u=rwx,g=rwx,o=rwx */
	int i;

	i = 0;
	if (m & S_IRUSR)
		ubits[i++] = 'r';
	if (m & S_IWUSR)
		ubits[i++] = 'w';
	if (m & S_IXUSR)
		ubits[i++] = 'x';
	ubits[i] = '\0';

	i = 0;
	if (m & S_IRGRP)
		gbits[i++] = 'r';
	if (m & S_IWGRP)
		gbits[i++] = 'w';
	if (m & S_IXGRP)
		gbits[i++] = 'x';
	gbits[i] = '\0';

	i = 0;
	if (m & S_IROTH)
		obits[i++] = 'r';
	if (m & S_IWOTH)
		obits[i++] = 'w';
	if (m & S_IXOTH)
		obits[i++] = 'x';
	obits[i] = '\0';

	if (m & S_ISUID)
		ubits[2] = (m & S_IXUSR) ? 's' : 'S';
	if (m & S_ISGID)
		gbits[2] = (m & S_IXGRP) ? 's' : 'S';
	if (m & S_ISVTX)
		obits[2] = (m & S_IXOTH) ? 't' : 'T';

	printf ("u=%s,g=%s,o=%s", ubits, gbits, obits);
}
warning: parse error {
	char ubits[4], gbits[4], obits[4];	/* u=rwx,g=rwx,o=rwx */
	int i;

	i = 0;
	if (m & S_IRUSR)
		ubits[i++] = 'r';
	if (m & S_IWUSR)
		ubits[i++] = 'w';
	if (m & S_IXUSR)
		ubits[i++] = 'x';
	ubits[i] = '\0';

	i = 0;
	if (m & S_IRGRP)
		gbits[i++] = 'r';
	if (m & S_IWGRP)
		gbits[i++] = 'w';
	if (m & S_IXGRP)
		gbits[i++] = 'x';
	gbits[i] = '\0';

	i = 0;
	if (m & S_IROTH)
		obits[i++] = 'r';
	if (m & S_IWOTH)
		obits[i++] = 'w';
	if (m & S_IXOTH)
		obits[i++] = 'x';
	obits[i] = '\0';

	if (m & S_ISUID)
		ubits[2] = (m & S_IXUSR) ? 's' : 'S';
	if (m & S_ISGID)
		gbits[2] = (m & S_IXGRP) ? 's' : 'S';
	if (m & S_ISVTX)
		obits[2] = (m & S_IXOTH) ? 't' : 'T';

	printf ("u=%s,g=%s,o=%s", ubits, gbits, obits);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\finfo.c:207
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\finfo.c:249
parsing error 
{
	if (S_ISBLK(mode))
		printf("S_IFBLK ");
	if (S_ISCHR(mode))
		printf("S_IFCHR ");
	if (S_ISDIR(mode))
		printf("S_IFDIR ");
	if (S_ISREG(mode))
		printf("S_IFREG ");
	if (S_ISFIFO(mode))
		printf("S_IFIFO ");
	if (S_ISLNK(mode))
		printf("S_IFLNK ");
	if (S_ISSOCK(mode))
		printf("S_IFSOCK ");
#ifdef S_ISWHT
	if (S_ISWHT(mode))
		printf("S_ISWHT ");
#endif
	perms(getperm(mode));
	printf("\n");
}
warning: parse error {
	if (S_ISBLK(mode))
		printf("S_IFBLK ");
	if (S_ISCHR(mode))
		printf("S_IFCHR ");
	if (S_ISDIR(mode))
		printf("S_IFDIR ");
	if (S_ISREG(mode))
		printf("S_IFREG ");
	if (S_ISFIFO(mode))
		printf("S_IFIFO ");
	if (S_ISLNK(mode))
		printf("S_IFLNK ");
	if (S_ISSOCK(mode))
		printf("S_IFSOCK ");
#ifdef S_ISWHT
	if (S_ISWHT(mode))
		printf("S_ISWHT ");
#endif
	perms(getperm(mode));
	printf("\n");
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\finfo.c:251
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\finfo.c:275
parsing error 
{
	struct passwd	*pw;
	struct group	*gr;
	char	*owner;
	int	ma, mi, d;

	ma = major (st->st_rdev);
	mi = minor (st->st_rdev);
#if defined (makedev)
	d = makedev (ma, mi);
#else
	d = st->st_rdev & 0xFF;
#endif
	printf("Device (major/minor): %d (%d/%d)\n", d, ma, mi);

	printf("Inode: %d\n", (int) st->st_ino);
	printf("Mode: (%o) ", (int) st->st_mode);
	printmode((int) st->st_mode);
	printf("Link count: %d\n", (int) st->st_nlink);
	pw = getpwuid(st->st_uid);
	owner = pw ? pw->pw_name : "unknown";
	printf("Uid of owner: %d (%s)\n", (int) st->st_uid, owner);
	gr = getgrgid(st->st_gid);
	owner = gr ? gr->gr_name : "unknown";
	printf("Gid of owner: %d (%s)\n", (int) st->st_gid, owner);
	printf("Device type: %d\n", (int) st->st_rdev);
	printf("File size: %ld\n", (long) st->st_size);
	printf("File last access time: %s", ctime (&st->st_atime));
	printf("File last modify time: %s", ctime (&st->st_mtime));
	printf("File last status change time: %s", ctime (&st->st_ctime));
	fflush(stdout);
	return(0);
}
warning: parse error {
	struct passwd	*pw;
	struct group	*gr;
	char	*owner;
	int	ma, mi, d;

	ma = major (st->st_rdev);
	mi = minor (st->st_rdev);
#if defined (makedev)
	d = makedev (ma, mi);
#else
	d = st->st_rdev & 0xFF;
#endif
	printf("Device (major/minor): %d (%d/%d)\n", d, ma, mi);

	printf("Inode: %d\n", (int) st->st_ino);
	printf("Mode: (%o) ", (int) st->st_mode);
	printmode((int) st->st_mode);
	printf("Link count: %d\n", (int) st->st_nlink);
	pw = getpwuid(st->st_uid);
	owner = pw ? pw->pw_name : "unknown";
	printf("Uid of owner: %d (%s)\n", (int) st->st_uid, owner);
	gr = getgrgid(st->st_gid);
	owner = gr ? gr->gr_name : "unknown";
	printf("Gid of owner: %d (%s)\n", (int) st->st_gid, owner);
	printf("Device type: %d\n", (int) st->st_rdev);
	printf("File size: %ld\n", (long) st->st_size);
	printf("File last access time: %s", ctime (&st->st_atime));
	printf("File last modify time: %s", ctime (&st->st_mtime));
	printf("File last status change time: %s", ctime (&st->st_ctime));
	fflush(stdout);
	return(0);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\finfo.c:277
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\finfo.c:312
parsing error 
{
	struct stat *st;
	struct passwd *pw;
	struct group *gr;
	int	p;
	char	*b;

	st = getstat(f);
	if (st == NULL)
		return (1);

	/* Print requested info */
	if (flags & OPT_ATIME) {
		if (flags & OPT_ASCII)
			printf("%s", ctime(&st->st_atime));
		else
			printf("%ld\n", st->st_atime);
	} else if (flags & OPT_MTIME) {
		if (flags & OPT_ASCII)
			printf("%s", ctime(&st->st_mtime));
		else
			printf("%ld\n", st->st_mtime);
	} else if (flags & OPT_CTIME) {
		if (flags & OPT_ASCII)
			printf("%s", ctime(&st->st_ctime));
		else
			printf("%ld\n", st->st_ctime);
	} else if (flags & OPT_DEV)
		printf("%lu\n", (unsigned long)st->st_dev);
	else if (flags & OPT_INO)
		printf("%lu\n", (unsigned long)st->st_ino);
	else if (flags & OPT_FID)
		printf("%lu:%lu\n", (unsigned long)st->st_dev, (unsigned long)st->st_ino);
	else if (flags & OPT_NLINK)
		printf("%lu\n", (unsigned long)st->st_nlink);
	else if (flags & OPT_LNKNAM) {
#ifdef S_ISLNK
		b = xmalloc(4096);
		p = readlink(f, b, 4096);
		if (p >= 0 && p < 4096)
			b[p] = '\0';
		else {
			p = errno;
			strcpy(b, prog);
			strcat(b, ": ");
			strcat(b, strerror(p));
		}
		printf("%s\n", b);
		free(b);
#else
		printf("%s\n", f);
#endif
	} else if (flags & OPT_PERM) {
		perms(st->st_mode);
		printf("\n");
	} else if (flags & OPT_OPERM)
		printf("%o\n", getperm(st->st_mode));
	else if (flags & OPT_PMASK)
		printf("%o\n", getperm(st->st_mode) & pmask);
	else if (flags & OPT_UID) {
		pw = getpwuid(st->st_uid);
		if (flags & OPT_ASCII)
			printf("%s\n", pw ? pw->pw_name : "unknown");
		else
			printf("%d\n", st->st_uid);
	} else if (flags & OPT_GID) {
		gr = getgrgid(st->st_gid);
		if (flags & OPT_ASCII)
			printf("%s\n", gr ? gr->gr_name : "unknown");
		else
			printf("%d\n", st->st_gid);
	} else if (flags & OPT_SIZE)
		printf("%ld\n", (long) st->st_size);

	return (0);
}
warning: parse error {
	struct stat *st;
	struct passwd *pw;
	struct group *gr;
	int	p;
	char	*b;

	st = getstat(f);
	if (st == NULL)
		return (1);

	/* Print requested info */
	if (flags & OPT_ATIME) {
		if (flags & OPT_ASCII)
			printf("%s", ctime(&st->st_atime));
		else
			printf("%ld\n", st->st_atime);
	} else if (flags & OPT_MTIME) {
		if (flags & OPT_ASCII)
			printf("%s", ctime(&st->st_mtime));
		else
			printf("%ld\n", st->st_mtime);
	} else if (flags & OPT_CTIME) {
		if (flags & OPT_ASCII)
			printf("%s", ctime(&st->st_ctime));
		else
			printf("%ld\n", st->st_ctime);
	} else if (flags & OPT_DEV)
		printf("%lu\n", (unsigned long)st->st_dev);
	else if (flags & OPT_INO)
		printf("%lu\n", (unsigned long)st->st_ino);
	else if (flags & OPT_FID)
		printf("%lu:%lu\n", (unsigned long)st->st_dev, (unsigned long)st->st_ino);
	else if (flags & OPT_NLINK)
		printf("%lu\n", (unsigned long)st->st_nlink);
	else if (flags & OPT_LNKNAM) {
#ifdef S_ISLNK
		b = xmalloc(4096);
		p = readlink(f, b, 4096);
		if (p >= 0 && p < 4096)
			b[p] = '\0';
		else {
			p = errno;
			strcpy(b, prog);
			strcat(b, ": ");
			strcat(b, strerror(p));
		}
		printf("%s\n", b);
		free(b);
#else
		printf("%s\n", f);
#endif
	} else if (flags & OPT_PERM) {
		perms(st->st_mode);
		printf("\n");
	} else if (flags & OPT_OPERM)
		printf("%o\n", getperm(st->st_mode));
	else if (flags & OPT_PMASK)
		printf("%o\n", getperm(st->st_mode) & pmask);
	else if (flags & OPT_UID) {
		pw = getpwuid(st->st_uid);
		if (flags & OPT_ASCII)
			printf("%s\n", pw ? pw->pw_name : "unknown");
		else
			printf("%d\n", st->st_uid);
	} else if (flags & OPT_GID) {
		gr = getgrgid(st->st_gid);
		if (flags & OPT_ASCII)
			printf("%s\n", gr ? gr->gr_name : "unknown");
		else
			printf("%d\n", st->st_gid);
	} else if (flags & OPT_SIZE)
		printf("%ld\n", (long) st->st_size);

	return (0);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\finfo.c:315
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\finfo.c:394
parsing error 
{
  int c, r;
  char **v;
  WORD_LIST *l;

  v = make_builtin_argv (list, &c);
  r = finfo_main (c, v);
  free (v);

  return r;
}
warning: parse error {
  int c, r;
  char **v;
  WORD_LIST *l;

  v = make_builtin_argv (list, &c);
  r = finfo_main (c, v);
  free (v);

  return r;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\finfo.c:396
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\head.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashtypes.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\posixstat.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\filecntl.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashansi.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\chartypes.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\shell.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\bashgetopt.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\common.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\head.c:49
parsing error 
{
  WORD_LIST *l, *nl;
  WORD_DESC *wd;
  char *arg;

  for (l = list; l; l = l->next)
    {
      arg = l->word->word;
      if (arg[0] != '-' || arg[1] == '-' || (DIGIT(arg[1]) == 0))
        return;
      /* We have -[0-9]* */
      wd = make_bare_word (arg+1);
      nl = make_word_list (wd, l->next);
      l->word->word[1] = 'n';
      l->word->word[2] = '\0';
      l->next = nl;
      l = nl;	/* skip over new argument */
    }
}
warning: parse error {
  WORD_LIST *l, *nl;
  WORD_DESC *wd;
  char *arg;

  for (l = list; l; l = l->next)
    {
      arg = l->word->word;
      if (arg[0] != '-' || arg[1] == '-' || (DIGIT(arg[1]) == 0))
        return;
      /* We have -[0-9]* */
      wd = make_bare_word (arg+1);
      nl = make_word_list (wd, l->next);
      l->word->word[1] = 'n';
      l->word->word[2] = '\0';
      l->next = nl;
      l = nl;	/* skip over new argument */
    }
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\head.c:51
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\head.c:72
parsing error 
{
  int ch;

  while (cnt--)
    {
      while ((ch = getc (fp)) != EOF)
	{
	  if (putchar (ch) == EOF)
	    {
	      builtin_error ("write error: %s", strerror (errno));
	      return EXECUTION_FAILURE;
	    }
	  if (ch == '\n')
	    break;
	}
    }
  return (EXECUTION_SUCCESS);
}
warning: parse error {
  int ch;

  while (cnt--)
    {
      while ((ch = getc (fp)) != EOF)
	{
	  if (putchar (ch) == EOF)
	    {
	      builtin_error ("write error: %s", strerror (errno));
	      return EXECUTION_FAILURE;
	    }
	  if (ch == '\n')
	    break;
	}
    }
  return (EXECUTION_SUCCESS);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\head.c:75
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\head.c:95
parsing error 
{
  int nline, opt, rval;
  WORD_LIST *l;
  FILE *fp;

  char *t;

  munge_list (list);	/* change -num into -n num */

  reset_internal_getopt ();
  nline = 10;
  while ((opt = internal_getopt (list, "n:")) != -1)
    {
      switch (opt)
	{
	case 'n':
	  nline = atoi (list_optarg);
	  if (nline <= 0)
	    {
	      builtin_error ("bad line count: %s", list_optarg);
	      return (EX_USAGE);
	    }
	  break;
	CASE_HELPOPT;
	default:
	  builtin_usage ();
	  return (EX_USAGE);
	}
    }
  list = loptend;

  if (list == 0)
    return (file_head (stdin, nline));

  for (rval = EXECUTION_SUCCESS, opt = 1, l = list; l; l = l->next)
    {
      fp = fopen (l->word->word, "r");
      if (fp == NULL)
	{
	  builtin_error ("%s: %s", l->word->word, strerror (errno));
	  continue;
	}
      if (list->next)	/* more than one file */
	{
	  printf ("%s==> %s <==\n", opt ? "" : "\n", l->word->word);
	  opt = 0;
	}
      rval = file_head (fp, nline);
      fclose (fp);
    }
   
  return (rval);
}
warning: parse error {
  int nline, opt, rval;
  WORD_LIST *l;
  FILE *fp;

  char *t;

  munge_list (list);	/* change -num into -n num */

  reset_internal_getopt ();
  nline = 10;
  while ((opt = internal_getopt (list, "n:")) != -1)
    {
      switch (opt)
	{
	case 'n':
	  nline = atoi (list_optarg);
	  if (nline <= 0)
	    {
	      builtin_error ("bad line count: %s", list_optarg);
	      return (EX_USAGE);
	    }
	  break;
	CASE_HELPOPT;
	default:
	  builtin_usage ();
	  return (EX_USAGE);
	}
    }
  list = loptend;

  if (list == 0)
    return (file_head (stdin, nline));

  for (rval = EXECUTION_SUCCESS, opt = 1, l = list; l; l = l->next)
    {
      fp = fopen (l->word->word, "r");
      if (fp == NULL)
	{
	  builtin_error ("%s: %s", l->word->word, strerror (errno));
	  continue;
	}
      if (list->next)	/* more than one file */
	{
	  printf ("%s==> %s <==\n", opt ? "" : "\n", l->word->word);
	  opt = 0;
	}
      rval = file_head (fp, nline);
      fclose (fp);
    }
   
  return (rval);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\head.c:97
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\hello.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\loadables.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\hello.c:51
parsing error 
{
  printf("hello world\n");
  fflush (stdout);
  return (EXECUTION_SUCCESS);
}
warning: parse error {
  printf("hello world\n");
  fflush (stdout);
  return (EXECUTION_SUCCESS);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\hello.c:53
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\hello.c:60
parsing error 
{
  printf ("hello builtin loaded\n");
  fflush (stdout);
  return (1);
}
warning: parse error {
  printf ("hello builtin loaded\n");
  fflush (stdout);
  return (1);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\hello.c:62
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\hello.c:69
parsing error 
{
  printf ("hello builtin unloaded\n");
  fflush (stdout);
}
warning: parse error {
  printf ("hello builtin unloaded\n");
  fflush (stdout);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\hello.c:71
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\id.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashtypes.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashansi.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\shell.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\stdc.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\common.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\bashgetopt.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\id.c:77
parsing error 
{
  int opt;
  char *user;

  id_flags = 0;
  reset_internal_getopt ();
  while ((opt = internal_getopt (list, "Ggnru")) != -1)
    {
      switch (opt)
	{
	case 'G': id_flags |= ID_ALLGROUPS; break;
	case 'g': id_flags |= ID_GIDONLY; break;
	case 'n': id_flags |= ID_USENAME; break;
	case 'r': id_flags |= ID_USEREAL; break;
	case 'u': id_flags |= ID_USERONLY; break;
	CASE_HELPOPT;
	default:
	  builtin_usage ();
	  return (EX_USAGE);
	}
    }
  list = loptend;

  user = list ? list->word->word : (char *)NULL;

  /* Check for some invalid option combinations */
  opt = ID_FLAGSET (ID_ALLGROUPS) + ID_FLAGSET (ID_GIDONLY) + ID_FLAGSET (ID_USERONLY);
  if (opt > 1 || (opt == 0 && ((id_flags & (ID_USEREAL|ID_USENAME)) != 0)))
    {
      builtin_usage ();
      return (EX_USAGE);
    }

  if (list && list->next)
    {
      builtin_usage ();
      return (EX_USAGE);
    }

  if (inituser (user) < 0)
    return (EXECUTION_FAILURE);

  opt = 0;
  if (id_flags & ID_USERONLY)
    opt += id_pruser ((id_flags & ID_USEREAL) ? ruid : euid);
  else if (id_flags & ID_GIDONLY)
    opt += id_prgrp ((id_flags & ID_USEREAL) ? rgid : egid);
  else if (id_flags & ID_ALLGROUPS)
    opt += id_prgroups (user);
  else
    opt += id_prall (user);
  putchar ('\n');
  fflush (stdout);

  return (opt == 0 ? EXECUTION_SUCCESS : EXECUTION_FAILURE);
}
warning: parse error {
  int opt;
  char *user;

  id_flags = 0;
  reset_internal_getopt ();
  while ((opt = internal_getopt (list, "Ggnru")) != -1)
    {
      switch (opt)
	{
	case 'G': id_flags |= ID_ALLGROUPS; break;
	case 'g': id_flags |= ID_GIDONLY; break;
	case 'n': id_flags |= ID_USENAME; break;
	case 'r': id_flags |= ID_USEREAL; break;
	case 'u': id_flags |= ID_USERONLY; break;
	CASE_HELPOPT;
	default:
	  builtin_usage ();
	  return (EX_USAGE);
	}
    }
  list = loptend;

  user = list ? list->word->word : (char *)NULL;

  /* Check for some invalid option combinations */
  opt = ID_FLAGSET (ID_ALLGROUPS) + ID_FLAGSET (ID_GIDONLY) + ID_FLAGSET (ID_USERONLY);
  if (opt > 1 || (opt == 0 && ((id_flags & (ID_USEREAL|ID_USENAME)) != 0)))
    {
      builtin_usage ();
      return (EX_USAGE);
    }

  if (list && list->next)
    {
      builtin_usage ();
      return (EX_USAGE);
    }

  if (inituser (user) < 0)
    return (EXECUTION_FAILURE);

  opt = 0;
  if (id_flags & ID_USERONLY)
    opt += id_pruser ((id_flags & ID_USEREAL) ? ruid : euid);
  else if (id_flags & ID_GIDONLY)
    opt += id_prgrp ((id_flags & ID_USEREAL) ? rgid : egid);
  else if (id_flags & ID_ALLGROUPS)
    opt += id_prgroups (user);
  else
    opt += id_prall (user);
  putchar ('\n');
  fflush (stdout);

  return (opt == 0 ? EXECUTION_SUCCESS : EXECUTION_FAILURE);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\id.c:79
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\id.c:137
parsing error 
{
  struct passwd *pwd;

  if (uname)
    {
      pwd = getpwnam (uname);
      if (pwd == 0)
	{
	  builtin_error ("%s: no such user", uname);
	  return -1;
	}
      ruid = euid = pwd->pw_uid;
      rgid = egid = pwd->pw_gid;
    }
  else
    {
      ruid = current_user.uid;
      euid = current_user.euid;
      rgid = current_user.gid;
      egid = current_user.egid;
    }
  return 0;
}
warning: parse error {
  struct passwd *pwd;

  if (uname)
    {
      pwd = getpwnam (uname);
      if (pwd == 0)
	{
	  builtin_error ("%s: no such user", uname);
	  return -1;
	}
      ruid = euid = pwd->pw_uid;
      rgid = egid = pwd->pw_gid;
    }
  else
    {
      ruid = current_user.uid;
      euid = current_user.euid;
      rgid = current_user.gid;
      egid = current_user.egid;
    }
  return 0;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\id.c:139
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\id.c:165
parsing error 
{
  struct passwd *pwd = NULL;
  int r;

  r = 0;
  if (id_flags & ID_USENAME)
    {
      pwd = getpwuid (uid);
      if (pwd == NULL)
        r = 1;
    }
  if (pwd)
    printf ("%s", pwd->pw_name);
  else
    printf ("%u", (unsigned) uid);
      
  return r;
}
warning: parse error {
  struct passwd *pwd = NULL;
  int r;

  r = 0;
  if (id_flags & ID_USENAME)
    {
      pwd = getpwuid (uid);
      if (pwd == NULL)
        r = 1;
    }
  if (pwd)
    printf ("%s", pwd->pw_name);
  else
    printf ("%u", (unsigned) uid);
      
  return r;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\id.c:167
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\id.c:189
parsing error 
{
  struct group *grp = NULL;
  int r;

  r = 0;
  if (id_flags & ID_USENAME)
    {
      grp = getgrgid (gid);
      if (grp == NULL)
	r = 1;
    }

  if (grp)
    printf ("%s", grp->gr_name);
  else
    printf ("%u", (unsigned) gid);

  return r;
}
warning: parse error {
  struct group *grp = NULL;
  int r;

  r = 0;
  if (id_flags & ID_USENAME)
    {
      grp = getgrgid (gid);
      if (grp == NULL)
	r = 1;
    }

  if (grp)
    printf ("%s", grp->gr_name);
  else
    printf ("%u", (unsigned) gid);

  return r;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\id.c:191
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\id.c:212
parsing error 
{
  int *glist, ng, i, r;

  r = 0;
  id_prgrp (rgid);
  if (egid != rgid)
    {
      putchar (' ');
      id_prgrp (egid);
    }

  if (uname)
    {
      builtin_error ("supplementary groups for other users not yet implemented");
      glist = (int *)NULL;
      ng = 0;
      r = 1;
    }
  else
    glist = get_group_array (&ng);

  for (i = 0; i < ng; i++)
    if (glist[i] != rgid && glist[i] != egid)
      {
	putchar (' ');
	id_prgrp (glist[i]);
      }
  
  return r;
}
warning: parse error {
  int *glist, ng, i, r;

  r = 0;
  id_prgrp (rgid);
  if (egid != rgid)
    {
      putchar (' ');
      id_prgrp (egid);
    }

  if (uname)
    {
      builtin_error ("supplementary groups for other users not yet implemented");
      glist = (int *)NULL;
      ng = 0;
      r = 1;
    }
  else
    glist = get_group_array (&ng);

  for (i = 0; i < ng; i++)
    if (glist[i] != rgid && glist[i] != egid)
      {
	putchar (' ');
	id_prgrp (glist[i]);
      }
  
  return r;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\id.c:214
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\id.c:246
parsing error 
{
  int r, i, ng, *glist;
  struct passwd *pwd;
  struct group *grp;

  r = 0;
  printf ("uid=%u", (unsigned) ruid);
  pwd = getpwuid (ruid);
  if (pwd == NULL)
    r = 1;
  else
    printf ("(%s)", pwd->pw_name);

  printf (" gid=%u", (unsigned) rgid);
  grp = getgrgid (rgid);
  if (grp == NULL)
    r = 1;
  else
    printf ("(%s)", grp->gr_name);

  if (euid != ruid)
    { 
      printf (" euid=%u", (unsigned) euid);
      pwd = getpwuid (euid);
      if (pwd == NULL)
	r = 1;
      else 
	printf ("(%s)", pwd->pw_name);
    }

  if (egid != rgid) 
    {
      printf (" egid=%u", (unsigned) egid);
      grp = getgrgid (egid);
      if (grp == NULL)
	r = 1;
      else
	printf ("(%s)", grp->gr_name);
    }

  if (uname)
    {
      builtin_error ("supplementary groups for other users not yet implemented");
      glist = (int *)NULL;
      ng = 0;
      r = 1;
    }
  else
    glist = get_group_array (&ng);

  if (ng > 0)
    printf (" groups=");
  for (i = 0; i < ng; i++)
    {
      if (i > 0)
	printf (", ");
      printf ("%u", (unsigned) glist[i]);
      grp = getgrgid (glist[i]);
      if (grp == NULL)
	r = 1;
      else
	printf ("(%s)", grp->gr_name);
    }

  return r;
}
warning: parse error {
  int r, i, ng, *glist;
  struct passwd *pwd;
  struct group *grp;

  r = 0;
  printf ("uid=%u", (unsigned) ruid);
  pwd = getpwuid (ruid);
  if (pwd == NULL)
    r = 1;
  else
    printf ("(%s)", pwd->pw_name);

  printf (" gid=%u", (unsigned) rgid);
  grp = getgrgid (rgid);
  if (grp == NULL)
    r = 1;
  else
    printf ("(%s)", grp->gr_name);

  if (euid != ruid)
    { 
      printf (" euid=%u", (unsigned) euid);
      pwd = getpwuid (euid);
      if (pwd == NULL)
	r = 1;
      else 
	printf ("(%s)", pwd->pw_name);
    }

  if (egid != rgid) 
    {
      printf (" egid=%u", (unsigned) egid);
      grp = getgrgid (egid);
      if (grp == NULL)
	r = 1;
      else
	printf ("(%s)", grp->gr_name);
    }

  if (uname)
    {
      builtin_error ("supplementary groups for other users not yet implemented");
      glist = (int *)NULL;
      ng = 0;
      r = 1;
    }
  else
    glist = get_group_array (&ng);

  if (ng > 0)
    printf (" groups=");
  for (i = 0; i < ng; i++)
    {
      if (i > 0)
	printf (", ");
      printf ("%u", (unsigned) glist[i]);
      grp = getgrgid (glist[i]);
      if (grp == NULL)
	r = 1;
      else
	printf ("(%s)", grp->gr_name);
    }

  return r;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\id.c:248
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\ln.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashtypes.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\posixstat.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\shell.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\bashgetopt.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\common.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\ln.c:55
parsing error 
{
  int rval, opt, flags;
  WORD_LIST *l;
  char *sdir;
  struct stat sb;

  flags = 0;
  reset_internal_getopt ();
  while ((opt = internal_getopt (list, "fs")) != -1)
    {
      switch (opt)
	{
	case 'f':
	  flags |= LN_UNLINK;
	  break;
	case 's':
	  flags |= LN_SYMLINK;
	  break;
	case 'h':
	case 'n':
	  flags |= LN_NOFOLLOW;
	  break;
	CASE_HELPOPT;
	default:
	  builtin_usage ();
	  return (EX_USAGE);
	}
    }
  list = loptend;

  if (list == 0)
    {
      builtin_usage ();
      return (EX_USAGE);
    }
    
  linkfn = (flags & LN_SYMLINK) ? symlink : link;  

  if (list->next == 0)			/* ln target, equivalent to ln target . */
    return (dolink (list->word->word, ".", flags));

  if (list->next->next == 0)		/* ln target source */
    return (dolink (list->word->word, list->next->word->word, flags));

  /* ln target1 target2 ... directory */

  /* find last argument: target directory, and make sure it's an existing
     directory. */
  for (l = list; l->next; l = l->next)  
    ;
  sdir = l->word->word;

  if (stat(sdir, &sb) < 0)
    {
      builtin_error ("%s", sdir);
      return (EXECUTION_FAILURE);
    }

  if (S_ISDIR (sb.st_mode) == 0)
    {
      builtin_usage ();
      return (EX_USAGE);
    }

  for (rval = EXECUTION_SUCCESS; list != l; list = list->next)
    rval += dolink (list->word->word, sdir, flags);
  
  return rval;
}
warning: parse error {
  int rval, opt, flags;
  WORD_LIST *l;
  char *sdir;
  struct stat sb;

  flags = 0;
  reset_internal_getopt ();
  while ((opt = internal_getopt (list, "fs")) != -1)
    {
      switch (opt)
	{
	case 'f':
	  flags |= LN_UNLINK;
	  break;
	case 's':
	  flags |= LN_SYMLINK;
	  break;
	case 'h':
	case 'n':
	  flags |= LN_NOFOLLOW;
	  break;
	CASE_HELPOPT;
	default:
	  builtin_usage ();
	  return (EX_USAGE);
	}
    }
  list = loptend;

  if (list == 0)
    {
      builtin_usage ();
      return (EX_USAGE);
    }
    
  linkfn = (flags & LN_SYMLINK) ? symlink : link;  

  if (list->next == 0)			/* ln target, equivalent to ln target . */
    return (dolink (list->word->word, ".", flags));

  if (list->next->next == 0)		/* ln target source */
    return (dolink (list->word->word, list->next->word->word, flags));

  /* ln target1 target2 ... directory */

  /* find last argument: target directory, and make sure it's an existing
     directory. */
  for (l = list; l->next; l = l->next)  
    ;
  sdir = l->word->word;

  if (stat(sdir, &sb) < 0)
    {
      builtin_error ("%s", sdir);
      return (EXECUTION_FAILURE);
    }

  if (S_ISDIR (sb.st_mode) == 0)
    {
      builtin_usage ();
      return (EX_USAGE);
    }

  for (rval = EXECUTION_SUCCESS; list != l; list = list->next)
    rval += dolink (list->word->word, sdir, flags);
  
  return rval;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\ln.c:57
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\ln.c:128
parsing error 
{
  int dlen, flen;
  char *ret;

  dlen = strlen (dir);
  flen = strlen (file);

  ret = xmalloc (2 + dlen + flen);

  strcpy (ret, dir);
  if (ret[dlen - 1] != '/')
    ret[dlen++] = '/';
  strcpy (ret + dlen, file);
  return ret;
}
warning: parse error {
  int dlen, flen;
  char *ret;

  dlen = strlen (dir);
  flen = strlen (file);

  ret = xmalloc (2 + dlen + flen);

  strcpy (ret, dir);
  if (ret[dlen - 1] != '/')
    ret[dlen++] = '/';
  strcpy (ret + dlen, file);
  return ret;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\ln.c:130
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\ln.c:155
parsing error 
{
  struct stat ssb, dsb;
  int exists;
  char *dst_path, *p;

  /* If we're not doing symlinks, the source must exist and not be a 
     directory. */
  if ((flags & LN_SYMLINK) == 0)
    {
      if (stat (src, &ssb) != 0)
	{
	  builtin_error ("%s: %s", src, strerror (errno));
	  return (EXECUTION_FAILURE);
	}
      if (S_ISDIR (ssb.st_mode))
	{
	  errno = EISDIR;
	  builtin_error ("%s: %s", src, strerror (errno));
	  return (EXECUTION_FAILURE);
	}
    }

  /* If the destination is a directory, create the final filename by appending
     the basename of the source to the destination. */
  dst_path = 0;
  if ((LSTAT_OR_STAT_IF((flags & LN_NOFOLLOW), dst, &dsb) == 0) && S_ISDIR (dsb.st_mode))
    {
      if ((p = strrchr (src, '/')) == 0)
	p = src;
      else
	p++;

      dst_path = mkdirpath (dst, p);
      dst = dst_path;
    }

  exists = LSTAT (dst, &dsb) == 0;

  /* If -f was specified, and the destination exists, unlink it. */
  if ((flags & LN_UNLINK) && exists && unlink (dst) != 0)
    {
      builtin_error ("%s: cannot unlink: %s", dst, strerror (errno));
      FREE (dst_path);
      return (EXECUTION_FAILURE);
    }

  /* Perform the link. */
  if ((*linkfn) (src, dst) != 0)
    {
      builtin_error ("cannot link %s to %s: %s", dst, src, strerror (errno));
      FREE (dst_path);
      return (EXECUTION_FAILURE);
    }

  FREE (dst_path);
  return (EXECUTION_SUCCESS);
}
warning: parse error {
  struct stat ssb, dsb;
  int exists;
  char *dst_path, *p;

  /* If we're not doing symlinks, the source must exist and not be a 
     directory. */
  if ((flags & LN_SYMLINK) == 0)
    {
      if (stat (src, &ssb) != 0)
	{
	  builtin_error ("%s: %s", src, strerror (errno));
	  return (EXECUTION_FAILURE);
	}
      if (S_ISDIR (ssb.st_mode))
	{
	  errno = EISDIR;
	  builtin_error ("%s: %s", src, strerror (errno));
	  return (EXECUTION_FAILURE);
	}
    }

  /* If the destination is a directory, create the final filename by appending
     the basename of the source to the destination. */
  dst_path = 0;
  if ((LSTAT_OR_STAT_IF((flags & LN_NOFOLLOW), dst, &dsb) == 0) && S_ISDIR (dsb.st_mode))
    {
      if ((p = strrchr (src, '/')) == 0)
	p = src;
      else
	p++;

      dst_path = mkdirpath (dst, p);
      dst = dst_path;
    }

  exists = LSTAT (dst, &dsb) == 0;

  /* If -f was specified, and the destination exists, unlink it. */
  if ((flags & LN_UNLINK) && exists && unlink (dst) != 0)
    {
      builtin_error ("%s: cannot unlink: %s", dst, strerror (errno));
      FREE (dst_path);
      return (EXECUTION_FAILURE);
    }

  /* Perform the link. */
  if ((*linkfn) (src, dst) != 0)
    {
      builtin_error ("cannot link %s to %s: %s", dst, src, strerror (errno));
      FREE (dst_path);
      return (EXECUTION_FAILURE);
    }

  FREE (dst_path);
  return (EXECUTION_SUCCESS);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\ln.c:158
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\logname.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\shell.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\common.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\logname.c:39
parsing error 
{
  char *np;

  if (no_options (list))
    return (EX_USAGE);

  np = getlogin ();
  if (np == 0)
    {
      builtin_error ("cannot find username: %s", strerror (errno));
      return (EXECUTION_FAILURE);
    }
  printf ("%s\n", np);
  return (EXECUTION_SUCCESS);
}
warning: parse error {
  char *np;

  if (no_options (list))
    return (EX_USAGE);

  np = getlogin ();
  if (np == 0)
    {
      builtin_error ("cannot find username: %s", strerror (errno));
      return (EXECUTION_FAILURE);
    }
  printf ("%s\n", np);
  return (EXECUTION_SUCCESS);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\logname.c:41
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\mkdir.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashtypes.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\posixstat.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashansi.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\shell.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\bashgetopt.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\common.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\mkdir.c:52
parsing error 
{
  int opt, pflag, mflag, omode, rval, nmode, parent_mode;
  char *mode;
  WORD_LIST *l;

  reset_internal_getopt ();
  pflag = mflag = 0;
  mode = (char *)NULL;
  while ((opt = internal_getopt(list, "m:p")) != -1)
    switch (opt)
      {
	case 'p':
	  pflag = 1;
	  break;
	case 'm':
	  mflag = 1;
	  mode = list_optarg;
	  break;
	CASE_HELPOPT;
	default:
	  builtin_usage();
	  return (EX_USAGE);
      }
  list = loptend;

  if (list == 0)
    {
      builtin_usage ();
      return (EX_USAGE);
    }

  if (mode == NULL)
    omode = S_IRWXU | S_IRWXG | S_IRWXO;	/* a=rwx */
  else if (ISOCTAL (*mode))	/* octal number */
    {
      omode = read_octal (mode);
      if (omode < 0)
	{
	  builtin_error ("invalid file mode: %s", mode);
	  return (EXECUTION_FAILURE);
	}
    }
  else 				/* symbolic mode */
    {
      /* initial bits are a=rwx; the mode argument modifies them */
      omode = parse_symbolic_mode (mode, S_IRWXU | S_IRWXG | S_IRWXO);
      if (omode < 0)
	{
	  builtin_error ("invalid file mode: %s", mode);
	  return (EXECUTION_FAILURE);
	}
    }

  /* Make the new mode */
  original_umask = umask (0);
  umask (original_umask);

  nmode = (S_IRWXU | S_IRWXG | S_IRWXO) & ~original_umask;
  parent_mode = nmode | (S_IWUSR|S_IXUSR);	/* u+wx */

  /* Adjust new mode based on mode argument */
  nmode &= omode;

  for (rval = EXECUTION_SUCCESS, l = list; l; l = l->next)
    {
      if (pflag && make_path (l->word->word, mflag, nmode, parent_mode))
	{
	  rval = EXECUTION_FAILURE;
	  continue;
	}
      else if (pflag == 0 && mkdir (l->word->word, nmode) < 0)
        {
          builtin_error ("cannot create directory `%s': %s", l->word->word, strerror (errno));
          rval = EXECUTION_FAILURE;
        }
    }
  return rval;
}
warning: parse error {
  int opt, pflag, mflag, omode, rval, nmode, parent_mode;
  char *mode;
  WORD_LIST *l;

  reset_internal_getopt ();
  pflag = mflag = 0;
  mode = (char *)NULL;
  while ((opt = internal_getopt(list, "m:p")) != -1)
    switch (opt)
      {
	case 'p':
	  pflag = 1;
	  break;
	case 'm':
	  mflag = 1;
	  mode = list_optarg;
	  break;
	CASE_HELPOPT;
	default:
	  builtin_usage();
	  return (EX_USAGE);
      }
  list = loptend;

  if (list == 0)
    {
      builtin_usage ();
      return (EX_USAGE);
    }

  if (mode == NULL)
    omode = S_IRWXU | S_IRWXG | S_IRWXO;	/* a=rwx */
  else if (ISOCTAL (*mode))	/* octal number */
    {
      omode = read_octal (mode);
      if (omode < 0)
	{
	  builtin_error ("invalid file mode: %s", mode);
	  return (EXECUTION_FAILURE);
	}
    }
  else 				/* symbolic mode */
    {
      /* initial bits are a=rwx; the mode argument modifies them */
      omode = parse_symbolic_mode (mode, S_IRWXU | S_IRWXG | S_IRWXO);
      if (omode < 0)
	{
	  builtin_error ("invalid file mode: %s", mode);
	  return (EXECUTION_FAILURE);
	}
    }

  /* Make the new mode */
  original_umask = umask (0);
  umask (original_umask);

  nmode = (S_IRWXU | S_IRWXG | S_IRWXO) & ~original_umask;
  parent_mode = nmode | (S_IWUSR|S_IXUSR);	/* u+wx */

  /* Adjust new mode based on mode argument */
  nmode &= omode;

  for (rval = EXECUTION_SUCCESS, l = list; l; l = l->next)
    {
      if (pflag && make_path (l->word->word, mflag, nmode, parent_mode))
	{
	  rval = EXECUTION_FAILURE;
	  continue;
	}
      else if (pflag == 0 && mkdir (l->word->word, nmode) < 0)
        {
          builtin_error ("cannot create directory `%s': %s", l->word->word, strerror (errno));
          rval = EXECUTION_FAILURE;
        }
    }
  return rval;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\mkdir.c:54
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\mkdir.c:137
parsing error 
{
  int oumask;
  struct stat sb;
  char *p, *npath;

  if (stat (path, &sb) == 0)
    {
      if (S_ISDIR (sb.st_mode) == 0)
	{
	  builtin_error ("`%s': file exists but is not a directory", path);
	  return 1;
	}
	
      if (user_mode && chmod (path, nmode))
        {
          builtin_error ("%s: %s", path, strerror (errno));
          return 1;
        }

      return 0;
    }

  oumask = umask (0);
  npath = savestring (path);	/* So we can write to it. */
    
  /* Check whether or not we need to do anything with intermediate dirs. */

  /* Skip leading slashes. */
  p = npath;
  while (*p == '/')
    p++;

  while (p = strchr (p, '/'))
    {
      *p = '\0';
      if (stat (npath, &sb) != 0)
	{
	  if (mkdir (npath, 0))
	    {
	      builtin_error ("cannot create directory `%s': %s", npath, strerror (errno));
	      umask (original_umask);
	      free (npath);
	      return 1;
	    }
	  if (chmod (npath, parent_mode) != 0)
	    {
	      builtin_error ("cannot chmod directory `%s': %s", npath, strerror (errno));
	      umask (original_umask);
	      free (npath);
	      return 1;
	    }
	}
      else if (S_ISDIR (sb.st_mode) == 0)
        {
          builtin_error ("`%s': file exists but is not a directory", npath);
          umask (original_umask);
          free (npath);
          return 1;
        }

      *p++ = '/';	/* restore slash */
      while (*p == '/')
	p++;
    }

  /* Create the final directory component. */
  if (stat (npath, &sb) && mkdir (npath, nmode))
    {
      builtin_error ("cannot create directory `%s': %s", npath, strerror (errno));
      umask (original_umask);
      free (npath);
      return 1;
    }

  umask (original_umask);
  free (npath);
  return 0;
}
warning: parse error {
  int oumask;
  struct stat sb;
  char *p, *npath;

  if (stat (path, &sb) == 0)
    {
      if (S_ISDIR (sb.st_mode) == 0)
	{
	  builtin_error ("`%s': file exists but is not a directory", path);
	  return 1;
	}
	
      if (user_mode && chmod (path, nmode))
        {
          builtin_error ("%s: %s", path, strerror (errno));
          return 1;
        }

      return 0;
    }

  oumask = umask (0);
  npath = savestring (path);	/* So we can write to it. */
    
  /* Check whether or not we need to do anything with intermediate dirs. */

  /* Skip leading slashes. */
  p = npath;
  while (*p == '/')
    p++;

  while (p = strchr (p, '/'))
    {
      *p = '\0';
      if (stat (npath, &sb) != 0)
	{
	  if (mkdir (npath, 0))
	    {
	      builtin_error ("cannot create directory `%s': %s", npath, strerror (errno));
	      umask (original_umask);
	      free (npath);
	      return 1;
	    }
	  if (chmod (npath, parent_mode) != 0)
	    {
	      builtin_error ("cannot chmod directory `%s': %s", npath, strerror (errno));
	      umask (original_umask);
	      free (npath);
	      return 1;
	    }
	}
      else if (S_ISDIR (sb.st_mode) == 0)
        {
          builtin_error ("`%s': file exists but is not a directory", npath);
          umask (original_umask);
          free (npath);
          return 1;
        }

      *p++ = '/';	/* restore slash */
      while (*p == '/')
	p++;
    }

  /* Create the final directory component. */
  if (stat (npath, &sb) && mkdir (npath, nmode))
    {
      builtin_error ("cannot create directory `%s': %s", npath, strerror (errno));
      umask (original_umask);
      free (npath);
      return 1;
    }

  umask (original_umask);
  free (npath);
  return 0;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\mkdir.c:141
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\mkfifo.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashtypes.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\posixstat.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashansi.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\shell.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\bashgetopt.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\common.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\mkfifo.c:50
parsing error 
{
  int opt, mflag, omode, rval, nmode, basemode;
  char *mode;
  WORD_LIST *l;

  mflag = 0;
  mode = (char *)NULL;

  reset_internal_getopt ();
  while ((opt = internal_getopt(list, "m:")) != -1)
    switch (opt)
      {
	case 'm':
	  mflag = 1;
	  mode = list_optarg;
	  break;
	CASE_HELPOPT;
	default:
	  builtin_usage();
	  return (EX_USAGE);
      }
  list = loptend;

  if (list == 0)
    {
      builtin_usage ();
      return (EX_USAGE);
    }

  basemode = S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH;
  if (mode == NULL)
    omode = basemode;
  else if (ISOCTAL (*mode))	/* octal number */
    {
      omode = read_octal (mode);
      if (omode < 0)
	{
	  builtin_error ("invalid file mode: %s", mode);
	  return (EXECUTION_FAILURE);
	}
    }
  else 				/* symbolic mode */
    {
      /* initial bits are a=rwx; the mode argument modifies them */
      omode = parse_symbolic_mode (mode, basemode);
      if (omode < 0)
	{
	  builtin_error ("invalid file mode: %s", mode);
	  return (EXECUTION_FAILURE);
	}
    }

  /* Make the new mode */
  original_umask = umask (0);
  umask (original_umask);

  nmode = basemode & ~original_umask;
  /* Adjust new mode based on mode argument */
  nmode &= omode;

  for (rval = EXECUTION_SUCCESS, l = list; l; l = l->next)
    {
      if (mkfifo (l->word->word, nmode) < 0)
        {
          builtin_error ("cannot create FIFO `%s': %s", l->word->word, strerror (errno));
          rval = EXECUTION_FAILURE;
        }
    }
  return rval;
}
warning: parse error {
  int opt, mflag, omode, rval, nmode, basemode;
  char *mode;
  WORD_LIST *l;

  mflag = 0;
  mode = (char *)NULL;

  reset_internal_getopt ();
  while ((opt = internal_getopt(list, "m:")) != -1)
    switch (opt)
      {
	case 'm':
	  mflag = 1;
	  mode = list_optarg;
	  break;
	CASE_HELPOPT;
	default:
	  builtin_usage();
	  return (EX_USAGE);
      }
  list = loptend;

  if (list == 0)
    {
      builtin_usage ();
      return (EX_USAGE);
    }

  basemode = S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH;
  if (mode == NULL)
    omode = basemode;
  else if (ISOCTAL (*mode))	/* octal number */
    {
      omode = read_octal (mode);
      if (omode < 0)
	{
	  builtin_error ("invalid file mode: %s", mode);
	  return (EXECUTION_FAILURE);
	}
    }
  else 				/* symbolic mode */
    {
      /* initial bits are a=rwx; the mode argument modifies them */
      omode = parse_symbolic_mode (mode, basemode);
      if (omode < 0)
	{
	  builtin_error ("invalid file mode: %s", mode);
	  return (EXECUTION_FAILURE);
	}
    }

  /* Make the new mode */
  original_umask = umask (0);
  umask (original_umask);

  nmode = basemode & ~original_umask;
  /* Adjust new mode based on mode argument */
  nmode &= omode;

  for (rval = EXECUTION_SUCCESS, l = list; l; l = l->next)
    {
      if (mkfifo (l->word->word, nmode) < 0)
        {
          builtin_error ("cannot create FIFO `%s': %s", l->word->word, strerror (errno));
          rval = EXECUTION_FAILURE;
        }
    }
  return rval;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\mkfifo.c:52
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\mktemp.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashansi.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\loadables.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\mktemp.c:35
parsing error 
{
  WORD_LIST *l;
  int rval, opt, fd, mflags, base_mflags;
  int dflag, qflag, tflag, uflag, onetime;
  char *prefix, *varname, *filename, *template;
  SHELL_VAR *v;

  dflag = qflag = uflag = tflag = onetime = 0;
  prefix = varname = 0;
  rval = EXECUTION_SUCCESS;

  reset_internal_getopt ();
  while ((opt = internal_getopt (list, "dqut:v:")) != -1)
    {
      switch (opt)
	{
	case 'd':
	  dflag = 1;
	  break;
	case 'q':
	  qflag = 1;
	  break;
	case 't':
	  tflag = 1;
	  prefix = list_optarg;
	  break;
	case 'u':
	  uflag = 1;
	  break;
	case 'v':
	  varname = list_optarg;
	  break;
	CASE_HELPOPT;
	default:
	  builtin_usage ();
	  return (EX_USAGE);
	}
    }
  list = loptend;

  if (varname)			/* check for validity, not readonly */
    {
      if (legal_identifier (varname) == 0)
	{
	  if (qflag == 0)
	    sh_invalidid (varname);
	  return (EXECUTION_FAILURE);
	}
      v = find_variable (varname);
      if (v && readonly_p (v))
	{
	  if (qflag == 0)
	    sh_readonly (varname);
	  return (EXECUTION_FAILURE);
	}
    }

  onetime = (list == 0);	/* once through the loop, $TMPDIR/prefix.XXXXXX */

  if (prefix == 0)
    prefix = DEFAULT_PREFIX;
  base_mflags = MT_USETMPDIR|MT_USERANDOM;	/* USERANDOM not strictly needed */

  while (list || onetime)
    {
      mflags = base_mflags;
      onetime = 0;
#if defined (USE_MKTEMP) && defined (USE_MKSTEMP)
      if (list)
	{
	  template = list->word->word;
	  mflags |= MT_TEMPLATE;
	}
#else
      /* This is sub-optimal. */
      if (list)
	{
	  /* Treat the basename as a prefix */
	  template = strrchr (list->word->word, '/');
	  if (template)
	    template++;
	  else
	    template = list->word->word;
	}
#endif
      else
	template = prefix;

      if (dflag)
	{
	  filename = sh_mktmpdir (template, mflags);
	  if (filename == 0)
	    {
	      if (qflag == 0)
		builtin_error ("%s: cannot create directory", template);
	      rval = EXECUTION_FAILURE;
	    }
	  else
	    {
	      if (uflag)
		rmdir (filename);
	      printf ("%s\n", filename);
	    }
	}
      else		/* filename */
	{
	  fd = sh_mktmpfd (template, mflags, &filename);
	  if (fd < 0)
	    {
	      if (qflag == 0)
		builtin_error ("%s: cannot create file", template);
	      rval = EXECUTION_FAILURE;
	    }
	  else
	    {
	      close (fd);
	      if (uflag)
		unlink (filename);
	      printf ("%s\n", filename);
	    }
	}

      /* Assign variable if requested */
      if (filename && varname)
	{
	  v = builtin_bind_variable (varname, filename, 0);
	  if (v == 0 || readonly_p (v) || noassign_p (v))
	    {
	      builtin_error ("%s: cannot set variable", varname);
	      rval = EXECUTION_FAILURE;
	    }
	}

      FREE (filename);

      if (list)
        list = list->next;
    }

  return (rval);
}
warning: parse error {
  WORD_LIST *l;
  int rval, opt, fd, mflags, base_mflags;
  int dflag, qflag, tflag, uflag, onetime;
  char *prefix, *varname, *filename, *template;
  SHELL_VAR *v;

  dflag = qflag = uflag = tflag = onetime = 0;
  prefix = varname = 0;
  rval = EXECUTION_SUCCESS;

  reset_internal_getopt ();
  while ((opt = internal_getopt (list, "dqut:v:")) != -1)
    {
      switch (opt)
	{
	case 'd':
	  dflag = 1;
	  break;
	case 'q':
	  qflag = 1;
	  break;
	case 't':
	  tflag = 1;
	  prefix = list_optarg;
	  break;
	case 'u':
	  uflag = 1;
	  break;
	case 'v':
	  varname = list_optarg;
	  break;
	CASE_HELPOPT;
	default:
	  builtin_usage ();
	  return (EX_USAGE);
	}
    }
  list = loptend;

  if (varname)			/* check for validity, not readonly */
    {
      if (legal_identifier (varname) == 0)
	{
	  if (qflag == 0)
	    sh_invalidid (varname);
	  return (EXECUTION_FAILURE);
	}
      v = find_variable (varname);
      if (v && readonly_p (v))
	{
	  if (qflag == 0)
	    sh_readonly (varname);
	  return (EXECUTION_FAILURE);
	}
    }

  onetime = (list == 0);	/* once through the loop, $TMPDIR/prefix.XXXXXX */

  if (prefix == 0)
    prefix = DEFAULT_PREFIX;
  base_mflags = MT_USETMPDIR|MT_USERANDOM;	/* USERANDOM not strictly needed */

  while (list || onetime)
    {
      mflags = base_mflags;
      onetime = 0;
#if defined (USE_MKTEMP) && defined (USE_MKSTEMP)
      if (list)
	{
	  template = list->word->word;
	  mflags |= MT_TEMPLATE;
	}
#else
      /* This is sub-optimal. */
      if (list)
	{
	  /* Treat the basename as a prefix */
	  template = strrchr (list->word->word, '/');
	  if (template)
	    template++;
	  else
	    template = list->word->word;
	}
#endif
      else
	template = prefix;

      if (dflag)
	{
	  filename = sh_mktmpdir (template, mflags);
	  if (filename == 0)
	    {
	      if (qflag == 0)
		builtin_error ("%s: cannot create directory", template);
	      rval = EXECUTION_FAILURE;
	    }
	  else
	    {
	      if (uflag)
		rmdir (filename);
	      printf ("%s\n", filename);
	    }
	}
      else		/* filename */
	{
	  fd = sh_mktmpfd (template, mflags, &filename);
	  if (fd < 0)
	    {
	      if (qflag == 0)
		builtin_error ("%s: cannot create file", template);
	      rval = EXECUTION_FAILURE;
	    }
	  else
	    {
	      close (fd);
	      if (uflag)
		unlink (filename);
	      printf ("%s\n", filename);
	    }
	}

      /* Assign variable if requested */
      if (filename && varname)
	{
	  v = builtin_bind_variable (varname, filename, 0);
	  if (v == 0 || readonly_p (v) || noassign_p (v))
	    {
	      builtin_error ("%s: cannot set variable", varname);
	      rval = EXECUTION_FAILURE;
	    }
	}

      FREE (filename);

      if (list)
        list = list->next;
    }

  return (rval);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\mktemp.c:37
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\mypid.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\shell.h...skip
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\necho.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\shell.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\necho.c:29
parsing error 
{
	print_word_list (list, " ");
	printf("\n");
	fflush (stdout);
	return (EXECUTION_SUCCESS);
}
warning: parse error {
	print_word_list (list, " ");
	printf("\n");
	fflush (stdout);
	return (EXECUTION_SUCCESS);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\necho.c:31
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\pathchk.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\posixstat.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashansi.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\shell.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\stdc.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\bashgetopt.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\maxpath.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\common.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\pathchk.c:102
parsing error 
{
  int retval, pflag, opt;

  reset_internal_getopt ();
  while ((opt = internal_getopt (list, "p")) != -1)
    {
      switch (opt)
	{
	case 'p':
	  pflag = 1;
	  break;
	CASE_HELPOPT;
	default:
	  builtin_usage ();
	  return (EX_USAGE);
	}
    }
  list = loptend;

  if (list == 0)
    {
      builtin_usage ();
      return (EX_USAGE);
    }

  for (retval = 0; list; list = list->next)
    retval |= validate_path (list->word->word, pflag);

  return (retval ? EXECUTION_FAILURE : EXECUTION_SUCCESS);
}
warning: parse error {
  int retval, pflag, opt;

  reset_internal_getopt ();
  while ((opt = internal_getopt (list, "p")) != -1)
    {
      switch (opt)
	{
	case 'p':
	  pflag = 1;
	  break;
	CASE_HELPOPT;
	default:
	  builtin_usage ();
	  return (EX_USAGE);
	}
    }
  list = loptend;

  if (list == 0)
    {
      builtin_usage ();
      return (EX_USAGE);
    }

  for (retval = 0; list; list = list->next)
    retval |= validate_path (list->word->word, pflag);

  return (retval ? EXECUTION_FAILURE : EXECUTION_SUCCESS);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\pathchk.c:104
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\pathchk.c:189
parsing error 
{
  const char *p;

  for (p = path; *p; ++p)
    if (portable_chars[(const unsigned char) *p] == 0)
      {
	builtin_error ("path `%s' contains nonportable character `%c'", path, *p);
	return 0;
      }
  return 1;
}
warning: parse error {
  const char *p;

  for (p = path; *p; ++p)
    if (portable_chars[(const unsigned char) *p] == 0)
      {
	builtin_error ("path `%s' contains nonportable character `%c'", path, *p);
	return 0;
      }
  return 1;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\pathchk.c:190
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\pathchk.c:228
parsing error 
{
  struct stat stats;

  if (SAFE_STAT (path, &stats))
    return 2;

  if (!S_ISDIR (stats.st_mode))
    {
      builtin_error ("`%s' is not a directory", path);
      return 0;
    }

  /* Use access to test for search permission because
     testing permission bits of st_mode can lose with new
     access control mechanisms.  Of course, access loses if you're
     running setuid. */
  if (access (path, X_OK) != 0)
    {
      if (errno == EACCES)
	builtin_error ("directory `%s' is not searchable", path);
      else
	builtin_error ("%s: %s", path, strerror (errno));
      return 0;
    }

  return 1;
}
warning: parse error {
  struct stat stats;

  if (SAFE_STAT (path, &stats))
    return 2;

  if (!S_ISDIR (stats.st_mode))
    {
      builtin_error ("`%s' is not a directory", path);
      return 0;
    }

  /* Use access to test for search permission because
     testing permission bits of st_mode can lose with new
     access control mechanisms.  Of course, access loses if you're
     running setuid. */
  if (access (path, X_OK) != 0)
    {
      if (errno == EACCES)
	builtin_error ("directory `%s' is not searchable", path);
      else
	builtin_error ("%s: %s", path, strerror (errno));
      return 0;
    }

  return 1;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\pathchk.c:229
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\pathchk.c:258
parsing error 
{
  return (savestring (s));
}
warning: parse error {
  return (savestring (s));
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\pathchk.c:260
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\pathchk.c:279
parsing error 
{
  int path_max;
  int last_elem;		/* Nonzero if checking last element of path. */
  int exists;			/* 2 if the path element exists.  */
  char *slash;
  char *parent;			/* Last existing leading directory so far.  */

  if (portability && !portable_chars_only (path))
    return 1;

  if (*path == '\0')
    return 0;

#ifdef lint
  /* Suppress `used before initialized' warning.  */
  exists = 0;
#endif

  /* Figure out the parent of the first element in PATH.  */
  parent = xstrdup (*path == '/' ? "/" : ".");

  slash = path;
  last_elem = 0;
  while (1)
    {
      int name_max;
      int length;		/* Length of partial path being checked. */
      char *start;		/* Start of path element being checked. */

      /* Find the end of this element of the path.
	 Then chop off the rest of the path after this element. */
      while (*slash == '/')
	slash++;
      start = slash;
      slash = strchr (slash, '/');
      if (slash != NULL)
	*slash = '\0';
      else
	{
	  last_elem = 1;
	  slash = strchr (start, '\0');
	}

      if (!last_elem)
	{
	  exists = dir_ok (path);
	  if (exists == 0)
	    {
	      free (parent);
	      return 1;
	    }
	}

      length = slash - start;
      /* Since we know that `parent' is a directory, it's ok to call
	 pathconf with it as the argument.  (If `parent' isn't a directory
	 or doesn't exist, the behavior of pathconf is undefined.)
	 But if `parent' is a directory and is on a remote file system,
	 it's likely that pathconf can't give us a reasonable value
	 and will return -1.  (NFS and tempfs are not POSIX . . .)
	 In that case, we have no choice but to assume the pessimal
	 POSIX minimums.  */
      name_max = portability ? _POSIX_NAME_MAX : NAME_MAX_FOR (parent);
      if (name_max < 0)
	name_max = _POSIX_NAME_MAX;
      if (length > name_max)
	{
	  builtin_error ("name `%s' has length %d; exceeds limit of %d",
		 start, length, name_max);
	  free (parent);
	  return 1;
	}

      if (last_elem)
	break;

      if (exists == 1)
	{
	  free (parent);
	  parent = xstrdup (path);
	}

      *slash++ = '/';
    }

  /* `parent' is now the last existing leading directory in the whole path,
     so it's ok to call pathconf with it as the argument.  */
  path_max = portability ? _POSIX_PATH_MAX : PATH_MAX_FOR (parent);
  if (path_max < 0)
    path_max = _POSIX_PATH_MAX;
  free (parent);
  if (strlen (path) > path_max)
    {
      builtin_error ("path `%s' has length %lu; exceeds limit of %d",
	     path, (unsigned long)strlen (path), path_max);
      return 1;
    }

  return 0;
}
warning: parse error {
  int path_max;
  int last_elem;		/* Nonzero if checking last element of path. */
  int exists;			/* 2 if the path element exists.  */
  char *slash;
  char *parent;			/* Last existing leading directory so far.  */

  if (portability && !portable_chars_only (path))
    return 1;

  if (*path == '\0')
    return 0;

#ifdef lint
  /* Suppress `used before initialized' warning.  */
  exists = 0;
#endif

  /* Figure out the parent of the first element in PATH.  */
  parent = xstrdup (*path == '/' ? "/" : ".");

  slash = path;
  last_elem = 0;
  while (1)
    {
      int name_max;
      int length;		/* Length of partial path being checked. */
      char *start;		/* Start of path element being checked. */

      /* Find the end of this element of the path.
	 Then chop off the rest of the path after this element. */
      while (*slash == '/')
	slash++;
      start = slash;
      slash = strchr (slash, '/');
      if (slash != NULL)
	*slash = '\0';
      else
	{
	  last_elem = 1;
	  slash = strchr (start, '\0');
	}

      if (!last_elem)
	{
	  exists = dir_ok (path);
	  if (exists == 0)
	    {
	      free (parent);
	      return 1;
	    }
	}

      length = slash - start;
      /* Since we know that `parent' is a directory, it's ok to call
	 pathconf with it as the argument.  (If `parent' isn't a directory
	 or doesn't exist, the behavior of pathconf is undefined.)
	 But if `parent' is a directory and is on a remote file system,
	 it's likely that pathconf can't give us a reasonable value
	 and will return -1.  (NFS and tempfs are not POSIX . . .)
	 In that case, we have no choice but to assume the pessimal
	 POSIX minimums.  */
      name_max = portability ? _POSIX_NAME_MAX : NAME_MAX_FOR (parent);
      if (name_max < 0)
	name_max = _POSIX_NAME_MAX;
      if (length > name_max)
	{
	  builtin_error ("name `%s' has length %d; exceeds limit of %d",
		 start, length, name_max);
	  free (parent);
	  return 1;
	}

      if (last_elem)
	break;

      if (exists == 1)
	{
	  free (parent);
	  parent = xstrdup (path);
	}

      *slash++ = '/';
    }

  /* `parent' is now the last existing leading directory in the whole path,
     so it's ok to call pathconf with it as the argument.  */
  path_max = portability ? _POSIX_PATH_MAX : PATH_MAX_FOR (parent);
  if (path_max < 0)
    path_max = _POSIX_PATH_MAX;
  free (parent);
  if (strlen (path) > path_max)
    {
      builtin_error ("path `%s' has length %lu; exceeds limit of %d",
	     path, (unsigned long)strlen (path), path_max);
      return 1;
    }

  return 0;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\pathchk.c:282
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\perl\bperl.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\shell.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\perl\bperl.c:21
parsing error 
{
	char	**v;
	int	c, r;

	v = make_builtin_argv(list, &c);
	r = perl_main(c, v, export_env);
	free(v);

	return r;
}
warning: parse error {
	char	**v;
	int	c, r;

	v = make_builtin_argv(list, &c);
	r = perl_main(c, v, export_env);
	free(v);

	return r;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\perl\bperl.c:23
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\perl\iperl.c...
parsing error 
extern void xs_init _((void));
warning: parse error extern void xs_init _((void));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\perl\iperl.c:4
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\print.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashtypes.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashansi.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\shell.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\stdc.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\bashgetopt.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\common.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\print.c:75
parsing error 
{
  int c, r, nflag, raw, ofd, sflag;
  intmax_t lfd;
  char **v, *pfmt, *arg;
  WORD_LIST *l;

  nflag = raw = sflag = 0;
  ofd = 1;
  pfmt = 0;

  reset_internal_getopt ();
  while ((c = internal_getopt (list, "Rnprsu:f:")) != -1)
    {
      switch (c)
	{
	case 'R':
	  raw = 2;
	  loptend = lcurrent;
	  if (loptend && ISOPTION (loptend->word->word, 'n'))
	    {
	      loptend = loptend->next;
	      nflag = 1;
	    }
	  goto opt_end;
	case 'r':
	  raw = 1;
	  break;
	case 'n':
	  nflag = 1;
	  break;
	case 's':
	  sflag = 1;
	  break;
	case 'p':
	  break;	/* NOP */
	case 'u':
	  if (all_digits (list_optarg) && legal_number (list_optarg, &lfd) && lfd == (int)lfd)
	    ofd = lfd;
	  else
	    {
	      for (l = list; l->next && l->next != lcurrent; l = l->next);
	      lcurrent = loptend = l;
	      goto opt_end;
	    }
	  break;
	case 'f':
	  pfmt = list_optarg;
	  break;
	CASE_HELPOPT;
	default:
	  builtin_usage ();
	  return (EX_USAGE);
	}
    }

opt_end:
  list = loptend;

  ofp = (ofd == 1) ? stdout : fdopen (dup (ofd), "w");

  if (pfmt)
    {
      WORD_DESC *w;
      WORD_LIST *nlist;

      w = make_word (pfmt);
      nlist = make_word_list (w, list);
      r = printf_builtin (nlist);
      nlist->next = (WORD_LIST *)NULL;
      dispose_words (nlist);
      return (r);
    }

  if (raw)
    {
      for (l = list; l; l = l->next)
	{
	  fprintf (ofp, "%s", l->word->word);
	  if (l->next)
	    fprintf (ofp, " ");
	}
      if (nflag == 0)
	fprintf (ofp, "\n");
      fflush (ofp);
      return (0);	
    }
        
  r = printargs (list, ofp);
  if (r && nflag == 0)
    fprintf (ofp, "\n");
  if (ofd != 1)
    fclose (ofp);
  return 0;
}
warning: parse error {
  int c, r, nflag, raw, ofd, sflag;
  intmax_t lfd;
  char **v, *pfmt, *arg;
  WORD_LIST *l;

  nflag = raw = sflag = 0;
  ofd = 1;
  pfmt = 0;

  reset_internal_getopt ();
  while ((c = internal_getopt (list, "Rnprsu:f:")) != -1)
    {
      switch (c)
	{
	case 'R':
	  raw = 2;
	  loptend = lcurrent;
	  if (loptend && ISOPTION (loptend->word->word, 'n'))
	    {
	      loptend = loptend->next;
	      nflag = 1;
	    }
	  goto opt_end;
	case 'r':
	  raw = 1;
	  break;
	case 'n':
	  nflag = 1;
	  break;
	case 's':
	  sflag = 1;
	  break;
	case 'p':
	  break;	/* NOP */
	case 'u':
	  if (all_digits (list_optarg) && legal_number (list_optarg, &lfd) && lfd == (int)lfd)
	    ofd = lfd;
	  else
	    {
	      for (l = list; l->next && l->next != lcurrent; l = l->next);
	      lcurrent = loptend = l;
	      goto opt_end;
	    }
	  break;
	case 'f':
	  pfmt = list_optarg;
	  break;
	CASE_HELPOPT;
	default:
	  builtin_usage ();
	  return (EX_USAGE);
	}
    }

opt_end:
  list = loptend;

  ofp = (ofd == 1) ? stdout : fdopen (dup (ofd), "w");

  if (pfmt)
    {
      WORD_DESC *w;
      WORD_LIST *nlist;

      w = make_word (pfmt);
      nlist = make_word_list (w, list);
      r = printf_builtin (nlist);
      nlist->next = (WORD_LIST *)NULL;
      dispose_words (nlist);
      return (r);
    }

  if (raw)
    {
      for (l = list; l; l = l->next)
	{
	  fprintf (ofp, "%s", l->word->word);
	  if (l->next)
	    fprintf (ofp, " ");
	}
      if (nflag == 0)
	fprintf (ofp, "\n");
      fflush (ofp);
      return (0);	
    }
        
  r = printargs (list, ofp);
  if (r && nflag == 0)
    fprintf (ofp, "\n");
  if (ofd != 1)
    fclose (ofp);
  return 0;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\print.c:77
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\print.c:173
parsing error 
{
  WORD_LIST *l;
  char *ostr;
  int sawc;

  for (sawc = 0, l = list; l; l = l->next)
    {
      ostr = ansicstr (l->word->word, strlen (l->word->word), 0, &sawc, (int *)0);
      fprintf (ofp, "%s", ostr);
      free (ostr);
      if (sawc)
        return (0);
      if (l->next)
        fprintf (ofp, " ");
    }
  return (1);
}
warning: parse error {
  WORD_LIST *l;
  char *ostr;
  int sawc;

  for (sawc = 0, l = list; l; l = l->next)
    {
      ostr = ansicstr (l->word->word, strlen (l->word->word), 0, &sawc, (int *)0);
      fprintf (ofp, "%s", ostr);
      free (ostr);
      if (sawc)
        return (0);
      if (l->next)
        fprintf (ofp, " ");
    }
  return (1);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\print.c:176
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\printenv.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\shell.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\bashgetopt.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\common.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\printenv.c:37
parsing error 
{
  register char **envp;
  int opt;
  SHELL_VAR *var;

  reset_internal_getopt ();
  while ((opt = internal_getopt (list, "")) != -1)
    {
      switch (opt)
	{
	CASE_HELPOPT;
	default:
	  builtin_usage ();
	  return (EX_USAGE);
	}
    }
  list = loptend;

  /* printenv */
  if (list == 0)
    {
      maybe_make_export_env ();		/* this allows minimal code */
      for (envp = export_env; *envp; envp++)
	printf ("%s\n", *envp);
      return (EXECUTION_SUCCESS);
    }

  /* printenv varname */
  var = find_variable (list->word->word);
  if (var == 0 || (exported_p (var) == 0))
    return (EXECUTION_FAILURE);

  if (function_p (var))
    print_var_function (var);
  else
    print_var_value (var, 0);

  printf("\n");
  return (EXECUTION_SUCCESS);
}
warning: parse error {
  register char **envp;
  int opt;
  SHELL_VAR *var;

  reset_internal_getopt ();
  while ((opt = internal_getopt (list, "")) != -1)
    {
      switch (opt)
	{
	CASE_HELPOPT;
	default:
	  builtin_usage ();
	  return (EX_USAGE);
	}
    }
  list = loptend;

  /* printenv */
  if (list == 0)
    {
      maybe_make_export_env ();		/* this allows minimal code */
      for (envp = export_env; *envp; envp++)
	printf ("%s\n", *envp);
      return (EXECUTION_SUCCESS);
    }

  /* printenv varname */
  var = find_variable (list->word->word);
  if (var == 0 || (exported_p (var) == 0))
    return (EXECUTION_FAILURE);

  if (function_p (var))
    print_var_function (var);
  else
    print_var_value (var, 0);

  printf("\n");
  return (EXECUTION_SUCCESS);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\printenv.c:39
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\push.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\shell.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\jobs.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\bashgetopt.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\common.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\push.c:42
parsing error 
{
  pid_t pid;
  int xstatus, opt;

  xstatus = EXECUTION_SUCCESS;
  reset_internal_getopt ();
  while ((opt = internal_getopt (list, "")) != -1)
    {
      switch (opt)
	{
	CASE_HELPOPT;
	default:
	  builtin_usage ();
	  return (EX_USAGE);
	}
    }
  list = loptend;  

  pid = make_child (savestring ("push"), 0);
  if (pid == -1)
    {
      builtin_error ("cannot fork: %s", strerror (errno));
      return (EXECUTION_FAILURE);
    }
  else if (pid == 0)
    {
      /* Shell variable adjustments: $SHLVL, $$, $PPID, $! */
      adjust_shell_level (1);
      dollar_dollar_pid = getpid ();
      set_ppid ();

      /* Clean up job control stuff. */
      stop_making_children ();
      cleanup_the_pipeline ();
      delete_all_jobs (0);

      last_asynchronous_pid = NO_PID;

      /* Make sure the job control code has the right values for
	 the shell's process group and tty process group, and that
	 the signals are set correctly for job control. */
      initialize_job_control (0);
      initialize_job_signals ();

      /* And read commands until exit. */
      reader_loop ();
      exit_shell (last_command_exit_value);
    }
  else
    {
      stop_pipeline (0, (COMMAND *)NULL);
      xstatus = wait_for (pid, 0);
      return (xstatus);
    }   
}
warning: parse error {
  pid_t pid;
  int xstatus, opt;

  xstatus = EXECUTION_SUCCESS;
  reset_internal_getopt ();
  while ((opt = internal_getopt (list, "")) != -1)
    {
      switch (opt)
	{
	CASE_HELPOPT;
	default:
	  builtin_usage ();
	  return (EX_USAGE);
	}
    }
  list = loptend;  

  pid = make_child (savestring ("push"), 0);
  if (pid == -1)
    {
      builtin_error ("cannot fork: %s", strerror (errno));
      return (EXECUTION_FAILURE);
    }
  else if (pid == 0)
    {
      /* Shell variable adjustments: $SHLVL, $$, $PPID, $! */
      adjust_shell_level (1);
      dollar_dollar_pid = getpid ();
      set_ppid ();

      /* Clean up job control stuff. */
      stop_making_children ();
      cleanup_the_pipeline ();
      delete_all_jobs (0);

      last_asynchronous_pid = NO_PID;

      /* Make sure the job control code has the right values for
	 the shell's process group and tty process group, and that
	 the signals are set correctly for job control. */
      initialize_job_control (0);
      initialize_job_signals ();

      /* And read commands until exit. */
      reader_loop ();
      exit_shell (last_command_exit_value);
    }
  else
    {
      stop_pipeline (0, (COMMAND *)NULL);
      xstatus = wait_for (pid, 0);
      return (xstatus);
    }   
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\push.c:44
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\realpath.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashansi.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\maxpath.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\shell.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\bashgetopt.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\common.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\realpath.c:64
parsing error 
{
	int	opt, cflag, vflag, sflag, es;
	char	*r, realbuf[PATH_MAX], *p;
	struct stat sb;

	if (list == 0) {
		builtin_usage();
		return (EX_USAGE);
	}

	vflag = cflag = sflag = 0;
	reset_internal_getopt();
	while ((opt = internal_getopt (list, "csv")) != -1) {
		switch (opt) {
		case 'c':
			cflag = 1;
			break;
		case 's':
			sflag = 1;
			break;
		case 'v':
			vflag = 1;
			break;
		CASE_HELPOPT;
		default:
			builtin_usage();
			return (EX_USAGE);
		}
	}

	list = loptend;

	if (list == 0) {
		builtin_usage();
		return (EX_USAGE);
	}

	for (es = EXECUTION_SUCCESS; list; list = list->next) {
		p = list->word->word;
		r = sh_realpath(p, realbuf);
		if (r == 0) {
			es = EXECUTION_FAILURE;
			if (sflag == 0)
				builtin_error("%s: cannot resolve: %s", p, strerror(errno));
			continue;
		}
		if (cflag && (stat(realbuf, &sb) < 0)) {
			es = EXECUTION_FAILURE;
			if (sflag == 0)
				builtin_error("%s: %s", p, strerror(errno));
			continue;
		}
		if (sflag == 0) {
			if (vflag)
				printf ("%s -> ", p);
			printf("%s\n", realbuf);
		}
	}
	return es;
}
warning: parse error {
	int	opt, cflag, vflag, sflag, es;
	char	*r, realbuf[PATH_MAX], *p;
	struct stat sb;

	if (list == 0) {
		builtin_usage();
		return (EX_USAGE);
	}

	vflag = cflag = sflag = 0;
	reset_internal_getopt();
	while ((opt = internal_getopt (list, "csv")) != -1) {
		switch (opt) {
		case 'c':
			cflag = 1;
			break;
		case 's':
			sflag = 1;
			break;
		case 'v':
			vflag = 1;
			break;
		CASE_HELPOPT;
		default:
			builtin_usage();
			return (EX_USAGE);
		}
	}

	list = loptend;

	if (list == 0) {
		builtin_usage();
		return (EX_USAGE);
	}

	for (es = EXECUTION_SUCCESS; list; list = list->next) {
		p = list->word->word;
		r = sh_realpath(p, realbuf);
		if (r == 0) {
			es = EXECUTION_FAILURE;
			if (sflag == 0)
				builtin_error("%s: cannot resolve: %s", p, strerror(errno));
			continue;
		}
		if (cflag && (stat(realbuf, &sb) < 0)) {
			es = EXECUTION_FAILURE;
			if (sflag == 0)
				builtin_error("%s: %s", p, strerror(errno));
			continue;
		}
		if (sflag == 0) {
			if (vflag)
				printf ("%s -> ", p);
			printf("%s\n", realbuf);
		}
	}
	return es;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\realpath.c:66
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\rm.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\shell.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\common.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\bashgetopt.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\rm.c:114
parsing error 
{
  const char *name;
  WORD_LIST *l;
  int rval, opt;

  recursive = force = 0;
  rval = EXECUTION_SUCCESS;

  reset_internal_getopt ();
  while ((opt = internal_getopt (list, "Rrfi")) != -1)
    {
      switch (opt)
	{
	case 'R':
	case 'r':
	  recursive = 1;
	  break;
	case 'f':
	  force = 1;
	  break;
	case 'i':
	  return (EX_DISKFALLBACK);
	CASE_HELPOPT;
	default:
	  builtin_usage ();
	  return (EX_USAGE);
	}
    }
  list = loptend;

  if (list == 0)
    {
      if (force == 0)
	{
          builtin_usage ();
          return (EXECUTION_FAILURE);
	}
      return (EXECUTION_SUCCESS);      
    }

  for (l = list; l; l = l->next)
    {
      if (rm_file(l->word->word) && force == 0)
	rval = EXECUTION_FAILURE;
    }

  return rval;
}
warning: parse error {
  const char *name;
  WORD_LIST *l;
  int rval, opt;

  recursive = force = 0;
  rval = EXECUTION_SUCCESS;

  reset_internal_getopt ();
  while ((opt = internal_getopt (list, "Rrfi")) != -1)
    {
      switch (opt)
	{
	case 'R':
	case 'r':
	  recursive = 1;
	  break;
	case 'f':
	  force = 1;
	  break;
	case 'i':
	  return (EX_DISKFALLBACK);
	CASE_HELPOPT;
	default:
	  builtin_usage ();
	  return (EX_USAGE);
	}
    }
  list = loptend;

  if (list == 0)
    {
      if (force == 0)
	{
          builtin_usage ();
          return (EXECUTION_FAILURE);
	}
      return (EXECUTION_SUCCESS);      
    }

  for (l = list; l; l = l->next)
    {
      if (rm_file(l->word->word) && force == 0)
	rval = EXECUTION_FAILURE;
    }

  return rval;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\rm.c:116
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\rmdir.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\shell.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\common.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\rmdir.c:36
parsing error 
{
  int rval;
  WORD_LIST *l;

  if (no_options (list))
    return (EX_USAGE);

  for (rval = EXECUTION_SUCCESS, l = list; l; l = l->next)
    if (rmdir (l->word->word) < 0)
      {
	builtin_error ("%s: %s", l->word->word, strerror (errno));
	rval = EXECUTION_FAILURE;
      }

  return rval;
}
warning: parse error {
  int rval;
  WORD_LIST *l;

  if (no_options (list))
    return (EX_USAGE);

  for (rval = EXECUTION_SUCCESS, l = list; l; l = l->next)
    if (rmdir (l->word->word) < 0)
      {
	builtin_error ("%s: %s", l->word->word, strerror (errno));
	rval = EXECUTION_FAILURE;
      }

  return rval;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\rmdir.c:38
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\seq.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashansi.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\loadables.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashintl.h...skip
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\seq.c:73
parsing error 
{
  floatmax_t ret;
  char *ep;

  errno = 0;
  ret = strtofltmax (arg, &ep);

  if (*ep)
    {
      sh_invalidnum ((char *)arg);
      conversion_error = 1;
    }
  else if (errno == ERANGE)
    {
      builtin_error ("warning: %s: %s", arg, strerror(ERANGE));
      conversion_error = 1;
    }

  if (ret == -0.0)
    ret = 0.0;

  return (ret);
}
warning: parse error {
  floatmax_t ret;
  char *ep;

  errno = 0;
  ret = strtofltmax (arg, &ep);

  if (*ep)
    {
      sh_invalidnum ((char *)arg);
      conversion_error = 1;
    }
  else if (errno == ERANGE)
    {
      builtin_error ("warning: %s: %s", arg, strerror(ERANGE));
      conversion_error = 1;
    }

  if (ret == -0.0)
    ret = 0.0;

  return (ret);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\seq.c:74
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\seq.c:173
parsing error 
{
  int p;
  char *dp;

  if (dp = strchr (numbuf, decimal_point))
    dp++;		/* skip over decimal point */
  for (p = 0; dp && *dp && ISDIGIT (*dp); dp++)
    p++;
  return p;
}
warning: parse error {
  int p;
  char *dp;

  if (dp = strchr (numbuf, decimal_point))
    dp++;		/* skip over decimal point */
  for (p = 0; dp && *dp && ISDIGIT (*dp); dp++)
    p++;
  return p;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\seq.c:174
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\seq.c:187
parsing error 
{
  static char buf[6 + 2 * INT_STRLEN_BOUND (int)];
  int wfirst, wlast, width;
  int iprec, fprec, lprec, prec;

  if (equal_width == 0)
    return (FLOATMAX_FMT);

  /* OK, we have to figure out the largest number of decimal places. This is
     a little more expensive than using the original strings. */
  snprintf (buf, sizeof (buf), FLOATMAX_FMT, incr);
  iprec = getprec (buf);

  wfirst = snprintf (buf, sizeof (buf), FLOATMAX_FMT, first);
  fprec = getprec (buf);
    
  prec = MAX (fprec, iprec);

  wlast = snprintf (buf, sizeof (buf), FLOATMAX_FMT, last);
  lprec = getprec (buf);

  /* increase first width by any increased precision in increment */
  wfirst += (prec - fprec);

  /* adjust last width to use precision from first/incr */
  wlast += (prec - lprec);

  if (lprec && prec == 0)
    wlast--;		/* no decimal point */
  if (lprec == 0 && prec)
    wlast++;		/* include decimal point */
  if (fprec == 0 && prec)
    wfirst++;		/* include decimal point */

  width = MAX (wfirst, wlast);
  if (width)
    sprintf (buf, "%%0%d.%d%sf", width, prec, FLOATMAX_CONV);
  else
    sprintf (buf, "%%.%d%sf", prec, FLOATMAX_CONV);

  return buf;
}
warning: parse error {
  static char buf[6 + 2 * INT_STRLEN_BOUND (int)];
  int wfirst, wlast, width;
  int iprec, fprec, lprec, prec;

  if (equal_width == 0)
    return (FLOATMAX_FMT);

  /* OK, we have to figure out the largest number of decimal places. This is
     a little more expensive than using the original strings. */
  snprintf (buf, sizeof (buf), FLOATMAX_FMT, incr);
  iprec = getprec (buf);

  wfirst = snprintf (buf, sizeof (buf), FLOATMAX_FMT, first);
  fprec = getprec (buf);
    
  prec = MAX (fprec, iprec);

  wlast = snprintf (buf, sizeof (buf), FLOATMAX_FMT, last);
  lprec = getprec (buf);

  /* increase first width by any increased precision in increment */
  wfirst += (prec - fprec);

  /* adjust last width to use precision from first/incr */
  wlast += (prec - lprec);

  if (lprec && prec == 0)
    wlast--;		/* no decimal point */
  if (lprec == 0 && prec)
    wlast++;		/* include decimal point */
  if (fprec == 0 && prec)
    wfirst++;		/* include decimal point */

  width = MAX (wfirst, wlast);
  if (width)
    sprintf (buf, "%%0%d.%d%sf", width, prec, FLOATMAX_CONV);
  else
    sprintf (buf, "%%.%d%sf", prec, FLOATMAX_CONV);

  return buf;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\seq.c:189
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\seq.c:234
parsing error 
{
  int n;
  floatmax_t next;
  const char *s;

  n = 0;		/* iteration counter */
  s = "";
  for (next = first; incr >= 0 ? (next <= last) : (next >= last); next = first + n * incr)
    {
      QUIT;
      if (*s && fputs (s, stdout) == EOF)
	return (sh_chkwrite (EXECUTION_FAILURE));
      if (printf (fmt, next) < 0)
	return (sh_chkwrite (EXECUTION_FAILURE));
      s = separator;
      n++;
    }

  if (n > 0 && fputs (terminator, stdout) == EOF)
    return (sh_chkwrite (EXECUTION_FAILURE));
  return (sh_chkwrite (EXECUTION_SUCCESS));
}
warning: parse error {
  int n;
  floatmax_t next;
  const char *s;

  n = 0;		/* iteration counter */
  s = "";
  for (next = first; incr >= 0 ? (next <= last) : (next >= last); next = first + n * incr)
    {
      QUIT;
      if (*s && fputs (s, stdout) == EOF)
	return (sh_chkwrite (EXECUTION_FAILURE));
      if (printf (fmt, next) < 0)
	return (sh_chkwrite (EXECUTION_FAILURE));
      s = separator;
      n++;
    }

  if (n > 0 && fputs (terminator, stdout) == EOF)
    return (sh_chkwrite (EXECUTION_FAILURE));
  return (sh_chkwrite (EXECUTION_SUCCESS));
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\seq.c:236
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\seq.c:261
parsing error 
{
  int ret;

  ret = num < 0;		/* sign */
  if (ret)
    num = -num;
  do
    ret++;
  while (num /= 10);
  return ret;
}
warning: parse error {
  int ret;

  ret = num < 0;		/* sign */
  if (ret)
    num = -num;
  do
    ret++;
  while (num /= 10);
  return ret;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\seq.c:263
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\seq.c:276
parsing error 
{
  char intwfmt[6 + INT_STRLEN_BOUND(int) + sizeof (PRIdMAX)];
  const char *s;
  intmax_t i, next;

  /* compute integer format string */
  if (equal_width)	/* -w supplied */
    {
      int wfirst, wlast, width;

      wfirst = width_needed (ifirst);
      wlast = width_needed (ilast);
      width = MAX(wfirst, wlast);

      /* The leading %s is for the separator */
      snprintf (intwfmt, sizeof (intwfmt), "%%s%%0%u" PRIdMAX, width);
    }

  /* We could use braces.c:mkseq here but that allocates lots of memory */
  s = "";
  for (i = ifirst; (ifirst <= ilast) ? (i <= ilast) : (i >= ilast); i = next)
    {
      QUIT;
      /* The leading %s is for the separator */
      if (printf (equal_width ?  intwfmt : "%s%" PRIdMAX, s, i) < 0)
	return (sh_chkwrite (EXECUTION_FAILURE));
      s = separator;
      next = i + iincr;
    }

  if (fputs (terminator, stdout) == EOF)
    return (sh_chkwrite (EXECUTION_FAILURE));
  return (sh_chkwrite (EXECUTION_SUCCESS));
}
warning: parse error {
  char intwfmt[6 + INT_STRLEN_BOUND(int) + sizeof (PRIdMAX)];
  const char *s;
  intmax_t i, next;

  /* compute integer format string */
  if (equal_width)	/* -w supplied */
    {
      int wfirst, wlast, width;

      wfirst = width_needed (ifirst);
      wlast = width_needed (ilast);
      width = MAX(wfirst, wlast);

      /* The leading %s is for the separator */
      snprintf (intwfmt, sizeof (intwfmt), "%%s%%0%u" PRIdMAX, width);
    }

  /* We could use braces.c:mkseq here but that allocates lots of memory */
  s = "";
  for (i = ifirst; (ifirst <= ilast) ? (i <= ilast) : (i >= ilast); i = next)
    {
      QUIT;
      /* The leading %s is for the separator */
      if (printf (equal_width ?  intwfmt : "%s%" PRIdMAX, s, i) < 0)
	return (sh_chkwrite (EXECUTION_FAILURE));
      s = separator;
      next = i + iincr;
    }

  if (fputs (terminator, stdout) == EOF)
    return (sh_chkwrite (EXECUTION_FAILURE));
  return (sh_chkwrite (EXECUTION_SUCCESS));
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\seq.c:278
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\seq.c:314
parsing error 
{
  floatmax_t first, last, incr;
  intmax_t ifirst, ilast, iincr;
  WORD_LIST *l;
  int opt, nargs, intseq, freefmt;
  char *first_str, *incr_str, *last_str;
  char const *fmtstr;		/* The printf(3) format used for output.  */

  equal_width = 0;
  separator = "\n";
  fmtstr = NULL;

  first = 1.0;
  last = 0.0;
  incr = 0.0;		/* set later */
  ifirst = ilast = iincr = 0;
  first_str = incr_str = last_str = 0;

  intseq = freefmt = 0;
  opt = 0;

  reset_internal_getopt ();
  while (opt != -1)
    {
      l = lcurrent ? lcurrent : list;
      if (l && l->word && l->word->word && l->word->word[0] == '-' &&
	   (l->word->word[1] == '.' || DIGIT (l->word->word[1])))
	{
	  loptend = l;
	  break;	/* negative number */
	}
      if ((opt = internal_getopt (list, "f:s:w")) == -1)
        break;

      switch (opt)
	{
	case 'f':
	  fmtstr = list_optarg;
	  break;
	case 's':
	  separator = list_optarg;
	  break;
	case 'w':
	  equal_width = 1;
	  break;
	CASE_HELPOPT;
	default:
	  builtin_usage ();
	  return (EX_USAGE);
	}
    }
  list = loptend;

  if (list == 0)
    {
      builtin_usage ();
      return (EXECUTION_FAILURE);
    }

  for (nargs = 1, l = list; l->next; l = l->next)
    nargs++;
  if (nargs > 3)
    {
      builtin_usage ();
      return (EXECUTION_FAILURE);
    }

  /* LAST */
  conversion_error = 0;
  last = getfloatmax (last_str = l->word->word);
  if (conversion_error)
    return (EXECUTION_FAILURE);

  /* FIRST LAST */
  if (nargs > 1)
    {
      conversion_error = 0;
      first = getfloatmax (first_str = list->word->word);
      if (conversion_error)
	return (EXECUTION_FAILURE);
    }

  /* FIRST INCR LAST */
  if (nargs > 2)
    {
      conversion_error = 0;
      incr = getfloatmax (incr_str = list->next->word->word);
      if (conversion_error)
	return (EXECUTION_FAILURE);
      if (incr == 0.0)
	{
	  builtin_error ("zero %screment", (first < last) ?  "in" : "de");
	  return (EXECUTION_FAILURE);
	}
    }

  /* Sanitize arguments */
  if (incr == 0.0)
    incr = (first <= last) ?  1.0 : -1.0;
  if ((incr < 0.0 && first < last) || (incr > 0 && first > last))
    {
      builtin_error ("incorrect %screment", (first < last) ?  "in" : "de");
      return (EXECUTION_FAILURE);
    }

  /* validate format here */
  if (fmtstr)
    {
      fmtstr = long_double_format (fmtstr);
      freefmt = 1;
      if (fmtstr == 0)
	return (EXECUTION_FAILURE);
    }
      
  if (fmtstr != NULL && equal_width)
    {
      builtin_warning ("-w ignored when the format string is specified");
      equal_width = 0;
    }

  /* Placeholder for later additional conditions */
  if (last_str && all_digits (last_str) &&
      (first_str == 0 || all_digits (first_str)) &&
      (incr_str == 0 || all_digits (incr_str)) &&
      fmtstr == NULL)
    intseq = 1;

  if (intseq)
    {
      ifirst = (intmax_t)first; /* truncation */
      ilast = (intmax_t)last;
      iincr = (intmax_t)incr;

      return (print_intseq (ifirst, ilast, iincr));
    }

  decimal_point = locale_decpoint ();
  if (fmtstr == NULL)
    fmtstr = genformat (first, incr, last);

  print_fltseq (fmtstr, first, last, incr);

  if (freefmt)
    free ((void *)fmtstr);
  return sh_chkwrite (EXECUTION_SUCCESS);
}
warning: parse error {
  floatmax_t first, last, incr;
  intmax_t ifirst, ilast, iincr;
  WORD_LIST *l;
  int opt, nargs, intseq, freefmt;
  char *first_str, *incr_str, *last_str;
  char const *fmtstr;		/* The printf(3) format used for output.  */

  equal_width = 0;
  separator = "\n";
  fmtstr = NULL;

  first = 1.0;
  last = 0.0;
  incr = 0.0;		/* set later */
  ifirst = ilast = iincr = 0;
  first_str = incr_str = last_str = 0;

  intseq = freefmt = 0;
  opt = 0;

  reset_internal_getopt ();
  while (opt != -1)
    {
      l = lcurrent ? lcurrent : list;
      if (l && l->word && l->word->word && l->word->word[0] == '-' &&
	   (l->word->word[1] == '.' || DIGIT (l->word->word[1])))
	{
	  loptend = l;
	  break;	/* negative number */
	}
      if ((opt = internal_getopt (list, "f:s:w")) == -1)
        break;

      switch (opt)
	{
	case 'f':
	  fmtstr = list_optarg;
	  break;
	case 's':
	  separator = list_optarg;
	  break;
	case 'w':
	  equal_width = 1;
	  break;
	CASE_HELPOPT;
	default:
	  builtin_usage ();
	  return (EX_USAGE);
	}
    }
  list = loptend;

  if (list == 0)
    {
      builtin_usage ();
      return (EXECUTION_FAILURE);
    }

  for (nargs = 1, l = list; l->next; l = l->next)
    nargs++;
  if (nargs > 3)
    {
      builtin_usage ();
      return (EXECUTION_FAILURE);
    }

  /* LAST */
  conversion_error = 0;
  last = getfloatmax (last_str = l->word->word);
  if (conversion_error)
    return (EXECUTION_FAILURE);

  /* FIRST LAST */
  if (nargs > 1)
    {
      conversion_error = 0;
      first = getfloatmax (first_str = list->word->word);
      if (conversion_error)
	return (EXECUTION_FAILURE);
    }

  /* FIRST INCR LAST */
  if (nargs > 2)
    {
      conversion_error = 0;
      incr = getfloatmax (incr_str = list->next->word->word);
      if (conversion_error)
	return (EXECUTION_FAILURE);
      if (incr == 0.0)
	{
	  builtin_error ("zero %screment", (first < last) ?  "in" : "de");
	  return (EXECUTION_FAILURE);
	}
    }

  /* Sanitize arguments */
  if (incr == 0.0)
    incr = (first <= last) ?  1.0 : -1.0;
  if ((incr < 0.0 && first < last) || (incr > 0 && first > last))
    {
      builtin_error ("incorrect %screment", (first < last) ?  "in" : "de");
      return (EXECUTION_FAILURE);
    }

  /* validate format here */
  if (fmtstr)
    {
      fmtstr = long_double_format (fmtstr);
      freefmt = 1;
      if (fmtstr == 0)
	return (EXECUTION_FAILURE);
    }
      
  if (fmtstr != NULL && equal_width)
    {
      builtin_warning ("-w ignored when the format string is specified");
      equal_width = 0;
    }

  /* Placeholder for later additional conditions */
  if (last_str && all_digits (last_str) &&
      (first_str == 0 || all_digits (first_str)) &&
      (incr_str == 0 || all_digits (incr_str)) &&
      fmtstr == NULL)
    intseq = 1;

  if (intseq)
    {
      ifirst = (intmax_t)first; /* truncation */
      ilast = (intmax_t)last;
      iincr = (intmax_t)incr;

      return (print_intseq (ifirst, ilast, iincr));
    }

  decimal_point = locale_decpoint ();
  if (fmtstr == NULL)
    fmtstr = genformat (first, incr, last);

  print_fltseq (fmtstr, first, last, incr);

  if (freefmt)
    free ((void *)fmtstr);
  return sh_chkwrite (EXECUTION_SUCCESS);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\seq.c:316
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\setpgid.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashtypes.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\posixtime.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\shell.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\common.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\bashgetopt.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\setpgid.c:45
parsing error 
{
  register WORD_LIST *wl;
  intmax_t pid_arg, pgid_arg;
  pid_t pid, pgid;
  char *pidstr, *pgidstr;

  wl = list;
  pid = pgid = 0;

  if (wl == 0 || wl->next == 0)
    {
      builtin_usage ();
      return (EX_USAGE);
    }

  pidstr = wl->word ? wl->word->word : 0;
  pgidstr = wl->next->word ? wl->next->word->word : 0;

  if (pidstr == 0 || pgidstr == 0)
    {
      builtin_usage ();
      return (EX_USAGE);
    }
      
  if (legal_number (pidstr, &pid_arg) == 0)
    {
      builtin_error ("%s: pid argument must be numeric", pidstr);
      return (EXECUTION_FAILURE);
    }
  if (pid_arg < 0)
    {
      builtin_error("%s: negative pid  values not allowed", pidstr);
      return (EXECUTION_FAILURE);
    }
  pid = pid_arg;

  if (legal_number (pgidstr, &pgid_arg) == 0)
    {
      builtin_error ("%s: pgrp argument must be numeric", pgidstr);
      return (EXECUTION_FAILURE);
    }
  if (pgid_arg < 0)
    {
      builtin_error ("%s: negative pgrp values not allowed", pgidstr);
      return (EXECUTION_FAILURE);
    }
  pgid = pgid_arg;

  errno = 0;
  if (setpgid(pid, pgid) < 0)
    {
      builtin_error("setpgid failed: %s", strerror (errno));
      return (EXECUTION_FAILURE);     
    }
  return (EXECUTION_SUCCESS);     
}
warning: parse error {
  register WORD_LIST *wl;
  intmax_t pid_arg, pgid_arg;
  pid_t pid, pgid;
  char *pidstr, *pgidstr;

  wl = list;
  pid = pgid = 0;

  if (wl == 0 || wl->next == 0)
    {
      builtin_usage ();
      return (EX_USAGE);
    }

  pidstr = wl->word ? wl->word->word : 0;
  pgidstr = wl->next->word ? wl->next->word->word : 0;

  if (pidstr == 0 || pgidstr == 0)
    {
      builtin_usage ();
      return (EX_USAGE);
    }
      
  if (legal_number (pidstr, &pid_arg) == 0)
    {
      builtin_error ("%s: pid argument must be numeric", pidstr);
      return (EXECUTION_FAILURE);
    }
  if (pid_arg < 0)
    {
      builtin_error("%s: negative pid  values not allowed", pidstr);
      return (EXECUTION_FAILURE);
    }
  pid = pid_arg;

  if (legal_number (pgidstr, &pgid_arg) == 0)
    {
      builtin_error ("%s: pgrp argument must be numeric", pgidstr);
      return (EXECUTION_FAILURE);
    }
  if (pgid_arg < 0)
    {
      builtin_error ("%s: negative pgrp values not allowed", pgidstr);
      return (EXECUTION_FAILURE);
    }
  pgid = pgid_arg;

  errno = 0;
  if (setpgid(pid, pgid) < 0)
    {
      builtin_error("setpgid failed: %s", strerror (errno));
      return (EXECUTION_FAILURE);     
    }
  return (EXECUTION_SUCCESS);     
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\setpgid.c:47
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\sleep.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashtypes.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\chartypes.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\shell.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\common.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\sleep.c:52
parsing error 
{
	long	sec, usec;
	char	*ep;
	int	r, mul;
	time_t	t;

	if (list == 0) {
		builtin_usage();
		return(EX_USAGE);
	}

	/* Skip over `--' */
	if (list->word && ISOPTION (list->word->word, '-'))
		list = list->next;

	if (*list->word->word == '-' || list->next) {
		builtin_usage ();
		return (EX_USAGE);
	}

    	r = uconvert(list->word->word, &sec, &usec, &ep);
	/* Maybe postprocess conversion failures here based on EP */
    		
    	if (r) {
		fsleep(sec, usec);
		QUIT;
		return(EXECUTION_SUCCESS);
    	}

	builtin_error("%s: bad sleep interval", list->word->word);
	return (EXECUTION_FAILURE);
}
warning: parse error {
	long	sec, usec;
	char	*ep;
	int	r, mul;
	time_t	t;

	if (list == 0) {
		builtin_usage();
		return(EX_USAGE);
	}

	/* Skip over `--' */
	if (list->word && ISOPTION (list->word->word, '-'))
		list = list->next;

	if (*list->word->word == '-' || list->next) {
		builtin_usage ();
		return (EX_USAGE);
	}

    	r = uconvert(list->word->word, &sec, &usec, &ep);
	/* Maybe postprocess conversion failures here based on EP */
    		
    	if (r) {
		fsleep(sec, usec);
		QUIT;
		return(EXECUTION_SUCCESS);
    	}

	builtin_error("%s: bad sleep interval", list->word->word);
	return (EXECUTION_FAILURE);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\sleep.c:54
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\stat.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\posixstat.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\posixtime.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashansi.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\shell.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\common.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\bashgetopt.h...skip
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\stat.c:77
parsing error 
{
  intmax_t lfd;
  int fd, r;

  if (strncmp (fname, "/dev/fd/", 8) == 0)
    {
      if ((legal_number(fname + 8, &lfd) == 0) || (int)lfd != lfd)
	{
	  errno = EINVAL;
	  return -1;
	}
      fd = lfd;
      r = fstat(fd, sp);
    }
#ifdef HAVE_LSTAT
  else if (flags & 1)
    r = lstat(fname, sp);
#endif
  else
    r = stat(fname, sp);

  return r;
}
warning: parse error {
  intmax_t lfd;
  int fd, r;

  if (strncmp (fname, "/dev/fd/", 8) == 0)
    {
      if ((legal_number(fname + 8, &lfd) == 0) || (int)lfd != lfd)
	{
	  errno = EINVAL;
	  return -1;
	}
      fd = lfd;
      r = fstat(fd, sp);
    }
#ifdef HAVE_LSTAT
  else if (flags & 1)
    r = lstat(fname, sp);
#endif
  else
    r = stat(fname, sp);

  return r;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\stat.c:80
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\stat.c:105
parsing error 
{
#if defined (HAVE_READLINK)
  char linkbuf[PATH_MAX];
  int n;

  if (fname && S_ISLNK (sp->st_mode) && (n = readlink (fname, linkbuf, PATH_MAX)) > 0)
    {
      linkbuf[n] = '\0';
      return (savestring (linkbuf));
    }
  else
#endif
    return (savestring (fname));
}
warning: parse error {
#if defined (HAVE_READLINK)
  char linkbuf[PATH_MAX];
  int n;

  if (fname && S_ISLNK (sp->st_mode) && (n = readlink (fname, linkbuf, PATH_MAX)) > 0)
    {
      linkbuf[n] = '\0';
      return (savestring (linkbuf));
    }
  else
#endif
    return (savestring (fname));
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\stat.c:108
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\stat.c:124
parsing error 
{
  int operms;
  char *ret;

  operms = 0;

  if (m & S_IRUSR)
    operms |= 0400;
  if (m & S_IWUSR)
    operms |= 0200;
  if (m & S_IXUSR)
    operms |= 0100;

  if (m & S_IRGRP)
    operms |= 0040;
  if (m & S_IWGRP)
    operms |= 0020;
  if (m & S_IXGRP)
    operms |= 0010;

  if (m & S_IROTH)
    operms |= 0004;
  if (m & S_IWOTH)
    operms |= 0002;
  if (m & S_IXOTH)
    operms |= 0001;

  if (m & S_ISUID)
    operms |= 04000;
  if (m & S_ISGID)
    operms |= 02000;
  if (m & S_ISVTX)
    operms |= 01000;

  ret = (char *)xmalloc (16);
  snprintf (ret, 16, "%04o", operms);
  return ret;
}
warning: parse error {
  int operms;
  char *ret;

  operms = 0;

  if (m & S_IRUSR)
    operms |= 0400;
  if (m & S_IWUSR)
    operms |= 0200;
  if (m & S_IXUSR)
    operms |= 0100;

  if (m & S_IRGRP)
    operms |= 0040;
  if (m & S_IWGRP)
    operms |= 0020;
  if (m & S_IXGRP)
    operms |= 0010;

  if (m & S_IROTH)
    operms |= 0004;
  if (m & S_IWOTH)
    operms |= 0002;
  if (m & S_IXOTH)
    operms |= 0001;

  if (m & S_ISUID)
    operms |= 04000;
  if (m & S_ISGID)
    operms |= 02000;
  if (m & S_ISVTX)
    operms |= 01000;

  ret = (char *)xmalloc (16);
  snprintf (ret, 16, "%04o", operms);
  return ret;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\stat.c:126
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\stat.c:166
parsing error 
{
  char ubits[4], gbits[4], obits[4];	/* u=rwx,g=rwx,o=rwx */
  int i;
  char *ret;

  i = 0;
  if (m & S_IRUSR)
    ubits[i++] = 'r';
  if (m & S_IWUSR)
    ubits[i++] = 'w';
  if (m & S_IXUSR)
    ubits[i++] = 'x';
  ubits[i] = '\0';

  i = 0;
  if (m & S_IRGRP)
    gbits[i++] = 'r';
  if (m & S_IWGRP)
    gbits[i++] = 'w';
  if (m & S_IXGRP)
    gbits[i++] = 'x';
  gbits[i] = '\0';

  i = 0;
  if (m & S_IROTH)
    obits[i++] = 'r';
  if (m & S_IWOTH)
    obits[i++] = 'w';
  if (m & S_IXOTH)
    obits[i++] = 'x';
  obits[i] = '\0';

  if (m & S_ISUID)
    ubits[2] = (m & S_IXUSR) ? 's' : 'S';
  if (m & S_ISGID)
    gbits[2] = (m & S_IXGRP) ? 's' : 'S';
  if (m & S_ISVTX)
    obits[2] = (m & S_IXOTH) ? 't' : 'T';

  ret = (char *)xmalloc (32);
  snprintf (ret, 32, "u=%s,g=%s,o=%s", ubits, gbits, obits);
  return ret;
}
warning: parse error {
  char ubits[4], gbits[4], obits[4];	/* u=rwx,g=rwx,o=rwx */
  int i;
  char *ret;

  i = 0;
  if (m & S_IRUSR)
    ubits[i++] = 'r';
  if (m & S_IWUSR)
    ubits[i++] = 'w';
  if (m & S_IXUSR)
    ubits[i++] = 'x';
  ubits[i] = '\0';

  i = 0;
  if (m & S_IRGRP)
    gbits[i++] = 'r';
  if (m & S_IWGRP)
    gbits[i++] = 'w';
  if (m & S_IXGRP)
    gbits[i++] = 'x';
  gbits[i] = '\0';

  i = 0;
  if (m & S_IROTH)
    obits[i++] = 'r';
  if (m & S_IWOTH)
    obits[i++] = 'w';
  if (m & S_IXOTH)
    obits[i++] = 'x';
  obits[i] = '\0';

  if (m & S_ISUID)
    ubits[2] = (m & S_IXUSR) ? 's' : 'S';
  if (m & S_ISGID)
    gbits[2] = (m & S_IXGRP) ? 's' : 'S';
  if (m & S_ISVTX)
    obits[2] = (m & S_IXOTH) ? 't' : 'T';

  ret = (char *)xmalloc (32);
  snprintf (ret, 32, "u=%s,g=%s,o=%s", ubits, gbits, obits);
  return ret;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\stat.c:168
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\stat.c:213
parsing error 
{
  char *modestr, *m;

  modestr = m = (char *)xmalloc (8);
  if (S_ISBLK (mode))
    *m++ = 'b';
  if (S_ISCHR (mode))
    *m++ = 'c';
  if (S_ISDIR (mode))
    *m++ = 'd';
  if (S_ISREG(mode))
    *m++ = '-';
  if (S_ISFIFO(mode))
    *m++ = 'p';
  if (S_ISLNK(mode))
    *m++ = 'l';
  if (S_ISSOCK(mode))
    *m++ = 's';

#ifdef S_ISDOOR
  if (S_ISDOOR (mode))
    *m++ = 'D';
#endif
#ifdef S_ISWHT
  if (S_ISWHT(mode))
    *m++ = 'W';
#endif
#ifdef S_ISNWK
  if (S_ISNWK(mode))
    *m++ = 'n';
#endif
#ifdef S_ISMPC
  if (S_ISMPC (mode))
    *m++ = 'm';
#endif

  *m = '\0';
  return (modestr);
}
warning: parse error {
  char *modestr, *m;

  modestr = m = (char *)xmalloc (8);
  if (S_ISBLK (mode))
    *m++ = 'b';
  if (S_ISCHR (mode))
    *m++ = 'c';
  if (S_ISDIR (mode))
    *m++ = 'd';
  if (S_ISREG(mode))
    *m++ = '-';
  if (S_ISFIFO(mode))
    *m++ = 'p';
  if (S_ISLNK(mode))
    *m++ = 'l';
  if (S_ISSOCK(mode))
    *m++ = 's';

#ifdef S_ISDOOR
  if (S_ISDOOR (mode))
    *m++ = 'D';
#endif
#ifdef S_ISWHT
  if (S_ISWHT(mode))
    *m++ = 'W';
#endif
#ifdef S_ISNWK
  if (S_ISNWK(mode))
    *m++ = 'n';
#endif
#ifdef S_ISMPC
  if (S_ISMPC (mode))
    *m++ = 'm';
#endif

  *m = '\0';
  return (modestr);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\stat.c:215
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\stat.c:256
parsing error 
{
  char *tbuf, *ret;
  size_t tlen;

  tbuf = ctime (&t);
  tlen = strlen (tbuf);
  ret = savestring (tbuf);
  ret[tlen-1] = '\0';
  return ret;
}
warning: parse error {
  char *tbuf, *ret;
  size_t tlen;

  tbuf = ctime (&t);
  tlen = strlen (tbuf);
  ret = savestring (tbuf);
  ret[tlen-1] = '\0';
  return ret;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\stat.c:258
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\stat.c:270
parsing error 
{
  int temp;

  switch (which)
    {
    case ST_NAME:
      return savestring (fname);
    case ST_DEV:
      return itos (sp->st_dev);
    case ST_INO:
      return itos (sp->st_ino);
    case ST_MODE:
      return (statmode (sp->st_mode));
    case ST_NLINK:
      return itos (sp->st_nlink);
    case ST_UID:
      return itos (sp->st_uid);
    case ST_GID:
      return itos (sp->st_gid);
    case ST_RDEV:
      return itos (sp->st_rdev);
    case ST_SIZE:
      return itos (sp->st_size);
    case ST_ATIME:
      return ((flags & 2) ? stattime (sp->st_atime) : itos (sp->st_atime));
    case ST_MTIME:
      return ((flags & 2) ? stattime (sp->st_mtime) : itos (sp->st_mtime));
    case ST_CTIME:
      return ((flags & 2) ? stattime (sp->st_ctime) : itos (sp->st_ctime));
    case ST_BLKSIZE:
      return itos (sp->st_blksize);
    case ST_BLOCKS:
      return itos (sp->st_blocks);
    case ST_CHASELINK:
      return (statlink (fname, sp));
    case ST_PERMS:
      temp = sp->st_mode & (S_IRWXU|S_IRWXG|S_IRWXO|S_ISUID|S_ISGID);
      return (flags & 2) ? statperms (temp) : octalperms (temp);
    default:
      return savestring ("42");
    }
}
warning: parse error {
  int temp;

  switch (which)
    {
    case ST_NAME:
      return savestring (fname);
    case ST_DEV:
      return itos (sp->st_dev);
    case ST_INO:
      return itos (sp->st_ino);
    case ST_MODE:
      return (statmode (sp->st_mode));
    case ST_NLINK:
      return itos (sp->st_nlink);
    case ST_UID:
      return itos (sp->st_uid);
    case ST_GID:
      return itos (sp->st_gid);
    case ST_RDEV:
      return itos (sp->st_rdev);
    case ST_SIZE:
      return itos (sp->st_size);
    case ST_ATIME:
      return ((flags & 2) ? stattime (sp->st_atime) : itos (sp->st_atime));
    case ST_MTIME:
      return ((flags & 2) ? stattime (sp->st_mtime) : itos (sp->st_mtime));
    case ST_CTIME:
      return ((flags & 2) ? stattime (sp->st_ctime) : itos (sp->st_ctime));
    case ST_BLKSIZE:
      return itos (sp->st_blksize);
    case ST_BLOCKS:
      return itos (sp->st_blocks);
    case ST_CHASELINK:
      return (statlink (fname, sp));
    case ST_PERMS:
      temp = sp->st_mode & (S_IRWXU|S_IRWXG|S_IRWXO|S_ISUID|S_ISGID);
      return (flags & 2) ? statperms (temp) : octalperms (temp);
    default:
      return savestring ("42");
    }
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\stat.c:275
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\stat.c:319
parsing error 
{
  int i;
  char *key, *value;
  SHELL_VAR *v;

  for (i = 0; arraysubs[i]; i++)
    {
      key = savestring (arraysubs[i]);
      value = statval (i, fname, flags, sp);
      v = bind_assoc_variable (var, vname, key, value, ASS_FORCE);
    }
  return 0;
}
warning: parse error {
  int i;
  char *key, *value;
  SHELL_VAR *v;

  for (i = 0; arraysubs[i]; i++)
    {
      key = savestring (arraysubs[i]);
      value = statval (i, fname, flags, sp);
      v = bind_assoc_variable (var, vname, key, value, ASS_FORCE);
    }
  return 0;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\stat.c:325
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\stat.c:340
parsing error 
{
  int opt, flags;
  char *aname, *fname;
  struct stat st;
  SHELL_VAR *v;

  aname = "STAT";
  flags = 0;

  reset_internal_getopt ();
  while ((opt = internal_getopt (list, "A:Ll")) != -1)
    {
      switch (opt)
	{
	case 'A':
	  aname = list_optarg;
	  break;
	case 'L':
	  flags |= 1;		/* operate on links rather than resolving them */
	  break;
	case 'l':
	  flags |= 2;
	  break;
	CASE_HELPOPT;
	default:
	  builtin_usage ();
	  return (EX_USAGE);
	}
    }

  list = loptend;
  if (list == 0)
    {
      builtin_usage ();
      return (EX_USAGE);
    }

  fname = list->word->word;

  if (getstat (fname, flags, &st) < 0)
    {
      builtin_error ("%s: cannot stat: %s", fname, strerror (errno));
      return (EXECUTION_FAILURE);
    }

  unbind_variable (aname);
  v = make_new_assoc_variable (aname);
  if (v == 0)
    {
      builtin_error ("%s: cannot create variable", aname);
      return (EXECUTION_FAILURE);
    }
  if (loadstat (aname, v, fname, flags, &st) < 0)
    {
      builtin_error ("%s: cannot assign file status information", aname);
      unbind_variable (aname);
      return (EXECUTION_FAILURE);
    }

  return (EXECUTION_SUCCESS);
}
warning: parse error {
  int opt, flags;
  char *aname, *fname;
  struct stat st;
  SHELL_VAR *v;

  aname = "STAT";
  flags = 0;

  reset_internal_getopt ();
  while ((opt = internal_getopt (list, "A:Ll")) != -1)
    {
      switch (opt)
	{
	case 'A':
	  aname = list_optarg;
	  break;
	case 'L':
	  flags |= 1;		/* operate on links rather than resolving them */
	  break;
	case 'l':
	  flags |= 2;
	  break;
	CASE_HELPOPT;
	default:
	  builtin_usage ();
	  return (EX_USAGE);
	}
    }

  list = loptend;
  if (list == 0)
    {
      builtin_usage ();
      return (EX_USAGE);
    }

  fname = list->word->word;

  if (getstat (fname, flags, &st) < 0)
    {
      builtin_error ("%s: cannot stat: %s", fname, strerror (errno));
      return (EXECUTION_FAILURE);
    }

  unbind_variable (aname);
  v = make_new_assoc_variable (aname);
  if (v == 0)
    {
      builtin_error ("%s: cannot create variable", aname);
      return (EXECUTION_FAILURE);
    }
  if (loadstat (aname, v, fname, flags, &st) < 0)
    {
      builtin_error ("%s: cannot assign file status information", aname);
      unbind_variable (aname);
      return (EXECUTION_FAILURE);
    }

  return (EXECUTION_SUCCESS);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\stat.c:342
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\strftime.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashtypes.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\posixtime.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\shell.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\common.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\bashgetopt.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\strftime.c:40
parsing error 
{
  char *format, *tbuf;
  size_t tbsize, tsize;
  time_t secs;
  struct tm *t;
  int n;
  intmax_t i;

  if (no_options (list))
    return (EX_USAGE);
  list = loptend;

  if (list == 0)
    {
      builtin_usage ();
      return (EX_USAGE);
    }

  format = list->word->word;
  if (format == 0 || *format == 0)
    {
      printf ("\n");
      return (EXECUTION_SUCCESS);
    }

  list = list->next;

  if (list && list->word->word)
    {
      n = legal_number (list->word->word, &i);
      if (n == 0 || i < 0 || i != (time_t)i)
	{
	  sh_invalidnum (list->word->word);
	  return (EXECUTION_FAILURE);
	}
      else
        secs = i;
    }
  else
    secs = NOW;

  t = localtime (&secs);

  tbsize = strlen (format) * 4;
  tbuf = 0;

  /* Now try to figure out how big the buffer should really be.  strftime(3)
     will return the number of bytes placed in the buffer unless it's greater
     than MAXSIZE, in which case it returns 0. */
  for (n = 1; n <= 8; n++)
    {
      tbuf = xrealloc (tbuf, tbsize * n);
      tsize = strftime (tbuf, tbsize * n, format, t);
      if (tsize)
        break;
    }

  if (tsize)
    printf ("%s\n", tbuf);
  free (tbuf);

  return (EXECUTION_SUCCESS);
}
warning: parse error {
  char *format, *tbuf;
  size_t tbsize, tsize;
  time_t secs;
  struct tm *t;
  int n;
  intmax_t i;

  if (no_options (list))
    return (EX_USAGE);
  list = loptend;

  if (list == 0)
    {
      builtin_usage ();
      return (EX_USAGE);
    }

  format = list->word->word;
  if (format == 0 || *format == 0)
    {
      printf ("\n");
      return (EXECUTION_SUCCESS);
    }

  list = list->next;

  if (list && list->word->word)
    {
      n = legal_number (list->word->word, &i);
      if (n == 0 || i < 0 || i != (time_t)i)
	{
	  sh_invalidnum (list->word->word);
	  return (EXECUTION_FAILURE);
	}
      else
        secs = i;
    }
  else
    secs = NOW;

  t = localtime (&secs);

  tbsize = strlen (format) * 4;
  tbuf = 0;

  /* Now try to figure out how big the buffer should really be.  strftime(3)
     will return the number of bytes placed in the buffer unless it's greater
     than MAXSIZE, in which case it returns 0. */
  for (n = 1; n <= 8; n++)
    {
      tbuf = xrealloc (tbuf, tbsize * n);
      tsize = strftime (tbuf, tbsize * n, format, t);
      if (tsize)
        break;
    }

  if (tsize)
    printf ("%s\n", tbuf);
  free (tbuf);

  return (EXECUTION_SUCCESS);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\strftime.c:42
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\sync.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\shell.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\bashgetopt.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\sync.c:32
parsing error 
{
  sync();
  return (EXECUTION_SUCCESS);
}
warning: parse error {
  sync();
  return (EXECUTION_SUCCESS);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\sync.c:34
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\tee.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashtypes.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\posixstat.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\filecntl.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashansi.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\shell.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\bashgetopt.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\common.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\tee.c:64
parsing error 
{
  int opt, append, nointr, rval, fd, fflags;
  int n, nr, nw;
  FLIST *fl;
  char *buf, *bp;

  char *t;

  reset_internal_getopt ();
  append = nointr = 0;
  tee_flist = (FLIST *)NULL;
  while ((opt = internal_getopt (list, "ai")) != -1)
    {
      switch (opt)
	{
	case 'a':
	  append = 1;
	  break;
	case 'i':
	  nointr = 1;
	  break;
	CASE_HELPOPT;
	default:
	  builtin_usage ();
	  return (EX_USAGE);
	}
    }
  list = loptend;

  if (nointr == 0)
    interrupt_immediately++;

  buf = xmalloc (TEE_BUFSIZE);

  /* Initialize output file list. */
  fl = tee_flist = (FLIST *)xmalloc (sizeof(FLIST));
  tee_flist->fd = 1;
  tee_flist->fname = "stdout";
  tee_flist->next = (FLIST *)NULL;

  /* Add file arguments to list of output files. */
  fflags = append ? O_WRONLY|O_CREAT|O_APPEND : O_WRONLY|O_CREAT|O_TRUNC;
  for (rval = EXECUTION_SUCCESS; list; list = list->next)
    {
      fd = open (list->word->word, fflags, 0666);
      if (fd < 0)
        {
          builtin_error ("%s: cannot open: %s", list->word->word, strerror (errno));
          rval = EXECUTION_FAILURE;
        }
      else
        {
          fl->next = (FLIST *)xmalloc (sizeof(FLIST));
          fl->next->fd = fd;
          fl->next->fname = list->word->word;
          fl = fl->next;
          fl->next = (FLIST *)NULL;
        }
    }

  while ((nr = read(0, buf, TEE_BUFSIZE)) > 0)
    for (fl = tee_flist; fl; fl = fl->next)
      {
	n = nr;
	bp = buf;
	do
	  {
	    if ((nw = write (fl->fd, bp, n)) == -1)
	      {
		builtin_error ("%s: write error: %s", fl->fname, strerror (errno));
		rval = EXECUTION_FAILURE;
		break;
	      }
            bp += nw;
	  }
	while (n -= nw);
      }
  if (nr < 0)
    builtin_error ("read error: %s", strerror (errno));

  /* Deallocate resources -- this is a builtin command. */
  tee_flist = tee_flist->next;		/* skip bogus close of stdout */
  while (tee_flist)
    {
      fl = tee_flist;
      if (close (fl->fd) < 0)
	{
	  builtin_error ("%s: close_error: %s", fl->fname, strerror (errno));
	  rval = EXECUTION_FAILURE;
	}
      tee_flist = tee_flist->next;
      free (fl);
    }
  
  return (rval);
}
warning: parse error {
  int opt, append, nointr, rval, fd, fflags;
  int n, nr, nw;
  FLIST *fl;
  char *buf, *bp;

  char *t;

  reset_internal_getopt ();
  append = nointr = 0;
  tee_flist = (FLIST *)NULL;
  while ((opt = internal_getopt (list, "ai")) != -1)
    {
      switch (opt)
	{
	case 'a':
	  append = 1;
	  break;
	case 'i':
	  nointr = 1;
	  break;
	CASE_HELPOPT;
	default:
	  builtin_usage ();
	  return (EX_USAGE);
	}
    }
  list = loptend;

  if (nointr == 0)
    interrupt_immediately++;

  buf = xmalloc (TEE_BUFSIZE);

  /* Initialize output file list. */
  fl = tee_flist = (FLIST *)xmalloc (sizeof(FLIST));
  tee_flist->fd = 1;
  tee_flist->fname = "stdout";
  tee_flist->next = (FLIST *)NULL;

  /* Add file arguments to list of output files. */
  fflags = append ? O_WRONLY|O_CREAT|O_APPEND : O_WRONLY|O_CREAT|O_TRUNC;
  for (rval = EXECUTION_SUCCESS; list; list = list->next)
    {
      fd = open (list->word->word, fflags, 0666);
      if (fd < 0)
        {
          builtin_error ("%s: cannot open: %s", list->word->word, strerror (errno));
          rval = EXECUTION_FAILURE;
        }
      else
        {
          fl->next = (FLIST *)xmalloc (sizeof(FLIST));
          fl->next->fd = fd;
          fl->next->fname = list->word->word;
          fl = fl->next;
          fl->next = (FLIST *)NULL;
        }
    }

  while ((nr = read(0, buf, TEE_BUFSIZE)) > 0)
    for (fl = tee_flist; fl; fl = fl->next)
      {
	n = nr;
	bp = buf;
	do
	  {
	    if ((nw = write (fl->fd, bp, n)) == -1)
	      {
		builtin_error ("%s: write error: %s", fl->fname, strerror (errno));
		rval = EXECUTION_FAILURE;
		break;
	      }
            bp += nw;
	  }
	while (n -= nw);
      }
  if (nr < 0)
    builtin_error ("read error: %s", strerror (errno));

  /* Deallocate resources -- this is a builtin command. */
  tee_flist = tee_flist->next;		/* skip bogus close of stdout */
  while (tee_flist)
    {
      fl = tee_flist;
      if (close (fl->fd) < 0)
	{
	  builtin_error ("%s: close_error: %s", fl->fname, strerror (errno));
	  rval = EXECUTION_FAILURE;
	}
      tee_flist = tee_flist->next;
      free (fl);
    }
  
  return (rval);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\tee.c:66
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\template.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashansi.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\loadables.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\template.c:23
parsing error 
{
  int opt, rval;

  rval = EXECUTION_SUCCESS;
  reset_internal_getopt ();
  while ((opt = internal_getopt (list, "")) != -1)
    {
      switch (opt)
	{
	CASE_HELPOPT;
	default:
	  builtin_usage ();
	  return (EX_USAGE);
	}
    }
  list = loptend;

  return (rval);
}
warning: parse error {
  int opt, rval;

  rval = EXECUTION_SUCCESS;
  reset_internal_getopt ();
  while ((opt = internal_getopt (list, "")) != -1)
    {
      switch (opt)
	{
	CASE_HELPOPT;
	default:
	  builtin_usage ();
	  return (EX_USAGE);
	}
    }
  list = loptend;

  return (rval);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\template.c:25
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\template.c:48
parsing error 
{
  return (1);
}
warning: parse error {
  return (1);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\template.c:50
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\template.c:56
parsing error 
{
}
warning: parse error {
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\template.c:58
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\truefalse.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashtypes.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\shell.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\common.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\truefalse.c:29
parsing error 
{
  return EXECUTION_SUCCESS;
}
warning: parse error {
  return EXECUTION_SUCCESS;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\truefalse.c:31
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\truefalse.c:36
parsing error 
{
  return EXECUTION_FAILURE;
}
warning: parse error {
  return EXECUTION_FAILURE;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\truefalse.c:38
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\tty.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\shell.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\bashgetopt.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\common.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\tty.c:34
parsing error 
{
  int opt, sflag;
  char *t;

  reset_internal_getopt ();
  sflag = 0;
  while ((opt = internal_getopt (list, "s")) != -1)
    {
      switch (opt)
	{
	case 's':
	  sflag = 1;
	  break;
	CASE_HELPOPT;
	default:
	  builtin_usage ();
	  return (EX_USAGE);
	}
    }
  list = loptend;

  t = ttyname (0);
  if (sflag == 0)
    puts (t ? t : "not a tty");
  return (t ? EXECUTION_SUCCESS : EXECUTION_FAILURE);
}
warning: parse error {
  int opt, sflag;
  char *t;

  reset_internal_getopt ();
  sflag = 0;
  while ((opt = internal_getopt (list, "s")) != -1)
    {
      switch (opt)
	{
	case 's':
	  sflag = 1;
	  break;
	CASE_HELPOPT;
	default:
	  builtin_usage ();
	  return (EX_USAGE);
	}
    }
  list = loptend;

  t = ttyname (0);
  if (sflag == 0)
    puts (t ? t : "not a tty");
  return (t ? EXECUTION_SUCCESS : EXECUTION_FAILURE);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\tty.c:36
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\uname.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashtypes.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\shell.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\bashgetopt.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\common.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\uname.c:67
parsing error 
{
  int opt, r;
  struct utsname uninfo;

  uname_flags = 0;
  reset_internal_getopt ();
  while ((opt = internal_getopt (list, "amnprsv")) != -1)
    {
      switch (opt)
	{
	case 'a':
	  uname_flags |= FLAG_ALL;
	  break;
	case 'm':
	case 'p':
	  uname_flags |= FLAG_MACHINE;
	  break;
	case 'n':
	  uname_flags |= FLAG_NODENAME;
	  break;
	case 'r':
	  uname_flags |= FLAG_RELEASE;
	  break;
	case 's':
	  uname_flags |= FLAG_SYSNAME;
	  break;
	case 'v':
	  uname_flags |= FLAG_VERSION;
	  break;
	CASE_HELPOPT;
	default:
	  builtin_usage ();
	  return (EX_USAGE);
	}
    }
  list = loptend;

  if (list)
    {
      builtin_usage ();
      return (EX_USAGE);
    }

  if (uname_flags == 0)
    uname_flags = FLAG_SYSNAME;

  /* Only ancient systems will not have uname(2). */
#ifdef HAVE_UNAME
  if (uname (&uninfo) < 0)
    {
      builtin_error ("cannot get system name: %s", strerror (errno));
      return (EXECUTION_FAILURE);
    }
#else
  builtin_error ("cannot get system information: uname(2) not available");
  return (EXECUTION_FAILURE);
#endif

  uprint (FLAG_SYSNAME, uninfo.sysname);
  uprint (FLAG_NODENAME, uninfo.nodename);
  uprint (FLAG_RELEASE, uninfo.release);
  uprint (FLAG_VERSION, uninfo.version);
  uprint (FLAG_MACHINE, uninfo.machine);

  return (EXECUTION_SUCCESS);
}
warning: parse error {
  int opt, r;
  struct utsname uninfo;

  uname_flags = 0;
  reset_internal_getopt ();
  while ((opt = internal_getopt (list, "amnprsv")) != -1)
    {
      switch (opt)
	{
	case 'a':
	  uname_flags |= FLAG_ALL;
	  break;
	case 'm':
	case 'p':
	  uname_flags |= FLAG_MACHINE;
	  break;
	case 'n':
	  uname_flags |= FLAG_NODENAME;
	  break;
	case 'r':
	  uname_flags |= FLAG_RELEASE;
	  break;
	case 's':
	  uname_flags |= FLAG_SYSNAME;
	  break;
	case 'v':
	  uname_flags |= FLAG_VERSION;
	  break;
	CASE_HELPOPT;
	default:
	  builtin_usage ();
	  return (EX_USAGE);
	}
    }
  list = loptend;

  if (list)
    {
      builtin_usage ();
      return (EX_USAGE);
    }

  if (uname_flags == 0)
    uname_flags = FLAG_SYSNAME;

  /* Only ancient systems will not have uname(2). */
#ifdef HAVE_UNAME
  if (uname (&uninfo) < 0)
    {
      builtin_error ("cannot get system name: %s", strerror (errno));
      return (EXECUTION_FAILURE);
    }
#else
  builtin_error ("cannot get system information: uname(2) not available");
  return (EXECUTION_FAILURE);
#endif

  uprint (FLAG_SYSNAME, uninfo.sysname);
  uprint (FLAG_NODENAME, uninfo.nodename);
  uprint (FLAG_RELEASE, uninfo.release);
  uprint (FLAG_VERSION, uninfo.version);
  uprint (FLAG_MACHINE, uninfo.machine);

  return (EXECUTION_SUCCESS);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\uname.c:69
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\uname.c:137
parsing error 
{
  if (uname_flags & flag)
    {
      uname_flags &= ~flag;
      printf ("%s%c", info, uname_flags ? ' ' : '\n');
    }
}
warning: parse error {
  if (uname_flags & flag)
    {
      uname_flags &= ~flag;
      printf ("%s%c", info, uname_flags ? ' ' : '\n');
    }
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\uname.c:140
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\unlink.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\shell.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\common.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\unlink.c:42
parsing error 
{
  if (list == 0)
    {
      builtin_usage ();
      return (EX_USAGE);
    }

  if (unlink (list->word->word) != 0)
    {
      builtin_error ("%s: cannot unlink: %s", list->word->word, strerror (errno));
      return (EXECUTION_FAILURE);
    }

  return (EXECUTION_SUCCESS);
}
warning: parse error {
  if (list == 0)
    {
      builtin_usage ();
      return (EX_USAGE);
    }

  if (unlink (list->word->word) != 0)
    {
      builtin_error ("%s: cannot unlink: %s", list->word->word, strerror (errno));
      return (EXECUTION_FAILURE);
    }

  return (EXECUTION_SUCCESS);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\unlink.c:44
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\whoami.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\shell.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\bashgetopt.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\common.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\whoami.c:32
parsing error 
{
  int opt;

  reset_internal_getopt ();
  while ((opt = internal_getopt (list, "")) != -1)
    {
      switch (opt)
	{
	CASE_HELPOPT;
	default:
	  builtin_usage ();
	  return (EX_USAGE);
	}
    }
  list = loptend;
  if (list)
    {
      builtin_usage ();
      return (EX_USAGE);
    }

  if (current_user.user_name == 0)
    get_current_user_info ();
  printf ("%s\n", current_user.user_name);
  return (EXECUTION_SUCCESS);
}
warning: parse error {
  int opt;

  reset_internal_getopt ();
  while ((opt = internal_getopt (list, "")) != -1)
    {
      switch (opt)
	{
	CASE_HELPOPT;
	default:
	  builtin_usage ();
	  return (EX_USAGE);
	}
    }
  list = loptend;
  if (list)
    {
      builtin_usage ();
      return (EX_USAGE);
    }

  if (current_user.user_name == 0)
    get_current_user_info ();
  printf ("%s\n", current_user.user_name);
  return (EXECUTION_SUCCESS);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\examples\loadables\whoami.c:34
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\execute_cmd.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\chartypes.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashtypes.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\filecntl.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\posixstat.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\posixtime.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashansi.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashintl.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\memalloc.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\shell.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\y.tab.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\parser.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\flags.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\hashlib.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\jobs.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\execute_cmd.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\findcmd.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\redir.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\trap.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\pathexp.h...skip
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\hashcmd.h...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\stdc.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\hashlib.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\common.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\getopt.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\glob\strmatch.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\tilde\tilde.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\execute_cmd.c:304
parsing error 
{
  struct fd_bitmap *ret;

  ret = (struct fd_bitmap *)xmalloc (sizeof (struct fd_bitmap));

  ret->size = size;

  if (size)
    {
      ret->bitmap = (char *)xmalloc (size);
      memset (ret->bitmap, '\0', size);
    }
  else
    ret->bitmap = (char *)NULL;
  return (ret);
}
warning: parse error {
  struct fd_bitmap *ret;

  ret = (struct fd_bitmap *)xmalloc (sizeof (struct fd_bitmap));

  ret->size = size;

  if (size)
    {
      ret->bitmap = (char *)xmalloc (size);
      memset (ret->bitmap, '\0', size);
    }
  else
    ret->bitmap = (char *)NULL;
  return (ret);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\execute_cmd.c:306
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\execute_cmd.c:324
parsing error 
{
  FREE (fdbp->bitmap);
  free (fdbp);
}
warning: parse error {
  FREE (fdbp->bitmap);
  free (fdbp);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\execute_cmd.c:326
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\execute_cmd.c:332
parsing error 
{
  register int i;

  if (fdbp)
    {
      for (i = 0; i < fdbp->size; i++)
	if (fdbp->bitmap[i])
	  {
	    close (i);
	    fdbp->bitmap[i] = 0;
	  }
    }
}
warning: parse error {
  register int i;

  if (fdbp)
    {
      for (i = 0; i < fdbp->size; i++)
	if (fdbp->bitmap[i])
	  {
	    close (i);
	    fdbp->bitmap[i] = 0;
	  }
    }
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\execute_cmd.c:334
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\execute_cmd.c:383
parsing error 
{
  struct fd_bitmap *bitmap;
  int result;

  current_fds_to_close = (struct fd_bitmap *)NULL;
  bitmap = new_fd_bitmap (FD_BITMAP_DEFAULT_SIZE);
  begin_unwind_frame ("execute-command");
  add_unwind_protect (dispose_fd_bitmap, (char *)bitmap);

  /* Just do the command, but not asynchronously. */
  result = execute_command_internal (command, 0, NO_PIPE, NO_PIPE, bitmap);

  dispose_fd_bitmap (bitmap);
  discard_unwind_frame ("execute-command");

#if defined (PROCESS_SUBSTITUTION)
  /* don't unlink fifos if we're in a shell function; wait until the function
     returns. */
  if (variable_context == 0 && executing_list == 0)
    unlink_fifo_list ();
#endif /* PROCESS_SUBSTITUTION */

  QUIT;
  return (result);
}
warning: parse error {
  struct fd_bitmap *bitmap;
  int result;

  current_fds_to_close = (struct fd_bitmap *)NULL;
  bitmap = new_fd_bitmap (FD_BITMAP_DEFAULT_SIZE);
  begin_unwind_frame ("execute-command");
  add_unwind_protect (dispose_fd_bitmap, (char *)bitmap);

  /* Just do the command, but not asynchronously. */
  result = execute_command_internal (command, 0, NO_PIPE, NO_PIPE, bitmap);

  dispose_fd_bitmap (bitmap);
  discard_unwind_frame ("execute-command");

#if defined (PROCESS_SUBSTITUTION)
  /* don't unlink fifos if we're in a shell function; wait until the function
     returns. */
  if (variable_context == 0 && executing_list == 0)
    unlink_fifo_list ();
#endif /* PROCESS_SUBSTITUTION */

  QUIT;
  return (result);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\execute_cmd.c:385
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\execute_cmd.c:413
parsing error 
{
  switch (type)
    {
#if defined (ARITH_FOR_COMMAND)
    case cm_arith_for:
#endif
#if defined (SELECT_COMMAND)
    case cm_select:
#endif
#if defined (DPAREN_ARITHMETIC)
    case cm_arith:
#endif
#if defined (COND_COMMAND)
    case cm_cond:
#endif
    case cm_case:
    case cm_while:
    case cm_until:
    case cm_if:
    case cm_for:
    case cm_group:
    case cm_function_def:
      return (1);

    default:
      return (0);
    }
}
warning: parse error {
  switch (type)
    {
#if defined (ARITH_FOR_COMMAND)
    case cm_arith_for:
#endif
#if defined (SELECT_COMMAND)
    case cm_select:
#endif
#if defined (DPAREN_ARITHMETIC)
    case cm_arith:
#endif
#if defined (COND_COMMAND)
    case cm_cond:
#endif
    case cm_case:
    case cm_while:
    case cm_until:
    case cm_if:
    case cm_for:
    case cm_group:
    case cm_function_def:
      return (1);

    default:
      return (0);
    }
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\execute_cmd.c:415
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\execute_cmd.c:447
parsing error 
{
  do_redirections (list, RX_ACTIVE);
  dispose_redirects (list);
}
warning: parse error {
  do_redirections (list, RX_ACTIVE);
  dispose_redirects (list);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\execute_cmd.c:449
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\execute_cmd.c:556
parsing error 
{
  int exec_result, user_subshell, invert, ignore_return, was_error_trap, fork_flags;
  REDIRECT *my_undo_list, *exec_undo_list;
  char *tcmd;
  volatile int save_line_number;
#if defined (PROCESS_SUBSTITUTION)
  volatile int ofifo, nfifo, osize, saved_fifo;
  volatile void *ofifo_list;
#endif

  if (breaking || continuing)
    return (last_command_exit_value);
  if (command == 0 || read_but_dont_execute)
    return (EXECUTION_SUCCESS);

  QUIT;
  run_pending_traps ();

#if 0
  if (running_trap == 0)
#endif
    currently_executing_command = command;

  invert = (command->flags & CMD_INVERT_RETURN) != 0;

  /* If we're inverting the return value and `set -e' has been executed,
     we don't want a failing command to inadvertently cause the shell
     to exit. */
  if (exit_immediately_on_error && invert)	/* XXX */
    command->flags |= CMD_IGNORE_RETURN;	/* XXX */

  exec_result = EXECUTION_SUCCESS;

  /* If a command was being explicitly run in a subshell, or if it is
     a shell control-structure, and it has a pipe, then we do the command
     in a subshell. */
  if (command->type == cm_subshell && (command->flags & CMD_NO_FORK))
    return (execute_in_subshell (command, asynchronous, pipe_in, pipe_out, fds_to_close));

#if defined (COPROCESS_SUPPORT)
  if (command->type == cm_coproc)
    return (last_command_exit_value = execute_coproc (command, pipe_in, pipe_out, fds_to_close));
#endif

  user_subshell = command->type == cm_subshell || ((command->flags & CMD_WANT_SUBSHELL) != 0);

#if defined (TIME_BEFORE_SUBSHELL)
  if ((command->flags & CMD_TIME_PIPELINE) && user_subshell && asynchronous == 0)
    {
      command->flags |= CMD_FORCE_SUBSHELL;
      exec_result = time_command (command, asynchronous, pipe_in, pipe_out, fds_to_close);
      currently_executing_command = (COMMAND *)NULL;
      return (exec_result);
    }
#endif

  if (command->type == cm_subshell ||
      (command->flags & (CMD_WANT_SUBSHELL|CMD_FORCE_SUBSHELL)) ||
      (shell_control_structure (command->type) &&
       (pipe_out != NO_PIPE || pipe_in != NO_PIPE || asynchronous)))
    {
      pid_t paren_pid;
      int s;
      char *p;

      /* Fork a subshell, turn off the subshell bit, turn off job
	 control and call execute_command () on the command again. */
      save_line_number = line_number;
      if (command->type == cm_subshell)
	line_number_for_err_trap = line_number = command->value.Subshell->line;	/* XXX - save value? */
	/* Otherwise we defer setting line_number */
      tcmd = make_command_string (command);
      fork_flags = asynchronous ? FORK_ASYNC : 0;
      paren_pid = make_child (p = savestring (tcmd), fork_flags);

      if (user_subshell && signal_is_trapped (ERROR_TRAP) && 
	  signal_in_progress (DEBUG_TRAP) == 0 && running_trap == 0)
	{
	  FREE (the_printed_command_except_trap);
	  the_printed_command_except_trap = savestring (the_printed_command);
	}

      if (paren_pid == 0)
        {
#if defined (JOB_CONTROL)
	  FREE (p);		/* child doesn't use pointer */
#endif
	  /* We want to run the exit trap for forced {} subshells, and we
	     want to note this before execute_in_subshell modifies the
	     COMMAND struct.  Need to keep in mind that execute_in_subshell
	     runs the exit trap for () subshells itself. */
	  /* This handles { command; } & */
	  s = user_subshell == 0 && command->type == cm_group && pipe_in == NO_PIPE && pipe_out == NO_PIPE && asynchronous;
	  /* run exit trap for : | { ...; } and { ...; } | : */
	  /* run exit trap for : | ( ...; ) and ( ...; ) | : */
	  s += user_subshell == 0 && command->type == cm_group && (pipe_in != NO_PIPE || pipe_out != NO_PIPE) && asynchronous == 0;

	  last_command_exit_value = execute_in_subshell (command, asynchronous, pipe_in, pipe_out, fds_to_close);
	  if (s)
	    subshell_exit (last_command_exit_value);
	  else
	    sh_exit (last_command_exit_value);
	  /* NOTREACHED */
        }
      else
	{
	  close_pipes (pipe_in, pipe_out);

#if defined (PROCESS_SUBSTITUTION) && defined (HAVE_DEV_FD)
	  if (variable_context == 0)	/* wait until shell function completes */
	    unlink_fifo_list ();
#endif
	  /* If we are part of a pipeline, and not the end of the pipeline,
	     then we should simply return and let the last command in the
	     pipe be waited for.  If we are not in a pipeline, or are the
	     last command in the pipeline, then we wait for the subshell
	     and return its exit status as usual. */
	  if (pipe_out != NO_PIPE)
	    return (EXECUTION_SUCCESS);

	  stop_pipeline (asynchronous, (COMMAND *)NULL);

	  line_number = save_line_number;

	  if (asynchronous == 0)
	    {
	      was_error_trap = signal_is_trapped (ERROR_TRAP) && signal_is_ignored (ERROR_TRAP) == 0;
	      invert = (command->flags & CMD_INVERT_RETURN) != 0;
	      ignore_return = (command->flags & CMD_IGNORE_RETURN) != 0;

	      exec_result = wait_for (paren_pid, 0);

	      /* If we have to, invert the return value. */
	      if (invert)
		exec_result = ((exec_result == EXECUTION_SUCCESS)
				? EXECUTION_FAILURE
				: EXECUTION_SUCCESS);

	      last_command_exit_value = exec_result;
	      if (user_subshell && was_error_trap && ignore_return == 0 && invert == 0 && exec_result != EXECUTION_SUCCESS)
		{
		  save_line_number = line_number;
		  line_number = line_number_for_err_trap;
		  run_error_trap ();
		  line_number = save_line_number;
		}

	      if (user_subshell && ignore_return == 0 && invert == 0 && exit_immediately_on_error && exec_result != EXECUTION_SUCCESS)
		{
		  run_pending_traps ();
		  jump_to_top_level (ERREXIT);
		}

	      return (last_command_exit_value);
	    }
	  else
	    {
	      DESCRIBE_PID (paren_pid);

	      run_pending_traps ();

	      /* Posix 2013 2.9.3.1: "the exit status of an asynchronous list
		 shall be zero." */
	      last_command_exit_value = 0;
	      return (EXECUTION_SUCCESS);
	    }
	}
    }

#if defined (COMMAND_TIMING)
  if (command->flags & CMD_TIME_PIPELINE)
    {
      if (asynchronous)
	{
	  command->flags |= CMD_FORCE_SUBSHELL;
	  exec_result = execute_command_internal (command, 1, pipe_in, pipe_out, fds_to_close);
	}
      else
	{
	  exec_result = time_command (command, asynchronous, pipe_in, pipe_out, fds_to_close);
#if 0
	  if (running_trap == 0)
#endif
	    currently_executing_command = (COMMAND *)NULL;
	}
      return (exec_result);
    }
#endif /* COMMAND_TIMING */

  if (shell_control_structure (command->type) && command->redirects)
    stdin_redir = stdin_redirects (command->redirects);

#if defined (PROCESS_SUBSTITUTION)
#  if !defined (HAVE_DEV_FD)
  reap_procsubs ();
#  endif

  /* XXX - also if sourcelevel != 0? */
  if (variable_context != 0 || executing_list)
    {
      ofifo = num_fifos ();
      ofifo_list = copy_fifo_list ((int *)&osize);
      begin_unwind_frame ("internal_fifos");
      if (ofifo_list)
	add_unwind_protect (xfree, ofifo_list);
      saved_fifo = 1;
    }
  else
    saved_fifo = 0;
#endif

  /* Handle WHILE FOR CASE etc. with redirections.  (Also '&' input
     redirection.)  */
  was_error_trap = signal_is_trapped (ERROR_TRAP) && signal_is_ignored (ERROR_TRAP) == 0;
  ignore_return = (command->flags & CMD_IGNORE_RETURN) != 0;

  if (do_redirections (command->redirects, RX_ACTIVE|RX_UNDOABLE) != 0)
    {
      undo_partial_redirects ();
      dispose_exec_redirects ();
#if defined (PROCESS_SUBSTITUTION)
      if (saved_fifo)
	{
	  free ((void *)ofifo_list);
          discard_unwind_frame ("internal_fifos");
	}
#endif

      /* Handle redirection error as command failure if errexit set. */
      last_command_exit_value = EXECUTION_FAILURE;
      if (ignore_return == 0 && invert == 0 && pipe_in == NO_PIPE && pipe_out == NO_PIPE)
	{
	  if (was_error_trap)
	    {
	      save_line_number = line_number;
	      line_number = line_number_for_err_trap;
	      run_error_trap ();
	      line_number = save_line_number;
	    }
	  if (exit_immediately_on_error)
	    {	  
	      run_pending_traps ();
	      jump_to_top_level (ERREXIT);
	    }
	}
      return (last_command_exit_value);
    }

  my_undo_list = redirection_undo_list;
  redirection_undo_list = (REDIRECT *)NULL;

  exec_undo_list = exec_redirection_undo_list;
  exec_redirection_undo_list = (REDIRECT *)NULL;

  if (my_undo_list || exec_undo_list)
    begin_unwind_frame ("loop_redirections");

  if (my_undo_list)
    add_unwind_protect ((Function *)cleanup_redirects, my_undo_list);

  if (exec_undo_list)
    add_unwind_protect ((Function *)dispose_redirects, exec_undo_list);

  QUIT;

  switch (command->type)
    {
    case cm_simple:
      {
	save_line_number = line_number;
	/* We can't rely on variables retaining their values across a
	   call to execute_simple_command if a longjmp occurs as the
	   result of a `return' builtin.  This is true for sure with gcc. */
#if defined (RECYCLES_PIDS)
	last_made_pid = NO_PID;
#endif
	was_error_trap = signal_is_trapped (ERROR_TRAP) && signal_is_ignored (ERROR_TRAP) == 0;

	if (ignore_return && command->value.Simple)
	  command->value.Simple->flags |= CMD_IGNORE_RETURN;
	if (command->flags & CMD_STDIN_REDIR)
	  command->value.Simple->flags |= CMD_STDIN_REDIR;

	line_number_for_err_trap = line_number = command->value.Simple->line;
	exec_result =
	  execute_simple_command (command->value.Simple, pipe_in, pipe_out,
				  asynchronous, fds_to_close);
	line_number = save_line_number;

	/* The temporary environment should be used for only the simple
	   command immediately following its definition. */
	dispose_used_env_vars ();

#if (defined (ultrix) && defined (mips)) || defined (C_ALLOCA)
	/* Reclaim memory allocated with alloca () on machines which
	   may be using the alloca emulation code. */
	(void) alloca (0);
#endif /* (ultrix && mips) || C_ALLOCA */

	/* If we forked to do the command, then we must wait_for ()
	   the child. */

	/* XXX - this is something to watch out for if there are problems
	   when the shell is compiled without job control.  Don't worry about
	   whether or not last_made_pid == last_pid; already_making_children
	   tells us whether or not there are unwaited-for children to wait
	   for and reap. */
	if (already_making_children && pipe_out == NO_PIPE)
	  {
	    stop_pipeline (asynchronous, (COMMAND *)NULL);

	    if (asynchronous)
	      {
		DESCRIBE_PID (last_made_pid);
		exec_result = EXECUTION_SUCCESS;
		invert = 0;		/* async commands always succeed */
	      }
	    else
#if !defined (JOB_CONTROL)
	      /* Do not wait for asynchronous processes started from
		 startup files. */
	    if (last_made_pid != NO_PID && last_made_pid != last_asynchronous_pid)
#else
	    if (last_made_pid != NO_PID)
#endif
	    /* When executing a shell function that executes other
	       commands, this causes the last simple command in
	       the function to be waited for twice.  This also causes
	       subshells forked to execute builtin commands (e.g., in
	       pipelines) to be waited for twice. */
	      exec_result = wait_for (last_made_pid, 0);
	  }
      }

      /* 2009/02/13 -- pipeline failure is processed elsewhere.  This handles
	 only the failure of a simple command. We don't want to run the error
	 trap if the command run by the `command' builtin fails; we want to
	 defer that until the command builtin itself returns failure. */
      /* 2020/07/14 -- this changes with how the command builtin is handled */ 
      if (was_error_trap && ignore_return == 0 && invert == 0 &&
	    pipe_in == NO_PIPE && pipe_out == NO_PIPE &&
	    (command->value.Simple->flags & CMD_COMMAND_BUILTIN) == 0 &&
	    exec_result != EXECUTION_SUCCESS)
	{
	  last_command_exit_value = exec_result;
	  line_number = line_number_for_err_trap;
	  run_error_trap ();
	  line_number = save_line_number;
	}

      if (ignore_return == 0 && invert == 0 &&
	  ((posixly_correct && interactive == 0 && special_builtin_failed) ||
	   (exit_immediately_on_error && pipe_in == NO_PIPE && pipe_out == NO_PIPE && exec_result != EXECUTION_SUCCESS)))
	{
	  last_command_exit_value = exec_result;
	  run_pending_traps ();

	  /* Undo redirections before running exit trap on the way out of
	     set -e. Report by Mark Farrell 5/19/2014 */
	  if (exit_immediately_on_error && signal_is_trapped (0) &&
		unwind_protect_tag_on_stack ("saved-redirects"))
	    run_unwind_frame ("saved-redirects");

	  jump_to_top_level (ERREXIT);
	}

      break;

    case cm_for:
      if (ignore_return)
	command->value.For->flags |= CMD_IGNORE_RETURN;
      exec_result = execute_for_command (command->value.For);
      break;

#if defined (ARITH_FOR_COMMAND)
    case cm_arith_for:
      if (ignore_return)
	command->value.ArithFor->flags |= CMD_IGNORE_RETURN;
      exec_result = execute_arith_for_command (command->value.ArithFor);
      break;
#endif

#if defined (SELECT_COMMAND)
    case cm_select:
      if (ignore_return)
	command->value.Select->flags |= CMD_IGNORE_RETURN;
      exec_result = execute_select_command (command->value.Select);
      break;
#endif

    case cm_case:
      if (ignore_return)
	command->value.Case->flags |= CMD_IGNORE_RETURN;
      exec_result = execute_case_command (command->value.Case);
      break;

    case cm_while:
      if (ignore_return)
	command->value.While->flags |= CMD_IGNORE_RETURN;
      exec_result = execute_while_command (command->value.While);
      break;

    case cm_until:
      if (ignore_return)
	command->value.While->flags |= CMD_IGNORE_RETURN;
      exec_result = execute_until_command (command->value.While);
      break;

    case cm_if:
      if (ignore_return)
	command->value.If->flags |= CMD_IGNORE_RETURN;
      exec_result = execute_if_command (command->value.If);
      break;

    case cm_group:

      /* This code can be executed from either of two paths: an explicit
	 '{}' command, or via a function call.  If we are executed via a
	 function call, we have already taken care of the function being
	 executed in the background (down there in execute_simple_command ()),
	 and this command should *not* be marked as asynchronous.  If we
	 are executing a regular '{}' group command, and asynchronous == 1,
	 we must want to execute the whole command in the background, so we
	 need a subshell, and we want the stuff executed in that subshell
	 (this group command) to be executed in the foreground of that
	 subshell (i.e. there will not be *another* subshell forked).

	 What we do is to force a subshell if asynchronous, and then call
	 execute_command_internal again with asynchronous still set to 1,
	 but with the original group command, so the printed command will
	 look right.

	 The code above that handles forking off subshells will note that
	 both subshell and async are on, and turn off async in the child
	 after forking the subshell (but leave async set in the parent, so
	 the normal call to describe_pid is made).  This turning off
	 async is *crucial*; if it is not done, this will fall into an
	 infinite loop of executions through this spot in subshell after
	 subshell until the process limit is exhausted. */

      if (asynchronous)
	{
	  command->flags |= CMD_FORCE_SUBSHELL;
	  exec_result =
	    execute_command_internal (command, 1, pipe_in, pipe_out,
				      fds_to_close);
	}
      else
	{
	  if (ignore_return && command->value.Group->command)
	    command->value.Group->command->flags |= CMD_IGNORE_RETURN;
	  exec_result =
	    execute_command_internal (command->value.Group->command,
				      asynchronous, pipe_in, pipe_out,
				      fds_to_close);
	}
      break;

    case cm_connection:
      exec_result = execute_connection (command, asynchronous,
					pipe_in, pipe_out, fds_to_close);
      if (asynchronous)
	invert = 0;		/* XXX */

      break;

#if defined (DPAREN_ARITHMETIC)
    case cm_arith:
#endif
#if defined (COND_COMMAND)
    case cm_cond:
#endif
    case cm_function_def:
      was_error_trap = signal_is_trapped (ERROR_TRAP) && signal_is_ignored (ERROR_TRAP) == 0;
#if defined (DPAREN_ARITHMETIC)
      if (ignore_return && command->type == cm_arith)
	command->value.Arith->flags |= CMD_IGNORE_RETURN;
#endif
#if defined (COND_COMMAND)
      if (ignore_return && command->type == cm_cond)
	command->value.Cond->flags |= CMD_IGNORE_RETURN;
#endif

      line_number_for_err_trap = save_line_number = line_number;
#if defined (DPAREN_ARITHMETIC)
      if (command->type == cm_arith)
	exec_result = execute_arith_command (command->value.Arith);
      else
#endif
#if defined (COND_COMMAND)
      if (command->type == cm_cond)
	exec_result = execute_cond_command (command->value.Cond);
      else
#endif
      if (command->type == cm_function_def)
	exec_result = execute_intern_function (command->value.Function_def->name,
					       command->value.Function_def);
      line_number = save_line_number;

      if (was_error_trap && ignore_return == 0 && invert == 0 && exec_result != EXECUTION_SUCCESS)
	{
	  last_command_exit_value = exec_result;
	  save_line_number = line_number;
	  line_number = line_number_for_err_trap;
	  run_error_trap ();
	  line_number = save_line_number;
	}

      if (ignore_return == 0 && invert == 0 && exit_immediately_on_error && exec_result != EXECUTION_SUCCESS)
	{
	  last_command_exit_value = exec_result;
	  run_pending_traps ();
	  jump_to_top_level (ERREXIT);
	}

      break;

    default:
      command_error ("execute_command", CMDERR_BADTYPE, command->type, 0);
    }

  if (my_undo_list)
    cleanup_redirects (my_undo_list);

  if (exec_undo_list)
    dispose_redirects (exec_undo_list);

  if (my_undo_list || exec_undo_list)
    discard_unwind_frame ("loop_redirections");

#if defined (PROCESS_SUBSTITUTION)
  if (saved_fifo)
    {
      nfifo = num_fifos ();
      if (nfifo > ofifo)
	close_new_fifos ((void *)ofifo_list, osize);
      free ((void *)ofifo_list);
      discard_unwind_frame ("internal_fifos");
    }
#endif

  /* Invert the return value if we have to */
  if (invert)
    exec_result = (exec_result == EXECUTION_SUCCESS)
		    ? EXECUTION_FAILURE
		    : EXECUTION_SUCCESS;

#if defined (DPAREN_ARITHMETIC) || defined (COND_COMMAND)
  /* This is where we set PIPESTATUS from the exit status of the appropriate
     compound commands (the ones that look enough like simple commands to
     cause confusion).  We might be able to optimize by not doing this if
     subshell_environment != 0. */
  switch (command->type)
    {
#  if defined (DPAREN_ARITHMETIC)
    case cm_arith:
#  endif
#  if defined (COND_COMMAND)
    case cm_cond:
#  endif
      set_pipestatus_from_exit (exec_result);
      break;
    default:
      break;
    }
#endif

  last_command_exit_value = exec_result;
  run_pending_traps ();
  currently_executing_command = (COMMAND *)NULL;

  return (last_command_exit_value);
}
warning: parse error {
  int exec_result, user_subshell, invert, ignore_return, was_error_trap, fork_flags;
  REDIRECT *my_undo_list, *exec_undo_list;
  char *tcmd;
  volatile int save_line_number;
#if defined (PROCESS_SUBSTITUTION)
  volatile int ofifo, nfifo, osize, saved_fifo;
  volatile void *ofifo_list;
#endif

  if (breaking || continuing)
    return (last_command_exit_value);
  if (command == 0 || read_but_dont_execute)
    return (EXECUTION_SUCCESS);

  QUIT;
  run_pending_traps ();

#if 0
  if (running_trap == 0)
#endif
    currently_executing_command = command;

  invert = (command->flags & CMD_INVERT_RETURN) != 0;

  /* If we're inverting the return value and `set -e' has been executed,
     we don't want a failing command to inadvertently cause the shell
     to exit. */
  if (exit_immediately_on_error && invert)	/* XXX */
    command->flags |= CMD_IGNORE_RETURN;	/* XXX */

  exec_result = EXECUTION_SUCCESS;

  /* If a command was being explicitly run in a subshell, or if it is
     a shell control-structure, and it has a pipe, then we do the command
     in a subshell. */
  if (command->type == cm_subshell && (command->flags & CMD_NO_FORK))
    return (execute_in_subshell (command, asynchronous, pipe_in, pipe_out, fds_to_close));

#if defined (COPROCESS_SUPPORT)
  if (command->type == cm_coproc)
    return (last_command_exit_value = execute_coproc (command, pipe_in, pipe_out, fds_to_close));
#endif

  user_subshell = command->type == cm_subshell || ((command->flags & CMD_WANT_SUBSHELL) != 0);

#if defined (TIME_BEFORE_SUBSHELL)
  if ((command->flags & CMD_TIME_PIPELINE) && user_subshell && asynchronous == 0)
    {
      command->flags |= CMD_FORCE_SUBSHELL;
      exec_result = time_command (command, asynchronous, pipe_in, pipe_out, fds_to_close);
      currently_executing_command = (COMMAND *)NULL;
      return (exec_result);
    }
#endif

  if (command->type == cm_subshell ||
      (command->flags & (CMD_WANT_SUBSHELL|CMD_FORCE_SUBSHELL)) ||
      (shell_control_structure (command->type) &&
       (pipe_out != NO_PIPE || pipe_in != NO_PIPE || asynchronous)))
    {
      pid_t paren_pid;
      int s;
      char *p;

      /* Fork a subshell, turn off the subshell bit, turn off job
	 control and call execute_command () on the command again. */
      save_line_number = line_number;
      if (command->type == cm_subshell)
	line_number_for_err_trap = line_number = command->value.Subshell->line;	/* XXX - save value? */
	/* Otherwise we defer setting line_number */
      tcmd = make_command_string (command);
      fork_flags = asynchronous ? FORK_ASYNC : 0;
      paren_pid = make_child (p = savestring (tcmd), fork_flags);

      if (user_subshell && signal_is_trapped (ERROR_TRAP) && 
	  signal_in_progress (DEBUG_TRAP) == 0 && running_trap == 0)
	{
	  FREE (the_printed_command_except_trap);
	  the_printed_command_except_trap = savestring (the_printed_command);
	}

      if (paren_pid == 0)
        {
#if defined (JOB_CONTROL)
	  FREE (p);		/* child doesn't use pointer */
#endif
	  /* We want to run the exit trap for forced {} subshells, and we
	     want to note this before execute_in_subshell modifies the
	     COMMAND struct.  Need to keep in mind that execute_in_subshell
	     runs the exit trap for () subshells itself. */
	  /* This handles { command; } & */
	  s = user_subshell == 0 && command->type == cm_group && pipe_in == NO_PIPE && pipe_out == NO_PIPE && asynchronous;
	  /* run exit trap for : | { ...; } and { ...; } | : */
	  /* run exit trap for : | ( ...; ) and ( ...; ) | : */
	  s += user_subshell == 0 && command->type == cm_group && (pipe_in != NO_PIPE || pipe_out != NO_PIPE) && asynchronous == 0;

	  last_command_exit_value = execute_in_subshell (command, asynchronous, pipe_in, pipe_out, fds_to_close);
	  if (s)
	    subshell_exit (last_command_exit_value);
	  else
	    sh_exit (last_command_exit_value);
	  /* NOTREACHED */
        }
      else
	{
	  close_pipes (pipe_in, pipe_out);

#if defined (PROCESS_SUBSTITUTION) && defined (HAVE_DEV_FD)
	  if (variable_context == 0)	/* wait until shell function completes */
	    unlink_fifo_list ();
#endif
	  /* If we are part of a pipeline, and not the end of the pipeline,
	     then we should simply return and let the last command in the
	     pipe be waited for.  If we are not in a pipeline, or are the
	     last command in the pipeline, then we wait for the subshell
	     and return its exit status as usual. */
	  if (pipe_out != NO_PIPE)
	    return (EXECUTION_SUCCESS);

	  stop_pipeline (asynchronous, (COMMAND *)NULL);

	  line_number = save_line_number;

	  if (asynchronous == 0)
	    {
	      was_error_trap = signal_is_trapped (ERROR_TRAP) && signal_is_ignored (ERROR_TRAP) == 0;
	      invert = (command->flags & CMD_INVERT_RETURN) != 0;
	      ignore_return = (command->flags & CMD_IGNORE_RETURN) != 0;

	      exec_result = wait_for (paren_pid, 0);

	      /* If we have to, invert the return value. */
	      if (invert)
		exec_result = ((exec_result == EXECUTION_SUCCESS)
				? EXECUTION_FAILURE
				: EXECUTION_SUCCESS);

	      last_command_exit_value = exec_result;
	      if (user_subshell && was_error_trap && ignore_return == 0 && invert == 0 && exec_result != EXECUTION_SUCCESS)
		{
		  save_line_number = line_number;
		  line_number = line_number_for_err_trap;
		  run_error_trap ();
		  line_number = save_line_number;
		}

	      if (user_subshell && ignore_return == 0 && invert == 0 && exit_immediately_on_error && exec_result != EXECUTION_SUCCESS)
		{
		  run_pending_traps ();
		  jump_to_top_level (ERREXIT);
		}

	      return (last_command_exit_value);
	    }
	  else
	    {
	      DESCRIBE_PID (paren_pid);

	      run_pending_traps ();

	      /* Posix 2013 2.9.3.1: "the exit status of an asynchronous list
		 shall be zero." */
	      last_command_exit_value = 0;
	      return (EXECUTION_SUCCESS);
	    }
	}
    }

#if defined (COMMAND_TIMING)
  if (command->flags & CMD_TIME_PIPELINE)
    {
      if (asynchronous)
	{
	  command->flags |= CMD_FORCE_SUBSHELL;
	  exec_result = execute_command_internal (command, 1, pipe_in, pipe_out, fds_to_close);
	}
      else
	{
	  exec_result = time_command (command, asynchronous, pipe_in, pipe_out, fds_to_close);
#if 0
	  if (running_trap == 0)
#endif
	    currently_executing_command = (COMMAND *)NULL;
	}
      return (exec_result);
    }
#endif /* COMMAND_TIMING */

  if (shell_control_structure (command->type) && command->redirects)
    stdin_redir = stdin_redirects (command->redirects);

#if defined (PROCESS_SUBSTITUTION)
#  if !defined (HAVE_DEV_FD)
  reap_procsubs ();
#  endif

  /* XXX - also if sourcelevel != 0? */
  if (variable_context != 0 || executing_list)
    {
      ofifo = num_fifos ();
      ofifo_list = copy_fifo_list ((int *)&osize);
      begin_unwind_frame ("internal_fifos");
      if (ofifo_list)
	add_unwind_protect (xfree, ofifo_list);
      saved_fifo = 1;
    }
  else
    saved_fifo = 0;
#endif

  /* Handle WHILE FOR CASE etc. with redirections.  (Also '&' input
     redirection.)  */
  was_error_trap = signal_is_trapped (ERROR_TRAP) && signal_is_ignored (ERROR_TRAP) == 0;
  ignore_return = (command->flags & CMD_IGNORE_RETURN) != 0;

  if (do_redirections (command->redirects, RX_ACTIVE|RX_UNDOABLE) != 0)
    {
      undo_partial_redirects ();
      dispose_exec_redirects ();
#if defined (PROCESS_SUBSTITUTION)
      if (saved_fifo)
	{
	  free ((void *)ofifo_list);
          discard_unwind_frame ("internal_fifos");
	}
#endif

      /* Handle redirection error as command failure if errexit set. */
      last_command_exit_value = EXECUTION_FAILURE;
      if (ignore_return == 0 && invert == 0 && pipe_in == NO_PIPE && pipe_out == NO_PIPE)
	{
	  if (was_error_trap)
	    {
	      save_line_number = line_number;
	      line_number = line_number_for_err_trap;
	      run_error_trap ();
	      line_number = save_line_number;
	    }
	  if (exit_immediately_on_error)
	    {	  
	      run_pending_traps ();
	      jump_to_top_level (ERREXIT);
	    }
	}
      return (last_command_exit_value);
    }

  my_undo_list = redirection_undo_list;
  redirection_undo_list = (REDIRECT *)NULL;

  exec_undo_list = exec_redirection_undo_list;
  exec_redirection_undo_list = (REDIRECT *)NULL;

  if (my_undo_list || exec_undo_list)
    begin_unwind_frame ("loop_redirections");

  if (my_undo_list)
    add_unwind_protect ((Function *)cleanup_redirects, my_undo_list);

  if (exec_undo_list)
    add_unwind_protect ((Function *)dispose_redirects, exec_undo_list);

  QUIT;

  switch (command->type)
    {
    case cm_simple:
      {
	save_line_number = line_number;
	/* We can't rely on variables retaining their values across a
	   call to execute_simple_command if a longjmp occurs as the
	   result of a `return' builtin.  This is true for sure with gcc. */
#if defined (RECYCLES_PIDS)
	last_made_pid = NO_PID;
#endif
	was_error_trap = signal_is_trapped (ERROR_TRAP) && signal_is_ignored (ERROR_TRAP) == 0;

	if (ignore_return && command->value.Simple)
	  command->value.Simple->flags |= CMD_IGNORE_RETURN;
	if (command->flags & CMD_STDIN_REDIR)
	  command->value.Simple->flags |= CMD_STDIN_REDIR;

	line_number_for_err_trap = line_number = command->value.Simple->line;
	exec_result =
	  execute_simple_command (command->value.Simple, pipe_in, pipe_out,
				  asynchronous, fds_to_close);
	line_number = save_line_number;

	/* The temporary environment should be used for only the simple
	   command immediately following its definition. */
	dispose_used_env_vars ();

#if (defined (ultrix) && defined (mips)) || defined (C_ALLOCA)
	/* Reclaim memory allocated with alloca () on machines which
	   may be using the alloca emulation code. */
	(void) alloca (0);
#endif /* (ultrix && mips) || C_ALLOCA */

	/* If we forked to do the command, then we must wait_for ()
	   the child. */

	/* XXX - this is something to watch out for if there are problems
	   when the shell is compiled without job control.  Don't worry about
	   whether or not last_made_pid == last_pid; already_making_children
	   tells us whether or not there are unwaited-for children to wait
	   for and reap. */
	if (already_making_children && pipe_out == NO_PIPE)
	  {
	    stop_pipeline (asynchronous, (COMMAND *)NULL);

	    if (asynchronous)
	      {
		DESCRIBE_PID (last_made_pid);
		exec_result = EXECUTION_SUCCESS;
		invert = 0;		/* async commands always succeed */
	      }
	    else
#if !defined (JOB_CONTROL)
	      /* Do not wait for asynchronous processes started from
		 startup files. */
	    if (last_made_pid != NO_PID && last_made_pid != last_asynchronous_pid)
#else
	    if (last_made_pid != NO_PID)
#endif
	    /* When executing a shell function that executes other
	       commands, this causes the last simple command in
	       the function to be waited for twice.  This also causes
	       subshells forked to execute builtin commands (e.g., in
	       pipelines) to be waited for twice. */
	      exec_result = wait_for (last_made_pid, 0);
	  }
      }

      /* 2009/02/13 -- pipeline failure is processed elsewhere.  This handles
	 only the failure of a simple command. We don't want to run the error
	 trap if the command run by the `command' builtin fails; we want to
	 defer that until the command builtin itself returns failure. */
      /* 2020/07/14 -- this changes with how the command builtin is handled */ 
      if (was_error_trap && ignore_return == 0 && invert == 0 &&
	    pipe_in == NO_PIPE && pipe_out == NO_PIPE &&
	    (command->value.Simple->flags & CMD_COMMAND_BUILTIN) == 0 &&
	    exec_result != EXECUTION_SUCCESS)
	{
	  last_command_exit_value = exec_result;
	  line_number = line_number_for_err_trap;
	  run_error_trap ();
	  line_number = save_line_number;
	}

      if (ignore_return == 0 && invert == 0 &&
	  ((posixly_correct && interactive == 0 && special_builtin_failed) ||
	   (exit_immediately_on_error && pipe_in == NO_PIPE && pipe_out == NO_PIPE && exec_result != EXECUTION_SUCCESS)))
	{
	  last_command_exit_value = exec_result;
	  run_pending_traps ();

	  /* Undo redirections before running exit trap on the way out of
	     set -e. Report by Mark Farrell 5/19/2014 */
	  if (exit_immediately_on_error && signal_is_trapped (0) &&
		unwind_protect_tag_on_stack ("saved-redirects"))
	    run_unwind_frame ("saved-redirects");

	  jump_to_top_level (ERREXIT);
	}

      break;

    case cm_for:
      if (ignore_return)
	command->value.For->flags |= CMD_IGNORE_RETURN;
      exec_result = execute_for_command (command->value.For);
      break;

#if defined (ARITH_FOR_COMMAND)
    case cm_arith_for:
      if (ignore_return)
	command->value.ArithFor->flags |= CMD_IGNORE_RETURN;
      exec_result = execute_arith_for_command (command->value.ArithFor);
      break;
#endif

#if defined (SELECT_COMMAND)
    case cm_select:
      if (ignore_return)
	command->value.Select->flags |= CMD_IGNORE_RETURN;
      exec_result = execute_select_command (command->value.Select);
      break;
#endif

    case cm_case:
      if (ignore_return)
	command->value.Case->flags |= CMD_IGNORE_RETURN;
      exec_result = execute_case_command (command->value.Case);
      break;

    case cm_while:
      if (ignore_return)
	command->value.While->flags |= CMD_IGNORE_RETURN;
      exec_result = execute_while_command (command->value.While);
      break;

    case cm_until:
      if (ignore_return)
	command->value.While->flags |= CMD_IGNORE_RETURN;
      exec_result = execute_until_command (command->value.While);
      break;

    case cm_if:
      if (ignore_return)
	command->value.If->flags |= CMD_IGNORE_RETURN;
      exec_result = execute_if_command (command->value.If);
      break;

    case cm_group:

      /* This code can be executed from either of two paths: an explicit
	 '{}' command, or via a function call.  If we are executed via a
	 function call, we have already taken care of the function being
	 executed in the background (down there in execute_simple_command ()),
	 and this command should *not* be marked as asynchronous.  If we
	 are executing a regular '{}' group command, and asynchronous == 1,
	 we must want to execute the whole command in the background, so we
	 need a subshell, and we want the stuff executed in that subshell
	 (this group command) to be executed in the foreground of that
	 subshell (i.e. there will not be *another* subshell forked).

	 What we do is to force a subshell if asynchronous, and then call
	 execute_command_internal again with asynchronous still set to 1,
	 but with the original group command, so the printed command will
	 look right.

	 The code above that handles forking off subshells will note that
	 both subshell and async are on, and turn off async in the child
	 after forking the subshell (but leave async set in the parent, so
	 the normal call to describe_pid is made).  This turning off
	 async is *crucial*; if it is not done, this will fall into an
	 infinite loop of executions through this spot in subshell after
	 subshell until the process limit is exhausted. */

      if (asynchronous)
	{
	  command->flags |= CMD_FORCE_SUBSHELL;
	  exec_result =
	    execute_command_internal (command, 1, pipe_in, pipe_out,
				      fds_to_close);
	}
      else
	{
	  if (ignore_return && command->value.Group->command)
	    command->value.Group->command->flags |= CMD_IGNORE_RETURN;
	  exec_result =
	    execute_command_internal (command->value.Group->command,
				      asynchronous, pipe_in, pipe_out,
				      fds_to_close);
	}
      break;

    case cm_connection:
      exec_result = execute_connection (command, asynchronous,
					pipe_in, pipe_out, fds_to_close);
      if (asynchronous)
	invert = 0;		/* XXX */

      break;

#if defined (DPAREN_ARITHMETIC)
    case cm_arith:
#endif
#if defined (COND_COMMAND)
    case cm_cond:
#endif
    case cm_function_def:
      was_error_trap = signal_is_trapped (ERROR_TRAP) && signal_is_ignored (ERROR_TRAP) == 0;
#if defined (DPAREN_ARITHMETIC)
      if (ignore_return && command->type == cm_arith)
	command->value.Arith->flags |= CMD_IGNORE_RETURN;
#endif
#if defined (COND_COMMAND)
      if (ignore_return && command->type == cm_cond)
	command->value.Cond->flags |= CMD_IGNORE_RETURN;
#endif

      line_number_for_err_trap = save_line_number = line_number;
#if defined (DPAREN_ARITHMETIC)
      if (command->type == cm_arith)
	exec_result = execute_arith_command (command->value.Arith);
      else
#endif
#if defined (COND_COMMAND)
      if (command->type == cm_cond)
	exec_result = execute_cond_command (command->value.Cond);
      else
#endif
      if (command->type == cm_function_def)
	exec_result = execute_intern_function (command->value.Function_def->name,
					       command->value.Function_def);
      line_number = save_line_number;

      if (was_error_trap && ignore_return == 0 && invert == 0 && exec_result != EXECUTION_SUCCESS)
	{
	  last_command_exit_value = exec_result;
	  save_line_number = line_number;
	  line_number = line_number_for_err_trap;
	  run_error_trap ();
	  line_number = save_line_number;
	}

      if (ignore_return == 0 && invert == 0 && exit_immediately_on_error && exec_result != EXECUTION_SUCCESS)
	{
	  last_command_exit_value = exec_result;
	  run_pending_traps ();
	  jump_to_top_level (ERREXIT);
	}

      break;

    default:
      command_error ("execute_command", CMDERR_BADTYPE, command->type, 0);
    }

  if (my_undo_list)
    cleanup_redirects (my_undo_list);

  if (exec_undo_list)
    dispose_redirects (exec_undo_list);

  if (my_undo_list || exec_undo_list)
    discard_unwind_frame ("loop_redirections");

#if defined (PROCESS_SUBSTITUTION)
  if (saved_fifo)
    {
      nfifo = num_fifos ();
      if (nfifo > ofifo)
	close_new_fifos ((void *)ofifo_list, osize);
      free ((void *)ofifo_list);
      discard_unwind_frame ("internal_fifos");
    }
#endif

  /* Invert the return value if we have to */
  if (invert)
    exec_result = (exec_result == EXECUTION_SUCCESS)
		    ? EXECUTION_FAILURE
		    : EXECUTION_SUCCESS;

#if defined (DPAREN_ARITHMETIC) || defined (COND_COMMAND)
  /* This is where we set PIPESTATUS from the exit status of the appropriate
     compound commands (the ones that look enough like simple commands to
     cause confusion).  We might be able to optimize by not doing this if
     subshell_environment != 0. */
  switch (command->type)
    {
#  if defined (DPAREN_ARITHMETIC)
    case cm_arith:
#  endif
#  if defined (COND_COMMAND)
    case cm_cond:
#  endif
      set_pipestatus_from_exit (exec_result);
      break;
    default:
      break;
    }
#endif

  last_command_exit_value = exec_result;
  run_pending_traps ();
  currently_executing_command = (COMMAND *)NULL;

  return (last_command_exit_value);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\execute_cmd.c:561
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\execute_cmd.c:1,450
parsing error 
{
  volatile int user_subshell, user_coproc, invert;
  int return_code, function_value, should_redir_stdin, ois, result;
  volatile COMMAND *tcom;

  USE_VAR(user_subshell);
  USE_VAR(user_coproc);
  USE_VAR(invert);
  USE_VAR(tcom);
  USE_VAR(asynchronous);

  subshell_level++;
  should_redir_stdin = (asynchronous && (command->flags & CMD_STDIN_REDIR) &&
			  pipe_in == NO_PIPE &&
			  stdin_redirects (command->redirects) == 0);

  invert = (command->flags & CMD_INVERT_RETURN) != 0;
  user_subshell = command->type == cm_subshell || ((command->flags & CMD_WANT_SUBSHELL) != 0);
  user_coproc = command->type == cm_coproc;

  command->flags &= ~(CMD_FORCE_SUBSHELL | CMD_WANT_SUBSHELL | CMD_INVERT_RETURN);

  /* If a command is asynchronous in a subshell (like ( foo ) & or
     the special case of an asynchronous GROUP command where the
     the subshell bit is turned on down in case cm_group: below),
     turn off `asynchronous', so that two subshells aren't spawned.
     XXX - asynchronous used to be set to 0 in this block, but that
     means that setup_async_signals was never run.  Now it's set to
     0 after subshell_environment is set appropriately and setup_async_signals
     is run.

     This seems semantically correct to me.  For example,
     ( foo ) & seems to say ``do the command `foo' in a subshell
     environment, but don't wait for that subshell to finish'',
     and "{ foo ; bar ; } &" seems to me to be like functions or
     builtins in the background, which executed in a subshell
     environment.  I just don't see the need to fork two subshells. */

  /* Don't fork again, we are already in a subshell.  A `doubly
     async' shell is not interactive, however. */
  if (asynchronous)
    {
#if defined (JOB_CONTROL)
      /* If a construct like ( exec xxx yyy ) & is given while job
	 control is active, we want to prevent exec from putting the
	 subshell back into the original process group, carefully
	 undoing all the work we just did in make_child. */
      original_pgrp = -1;
#endif /* JOB_CONTROL */
      ois = interactive_shell;
      interactive_shell = 0;
      /* This test is to prevent alias expansion by interactive shells that
	 run `(command) &' but to allow scripts that have enabled alias
	 expansion with `shopt -s expand_alias' to continue to expand
	 aliases. */
      if (ois != interactive_shell)
	expand_aliases = 0;
    }

  /* Subshells are neither login nor interactive. */
  login_shell = interactive = 0;

  /* And we're no longer in a loop. See Posix interp 842 (we are not in the
     "same execution environment"). */
  if (shell_compatibility_level > 44)
    loop_level = 0;

  if (user_subshell)
    {
      subshell_environment = SUBSHELL_PAREN;	/* XXX */
      if (asynchronous)
	subshell_environment |= SUBSHELL_ASYNC;
    }
  else
    {
      subshell_environment = 0;			/* XXX */
      if (asynchronous)
	subshell_environment |= SUBSHELL_ASYNC;
      if (pipe_in != NO_PIPE || pipe_out != NO_PIPE)
	subshell_environment |= SUBSHELL_PIPE;
      if (user_coproc)
	subshell_environment |= SUBSHELL_COPROC;
    }

  QUIT;
  CHECK_TERMSIG;

  reset_terminating_signals ();		/* in sig.c */
  /* Cancel traps, in trap.c. */
  /* Reset the signal handlers in the child, but don't free the
     trap strings.  Set a flag noting that we have to free the
     trap strings if we run trap to change a signal disposition. */
  clear_pending_traps ();
  reset_signal_handlers ();
  subshell_environment |= SUBSHELL_RESETTRAP;

  /* We are in a subshell, so forget that we are running a trap handler or
     that the signal handler has changed (we haven't changed it!) */
  if (running_trap > 0)
    {
      run_trap_cleanup (running_trap - 1);
      running_trap = 0;		/* XXX - maybe leave this */
    }

  /* Make sure restore_original_signals doesn't undo the work done by
     make_child to ensure that asynchronous children are immune to SIGINT
     and SIGQUIT.  Turn off asynchronous to make sure more subshells are
     not spawned. */
  if (asynchronous)
    {
      setup_async_signals ();
      asynchronous = 0;
    }
  else
    set_sigint_handler ();

#if defined (JOB_CONTROL)
  set_sigchld_handler ();
#endif /* JOB_CONTROL */

  /* Delete all traces that there were any jobs running.  This is
     only for subshells. */
  without_job_control ();

  if (fds_to_close)
    close_fd_bitmap (fds_to_close);

  do_piping (pipe_in, pipe_out);

#if defined (COPROCESS_SUPPORT)
  coproc_closeall ();
#endif

#if defined (PROCESS_SUBSTITUTION)
  clear_fifo_list ();		/* XXX- we haven't created any FIFOs */
#endif

  /* If this is a user subshell, set a flag if stdin was redirected.
     This is used later to decide whether to redirect fd 0 to
     /dev/null for async commands in the subshell.  This adds more
     sh compatibility, but I'm not sure it's the right thing to do.
     Note that an input pipe to a compound command suffices to inhibit
     the implicit /dev/null redirection for asynchronous commands
     executed as part of that compound command. */
  if (user_subshell)
    {
      stdin_redir = stdin_redirects (command->redirects) || pipe_in != NO_PIPE;
#if 0
      restore_default_signal (EXIT_TRAP);	/* XXX - reset_signal_handlers above */
#endif
    }
  else if (shell_control_structure (command->type) && pipe_in != NO_PIPE)
    stdin_redir = 1;

  /* If this is an asynchronous command (command &), we want to
     redirect the standard input from /dev/null in the absence of
     any specific redirection involving stdin. */
  if (should_redir_stdin && stdin_redir == 0)
    async_redirect_stdin ();

#if defined (BUFFERED_INPUT)
  /* In any case, we are not reading our command input from stdin. */
  default_buffered_input = -1;
#endif

#if 0 /* TAG: bash-5.2 */
  if (user_subshell && command->type == cm_subshell)
    optimize_subshell_command (command->value.Subshell->command);
#endif

  /* Do redirections, then dispose of them before recursive call. */
  if (command->redirects)
    {
      if (do_redirections (command->redirects, RX_ACTIVE) != 0)
	exit (invert ? EXECUTION_SUCCESS : EXECUTION_FAILURE);

      dispose_redirects (command->redirects);
      command->redirects = (REDIRECT *)NULL;
    }

  if (command->type == cm_subshell)
    tcom = command->value.Subshell->command;
  else if (user_coproc)
    tcom = command->value.Coproc->command;
  else
    tcom = command;

  if (command->flags & CMD_TIME_PIPELINE)
    tcom->flags |= CMD_TIME_PIPELINE;
  if (command->flags & CMD_TIME_POSIX)
    tcom->flags |= CMD_TIME_POSIX;
  
  /* Make sure the subshell inherits any CMD_IGNORE_RETURN flag. */
  if ((command->flags & CMD_IGNORE_RETURN) && tcom != command)
    tcom->flags |= CMD_IGNORE_RETURN;

  /* If this is a simple command, tell execute_disk_command that it
     might be able to get away without forking and simply exec.
     This means things like ( sleep 10 ) will only cause one fork.
     If we're timing the command or inverting its return value, however,
     we cannot do this optimization. */
  if ((user_subshell || user_coproc) && (tcom->type == cm_simple || tcom->type == cm_subshell) &&
      ((tcom->flags & CMD_TIME_PIPELINE) == 0) &&
      ((tcom->flags & CMD_INVERT_RETURN) == 0))
    {
      tcom->flags |= CMD_NO_FORK;
      if (tcom->type == cm_simple)
	tcom->value.Simple->flags |= CMD_NO_FORK;
    }

  invert = (tcom->flags & CMD_INVERT_RETURN) != 0;
  tcom->flags &= ~CMD_INVERT_RETURN;

  result = setjmp_nosigs (top_level);

  /* If we're inside a function while executing this subshell, we
     need to handle a possible `return'. */
  function_value = 0;
  if (return_catch_flag)
    function_value = setjmp_nosigs (return_catch);

  /* If we're going to exit the shell, we don't want to invert the return
     status. */
  if (result == EXITPROG)
    invert = 0, return_code = last_command_exit_value;
  else if (result)
    return_code = (last_command_exit_value == EXECUTION_SUCCESS) ? EXECUTION_FAILURE : last_command_exit_value;
  else if (function_value)
    return_code = return_catch_value;
  else
    return_code = execute_command_internal ((COMMAND *)tcom, asynchronous, NO_PIPE, NO_PIPE, fds_to_close);

  /* If we are asked to, invert the return value. */
  if (invert)
    return_code = (return_code == EXECUTION_SUCCESS) ? EXECUTION_FAILURE
						     : EXECUTION_SUCCESS;


  /* If we were explicitly placed in a subshell with (), we need
     to do the `shell cleanup' things, such as running traps[0]. */
  if (user_subshell && signal_is_trapped (0))
    {
      last_command_exit_value = return_code;
      return_code = run_exit_trap ();
    }

#if 0
  subshell_level--;		/* don't bother, caller will just exit */
#endif
  return (return_code);
  /* NOTREACHED */
}
warning: parse error {
  volatile int user_subshell, user_coproc, invert;
  int return_code, function_value, should_redir_stdin, ois, result;
  volatile COMMAND *tcom;

  USE_VAR(user_subshell);
  USE_VAR(user_coproc);
  USE_VAR(invert);
  USE_VAR(tcom);
  USE_VAR(asynchronous);

  subshell_level++;
  should_redir_stdin = (asynchronous && (command->flags & CMD_STDIN_REDIR) &&
			  pipe_in == NO_PIPE &&
			  stdin_redirects (command->redirects) == 0);

  invert = (command->flags & CMD_INVERT_RETURN) != 0;
  user_subshell = command->type == cm_subshell || ((command->flags & CMD_WANT_SUBSHELL) != 0);
  user_coproc = command->type == cm_coproc;

  command->flags &= ~(CMD_FORCE_SUBSHELL | CMD_WANT_SUBSHELL | CMD_INVERT_RETURN);

  /* If a command is asynchronous in a subshell (like ( foo ) & or
     the special case of an asynchronous GROUP command where the
     the subshell bit is turned on down in case cm_group: below),
     turn off `asynchronous', so that two subshells aren't spawned.
     XXX - asynchronous used to be set to 0 in this block, but that
     means that setup_async_signals was never run.  Now it's set to
     0 after subshell_environment is set appropriately and setup_async_signals
     is run.

     This seems semantically correct to me.  For example,
     ( foo ) & seems to say ``do the command `foo' in a subshell
     environment, but don't wait for that subshell to finish'',
     and "{ foo ; bar ; } &" seems to me to be like functions or
     builtins in the background, which executed in a subshell
     environment.  I just don't see the need to fork two subshells. */

  /* Don't fork again, we are already in a subshell.  A `doubly
     async' shell is not interactive, however. */
  if (asynchronous)
    {
#if defined (JOB_CONTROL)
      /* If a construct like ( exec xxx yyy ) & is given while job
	 control is active, we want to prevent exec from putting the
	 subshell back into the original process group, carefully
	 undoing all the work we just did in make_child. */
      original_pgrp = -1;
#endif /* JOB_CONTROL */
      ois = interactive_shell;
      interactive_shell = 0;
      /* This test is to prevent alias expansion by interactive shells that
	 run `(command) &' but to allow scripts that have enabled alias
	 expansion with `shopt -s expand_alias' to continue to expand
	 aliases. */
      if (ois != interactive_shell)
	expand_aliases = 0;
    }

  /* Subshells are neither login nor interactive. */
  login_shell = interactive = 0;

  /* And we're no longer in a loop. See Posix interp 842 (we are not in the
     "same execution environment"). */
  if (shell_compatibility_level > 44)
    loop_level = 0;

  if (user_subshell)
    {
      subshell_environment = SUBSHELL_PAREN;	/* XXX */
      if (asynchronous)
	subshell_environment |= SUBSHELL_ASYNC;
    }
  else
    {
      subshell_environment = 0;			/* XXX */
      if (asynchronous)
	subshell_environment |= SUBSHELL_ASYNC;
      if (pipe_in != NO_PIPE || pipe_out != NO_PIPE)
	subshell_environment |= SUBSHELL_PIPE;
      if (user_coproc)
	subshell_environment |= SUBSHELL_COPROC;
    }

  QUIT;
  CHECK_TERMSIG;

  reset_terminating_signals ();		/* in sig.c */
  /* Cancel traps, in trap.c. */
  /* Reset the signal handlers in the child, but don't free the
     trap strings.  Set a flag noting that we have to free the
     trap strings if we run trap to change a signal disposition. */
  clear_pending_traps ();
  reset_signal_handlers ();
  subshell_environment |= SUBSHELL_RESETTRAP;

  /* We are in a subshell, so forget that we are running a trap handler or
     that the signal handler has changed (we haven't changed it!) */
  if (running_trap > 0)
    {
      run_trap_cleanup (running_trap - 1);
      running_trap = 0;		/* XXX - maybe leave this */
    }

  /* Make sure restore_original_signals doesn't undo the work done by
     make_child to ensure that asynchronous children are immune to SIGINT
     and SIGQUIT.  Turn off asynchronous to make sure more subshells are
     not spawned. */
  if (asynchronous)
    {
      setup_async_signals ();
      asynchronous = 0;
    }
  else
    set_sigint_handler ();

#if defined (JOB_CONTROL)
  set_sigchld_handler ();
#endif /* JOB_CONTROL */

  /* Delete all traces that there were any jobs running.  This is
     only for subshells. */
  without_job_control ();

  if (fds_to_close)
    close_fd_bitmap (fds_to_close);

  do_piping (pipe_in, pipe_out);

#if defined (COPROCESS_SUPPORT)
  coproc_closeall ();
#endif

#if defined (PROCESS_SUBSTITUTION)
  clear_fifo_list ();		/* XXX- we haven't created any FIFOs */
#endif

  /* If this is a user subshell, set a flag if stdin was redirected.
     This is used later to decide whether to redirect fd 0 to
     /dev/null for async commands in the subshell.  This adds more
     sh compatibility, but I'm not sure it's the right thing to do.
     Note that an input pipe to a compound command suffices to inhibit
     the implicit /dev/null redirection for asynchronous commands
     executed as part of that compound command. */
  if (user_subshell)
    {
      stdin_redir = stdin_redirects (command->redirects) || pipe_in != NO_PIPE;
#if 0
      restore_default_signal (EXIT_TRAP);	/* XXX - reset_signal_handlers above */
#endif
    }
  else if (shell_control_structure (command->type) && pipe_in != NO_PIPE)
    stdin_redir = 1;

  /* If this is an asynchronous command (command &), we want to
     redirect the standard input from /dev/null in the absence of
     any specific redirection involving stdin. */
  if (should_redir_stdin && stdin_redir == 0)
    async_redirect_stdin ();

#if defined (BUFFERED_INPUT)
  /* In any case, we are not reading our command input from stdin. */
  default_buffered_input = -1;
#endif

#if 0 /* TAG: bash-5.2 */
  if (user_subshell && command->type == cm_subshell)
    optimize_subshell_command (command->value.Subshell->command);
#endif

  /* Do redirections, then dispose of them before recursive call. */
  if (command->redirects)
    {
      if (do_redirections (command->redirects, RX_ACTIVE) != 0)
	exit (invert ? EXECUTION_SUCCESS : EXECUTION_FAILURE);

      dispose_redirects (command->redirects);
      command->redirects = (REDIRECT *)NULL;
    }

  if (command->type == cm_subshell)
    tcom = command->value.Subshell->command;
  else if (user_coproc)
    tcom = command->value.Coproc->command;
  else
    tcom = command;

  if (command->flags & CMD_TIME_PIPELINE)
    tcom->flags |= CMD_TIME_PIPELINE;
  if (command->flags & CMD_TIME_POSIX)
    tcom->flags |= CMD_TIME_POSIX;
  
  /* Make sure the subshell inherits any CMD_IGNORE_RETURN flag. */
  if ((command->flags & CMD_IGNORE_RETURN) && tcom != command)
    tcom->flags |= CMD_IGNORE_RETURN;

  /* If this is a simple command, tell execute_disk_command that it
     might be able to get away without forking and simply exec.
     This means things like ( sleep 10 ) will only cause one fork.
     If we're timing the command or inverting its return value, however,
     we cannot do this optimization. */
  if ((user_subshell || user_coproc) && (tcom->type == cm_simple || tcom->type == cm_subshell) &&
      ((tcom->flags & CMD_TIME_PIPELINE) == 0) &&
      ((tcom->flags & CMD_INVERT_RETURN) == 0))
    {
      tcom->flags |= CMD_NO_FORK;
      if (tcom->type == cm_simple)
	tcom->value.Simple->flags |= CMD_NO_FORK;
    }

  invert = (tcom->flags & CMD_INVERT_RETURN) != 0;
  tcom->flags &= ~CMD_INVERT_RETURN;

  result = setjmp_nosigs (top_level);

  /* If we're inside a function while executing this subshell, we
     need to handle a possible `return'. */
  function_value = 0;
  if (return_catch_flag)
    function_value = setjmp_nosigs (return_catch);

  /* If we're going to exit the shell, we don't want to invert the return
     status. */
  if (result == EXITPROG)
    invert = 0, return_code = last_command_exit_value;
  else if (result)
    return_code = (last_command_exit_value == EXECUTION_SUCCESS) ? EXECUTION_FAILURE : last_command_exit_value;
  else if (function_value)
    return_code = return_catch_value;
  else
    return_code = execute_command_internal ((COMMAND *)tcom, asynchronous, NO_PIPE, NO_PIPE, fds_to_close);

  /* If we are asked to, invert the return value. */
  if (invert)
    return_code = (return_code == EXECUTION_SUCCESS) ? EXECUTION_FAILURE
						     : EXECUTION_SUCCESS;


  /* If we were explicitly placed in a subshell with (), we need
     to do the `shell cleanup' things, such as running traps[0]. */
  if (user_subshell && signal_is_trapped (0))
    {
      last_command_exit_value = return_code;
      return_code = run_exit_trap ();
    }

#if 0
  subshell_level--;		/* don't bother, caller will just exit */
#endif
  return (return_code);
  /* NOTREACHED */
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\execute_cmd.c:1,455
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\execute_cmd.c:2,443
parsing error 
{
  dup2 (s, 0);
  close (s);
}
warning: parse error {
  dup2 (s, 0);
  close (s);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\execute_cmd.c:2,445
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\execute_cmd.c:2,452
parsing error 
{
  set_jobs_list_frozen (s);
}
warning: parse error {
  set_jobs_list_frozen (s);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\execute_cmd.c:2,454
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\execute_cmd.c:2,459
parsing error 
{
  int prev, fildes[2], new_bitmap_size, dummyfd, ignore_return, exec_result;
  int lstdin, lastpipe_flag, lastpipe_jid, old_frozen;
  COMMAND *cmd;
  struct fd_bitmap *fd_bitmap;
  pid_t lastpid;

#if defined (JOB_CONTROL)
  sigset_t set, oset;
  BLOCK_CHILD (set, oset);
#endif /* JOB_CONTROL */

  ignore_return = (command->flags & CMD_IGNORE_RETURN) != 0;

  prev = pipe_in;
  cmd = command;

  while (cmd && cmd->type == cm_connection &&
	 cmd->value.Connection && cmd->value.Connection->connector == '|')
    {
      /* Make a pipeline between the two commands. */
      if (pipe (fildes) < 0)
	{
	  sys_error (_("pipe error"));
#if defined (JOB_CONTROL)
	  terminate_current_pipeline ();
	  kill_current_pipeline ();
	  UNBLOCK_CHILD (oset);
#endif /* JOB_CONTROL */
	  last_command_exit_value = EXECUTION_FAILURE;
	  /* The unwind-protects installed below will take care
	     of closing all of the open file descriptors. */
	  throw_to_top_level ();
	  return (EXECUTION_FAILURE);	/* XXX */
	}

      /* Here is a problem: with the new file close-on-exec
	 code, the read end of the pipe (fildes[0]) stays open
	 in the first process, so that process will never get a
	 SIGPIPE.  There is no way to signal the first process
	 that it should close fildes[0] after forking, so it
	 remains open.  No SIGPIPE is ever sent because there
	 is still a file descriptor open for reading connected
	 to the pipe.  We take care of that here.  This passes
	 around a bitmap of file descriptors that must be
	 closed after making a child process in execute_simple_command. */

      /* We need fd_bitmap to be at least as big as fildes[0].
	 If fildes[0] is less than fds_to_close->size, then
	 use fds_to_close->size. */
      new_bitmap_size = (fildes[0] < fds_to_close->size)
				? fds_to_close->size
				: fildes[0] + 8;

      fd_bitmap = new_fd_bitmap (new_bitmap_size);

      /* Now copy the old information into the new bitmap. */
      xbcopy ((char *)fds_to_close->bitmap, (char *)fd_bitmap->bitmap, fds_to_close->size);

      /* And mark the pipe file descriptors to be closed. */
      fd_bitmap->bitmap[fildes[0]] = 1;

      /* In case there are pipe or out-of-processes errors, we
	 want all these file descriptors to be closed when
	 unwind-protects are run, and the storage used for the
	 bitmaps freed up. */
      begin_unwind_frame ("pipe-file-descriptors");
      add_unwind_protect (dispose_fd_bitmap, fd_bitmap);
      add_unwind_protect (close_fd_bitmap, fd_bitmap);
      if (prev >= 0)
	add_unwind_protect (close, prev);
      dummyfd = fildes[1];
      add_unwind_protect (close, dummyfd);

#if defined (JOB_CONTROL)
      add_unwind_protect (restore_signal_mask, &oset);
#endif /* JOB_CONTROL */

      if (ignore_return && cmd->value.Connection->first)
	cmd->value.Connection->first->flags |= CMD_IGNORE_RETURN;
      execute_command_internal (cmd->value.Connection->first, asynchronous,
				prev, fildes[1], fd_bitmap);

      if (prev >= 0)
	close (prev);

      prev = fildes[0];
      close (fildes[1]);

      dispose_fd_bitmap (fd_bitmap);
      discard_unwind_frame ("pipe-file-descriptors");

      cmd = cmd->value.Connection->second;
    }

  lastpid = last_made_pid;

  /* Now execute the rightmost command in the pipeline.  */
  if (ignore_return && cmd)
    cmd->flags |= CMD_IGNORE_RETURN;

  lastpipe_flag = 0;

  begin_unwind_frame ("lastpipe-exec");
  lstdin = -1;
  /* If the `lastpipe' option is set with shopt, and job control is not
     enabled, execute the last element of non-async pipelines in the
     current shell environment. */
  if (lastpipe_opt && job_control == 0 && asynchronous == 0 && pipe_out == NO_PIPE && prev > 0)
    {
      lstdin = move_to_high_fd (0, 1, -1);
      if (lstdin > 0)
	{
	  do_piping (prev, pipe_out);
	  prev = NO_PIPE;
	  add_unwind_protect (restore_stdin, lstdin);
	  lastpipe_flag = 1;
	  old_frozen = freeze_jobs_list ();
	  lastpipe_jid = stop_pipeline (0, (COMMAND *)NULL);	/* XXX */
	  add_unwind_protect (lastpipe_cleanup, old_frozen);
#if defined (JOB_CONTROL)
	  UNBLOCK_CHILD (oset);		/* XXX */
#endif
	}
      if (cmd)
	cmd->flags |= CMD_LASTPIPE;
    }	  
  if (prev >= 0)
    add_unwind_protect (close, prev);

  exec_result = execute_command_internal (cmd, asynchronous, prev, pipe_out, fds_to_close);

  if (lstdin > 0)
    restore_stdin (lstdin);

  if (prev >= 0)
    close (prev);

#if defined (JOB_CONTROL)
  UNBLOCK_CHILD (oset);
#endif

  QUIT;

  if (lastpipe_flag)
    {
#if defined (JOB_CONTROL)
      if (INVALID_JOB (lastpipe_jid) == 0)
        {
          append_process (savestring (the_printed_command_except_trap), dollar_dollar_pid, exec_result, lastpipe_jid);
          lstdin = wait_for (lastpid, 0);
        }
      else
        lstdin = wait_for_single_pid (lastpid, 0);		/* checks bgpids list */
#else
      lstdin = wait_for (lastpid, 0);
#endif

#if defined (JOB_CONTROL)
      /* If wait_for removes the job from the jobs table, use result of last
	 command as pipeline's exit status as usual.  The jobs list can get
	 frozen and unfrozen at inconvenient times if there are multiple pipelines
	 running simultaneously. */
      if (INVALID_JOB (lastpipe_jid) == 0)
	exec_result = job_exit_status (lastpipe_jid);
      else if (pipefail_opt)
	exec_result = exec_result | lstdin;	/* XXX */
      /* otherwise we use exec_result */
#endif

      set_jobs_list_frozen (old_frozen);
    }

  discard_unwind_frame ("lastpipe-exec");

  return (exec_result);
}
warning: parse error {
  int prev, fildes[2], new_bitmap_size, dummyfd, ignore_return, exec_result;
  int lstdin, lastpipe_flag, lastpipe_jid, old_frozen;
  COMMAND *cmd;
  struct fd_bitmap *fd_bitmap;
  pid_t lastpid;

#if defined (JOB_CONTROL)
  sigset_t set, oset;
  BLOCK_CHILD (set, oset);
#endif /* JOB_CONTROL */

  ignore_return = (command->flags & CMD_IGNORE_RETURN) != 0;

  prev = pipe_in;
  cmd = command;

  while (cmd && cmd->type == cm_connection &&
	 cmd->value.Connection && cmd->value.Connection->connector == '|')
    {
      /* Make a pipeline between the two commands. */
      if (pipe (fildes) < 0)
	{
	  sys_error (_("pipe error"));
#if defined (JOB_CONTROL)
	  terminate_current_pipeline ();
	  kill_current_pipeline ();
	  UNBLOCK_CHILD (oset);
#endif /* JOB_CONTROL */
	  last_command_exit_value = EXECUTION_FAILURE;
	  /* The unwind-protects installed below will take care
	     of closing all of the open file descriptors. */
	  throw_to_top_level ();
	  return (EXECUTION_FAILURE);	/* XXX */
	}

      /* Here is a problem: with the new file close-on-exec
	 code, the read end of the pipe (fildes[0]) stays open
	 in the first process, so that process will never get a
	 SIGPIPE.  There is no way to signal the first process
	 that it should close fildes[0] after forking, so it
	 remains open.  No SIGPIPE is ever sent because there
	 is still a file descriptor open for reading connected
	 to the pipe.  We take care of that here.  This passes
	 around a bitmap of file descriptors that must be
	 closed after making a child process in execute_simple_command. */

      /* We need fd_bitmap to be at least as big as fildes[0].
	 If fildes[0] is less than fds_to_close->size, then
	 use fds_to_close->size. */
      new_bitmap_size = (fildes[0] < fds_to_close->size)
				? fds_to_close->size
				: fildes[0] + 8;

      fd_bitmap = new_fd_bitmap (new_bitmap_size);

      /* Now copy the old information into the new bitmap. */
      xbcopy ((char *)fds_to_close->bitmap, (char *)fd_bitmap->bitmap, fds_to_close->size);

      /* And mark the pipe file descriptors to be closed. */
      fd_bitmap->bitmap[fildes[0]] = 1;

      /* In case there are pipe or out-of-processes errors, we
	 want all these file descriptors to be closed when
	 unwind-protects are run, and the storage used for the
	 bitmaps freed up. */
      begin_unwind_frame ("pipe-file-descriptors");
      add_unwind_protect (dispose_fd_bitmap, fd_bitmap);
      add_unwind_protect (close_fd_bitmap, fd_bitmap);
      if (prev >= 0)
	add_unwind_protect (close, prev);
      dummyfd = fildes[1];
      add_unwind_protect (close, dummyfd);

#if defined (JOB_CONTROL)
      add_unwind_protect (restore_signal_mask, &oset);
#endif /* JOB_CONTROL */

      if (ignore_return && cmd->value.Connection->first)
	cmd->value.Connection->first->flags |= CMD_IGNORE_RETURN;
      execute_command_internal (cmd->value.Connection->first, asynchronous,
				prev, fildes[1], fd_bitmap);

      if (prev >= 0)
	close (prev);

      prev = fildes[0];
      close (fildes[1]);

      dispose_fd_bitmap (fd_bitmap);
      discard_unwind_frame ("pipe-file-descriptors");

      cmd = cmd->value.Connection->second;
    }

  lastpid = last_made_pid;

  /* Now execute the rightmost command in the pipeline.  */
  if (ignore_return && cmd)
    cmd->flags |= CMD_IGNORE_RETURN;

  lastpipe_flag = 0;

  begin_unwind_frame ("lastpipe-exec");
  lstdin = -1;
  /* If the `lastpipe' option is set with shopt, and job control is not
     enabled, execute the last element of non-async pipelines in the
     current shell environment. */
  if (lastpipe_opt && job_control == 0 && asynchronous == 0 && pipe_out == NO_PIPE && prev > 0)
    {
      lstdin = move_to_high_fd (0, 1, -1);
      if (lstdin > 0)
	{
	  do_piping (prev, pipe_out);
	  prev = NO_PIPE;
	  add_unwind_protect (restore_stdin, lstdin);
	  lastpipe_flag = 1;
	  old_frozen = freeze_jobs_list ();
	  lastpipe_jid = stop_pipeline (0, (COMMAND *)NULL);	/* XXX */
	  add_unwind_protect (lastpipe_cleanup, old_frozen);
#if defined (JOB_CONTROL)
	  UNBLOCK_CHILD (oset);		/* XXX */
#endif
	}
      if (cmd)
	cmd->flags |= CMD_LASTPIPE;
    }	  
  if (prev >= 0)
    add_unwind_protect (close, prev);

  exec_result = execute_command_internal (cmd, asynchronous, prev, pipe_out, fds_to_close);

  if (lstdin > 0)
    restore_stdin (lstdin);

  if (prev >= 0)
    close (prev);

#if defined (JOB_CONTROL)
  UNBLOCK_CHILD (oset);
#endif

  QUIT;

  if (lastpipe_flag)
    {
#if defined (JOB_CONTROL)
      if (INVALID_JOB (lastpipe_jid) == 0)
        {
          append_process (savestring (the_printed_command_except_trap), dollar_dollar_pid, exec_result, lastpipe_jid);
          lstdin = wait_for (lastpid, 0);
        }
      else
        lstdin = wait_for_single_pid (lastpid, 0);		/* checks bgpids list */
#else
      lstdin = wait_for (lastpid, 0);
#endif

#if defined (JOB_CONTROL)
      /* If wait_for removes the job from the jobs table, use result of last
	 command as pipeline's exit status as usual.  The jobs list can get
	 frozen and unfrozen at inconvenient times if there are multiple pipelines
	 running simultaneously. */
      if (INVALID_JOB (lastpipe_jid) == 0)
	exec_result = job_exit_status (lastpipe_jid);
      else if (pipefail_opt)
	exec_result = exec_result | lstdin;	/* XXX */
      /* otherwise we use exec_result */
#endif

      set_jobs_list_frozen (old_frozen);
    }

  discard_unwind_frame ("lastpipe-exec");

  return (exec_result);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\execute_cmd.c:2,463
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\execute_cmd.c:2,642
parsing error 
{
  COMMAND *tc, *second;
  int ignore_return, exec_result, was_error_trap, invert;
  volatile int save_line_number;

  ignore_return = (command->flags & CMD_IGNORE_RETURN) != 0;

  switch (command->value.Connection->connector)
    {
    /* Do the first command asynchronously. */
    case '&':
      tc = command->value.Connection->first;
      if (tc == 0)
	return (EXECUTION_SUCCESS);

      if (ignore_return)
	tc->flags |= CMD_IGNORE_RETURN;
      tc->flags |= CMD_AMPERSAND;

      /* If this shell was compiled without job control support,
	 if we are currently in a subshell via `( xxx )', or if job
	 control is not active then the standard input for an
	 asynchronous command is forced to /dev/null. */
#if defined (JOB_CONTROL)
      if ((subshell_environment || !job_control) && !stdin_redir)
#else
      if (!stdin_redir)
#endif /* JOB_CONTROL */
	tc->flags |= CMD_STDIN_REDIR;

      exec_result = execute_command_internal (tc, 1, pipe_in, pipe_out, fds_to_close);
      QUIT;

      if (tc->flags & CMD_STDIN_REDIR)
	tc->flags &= ~CMD_STDIN_REDIR;

      second = command->value.Connection->second;
      if (second)
	{
	  if (ignore_return)
	    second->flags |= CMD_IGNORE_RETURN;

	  exec_result = execute_command_internal (second, asynchronous, pipe_in, pipe_out, fds_to_close);
	}

      break;

    /* Just call execute command on both sides. */
    case ';':
      if (ignore_return)
	{
	  if (command->value.Connection->first)
	    command->value.Connection->first->flags |= CMD_IGNORE_RETURN;
	  if (command->value.Connection->second)
	    command->value.Connection->second->flags |= CMD_IGNORE_RETURN;
	}
      executing_list++;
      QUIT;

#if 1
      execute_command (command->value.Connection->first);
#else
      execute_command_internal (command->value.Connection->first,
				  asynchronous, pipe_in, pipe_out,
				  fds_to_close);
#endif

      QUIT;
      optimize_fork (command);			/* XXX */
      exec_result = execute_command_internal (command->value.Connection->second,
				      asynchronous, pipe_in, pipe_out,
				      fds_to_close);
      executing_list--;
      break;

    case '|':
      was_error_trap = signal_is_trapped (ERROR_TRAP) && signal_is_ignored (ERROR_TRAP) == 0;
      invert = (command->flags & CMD_INVERT_RETURN) != 0;
      ignore_return = (command->flags & CMD_IGNORE_RETURN) != 0;

      line_number_for_err_trap = line_number;	/* XXX - save value? */
      exec_result = execute_pipeline (command, asynchronous, pipe_in, pipe_out, fds_to_close);

      if (asynchronous)
	{
	  exec_result = EXECUTION_SUCCESS;
	  invert = 0;
	}

      if (was_error_trap && ignore_return == 0 && invert == 0 && exec_result != EXECUTION_SUCCESS)
	{
	  last_command_exit_value = exec_result;
	  save_line_number = line_number;
	  line_number = line_number_for_err_trap;
	  run_error_trap ();
	  line_number = save_line_number;
	}

      if (ignore_return == 0 && invert == 0 && exit_immediately_on_error && exec_result != EXECUTION_SUCCESS)
	{
	  last_command_exit_value = exec_result;
	  run_pending_traps ();
	  jump_to_top_level (ERREXIT);
	}

      break;

    case AND_AND:
    case OR_OR:
      if (asynchronous)
	{
	  /* If we have something like `a && b &' or `a || b &', run the
	     && or || stuff in a subshell.  Force a subshell and just call
	     execute_command_internal again.  Leave asynchronous on
	     so that we get a report from the parent shell about the
	     background job. */
	  command->flags |= CMD_FORCE_SUBSHELL;
	  exec_result = execute_command_internal (command, 1, pipe_in, pipe_out, fds_to_close);
	  break;
	}

      /* Execute the first command.  If the result of that is successful
	 and the connector is AND_AND, or the result is not successful
	 and the connector is OR_OR, then execute the second command,
	 otherwise return. */

      executing_list++;
      if (command->value.Connection->first)
	command->value.Connection->first->flags |= CMD_IGNORE_RETURN;

#if 1
      exec_result = execute_command (command->value.Connection->first);
#else
      exec_result = execute_command_internal (command->value.Connection->first, 0, NO_PIPE, NO_PIPE, fds_to_close);
#endif
      QUIT;
      if (((command->value.Connection->connector == AND_AND) &&
	   (exec_result == EXECUTION_SUCCESS)) ||
	  ((command->value.Connection->connector == OR_OR) &&
	   (exec_result != EXECUTION_SUCCESS)))
	{
	  optimize_fork (command);

	  second = command->value.Connection->second;
	  if (ignore_return && second)
	    second->flags |= CMD_IGNORE_RETURN;

	  exec_result = execute_command (second);
	}
      executing_list--;
      break;

    default:
      command_error ("execute_connection", CMDERR_BADCONN, command->value.Connection->connector, 0);
      jump_to_top_level (DISCARD);
      exec_result = EXECUTION_FAILURE;
    }

  return exec_result;
}
warning: parse error {
  COMMAND *tc, *second;
  int ignore_return, exec_result, was_error_trap, invert;
  volatile int save_line_number;

  ignore_return = (command->flags & CMD_IGNORE_RETURN) != 0;

  switch (command->value.Connection->connector)
    {
    /* Do the first command asynchronously. */
    case '&':
      tc = command->value.Connection->first;
      if (tc == 0)
	return (EXECUTION_SUCCESS);

      if (ignore_return)
	tc->flags |= CMD_IGNORE_RETURN;
      tc->flags |= CMD_AMPERSAND;

      /* If this shell was compiled without job control support,
	 if we are currently in a subshell via `( xxx )', or if job
	 control is not active then the standard input for an
	 asynchronous command is forced to /dev/null. */
#if defined (JOB_CONTROL)
      if ((subshell_environment || !job_control) && !stdin_redir)
#else
      if (!stdin_redir)
#endif /* JOB_CONTROL */
	tc->flags |= CMD_STDIN_REDIR;

      exec_result = execute_command_internal (tc, 1, pipe_in, pipe_out, fds_to_close);
      QUIT;

      if (tc->flags & CMD_STDIN_REDIR)
	tc->flags &= ~CMD_STDIN_REDIR;

      second = command->value.Connection->second;
      if (second)
	{
	  if (ignore_return)
	    second->flags |= CMD_IGNORE_RETURN;

	  exec_result = execute_command_internal (second, asynchronous, pipe_in, pipe_out, fds_to_close);
	}

      break;

    /* Just call execute command on both sides. */
    case ';':
      if (ignore_return)
	{
	  if (command->value.Connection->first)
	    command->value.Connection->first->flags |= CMD_IGNORE_RETURN;
	  if (command->value.Connection->second)
	    command->value.Connection->second->flags |= CMD_IGNORE_RETURN;
	}
      executing_list++;
      QUIT;

#if 1
      execute_command (command->value.Connection->first);
#else
      execute_command_internal (command->value.Connection->first,
				  asynchronous, pipe_in, pipe_out,
				  fds_to_close);
#endif

      QUIT;
      optimize_fork (command);			/* XXX */
      exec_result = execute_command_internal (command->value.Connection->second,
				      asynchronous, pipe_in, pipe_out,
				      fds_to_close);
      executing_list--;
      break;

    case '|':
      was_error_trap = signal_is_trapped (ERROR_TRAP) && signal_is_ignored (ERROR_TRAP) == 0;
      invert = (command->flags & CMD_INVERT_RETURN) != 0;
      ignore_return = (command->flags & CMD_IGNORE_RETURN) != 0;

      line_number_for_err_trap = line_number;	/* XXX - save value? */
      exec_result = execute_pipeline (command, asynchronous, pipe_in, pipe_out, fds_to_close);

      if (asynchronous)
	{
	  exec_result = EXECUTION_SUCCESS;
	  invert = 0;
	}

      if (was_error_trap && ignore_return == 0 && invert == 0 && exec_result != EXECUTION_SUCCESS)
	{
	  last_command_exit_value = exec_result;
	  save_line_number = line_number;
	  line_number = line_number_for_err_trap;
	  run_error_trap ();
	  line_number = save_line_number;
	}

      if (ignore_return == 0 && invert == 0 && exit_immediately_on_error && exec_result != EXECUTION_SUCCESS)
	{
	  last_command_exit_value = exec_result;
	  run_pending_traps ();
	  jump_to_top_level (ERREXIT);
	}

      break;

    case AND_AND:
    case OR_OR:
      if (asynchronous)
	{
	  /* If we have something like `a && b &' or `a || b &', run the
	     && or || stuff in a subshell.  Force a subshell and just call
	     execute_command_internal again.  Leave asynchronous on
	     so that we get a report from the parent shell about the
	     background job. */
	  command->flags |= CMD_FORCE_SUBSHELL;
	  exec_result = execute_command_internal (command, 1, pipe_in, pipe_out, fds_to_close);
	  break;
	}

      /* Execute the first command.  If the result of that is successful
	 and the connector is AND_AND, or the result is not successful
	 and the connector is OR_OR, then execute the second command,
	 otherwise return. */

      executing_list++;
      if (command->value.Connection->first)
	command->value.Connection->first->flags |= CMD_IGNORE_RETURN;

#if 1
      exec_result = execute_command (command->value.Connection->first);
#else
      exec_result = execute_command_internal (command->value.Connection->first, 0, NO_PIPE, NO_PIPE, fds_to_close);
#endif
      QUIT;
      if (((command->value.Connection->connector == AND_AND) &&
	   (exec_result == EXECUTION_SUCCESS)) ||
	  ((command->value.Connection->connector == OR_OR) &&
	   (exec_result != EXECUTION_SUCCESS)))
	{
	  optimize_fork (command);

	  second = command->value.Connection->second;
	  if (ignore_return && second)
	    second->flags |= CMD_IGNORE_RETURN;

	  exec_result = execute_command (second);
	}
      executing_list--;
      break;

    default:
      command_error ("execute_connection", CMDERR_BADCONN, command->value.Connection->connector, 0);
      jump_to_top_level (DISCARD);
      exec_result = EXECUTION_FAILURE;
    }

  return exec_result;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\execute_cmd.c:2,646
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\execute_cmd.c:2,821
parsing error 
{
  register WORD_LIST *releaser, *list;
  SHELL_VAR *v;
  char *identifier;
  int retval, save_line_number;
#if 0
  SHELL_VAR *old_value = (SHELL_VAR *)NULL; /* Remember the old value of x. */
#endif

  save_line_number = line_number;
  if (check_identifier (for_command->name, 1) == 0)
    {
      if (posixly_correct && interactive_shell == 0)
	{
	  last_command_exit_value = EX_BADUSAGE;
	  jump_to_top_level (ERREXIT);
	}
      return (EXECUTION_FAILURE);
    }

  loop_level++;
  identifier = for_command->name->word;

  line_number = for_command->line;	/* for expansion error messages */
  list = releaser = expand_words_no_vars (for_command->map_list);

  begin_unwind_frame ("for");
  add_unwind_protect (dispose_words, releaser);

#if 0
  if (lexical_scoping)
    {
      old_value = copy_variable (find_variable (identifier));
      if (old_value)
	add_unwind_protect (dispose_variable, old_value);
    }
#endif

  if (for_command->flags & CMD_IGNORE_RETURN)
    for_command->action->flags |= CMD_IGNORE_RETURN;

  for (retval = EXECUTION_SUCCESS; list; list = list->next)
    {
      QUIT;

      line_number = for_command->line;

      /* Remember what this command looks like, for debugger. */
      command_string_index = 0;
      print_for_command_head (for_command);

      if (echo_command_at_execute)
	xtrace_print_for_command_head (for_command);

      /* Save this command unless it's a trap command and we're not running
	 a debug trap. */
      if (signal_in_progress (DEBUG_TRAP) == 0 && running_trap == 0)
	{
	  FREE (the_printed_command_except_trap);
	  the_printed_command_except_trap = savestring (the_printed_command);
	}

      retval = run_debug_trap ();
#if defined (DEBUGGER)
      /* In debugging mode, if the DEBUG trap returns a non-zero status, we
	 skip the command. */
      if (debugging_mode && retval != EXECUTION_SUCCESS)
        continue;
#endif

      this_command_name = (char *)NULL;
      /* XXX - special ksh93 for command index variable handling */
      v = find_variable_last_nameref (identifier, 1);
      if (v && nameref_p (v))
	{
	  if (valid_nameref_value (list->word->word, 1) == 0)
	    {
	      sh_invalidid (list->word->word);
	      v = 0;
	    }
	  else if (readonly_p (v))
	    err_readonly (name_cell (v));
	  else
	    v = bind_variable_value (v, list->word->word, ASS_NAMEREF);
	}
      else
	v = bind_variable (identifier, list->word->word, 0);

      if (v == 0 || readonly_p (v) || noassign_p (v))
	{
	  line_number = save_line_number;
	  if (v && readonly_p (v) && interactive_shell == 0 && posixly_correct)
	    {
	      last_command_exit_value = EXECUTION_FAILURE;
	      jump_to_top_level (FORCE_EOF);
	    }
	  else
	    {
	      dispose_words (releaser);
	      discard_unwind_frame ("for");
	      loop_level--;
	      return (EXECUTION_FAILURE);
	    }
	}

      if (ifsname (identifier))
	setifs (v);
      else
	stupidly_hack_special_variables (identifier);

      retval = execute_command (for_command->action);
      REAP ();
      QUIT;

      if (breaking)
	{
	  breaking--;
	  break;
	}

      if (continuing)
	{
	  continuing--;
	  if (continuing)
	    break;
	}
    }

  loop_level--;
  line_number = save_line_number;

#if 0
  if (lexical_scoping)
    {
      if (!old_value)
        unbind_variable (identifier);
      else
	{
	  SHELL_VAR *new_value;

	  new_value = bind_variable (identifier, value_cell (old_value), 0);
	  new_value->attributes = old_value->attributes;
	  dispose_variable (old_value);
	}
    }
#endif

  dispose_words (releaser);
  discard_unwind_frame ("for");
  return (retval);
}
warning: parse error {
  register WORD_LIST *releaser, *list;
  SHELL_VAR *v;
  char *identifier;
  int retval, save_line_number;
#if 0
  SHELL_VAR *old_value = (SHELL_VAR *)NULL; /* Remember the old value of x. */
#endif

  save_line_number = line_number;
  if (check_identifier (for_command->name, 1) == 0)
    {
      if (posixly_correct && interactive_shell == 0)
	{
	  last_command_exit_value = EX_BADUSAGE;
	  jump_to_top_level (ERREXIT);
	}
      return (EXECUTION_FAILURE);
    }

  loop_level++;
  identifier = for_command->name->word;

  line_number = for_command->line;	/* for expansion error messages */
  list = releaser = expand_words_no_vars (for_command->map_list);

  begin_unwind_frame ("for");
  add_unwind_protect (dispose_words, releaser);

#if 0
  if (lexical_scoping)
    {
      old_value = copy_variable (find_variable (identifier));
      if (old_value)
	add_unwind_protect (dispose_variable, old_value);
    }
#endif

  if (for_command->flags & CMD_IGNORE_RETURN)
    for_command->action->flags |= CMD_IGNORE_RETURN;

  for (retval = EXECUTION_SUCCESS; list; list = list->next)
    {
      QUIT;

      line_number = for_command->line;

      /* Remember what this command looks like, for debugger. */
      command_string_index = 0;
      print_for_command_head (for_command);

      if (echo_command_at_execute)
	xtrace_print_for_command_head (for_command);

      /* Save this command unless it's a trap command and we're not running
	 a debug trap. */
      if (signal_in_progress (DEBUG_TRAP) == 0 && running_trap == 0)
	{
	  FREE (the_printed_command_except_trap);
	  the_printed_command_except_trap = savestring (the_printed_command);
	}

      retval = run_debug_trap ();
#if defined (DEBUGGER)
      /* In debugging mode, if the DEBUG trap returns a non-zero status, we
	 skip the command. */
      if (debugging_mode && retval != EXECUTION_SUCCESS)
        continue;
#endif

      this_command_name = (char *)NULL;
      /* XXX - special ksh93 for command index variable handling */
      v = find_variable_last_nameref (identifier, 1);
      if (v && nameref_p (v))
	{
	  if (valid_nameref_value (list->word->word, 1) == 0)
	    {
	      sh_invalidid (list->word->word);
	      v = 0;
	    }
	  else if (readonly_p (v))
	    err_readonly (name_cell (v));
	  else
	    v = bind_variable_value (v, list->word->word, ASS_NAMEREF);
	}
      else
	v = bind_variable (identifier, list->word->word, 0);

      if (v == 0 || readonly_p (v) || noassign_p (v))
	{
	  line_number = save_line_number;
	  if (v && readonly_p (v) && interactive_shell == 0 && posixly_correct)
	    {
	      last_command_exit_value = EXECUTION_FAILURE;
	      jump_to_top_level (FORCE_EOF);
	    }
	  else
	    {
	      dispose_words (releaser);
	      discard_unwind_frame ("for");
	      loop_level--;
	      return (EXECUTION_FAILURE);
	    }
	}

      if (ifsname (identifier))
	setifs (v);
      else
	stupidly_hack_special_variables (identifier);

      retval = execute_command (for_command->action);
      REAP ();
      QUIT;

      if (breaking)
	{
	  breaking--;
	  break;
	}

      if (continuing)
	{
	  continuing--;
	  if (continuing)
	    break;
	}
    }

  loop_level--;
  line_number = save_line_number;

#if 0
  if (lexical_scoping)
    {
      if (!old_value)
        unbind_variable (identifier);
      else
	{
	  SHELL_VAR *new_value;

	  new_value = bind_variable (identifier, value_cell (old_value), 0);
	  new_value->attributes = old_value->attributes;
	  dispose_variable (old_value);
	}
    }
#endif

  dispose_words (releaser);
  discard_unwind_frame ("for");
  return (retval);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\execute_cmd.c:2,823
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\execute_cmd.c:3,473
parsing error 
{
  register WORD_LIST *list;
  WORD_LIST *wlist, *es;
  PATTERN_LIST *clauses;
  char *word, *pattern;
  int retval, match, ignore_return, save_line_number, qflags;

  save_line_number = line_number;
  line_number = case_command->line;

  command_string_index = 0;
  print_case_command_head (case_command);

  if (echo_command_at_execute)
    xtrace_print_case_command_head (case_command);

#if 0
  if (signal_in_progress (DEBUG_TRAP) == 0 && (this_command_name == 0 || (STREQ (this_command_name, "trap") == 0)))
#else
  if (signal_in_progress (DEBUG_TRAP) == 0 && running_trap == 0)
#endif
    {
      FREE (the_printed_command_except_trap);
      the_printed_command_except_trap = savestring (the_printed_command);
    }

  retval = run_debug_trap();
#if defined (DEBUGGER)
  /* In debugging mode, if the DEBUG trap returns a non-zero status, we
     skip the command. */
  if (debugging_mode && retval != EXECUTION_SUCCESS)
    {
      line_number = save_line_number;
      return (EXECUTION_SUCCESS);
    }
#endif

  /* Use the same expansions (the ones POSIX specifies) as the patterns;
     dequote the resulting string (as POSIX specifies) since the quotes in
     patterns are handled specially below. We have to do it in this order
     because we're not supposed to perform word splitting. */
  wlist = expand_word_leave_quoted (case_command->word, 0);
  if (wlist)
    {
      char *t;
      t = string_list (wlist);
      word = dequote_string (t);
      free (t);
    }
  else
    word = savestring ("");
  dispose_words (wlist);

  retval = EXECUTION_SUCCESS;
  ignore_return = case_command->flags & CMD_IGNORE_RETURN;

  begin_unwind_frame ("case");
  add_unwind_protect (xfree, word);

#define EXIT_CASE()  goto exit_case_command

  for (clauses = case_command->clauses; clauses; clauses = clauses->next)
    {
      QUIT;
      for (list = clauses->patterns; list; list = list->next)
	{
	  es = expand_word_leave_quoted (list->word, 0);

	  if (es && es->word && es->word->word && *(es->word->word))
	    {
	      /* Convert quoted null strings into empty strings. */
	      qflags = QGLOB_CVTNULL;

	      /* We left CTLESC in place quoting CTLESC and CTLNUL after the
	      	 call to expand_word_leave_quoted; tell quote_string_for_globbing
	      	 to remove those here. This works for both unquoted portions of
		 the word (which call quote_escapes) and quoted portions
		 (which call quote_string). */
	      qflags |= QGLOB_CTLESC;
	      pattern = quote_string_for_globbing (es->word->word, qflags);
	    }
	  else
	    {
	      pattern = (char *)xmalloc (1);
	      pattern[0] = '\0';
	    }

	  /* Since the pattern does not undergo quote removal (as per
	     Posix.2, section 3.9.4.3), the strmatch () call must be able
	     to recognize backslashes as escape characters. */
	  match = strmatch (pattern, word, FNMATCH_EXTFLAG|FNMATCH_IGNCASE) != FNM_NOMATCH;
	  free (pattern);

	  dispose_words (es);

	  if (match)
	    {
	      do
		{
		  if (clauses->action && ignore_return)
		    clauses->action->flags |= CMD_IGNORE_RETURN;
		  retval = execute_command (clauses->action);
		}
	      while ((clauses->flags & CASEPAT_FALLTHROUGH) && (clauses = clauses->next));
	      if (clauses == 0 || (clauses->flags & CASEPAT_TESTNEXT) == 0)
		EXIT_CASE ();
	      else
		break;
	    }

	  QUIT;
	}
    }

exit_case_command:
  free (word);
  discard_unwind_frame ("case");
  line_number = save_line_number;
  return (retval);
}
warning: parse error {
  register WORD_LIST *list;
  WORD_LIST *wlist, *es;
  PATTERN_LIST *clauses;
  char *word, *pattern;
  int retval, match, ignore_return, save_line_number, qflags;

  save_line_number = line_number;
  line_number = case_command->line;

  command_string_index = 0;
  print_case_command_head (case_command);

  if (echo_command_at_execute)
    xtrace_print_case_command_head (case_command);

#if 0
  if (signal_in_progress (DEBUG_TRAP) == 0 && (this_command_name == 0 || (STREQ (this_command_name, "trap") == 0)))
#else
  if (signal_in_progress (DEBUG_TRAP) == 0 && running_trap == 0)
#endif
    {
      FREE (the_printed_command_except_trap);
      the_printed_command_except_trap = savestring (the_printed_command);
    }

  retval = run_debug_trap();
#if defined (DEBUGGER)
  /* In debugging mode, if the DEBUG trap returns a non-zero status, we
     skip the command. */
  if (debugging_mode && retval != EXECUTION_SUCCESS)
    {
      line_number = save_line_number;
      return (EXECUTION_SUCCESS);
    }
#endif

  /* Use the same expansions (the ones POSIX specifies) as the patterns;
     dequote the resulting string (as POSIX specifies) since the quotes in
     patterns are handled specially below. We have to do it in this order
     because we're not supposed to perform word splitting. */
  wlist = expand_word_leave_quoted (case_command->word, 0);
  if (wlist)
    {
      char *t;
      t = string_list (wlist);
      word = dequote_string (t);
      free (t);
    }
  else
    word = savestring ("");
  dispose_words (wlist);

  retval = EXECUTION_SUCCESS;
  ignore_return = case_command->flags & CMD_IGNORE_RETURN;

  begin_unwind_frame ("case");
  add_unwind_protect (xfree, word);

#define EXIT_CASE()  goto exit_case_command

  for (clauses = case_command->clauses; clauses; clauses = clauses->next)
    {
      QUIT;
      for (list = clauses->patterns; list; list = list->next)
	{
	  es = expand_word_leave_quoted (list->word, 0);

	  if (es && es->word && es->word->word && *(es->word->word))
	    {
	      /* Convert quoted null strings into empty strings. */
	      qflags = QGLOB_CVTNULL;

	      /* We left CTLESC in place quoting CTLESC and CTLNUL after the
	      	 call to expand_word_leave_quoted; tell quote_string_for_globbing
	      	 to remove those here. This works for both unquoted portions of
		 the word (which call quote_escapes) and quoted portions
		 (which call quote_string). */
	      qflags |= QGLOB_CTLESC;
	      pattern = quote_string_for_globbing (es->word->word, qflags);
	    }
	  else
	    {
	      pattern = (char *)xmalloc (1);
	      pattern[0] = '\0';
	    }

	  /* Since the pattern does not undergo quote removal (as per
	     Posix.2, section 3.9.4.3), the strmatch () call must be able
	     to recognize backslashes as escape characters. */
	  match = strmatch (pattern, word, FNMATCH_EXTFLAG|FNMATCH_IGNCASE) != FNM_NOMATCH;
	  free (pattern);

	  dispose_words (es);

	  if (match)
	    {
	      do
		{
		  if (clauses->action && ignore_return)
		    clauses->action->flags |= CMD_IGNORE_RETURN;
		  retval = execute_command (clauses->action);
		}
	      while ((clauses->flags & CASEPAT_FALLTHROUGH) && (clauses = clauses->next));
	      if (clauses == 0 || (clauses->flags & CASEPAT_TESTNEXT) == 0)
		EXIT_CASE ();
	      else
		break;
	    }

	  QUIT;
	}
    }

exit_case_command:
  free (word);
  discard_unwind_frame ("case");
  line_number = save_line_number;
  return (retval);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\execute_cmd.c:3,475
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\execute_cmd.c:3,603
parsing error 
{
  return (execute_while_or_until (while_command, CMD_WHILE));
}
warning: parse error {
  return (execute_while_or_until (while_command, CMD_WHILE));
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\execute_cmd.c:3,605
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\execute_cmd.c:3,611
parsing error 
{
  return (execute_while_or_until (while_command, CMD_UNTIL));
}
warning: parse error {
  return (execute_while_or_until (while_command, CMD_UNTIL));
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\execute_cmd.c:3,613
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\execute_cmd.c:3,623
parsing error 
{
  int return_value, body_status;

  body_status = EXECUTION_SUCCESS;
  loop_level++;

  while_command->test->flags |= CMD_IGNORE_RETURN;
  if (while_command->flags & CMD_IGNORE_RETURN)
    while_command->action->flags |= CMD_IGNORE_RETURN;

  while (1)
    {
      return_value = execute_command (while_command->test);
      REAP ();

      /* Need to handle `break' in the test when we would break out of the
         loop.  The job control code will set `breaking' to loop_level
         when a job in a loop is stopped with SIGTSTP.  If the stopped job
         is in the loop test, `breaking' will not be reset unless we do
         this, and the shell will cease to execute commands.  The same holds
         true for `continue'. */
      if (type == CMD_WHILE && return_value != EXECUTION_SUCCESS)
	{
	  if (breaking)
	    breaking--;
	  if (continuing)
	    continuing--;
	  break;
	}
      if (type == CMD_UNTIL && return_value == EXECUTION_SUCCESS)
	{
	  if (breaking)
	    breaking--;
	  if (continuing)
	    continuing--;
	  break;
	}

      QUIT;
      body_status = execute_command (while_command->action);
      QUIT;

      if (breaking)
	{
	  breaking--;
	  break;
	}

      if (continuing)
	{
	  continuing--;
	  if (continuing)
	    break;
	}
    }
  loop_level--;

  return (body_status);
}
warning: parse error {
  int return_value, body_status;

  body_status = EXECUTION_SUCCESS;
  loop_level++;

  while_command->test->flags |= CMD_IGNORE_RETURN;
  if (while_command->flags & CMD_IGNORE_RETURN)
    while_command->action->flags |= CMD_IGNORE_RETURN;

  while (1)
    {
      return_value = execute_command (while_command->test);
      REAP ();

      /* Need to handle `break' in the test when we would break out of the
         loop.  The job control code will set `breaking' to loop_level
         when a job in a loop is stopped with SIGTSTP.  If the stopped job
         is in the loop test, `breaking' will not be reset unless we do
         this, and the shell will cease to execute commands.  The same holds
         true for `continue'. */
      if (type == CMD_WHILE && return_value != EXECUTION_SUCCESS)
	{
	  if (breaking)
	    breaking--;
	  if (continuing)
	    continuing--;
	  break;
	}
      if (type == CMD_UNTIL && return_value == EXECUTION_SUCCESS)
	{
	  if (breaking)
	    breaking--;
	  if (continuing)
	    continuing--;
	  break;
	}

      QUIT;
      body_status = execute_command (while_command->action);
      QUIT;

      if (breaking)
	{
	  breaking--;
	  break;
	}

      if (continuing)
	{
	  continuing--;
	  if (continuing)
	    break;
	}
    }
  loop_level--;

  return (body_status);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\execute_cmd.c:3,626
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\execute_cmd.c:3,690
parsing error 
{
  int return_value, save_line_number;

  save_line_number = line_number;
  if_command->test->flags |= CMD_IGNORE_RETURN;
  return_value = execute_command (if_command->test);
  line_number = save_line_number;

  if (return_value == EXECUTION_SUCCESS)
    {
      QUIT;

      if (if_command->true_case && (if_command->flags & CMD_IGNORE_RETURN))
	if_command->true_case->flags |= CMD_IGNORE_RETURN;

      return (execute_command (if_command->true_case));
    }
  else
    {
      QUIT;

      if (if_command->false_case && (if_command->flags & CMD_IGNORE_RETURN))
	if_command->false_case->flags |= CMD_IGNORE_RETURN;

      return (execute_command (if_command->false_case));
    }
}
warning: parse error {
  int return_value, save_line_number;

  save_line_number = line_number;
  if_command->test->flags |= CMD_IGNORE_RETURN;
  return_value = execute_command (if_command->test);
  line_number = save_line_number;

  if (return_value == EXECUTION_SUCCESS)
    {
      QUIT;

      if (if_command->true_case && (if_command->flags & CMD_IGNORE_RETURN))
	if_command->true_case->flags |= CMD_IGNORE_RETURN;

      return (execute_command (if_command->true_case));
    }
  else
    {
      QUIT;

      if (if_command->false_case && (if_command->flags & CMD_IGNORE_RETURN))
	if_command->false_case->flags |= CMD_IGNORE_RETURN;

      return (execute_command (if_command->false_case));
    }
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\execute_cmd.c:3,692
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\execute_cmd.c:3,988
parsing error 
{
  SHELL_VAR *var;

  if (arg == 0)
    arg = "";
  var = bind_variable ("_", arg, 0);
  if (var)
    VUNSETATTR (var, att_exported);
}
warning: parse error {
  SHELL_VAR *var;

  if (arg == 0)
    arg = "";
  var = bind_variable ("_", arg, 0);
  if (var)
    VUNSETATTR (var, att_exported);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\execute_cmd.c:3,990
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\execute_cmd.c:4,004
parsing error 
{
  int r;
  int forcefork, fork_flags;
  REDIRECT *rd;

  for (forcefork = 0, rd = redirects; rd; rd = rd->next)
    {
      forcefork += rd->rflags & REDIR_VARASSIGN;
      /* Safety */
      forcefork += (rd->redirector.dest == 0 || fd_is_bash_input (rd->redirector.dest)) && (INPUT_REDIRECT (rd->instruction) || TRANSLATE_REDIRECT (rd->instruction) || rd->instruction == r_close_this);
    }

  if (forcefork || pipe_in != NO_PIPE || pipe_out != NO_PIPE || async)
    {
      /* We have a null command, but we really want a subshell to take
	 care of it.  Just fork, do piping and redirections, and exit. */
      fork_flags = async ? FORK_ASYNC : 0;
      if (make_child ((char *)NULL, fork_flags) == 0)
	{
	  /* Cancel traps, in trap.c. */
	  restore_original_signals ();		/* XXX */

	  do_piping (pipe_in, pipe_out);

#if defined (COPROCESS_SUPPORT)
	  coproc_closeall ();
#endif

	  interactive = 0;			/* XXX */

	  subshell_environment = 0;
	  if (async)
	    subshell_environment |= SUBSHELL_ASYNC;
	  if (pipe_in != NO_PIPE || pipe_out != NO_PIPE)
	    subshell_environment |= SUBSHELL_PIPE;

	  if (do_redirections (redirects, RX_ACTIVE) == 0)
	    exit (EXECUTION_SUCCESS);
	  else
	    exit (EXECUTION_FAILURE);
	}
      else
	{
	  close_pipes (pipe_in, pipe_out);
#if defined (PROCESS_SUBSTITUTION) && defined (HAVE_DEV_FD)
	  if (pipe_out == NO_PIPE)
	    unlink_fifo_list ();
#endif
	  return (EXECUTION_SUCCESS);
	}
    }
  else
    {
      /* Even if there aren't any command names, pretend to do the
	 redirections that are specified.  The user expects the side
	 effects to take place.  If the redirections fail, then return
	 failure.  Otherwise, if a command substitution took place while
	 expanding the command or a redirection, return the value of that
	 substitution.  Otherwise, return EXECUTION_SUCCESS. */

      r = do_redirections (redirects, RX_ACTIVE|RX_UNDOABLE);
      cleanup_redirects (redirection_undo_list);
      redirection_undo_list = (REDIRECT *)NULL;

      if (r != 0)
	return (EXECUTION_FAILURE);
      else if (last_command_subst_pid != NO_PID)
	return (last_command_exit_value);
      else
	return (EXECUTION_SUCCESS);
    }
}
warning: parse error {
  int r;
  int forcefork, fork_flags;
  REDIRECT *rd;

  for (forcefork = 0, rd = redirects; rd; rd = rd->next)
    {
      forcefork += rd->rflags & REDIR_VARASSIGN;
      /* Safety */
      forcefork += (rd->redirector.dest == 0 || fd_is_bash_input (rd->redirector.dest)) && (INPUT_REDIRECT (rd->instruction) || TRANSLATE_REDIRECT (rd->instruction) || rd->instruction == r_close_this);
    }

  if (forcefork || pipe_in != NO_PIPE || pipe_out != NO_PIPE || async)
    {
      /* We have a null command, but we really want a subshell to take
	 care of it.  Just fork, do piping and redirections, and exit. */
      fork_flags = async ? FORK_ASYNC : 0;
      if (make_child ((char *)NULL, fork_flags) == 0)
	{
	  /* Cancel traps, in trap.c. */
	  restore_original_signals ();		/* XXX */

	  do_piping (pipe_in, pipe_out);

#if defined (COPROCESS_SUPPORT)
	  coproc_closeall ();
#endif

	  interactive = 0;			/* XXX */

	  subshell_environment = 0;
	  if (async)
	    subshell_environment |= SUBSHELL_ASYNC;
	  if (pipe_in != NO_PIPE || pipe_out != NO_PIPE)
	    subshell_environment |= SUBSHELL_PIPE;

	  if (do_redirections (redirects, RX_ACTIVE) == 0)
	    exit (EXECUTION_SUCCESS);
	  else
	    exit (EXECUTION_FAILURE);
	}
      else
	{
	  close_pipes (pipe_in, pipe_out);
#if defined (PROCESS_SUBSTITUTION) && defined (HAVE_DEV_FD)
	  if (pipe_out == NO_PIPE)
	    unlink_fifo_list ();
#endif
	  return (EXECUTION_SUCCESS);
	}
    }
  else
    {
      /* Even if there aren't any command names, pretend to do the
	 redirections that are specified.  The user expects the side
	 effects to take place.  If the redirections fail, then return
	 failure.  Otherwise, if a command substitution took place while
	 expanding the command or a redirection, return the value of that
	 substitution.  Otherwise, return EXECUTION_SUCCESS. */

      r = do_redirections (redirects, RX_ACTIVE|RX_UNDOABLE);
      cleanup_redirects (redirection_undo_list);
      redirection_undo_list = (REDIRECT *)NULL;

      if (r != 0)
	return (EXECUTION_FAILURE);
      else if (last_command_subst_pid != NO_PID)
	return (last_command_exit_value);
      else
	return (EXECUTION_SUCCESS);
    }
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\execute_cmd.c:4,007
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\execute_cmd.c:4,083
parsing error 
{
  WORD_LIST *w, *wcmd;
  struct builtin *b;
  int assoc, global, array, integer;

  if (words == 0)
    return;

  b = 0;
  assoc = global = array = integer = 0;

  /* Skip over assignment statements preceding a command name */
  wcmd = words;
  for (wcmd = words; wcmd; wcmd = wcmd->next)
    if ((wcmd->word->flags & W_ASSIGNMENT) == 0)
      break;
  /* Posix (post-2008) says that `command' doesn't change whether
     or not the builtin it shadows is a `declaration command', even
     though it removes other special builtin properties.  In Posix
     mode, we skip over one or more instances of `command' and
     deal with the next word as the assignment builtin. */
  while (posixly_correct && wcmd && wcmd->word && wcmd->word->word && STREQ (wcmd->word->word, "command"))
    wcmd = wcmd->next;

  for (w = wcmd; w; w = w->next)
    if (w->word->flags & W_ASSIGNMENT)
      {
      	/* Lazy builtin lookup, only do it if we find an assignment */
	if (b == 0)
	  {
	    b = builtin_address_internal (wcmd->word->word, 0);
	    if (b == 0 || (b->flags & ASSIGNMENT_BUILTIN) == 0)
	      return;
	    else if (b && (b->flags & ASSIGNMENT_BUILTIN))
	      wcmd->word->flags |= W_ASSNBLTIN;
	  }
	w->word->flags |= (W_NOSPLIT|W_NOGLOB|W_TILDEEXP|W_ASSIGNARG);
#if defined (ARRAY_VARS)
	if (assoc)
	  w->word->flags |= W_ASSIGNASSOC;
	if (array)
	  w->word->flags |= W_ASSIGNARRAY;
#endif
	if (global)
	  w->word->flags |= W_ASSNGLOBAL;

	/* If we have an assignment builtin that does not create local variables,
	   make sure we create global variables even if we internally call
	   `declare'.  The CHKLOCAL flag means to set attributes or values on
	   an existing local variable, if there is one. */
	if (b && ((b->flags & (ASSIGNMENT_BUILTIN|LOCALVAR_BUILTIN)) == ASSIGNMENT_BUILTIN))
	  w->word->flags |= W_ASSNGLOBAL|W_CHKLOCAL;
	else if (b && (b->flags & ASSIGNMENT_BUILTIN) && (b->flags & LOCALVAR_BUILTIN) && variable_context)
	  w->word->flags |= W_FORCELOCAL;
      }
#if defined (ARRAY_VARS)
    /* Note that we saw an associative array option to a builtin that takes
       assignment statements.  This is a bit of a kludge. */
    else if (w->word->word[0] == '-' && (strpbrk (w->word->word+1, "Aag") != 0))
#else
    else if (w->word->word[0] == '-' && strchr (w->word->word+1, 'g'))
#endif
      {
	if (b == 0)
	  {
	    b = builtin_address_internal (wcmd->word->word, 0);
	    if (b == 0 || (b->flags & ASSIGNMENT_BUILTIN) == 0)
	      return;
	    else if (b && (b->flags & ASSIGNMENT_BUILTIN))
	      wcmd->word->flags |= W_ASSNBLTIN;
	  }
	if ((wcmd->word->flags & W_ASSNBLTIN) && strchr (w->word->word+1, 'A'))
	  assoc = 1;
	else if ((wcmd->word->flags & W_ASSNBLTIN) && strchr (w->word->word+1, 'a'))
	  array = 1;
	if ((wcmd->word->flags & W_ASSNBLTIN) && strchr (w->word->word+1, 'g'))
	  global = 1;
      }
}
warning: parse error {
  WORD_LIST *w, *wcmd;
  struct builtin *b;
  int assoc, global, array, integer;

  if (words == 0)
    return;

  b = 0;
  assoc = global = array = integer = 0;

  /* Skip over assignment statements preceding a command name */
  wcmd = words;
  for (wcmd = words; wcmd; wcmd = wcmd->next)
    if ((wcmd->word->flags & W_ASSIGNMENT) == 0)
      break;
  /* Posix (post-2008) says that `command' doesn't change whether
     or not the builtin it shadows is a `declaration command', even
     though it removes other special builtin properties.  In Posix
     mode, we skip over one or more instances of `command' and
     deal with the next word as the assignment builtin. */
  while (posixly_correct && wcmd && wcmd->word && wcmd->word->word && STREQ (wcmd->word->word, "command"))
    wcmd = wcmd->next;

  for (w = wcmd; w; w = w->next)
    if (w->word->flags & W_ASSIGNMENT)
      {
      	/* Lazy builtin lookup, only do it if we find an assignment */
	if (b == 0)
	  {
	    b = builtin_address_internal (wcmd->word->word, 0);
	    if (b == 0 || (b->flags & ASSIGNMENT_BUILTIN) == 0)
	      return;
	    else if (b && (b->flags & ASSIGNMENT_BUILTIN))
	      wcmd->word->flags |= W_ASSNBLTIN;
	  }
	w->word->flags |= (W_NOSPLIT|W_NOGLOB|W_TILDEEXP|W_ASSIGNARG);
#if defined (ARRAY_VARS)
	if (assoc)
	  w->word->flags |= W_ASSIGNASSOC;
	if (array)
	  w->word->flags |= W_ASSIGNARRAY;
#endif
	if (global)
	  w->word->flags |= W_ASSNGLOBAL;

	/* If we have an assignment builtin that does not create local variables,
	   make sure we create global variables even if we internally call
	   `declare'.  The CHKLOCAL flag means to set attributes or values on
	   an existing local variable, if there is one. */
	if (b && ((b->flags & (ASSIGNMENT_BUILTIN|LOCALVAR_BUILTIN)) == ASSIGNMENT_BUILTIN))
	  w->word->flags |= W_ASSNGLOBAL|W_CHKLOCAL;
	else if (b && (b->flags & ASSIGNMENT_BUILTIN) && (b->flags & LOCALVAR_BUILTIN) && variable_context)
	  w->word->flags |= W_FORCELOCAL;
      }
#if defined (ARRAY_VARS)
    /* Note that we saw an associative array option to a builtin that takes
       assignment statements.  This is a bit of a kludge. */
    else if (w->word->word[0] == '-' && (strpbrk (w->word->word+1, "Aag") != 0))
#else
    else if (w->word->word[0] == '-' && strchr (w->word->word+1, 'g'))
#endif
      {
	if (b == 0)
	  {
	    b = builtin_address_internal (wcmd->word->word, 0);
	    if (b == 0 || (b->flags & ASSIGNMENT_BUILTIN) == 0)
	      return;
	    else if (b && (b->flags & ASSIGNMENT_BUILTIN))
	      wcmd->word->flags |= W_ASSNBLTIN;
	  }
	if ((wcmd->word->flags & W_ASSNBLTIN) && strchr (w->word->word+1, 'A'))
	  assoc = 1;
	else if ((wcmd->word->flags & W_ASSNBLTIN) && strchr (w->word->word+1, 'a'))
	  array = 1;
	if ((wcmd->word->flags & W_ASSNBLTIN) && strchr (w->word->word+1, 'g'))
	  global = 1;
      }
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\execute_cmd.c:4,085
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\execute_cmd.c:4,178
parsing error 
{
  int type;
  WORD_LIST *w;

  w = words->next;
  type = 1;

  if (w && ISOPTION (w->word->word, 'p'))	/* command -p */
    {
#if defined (RESTRICTED_SHELL)
      if (restricted)
        RETURN_NOT_COMMAND();
#endif
      w = w->next;
      type = 2;
    }

  if (w && ISOPTION (w->word->word, '-'))	/* command [-p] -- */
    w = w->next;
  else if (w && w->word->word[0] == '-')	/* any other option */
    RETURN_NOT_COMMAND();

  if (w == 0 || w->word->word == 0)		/* must have a command_name */
    RETURN_NOT_COMMAND();

  if (typep)
    *typep = type;
  return w;
}
warning: parse error {
  int type;
  WORD_LIST *w;

  w = words->next;
  type = 1;

  if (w && ISOPTION (w->word->word, 'p'))	/* command -p */
    {
#if defined (RESTRICTED_SHELL)
      if (restricted)
        RETURN_NOT_COMMAND();
#endif
      w = w->next;
      type = 2;
    }

  if (w && ISOPTION (w->word->word, '-'))	/* command [-p] -- */
    w = w->next;
  else if (w && w->word->word[0] == '-')	/* any other option */
    RETURN_NOT_COMMAND();

  if (w == 0 || w->word->word == 0)		/* must have a command_name */
    RETURN_NOT_COMMAND();

  if (typep)
    *typep = type;
  return w;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\execute_cmd.c:4,181
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\execute_cmd.c:4,214
parsing error 
{
  char *temp;
  int ret;

  temp = search_for_command (pathname, 0);
  ret = temp ? file_isdir (temp) : file_isdir (pathname);
  free (temp);
  return ret;
}
warning: parse error {
  char *temp;
  int ret;

  temp = search_for_command (pathname, 0);
  ret = temp ? file_isdir (temp) : file_isdir (pathname);
  free (temp);
  return ret;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\execute_cmd.c:4,216
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\execute_cmd.c:4,230
parsing error 
{
  WORD_LIST *words, *lastword;
  char *command_line, *lastarg, *temp;
  int first_word_quoted, result, builtin_is_special, already_forked, dofork;
  int fork_flags, cmdflags;
  pid_t old_last_async_pid;
  sh_builtin_func_t *builtin;
  SHELL_VAR *func;
  volatile int old_builtin, old_command_builtin;

  result = EXECUTION_SUCCESS;
  special_builtin_failed = builtin_is_special = 0;
  command_line = (char *)0;

  QUIT;

  /* If we're in a function, update the line number information. */
  if (variable_context && interactive_shell && sourcelevel == 0)
    {
      /* line numbers in a function start at 1 */
      line_number -= function_line_number - 1;
      if (line_number <= 0)
	line_number = 1;
    }

  /* Remember what this command line looks like at invocation. */
  command_string_index = 0;
  print_simple_command (simple_command);

#if 0
  if (signal_in_progress (DEBUG_TRAP) == 0 && (this_command_name == 0 || (STREQ (this_command_name, "trap") == 0)))
#else
  if (signal_in_progress (DEBUG_TRAP) == 0 && running_trap == 0)
#endif
    {
      FREE (the_printed_command_except_trap);
      the_printed_command_except_trap = the_printed_command ? savestring (the_printed_command) : (char *)0;
    }

  /* Run the debug trap before each simple command, but do it after we
     update the line number information. */
  result = run_debug_trap ();
#if defined (DEBUGGER)
  /* In debugging mode, if the DEBUG trap returns a non-zero status, we
     skip the command. */
  if (debugging_mode && result != EXECUTION_SUCCESS)
    return (EXECUTION_SUCCESS);
#endif

  cmdflags = simple_command->flags;

  first_word_quoted =
    simple_command->words ? (simple_command->words->word->flags & W_QUOTED) : 0;

  last_command_subst_pid = NO_PID;
  old_last_async_pid = last_asynchronous_pid;

  already_forked = 0;

  /* If we're in a pipeline or run in the background, set DOFORK so we
     make the child early, before word expansion.  This keeps assignment
     statements from affecting the parent shell's environment when they
     should not. */
  dofork = pipe_in != NO_PIPE || pipe_out != NO_PIPE || async;

  /* Something like `%2 &' should restart job 2 in the background, not cause
     the shell to fork here. */
  if (dofork && pipe_in == NO_PIPE && pipe_out == NO_PIPE &&
	simple_command->words && simple_command->words->word &&
	simple_command->words->word->word &&
	(simple_command->words->word->word[0] == '%'))
    dofork = 0;

  if (dofork)
    {
      char *p;

      /* Do this now, because execute_disk_command will do it anyway in the
	 vast majority of cases. */
      maybe_make_export_env ();

      /* Don't let a DEBUG trap overwrite the command string to be saved with
	 the process/job associated with this child. */
      fork_flags = async ? FORK_ASYNC : 0;
      if (make_child (p = savestring (the_printed_command_except_trap), fork_flags) == 0)
	{
	  already_forked = 1;
	  cmdflags |= CMD_NO_FORK;

	  subshell_environment = SUBSHELL_FORK;		/* XXX */
	  if (pipe_in != NO_PIPE || pipe_out != NO_PIPE)
	    subshell_environment |= SUBSHELL_PIPE;
	  if (async)
	    subshell_environment |= SUBSHELL_ASYNC;

	  /* We need to do this before piping to handle some really
	     pathological cases where one of the pipe file descriptors
	     is < 2. */
	  if (fds_to_close)
	    close_fd_bitmap (fds_to_close);

	  /* If we fork because of an input pipe, note input pipe for later to
	     inhibit async commands from redirecting stdin from /dev/null */
	  stdin_redir |= pipe_in != NO_PIPE;

	  do_piping (pipe_in, pipe_out);
	  pipe_in = pipe_out = NO_PIPE;
#if defined (COPROCESS_SUPPORT)
	  coproc_closeall ();
#endif

	  last_asynchronous_pid = old_last_async_pid;

	  if (async)
	    subshell_level++;		/* not for pipes yet */

#if defined (JOB_CONTROL)
	  FREE (p);			/* child doesn't use pointer */
#endif
	}
      else
	{
	  /* Don't let simple commands that aren't the last command in a
	     pipeline change $? for the rest of the pipeline (or at all). */
	  if (pipe_out != NO_PIPE)
	    result = last_command_exit_value;
	  close_pipes (pipe_in, pipe_out);
	  command_line = (char *)NULL;      /* don't free this. */
	  return (result);
	}
    }

  QUIT;		/* XXX */

  /* If we are re-running this as the result of executing the `command'
     builtin, do not expand the command words a second time. */
  if ((cmdflags & CMD_INHIBIT_EXPANSION) == 0)
    {
      current_fds_to_close = fds_to_close;
      fix_assignment_words (simple_command->words);
      /* Pass the ignore return flag down to command substitutions */
      if (cmdflags & CMD_IGNORE_RETURN)	/* XXX */
	comsub_ignore_return++;
      words = expand_words (simple_command->words);
      if (cmdflags & CMD_IGNORE_RETURN)
	comsub_ignore_return--;
      current_fds_to_close = (struct fd_bitmap *)NULL;
    }
  else
    words = copy_word_list (simple_command->words);

  /* It is possible for WORDS not to have anything left in it.
     Perhaps all the words consisted of `$foo', and there was
     no variable `$foo'. */
  if (words == 0)
    {
      this_command_name = 0;
      result = execute_null_command (simple_command->redirects,
				     pipe_in, pipe_out,
				     already_forked ? 0 : async);
      if (already_forked)
	sh_exit (result);
      else
	{
	  bind_lastarg ((char *)NULL);
	  set_pipestatus_from_exit (result);
	  return (result);
	}
    }

  lastarg = (char *)NULL;

  begin_unwind_frame ("simple-command");

  if (echo_command_at_execute && (cmdflags & CMD_COMMAND_BUILTIN) == 0)
    xtrace_print_word_list (words, 1);

  builtin = (sh_builtin_func_t *)NULL;
  func = (SHELL_VAR *)NULL;

  /* This test is still here in case we want to change the command builtin
     handler code below to recursively call execute_simple_command (after
     modifying the simple_command struct). */
  if ((cmdflags & CMD_NO_FUNCTIONS) == 0)
    {
      /* Posix.2 says special builtins are found before functions.  We
	 don't set builtin_is_special anywhere other than here, because
	 this path is followed only when the `command' builtin is *not*
	 being used, and we don't want to exit the shell if a special
	 builtin executed with `command builtin' fails.  `command' is not
	 a special builtin. */
      if (posixly_correct)
	{
	  builtin = find_special_builtin (words->word->word);
	  if (builtin)
	    builtin_is_special = 1;
	}
      if (builtin == 0)
	func = find_function (words->word->word);
    }

  /* In POSIX mode, assignment errors in the temporary environment cause a
     non-interactive shell to exit. */
#if 1
  if (posixly_correct && builtin_is_special && interactive_shell == 0 && tempenv_assign_error)
#else
  /* This is for strict posix conformance. */
  if (posixly_correct && interactive_shell == 0 && tempenv_assign_error)
#endif
    {
      last_command_exit_value = EXECUTION_FAILURE;
      jump_to_top_level (ERREXIT);
    }
  tempenv_assign_error = 0;	/* don't care about this any more */

  /* This is where we handle the command builtin as a pseudo-reserved word
     prefix. This allows us to optimize away forks if we can. */
  old_command_builtin = -1;
  if (builtin == 0 && func == 0)
    {
      WORD_LIST *disposer, *l;
      int cmdtype;

      builtin = find_shell_builtin (words->word->word);
      while (builtin == command_builtin)
	{
	  disposer = words;
	  cmdtype = 0;
	  words = check_command_builtin (words, &cmdtype);
	  if (cmdtype > 0)	/* command -p [--] words */
	    {
	      for (l = disposer; l->next != words; l = l->next)
		;
	      l->next = 0;
	      dispose_words (disposer);
	      cmdflags |= CMD_COMMAND_BUILTIN | CMD_NO_FUNCTIONS;
	      if (cmdtype == 2)
		cmdflags |= CMD_STDPATH;
	      builtin = find_shell_builtin (words->word->word);
	    }
	  else
	    break;
	}
      if (cmdflags & CMD_COMMAND_BUILTIN)
	{
	  old_command_builtin = executing_command_builtin;
	  unwind_protect_int (executing_command_builtin);
	  executing_command_builtin |= 1;
	}        
      builtin = 0;
    }

  add_unwind_protect (dispose_words, words);
  QUIT;

  /* Bind the last word in this command to "$_" after execution. */
  for (lastword = words; lastword->next; lastword = lastword->next)
    ;
  lastarg = lastword->word->word;

#if defined (JOB_CONTROL)
  /* Is this command a job control related thing? */
  if (words->word->word[0] == '%' && already_forked == 0)
    {
      this_command_name = async ? "bg" : "fg";
      last_shell_builtin = this_shell_builtin;
      this_shell_builtin = builtin_address (this_command_name);
      result = (*this_shell_builtin) (words);
      goto return_result;
    }

  /* One other possibililty.  The user may want to resume an existing job.
     If they do, find out whether this word is a candidate for a running
     job. */
  if (job_control && already_forked == 0 && async == 0 &&
	!first_word_quoted &&
	!words->next &&
	words->word->word[0] &&
	!simple_command->redirects &&
	pipe_in == NO_PIPE &&
	pipe_out == NO_PIPE &&
	(temp = get_string_value ("auto_resume")))
    {
      int job, jflags, started_status;

      jflags = JM_STOPPED|JM_FIRSTMATCH;
      if (STREQ (temp, "exact"))
	jflags |= JM_EXACT;
      else if (STREQ (temp, "substring"))
	jflags |= JM_SUBSTRING;
      else
	jflags |= JM_PREFIX;
      job = get_job_by_name (words->word->word, jflags);
      if (job != NO_JOB)
	{
	  run_unwind_frame ("simple-command");
	  this_command_name = "fg";
	  last_shell_builtin = this_shell_builtin;
	  this_shell_builtin = builtin_address ("fg");

	  started_status = start_job (job, 1);
	  return ((started_status < 0) ? EXECUTION_FAILURE : started_status);
	}
    }
#endif /* JOB_CONTROL */

run_builtin:
  /* Remember the name of this command globally. */
  this_command_name = words->word->word;

  QUIT;

  /* This command could be a shell builtin or a user-defined function.
     We have already found special builtins by this time, so we do not
     set builtin_is_special.  If this is a function or builtin, and we
     have pipes, then fork a subshell in here.  Otherwise, just execute
     the command directly. */
  if (func == 0 && builtin == 0)
    builtin = find_shell_builtin (this_command_name);

  last_shell_builtin = this_shell_builtin;
  this_shell_builtin = builtin;

  if (builtin || func)
    {
      if (builtin)
        {
	  old_builtin = executing_builtin;
	  unwind_protect_int (executing_builtin);	/* modified in execute_builtin */
	  if (old_command_builtin == -1)	/* sentinel, can be set above */
	    {
	      old_command_builtin = executing_command_builtin;
	      unwind_protect_int (executing_command_builtin);	/* ditto and set above */
	    }
        }
      if (already_forked)
	{
	  /* reset_terminating_signals (); */	/* XXX */
	  /* Reset the signal handlers in the child, but don't free the
	     trap strings.  Set a flag noting that we have to free the
	     trap strings if we run trap to change a signal disposition. */
	  reset_signal_handlers ();
	  subshell_environment |= SUBSHELL_RESETTRAP;

	  if (async)
	    {
	      if ((cmdflags & CMD_STDIN_REDIR) &&
		    pipe_in == NO_PIPE &&
		    (stdin_redirects (simple_command->redirects) == 0))
		async_redirect_stdin ();
	      setup_async_signals ();
	    }

	  if (async == 0)
	    subshell_level++;
	  execute_subshell_builtin_or_function
	    (words, simple_command->redirects, builtin, func,
	     pipe_in, pipe_out, async, fds_to_close,
	     cmdflags);
	  subshell_level--;
	}
      else
	{
	  result = execute_builtin_or_function
	    (words, builtin, func, simple_command->redirects, fds_to_close,
	     cmdflags);
	  if (builtin)
	    {
	      if (result > EX_SHERRBASE)
		{
		  switch (result)
		    {
		    case EX_REDIRFAIL:
		    case EX_BADASSIGN:
		    case EX_EXPFAIL:
		      /* These errors cause non-interactive posix mode shells to exit */
		      if (posixly_correct && builtin_is_special && interactive_shell == 0)
			{
			  last_command_exit_value = EXECUTION_FAILURE;
			  jump_to_top_level (ERREXIT);
			}
		      break;
		    case EX_DISKFALLBACK:
		      /* XXX - experimental */
		      executing_builtin = old_builtin;
		      executing_command_builtin = old_command_builtin;
		      builtin = 0;
		      /* XXX - redirections will have to be performed again */
		      goto execute_from_filesystem;
		    }
		  result = builtin_status (result);
		  if (builtin_is_special)
		    special_builtin_failed = 1;	/* XXX - take command builtin into account? */
		}
	      /* In POSIX mode, if there are assignment statements preceding
		 a special builtin, they persist after the builtin
		 completes. */
	      if (posixly_correct && builtin_is_special && temporary_env)
		merge_temporary_env ();
	    }
	  else		/* function */
	    {
	      if (result == EX_USAGE)
		result = EX_BADUSAGE;
	      else if (result > EX_SHERRBASE)
		result = builtin_status (result);
	    }

	  set_pipestatus_from_exit (result);

	  goto return_result;
	}
    }

  if (autocd && interactive && words->word && is_dirname (words->word->word))
    {
      words = make_word_list (make_word ("--"), words);
      words = make_word_list (make_word ("cd"), words);
      xtrace_print_word_list (words, 0);
      func = find_function ("cd");
      goto run_builtin;
    }

execute_from_filesystem:
  if (command_line == 0)
    command_line = savestring (the_printed_command_except_trap ? the_printed_command_except_trap : "");

#if defined (PROCESS_SUBSTITUTION)
  /* The old code did not test already_forked and only did this if
     subshell_environment&SUBSHELL_COMSUB != 0 (comsubs and procsubs). Other
     uses of the no-fork optimization left FIFOs in $TMPDIR */
  if (already_forked == 0 && (cmdflags & CMD_NO_FORK) && fifos_pending() > 0)
    cmdflags &= ~CMD_NO_FORK;
#endif
  result = execute_disk_command (words, simple_command->redirects, command_line,
			pipe_in, pipe_out, async, fds_to_close,
			cmdflags);

 return_result:
  bind_lastarg (lastarg);
  FREE (command_line);
  dispose_words (words);
  if (builtin)
    {
      executing_builtin = old_builtin;
      executing_command_builtin = old_command_builtin;
    }
  discard_unwind_frame ("simple-command");
  this_command_name = (char *)NULL;	/* points to freed memory now */
  return (result);
}
warning: parse error {
  WORD_LIST *words, *lastword;
  char *command_line, *lastarg, *temp;
  int first_word_quoted, result, builtin_is_special, already_forked, dofork;
  int fork_flags, cmdflags;
  pid_t old_last_async_pid;
  sh_builtin_func_t *builtin;
  SHELL_VAR *func;
  volatile int old_builtin, old_command_builtin;

  result = EXECUTION_SUCCESS;
  special_builtin_failed = builtin_is_special = 0;
  command_line = (char *)0;

  QUIT;

  /* If we're in a function, update the line number information. */
  if (variable_context && interactive_shell && sourcelevel == 0)
    {
      /* line numbers in a function start at 1 */
      line_number -= function_line_number - 1;
      if (line_number <= 0)
	line_number = 1;
    }

  /* Remember what this command line looks like at invocation. */
  command_string_index = 0;
  print_simple_command (simple_command);

#if 0
  if (signal_in_progress (DEBUG_TRAP) == 0 && (this_command_name == 0 || (STREQ (this_command_name, "trap") == 0)))
#else
  if (signal_in_progress (DEBUG_TRAP) == 0 && running_trap == 0)
#endif
    {
      FREE (the_printed_command_except_trap);
      the_printed_command_except_trap = the_printed_command ? savestring (the_printed_command) : (char *)0;
    }

  /* Run the debug trap before each simple command, but do it after we
     update the line number information. */
  result = run_debug_trap ();
#if defined (DEBUGGER)
  /* In debugging mode, if the DEBUG trap returns a non-zero status, we
     skip the command. */
  if (debugging_mode && result != EXECUTION_SUCCESS)
    return (EXECUTION_SUCCESS);
#endif

  cmdflags = simple_command->flags;

  first_word_quoted =
    simple_command->words ? (simple_command->words->word->flags & W_QUOTED) : 0;

  last_command_subst_pid = NO_PID;
  old_last_async_pid = last_asynchronous_pid;

  already_forked = 0;

  /* If we're in a pipeline or run in the background, set DOFORK so we
     make the child early, before word expansion.  This keeps assignment
     statements from affecting the parent shell's environment when they
     should not. */
  dofork = pipe_in != NO_PIPE || pipe_out != NO_PIPE || async;

  /* Something like `%2 &' should restart job 2 in the background, not cause
     the shell to fork here. */
  if (dofork && pipe_in == NO_PIPE && pipe_out == NO_PIPE &&
	simple_command->words && simple_command->words->word &&
	simple_command->words->word->word &&
	(simple_command->words->word->word[0] == '%'))
    dofork = 0;

  if (dofork)
    {
      char *p;

      /* Do this now, because execute_disk_command will do it anyway in the
	 vast majority of cases. */
      maybe_make_export_env ();

      /* Don't let a DEBUG trap overwrite the command string to be saved with
	 the process/job associated with this child. */
      fork_flags = async ? FORK_ASYNC : 0;
      if (make_child (p = savestring (the_printed_command_except_trap), fork_flags) == 0)
	{
	  already_forked = 1;
	  cmdflags |= CMD_NO_FORK;

	  subshell_environment = SUBSHELL_FORK;		/* XXX */
	  if (pipe_in != NO_PIPE || pipe_out != NO_PIPE)
	    subshell_environment |= SUBSHELL_PIPE;
	  if (async)
	    subshell_environment |= SUBSHELL_ASYNC;

	  /* We need to do this before piping to handle some really
	     pathological cases where one of the pipe file descriptors
	     is < 2. */
	  if (fds_to_close)
	    close_fd_bitmap (fds_to_close);

	  /* If we fork because of an input pipe, note input pipe for later to
	     inhibit async commands from redirecting stdin from /dev/null */
	  stdin_redir |= pipe_in != NO_PIPE;

	  do_piping (pipe_in, pipe_out);
	  pipe_in = pipe_out = NO_PIPE;
#if defined (COPROCESS_SUPPORT)
	  coproc_closeall ();
#endif

	  last_asynchronous_pid = old_last_async_pid;

	  if (async)
	    subshell_level++;		/* not for pipes yet */

#if defined (JOB_CONTROL)
	  FREE (p);			/* child doesn't use pointer */
#endif
	}
      else
	{
	  /* Don't let simple commands that aren't the last command in a
	     pipeline change $? for the rest of the pipeline (or at all). */
	  if (pipe_out != NO_PIPE)
	    result = last_command_exit_value;
	  close_pipes (pipe_in, pipe_out);
	  command_line = (char *)NULL;      /* don't free this. */
	  return (result);
	}
    }

  QUIT;		/* XXX */

  /* If we are re-running this as the result of executing the `command'
     builtin, do not expand the command words a second time. */
  if ((cmdflags & CMD_INHIBIT_EXPANSION) == 0)
    {
      current_fds_to_close = fds_to_close;
      fix_assignment_words (simple_command->words);
      /* Pass the ignore return flag down to command substitutions */
      if (cmdflags & CMD_IGNORE_RETURN)	/* XXX */
	comsub_ignore_return++;
      words = expand_words (simple_command->words);
      if (cmdflags & CMD_IGNORE_RETURN)
	comsub_ignore_return--;
      current_fds_to_close = (struct fd_bitmap *)NULL;
    }
  else
    words = copy_word_list (simple_command->words);

  /* It is possible for WORDS not to have anything left in it.
     Perhaps all the words consisted of `$foo', and there was
     no variable `$foo'. */
  if (words == 0)
    {
      this_command_name = 0;
      result = execute_null_command (simple_command->redirects,
				     pipe_in, pipe_out,
				     already_forked ? 0 : async);
      if (already_forked)
	sh_exit (result);
      else
	{
	  bind_lastarg ((char *)NULL);
	  set_pipestatus_from_exit (result);
	  return (result);
	}
    }

  lastarg = (char *)NULL;

  begin_unwind_frame ("simple-command");

  if (echo_command_at_execute && (cmdflags & CMD_COMMAND_BUILTIN) == 0)
    xtrace_print_word_list (words, 1);

  builtin = (sh_builtin_func_t *)NULL;
  func = (SHELL_VAR *)NULL;

  /* This test is still here in case we want to change the command builtin
     handler code below to recursively call execute_simple_command (after
     modifying the simple_command struct). */
  if ((cmdflags & CMD_NO_FUNCTIONS) == 0)
    {
      /* Posix.2 says special builtins are found before functions.  We
	 don't set builtin_is_special anywhere other than here, because
	 this path is followed only when the `command' builtin is *not*
	 being used, and we don't want to exit the shell if a special
	 builtin executed with `command builtin' fails.  `command' is not
	 a special builtin. */
      if (posixly_correct)
	{
	  builtin = find_special_builtin (words->word->word);
	  if (builtin)
	    builtin_is_special = 1;
	}
      if (builtin == 0)
	func = find_function (words->word->word);
    }

  /* In POSIX mode, assignment errors in the temporary environment cause a
     non-interactive shell to exit. */
#if 1
  if (posixly_correct && builtin_is_special && interactive_shell == 0 && tempenv_assign_error)
#else
  /* This is for strict posix conformance. */
  if (posixly_correct && interactive_shell == 0 && tempenv_assign_error)
#endif
    {
      last_command_exit_value = EXECUTION_FAILURE;
      jump_to_top_level (ERREXIT);
    }
  tempenv_assign_error = 0;	/* don't care about this any more */

  /* This is where we handle the command builtin as a pseudo-reserved word
     prefix. This allows us to optimize away forks if we can. */
  old_command_builtin = -1;
  if (builtin == 0 && func == 0)
    {
      WORD_LIST *disposer, *l;
      int cmdtype;

      builtin = find_shell_builtin (words->word->word);
      while (builtin == command_builtin)
	{
	  disposer = words;
	  cmdtype = 0;
	  words = check_command_builtin (words, &cmdtype);
	  if (cmdtype > 0)	/* command -p [--] words */
	    {
	      for (l = disposer; l->next != words; l = l->next)
		;
	      l->next = 0;
	      dispose_words (disposer);
	      cmdflags |= CMD_COMMAND_BUILTIN | CMD_NO_FUNCTIONS;
	      if (cmdtype == 2)
		cmdflags |= CMD_STDPATH;
	      builtin = find_shell_builtin (words->word->word);
	    }
	  else
	    break;
	}
      if (cmdflags & CMD_COMMAND_BUILTIN)
	{
	  old_command_builtin = executing_command_builtin;
	  unwind_protect_int (executing_command_builtin);
	  executing_command_builtin |= 1;
	}        
      builtin = 0;
    }

  add_unwind_protect (dispose_words, words);
  QUIT;

  /* Bind the last word in this command to "$_" after execution. */
  for (lastword = words; lastword->next; lastword = lastword->next)
    ;
  lastarg = lastword->word->word;

#if defined (JOB_CONTROL)
  /* Is this command a job control related thing? */
  if (words->word->word[0] == '%' && already_forked == 0)
    {
      this_command_name = async ? "bg" : "fg";
      last_shell_builtin = this_shell_builtin;
      this_shell_builtin = builtin_address (this_command_name);
      result = (*this_shell_builtin) (words);
      goto return_result;
    }

  /* One other possibililty.  The user may want to resume an existing job.
     If they do, find out whether this word is a candidate for a running
     job. */
  if (job_control && already_forked == 0 && async == 0 &&
	!first_word_quoted &&
	!words->next &&
	words->word->word[0] &&
	!simple_command->redirects &&
	pipe_in == NO_PIPE &&
	pipe_out == NO_PIPE &&
	(temp = get_string_value ("auto_resume")))
    {
      int job, jflags, started_status;

      jflags = JM_STOPPED|JM_FIRSTMATCH;
      if (STREQ (temp, "exact"))
	jflags |= JM_EXACT;
      else if (STREQ (temp, "substring"))
	jflags |= JM_SUBSTRING;
      else
	jflags |= JM_PREFIX;
      job = get_job_by_name (words->word->word, jflags);
      if (job != NO_JOB)
	{
	  run_unwind_frame ("simple-command");
	  this_command_name = "fg";
	  last_shell_builtin = this_shell_builtin;
	  this_shell_builtin = builtin_address ("fg");

	  started_status = start_job (job, 1);
	  return ((started_status < 0) ? EXECUTION_FAILURE : started_status);
	}
    }
#endif /* JOB_CONTROL */

run_builtin:
  /* Remember the name of this command globally. */
  this_command_name = words->word->word;

  QUIT;

  /* This command could be a shell builtin or a user-defined function.
     We have already found special builtins by this time, so we do not
     set builtin_is_special.  If this is a function or builtin, and we
     have pipes, then fork a subshell in here.  Otherwise, just execute
     the command directly. */
  if (func == 0 && builtin == 0)
    builtin = find_shell_builtin (this_command_name);

  last_shell_builtin = this_shell_builtin;
  this_shell_builtin = builtin;

  if (builtin || func)
    {
      if (builtin)
        {
	  old_builtin = executing_builtin;
	  unwind_protect_int (executing_builtin);	/* modified in execute_builtin */
	  if (old_command_builtin == -1)	/* sentinel, can be set above */
	    {
	      old_command_builtin = executing_command_builtin;
	      unwind_protect_int (executing_command_builtin);	/* ditto and set above */
	    }
        }
      if (already_forked)
	{
	  /* reset_terminating_signals (); */	/* XXX */
	  /* Reset the signal handlers in the child, but don't free the
	     trap strings.  Set a flag noting that we have to free the
	     trap strings if we run trap to change a signal disposition. */
	  reset_signal_handlers ();
	  subshell_environment |= SUBSHELL_RESETTRAP;

	  if (async)
	    {
	      if ((cmdflags & CMD_STDIN_REDIR) &&
		    pipe_in == NO_PIPE &&
		    (stdin_redirects (simple_command->redirects) == 0))
		async_redirect_stdin ();
	      setup_async_signals ();
	    }

	  if (async == 0)
	    subshell_level++;
	  execute_subshell_builtin_or_function
	    (words, simple_command->redirects, builtin, func,
	     pipe_in, pipe_out, async, fds_to_close,
	     cmdflags);
	  subshell_level--;
	}
      else
	{
	  result = execute_builtin_or_function
	    (words, builtin, func, simple_command->redirects, fds_to_close,
	     cmdflags);
	  if (builtin)
	    {
	      if (result > EX_SHERRBASE)
		{
		  switch (result)
		    {
		    case EX_REDIRFAIL:
		    case EX_BADASSIGN:
		    case EX_EXPFAIL:
		      /* These errors cause non-interactive posix mode shells to exit */
		      if (posixly_correct && builtin_is_special && interactive_shell == 0)
			{
			  last_command_exit_value = EXECUTION_FAILURE;
			  jump_to_top_level (ERREXIT);
			}
		      break;
		    case EX_DISKFALLBACK:
		      /* XXX - experimental */
		      executing_builtin = old_builtin;
		      executing_command_builtin = old_command_builtin;
		      builtin = 0;
		      /* XXX - redirections will have to be performed again */
		      goto execute_from_filesystem;
		    }
		  result = builtin_status (result);
		  if (builtin_is_special)
		    special_builtin_failed = 1;	/* XXX - take command builtin into account? */
		}
	      /* In POSIX mode, if there are assignment statements preceding
		 a special builtin, they persist after the builtin
		 completes. */
	      if (posixly_correct && builtin_is_special && temporary_env)
		merge_temporary_env ();
	    }
	  else		/* function */
	    {
	      if (result == EX_USAGE)
		result = EX_BADUSAGE;
	      else if (result > EX_SHERRBASE)
		result = builtin_status (result);
	    }

	  set_pipestatus_from_exit (result);

	  goto return_result;
	}
    }

  if (autocd && interactive && words->word && is_dirname (words->word->word))
    {
      words = make_word_list (make_word ("--"), words);
      words = make_word_list (make_word ("cd"), words);
      xtrace_print_word_list (words, 0);
      func = find_function ("cd");
      goto run_builtin;
    }

execute_from_filesystem:
  if (command_line == 0)
    command_line = savestring (the_printed_command_except_trap ? the_printed_command_except_trap : "");

#if defined (PROCESS_SUBSTITUTION)
  /* The old code did not test already_forked and only did this if
     subshell_environment&SUBSHELL_COMSUB != 0 (comsubs and procsubs). Other
     uses of the no-fork optimization left FIFOs in $TMPDIR */
  if (already_forked == 0 && (cmdflags & CMD_NO_FORK) && fifos_pending() > 0)
    cmdflags &= ~CMD_NO_FORK;
#endif
  result = execute_disk_command (words, simple_command->redirects, command_line,
			pipe_in, pipe_out, async, fds_to_close,
			cmdflags);

 return_result:
  bind_lastarg (lastarg);
  FREE (command_line);
  dispose_words (words);
  if (builtin)
    {
      executing_builtin = old_builtin;
      executing_command_builtin = old_command_builtin;
    }
  discard_unwind_frame ("simple-command");
  this_command_name = (char *)NULL;	/* points to freed memory now */
  return (result);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\execute_cmd.c:4,234
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\execute_cmd.c:4,689
parsing error 
{
  int r;

  switch (result)
    {
    case EX_USAGE:
    case EX_BADSYNTAX:
      r = EX_BADUSAGE;
      break;
    case EX_REDIRFAIL:
    case EX_BADASSIGN:
    case EX_EXPFAIL:
      r = EXECUTION_FAILURE;
      break;
    default:
      /* other special exit statuses not yet defined */
      r = (result > EX_SHERRBASE) ? EXECUTION_FAILURE : EXECUTION_SUCCESS;
      break;
    }
  return (r);
}
warning: parse error {
  int r;

  switch (result)
    {
    case EX_USAGE:
    case EX_BADSYNTAX:
      r = EX_BADUSAGE;
      break;
    case EX_REDIRFAIL:
    case EX_BADASSIGN:
    case EX_EXPFAIL:
      r = EXECUTION_FAILURE;
      break;
    default:
      /* other special exit statuses not yet defined */
      r = (result > EX_SHERRBASE) ? EXECUTION_FAILURE : EXECUTION_SUCCESS;
      break;
    }
  return (r);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\execute_cmd.c:4,691
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\execute_cmd.c:4,714
parsing error 
{
  int result, eval_unwind, ignexit_flag;
  int isbltinenv, should_keep;
  char *error_trap;

  error_trap = 0;
  should_keep = 0;

  /* The eval builtin calls parse_and_execute, which does not know about
     the setting of flags, and always calls the execution functions with
     flags that will exit the shell on an error if -e is set.  If the
     eval builtin is being called, and we're supposed to ignore the exit
     value of the command, we turn the -e flag off ourselves and disable
     the ERR trap, then restore them when the command completes.  This is
     also a problem (as below) for the command and source/. builtins. */
  if (subshell == 0 && (flags & CMD_IGNORE_RETURN) &&
	(builtin == eval_builtin || (flags & CMD_COMMAND_BUILTIN) || builtin == source_builtin))
    {
      begin_unwind_frame ("eval_builtin");
      unwind_protect_int (exit_immediately_on_error);
      unwind_protect_int (builtin_ignoring_errexit);
      error_trap = TRAP_STRING (ERROR_TRAP);
      if (error_trap)
	{
	  error_trap = savestring (error_trap);
	  add_unwind_protect (xfree, error_trap);
	  add_unwind_protect (set_error_trap, error_trap);
	  restore_default_signal (ERROR_TRAP);
	}
      exit_immediately_on_error = 0;
      ignexit_flag = builtin_ignoring_errexit;
      builtin_ignoring_errexit = 1;
      eval_unwind = 1;
    }
  else
    eval_unwind = 0;

  /* The temporary environment for a builtin is supposed to apply to
     all commands executed by that builtin.  Currently, this is a
     problem only with the `unset', `source' and `eval' builtins.
     `mapfile' is a special case because it uses evalstring (same as
     eval or source) to run its callbacks. */
  /* SHOULD_KEEP is for the pop_scope call below; it only matters when
     posixly_correct is set, but we should propagate the temporary environment
     to the enclosing environment only for special builtins. */
  isbltinenv = (builtin == source_builtin || builtin == eval_builtin || builtin == unset_builtin || builtin == mapfile_builtin);
  should_keep = isbltinenv && builtin != mapfile_builtin;
#if defined (HISTORY) && defined (READLINE)
  if (builtin == fc_builtin || builtin == read_builtin)
    {
      isbltinenv = 1;
      should_keep = 0;
    }
#endif

  if (isbltinenv)
    {
      if (subshell == 0)
	begin_unwind_frame ("builtin_env");

      if (temporary_env)
	{
	  push_scope (VC_BLTNENV, temporary_env);
	  if (flags & CMD_COMMAND_BUILTIN)
	    should_keep = 0;
	  if (subshell == 0)
	    add_unwind_protect (pop_scope, should_keep ? "1" : 0);
          temporary_env = (HASH_TABLE *)NULL;	  
	}
    }

  if (subshell == 0 && builtin == eval_builtin)
    {
      if (evalnest_max > 0 && evalnest >= evalnest_max)
	{
	  internal_error (_("eval: maximum eval nesting level exceeded (%d)"), evalnest);
	  evalnest = 0;
	  jump_to_top_level (DISCARD);
	}
      unwind_protect_int (evalnest);
      /* The test for subshell == 0 above doesn't make a difference */
      evalnest++;	/* execute_subshell_builtin_or_function sets this to 0 */
    }
  else if (subshell == 0 && builtin == source_builtin)
    {
      if (sourcenest_max > 0 && sourcenest >= sourcenest_max)
	{
	  internal_error (_("%s: maximum source nesting level exceeded (%d)"), this_command_name, sourcenest);
	  sourcenest = 0;
	  jump_to_top_level (DISCARD);
	}
      unwind_protect_int (sourcenest);
      /* The test for subshell == 0 above doesn't make a difference */
      sourcenest++;	/* execute_subshell_builtin_or_function sets this to 0 */
    }

  /* `return' does a longjmp() back to a saved environment in execute_function.
     If a variable assignment list preceded the command, and the shell is
     running in POSIX mode, we need to merge that into the shell_variables
     table, since `return' is a POSIX special builtin. We don't do this if
     it's being run by the `command' builtin, since that's supposed to inhibit
     the special builtin properties. */
  if (posixly_correct && subshell == 0 && builtin == return_builtin && (flags & CMD_COMMAND_BUILTIN) == 0 && temporary_env)
    {
      begin_unwind_frame ("return_temp_env");
      add_unwind_protect (merge_temporary_env, (char *)NULL);
    }

  executing_builtin++;
  executing_command_builtin |= builtin == command_builtin;
  result = ((*builtin) (words->next));

  /* This shouldn't happen, but in case `return' comes back instead of
     longjmp'ing, we need to unwind. */
  if (posixly_correct && subshell == 0 && builtin == return_builtin && temporary_env)
    discard_unwind_frame ("return_temp_env");

  if (subshell == 0 && isbltinenv)
    run_unwind_frame ("builtin_env");

  if (eval_unwind)
    {
      builtin_ignoring_errexit = ignexit_flag;
      exit_immediately_on_error = builtin_ignoring_errexit ? 0 : errexit_flag;
      if (error_trap)
	{
	  set_error_trap (error_trap);
	  free (error_trap);
	}
      discard_unwind_frame ("eval_builtin");
    }

  return (result);
}
warning: parse error {
  int result, eval_unwind, ignexit_flag;
  int isbltinenv, should_keep;
  char *error_trap;

  error_trap = 0;
  should_keep = 0;

  /* The eval builtin calls parse_and_execute, which does not know about
     the setting of flags, and always calls the execution functions with
     flags that will exit the shell on an error if -e is set.  If the
     eval builtin is being called, and we're supposed to ignore the exit
     value of the command, we turn the -e flag off ourselves and disable
     the ERR trap, then restore them when the command completes.  This is
     also a problem (as below) for the command and source/. builtins. */
  if (subshell == 0 && (flags & CMD_IGNORE_RETURN) &&
	(builtin == eval_builtin || (flags & CMD_COMMAND_BUILTIN) || builtin == source_builtin))
    {
      begin_unwind_frame ("eval_builtin");
      unwind_protect_int (exit_immediately_on_error);
      unwind_protect_int (builtin_ignoring_errexit);
      error_trap = TRAP_STRING (ERROR_TRAP);
      if (error_trap)
	{
	  error_trap = savestring (error_trap);
	  add_unwind_protect (xfree, error_trap);
	  add_unwind_protect (set_error_trap, error_trap);
	  restore_default_signal (ERROR_TRAP);
	}
      exit_immediately_on_error = 0;
      ignexit_flag = builtin_ignoring_errexit;
      builtin_ignoring_errexit = 1;
      eval_unwind = 1;
    }
  else
    eval_unwind = 0;

  /* The temporary environment for a builtin is supposed to apply to
     all commands executed by that builtin.  Currently, this is a
     problem only with the `unset', `source' and `eval' builtins.
     `mapfile' is a special case because it uses evalstring (same as
     eval or source) to run its callbacks. */
  /* SHOULD_KEEP is for the pop_scope call below; it only matters when
     posixly_correct is set, but we should propagate the temporary environment
     to the enclosing environment only for special builtins. */
  isbltinenv = (builtin == source_builtin || builtin == eval_builtin || builtin == unset_builtin || builtin == mapfile_builtin);
  should_keep = isbltinenv && builtin != mapfile_builtin;
#if defined (HISTORY) && defined (READLINE)
  if (builtin == fc_builtin || builtin == read_builtin)
    {
      isbltinenv = 1;
      should_keep = 0;
    }
#endif

  if (isbltinenv)
    {
      if (subshell == 0)
	begin_unwind_frame ("builtin_env");

      if (temporary_env)
	{
	  push_scope (VC_BLTNENV, temporary_env);
	  if (flags & CMD_COMMAND_BUILTIN)
	    should_keep = 0;
	  if (subshell == 0)
	    add_unwind_protect (pop_scope, should_keep ? "1" : 0);
          temporary_env = (HASH_TABLE *)NULL;	  
	}
    }

  if (subshell == 0 && builtin == eval_builtin)
    {
      if (evalnest_max > 0 && evalnest >= evalnest_max)
	{
	  internal_error (_("eval: maximum eval nesting level exceeded (%d)"), evalnest);
	  evalnest = 0;
	  jump_to_top_level (DISCARD);
	}
      unwind_protect_int (evalnest);
      /* The test for subshell == 0 above doesn't make a difference */
      evalnest++;	/* execute_subshell_builtin_or_function sets this to 0 */
    }
  else if (subshell == 0 && builtin == source_builtin)
    {
      if (sourcenest_max > 0 && sourcenest >= sourcenest_max)
	{
	  internal_error (_("%s: maximum source nesting level exceeded (%d)"), this_command_name, sourcenest);
	  sourcenest = 0;
	  jump_to_top_level (DISCARD);
	}
      unwind_protect_int (sourcenest);
      /* The test for subshell == 0 above doesn't make a difference */
      sourcenest++;	/* execute_subshell_builtin_or_function sets this to 0 */
    }

  /* `return' does a longjmp() back to a saved environment in execute_function.
     If a variable assignment list preceded the command, and the shell is
     running in POSIX mode, we need to merge that into the shell_variables
     table, since `return' is a POSIX special builtin. We don't do this if
     it's being run by the `command' builtin, since that's supposed to inhibit
     the special builtin properties. */
  if (posixly_correct && subshell == 0 && builtin == return_builtin && (flags & CMD_COMMAND_BUILTIN) == 0 && temporary_env)
    {
      begin_unwind_frame ("return_temp_env");
      add_unwind_protect (merge_temporary_env, (char *)NULL);
    }

  executing_builtin++;
  executing_command_builtin |= builtin == command_builtin;
  result = ((*builtin) (words->next));

  /* This shouldn't happen, but in case `return' comes back instead of
     longjmp'ing, we need to unwind. */
  if (posixly_correct && subshell == 0 && builtin == return_builtin && temporary_env)
    discard_unwind_frame ("return_temp_env");

  if (subshell == 0 && isbltinenv)
    run_unwind_frame ("builtin_env");

  if (eval_unwind)
    {
      builtin_ignoring_errexit = ignexit_flag;
      exit_immediately_on_error = builtin_ignoring_errexit ? 0 : errexit_flag;
      if (error_trap)
	{
	  set_error_trap (error_trap);
	  free (error_trap);
	}
      discard_unwind_frame ("eval_builtin");
    }

  return (result);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\execute_cmd.c:4,718
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\execute_cmd.c:4,854
parsing error 
{
  /* If we have a local copy of OPTIND and it's at the right (current)
     context, then we restore getopt's internal state.  If not, we just
     let it go.  We know there is a local OPTIND if gs->gs_flags & 1.
     This is set below in execute_function() before the context is run. */
  if (gs->gs_flags & 1)
    sh_getopt_restore_istate (gs);
  else
    free (gs);
}
warning: parse error {
  /* If we have a local copy of OPTIND and it's at the right (current)
     context, then we restore getopt's internal state.  If not, we just
     let it go.  We know there is a local OPTIND if gs->gs_flags & 1.
     This is set below in execute_function() before the context is run. */
  if (gs->gs_flags & 1)
    sh_getopt_restore_istate (gs);
  else
    free (gs);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\execute_cmd.c:4,856
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\execute_cmd.c:4,887
parsing error 
{
  int return_val, result;
  COMMAND *tc, *fc, *save_current;
  char *debug_trap, *error_trap, *return_trap;
#if defined (ARRAY_VARS)
  SHELL_VAR *funcname_v, *bash_source_v, *bash_lineno_v;
  ARRAY *funcname_a;
  volatile ARRAY *bash_source_a;
  volatile ARRAY *bash_lineno_a;
  struct func_array_state *fa;
#endif
  FUNCTION_DEF *shell_fn;
  char *sfile, *t;
  sh_getopt_state_t *gs;
  SHELL_VAR *gv;

  USE_VAR(fc);

  if (funcnest_max > 0 && funcnest >= funcnest_max)
    {
      internal_error (_("%s: maximum function nesting level exceeded (%d)"), var->name, funcnest);
      funcnest = 0;	/* XXX - should we reset it somewhere else? */
      jump_to_top_level (DISCARD);
    }

#if defined (ARRAY_VARS)
  GET_ARRAY_FROM_VAR ("FUNCNAME", funcname_v, funcname_a);
  GET_ARRAY_FROM_VAR ("BASH_SOURCE", bash_source_v, bash_source_a);
  GET_ARRAY_FROM_VAR ("BASH_LINENO", bash_lineno_v, bash_lineno_a);
#endif

  tc = (COMMAND *)copy_command (function_cell (var));
  if (tc && (flags & CMD_IGNORE_RETURN))
    tc->flags |= CMD_IGNORE_RETURN;

  /* A limited attempt at optimization: shell functions at the end of command
     substitutions that are already marked NO_FORK. */
  if (tc && (flags & CMD_NO_FORK) && (subshell_environment & SUBSHELL_COMSUB))
    optimize_shell_function (tc);

  gs = sh_getopt_save_istate ();
  if (subshell == 0)
    {
      begin_unwind_frame ("function_calling");
      /* If the shell is in posix mode, this will push the variables in
	 the temporary environment to the "current shell environment" (the
	 global scope), and dispose the temporary env before setting it to
	 NULL later. This behavior has disappeared from the latest edition
	 of the standard, so I will eventually remove it from variables.c:
	 push_var_context. */
      push_context (var->name, subshell, temporary_env);
      /* This has to be before the pop_context(), because the unwinding of
	 local variables may cause the restore of a local declaration of
	 OPTIND to force a getopts state reset. */
      add_unwind_protect (maybe_restore_getopt_state, gs);
      add_unwind_protect (pop_context, (char *)NULL);
      unwind_protect_int (line_number);
      unwind_protect_int (line_number_for_err_trap);
      unwind_protect_int (function_line_number);
      unwind_protect_int (return_catch_flag);
      unwind_protect_jmp_buf (return_catch);
      add_unwind_protect (dispose_command, (char *)tc);
      unwind_protect_pointer (this_shell_function);
      unwind_protect_int (funcnest);
      unwind_protect_int (loop_level);
    }
  else
    push_context (var->name, subshell, temporary_env);	/* don't unwind-protect for subshells */

  temporary_env = (HASH_TABLE *)NULL;

  this_shell_function = var;
  make_funcname_visible (1);

  debug_trap = TRAP_STRING(DEBUG_TRAP);
  error_trap = TRAP_STRING(ERROR_TRAP);
  return_trap = TRAP_STRING(RETURN_TRAP);
  
  /* The order of the unwind protects for debug_trap, error_trap and
     return_trap is important here!  unwind-protect commands are run
     in reverse order of registration.  If this causes problems, take
     out the xfree unwind-protect calls and live with the small memory leak. */

  /* function_trace_mode != 0 means that all functions inherit the DEBUG trap.
     if the function has the trace attribute set, it inherits the DEBUG trap */
  if (debug_trap && ((trace_p (var) == 0) && function_trace_mode == 0))
    {
      if (subshell == 0)
	{
	  debug_trap = savestring (debug_trap);
	  add_unwind_protect (xfree, debug_trap);
	  add_unwind_protect (maybe_set_debug_trap, debug_trap);
	}
      restore_default_signal (DEBUG_TRAP);
    }

  /* error_trace_mode != 0 means that functions inherit the ERR trap. */
  if (error_trap && error_trace_mode == 0)
    {
      if (subshell == 0)
	{
	  error_trap = savestring (error_trap);
	  add_unwind_protect (xfree, error_trap);
	  add_unwind_protect (maybe_set_error_trap, error_trap);
	}
      restore_default_signal (ERROR_TRAP);
    }

  /* Shell functions inherit the RETURN trap if function tracing is on
     globally or on individually for this function. */
  if (return_trap && (signal_in_progress (DEBUG_TRAP) || ((trace_p (var) == 0) && function_trace_mode == 0)))
    {
      if (subshell == 0)
	{
	  return_trap = savestring (return_trap);
	  add_unwind_protect (xfree, return_trap);
	  add_unwind_protect (maybe_set_return_trap, return_trap);
	}
      restore_default_signal (RETURN_TRAP);
    }
  
  funcnest++;
#if defined (ARRAY_VARS)
  /* This is quite similar to the code in shell.c and elsewhere. */
  shell_fn = find_function_def (this_shell_function->name);
  sfile = shell_fn ? shell_fn->source_file : "";
  array_push ((ARRAY *)funcname_a, this_shell_function->name);

  array_push ((ARRAY *)bash_source_a, sfile);
  t = itos (executing_line_number ());
  array_push ((ARRAY *)bash_lineno_a, t);
  free (t);
#endif

#if defined (ARRAY_VARS)
  fa = (struct func_array_state *)xmalloc (sizeof (struct func_array_state));
  fa->source_a = (ARRAY *)bash_source_a;
  fa->source_v = bash_source_v;
  fa->lineno_a = (ARRAY *)bash_lineno_a;
  fa->lineno_v = bash_lineno_v;
  fa->funcname_a = (ARRAY *)funcname_a;
  fa->funcname_v = funcname_v;
  if (subshell == 0)
    add_unwind_protect (restore_funcarray_state, fa);
#endif

  /* The temporary environment for a function is supposed to apply to
     all commands executed within the function body. */

  /* Initialize BASH_ARGC and BASH_ARGV before we blow away the positional
     parameters */
  if (debugging_mode || shell_compatibility_level <= 44)
    init_bash_argv ();

  remember_args (words->next, 1);

  /* Update BASH_ARGV and BASH_ARGC */
  if (debugging_mode)
    {
      push_args (words->next);
      if (subshell == 0)
	add_unwind_protect (pop_args, 0);
    }

  /* Number of the line on which the function body starts. */
  line_number = function_line_number = tc->line;

#if defined (JOB_CONTROL)
  if (subshell)
    stop_pipeline (async, (COMMAND *)NULL);
#endif

  if (shell_compatibility_level > 43)
    loop_level = 0;

  fc = tc;

  from_return_trap = 0;

  return_catch_flag++;
  return_val = setjmp_nosigs (return_catch);

  if (return_val)
    {
      result = return_catch_value;
      /* Run the RETURN trap in the function's context. */
      save_current = currently_executing_command;
      if (from_return_trap == 0)
	run_return_trap ();
      currently_executing_command = save_current;
    }
  else
    {
      /* Run the debug trap here so we can trap at the start of a function's
	 execution rather than the execution of the body's first command. */
      showing_function_line = 1;
      save_current = currently_executing_command;
      result = run_debug_trap ();
#if defined (DEBUGGER)
      /* In debugging mode, if the DEBUG trap returns a non-zero status, we
	 skip the command. */
      if (debugging_mode == 0 || result == EXECUTION_SUCCESS)
	{
	  showing_function_line = 0;
	  currently_executing_command = save_current;
	  result = execute_command_internal (fc, 0, NO_PIPE, NO_PIPE, fds_to_close);

	  /* Run the RETURN trap in the function's context */
	  save_current = currently_executing_command;
	  run_return_trap ();
	  currently_executing_command = save_current;
	}
#else
      result = execute_command_internal (fc, 0, NO_PIPE, NO_PIPE, fds_to_close);

      save_current = currently_executing_command;
      run_return_trap ();
      currently_executing_command = save_current;
#endif
      showing_function_line = 0;
    }

  /* If we have a local copy of OPTIND, note it in the saved getopts state. */
  gv = find_variable ("OPTIND");
  if (gv && gv->context == variable_context)
    gs->gs_flags |= 1;

  if (subshell == 0)
    run_unwind_frame ("function_calling");
#if defined (ARRAY_VARS)
  else
    {
      restore_funcarray_state (fa);
      /* Restore BASH_ARGC and BASH_ARGV */
      if (debugging_mode)
	pop_args ();
    }
#endif

  if (variable_context == 0 || this_shell_function == 0)
    {
      make_funcname_visible (0);
#if defined (PROCESS_SUBSTITUTION)
      unlink_fifo_list ();
#endif
    }

  return (result);
}
warning: parse error {
  int return_val, result;
  COMMAND *tc, *fc, *save_current;
  char *debug_trap, *error_trap, *return_trap;
#if defined (ARRAY_VARS)
  SHELL_VAR *funcname_v, *bash_source_v, *bash_lineno_v;
  ARRAY *funcname_a;
  volatile ARRAY *bash_source_a;
  volatile ARRAY *bash_lineno_a;
  struct func_array_state *fa;
#endif
  FUNCTION_DEF *shell_fn;
  char *sfile, *t;
  sh_getopt_state_t *gs;
  SHELL_VAR *gv;

  USE_VAR(fc);

  if (funcnest_max > 0 && funcnest >= funcnest_max)
    {
      internal_error (_("%s: maximum function nesting level exceeded (%d)"), var->name, funcnest);
      funcnest = 0;	/* XXX - should we reset it somewhere else? */
      jump_to_top_level (DISCARD);
    }

#if defined (ARRAY_VARS)
  GET_ARRAY_FROM_VAR ("FUNCNAME", funcname_v, funcname_a);
  GET_ARRAY_FROM_VAR ("BASH_SOURCE", bash_source_v, bash_source_a);
  GET_ARRAY_FROM_VAR ("BASH_LINENO", bash_lineno_v, bash_lineno_a);
#endif

  tc = (COMMAND *)copy_command (function_cell (var));
  if (tc && (flags & CMD_IGNORE_RETURN))
    tc->flags |= CMD_IGNORE_RETURN;

  /* A limited attempt at optimization: shell functions at the end of command
     substitutions that are already marked NO_FORK. */
  if (tc && (flags & CMD_NO_FORK) && (subshell_environment & SUBSHELL_COMSUB))
    optimize_shell_function (tc);

  gs = sh_getopt_save_istate ();
  if (subshell == 0)
    {
      begin_unwind_frame ("function_calling");
      /* If the shell is in posix mode, this will push the variables in
	 the temporary environment to the "current shell environment" (the
	 global scope), and dispose the temporary env before setting it to
	 NULL later. This behavior has disappeared from the latest edition
	 of the standard, so I will eventually remove it from variables.c:
	 push_var_context. */
      push_context (var->name, subshell, temporary_env);
      /* This has to be before the pop_context(), because the unwinding of
	 local variables may cause the restore of a local declaration of
	 OPTIND to force a getopts state reset. */
      add_unwind_protect (maybe_restore_getopt_state, gs);
      add_unwind_protect (pop_context, (char *)NULL);
      unwind_protect_int (line_number);
      unwind_protect_int (line_number_for_err_trap);
      unwind_protect_int (function_line_number);
      unwind_protect_int (return_catch_flag);
      unwind_protect_jmp_buf (return_catch);
      add_unwind_protect (dispose_command, (char *)tc);
      unwind_protect_pointer (this_shell_function);
      unwind_protect_int (funcnest);
      unwind_protect_int (loop_level);
    }
  else
    push_context (var->name, subshell, temporary_env);	/* don't unwind-protect for subshells */

  temporary_env = (HASH_TABLE *)NULL;

  this_shell_function = var;
  make_funcname_visible (1);

  debug_trap = TRAP_STRING(DEBUG_TRAP);
  error_trap = TRAP_STRING(ERROR_TRAP);
  return_trap = TRAP_STRING(RETURN_TRAP);
  
  /* The order of the unwind protects for debug_trap, error_trap and
     return_trap is important here!  unwind-protect commands are run
     in reverse order of registration.  If this causes problems, take
     out the xfree unwind-protect calls and live with the small memory leak. */

  /* function_trace_mode != 0 means that all functions inherit the DEBUG trap.
     if the function has the trace attribute set, it inherits the DEBUG trap */
  if (debug_trap && ((trace_p (var) == 0) && function_trace_mode == 0))
    {
      if (subshell == 0)
	{
	  debug_trap = savestring (debug_trap);
	  add_unwind_protect (xfree, debug_trap);
	  add_unwind_protect (maybe_set_debug_trap, debug_trap);
	}
      restore_default_signal (DEBUG_TRAP);
    }

  /* error_trace_mode != 0 means that functions inherit the ERR trap. */
  if (error_trap && error_trace_mode == 0)
    {
      if (subshell == 0)
	{
	  error_trap = savestring (error_trap);
	  add_unwind_protect (xfree, error_trap);
	  add_unwind_protect (maybe_set_error_trap, error_trap);
	}
      restore_default_signal (ERROR_TRAP);
    }

  /* Shell functions inherit the RETURN trap if function tracing is on
     globally or on individually for this function. */
  if (return_trap && (signal_in_progress (DEBUG_TRAP) || ((trace_p (var) == 0) && function_trace_mode == 0)))
    {
      if (subshell == 0)
	{
	  return_trap = savestring (return_trap);
	  add_unwind_protect (xfree, return_trap);
	  add_unwind_protect (maybe_set_return_trap, return_trap);
	}
      restore_default_signal (RETURN_TRAP);
    }
  
  funcnest++;
#if defined (ARRAY_VARS)
  /* This is quite similar to the code in shell.c and elsewhere. */
  shell_fn = find_function_def (this_shell_function->name);
  sfile = shell_fn ? shell_fn->source_file : "";
  array_push ((ARRAY *)funcname_a, this_shell_function->name);

  array_push ((ARRAY *)bash_source_a, sfile);
  t = itos (executing_line_number ());
  array_push ((ARRAY *)bash_lineno_a, t);
  free (t);
#endif

#if defined (ARRAY_VARS)
  fa = (struct func_array_state *)xmalloc (sizeof (struct func_array_state));
  fa->source_a = (ARRAY *)bash_source_a;
  fa->source_v = bash_source_v;
  fa->lineno_a = (ARRAY *)bash_lineno_a;
  fa->lineno_v = bash_lineno_v;
  fa->funcname_a = (ARRAY *)funcname_a;
  fa->funcname_v = funcname_v;
  if (subshell == 0)
    add_unwind_protect (restore_funcarray_state, fa);
#endif

  /* The temporary environment for a function is supposed to apply to
     all commands executed within the function body. */

  /* Initialize BASH_ARGC and BASH_ARGV before we blow away the positional
     parameters */
  if (debugging_mode || shell_compatibility_level <= 44)
    init_bash_argv ();

  remember_args (words->next, 1);

  /* Update BASH_ARGV and BASH_ARGC */
  if (debugging_mode)
    {
      push_args (words->next);
      if (subshell == 0)
	add_unwind_protect (pop_args, 0);
    }

  /* Number of the line on which the function body starts. */
  line_number = function_line_number = tc->line;

#if defined (JOB_CONTROL)
  if (subshell)
    stop_pipeline (async, (COMMAND *)NULL);
#endif

  if (shell_compatibility_level > 43)
    loop_level = 0;

  fc = tc;

  from_return_trap = 0;

  return_catch_flag++;
  return_val = setjmp_nosigs (return_catch);

  if (return_val)
    {
      result = return_catch_value;
      /* Run the RETURN trap in the function's context. */
      save_current = currently_executing_command;
      if (from_return_trap == 0)
	run_return_trap ();
      currently_executing_command = save_current;
    }
  else
    {
      /* Run the debug trap here so we can trap at the start of a function's
	 execution rather than the execution of the body's first command. */
      showing_function_line = 1;
      save_current = currently_executing_command;
      result = run_debug_trap ();
#if defined (DEBUGGER)
      /* In debugging mode, if the DEBUG trap returns a non-zero status, we
	 skip the command. */
      if (debugging_mode == 0 || result == EXECUTION_SUCCESS)
	{
	  showing_function_line = 0;
	  currently_executing_command = save_current;
	  result = execute_command_internal (fc, 0, NO_PIPE, NO_PIPE, fds_to_close);

	  /* Run the RETURN trap in the function's context */
	  save_current = currently_executing_command;
	  run_return_trap ();
	  currently_executing_command = save_current;
	}
#else
      result = execute_command_internal (fc, 0, NO_PIPE, NO_PIPE, fds_to_close);

      save_current = currently_executing_command;
      run_return_trap ();
      currently_executing_command = save_current;
#endif
      showing_function_line = 0;
    }

  /* If we have a local copy of OPTIND, note it in the saved getopts state. */
  gv = find_variable ("OPTIND");
  if (gv && gv->context == variable_context)
    gs->gs_flags |= 1;

  if (subshell == 0)
    run_unwind_frame ("function_calling");
#if defined (ARRAY_VARS)
  else
    {
      restore_funcarray_state (fa);
      /* Restore BASH_ARGC and BASH_ARGV */
      if (debugging_mode)
	pop_args ();
    }
#endif

  if (variable_context == 0 || this_shell_function == 0)
    {
      make_funcname_visible (0);
#if defined (PROCESS_SUBSTITUTION)
      unlink_fifo_list ();
#endif
    }

  return (result);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\execute_cmd.c:4,893
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\execute_cmd.c:5,146
parsing error 
{
  int ret;
  struct fd_bitmap *bitmap;

  bitmap = new_fd_bitmap (FD_BITMAP_DEFAULT_SIZE);
  begin_unwind_frame ("execute-shell-function");
  add_unwind_protect (dispose_fd_bitmap, (char *)bitmap);
      
  ret = execute_function (var, words, 0, bitmap, 0, 0);

  dispose_fd_bitmap (bitmap);
  discard_unwind_frame ("execute-shell-function");

  return ret;
}
warning: parse error {
  int ret;
  struct fd_bitmap *bitmap;

  bitmap = new_fd_bitmap (FD_BITMAP_DEFAULT_SIZE);
  begin_unwind_frame ("execute-shell-function");
  add_unwind_protect (dispose_fd_bitmap, (char *)bitmap);
      
  ret = execute_function (var, words, 0, bitmap, 0, 0);

  dispose_fd_bitmap (bitmap);
  discard_unwind_frame ("execute-shell-function");

  return ret;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\execute_cmd.c:5,149
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\execute_cmd.c:5,174
parsing error 
{
  int result, r, funcvalue;
#if defined (JOB_CONTROL)
  int jobs_hack;

  jobs_hack = (builtin == jobs_builtin) &&
		((subshell_environment & SUBSHELL_ASYNC) == 0 || pipe_out != NO_PIPE);
#endif

  /* A subshell is neither a login shell nor interactive. */
  login_shell = interactive = 0;
  if (builtin == eval_builtin)
    evalnest = 0;
  else if (builtin == source_builtin)
    sourcenest = 0;

  if (async)
    subshell_environment |= SUBSHELL_ASYNC;
  if (pipe_in != NO_PIPE || pipe_out != NO_PIPE)
    subshell_environment |= SUBSHELL_PIPE;

  maybe_make_export_env ();	/* XXX - is this needed? */

#if defined (JOB_CONTROL)
  /* Eradicate all traces of job control after we fork the subshell, so
     all jobs begun by this subshell are in the same process group as
     the shell itself. */

  /* Allow the output of `jobs' to be piped. */
  if (jobs_hack)
    kill_current_pipeline ();
  else
    without_job_control ();

  set_sigchld_handler ();
#else
  without_job_control ();
#endif /* JOB_CONTROL */

  set_sigint_handler ();

  if (fds_to_close)
    close_fd_bitmap (fds_to_close);

  do_piping (pipe_in, pipe_out);

  if (do_redirections (redirects, RX_ACTIVE) != 0)
    exit (EXECUTION_FAILURE);

  if (builtin)
    {
      /* Give builtins a place to jump back to on failure,
	 so we don't go back up to main(). */
      result = setjmp_nosigs (top_level);

      /* Give the return builtin a place to jump to when executed in a subshell
         or pipeline */
      funcvalue = 0;
      if (return_catch_flag && builtin == return_builtin)
        funcvalue = setjmp_nosigs (return_catch);

      if (result == EXITPROG)
	subshell_exit (last_command_exit_value);
      else if (result)
	subshell_exit (EXECUTION_FAILURE);
      else if (funcvalue)
	subshell_exit (return_catch_value);
      else
	{
	  r = execute_builtin (builtin, words, flags, 1);
	  fflush (stdout);
	  if (r == EX_USAGE)
	    r = EX_BADUSAGE;
	  /* XXX - experimental */
	  else if (r == EX_DISKFALLBACK)
	    {
	      char *command_line;

	      command_line = savestring (the_printed_command_except_trap ? the_printed_command_except_trap : "");
	      r = execute_disk_command (words, (REDIRECT *)0, command_line,
		  -1, -1, async, (struct fd_bitmap *)0, flags|CMD_NO_FORK);
	    }
	  subshell_exit (r);
	}
    }
  else
    {
      r = execute_function (var, words, flags, fds_to_close, async, 1);
      fflush (stdout);
      subshell_exit (r);
    }
}
warning: parse error {
  int result, r, funcvalue;
#if defined (JOB_CONTROL)
  int jobs_hack;

  jobs_hack = (builtin == jobs_builtin) &&
		((subshell_environment & SUBSHELL_ASYNC) == 0 || pipe_out != NO_PIPE);
#endif

  /* A subshell is neither a login shell nor interactive. */
  login_shell = interactive = 0;
  if (builtin == eval_builtin)
    evalnest = 0;
  else if (builtin == source_builtin)
    sourcenest = 0;

  if (async)
    subshell_environment |= SUBSHELL_ASYNC;
  if (pipe_in != NO_PIPE || pipe_out != NO_PIPE)
    subshell_environment |= SUBSHELL_PIPE;

  maybe_make_export_env ();	/* XXX - is this needed? */

#if defined (JOB_CONTROL)
  /* Eradicate all traces of job control after we fork the subshell, so
     all jobs begun by this subshell are in the same process group as
     the shell itself. */

  /* Allow the output of `jobs' to be piped. */
  if (jobs_hack)
    kill_current_pipeline ();
  else
    without_job_control ();

  set_sigchld_handler ();
#else
  without_job_control ();
#endif /* JOB_CONTROL */

  set_sigint_handler ();

  if (fds_to_close)
    close_fd_bitmap (fds_to_close);

  do_piping (pipe_in, pipe_out);

  if (do_redirections (redirects, RX_ACTIVE) != 0)
    exit (EXECUTION_FAILURE);

  if (builtin)
    {
      /* Give builtins a place to jump back to on failure,
	 so we don't go back up to main(). */
      result = setjmp_nosigs (top_level);

      /* Give the return builtin a place to jump to when executed in a subshell
         or pipeline */
      funcvalue = 0;
      if (return_catch_flag && builtin == return_builtin)
        funcvalue = setjmp_nosigs (return_catch);

      if (result == EXITPROG)
	subshell_exit (last_command_exit_value);
      else if (result)
	subshell_exit (EXECUTION_FAILURE);
      else if (funcvalue)
	subshell_exit (return_catch_value);
      else
	{
	  r = execute_builtin (builtin, words, flags, 1);
	  fflush (stdout);
	  if (r == EX_USAGE)
	    r = EX_BADUSAGE;
	  /* XXX - experimental */
	  else if (r == EX_DISKFALLBACK)
	    {
	      char *command_line;

	      command_line = savestring (the_printed_command_except_trap ? the_printed_command_except_trap : "");
	      r = execute_disk_command (words, (REDIRECT *)0, command_line,
		  -1, -1, async, (struct fd_bitmap *)0, flags|CMD_NO_FORK);
	    }
	  subshell_exit (r);
	}
    }
  else
    {
      r = execute_function (var, words, flags, fds_to_close, async, 1);
      fflush (stdout);
      subshell_exit (r);
    }
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\execute_cmd.c:5,182
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\execute_cmd.c:5,285
parsing error 
{
  int result;
  REDIRECT *saved_undo_list;
#if defined (PROCESS_SUBSTITUTION)
  int ofifo, nfifo, osize;
  void *ofifo_list;
#endif

#if defined (PROCESS_SUBSTITUTION)
  begin_unwind_frame ("saved_fifos");
  /* If we return, we longjmp and don't get a chance to restore the old
     fifo list, so we add an unwind protect to free it */
  ofifo = num_fifos ();
  ofifo_list = copy_fifo_list (&osize);
  if (ofifo_list)
    add_unwind_protect (xfree, ofifo_list);
#endif

  if (do_redirections (redirects, RX_ACTIVE|RX_UNDOABLE) != 0)
    {
      undo_partial_redirects ();
      dispose_exec_redirects ();
#if defined (PROCESS_SUBSTITUTION)
      free (ofifo_list);
#endif
      return (EX_REDIRFAIL);	/* was EXECUTION_FAILURE */
    }

  saved_undo_list = redirection_undo_list;

  /* Calling the "exec" builtin changes redirections forever. */
  if (builtin == exec_builtin)
    {
      dispose_redirects (saved_undo_list);
      saved_undo_list = exec_redirection_undo_list;
      exec_redirection_undo_list = (REDIRECT *)NULL;
    }
  else
    dispose_exec_redirects ();

  if (saved_undo_list)
    {
      begin_unwind_frame ("saved-redirects");
      add_unwind_protect (cleanup_redirects, (char *)saved_undo_list);
    }

  redirection_undo_list = (REDIRECT *)NULL;

  if (builtin)
    result = execute_builtin (builtin, words, flags, 0);
  else
    result = execute_function (var, words, flags, fds_to_close, 0, 0);

  /* We do this before undoing the effects of any redirections. */
  fflush (stdout);
  fpurge (stdout);
  if (ferror (stdout))
    clearerr (stdout);  

  /* If we are executing the `command' builtin, but this_shell_builtin is
     set to `exec_builtin', we know that we have something like
     `command exec [redirection]', since otherwise `exec' would have
     overwritten the shell and we wouldn't get here.  In this case, we
     want to behave as if the `command' builtin had not been specified
     and preserve the redirections. */
  if (builtin == command_builtin && this_shell_builtin == exec_builtin)
    {
      int discard;

      discard = 0;
      if (saved_undo_list)
	{
	  dispose_redirects (saved_undo_list);
	  discard = 1;
	}
      redirection_undo_list = exec_redirection_undo_list;
      saved_undo_list = exec_redirection_undo_list = (REDIRECT *)NULL;      
      if (discard)
	discard_unwind_frame ("saved-redirects");
    }

  if (saved_undo_list)
    {
      redirection_undo_list = saved_undo_list;
      discard_unwind_frame ("saved-redirects");
    }

  undo_partial_redirects ();

#if defined (PROCESS_SUBSTITUTION)
  /* Close any FIFOs created by this builtin or function. */
  nfifo = num_fifos ();
  if (nfifo > ofifo)
    close_new_fifos (ofifo_list, osize);
  if (ofifo_list)
    free (ofifo_list);
  discard_unwind_frame ("saved_fifos");
#endif

  return (result);
}
warning: parse error {
  int result;
  REDIRECT *saved_undo_list;
#if defined (PROCESS_SUBSTITUTION)
  int ofifo, nfifo, osize;
  void *ofifo_list;
#endif

#if defined (PROCESS_SUBSTITUTION)
  begin_unwind_frame ("saved_fifos");
  /* If we return, we longjmp and don't get a chance to restore the old
     fifo list, so we add an unwind protect to free it */
  ofifo = num_fifos ();
  ofifo_list = copy_fifo_list (&osize);
  if (ofifo_list)
    add_unwind_protect (xfree, ofifo_list);
#endif

  if (do_redirections (redirects, RX_ACTIVE|RX_UNDOABLE) != 0)
    {
      undo_partial_redirects ();
      dispose_exec_redirects ();
#if defined (PROCESS_SUBSTITUTION)
      free (ofifo_list);
#endif
      return (EX_REDIRFAIL);	/* was EXECUTION_FAILURE */
    }

  saved_undo_list = redirection_undo_list;

  /* Calling the "exec" builtin changes redirections forever. */
  if (builtin == exec_builtin)
    {
      dispose_redirects (saved_undo_list);
      saved_undo_list = exec_redirection_undo_list;
      exec_redirection_undo_list = (REDIRECT *)NULL;
    }
  else
    dispose_exec_redirects ();

  if (saved_undo_list)
    {
      begin_unwind_frame ("saved-redirects");
      add_unwind_protect (cleanup_redirects, (char *)saved_undo_list);
    }

  redirection_undo_list = (REDIRECT *)NULL;

  if (builtin)
    result = execute_builtin (builtin, words, flags, 0);
  else
    result = execute_function (var, words, flags, fds_to_close, 0, 0);

  /* We do this before undoing the effects of any redirections. */
  fflush (stdout);
  fpurge (stdout);
  if (ferror (stdout))
    clearerr (stdout);  

  /* If we are executing the `command' builtin, but this_shell_builtin is
     set to `exec_builtin', we know that we have something like
     `command exec [redirection]', since otherwise `exec' would have
     overwritten the shell and we wouldn't get here.  In this case, we
     want to behave as if the `command' builtin had not been specified
     and preserve the redirections. */
  if (builtin == command_builtin && this_shell_builtin == exec_builtin)
    {
      int discard;

      discard = 0;
      if (saved_undo_list)
	{
	  dispose_redirects (saved_undo_list);
	  discard = 1;
	}
      redirection_undo_list = exec_redirection_undo_list;
      saved_undo_list = exec_redirection_undo_list = (REDIRECT *)NULL;      
      if (discard)
	discard_unwind_frame ("saved-redirects");
    }

  if (saved_undo_list)
    {
      redirection_undo_list = saved_undo_list;
      discard_unwind_frame ("saved-redirects");
    }

  undo_partial_redirects ();

#if defined (PROCESS_SUBSTITUTION)
  /* Close any FIFOs created by this builtin or function. */
  nfifo = num_fifos ();
  if (nfifo > ofifo)
    close_new_fifos (ofifo_list, osize);
  if (ofifo_list)
    free (ofifo_list);
  discard_unwind_frame ("saved_fifos");
#endif

  return (result);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\execute_cmd.c:5,292
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\execute_cmd.c:5,443
parsing error 
{
  char *pathname, *command, **args, *p;
  int nofork, stdpath, result, fork_flags;
  pid_t pid;
  SHELL_VAR *hookf;
  WORD_LIST *wl;

  stdpath = (cmdflags & CMD_STDPATH);	/* use command -p path */
  nofork = (cmdflags & CMD_NO_FORK);	/* Don't fork, just exec, if no pipes */
  pathname = words->word->word;

  p = 0;
  result = EXECUTION_SUCCESS;
#if defined (RESTRICTED_SHELL)
  command = (char *)NULL;
  if (restricted && mbschr (pathname, '/'))
    {
      internal_error (_("%s: restricted: cannot specify `/' in command names"),
		    pathname);
      result = last_command_exit_value = EXECUTION_FAILURE;

      /* If we're not going to fork below, we must already be in a child
         process or a context in which it's safe to call exit(2).  */
      if (nofork && pipe_in == NO_PIPE && pipe_out == NO_PIPE)
	exit (last_command_exit_value);
      else
	goto parent_return;
    }
#endif /* RESTRICTED_SHELL */

  command = search_for_command (pathname, CMDSRCH_HASH|(stdpath ? CMDSRCH_STDPATH : 0));
  QUIT;

  if (command)
    {
      /* If we're optimizing out the fork (implicit `exec'), decrement the
	 shell level like `exec' would do. */
#if 0 /* TAG: bash-5.2 psmith 10/11/2020 */
      if (nofork && pipe_in == NO_PIPE && pipe_out == NO_PIPE && (subshell_environment & SUBSHELL_PIPE) == 0)
#else
      if (nofork && pipe_in == NO_PIPE && pipe_out == NO_PIPE)
#endif
	adjust_shell_level (-1);

      maybe_make_export_env ();
      put_command_name_into_env (command);
    }

  /* We have to make the child before we check for the non-existence
     of COMMAND, since we want the error messages to be redirected. */
  /* If we can get away without forking and there are no pipes to deal with,
     don't bother to fork, just directly exec the command. */
  if (nofork && pipe_in == NO_PIPE && pipe_out == NO_PIPE)
    pid = 0;
  else
    {
      fork_flags = async ? FORK_ASYNC : 0;
      pid = make_child (p = savestring (command_line), fork_flags);
    }

  if (pid == 0)
    {
      int old_interactive;

      reset_terminating_signals ();	/* XXX */
      /* Cancel traps, in trap.c. */
      restore_original_signals ();

#if defined (JOB_CONTROL)
      FREE (p);
#endif

      /* restore_original_signals may have undone the work done
	 by make_child to ensure that SIGINT and SIGQUIT are ignored
	 in asynchronous children. */
      if (async)
	{
	  if ((cmdflags & CMD_STDIN_REDIR) &&
		pipe_in == NO_PIPE &&
		(stdin_redirects (redirects) == 0))
	    async_redirect_stdin ();
	  setup_async_signals ();
	}

      /* This functionality is now provided by close-on-exec of the
	 file descriptors manipulated by redirection and piping.
	 Some file descriptors still need to be closed in all children
	 because of the way bash does pipes; fds_to_close is a
	 bitmap of all such file descriptors. */
      if (fds_to_close)
	close_fd_bitmap (fds_to_close);

      do_piping (pipe_in, pipe_out);

      old_interactive = interactive;
      if (async)
	interactive = 0;

      subshell_environment |= SUBSHELL_FORK;	/* XXX - was just = */

#if defined (PROCESS_SUBSTITUTION) && !defined (HAVE_DEV_FD)
      clear_fifo_list ();	/* XXX - we haven't created any FIFOs */
#endif

      if (redirects && (do_redirections (redirects, RX_ACTIVE) != 0))
	{
#if defined (PROCESS_SUBSTITUTION)
	  /* Try to remove named pipes that may have been created as the
	     result of redirections. */
	  unlink_fifo_list ();
#endif /* PROCESS_SUBSTITUTION */
	  exit (EXECUTION_FAILURE);
	}

      if (async)
	interactive = old_interactive;

      if (command == 0)
	{
	  hookf = find_function (NOTFOUND_HOOK);
	  if (hookf == 0)
	    {
	      /* Make sure filenames are displayed using printable characters */
	      pathname = printable_filename (pathname, 0);
	      internal_error (_("%s: command not found"), pathname);
	      exit (EX_NOTFOUND);	/* Posix.2 says the exit status is 127 */
	    }

	  /* We don't want to manage process groups for processes we start
	     from here, so we turn off job control and don't attempt to
	     manipulate the terminal's process group. */
	  without_job_control ();

#if defined (JOB_CONTROL)
	  set_sigchld_handler ();
#endif

	  wl = make_word_list (make_word (NOTFOUND_HOOK), words);
	  exit (execute_shell_function (hookf, wl));
	}

      /* Execve expects the command name to be in args[0].  So we
	 leave it there, in the same format that the user used to
	 type it in. */
      args = strvec_from_word_list (words, 0, 0, (int *)NULL);
      exit (shell_execve (command, args, export_env));
    }
  else
    {
parent_return:
      QUIT;

      /* Make sure that the pipes are closed in the parent. */
      close_pipes (pipe_in, pipe_out);
#if defined (PROCESS_SUBSTITUTION) && defined (HAVE_DEV_FD)
#if 0
      if (variable_context == 0)
        unlink_fifo_list ();
#endif
#endif
      FREE (command);
      return (result);
    }
}
warning: parse error {
  char *pathname, *command, **args, *p;
  int nofork, stdpath, result, fork_flags;
  pid_t pid;
  SHELL_VAR *hookf;
  WORD_LIST *wl;

  stdpath = (cmdflags & CMD_STDPATH);	/* use command -p path */
  nofork = (cmdflags & CMD_NO_FORK);	/* Don't fork, just exec, if no pipes */
  pathname = words->word->word;

  p = 0;
  result = EXECUTION_SUCCESS;
#if defined (RESTRICTED_SHELL)
  command = (char *)NULL;
  if (restricted && mbschr (pathname, '/'))
    {
      internal_error (_("%s: restricted: cannot specify `/' in command names"),
		    pathname);
      result = last_command_exit_value = EXECUTION_FAILURE;

      /* If we're not going to fork below, we must already be in a child
         process or a context in which it's safe to call exit(2).  */
      if (nofork && pipe_in == NO_PIPE && pipe_out == NO_PIPE)
	exit (last_command_exit_value);
      else
	goto parent_return;
    }
#endif /* RESTRICTED_SHELL */

  command = search_for_command (pathname, CMDSRCH_HASH|(stdpath ? CMDSRCH_STDPATH : 0));
  QUIT;

  if (command)
    {
      /* If we're optimizing out the fork (implicit `exec'), decrement the
	 shell level like `exec' would do. */
#if 0 /* TAG: bash-5.2 psmith 10/11/2020 */
      if (nofork && pipe_in == NO_PIPE && pipe_out == NO_PIPE && (subshell_environment & SUBSHELL_PIPE) == 0)
#else
      if (nofork && pipe_in == NO_PIPE && pipe_out == NO_PIPE)
#endif
	adjust_shell_level (-1);

      maybe_make_export_env ();
      put_command_name_into_env (command);
    }

  /* We have to make the child before we check for the non-existence
     of COMMAND, since we want the error messages to be redirected. */
  /* If we can get away without forking and there are no pipes to deal with,
     don't bother to fork, just directly exec the command. */
  if (nofork && pipe_in == NO_PIPE && pipe_out == NO_PIPE)
    pid = 0;
  else
    {
      fork_flags = async ? FORK_ASYNC : 0;
      pid = make_child (p = savestring (command_line), fork_flags);
    }

  if (pid == 0)
    {
      int old_interactive;

      reset_terminating_signals ();	/* XXX */
      /* Cancel traps, in trap.c. */
      restore_original_signals ();

#if defined (JOB_CONTROL)
      FREE (p);
#endif

      /* restore_original_signals may have undone the work done
	 by make_child to ensure that SIGINT and SIGQUIT are ignored
	 in asynchronous children. */
      if (async)
	{
	  if ((cmdflags & CMD_STDIN_REDIR) &&
		pipe_in == NO_PIPE &&
		(stdin_redirects (redirects) == 0))
	    async_redirect_stdin ();
	  setup_async_signals ();
	}

      /* This functionality is now provided by close-on-exec of the
	 file descriptors manipulated by redirection and piping.
	 Some file descriptors still need to be closed in all children
	 because of the way bash does pipes; fds_to_close is a
	 bitmap of all such file descriptors. */
      if (fds_to_close)
	close_fd_bitmap (fds_to_close);

      do_piping (pipe_in, pipe_out);

      old_interactive = interactive;
      if (async)
	interactive = 0;

      subshell_environment |= SUBSHELL_FORK;	/* XXX - was just = */

#if defined (PROCESS_SUBSTITUTION) && !defined (HAVE_DEV_FD)
      clear_fifo_list ();	/* XXX - we haven't created any FIFOs */
#endif

      if (redirects && (do_redirections (redirects, RX_ACTIVE) != 0))
	{
#if defined (PROCESS_SUBSTITUTION)
	  /* Try to remove named pipes that may have been created as the
	     result of redirections. */
	  unlink_fifo_list ();
#endif /* PROCESS_SUBSTITUTION */
	  exit (EXECUTION_FAILURE);
	}

      if (async)
	interactive = old_interactive;

      if (command == 0)
	{
	  hookf = find_function (NOTFOUND_HOOK);
	  if (hookf == 0)
	    {
	      /* Make sure filenames are displayed using printable characters */
	      pathname = printable_filename (pathname, 0);
	      internal_error (_("%s: command not found"), pathname);
	      exit (EX_NOTFOUND);	/* Posix.2 says the exit status is 127 */
	    }

	  /* We don't want to manage process groups for processes we start
	     from here, so we turn off job control and don't attempt to
	     manipulate the terminal's process group. */
	  without_job_control ();

#if defined (JOB_CONTROL)
	  set_sigchld_handler ();
#endif

	  wl = make_word_list (make_word (NOTFOUND_HOOK), words);
	  exit (execute_shell_function (hookf, wl));
	}

      /* Execve expects the command name to be in args[0].  So we
	 leave it there, in the same format that the user used to
	 type it in. */
      args = strvec_from_word_list (words, 0, 0, (int *)NULL);
      exit (shell_execve (command, args, export_env));
    }
  else
    {
parent_return:
      QUIT;

      /* Make sure that the pipes are closed in the parent. */
      close_pipes (pipe_in, pipe_out);
#if defined (PROCESS_SUBSTITUTION) && defined (HAVE_DEV_FD)
#if 0
      if (variable_context == 0)
        unlink_fifo_list ();
#endif
#endif
      FREE (command);
      return (result);
    }
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\execute_cmd.c:5,450
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\execute_cmd.c:5,633
parsing error 
{
  register int i;
  char *execname;
  int start;

  /* Find the name of the interpreter to exec. */
  for (i = 2; i < sample_len && whitespace (sample[i]); i++)
    ;

  for (start = i; STRINGCHAR(i); i++)
    ;

  execname = substring (sample, start, i);

  if (endp)
    *endp = i;
  return execname;
}
warning: parse error {
  register int i;
  char *execname;
  int start;

  /* Find the name of the interpreter to exec. */
  for (i = 2; i < sample_len && whitespace (sample[i]); i++)
    ;

  for (start = i; STRINGCHAR(i); i++)
    ;

  execname = substring (sample, start, i);

  if (endp)
    *endp = i;
  return execname;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\execute_cmd.c:5,636
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\execute_cmd.c:5,667
parsing error 
{
  char *execname, *firstarg;
  int i, start, size_increment, larry;

  /* Find the name of the interpreter to exec. */
  execname = getinterp (sample, sample_len, &i);
  size_increment = 1;

  /* Now the argument, if any. */
  for (firstarg = (char *)NULL, start = i; WHITECHAR(i); i++)
    ;

  /* If there is more text on the line, then it is an argument for the
     interpreter. */

  if (STRINGCHAR(i))  
    {
      for (start = i; STRINGCHAR(i); i++)
	;
      firstarg = substring ((char *)sample, start, i);
      size_increment = 2;
    }

  larry = strvec_len (args) + size_increment;
  args = strvec_resize (args, larry + 1);

  for (i = larry - 1; i; i--)
    args[i] = args[i - size_increment];

  args[0] = execname;
  if (firstarg)
    {
      args[1] = firstarg;
      args[2] = command;
    }
  else
    args[1] = command;

  args[larry] = (char *)NULL;

  return (shell_execve (execname, args, env));
}
warning: parse error {
  char *execname, *firstarg;
  int i, start, size_increment, larry;

  /* Find the name of the interpreter to exec. */
  execname = getinterp (sample, sample_len, &i);
  size_increment = 1;

  /* Now the argument, if any. */
  for (firstarg = (char *)NULL, start = i; WHITECHAR(i); i++)
    ;

  /* If there is more text on the line, then it is an argument for the
     interpreter. */

  if (STRINGCHAR(i))  
    {
      for (start = i; STRINGCHAR(i); i++)
	;
      firstarg = substring ((char *)sample, start, i);
      size_increment = 2;
    }

  larry = strvec_len (args) + size_increment;
  args = strvec_resize (args, larry + 1);

  for (i = larry - 1; i; i--)
    args[i] = args[i - size_increment];

  args[0] = execname;
  if (firstarg)
    {
      args[1] = firstarg;
      args[2] = command;
    }
  else
    args[1] = command;

  args[larry] = (char *)NULL;

  return (shell_execve (execname, args, env));
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\execute_cmd.c:5,672
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\execute_cmd.c:5,794
parsing error 
{
  int larray, i, fd;
  char sample[HASH_BANG_BUFSIZ];
  int sample_len;

  SETOSTYPE (0);		/* Some systems use for USG/POSIX semantics */
  execve (command, args, env);
  i = errno;			/* error from execve() */
  CHECK_TERMSIG;
  SETOSTYPE (1);

  /* If we get to this point, then start checking out the file.
     Maybe it is something we can hack ourselves. */
  if (i != ENOEXEC)
    {
      /* make sure this is set correctly for file_error/report_error */
      last_command_exit_value = (i == ENOENT) ?  EX_NOTFOUND : EX_NOEXEC; /* XXX Posix.2 says that exit status is 126 */
      if (file_isdir (command))
#if defined (EISDIR)
	internal_error (_("%s: %s"), command, strerror (EISDIR));
#else
	internal_error (_("%s: is a directory"), command);
#endif
      else if (executable_file (command) == 0)
	{
	  errno = i;
	  file_error (command);
	}
      /* errors not involving the path argument to execve. */
      else if (i == E2BIG || i == ENOMEM)
	{
	  errno = i;
	  file_error (command);
	}
      else
	{
	  /* The file has the execute bits set, but the kernel refuses to
	     run it for some reason.  See why. */
#if defined (HAVE_HASH_BANG_EXEC)
	  READ_SAMPLE_BUF (command, sample, sample_len);
	  if (sample_len > 0)
	    sample[sample_len - 1] = '\0';
	  if (sample_len > 2 && sample[0] == '#' && sample[1] == '!')
	    {
	      char *interp;
	      int ilen;

	      interp = getinterp (sample, sample_len, (int *)NULL);
	      ilen = strlen (interp);
	      errno = i;
	      if (interp[ilen - 1] == '\r')
		{
		  interp = xrealloc (interp, ilen + 2);
		  interp[ilen - 1] = '^';
		  interp[ilen] = 'M';
		  interp[ilen + 1] = '\0';
		}
	      sys_error (_("%s: %s: bad interpreter"), command, interp ? interp : "");
	      FREE (interp);
	      return (EX_NOEXEC);
	    }
#endif
	  errno = i;
	  file_error (command);
	}
      return (last_command_exit_value);
    }

  /* This file is executable.
     If it begins with #!, then help out people with losing operating
     systems.  Otherwise, check to see if it is a binary file by seeing
     if the contents of the first line (or up to 80 characters) are in the
     ASCII set.  If it's a text file, execute the contents as shell commands,
     otherwise return 126 (EX_BINARY_FILE). */
  READ_SAMPLE_BUF (command, sample, sample_len);

  if (sample_len == 0)
    return (EXECUTION_SUCCESS);

  /* Is this supposed to be an executable script?
     If so, the format of the line is "#! interpreter [argument]".
     A single argument is allowed.  The BSD kernel restricts
     the length of the entire line to 32 characters (32 bytes
     being the size of the BSD exec header), but we allow 80
     characters. */
  if (sample_len > 0)
    {
#if !defined (HAVE_HASH_BANG_EXEC)
      if (sample_len > 2 && sample[0] == '#' && sample[1] == '!')
	return (execute_shell_script (sample, sample_len, command, args, env));
      else
#endif
      if (check_binary_file (sample, sample_len))
	{
	  internal_error (_("%s: cannot execute binary file: %s"), command, strerror (i));
	  errno = i;
	  return (EX_BINARY_FILE);
	}
    }

  /* We have committed to attempting to execute the contents of this file
     as shell commands. */

  reset_parser ();
  initialize_subshell ();

  set_sigint_handler ();

  /* Insert the name of this shell into the argument list. */
  larray = strvec_len (args) + 1;
  args = strvec_resize (args, larray + 1);

  for (i = larray - 1; i; i--)
    args[i] = args[i - 1];

  args[0] = shell_name;
  args[1] = command;
  args[larray] = (char *)NULL;

  if (args[0][0] == '-')
    args[0]++;

#if defined (RESTRICTED_SHELL)
  if (restricted)
    change_flag ('r', FLAG_OFF);
#endif

  if (subshell_argv)
    {
      /* Can't free subshell_argv[0]; that is shell_name. */
      for (i = 1; i < subshell_argc; i++)
	free (subshell_argv[i]);
      free (subshell_argv);
    }

  dispose_command (currently_executing_command);	/* XXX */
  currently_executing_command = (COMMAND *)NULL;

  subshell_argc = larray;
  subshell_argv = args;
  subshell_envp = env;

  unbind_args ();	/* remove the positional parameters */

#if defined (PROCESS_SUBSTITUTION) && defined (HAVE_DEV_FD)
  clear_fifo_list ();	/* pipe fds are what they are now */
#endif

  sh_longjmp (subshell_top_level, 1);
  /*NOTREACHED*/
}
warning: parse error {
  int larray, i, fd;
  char sample[HASH_BANG_BUFSIZ];
  int sample_len;

  SETOSTYPE (0);		/* Some systems use for USG/POSIX semantics */
  execve (command, args, env);
  i = errno;			/* error from execve() */
  CHECK_TERMSIG;
  SETOSTYPE (1);

  /* If we get to this point, then start checking out the file.
     Maybe it is something we can hack ourselves. */
  if (i != ENOEXEC)
    {
      /* make sure this is set correctly for file_error/report_error */
      last_command_exit_value = (i == ENOENT) ?  EX_NOTFOUND : EX_NOEXEC; /* XXX Posix.2 says that exit status is 126 */
      if (file_isdir (command))
#if defined (EISDIR)
	internal_error (_("%s: %s"), command, strerror (EISDIR));
#else
	internal_error (_("%s: is a directory"), command);
#endif
      else if (executable_file (command) == 0)
	{
	  errno = i;
	  file_error (command);
	}
      /* errors not involving the path argument to execve. */
      else if (i == E2BIG || i == ENOMEM)
	{
	  errno = i;
	  file_error (command);
	}
      else
	{
	  /* The file has the execute bits set, but the kernel refuses to
	     run it for some reason.  See why. */
#if defined (HAVE_HASH_BANG_EXEC)
	  READ_SAMPLE_BUF (command, sample, sample_len);
	  if (sample_len > 0)
	    sample[sample_len - 1] = '\0';
	  if (sample_len > 2 && sample[0] == '#' && sample[1] == '!')
	    {
	      char *interp;
	      int ilen;

	      interp = getinterp (sample, sample_len, (int *)NULL);
	      ilen = strlen (interp);
	      errno = i;
	      if (interp[ilen - 1] == '\r')
		{
		  interp = xrealloc (interp, ilen + 2);
		  interp[ilen - 1] = '^';
		  interp[ilen] = 'M';
		  interp[ilen + 1] = '\0';
		}
	      sys_error (_("%s: %s: bad interpreter"), command, interp ? interp : "");
	      FREE (interp);
	      return (EX_NOEXEC);
	    }
#endif
	  errno = i;
	  file_error (command);
	}
      return (last_command_exit_value);
    }

  /* This file is executable.
     If it begins with #!, then help out people with losing operating
     systems.  Otherwise, check to see if it is a binary file by seeing
     if the contents of the first line (or up to 80 characters) are in the
     ASCII set.  If it's a text file, execute the contents as shell commands,
     otherwise return 126 (EX_BINARY_FILE). */
  READ_SAMPLE_BUF (command, sample, sample_len);

  if (sample_len == 0)
    return (EXECUTION_SUCCESS);

  /* Is this supposed to be an executable script?
     If so, the format of the line is "#! interpreter [argument]".
     A single argument is allowed.  The BSD kernel restricts
     the length of the entire line to 32 characters (32 bytes
     being the size of the BSD exec header), but we allow 80
     characters. */
  if (sample_len > 0)
    {
#if !defined (HAVE_HASH_BANG_EXEC)
      if (sample_len > 2 && sample[0] == '#' && sample[1] == '!')
	return (execute_shell_script (sample, sample_len, command, args, env));
      else
#endif
      if (check_binary_file (sample, sample_len))
	{
	  internal_error (_("%s: cannot execute binary file: %s"), command, strerror (i));
	  errno = i;
	  return (EX_BINARY_FILE);
	}
    }

  /* We have committed to attempting to execute the contents of this file
     as shell commands. */

  reset_parser ();
  initialize_subshell ();

  set_sigint_handler ();

  /* Insert the name of this shell into the argument list. */
  larray = strvec_len (args) + 1;
  args = strvec_resize (args, larray + 1);

  for (i = larray - 1; i; i--)
    args[i] = args[i - 1];

  args[0] = shell_name;
  args[1] = command;
  args[larray] = (char *)NULL;

  if (args[0][0] == '-')
    args[0]++;

#if defined (RESTRICTED_SHELL)
  if (restricted)
    change_flag ('r', FLAG_OFF);
#endif

  if (subshell_argv)
    {
      /* Can't free subshell_argv[0]; that is shell_name. */
      for (i = 1; i < subshell_argc; i++)
	free (subshell_argv[i]);
      free (subshell_argv);
    }

  dispose_command (currently_executing_command);	/* XXX */
  currently_executing_command = (COMMAND *)NULL;

  subshell_argc = larray;
  subshell_argv = args;
  subshell_envp = env;

  unbind_args ();	/* remove the positional parameters */

#if defined (PROCESS_SUBSTITUTION) && defined (HAVE_DEV_FD)
  clear_fifo_list ();	/* pipe fds are what they are now */
#endif

  sh_longjmp (subshell_top_level, 1);
  /*NOTREACHED*/
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\execute_cmd.c:5,797
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\execute_cmd.c:5,950
parsing error 
{
  SHELL_VAR *var;
  char *t;

  if (check_identifier (name, posixly_correct) == 0)
    {
      if (posixly_correct && interactive_shell == 0)
	{
	  last_command_exit_value = EX_BADUSAGE;
	  jump_to_top_level (ERREXIT);
	}
      return (EXECUTION_FAILURE);
    }

  if (strchr (name->word, CTLESC))	/* WHY? */
    {
      t = dequote_escapes (name->word);
      free (name->word);
      name->word = t;
    }

  /* Posix interpretation 383 */
  if (posixly_correct && find_special_builtin (name->word))
    {
      internal_error (_("`%s': is a special builtin"), name->word);
      last_command_exit_value = EX_BADUSAGE;
      jump_to_top_level (interactive_shell ? DISCARD : ERREXIT);
    }

  var = find_function (name->word);
  if (var && (readonly_p (var) || noassign_p (var)))
    {
      if (readonly_p (var))
	internal_error (_("%s: readonly function"), var->name);
      return (EXECUTION_FAILURE);
    }

#if defined (DEBUGGER)
  bind_function_def (name->word, funcdef, 1);
#endif

  bind_function (name->word, funcdef->command);
  return (EXECUTION_SUCCESS);
}
warning: parse error {
  SHELL_VAR *var;
  char *t;

  if (check_identifier (name, posixly_correct) == 0)
    {
      if (posixly_correct && interactive_shell == 0)
	{
	  last_command_exit_value = EX_BADUSAGE;
	  jump_to_top_level (ERREXIT);
	}
      return (EXECUTION_FAILURE);
    }

  if (strchr (name->word, CTLESC))	/* WHY? */
    {
      t = dequote_escapes (name->word);
      free (name->word);
      name->word = t;
    }

  /* Posix interpretation 383 */
  if (posixly_correct && find_special_builtin (name->word))
    {
      internal_error (_("`%s': is a special builtin"), name->word);
      last_command_exit_value = EX_BADUSAGE;
      jump_to_top_level (interactive_shell ? DISCARD : ERREXIT);
    }

  var = find_function (name->word);
  if (var && (readonly_p (var) || noassign_p (var)))
    {
      if (readonly_p (var))
	internal_error (_("%s: readonly function"), var->name);
      return (EXECUTION_FAILURE);
    }

#if defined (DEBUGGER)
  bind_function_def (name->word, funcdef, 1);
#endif

  bind_function (name->word, funcdef->command);
  return (EXECUTION_SUCCESS);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\execute_cmd.c:5,953
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\execute_cmd.c:6,016
parsing error 
{
  if (in >= 0)
    close (in);
  if (out >= 0)
    close (out);
}
warning: parse error {
  if (in >= 0)
    close (in);
  if (out >= 0)
    close (out);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\execute_cmd.c:6,018
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\execute_cmd.c:6,026
parsing error 
{
  sys_error (_("cannot duplicate fd %d to fd %d"), oldd, newd);
}
warning: parse error {
  sys_error (_("cannot duplicate fd %d to fd %d"), oldd, newd);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\execute_cmd.c:6,028
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\execute_cmd.c:6,035
parsing error 
{
  if (pipe_in != NO_PIPE)
    {
      if (dup2 (pipe_in, 0) < 0)
	dup_error (pipe_in, 0);
      if (pipe_in > 0)
	close (pipe_in);
#ifdef __CYGWIN__
      /* Let stdio know the fd may have changed from text to binary mode. */
      freopen (NULL, "r", stdin);
#endif /* __CYGWIN__ */
    }
  if (pipe_out != NO_PIPE)
    {
      if (pipe_out != REDIRECT_BOTH)
	{
	  if (dup2 (pipe_out, 1) < 0)
	    dup_error (pipe_out, 1);
	  if (pipe_out == 0 || pipe_out > 1)
	    close (pipe_out);
	}
      else
	{
	  if (dup2 (1, 2) < 0)
	    dup_error (1, 2);
	}
#ifdef __CYGWIN__
      /* Let stdio know the fd may have changed from text to binary mode, and
	 make sure to preserve stdout line buffering. */
      freopen (NULL, "w", stdout);
      sh_setlinebuf (stdout);
#endif /* __CYGWIN__ */
    }
}
warning: parse error {
  if (pipe_in != NO_PIPE)
    {
      if (dup2 (pipe_in, 0) < 0)
	dup_error (pipe_in, 0);
      if (pipe_in > 0)
	close (pipe_in);
#ifdef __CYGWIN__
      /* Let stdio know the fd may have changed from text to binary mode. */
      freopen (NULL, "r", stdin);
#endif /* __CYGWIN__ */
    }
  if (pipe_out != NO_PIPE)
    {
      if (pipe_out != REDIRECT_BOTH)
	{
	  if (dup2 (pipe_out, 1) < 0)
	    dup_error (pipe_out, 1);
	  if (pipe_out == 0 || pipe_out > 1)
	    close (pipe_out);
	}
      else
	{
	  if (dup2 (1, 2) < 0)
	    dup_error (1, 2);
	}
#ifdef __CYGWIN__
      /* Let stdio know the fd may have changed from text to binary mode, and
	 make sure to preserve stdout line buffering. */
      freopen (NULL, "w", stdout);
      sh_setlinebuf (stdout);
#endif /* __CYGWIN__ */
    }
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\execute_cmd.c:6,037
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\expr.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashansi.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\chartypes.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashintl.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\shell.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\arrayfunc.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\execute_cmd.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\flags.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\typemax.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\expr.c:322
parsing error 
{
  SHELL_VAR *v;
  int aflags;

  if (lhs == 0 || *lhs == 0)
    return;		/* XXX */

#if defined (ARRAY_VARS)
  aflags = (assoc_expand_once && already_expanded) ? ASS_NOEXPAND : 0;
#else
  aflags = 0;
#endif
  v = bind_int_variable (lhs, rhs, aflags);
  if (v && (readonly_p (v) || noassign_p (v)))
    sh_longjmp (evalbuf, 1);	/* variable assignment error */
  stupidly_hack_special_variables (lhs);
}
warning: parse error {
  SHELL_VAR *v;
  int aflags;

  if (lhs == 0 || *lhs == 0)
    return;		/* XXX */

#if defined (ARRAY_VARS)
  aflags = (assoc_expand_once && already_expanded) ? ASS_NOEXPAND : 0;
#else
  aflags = 0;
#endif
  v = bind_int_variable (lhs, rhs, aflags);
  if (v && (readonly_p (v) || noassign_p (v)))
    sh_longjmp (evalbuf, 1);	/* variable assignment error */
  stupidly_hack_special_variables (lhs);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\expr.c:324
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\expr.c:405
parsing error 
{
  intmax_t val;
  int c;
  procenv_t oevalbuf;

  val = 0;
  noeval = 0;
  already_expanded = (flags&EXP_EXPANDED);

  FASTCOPY (evalbuf, oevalbuf, sizeof (evalbuf));

  c = setjmp_nosigs (evalbuf);

  if (c)
    {
      FREE (tokstr);
      FREE (expression);
      tokstr = expression = (char *)NULL;

      expr_unwind ();
      expr_depth = 0;	/* XXX - make sure */

      /* We copy in case we've called evalexp recursively */
      FASTCOPY (oevalbuf, evalbuf, sizeof (evalbuf));

      if (validp)
	*validp = 0;
      return (0);
    }

  val = subexpr (expr);

  if (validp)
    *validp = 1;

  FASTCOPY (oevalbuf, evalbuf, sizeof (evalbuf));

  return (val);
}
warning: parse error {
  intmax_t val;
  int c;
  procenv_t oevalbuf;

  val = 0;
  noeval = 0;
  already_expanded = (flags&EXP_EXPANDED);

  FASTCOPY (evalbuf, oevalbuf, sizeof (evalbuf));

  c = setjmp_nosigs (evalbuf);

  if (c)
    {
      FREE (tokstr);
      FREE (expression);
      tokstr = expression = (char *)NULL;

      expr_unwind ();
      expr_depth = 0;	/* XXX - make sure */

      /* We copy in case we've called evalexp recursively */
      FASTCOPY (oevalbuf, evalbuf, sizeof (evalbuf));

      if (validp)
	*validp = 0;
      return (0);
    }

  val = subexpr (expr);

  if (validp)
    *validp = 1;

  FASTCOPY (oevalbuf, evalbuf, sizeof (evalbuf));

  return (val);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\expr.c:409
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\expr.c:450
parsing error 
{
  intmax_t val;
  char *p;

  for (p = expr; p && *p && cr_whitespace (*p); p++)
    ;

  if (p == NULL || *p == '\0')
    return (0);

  pushexp ();
  expression = savestring (expr);
  tp = expression;

  curtok = lasttok = 0;
  tokstr = (char *)NULL;
  tokval = 0;
  init_lvalue (&curlval);
  lastlval = curlval;

  readtok ();

  val = EXP_HIGHEST ();

  if (curtok != 0)
    evalerror (_("syntax error in expression"));

  FREE (tokstr);
  FREE (expression);

  popexp ();

  return val;
}
warning: parse error {
  intmax_t val;
  char *p;

  for (p = expr; p && *p && cr_whitespace (*p); p++)
    ;

  if (p == NULL || *p == '\0')
    return (0);

  pushexp ();
  expression = savestring (expr);
  tp = expression;

  curtok = lasttok = 0;
  tokstr = (char *)NULL;
  tokval = 0;
  init_lvalue (&curlval);
  lastlval = curlval;

  readtok ();

  val = EXP_HIGHEST ();

  if (curtok != 0)
    evalerror (_("syntax error in expression"));

  FREE (tokstr);
  FREE (expression);

  popexp ();

  return val;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\expr.c:452
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\expr.c:942
parsing error 
{
  intmax_t result;

  result = 1;
  while (exp)
    {
      if (exp & 1)
	result *= base;
      exp >>= 1;
      base *= base;
    }
  return result;
}
warning: parse error {
  intmax_t result;

  result = 1;
  while (exp)
    {
      if (exp & 1)
	result *= base;
      exp >>= 1;
      base *= base;
    }
  return result;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\expr.c:944
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\expr.c:1,113
parsing error 
{
  lv->tokstr = 0;
  lv->tokvar = 0;
  lv->tokval = lv->ind = -1;
}
warning: parse error {
  lv->tokstr = 0;
  lv->tokvar = 0;
  lv->tokval = lv->ind = -1;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\expr.c:1,115
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\expr.c:1,132
parsing error 
{
  free (lv);		/* should be inlined */
}
warning: parse error {
  free (lv);		/* should be inlined */
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\expr.c:1,134
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\expr.c:1,139
parsing error 
{
  SHELL_VAR *v;
  char *value;
  intmax_t tval;
  int initial_depth;
#if defined (ARRAY_VARS)
  arrayind_t ind;
  int tflag, aflag;
#endif

/*itrace("expr_streval: %s: noeval = %d expanded=%d", tok, noeval, already_expanded);*/
  /* If we are suppressing evaluation, just short-circuit here instead of
     going through the rest of the evaluator. */
  if (noeval)
    return (0);

  initial_depth = expr_depth;

#if defined (ARRAY_VARS)
  tflag = assoc_expand_once && already_expanded;	/* for a start */
#endif

  /* [[[[[ */
#if defined (ARRAY_VARS)
  aflag = (tflag) ? AV_NOEXPAND : 0;
  v = (e == ']') ? array_variable_part (tok, tflag, (char **)0, (int *)0) : find_variable (tok);
#else
  v = find_variable (tok);
#endif
  if (v == 0 && e != ']')
    v = find_variable_last_nameref (tok, 0);  

  if ((v == 0 || invisible_p (v)) && unbound_vars_is_error)
    {
#if defined (ARRAY_VARS)
      value = (e == ']') ? array_variable_name (tok, tflag, (char **)0, (int *)0) : tok;
#else
      value = tok;
#endif

      set_exit_status (EXECUTION_FAILURE);
      err_unboundvar (value);

#if defined (ARRAY_VARS)
      if (e == ']')
	FREE (value);	/* array_variable_name returns new memory */
#endif

      if (no_longjmp_on_fatal_error && interactive_shell)
	sh_longjmp (evalbuf, 1);

      if (interactive_shell)
	{
	  expr_unwind ();
	  top_level_cleanup ();
	  jump_to_top_level (DISCARD);
	}
      else
	jump_to_top_level (FORCE_EOF);
    }

#if defined (ARRAY_VARS)
  ind = -1;
  /* If the second argument to get_array_value doesn't include AV_ALLOWALL,
     we don't allow references like array[@].  In this case, get_array_value
     is just like get_variable_value in that it does not return newly-allocated
     memory or quote the results.  AFLAG is set above and is either AV_NOEXPAND
     or 0. */
  value = (e == ']') ? get_array_value (tok, aflag, (int *)NULL, &ind) : get_variable_value (v);
#else
  value = get_variable_value (v);
#endif

  if (expr_depth < initial_depth)
    {
      if (no_longjmp_on_fatal_error && interactive_shell)
	sh_longjmp (evalbuf, 1);
      return (0);
    }

  tval = (value && *value) ? subexpr (value) : 0;

  if (lvalue)
    {
      lvalue->tokstr = tok;	/* XXX */
      lvalue->tokval = tval;
      lvalue->tokvar = v;	/* XXX */
#if defined (ARRAY_VARS)
      lvalue->ind = ind;
#else
      lvalue->ind = -1;
#endif
    }
	  
  return (tval);
}
warning: parse error {
  SHELL_VAR *v;
  char *value;
  intmax_t tval;
  int initial_depth;
#if defined (ARRAY_VARS)
  arrayind_t ind;
  int tflag, aflag;
#endif

/*itrace("expr_streval: %s: noeval = %d expanded=%d", tok, noeval, already_expanded);*/
  /* If we are suppressing evaluation, just short-circuit here instead of
     going through the rest of the evaluator. */
  if (noeval)
    return (0);

  initial_depth = expr_depth;

#if defined (ARRAY_VARS)
  tflag = assoc_expand_once && already_expanded;	/* for a start */
#endif

  /* [[[[[ */
#if defined (ARRAY_VARS)
  aflag = (tflag) ? AV_NOEXPAND : 0;
  v = (e == ']') ? array_variable_part (tok, tflag, (char **)0, (int *)0) : find_variable (tok);
#else
  v = find_variable (tok);
#endif
  if (v == 0 && e != ']')
    v = find_variable_last_nameref (tok, 0);  

  if ((v == 0 || invisible_p (v)) && unbound_vars_is_error)
    {
#if defined (ARRAY_VARS)
      value = (e == ']') ? array_variable_name (tok, tflag, (char **)0, (int *)0) : tok;
#else
      value = tok;
#endif

      set_exit_status (EXECUTION_FAILURE);
      err_unboundvar (value);

#if defined (ARRAY_VARS)
      if (e == ']')
	FREE (value);	/* array_variable_name returns new memory */
#endif

      if (no_longjmp_on_fatal_error && interactive_shell)
	sh_longjmp (evalbuf, 1);

      if (interactive_shell)
	{
	  expr_unwind ();
	  top_level_cleanup ();
	  jump_to_top_level (DISCARD);
	}
      else
	jump_to_top_level (FORCE_EOF);
    }

#if defined (ARRAY_VARS)
  ind = -1;
  /* If the second argument to get_array_value doesn't include AV_ALLOWALL,
     we don't allow references like array[@].  In this case, get_array_value
     is just like get_variable_value in that it does not return newly-allocated
     memory or quote the results.  AFLAG is set above and is either AV_NOEXPAND
     or 0. */
  value = (e == ']') ? get_array_value (tok, aflag, (int *)NULL, &ind) : get_variable_value (v);
#else
  value = get_variable_value (v);
#endif

  if (expr_depth < initial_depth)
    {
      if (no_longjmp_on_fatal_error && interactive_shell)
	sh_longjmp (evalbuf, 1);
      return (0);
    }

  tval = (value && *value) ? subexpr (value) : 0;

  if (lvalue)
    {
      lvalue->tokstr = tok;	/* XXX */
      lvalue->tokval = tval;
      lvalue->tokvar = v;	/* XXX */
#if defined (ARRAY_VARS)
      lvalue->ind = ind;
#else
      lvalue->ind = -1;
#endif
    }
	  
  return (tval);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\expr.c:1,143
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\expr.c:1,241
parsing error 
{
  switch (c)
    {
    case EQEQ:
    case NEQ:
    case LEQ:
    case GEQ:
    case LAND:
    case LOR:
    case LSH:
    case RSH:
    case OP_ASSIGN:
    case COND:
    case POWER:
    case PREINC:
    case PREDEC:
    case POSTINC:
    case POSTDEC:
      return 1;
    default:
      return 0;
    }
}
warning: parse error {
  switch (c)
    {
    case EQEQ:
    case NEQ:
    case LEQ:
    case GEQ:
    case LAND:
    case LOR:
    case LSH:
    case RSH:
    case OP_ASSIGN:
    case COND:
    case POWER:
    case PREINC:
    case PREDEC:
    case POSTINC:
    case POSTDEC:
      return 1;
    default:
      return 0;
    }
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\expr.c:1,243
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\expr.c:1,268
parsing error 
{
  switch (c)
    {
    case EQ:
    case GT:
    case LT:
    case PLUS:
    case MINUS:
    case MUL:
    case DIV:
    case MOD:
    case NOT:
    case LPAR:
    case RPAR:
    case BAND:
    case BOR:
    case BXOR:
    case BNOT:
      return 1;		/* operator tokens */
    case QUES:
    case COL:
    case COMMA:
      return 1;		/* questionable */
    default:
      return 0;		/* anything else is invalid */
    }
}
warning: parse error {
  switch (c)
    {
    case EQ:
    case GT:
    case LT:
    case PLUS:
    case MINUS:
    case MUL:
    case DIV:
    case MOD:
    case NOT:
    case LPAR:
    case RPAR:
    case BAND:
    case BOR:
    case BXOR:
    case BNOT:
      return 1;		/* operator tokens */
    case QUES:
    case COL:
    case COMMA:
      return 1;		/* questionable */
    default:
      return 0;		/* anything else is invalid */
    }
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\expr.c:1,270
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\expr.c:1,506
parsing error 
{
  char *name, *t;

  name = this_command_name;
  for (t = expression; t && whitespace (*t); t++)
    ;
  internal_error (_("%s%s%s: %s (error token is \"%s\")"),
		   name ? name : "", name ? ": " : "",
		   t ? t : "", msg, (lasttp && *lasttp) ? lasttp : "");
  sh_longjmp (evalbuf, 1);
}
warning: parse error {
  char *name, *t;

  name = this_command_name;
  for (t = expression; t && whitespace (*t); t++)
    ;
  internal_error (_("%s%s%s: %s (error token is \"%s\")"),
		   name ? name : "", name ? ": " : "",
		   t ? t : "", msg, (lasttp && *lasttp) ? lasttp : "");
  sh_longjmp (evalbuf, 1);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\expr.c:1,507
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\expr.c:1,533
parsing error 
{
  register char *s;
  register unsigned char c;
  int base, foundbase;
  intmax_t val;

  s = num;

  base = 10;
  foundbase = 0;
  if (*s == '0')
    {
      s++;

      if (*s == '\0')
	return 0;

       /* Base 16? */
      if (*s == 'x' || *s == 'X')
	{
	  base = 16;
	  s++;
	}
      else
	base = 8;
      foundbase++;
    }

  val = 0;
  for (c = *s++; c; c = *s++)
    {
      if (c == '#')
	{
	  if (foundbase)
	    evalerror (_("invalid number"));

	  /* Illegal base specifications raise an evaluation error. */
	  if (val < 2 || val > 64)
	    evalerror (_("invalid arithmetic base"));

	  base = val;
	  val = 0;
	  foundbase++;

	  /* Make sure a base# is followed by a character that can compose a
	     valid integer constant. Jeremy Townshend <jeremy.townshend@gmail.com> */
	  if (VALID_NUMCHAR (*s) == 0)
	    evalerror (_("invalid integer constant"));
	}
      else if (VALID_NUMCHAR (c))
	{
	  if (DIGIT(c))
	    c = TODIGIT(c);
	  else if (c >= 'a' && c <= 'z')
	    c -= 'a' - 10;
	  else if (c >= 'A' && c <= 'Z')
	    c -= 'A' - ((base <= 36) ? 10 : 36);
	  else if (c == '@')
	    c = 62;
	  else if (c == '_')
	    c = 63;

	  if (c >= base)
	    evalerror (_("value too great for base"));

	  val = (val * base) + c;
	}
      else
	break;
    }

  return (val);
}
warning: parse error {
  register char *s;
  register unsigned char c;
  int base, foundbase;
  intmax_t val;

  s = num;

  base = 10;
  foundbase = 0;
  if (*s == '0')
    {
      s++;

      if (*s == '\0')
	return 0;

       /* Base 16? */
      if (*s == 'x' || *s == 'X')
	{
	  base = 16;
	  s++;
	}
      else
	base = 8;
      foundbase++;
    }

  val = 0;
  for (c = *s++; c; c = *s++)
    {
      if (c == '#')
	{
	  if (foundbase)
	    evalerror (_("invalid number"));

	  /* Illegal base specifications raise an evaluation error. */
	  if (val < 2 || val > 64)
	    evalerror (_("invalid arithmetic base"));

	  base = val;
	  val = 0;
	  foundbase++;

	  /* Make sure a base# is followed by a character that can compose a
	     valid integer constant. Jeremy Townshend <jeremy.townshend@gmail.com> */
	  if (VALID_NUMCHAR (*s) == 0)
	    evalerror (_("invalid integer constant"));
	}
      else if (VALID_NUMCHAR (c))
	{
	  if (DIGIT(c))
	    c = TODIGIT(c);
	  else if (c >= 'a' && c <= 'z')
	    c -= 'a' - 10;
	  else if (c >= 'A' && c <= 'Z')
	    c -= 'A' - ((base <= 36) ? 10 : 36);
	  else if (c == '@')
	    c = 62;
	  else if (c == '_')
	    c = 63;

	  if (c >= base)
	    evalerror (_("value too great for base"));

	  val = (val * base) + c;
	}
      else
	break;
    }

  return (val);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\expr.c:1,535
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\findcmd.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\chartypes.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashtypes.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\filecntl.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\posixstat.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashansi.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\memalloc.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\shell.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\execute_cmd.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\flags.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\hashlib.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\pathexp.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\hashcmd.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\findcmd.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\glob\strmatch.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\findcmd.c:92
parsing error 
{
  setup_ignore_patterns (&execignore);
}
warning: parse error {
  setup_ignore_patterns (&execignore);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\findcmd.c:94
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\findcmd.c:100
parsing error 
{
  struct ign *p;

  for (p = execignore.ignores; p && p->val; p++)
    if (strmatch (p->val, (char *)name, FNMATCH_EXTFLAG|FNM_CASEFOLD) != FNM_NOMATCH)
      return 1;
  return 0;
}
warning: parse error {
  struct ign *p;

  for (p = execignore.ignores; p && p->val; p++)
    if (strmatch (p->val, (char *)name, FNMATCH_EXTFLAG|FNM_CASEFOLD) != FNM_NOMATCH)
      return 1;
  return 0;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\findcmd.c:101
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\findcmd.c:116
parsing error 
{
  struct stat finfo;
  int r;

  /* Determine whether this file exists or not. */
  if (stat (name, &finfo) < 0)
    return (0);

  /* If the file is a directory, then it is not "executable" in the
     sense of the shell. */
  if (S_ISDIR (finfo.st_mode))
    return (FS_EXISTS|FS_DIRECTORY);

  r = FS_EXISTS;

#if defined (HAVE_EACCESS)
  /* Use eaccess(2) if we have it to take things like ACLs and other
     file access mechanisms into account.  eaccess uses the effective
     user and group IDs, not the real ones.  We could use sh_eaccess,
     but we don't want any special treatment for /dev/fd. */
  if (exec_name_should_ignore (name) == 0 && eaccess (name, X_OK) == 0)
    r |= FS_EXECABLE;
  if (eaccess (name, R_OK) == 0)
    r |= FS_READABLE;

  return r;
#elif defined (AFS)
  /* We have to use access(2) to determine access because AFS does not
     support Unix file system semantics.  This may produce wrong
     answers for non-AFS files when ruid != euid.  I hate AFS. */
  if (exec_name_should_ignore (name) == 0 && access (name, X_OK) == 0)
    r |= FS_EXECABLE;
  if (access (name, R_OK) == 0)
    r |= FS_READABLE;

  return r;
#else /* !HAVE_EACCESS && !AFS */

  /* Find out if the file is actually executable.  By definition, the
     only other criteria is that the file has an execute bit set that
     we can use.  The same with whether or not a file is readable. */

  /* Root only requires execute permission for any of owner, group or
     others to be able to exec a file, and can read any file. */
  if (current_user.euid == (uid_t)0)
    {
      r |= FS_READABLE;
      if (exec_name_should_ignore (name) == 0 && (finfo.st_mode & S_IXUGO))
	r |= FS_EXECABLE;
      return r;
    }

  /* If we are the owner of the file, the owner bits apply. */
  if (current_user.euid == finfo.st_uid)
    {
      if (exec_name_should_ignore (name) == 0 && (finfo.st_mode & S_IXUSR))
	r |= FS_EXECABLE;
      if (finfo.st_mode & S_IRUSR)
	r |= FS_READABLE;
    }

  /* If we are in the owning group, the group permissions apply. */
  else if (group_member (finfo.st_gid))
    {
      if (exec_name_should_ignore (name) == 0 && (finfo.st_mode & S_IXGRP))
	r |= FS_EXECABLE;
      if (finfo.st_mode & S_IRGRP)
	r |= FS_READABLE;
    }

  /* Else we check whether `others' have permission to execute the file */
  else
    {
      if (exec_name_should_ignore (name) == 0 && finfo.st_mode & S_IXOTH)
	r |= FS_EXECABLE;
      if (finfo.st_mode & S_IROTH)
	r |= FS_READABLE;
    }

  return r;
#endif /* !AFS */
}
warning: parse error {
  struct stat finfo;
  int r;

  /* Determine whether this file exists or not. */
  if (stat (name, &finfo) < 0)
    return (0);

  /* If the file is a directory, then it is not "executable" in the
     sense of the shell. */
  if (S_ISDIR (finfo.st_mode))
    return (FS_EXISTS|FS_DIRECTORY);

  r = FS_EXISTS;

#if defined (HAVE_EACCESS)
  /* Use eaccess(2) if we have it to take things like ACLs and other
     file access mechanisms into account.  eaccess uses the effective
     user and group IDs, not the real ones.  We could use sh_eaccess,
     but we don't want any special treatment for /dev/fd. */
  if (exec_name_should_ignore (name) == 0 && eaccess (name, X_OK) == 0)
    r |= FS_EXECABLE;
  if (eaccess (name, R_OK) == 0)
    r |= FS_READABLE;

  return r;
#elif defined (AFS)
  /* We have to use access(2) to determine access because AFS does not
     support Unix file system semantics.  This may produce wrong
     answers for non-AFS files when ruid != euid.  I hate AFS. */
  if (exec_name_should_ignore (name) == 0 && access (name, X_OK) == 0)
    r |= FS_EXECABLE;
  if (access (name, R_OK) == 0)
    r |= FS_READABLE;

  return r;
#else /* !HAVE_EACCESS && !AFS */

  /* Find out if the file is actually executable.  By definition, the
     only other criteria is that the file has an execute bit set that
     we can use.  The same with whether or not a file is readable. */

  /* Root only requires execute permission for any of owner, group or
     others to be able to exec a file, and can read any file. */
  if (current_user.euid == (uid_t)0)
    {
      r |= FS_READABLE;
      if (exec_name_should_ignore (name) == 0 && (finfo.st_mode & S_IXUGO))
	r |= FS_EXECABLE;
      return r;
    }

  /* If we are the owner of the file, the owner bits apply. */
  if (current_user.euid == finfo.st_uid)
    {
      if (exec_name_should_ignore (name) == 0 && (finfo.st_mode & S_IXUSR))
	r |= FS_EXECABLE;
      if (finfo.st_mode & S_IRUSR)
	r |= FS_READABLE;
    }

  /* If we are in the owning group, the group permissions apply. */
  else if (group_member (finfo.st_gid))
    {
      if (exec_name_should_ignore (name) == 0 && (finfo.st_mode & S_IXGRP))
	r |= FS_EXECABLE;
      if (finfo.st_mode & S_IRGRP)
	r |= FS_READABLE;
    }

  /* Else we check whether `others' have permission to execute the file */
  else
    {
      if (exec_name_should_ignore (name) == 0 && finfo.st_mode & S_IXOTH)
	r |= FS_EXECABLE;
      if (finfo.st_mode & S_IROTH)
	r |= FS_READABLE;
    }

  return r;
#endif /* !AFS */
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\findcmd.c:117
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\findcmd.c:206
parsing error 
{
  int s;

  s = file_status (file);
#if defined (EISDIR)
  if (s & FS_DIRECTORY)
    errno = EISDIR;	/* let's see if we can improve error messages */
#endif
  return ((s & FS_EXECABLE) && ((s & FS_DIRECTORY) == 0));
}
warning: parse error {
  int s;

  s = file_status (file);
#if defined (EISDIR)
  if (s & FS_DIRECTORY)
    errno = EISDIR;	/* let's see if we can improve error messages */
#endif
  return ((s & FS_EXECABLE) && ((s & FS_DIRECTORY) == 0));
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\findcmd.c:207
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\findcmd.c:220
parsing error 
{
  return (file_status (file) & FS_DIRECTORY);
}
warning: parse error {
  return (file_status (file) & FS_DIRECTORY);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\findcmd.c:221
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\findcmd.c:227
parsing error 
{
  int s;

  s = file_status (file);
  return ((s & FS_EXECABLE) || (s & FS_DIRECTORY));
}
warning: parse error {
  int s;

  s = file_status (file);
  return ((s & FS_EXECABLE) || (s & FS_DIRECTORY));
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\findcmd.c:228
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\findcmd.c:242
parsing error 
{
  return (find_user_command_internal (name, FS_EXEC_PREFERRED|FS_NODIRS));
}
warning: parse error {
  return (find_user_command_internal (name, FS_EXEC_PREFERRED|FS_NODIRS));
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\findcmd.c:243
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\findcmd.c:254
parsing error 
{
  return (find_user_command_internal (name, FS_READABLE));
}
warning: parse error {
  return (find_user_command_internal (name, FS_READABLE));
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\findcmd.c:255
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\findcmd.c:261
parsing error 
{
  char *path_list, *cmd;
  SHELL_VAR *var;

  /* Search for the value of PATH in both the temporary environments and
     in the regular list of variables. */
  if (var = find_variable_tempenv ("PATH"))	/* XXX could be array? */
    path_list = value_cell (var);
  else
    path_list = (char *)NULL;

  if (path_list == 0 || *path_list == '\0')
    return (savestring (name));

  cmd = find_user_command_in_path (name, path_list, flags);

  return (cmd);
}
warning: parse error {
  char *path_list, *cmd;
  SHELL_VAR *var;

  /* Search for the value of PATH in both the temporary environments and
     in the regular list of variables. */
  if (var = find_variable_tempenv ("PATH"))	/* XXX could be array? */
    path_list = value_cell (var);
  else
    path_list = (char *)NULL;

  if (path_list == 0 || *path_list == '\0')
    return (savestring (name));

  cmd = find_user_command_in_path (name, path_list, flags);

  return (cmd);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\findcmd.c:263
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\findcmd.c:284
parsing error 
{
#ifdef __WIN32__
  char *res, *dotexe;

  dotexe = (char *)xmalloc (strlen (name) + 5);
  strcpy (dotexe, name);
  strcat (dotexe, ".exe");
  res = _find_user_command_internal (dotexe, flags);
  free (dotexe);
  if (res == 0)
    res = _find_user_command_internal (name, flags);
  return res;
#else
  return (_find_user_command_internal (name, flags));
#endif
}
warning: parse error {
#ifdef __WIN32__
  char *res, *dotexe;

  dotexe = (char *)xmalloc (strlen (name) + 5);
  strcpy (dotexe, name);
  strcat (dotexe, ".exe");
  res = _find_user_command_internal (dotexe, flags);
  free (dotexe);
  if (res == 0)
    res = _find_user_command_internal (name, flags);
  return res;
#else
  return (_find_user_command_internal (name, flags));
#endif
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\findcmd.c:286
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\findcmd.c:308
parsing error 
{
  char *path;

  path = extract_colon_unit (path_list, path_index_pointer);

  if (path == 0)
    return (path);

  if (*path == '\0')
    {
      free (path);
      path = savestring (".");
    }

  return (path);
}
warning: parse error {
  char *path;

  path = extract_colon_unit (path_list, path_index_pointer);

  if (path == 0)
    return (path);

  if (*path == '\0')
    {
      free (path);
      path = savestring (".");
    }

  return (path);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\findcmd.c:311
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\findcmd.c:337
parsing error 
{
  char *hashed_file, *command, *path_list;
  int temp_path, st;
  SHELL_VAR *path;

  hashed_file = command = (char *)NULL;

  /* If PATH is in the temporary environment for this command, don't use the
     hash table to search for the full pathname. */
  path = find_variable_tempenv ("PATH");
  temp_path = path && tempvar_p (path);

  /* Don't waste time trying to find hashed data for a pathname
     that is already completely specified or if we're using a command-
     specific value for PATH. */
  if (temp_path == 0 && absolute_program (pathname) == 0)
    hashed_file = phash_search (pathname);

  /* If a command found in the hash table no longer exists, we need to
     look for it in $PATH.  Thank you Posix.2.  This forces us to stat
     every command found in the hash table. */

  if (hashed_file && (posixly_correct || check_hashed_filenames))
    {
      st = file_status (hashed_file);
      if ((st & (FS_EXISTS|FS_EXECABLE)) != (FS_EXISTS|FS_EXECABLE))
	{
	  phash_remove (pathname);
	  free (hashed_file);
	  hashed_file = (char *)NULL;
	}
    }

  if (hashed_file)
    command = hashed_file;
  else if (absolute_program (pathname))
    /* A command containing a slash is not looked up in PATH or saved in
       the hash table. */
    command = savestring (pathname);
  else
    {
      if (flags & CMDSRCH_STDPATH)
	path_list = conf_standard_path ();
      else if (temp_path || path)
	path_list = value_cell (path);
      else
	path_list = 0;

      command = find_user_command_in_path (pathname, path_list, FS_EXEC_PREFERRED|FS_NODIRS);

      if (command && hashing_enabled && temp_path == 0 && (flags & CMDSRCH_HASH))
	{
	  /* If we found the full pathname the same as the command name, the
	     command probably doesn't exist.  Don't put it into the hash
	     table. */
	  if (STREQ (command, pathname))
	    {
	      st = file_status (command);
	      if (st & FS_EXECABLE)
	        phash_insert ((char *)pathname, command, dot_found_in_search, 1);
	    }
	  /* If we're in posix mode, don't add files without the execute bit
	     to the hash table. */
	  else if (posixly_correct)
	    {
	      st = file_status (command);
	      if (st & FS_EXECABLE)
	        phash_insert ((char *)pathname, command, dot_found_in_search, 1);
	    }
	  else
	    phash_insert ((char *)pathname, command, dot_found_in_search, 1);
	}

      if (flags & CMDSRCH_STDPATH)
	free (path_list);
    }

  return (command);
}
warning: parse error {
  char *hashed_file, *command, *path_list;
  int temp_path, st;
  SHELL_VAR *path;

  hashed_file = command = (char *)NULL;

  /* If PATH is in the temporary environment for this command, don't use the
     hash table to search for the full pathname. */
  path = find_variable_tempenv ("PATH");
  temp_path = path && tempvar_p (path);

  /* Don't waste time trying to find hashed data for a pathname
     that is already completely specified or if we're using a command-
     specific value for PATH. */
  if (temp_path == 0 && absolute_program (pathname) == 0)
    hashed_file = phash_search (pathname);

  /* If a command found in the hash table no longer exists, we need to
     look for it in $PATH.  Thank you Posix.2.  This forces us to stat
     every command found in the hash table. */

  if (hashed_file && (posixly_correct || check_hashed_filenames))
    {
      st = file_status (hashed_file);
      if ((st & (FS_EXISTS|FS_EXECABLE)) != (FS_EXISTS|FS_EXECABLE))
	{
	  phash_remove (pathname);
	  free (hashed_file);
	  hashed_file = (char *)NULL;
	}
    }

  if (hashed_file)
    command = hashed_file;
  else if (absolute_program (pathname))
    /* A command containing a slash is not looked up in PATH or saved in
       the hash table. */
    command = savestring (pathname);
  else
    {
      if (flags & CMDSRCH_STDPATH)
	path_list = conf_standard_path ();
      else if (temp_path || path)
	path_list = value_cell (path);
      else
	path_list = 0;

      command = find_user_command_in_path (pathname, path_list, FS_EXEC_PREFERRED|FS_NODIRS);

      if (command && hashing_enabled && temp_path == 0 && (flags & CMDSRCH_HASH))
	{
	  /* If we found the full pathname the same as the command name, the
	     command probably doesn't exist.  Don't put it into the hash
	     table. */
	  if (STREQ (command, pathname))
	    {
	      st = file_status (command);
	      if (st & FS_EXECABLE)
	        phash_insert ((char *)pathname, command, dot_found_in_search, 1);
	    }
	  /* If we're in posix mode, don't add files without the execute bit
	     to the hash table. */
	  else if (posixly_correct)
	    {
	      st = file_status (command);
	      if (st & FS_EXECABLE)
	        phash_insert ((char *)pathname, command, dot_found_in_search, 1);
	    }
	  else
	    phash_insert ((char *)pathname, command, dot_found_in_search, 1);
	}

      if (flags & CMDSRCH_STDPATH)
	free (path_list);
    }

  return (command);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\findcmd.c:339
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\findcmd.c:421
parsing error 
{
  register int i;
  int  path_index, name_len;
  char *path_list, *path_element, *match;
  struct stat dotinfo;
  static char **match_list = NULL;
  static int match_list_size = 0;
  static int match_index = 0;

  if (state == 0)
    {
      /* Create the list of matches. */
      if (match_list == 0)
	{
	  match_list_size = 5;
	  match_list = strvec_create (match_list_size);
	}

      /* Clear out the old match list. */
      for (i = 0; i < match_list_size; i++)
	match_list[i] = 0;

      /* We haven't found any files yet. */
      match_index = 0;

      if (absolute_program (name))
	{
	  match_list[0] = find_absolute_program (name, flags);
	  match_list[1] = (char *)NULL;
	  path_list = (char *)NULL;
	}
      else
	{
	  name_len = strlen (name);
	  file_to_lose_on = (char *)NULL;
	  dot_found_in_search = 0;
	  if (stat (".", &dotinfo) < 0)
	    dotinfo.st_dev = dotinfo.st_ino = 0;	/* so same_file won't match */
	  path_list = get_string_value ("PATH");
      	  path_index = 0;
	}

      while (path_list && path_list[path_index])
	{
	  path_element = get_next_path_element (path_list, &path_index);

	  if (path_element == 0)
	    break;

	  match = find_in_path_element (name, path_element, flags, name_len, &dotinfo);

	  free (path_element);

	  if (match == 0)
	    continue;

	  if (match_index + 1 == match_list_size)
	    {
	      match_list_size += 10;
	      match_list = strvec_resize (match_list, (match_list_size + 1));
	    }

	  match_list[match_index++] = match;
	  match_list[match_index] = (char *)NULL;
	  FREE (file_to_lose_on);
	  file_to_lose_on = (char *)NULL;
	}

      /* We haven't returned any strings yet. */
      match_index = 0;
    }

  match = match_list[match_index];

  if (match)
    match_index++;

  return (match);
}
warning: parse error {
  register int i;
  int  path_index, name_len;
  char *path_list, *path_element, *match;
  struct stat dotinfo;
  static char **match_list = NULL;
  static int match_list_size = 0;
  static int match_index = 0;

  if (state == 0)
    {
      /* Create the list of matches. */
      if (match_list == 0)
	{
	  match_list_size = 5;
	  match_list = strvec_create (match_list_size);
	}

      /* Clear out the old match list. */
      for (i = 0; i < match_list_size; i++)
	match_list[i] = 0;

      /* We haven't found any files yet. */
      match_index = 0;

      if (absolute_program (name))
	{
	  match_list[0] = find_absolute_program (name, flags);
	  match_list[1] = (char *)NULL;
	  path_list = (char *)NULL;
	}
      else
	{
	  name_len = strlen (name);
	  file_to_lose_on = (char *)NULL;
	  dot_found_in_search = 0;
	  if (stat (".", &dotinfo) < 0)
	    dotinfo.st_dev = dotinfo.st_ino = 0;	/* so same_file won't match */
	  path_list = get_string_value ("PATH");
      	  path_index = 0;
	}

      while (path_list && path_list[path_index])
	{
	  path_element = get_next_path_element (path_list, &path_index);

	  if (path_element == 0)
	    break;

	  match = find_in_path_element (name, path_element, flags, name_len, &dotinfo);

	  free (path_element);

	  if (match == 0)
	    continue;

	  if (match_index + 1 == match_list_size)
	    {
	      match_list_size += 10;
	      match_list = strvec_resize (match_list, (match_list_size + 1));
	    }

	  match_list[match_index++] = match;
	  match_list[match_index] = (char *)NULL;
	  FREE (file_to_lose_on);
	  file_to_lose_on = (char *)NULL;
	}

      /* We haven't returned any strings yet. */
      match_index = 0;
    }

  match = match_list[match_index];

  if (match)
    match_index++;

  return (match);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\findcmd.c:423
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\findcmd.c:505
parsing error 
{
  int st;

  st = file_status (name);

  /* If the file doesn't exist, quit now. */
  if ((st & FS_EXISTS) == 0)
    return ((char *)NULL);

  /* If we only care about whether the file exists or not, return
     this filename.  Otherwise, maybe we care about whether this
     file is executable.  If it is, and that is what we want, return it. */
  if ((flags & FS_EXISTS) || ((flags & FS_EXEC_ONLY) && (st & FS_EXECABLE)))
    return (savestring (name));

  return (NULL);
}
warning: parse error {
  int st;

  st = file_status (name);

  /* If the file doesn't exist, quit now. */
  if ((st & FS_EXISTS) == 0)
    return ((char *)NULL);

  /* If we only care about whether the file exists or not, return
     this filename.  Otherwise, maybe we care about whether this
     file is executable.  If it is, and that is what we want, return it. */
  if ((flags & FS_EXISTS) || ((flags & FS_EXEC_ONLY) && (st & FS_EXECABLE)))
    return (savestring (name));

  return (NULL);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\findcmd.c:507
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\findcmd.c:527
parsing error 
{
  int status;
  char *full_path, *xpath;

  xpath = (posixly_correct == 0 && *path == '~') ? bash_tilde_expand (path, 0) : path;

  /* Remember the location of "." in the path, in all its forms
     (as long as they begin with a `.', e.g. `./.') */
  if (dot_found_in_search == 0 && *xpath == '.')
    dot_found_in_search = same_file (".", xpath, dotinfop, (struct stat *)NULL);

  full_path = sh_makepath (xpath, name, 0);

  status = file_status (full_path);

  if (xpath != path)
    free (xpath);

  if ((status & FS_EXISTS) == 0)
    {
      free (full_path);
      return ((char *)NULL);
    }

  /* The file exists.  If the caller simply wants the first file, here it is. */
  if (flags & FS_EXISTS)
    return (full_path);

  /* If we have a readable file, and the caller wants a readable file, this
     is it. */
  if ((flags & FS_READABLE) && (status & FS_READABLE))
    return (full_path);

  /* If the file is executable, then it satisfies the cases of
      EXEC_ONLY and EXEC_PREFERRED.  Return this file unconditionally. */
  if ((status & FS_EXECABLE) && (flags & (FS_EXEC_ONLY|FS_EXEC_PREFERRED)) &&
      (((flags & FS_NODIRS) == 0) || ((status & FS_DIRECTORY) == 0)))
    {
      FREE (file_to_lose_on);
      file_to_lose_on = (char *)NULL;
      return (full_path);
    }

  /* The file is not executable, but it does exist.  If we prefer
     an executable, then remember this one if it is the first one
     we have found. */
  if ((flags & FS_EXEC_PREFERRED) && file_to_lose_on == 0 && exec_name_should_ignore (full_path) == 0)
    file_to_lose_on = savestring (full_path);

  /* If we want only executable files, or we don't want directories and
     this file is a directory, or we want a readable file and this file
     isn't readable, fail. */
  if ((flags & (FS_EXEC_ONLY|FS_EXEC_PREFERRED)) ||
      ((flags & FS_NODIRS) && (status & FS_DIRECTORY)) ||
      ((flags & FS_READABLE) && (status & FS_READABLE) == 0))
    {
      free (full_path);
      return ((char *)NULL);
    }
  else
    return (full_path);
}
warning: parse error {
  int status;
  char *full_path, *xpath;

  xpath = (posixly_correct == 0 && *path == '~') ? bash_tilde_expand (path, 0) : path;

  /* Remember the location of "." in the path, in all its forms
     (as long as they begin with a `.', e.g. `./.') */
  if (dot_found_in_search == 0 && *xpath == '.')
    dot_found_in_search = same_file (".", xpath, dotinfop, (struct stat *)NULL);

  full_path = sh_makepath (xpath, name, 0);

  status = file_status (full_path);

  if (xpath != path)
    free (xpath);

  if ((status & FS_EXISTS) == 0)
    {
      free (full_path);
      return ((char *)NULL);
    }

  /* The file exists.  If the caller simply wants the first file, here it is. */
  if (flags & FS_EXISTS)
    return (full_path);

  /* If we have a readable file, and the caller wants a readable file, this
     is it. */
  if ((flags & FS_READABLE) && (status & FS_READABLE))
    return (full_path);

  /* If the file is executable, then it satisfies the cases of
      EXEC_ONLY and EXEC_PREFERRED.  Return this file unconditionally. */
  if ((status & FS_EXECABLE) && (flags & (FS_EXEC_ONLY|FS_EXEC_PREFERRED)) &&
      (((flags & FS_NODIRS) == 0) || ((status & FS_DIRECTORY) == 0)))
    {
      FREE (file_to_lose_on);
      file_to_lose_on = (char *)NULL;
      return (full_path);
    }

  /* The file is not executable, but it does exist.  If we prefer
     an executable, then remember this one if it is the first one
     we have found. */
  if ((flags & FS_EXEC_PREFERRED) && file_to_lose_on == 0 && exec_name_should_ignore (full_path) == 0)
    file_to_lose_on = savestring (full_path);

  /* If we want only executable files, or we don't want directories and
     this file is a directory, or we want a readable file and this file
     isn't readable, fail. */
  if ((flags & (FS_EXEC_ONLY|FS_EXEC_PREFERRED)) ||
      ((flags & FS_NODIRS) && (status & FS_DIRECTORY)) ||
      ((flags & FS_READABLE) && (status & FS_READABLE) == 0))
    {
      free (full_path);
      return ((char *)NULL);
    }
  else
    return (full_path);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\findcmd.c:531
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\findcmd.c:608
parsing error 
{
  char *full_path, *path;
  int path_index, name_len;
  struct stat dotinfo;

  /* We haven't started looking, so we certainly haven't seen
     a `.' as the directory path yet. */
  dot_found_in_search = 0;

  if (absolute_program (name))
    {
      full_path = find_absolute_program (name, flags);
      return (full_path);
    }

  if (path_list == 0 || *path_list == '\0')
    return (savestring (name));		/* XXX */

  file_to_lose_on = (char *)NULL;
  name_len = strlen (name);
  if (stat (".", &dotinfo) < 0)
    dotinfo.st_dev = dotinfo.st_ino = 0;
  path_index = 0;

  while (path_list[path_index])
    {
      /* Allow the user to interrupt out of a lengthy path search. */
      QUIT;

      path = get_next_path_element (path_list, &path_index);
      if (path == 0)
	break;

      /* Side effects: sets dot_found_in_search, possibly sets
	 file_to_lose_on. */
      full_path = find_in_path_element (name, path, flags, name_len, &dotinfo);
      free (path);

      /* This should really be in find_in_path_element, but there isn't the
	 right combination of flags. */
      if (full_path && is_directory (full_path))
	{
	  free (full_path);
	  continue;
	}

      if (full_path)
	{
	  FREE (file_to_lose_on);
	  return (full_path);
	}
    }

  /* We didn't find exactly what the user was looking for.  Return
     the contents of FILE_TO_LOSE_ON which is NULL when the search
     required an executable, or non-NULL if a file was found and the
     search would accept a non-executable as a last resort.  If the
     caller specified FS_NODIRS, and file_to_lose_on is a directory,
     return NULL. */
  if (file_to_lose_on && (flags & FS_NODIRS) && is_directory (file_to_lose_on))
    {
      free (file_to_lose_on);
      file_to_lose_on = (char *)NULL;
    }

  return (file_to_lose_on);
}
warning: parse error {
  char *full_path, *path;
  int path_index, name_len;
  struct stat dotinfo;

  /* We haven't started looking, so we certainly haven't seen
     a `.' as the directory path yet. */
  dot_found_in_search = 0;

  if (absolute_program (name))
    {
      full_path = find_absolute_program (name, flags);
      return (full_path);
    }

  if (path_list == 0 || *path_list == '\0')
    return (savestring (name));		/* XXX */

  file_to_lose_on = (char *)NULL;
  name_len = strlen (name);
  if (stat (".", &dotinfo) < 0)
    dotinfo.st_dev = dotinfo.st_ino = 0;
  path_index = 0;

  while (path_list[path_index])
    {
      /* Allow the user to interrupt out of a lengthy path search. */
      QUIT;

      path = get_next_path_element (path_list, &path_index);
      if (path == 0)
	break;

      /* Side effects: sets dot_found_in_search, possibly sets
	 file_to_lose_on. */
      full_path = find_in_path_element (name, path, flags, name_len, &dotinfo);
      free (path);

      /* This should really be in find_in_path_element, but there isn't the
	 right combination of flags. */
      if (full_path && is_directory (full_path))
	{
	  free (full_path);
	  continue;
	}

      if (full_path)
	{
	  FREE (file_to_lose_on);
	  return (full_path);
	}
    }

  /* We didn't find exactly what the user was looking for.  Return
     the contents of FILE_TO_LOSE_ON which is NULL when the search
     required an executable, or non-NULL if a file was found and the
     search would accept a non-executable as a last resort.  If the
     caller specified FS_NODIRS, and file_to_lose_on is a directory,
     return NULL. */
  if (file_to_lose_on && (flags & FS_NODIRS) && is_directory (file_to_lose_on))
    {
      free (file_to_lose_on);
      file_to_lose_on = (char *)NULL;
    }

  return (file_to_lose_on);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\findcmd.c:611
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\findcmd.c:683
parsing error 
{
  return (find_user_command_in_path (name, path_list, flags));
}
warning: parse error {
  return (find_user_command_in_path (name, path_list, flags));
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\findcmd.c:686
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\flags.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\shell.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\execute_cmd.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\flags.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\flags.c:211
parsing error 
{
  int i;
  for (i = 0; shell_flags[i].name; i++)
    {
      if (shell_flags[i].name == name)
	return (shell_flags[i].value);
    }
  return (FLAG_UNKNOWN);
}
warning: parse error {
  int i;
  for (i = 0; shell_flags[i].name; i++)
    {
      if (shell_flags[i].name == name)
	return (shell_flags[i].value);
    }
  return (FLAG_UNKNOWN);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\flags.c:213
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\flags.c:227
parsing error 
{
  int *value, old_value;

#if defined (RESTRICTED_SHELL)
  /* Don't allow "set +r" in a shell which is `restricted'. */
  if (restricted && flag == 'r' && on_or_off == FLAG_OFF)
    return (FLAG_ERROR);
#endif /* RESTRICTED_SHELL */

  value = find_flag (flag);

  if ((value == (int *)FLAG_UNKNOWN) || (on_or_off != FLAG_ON && on_or_off != FLAG_OFF))
    return (FLAG_ERROR);

  old_value = *value;
  *value = (on_or_off == FLAG_ON) ? 1 : 0;

  /* Special cases for a few flags. */
  switch (flag)
    {
#if defined (BANG_HISTORY)
    case 'H':
      history_expansion = histexp_flag;
      if (on_or_off == FLAG_ON)
	bash_initialize_history ();
      break;
#endif

#if defined (JOB_CONTROL)
    case 'm':
      set_job_control (on_or_off == FLAG_ON);
      break;
#endif /* JOB_CONTROL */

    case 'e':
      if (builtin_ignoring_errexit == 0)
	exit_immediately_on_error = errexit_flag;
      break;

    case 'n':
      if (interactive_shell)
	read_but_dont_execute = 0;
      break;

    case 'p':
      if (on_or_off == FLAG_OFF)
	disable_priv_mode ();
      break;

#if defined (RESTRICTED_SHELL)
    case 'r':
      if (on_or_off == FLAG_ON && shell_initialized)
	maybe_make_restricted (shell_name);
      break;
#endif

    case 'v':
      echo_input_at_read = verbose_flag;
      break;
    }

  return (old_value);
}
warning: parse error {
  int *value, old_value;

#if defined (RESTRICTED_SHELL)
  /* Don't allow "set +r" in a shell which is `restricted'. */
  if (restricted && flag == 'r' && on_or_off == FLAG_OFF)
    return (FLAG_ERROR);
#endif /* RESTRICTED_SHELL */

  value = find_flag (flag);

  if ((value == (int *)FLAG_UNKNOWN) || (on_or_off != FLAG_ON && on_or_off != FLAG_OFF))
    return (FLAG_ERROR);

  old_value = *value;
  *value = (on_or_off == FLAG_ON) ? 1 : 0;

  /* Special cases for a few flags. */
  switch (flag)
    {
#if defined (BANG_HISTORY)
    case 'H':
      history_expansion = histexp_flag;
      if (on_or_off == FLAG_ON)
	bash_initialize_history ();
      break;
#endif

#if defined (JOB_CONTROL)
    case 'm':
      set_job_control (on_or_off == FLAG_ON);
      break;
#endif /* JOB_CONTROL */

    case 'e':
      if (builtin_ignoring_errexit == 0)
	exit_immediately_on_error = errexit_flag;
      break;

    case 'n':
      if (interactive_shell)
	read_but_dont_execute = 0;
      break;

    case 'p':
      if (on_or_off == FLAG_OFF)
	disable_priv_mode ();
      break;

#if defined (RESTRICTED_SHELL)
    case 'r':
      if (on_or_off == FLAG_ON && shell_initialized)
	maybe_make_restricted (shell_name);
      break;
#endif

    case 'v':
      echo_input_at_read = verbose_flag;
      break;
    }

  return (old_value);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\flags.c:230
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\flags.c:331
parsing error 
{
  int i;

  if (bitmap == 0)
    return;
  for (i = 0; shell_flags[i].name; i++)
    *(shell_flags[i].value) = bitmap[i];
}
warning: parse error {
  int i;

  if (bitmap == 0)
    return;
  for (i = 0; shell_flags[i].name; i++)
    *(shell_flags[i].value) = bitmap[i];
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\flags.c:332
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\general.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashtypes.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\posixstat.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\filecntl.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashansi.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\chartypes.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashintl.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\shell.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\parser.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\flags.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\findcmd.h...skip
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\test.h...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\stdc.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\trap.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\pathexp.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\common.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\tilde\tilde.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\general.c:103
parsing error 
{
  /* Things that should be turned on when posix mode is enabled. */
  if (on != 0)
    {
      interactive_comments = source_uses_path = expand_aliases = 1;
      inherit_errexit = 1;
      source_searches_cwd = 0;
      print_shift_error = 1;
    }

  /* Things that should be turned on when posix mode is disabled. */
  else if (saved_posix_vars)		/* on == 0, restore saved settings */
    {
      set_posix_options (saved_posix_vars);
      free (saved_posix_vars);
      saved_posix_vars = 0;
    }
  else	/* on == 0, restore a default set of settings */
    {
      source_searches_cwd = 1;
      expand_aliases = interactive_shell;
      print_shift_error = 0;
    }
}
warning: parse error {
  /* Things that should be turned on when posix mode is enabled. */
  if (on != 0)
    {
      interactive_comments = source_uses_path = expand_aliases = 1;
      inherit_errexit = 1;
      source_searches_cwd = 0;
      print_shift_error = 1;
    }

  /* Things that should be turned on when posix mode is disabled. */
  else if (saved_posix_vars)		/* on == 0, restore saved settings */
    {
      set_posix_options (saved_posix_vars);
      free (saved_posix_vars);
      saved_posix_vars = 0;
    }
  else	/* on == 0, restore a default set of settings */
    {
      source_searches_cwd = 1;
      expand_aliases = interactive_shell;
      print_shift_error = 0;
    }
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\general.c:105
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\general.c:137
parsing error 
{
  register int i;

  if (bitmap == 0)
    bitmap = (char *)xmalloc (num_posix_options ());	/* no trailing NULL */
  for (i = 0; posix_vars[i].posix_mode_var; i++)
    bitmap[i] = *(posix_vars[i].posix_mode_var);
  return bitmap;
}
warning: parse error {
  register int i;

  if (bitmap == 0)
    bitmap = (char *)xmalloc (num_posix_options ());	/* no trailing NULL */
  for (i = 0; posix_vars[i].posix_mode_var; i++)
    bitmap[i] = *(posix_vars[i].posix_mode_var);
  return bitmap;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\general.c:139
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\general.c:158
parsing error 
{
  register int i;

  for (i = 0; posix_vars[i].posix_mode_var; i++)
    *(posix_vars[i].posix_mode_var) = bitmap[i];
}
warning: parse error {
  register int i;

  for (i = 0; posix_vars[i].posix_mode_var; i++)
    *(posix_vars[i].posix_mode_var) = bitmap[i];
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\general.c:159
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\general.c:232
parsing error 
{
  register const char *s;

  for (s = string; *s; s++)
    if (DIGIT (*s) == 0)
      return (0);

  return (1);
}
warning: parse error {
  register const char *s;

  for (s = string; *s; s++)
    if (DIGIT (*s) == 0)
      return (0);

  return (1);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\general.c:233
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\general.c:248
parsing error 
{
  intmax_t value;
  char *ep;

  if (result)
    *result = 0;

  if (string == 0)
    return 0;

  errno = 0;
  value = strtoimax (string, &ep, 10);
  if (errno || ep == string)
    return 0;	/* errno is set on overflow or underflow */

  /* Skip any trailing whitespace, since strtoimax does not. */
  while (whitespace (*ep))
    ep++;

  /* If *string is not '\0' but *ep is '\0' on return, the entire string
     is valid. */
  if (*string && *ep == '\0')
    {
      if (result)
	*result = value;
      /* The SunOS4 implementation of strtol() will happily ignore
	 overflow conditions, so this cannot do overflow correctly
	 on those systems. */
      return 1;
    }
    
  return (0);
}
warning: parse error {
  intmax_t value;
  char *ep;

  if (result)
    *result = 0;

  if (string == 0)
    return 0;

  errno = 0;
  value = strtoimax (string, &ep, 10);
  if (errno || ep == string)
    return 0;	/* errno is set on overflow or underflow */

  /* Skip any trailing whitespace, since strtoimax does not. */
  while (whitespace (*ep))
    ep++;

  /* If *string is not '\0' but *ep is '\0' on return, the entire string
     is valid. */
  if (*string && *ep == '\0')
    {
      if (result)
	*result = value;
      /* The SunOS4 implementation of strtol() will happily ignore
	 overflow conditions, so this cannot do overflow correctly
	 on those systems. */
      return 1;
    }
    
  return (0);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\general.c:250
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\general.c:289
parsing error 
{
  register const char *s;
  unsigned char c;

  if (!name || !(c = *name) || (legal_variable_starter (c) == 0))
    return (0);

  for (s = name + 1; (c = *s) != 0; s++)
    {
      if (legal_variable_char (c) == 0)
	return (0);
    }
  return (1);
}
warning: parse error {
  register const char *s;
  unsigned char c;

  if (!name || !(c = *name) || (legal_variable_starter (c) == 0))
    return (0);

  for (s = name + 1; (c = *s) != 0; s++)
    {
      if (legal_variable_char (c) == 0)
	return (0);
    }
  return (1);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\general.c:290
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\general.c:312
parsing error 
{
  if (name == 0 || *name == 0)
    return 0;

  /* valid identifier */
#if defined (ARRAY_VARS)  
  if (legal_identifier (name) || (flags != 2 && valid_array_reference (name, 0)))
#else
  if (legal_identifier (name))
#endif
    return 1;

  return 0;
}
warning: parse error {
  if (name == 0 || *name == 0)
    return 0;

  /* valid identifier */
#if defined (ARRAY_VARS)  
  if (legal_identifier (name) || (flags != 2 && valid_array_reference (name, 0)))
#else
  if (legal_identifier (name))
#endif
    return 1;

  return 0;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\general.c:314
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\general.c:331
parsing error 
{
  char *t;

  if (STREQ (name, value))
    return 1;

#if defined (ARRAY_VARS)
  if (valid_array_reference (value, 0))
    {
      t = array_variable_name (value, 0, (char **)NULL, (int *)NULL);
      if (t && STREQ (name, t))
	{
	  free (t);
	  return 1;
	}
      free (t);
    }
#endif

  return 0;	/* not a self reference */
}
warning: parse error {
  char *t;

  if (STREQ (name, value))
    return 1;

#if defined (ARRAY_VARS)
  if (valid_array_reference (value, 0))
    {
      t = array_variable_name (value, 0, (char **)NULL, (int *)NULL);
      if (t && STREQ (name, t))
	{
	  free (t);
	  return 1;
	}
      free (t);
    }
#endif

  return 0;	/* not a self reference */
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\general.c:334
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\general.c:362
parsing error 
{
  if (word->flags & (W_HASDOLLAR|W_QUOTED))	/* XXX - HASDOLLAR? */
    {
      internal_error (_("`%s': not a valid identifier"), word->word);
      return (0);
    }
  else if (check_word && (all_digits (word->word) || legal_identifier (word->word) == 0))
    {
      internal_error (_("`%s': not a valid identifier"), word->word);
      return (0);
    }
  else
    return (1);
}
warning: parse error {
  if (word->flags & (W_HASDOLLAR|W_QUOTED))	/* XXX - HASDOLLAR? */
    {
      internal_error (_("`%s': not a valid identifier"), word->word);
      return (0);
    }
  else if (check_word && (all_digits (word->word) || legal_identifier (word->word) == 0))
    {
      internal_error (_("`%s': not a valid identifier"), word->word);
      return (0);
    }
  else
    return (1);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\general.c:365
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\general.c:387
parsing error 
{
  if (absolute_program (string))	/* don't allow slash */
    return 0;
  if (*string == '\n')			/* can't start with a newline */
    return 0;
  if (shellblank (*string) || shellblank(string[len-1]))
    return 0;
  return (posixly_correct ? legal_identifier (string) : 1);
}
warning: parse error {
  if (absolute_program (string))	/* don't allow slash */
    return 0;
  if (*string == '\n')			/* can't start with a newline */
    return 0;
  if (shellblank (*string) || shellblank(string[len-1]))
    return 0;
  return (posixly_correct ? legal_identifier (string) : 1);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\general.c:389
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\general.c:401
parsing error 
{
  if (absolute_program (string))
    return 0;
  if (mbschr (string, '=') != 0)
    return 0;
  return 1;
}
warning: parse error {
  if (absolute_program (string))
    return 0;
  if (mbschr (string, '=') != 0)
    return 0;
  return 1;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\general.c:402
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\general.c:415
parsing error 
{
  register const char *s;

  for (s = string; *s; s++)
    if (shellbreak (*s) || shellxquote (*s) || shellexp (*s) || (*s == '/'))
      return 0;
  return 1;
}
warning: parse error {
  register const char *s;

  for (s = string; *s; s++)
    if (shellbreak (*s) || shellxquote (*s) || shellexp (*s) || (*s == '/'))
      return 0;
  return 1;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\general.c:417
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\general.c:432
parsing error 
{
  register unsigned char c;
  register int newi, indx;

  c = string[indx = 0];

#if defined (ARRAY_VARS)
  /* If parser_state includes PST_COMPASSIGN, FLAGS will include 1, so we are
     parsing the contents of a compound assignment. If parser_state includes
     PST_REPARSE, we are in the middle of an assignment statement and breaking
     the words between the parens into words and assignment statements, but
     we don't need to check for that right now. Within a compound assignment,
     the subscript is required to make the word an assignment statement. If
     we don't have a subscript, even if the word is a valid assignment
     statement otherwise, we don't want to treat it as one. */
  if ((flags & 1) && c != '[')		/* ] */
    return (0);
  else if ((flags & 1) == 0 && legal_variable_starter (c) == 0)
#else
  if (legal_variable_starter (c) == 0)
#endif
    return (0);

  while (c = string[indx])
    {
      /* The following is safe.  Note that '=' at the start of a word
	 is not an assignment statement. */
      if (c == '=')
	return (indx);

#if defined (ARRAY_VARS)
      if (c == '[')
	{
	  newi = skipsubscript (string, indx, (flags & 2) ? 1 : 0);
	  /* XXX - why not check for blank subscripts here, if we do in
	     valid_array_reference? */
	  if (string[newi++] != ']')
	    return (0);
	  if (string[newi] == '+' && string[newi+1] == '=')
	    return (newi + 1);
	  return ((string[newi] == '=') ? newi : 0);
	}
#endif /* ARRAY_VARS */

      /* Check for `+=' */
      if (c == '+' && string[indx+1] == '=')
	return (indx + 1);

      /* Variable names in assignment statements may contain only letters,
	 digits, and `_'. */
      if (legal_variable_char (c) == 0)
	return (0);

      indx++;
    }
  return (0);
}
warning: parse error {
  register unsigned char c;
  register int newi, indx;

  c = string[indx = 0];

#if defined (ARRAY_VARS)
  /* If parser_state includes PST_COMPASSIGN, FLAGS will include 1, so we are
     parsing the contents of a compound assignment. If parser_state includes
     PST_REPARSE, we are in the middle of an assignment statement and breaking
     the words between the parens into words and assignment statements, but
     we don't need to check for that right now. Within a compound assignment,
     the subscript is required to make the word an assignment statement. If
     we don't have a subscript, even if the word is a valid assignment
     statement otherwise, we don't want to treat it as one. */
  if ((flags & 1) && c != '[')		/* ] */
    return (0);
  else if ((flags & 1) == 0 && legal_variable_starter (c) == 0)
#else
  if (legal_variable_starter (c) == 0)
#endif
    return (0);

  while (c = string[indx])
    {
      /* The following is safe.  Note that '=' at the start of a word
	 is not an assignment statement. */
      if (c == '=')
	return (indx);

#if defined (ARRAY_VARS)
      if (c == '[')
	{
	  newi = skipsubscript (string, indx, (flags & 2) ? 1 : 0);
	  /* XXX - why not check for blank subscripts here, if we do in
	     valid_array_reference? */
	  if (string[newi++] != ']')
	    return (0);
	  if (string[newi] == '+' && string[newi+1] == '=')
	    return (newi + 1);
	  return ((string[newi] == '=') ? newi : 0);
	}
#endif /* ARRAY_VARS */

      /* Check for `+=' */
      if (c == '+' && string[indx+1] == '=')
	return (indx + 1);

      /* Variable names in assignment statements may contain only letters,
	 digits, and `_'. */
      if (legal_variable_char (c) == 0)
	return (0);

      indx++;
    }
  return (0);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\general.c:434
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\general.c:494
parsing error 
{
  register int i;

  if (line == 0)
    return 0;		/* XXX */
  for (i = 0; line[i]; i++)
    if (isblank ((unsigned char)line[i]) == 0)
      break;
  return (line[i] == '\0');  
}
warning: parse error {
  register int i;

  if (line == 0)
    return 0;		/* XXX */
  for (i = 0; line[i]; i++)
    if (isblank ((unsigned char)line[i]) == 0)
      break;
  return (line[i] == '\0');  
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\general.c:495
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\general.c:524
parsing error 
{
  int flags, bflags;

  if ((flags = fcntl (fd, F_GETFL, 0)) < 0)
    return -1;

  bflags = 0;

  /* This is defined to O_NDELAY in filecntl.h if O_NONBLOCK is not present
     and O_NDELAY is defined. */
#ifdef O_NONBLOCK
  bflags |= O_NONBLOCK;
#endif

#ifdef O_NDELAY
  bflags |= O_NDELAY;
#endif

  if (flags & bflags)
    {
      flags &= ~bflags;
      return (fcntl (fd, F_SETFL, flags));
    }

  return 0;
}
warning: parse error {
  int flags, bflags;

  if ((flags = fcntl (fd, F_GETFL, 0)) < 0)
    return -1;

  bflags = 0;

  /* This is defined to O_NDELAY in filecntl.h if O_NONBLOCK is not present
     and O_NDELAY is defined. */
#ifdef O_NONBLOCK
  bflags |= O_NONBLOCK;
#endif

#ifdef O_NDELAY
  bflags |= O_NDELAY;
#endif

  if (flags & bflags)
    {
      flags &= ~bflags;
      return (fcntl (fd, F_SETFL, flags));
    }

  return 0;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\general.c:526
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\general.c:555
parsing error 
{
  return (SET_CLOSE_ON_EXEC (fd));
}
warning: parse error {
  return (SET_CLOSE_ON_EXEC (fd));
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\general.c:557
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\general.c:563
parsing error 
{
  return (fcntl (fd, F_GETFD, 0) >= 0);
}
warning: parse error {
  return (fcntl (fd, F_GETFD, 0) >= 0);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\general.c:565
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\general.c:570
parsing error 
{
  errno = 0;
  return ((lseek (fd, 0L, SEEK_CUR) < 0) && (errno == ESPIPE));
}
warning: parse error {
  errno = 0;
  return ((lseek (fd, 0L, SEEK_CUR) < 0) && (errno == ESPIPE));
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\general.c:572
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\general.c:611
parsing error 
{
  struct stat st1, st2;

  if (stp1 == NULL)
    {
      if (stat (path1, &st1) != 0)
	return (0);
      stp1 = &st1;
    }

  if (stp2 == NULL)
    {
      if (stat (path2, &st2) != 0)
	return (0);
      stp2 = &st2;
    }

  return ((stp1->st_dev == stp2->st_dev) && (stp1->st_ino == stp2->st_ino));
}
warning: parse error {
  struct stat st1, st2;

  if (stp1 == NULL)
    {
      if (stat (path1, &st1) != 0)
	return (0);
      stp1 = &st1;
    }

  if (stp2 == NULL)
    {
      if (stat (path2, &st2) != 0)
	return (0);
      stp2 = &st2;
    }

  return ((stp1->st_dev == stp2->st_dev) && (stp1->st_ino == stp2->st_ino));
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\general.c:613
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\general.c:641
parsing error 
{
  int script_fd, nfds, ignore;

  if (maxfd < 20)
    {
      nfds = getdtablesize ();
      if (nfds <= 0)
	nfds = 20;
      if (nfds > HIGH_FD_MAX)
	nfds = HIGH_FD_MAX;		/* reasonable maximum */
    }
  else
    nfds = maxfd;

  for (nfds--; check_new && nfds > 3; nfds--)
    if (fcntl (nfds, F_GETFD, &ignore) == -1)
      break;

  if (nfds > 3 && fd != nfds && (script_fd = dup2 (fd, nfds)) != -1)
    {
      if (check_new == 0 || fd != fileno (stderr))	/* don't close stderr */
	close (fd);
      return (script_fd);
    }

  /* OK, we didn't find one less than our artificial maximum; return the
     original file descriptor. */
  return (fd);
}
warning: parse error {
  int script_fd, nfds, ignore;

  if (maxfd < 20)
    {
      nfds = getdtablesize ();
      if (nfds <= 0)
	nfds = 20;
      if (nfds > HIGH_FD_MAX)
	nfds = HIGH_FD_MAX;		/* reasonable maximum */
    }
  else
    nfds = maxfd;

  for (nfds--; check_new && nfds > 3; nfds--)
    if (fcntl (nfds, F_GETFD, &ignore) == -1)
      break;

  if (nfds > 3 && fd != nfds && (script_fd = dup2 (fd, nfds)) != -1)
    {
      if (check_new == 0 || fd != fileno (stderr))	/* don't close stderr */
	close (fd);
      return (script_fd);
    }

  /* OK, we didn't find one less than our artificial maximum; return the
     original file descriptor. */
  return (fd);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\general.c:643
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\general.c:680
parsing error 
{
  register int i;
  unsigned char c;

  for (i = 0; i < sample_len; i++)
    {
      c = sample[i];
      if (c == '\n')
	return (0);
      if (c == '\0')
	return (1);
    }

  return (0);
}
warning: parse error {
  register int i;
  unsigned char c;

  for (i = 0; i < sample_len; i++)
    {
      c = sample[i];
      if (c == '\n')
	return (0);
      if (c == '\0')
	return (1);
    }

  return (0);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\general.c:682
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\general.c:705
parsing error 
{
  int r;

  if ((r = pipe (pv)) < 0)
    return r;

  pv[0] = move_to_high_fd (pv[0], 1, 64);
  pv[1] = move_to_high_fd (pv[1], 1, 64);

  return 0;  
}
warning: parse error {
  int r;

  if ((r = pipe (pv)) < 0)
    return r;

  pv[0] = move_to_high_fd (pv[0], 1, 64);
  pv[1] = move_to_high_fd (pv[1], 1, 64);

  return 0;  
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\general.c:707
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\general.c:720
parsing error 
{
  if (pv[0] >= 0)
    close (pv[0]);

  if (pv[1] >= 0)
    close (pv[1]);

  pv[0] = pv[1] = -1;
  return 0;
}
warning: parse error {
  if (pv[0] >= 0)
    close (pv[0]);

  if (pv[1] >= 0)
    close (pv[1]);

  pv[0] = pv[1] = -1;
  return 0;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\general.c:722
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\general.c:741
parsing error 
{
  struct stat sb;

  return (stat (fn, &sb) == 0);
}
warning: parse error {
  struct stat sb;

  return (stat (fn, &sb) == 0);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\general.c:742
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\general.c:750
parsing error 
{
  struct stat sb;

  return ((stat (fn, &sb) == 0) && S_ISDIR (sb.st_mode));
}
warning: parse error {
  struct stat sb;

  return ((stat (fn, &sb) == 0) && S_ISDIR (sb.st_mode));
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\general.c:751
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\general.c:759
parsing error 
{
  return (file_isdir (fn) && sh_eaccess (fn, W_OK) == 0);
}
warning: parse error {
  return (file_isdir (fn) && sh_eaccess (fn, W_OK) == 0);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\general.c:760
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\general.c:768
parsing error 
{
  if (string == 0 || *string == '\0' || *string != '.')
    return (0);

  /* string[0] == '.' */
  if (PATHSEP(string[1]) || (string[1] == '.' && PATHSEP(string[2])))
    return (1);

  return (0);
}
warning: parse error {
  if (string == 0 || *string == '\0' || *string != '.')
    return (0);

  /* string[0] == '.' */
  if (PATHSEP(string[1]) || (string[1] == '.' && PATHSEP(string[2])))
    return (1);

  return (0);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\general.c:769
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\general.c:784
parsing error 
{
  if (string == 0 || *string == '\0')
    return (0);

  if (ABSPATH(string))
    return (1);

  if (string[0] == '.' && PATHSEP(string[1]))	/* . and ./ */
    return (1);

  if (string[0] == '.' && string[1] == '.' && PATHSEP(string[2]))	/* .. and ../ */
    return (1);

  return (0);
}
warning: parse error {
  if (string == 0 || *string == '\0')
    return (0);

  if (ABSPATH(string))
    return (1);

  if (string[0] == '.' && PATHSEP(string[1]))	/* . and ./ */
    return (1);

  if (string[0] == '.' && string[1] == '.' && PATHSEP(string[2]))	/* .. and ../ */
    return (1);

  return (0);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\general.c:785
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\general.c:806
parsing error 
{
  return ((char *)mbschr (string, '/') != (char *)NULL);
}
warning: parse error {
  return ((char *)mbschr (string, '/') != (char *)NULL);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\general.c:807
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\general.c:823
parsing error 
{
  char *result;

  if (dot_path == 0 || ABSPATH(string))
#ifdef __CYGWIN__
    {
      char pathbuf[PATH_MAX + 1];

      /* WAS cygwin_conv_to_full_posix_path (string, pathbuf); */
      cygwin_conv_path (CCP_WIN_A_TO_POSIX, string, pathbuf, PATH_MAX);
      result = savestring (pathbuf);
    }
#else
    result = savestring (string);
#endif
  else
    result = sh_makepath (dot_path, string, 0);

  return (result);
}
warning: parse error {
  char *result;

  if (dot_path == 0 || ABSPATH(string))
#ifdef __CYGWIN__
    {
      char pathbuf[PATH_MAX + 1];

      /* WAS cygwin_conv_to_full_posix_path (string, pathbuf); */
      cygwin_conv_path (CCP_WIN_A_TO_POSIX, string, pathbuf, PATH_MAX);
      result = savestring (pathbuf);
    }
#else
    result = savestring (string);
#endif
  else
    result = sh_makepath (dot_path, string, 0);

  return (result);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\general.c:824
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\general.c:848
parsing error 
{
  char *p;

#if 0
  if (absolute_pathname (string) == 0)
    return (string);
#endif

  if (string[0] == '/' && string[1] == 0)
    return (string);

  p = (char *)strrchr (string, '/');
  return (p ? ++p : string);
}
warning: parse error {
  char *p;

#if 0
  if (absolute_pathname (string) == 0)
    return (string);
#endif

  if (string[0] == '/' && string[1] == 0)
    return (string);

  p = (char *)strrchr (string, '/');
  return (p ? ++p : string);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\general.c:850
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\general.c:870
parsing error 
{
  char *ret;

  file = (*file == '~') ? bash_tilde_expand (file, 0) : savestring (file);

  if (ABSPATH(file))
    return (file);

  ret = sh_makepath ((char *)NULL, file, (MP_DOCWD|MP_RMDOT));
  free (file);

  return (ret);
}
warning: parse error {
  char *ret;

  file = (*file == '~') ? bash_tilde_expand (file, 0) : savestring (file);

  if (ABSPATH(file))
    return (file);

  ret = sh_makepath ((char *)NULL, file, (MP_DOCWD|MP_RMDOT));
  free (file);

  return (ret);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\general.c:872
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\general.c:893
parsing error 
{
  char *home;
  int l;

  home = get_string_value ("HOME");
  l = home ? strlen (home) : 0;
  if (l > 1 && strncmp (home, name, l) == 0 && (!name[l] || name[l] == '/'))
    {
      strncpy (tdir + 1, name + l, sizeof(tdir) - 2);
      tdir[0] = '~';
      tdir[sizeof(tdir) - 1] = '\0';
      return (tdir);
    }
  else
    return (name);
}
warning: parse error {
  char *home;
  int l;

  home = get_string_value ("HOME");
  l = home ? strlen (home) : 0;
  if (l > 1 && strncmp (home, name, l) == 0 && (!name[l] || name[l] == '/'))
    {
      strncpy (tdir + 1, name + l, sizeof(tdir) - 2);
      tdir[0] = '~';
      tdir[sizeof(tdir) - 1] = '\0';
      return (tdir);
    }
  else
    return (name);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\general.c:895
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\general.c:916
parsing error 
{
  int nlen, ndirs;
  intmax_t nskip;
  char *nbeg, *nend, *ntail, *v;

  if (name == 0 || (nlen = strlen (name)) == 0)
    return name;
  nend = name + nlen;

  v = get_string_value ("PROMPT_DIRTRIM");
  if (v == 0 || *v == 0)
    return name;
  if (legal_number (v, &nskip) == 0 || nskip <= 0)
    return name;

  /* Skip over tilde prefix */
  nbeg = name;
  if (name[0] == '~')
    for (nbeg = name; *nbeg; nbeg++)
      if (*nbeg == '/')
	{
	  nbeg++;
	  break;
	}
  if (*nbeg == 0)
    return name;

  for (ndirs = 0, ntail = nbeg; *ntail; ntail++)
    if (*ntail == '/')
      ndirs++;
  if (ndirs < nskip)
    return name;

  for (ntail = (*nend == '/') ? nend : nend - 1; ntail > nbeg; ntail--)
    {
      if (*ntail == '/')
	nskip--;
      if (nskip == 0)
	break;
    }
  if (ntail == nbeg)
    return name;

  /* Now we want to return name[0..nbeg]+"..."+ntail, modifying name in place */
  nlen = ntail - nbeg;
  if (nlen <= 3)
    return name;

  *nbeg++ = '.';
  *nbeg++ = '.';
  *nbeg++ = '.';

  nlen = nend - ntail;
  memmove (nbeg, ntail, nlen);
  nbeg[nlen] = '\0';

  return name;
}
warning: parse error {
  int nlen, ndirs;
  intmax_t nskip;
  char *nbeg, *nend, *ntail, *v;

  if (name == 0 || (nlen = strlen (name)) == 0)
    return name;
  nend = name + nlen;

  v = get_string_value ("PROMPT_DIRTRIM");
  if (v == 0 || *v == 0)
    return name;
  if (legal_number (v, &nskip) == 0 || nskip <= 0)
    return name;

  /* Skip over tilde prefix */
  nbeg = name;
  if (name[0] == '~')
    for (nbeg = name; *nbeg; nbeg++)
      if (*nbeg == '/')
	{
	  nbeg++;
	  break;
	}
  if (*nbeg == 0)
    return name;

  for (ndirs = 0, ntail = nbeg; *ntail; ntail++)
    if (*ntail == '/')
      ndirs++;
  if (ndirs < nskip)
    return name;

  for (ntail = (*nend == '/') ? nend : nend - 1; ntail > nbeg; ntail--)
    {
      if (*ntail == '/')
	nskip--;
      if (nskip == 0)
	break;
    }
  if (ntail == nbeg)
    return name;

  /* Now we want to return name[0..nbeg]+"..."+ntail, modifying name in place */
  nlen = ntail - nbeg;
  if (nlen <= 3)
    return name;

  *nbeg++ = '.';
  *nbeg++ = '.';
  *nbeg++ = '.';

  nlen = nend - ntail;
  memmove (nbeg, ntail, nlen);
  nbeg[nlen] = '\0';

  return name;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\general.c:919
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\general.c:983
parsing error 
{
  char *newf;

  if (ansic_shouldquote (fn))
    newf = ansic_quote (fn, 0, NULL);
  else if (flags && sh_contains_shell_metas (fn))
    newf = sh_single_quote (fn);
  else
    newf = fn;

  return newf;
}
warning: parse error {
  char *newf;

  if (ansic_shouldquote (fn))
    newf = ansic_quote (fn, 0, NULL);
  else if (flags && sh_contains_shell_metas (fn))
    newf = sh_single_quote (fn);
  else
    newf = fn;

  return newf;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\general.c:986
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\general.c:1,003
parsing error 
{
  int i, start, len;
  char *value;

  if (string == 0)
    return (string);

  len = strlen (string);
  if (*p_index >= len)
    return ((char *)NULL);

  i = *p_index;

  /* Each call to this routine leaves the index pointing at a colon if
     there is more to the path.  If I is > 0, then increment past the
     `:'.  If I is 0, then the path has a leading colon.  Trailing colons
     are handled OK by the `else' part of the if statement; an empty
     string is returned in that case. */
  if (i && string[i] == ':')
    i++;

  for (start = i; string[i] && string[i] != ':'; i++)
    ;

  *p_index = i;

  if (i == start)
    {
      if (string[i])
	(*p_index)++;
      /* Return "" in the case of a trailing `:'. */
      value = (char *)xmalloc (1);
      value[0] = '\0';
    }
  else
    value = substring (string, start, i);

  return (value);
}
warning: parse error {
  int i, start, len;
  char *value;

  if (string == 0)
    return (string);

  len = strlen (string);
  if (*p_index >= len)
    return ((char *)NULL);

  i = *p_index;

  /* Each call to this routine leaves the index pointing at a colon if
     there is more to the path.  If I is > 0, then increment past the
     `:'.  If I is 0, then the path has a leading colon.  Trailing colons
     are handled OK by the `else' part of the if statement; an empty
     string is returned in that case. */
  if (i && string[i] == ':')
    i++;

  for (start = i; string[i] && string[i] != ':'; i++)
    ;

  *p_index = i;

  if (i == start)
    {
      if (string[i])
	(*p_index)++;
      /* Return "" in the case of a trailing `:'. */
      value = (char *)xmalloc (1);
      value[0] = '\0';
    }
  else
    value = substring (string, start, i);

  return (value);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\general.c:1,006
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\general.c:1,067
parsing error 
{
  char *result;

  result = (char *)NULL;

  if (text[0] == '+' && text[1] == '\0')
    result = get_string_value ("PWD");
  else if (text[0] == '-' && text[1] == '\0')
    result = get_string_value ("OLDPWD");
#if defined (PUSHD_AND_POPD)
  else if (DIGIT (*text) || ((*text == '+' || *text == '-') && DIGIT (text[1])))
    result = get_dirstack_from_string (text);
#endif

  return (result ? savestring (result) : (char *)NULL);
}
warning: parse error {
  char *result;

  result = (char *)NULL;

  if (text[0] == '+' && text[1] == '\0')
    result = get_string_value ("PWD");
  else if (text[0] == '-' && text[1] == '\0')
    result = get_string_value ("OLDPWD");
#if defined (PUSHD_AND_POPD)
  else if (DIGIT (*text) || ((*text == '+' || *text == '-') && DIGIT (text[1])))
    result = get_dirstack_from_string (text);
#endif

  return (result ? savestring (result) : (char *)NULL);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\general.c:1,069
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\general.c:1,137
parsing error 
{
  const char *r;

  for (r = s; TILDE_END(*r) == 0; r++)
    {
      switch (*r)
	{
	case '\\':
	case '\'':
	case '"':
	  return 0;
	}
    }
  return 1;
}
warning: parse error {
  const char *r;

  for (r = s; TILDE_END(*r) == 0; r++)
    {
      switch (*r)
	{
	case '\\':
	case '\'':
	case '"':
	  return 0;
	}
    }
  return 1;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\general.c:1,138
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\general.c:1,160
parsing error 
{
  const char *r;
  char *ret;
  int l;

  for (r = s; *r && *r != '/'; r++)
    {
      /* Short-circuit immediately if we see a quote character.  Even though
	 POSIX says that `the first unquoted slash' (or `:') terminates the
	 tilde-prefix, in practice, any quoted portion of the tilde prefix
	 will cause it to not be expanded. */
      if (*r == '\\' || *r == '\'' || *r == '"')  
	{
	  ret = savestring (s);
	  if (lenp)
	    *lenp = 0;
	  return ret;
	}
      else if (flags && *r == ':')
	break;
    }
  l = r - s;
  ret = xmalloc (l + 1);
  strncpy (ret, s, l);
  ret[l] = '\0';
  if (lenp)
    *lenp = l;
  return ret;
}
warning: parse error {
  const char *r;
  char *ret;
  int l;

  for (r = s; *r && *r != '/'; r++)
    {
      /* Short-circuit immediately if we see a quote character.  Even though
	 POSIX says that `the first unquoted slash' (or `:') terminates the
	 tilde-prefix, in practice, any quoted portion of the tilde prefix
	 will cause it to not be expanded. */
      if (*r == '\\' || *r == '\'' || *r == '"')  
	{
	  ret = savestring (s);
	  if (lenp)
	    *lenp = 0;
	  return ret;
	}
      else if (flags && *r == ':')
	break;
    }
  l = r - s;
  ret = xmalloc (l + 1);
  strncpy (ret, s, l);
  ret[l] = '\0';
  if (lenp)
    *lenp = l;
  return ret;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\general.c:1,162
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\general.c:1,199
parsing error 
{
  int r;
  char *ret;

  tilde_additional_prefixes = assign_p == 0 ? (char **)0
  					    : (assign_p == 2 ? bash_tilde_prefixes2 : bash_tilde_prefixes);
  if (assign_p == 2)
    tilde_additional_suffixes = bash_tilde_suffixes2;

  r = (*s == '~') ? unquoted_tilde_word (s) : 1;
  ret = r ? tilde_expand (s) : savestring (s);

  QUIT;

  return (ret);
}
warning: parse error {
  int r;
  char *ret;

  tilde_additional_prefixes = assign_p == 0 ? (char **)0
  					    : (assign_p == 2 ? bash_tilde_prefixes2 : bash_tilde_prefixes);
  if (assign_p == 2)
    tilde_additional_suffixes = bash_tilde_suffixes2;

  r = (*s == '~') ? unquoted_tilde_word (s) : 1;
  ret = r ? tilde_expand (s) : savestring (s);

  QUIT;

  return (ret);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\general.c:1,201
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\general.c:1,320
parsing error 
{
  static char **group_vector = (char **)NULL;
  register int i;

  if (group_vector)
    {
      if (ngp)
	*ngp = ngroups;
      return group_vector;
    }

  if (ngroups == 0)
    initialize_group_array ();

  if (ngroups <= 0)
    {
      if (ngp)
	*ngp = 0;
      return (char **)NULL;
    }

  group_vector = strvec_create (ngroups);
  for (i = 0; i < ngroups; i++)
    group_vector[i] = itos (group_array[i]);

  if (ngp)
    *ngp = ngroups;
  return group_vector;
}
warning: parse error {
  static char **group_vector = (char **)NULL;
  register int i;

  if (group_vector)
    {
      if (ngp)
	*ngp = ngroups;
      return group_vector;
    }

  if (ngroups == 0)
    initialize_group_array ();

  if (ngroups <= 0)
    {
      if (ngp)
	*ngp = 0;
      return (char **)NULL;
    }

  group_vector = strvec_create (ngroups);
  for (i = 0; i < ngroups; i++)
    group_vector[i] = itos (group_array[i]);

  if (ngp)
    *ngp = ngroups;
  return group_vector;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\general.c:1,322
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\general.c:1,353
parsing error 
{
  int i;
  static int *group_iarray = (int *)NULL;

  if (group_iarray)
    {
      if (ngp)
	*ngp = ngroups;
      return (group_iarray);
    }

  if (ngroups == 0)
    initialize_group_array ();    

  if (ngroups <= 0)
    {
      if (ngp)
	*ngp = 0;
      return (int *)NULL;
    }

  group_iarray = (int *)xmalloc (ngroups * sizeof (int));
  for (i = 0; i < ngroups; i++)
    group_iarray[i] = (int)group_array[i];

  if (ngp)
    *ngp = ngroups;
  return group_iarray;
}
warning: parse error {
  int i;
  static int *group_iarray = (int *)NULL;

  if (group_iarray)
    {
      if (ngp)
	*ngp = ngroups;
      return (group_iarray);
    }

  if (ngroups == 0)
    initialize_group_array ();    

  if (ngroups <= 0)
    {
      if (ngp)
	*ngp = 0;
      return (int *)NULL;
    }

  group_iarray = (int *)xmalloc (ngroups * sizeof (int));
  for (i = 0; i < ngroups; i++)
    group_iarray[i] = (int)group_array[i];

  if (ngp)
    *ngp = ngroups;
  return group_iarray;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\general.c:1,355
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\hashcmd.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashtypes.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\posixstat.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashansi.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\shell.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\flags.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\findcmd.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\hashcmd.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\hashcmd.c:50
parsing error 
{
  free (((PATH_DATA *)data)->path);
  free (data);
}
warning: parse error {
  free (((PATH_DATA *)data)->path);
  free (data);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\hashcmd.c:52
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\hashcmd.c:67
parsing error 
{
  register BUCKET_CONTENTS *item;

  if (hashing_enabled == 0 || hashed_filenames == 0)
    return 0;

  item = hash_remove (filename, hashed_filenames, 0);
  if (item)
    {
      if (item->data)
	phash_freedata (item->data);
      free (item->key);
      free (item);
      return 0;
    }
  return 1;
}
warning: parse error {
  register BUCKET_CONTENTS *item;

  if (hashing_enabled == 0 || hashed_filenames == 0)
    return 0;

  item = hash_remove (filename, hashed_filenames, 0);
  if (item)
    {
      if (item->data)
	phash_freedata (item->data);
      free (item->key);
      free (item);
      return 0;
    }
  return 1;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\hashcmd.c:68
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\hashcmd.c:92
parsing error 
{
  register BUCKET_CONTENTS *item;

  if (hashing_enabled == 0)
    return;

  if (hashed_filenames == 0)
    phash_create ();

  item = hash_insert (filename, hashed_filenames, 0);
  if (item->data)
    free (pathdata(item)->path);
  else
    {
      item->key = savestring (filename);
      item->data = xmalloc (sizeof (PATH_DATA));
    }
  pathdata(item)->path = savestring (full_path);
  pathdata(item)->flags = 0;
  if (check_dot)
    pathdata(item)->flags |= HASH_CHKDOT;
  if (*full_path != '/')
    pathdata(item)->flags |= HASH_RELPATH;
  item->times_found = found;
}
warning: parse error {
  register BUCKET_CONTENTS *item;

  if (hashing_enabled == 0)
    return;

  if (hashed_filenames == 0)
    phash_create ();

  item = hash_insert (filename, hashed_filenames, 0);
  if (item->data)
    free (pathdata(item)->path);
  else
    {
      item->key = savestring (filename);
      item->data = xmalloc (sizeof (PATH_DATA));
    }
  pathdata(item)->path = savestring (full_path);
  pathdata(item)->flags = 0;
  if (check_dot)
    pathdata(item)->flags |= HASH_CHKDOT;
  if (*full_path != '/')
    pathdata(item)->flags |= HASH_RELPATH;
  item->times_found = found;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\hashcmd.c:95
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\hashcmd.c:128
parsing error 
{
  register BUCKET_CONTENTS *item;
  char *path, *dotted_filename, *tail;
  int same;

  if (hashing_enabled == 0 || hashed_filenames == 0)
    return ((char *)NULL);

  item = hash_search (filename, hashed_filenames, 0);

  if (item == NULL)
    return ((char *)NULL);

  /* If this filename is hashed, but `.' comes before it in the path,
     see if ./filename is executable.  If the hashed value is not an
     absolute pathname, see if ./`hashed-value' exists. */
  path = pathdata(item)->path;
  if (pathdata(item)->flags & (HASH_CHKDOT|HASH_RELPATH))
    {
      tail = (pathdata(item)->flags & HASH_RELPATH) ? path : (char *)filename;	/* XXX - fix const later */
      /* If the pathname does not start with a `./', add a `./' to it. */
      if (tail[0] != '.' || tail[1] != '/')
	{
	  dotted_filename = (char *)xmalloc (3 + strlen (tail));
	  dotted_filename[0] = '.'; dotted_filename[1] = '/';
	  strcpy (dotted_filename + 2, tail);
	}
      else
	dotted_filename = savestring (tail);

      if (executable_file (dotted_filename))
	return (dotted_filename);

      free (dotted_filename);

#if 0
      if (pathdata(item)->flags & HASH_RELPATH)
	return ((char *)NULL);
#endif

      /* Watch out.  If this file was hashed to "./filename", and
	 "./filename" is not executable, then return NULL. */

      /* Since we already know "./filename" is not executable, what
	 we're really interested in is whether or not the `path'
	 portion of the hashed filename is equivalent to the current
	 directory, but only if it starts with a `.'.  (This catches
	 ./. and so on.)  same_file () tests general Unix file
	 equivalence -- same device and inode. */
      if (*path == '.')
	{
	  same = 0;
	  tail = (char *)strrchr (path, '/');

	  if (tail)
	    {
	      *tail = '\0';
	      same = same_file (".", path, (struct stat *)NULL, (struct stat *)NULL);
	      *tail = '/';
	    }

	  return same ? (char *)NULL : savestring (path);
	}
    }

  return (savestring (path));
}
warning: parse error {
  register BUCKET_CONTENTS *item;
  char *path, *dotted_filename, *tail;
  int same;

  if (hashing_enabled == 0 || hashed_filenames == 0)
    return ((char *)NULL);

  item = hash_search (filename, hashed_filenames, 0);

  if (item == NULL)
    return ((char *)NULL);

  /* If this filename is hashed, but `.' comes before it in the path,
     see if ./filename is executable.  If the hashed value is not an
     absolute pathname, see if ./`hashed-value' exists. */
  path = pathdata(item)->path;
  if (pathdata(item)->flags & (HASH_CHKDOT|HASH_RELPATH))
    {
      tail = (pathdata(item)->flags & HASH_RELPATH) ? path : (char *)filename;	/* XXX - fix const later */
      /* If the pathname does not start with a `./', add a `./' to it. */
      if (tail[0] != '.' || tail[1] != '/')
	{
	  dotted_filename = (char *)xmalloc (3 + strlen (tail));
	  dotted_filename[0] = '.'; dotted_filename[1] = '/';
	  strcpy (dotted_filename + 2, tail);
	}
      else
	dotted_filename = savestring (tail);

      if (executable_file (dotted_filename))
	return (dotted_filename);

      free (dotted_filename);

#if 0
      if (pathdata(item)->flags & HASH_RELPATH)
	return ((char *)NULL);
#endif

      /* Watch out.  If this file was hashed to "./filename", and
	 "./filename" is not executable, then return NULL. */

      /* Since we already know "./filename" is not executable, what
	 we're really interested in is whether or not the `path'
	 portion of the hashed filename is equivalent to the current
	 directory, but only if it starts with a `.'.  (This catches
	 ./. and so on.)  same_file () tests general Unix file
	 equivalence -- same device and inode. */
      if (*path == '.')
	{
	  same = 0;
	  tail = (char *)strrchr (path, '/');

	  if (tail)
	    {
	      *tail = '\0';
	      same = same_file (".", path, (struct stat *)NULL, (struct stat *)NULL);
	      *tail = '/';
	    }

	  return same ? (char *)NULL : savestring (path);
	}
    }

  return (savestring (path));
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\hashcmd.c:129
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\hashlib.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashansi.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\shell.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\hashlib.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\hashlib.c:62
parsing error 
{
  HASH_TABLE *new_table;
  register int i;

  new_table = (HASH_TABLE *)xmalloc (sizeof (HASH_TABLE));
  if (buckets == 0)
    buckets = DEFAULT_HASH_BUCKETS;

  new_table->bucket_array =
    (BUCKET_CONTENTS **)xmalloc (buckets * sizeof (BUCKET_CONTENTS *));
  new_table->nbuckets = buckets;
  new_table->nentries = 0;

  for (i = 0; i < buckets; i++)
    new_table->bucket_array[i] = (BUCKET_CONTENTS *)NULL;

  return (new_table);
}
warning: parse error {
  HASH_TABLE *new_table;
  register int i;

  new_table = (HASH_TABLE *)xmalloc (sizeof (HASH_TABLE));
  if (buckets == 0)
    buckets = DEFAULT_HASH_BUCKETS;

  new_table->bucket_array =
    (BUCKET_CONTENTS **)xmalloc (buckets * sizeof (BUCKET_CONTENTS *));
  new_table->nbuckets = buckets;
  new_table->nentries = 0;

  for (i = 0; i < buckets; i++)
    new_table->bucket_array[i] = (BUCKET_CONTENTS *)NULL;

  return (new_table);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\hashlib.c:64
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\hashlib.c:84
parsing error 
{
  return (HASH_ENTRIES(table));
}
warning: parse error {
  return (HASH_ENTRIES(table));
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\hashlib.c:86
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\hashlib.c:91
parsing error 
{
  BUCKET_CONTENTS *new_bucket, *n, *e;

  if (ba == 0)
    return ((BUCKET_CONTENTS *)0);

  for (n = (BUCKET_CONTENTS *)0, e = ba; e; e = e->next)
    {
      if (n == 0)
        {
          new_bucket = (BUCKET_CONTENTS *)xmalloc (sizeof (BUCKET_CONTENTS));
          n = new_bucket;
        }
      else
        {
          n->next = (BUCKET_CONTENTS *)xmalloc (sizeof (BUCKET_CONTENTS));
          n = n->next;
        }

      n->key = savestring (e->key);
      n->data = e->data ? (cpdata ? (*cpdata) (e->data) : savestring (e->data))
			: NULL;
      n->khash = e->khash;
      n->times_found = e->times_found;
      n->next = (BUCKET_CONTENTS *)NULL;
    }

  return new_bucket;  
}
warning: parse error {
  BUCKET_CONTENTS *new_bucket, *n, *e;

  if (ba == 0)
    return ((BUCKET_CONTENTS *)0);

  for (n = (BUCKET_CONTENTS *)0, e = ba; e; e = e->next)
    {
      if (n == 0)
        {
          new_bucket = (BUCKET_CONTENTS *)xmalloc (sizeof (BUCKET_CONTENTS));
          n = new_bucket;
        }
      else
        {
          n->next = (BUCKET_CONTENTS *)xmalloc (sizeof (BUCKET_CONTENTS));
          n = n->next;
        }

      n->key = savestring (e->key);
      n->data = e->data ? (cpdata ? (*cpdata) (e->data) : savestring (e->data))
			: NULL;
      n->khash = e->khash;
      n->times_found = e->times_found;
      n->next = (BUCKET_CONTENTS *)NULL;
    }

  return new_bucket;  
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\hashlib.c:94
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\hashlib.c:125
parsing error 
{
  int osize, i, j;
  BUCKET_CONTENTS **old_bucket_array, *item, *next;

  if (table == NULL || nsize == table->nbuckets)
    return;

  osize = table->nbuckets;
  old_bucket_array = table->bucket_array;

  table->nbuckets = nsize;
  table->bucket_array = (BUCKET_CONTENTS **)xmalloc (table->nbuckets * sizeof (BUCKET_CONTENTS *));
  for (i = 0; i < table->nbuckets; i++)
    table->bucket_array[i] = (BUCKET_CONTENTS *)NULL;

  for (j = 0; j < osize; j++)
    {
      for (item = old_bucket_array[j]; item; item = next)
	{
	  next = item->next;
	  i = item->khash & (table->nbuckets - 1);
	  item->next = table->bucket_array[i];
	  table->bucket_array[i] = item;
	}
    }

  free (old_bucket_array);
}
warning: parse error {
  int osize, i, j;
  BUCKET_CONTENTS **old_bucket_array, *item, *next;

  if (table == NULL || nsize == table->nbuckets)
    return;

  osize = table->nbuckets;
  old_bucket_array = table->bucket_array;

  table->nbuckets = nsize;
  table->bucket_array = (BUCKET_CONTENTS **)xmalloc (table->nbuckets * sizeof (BUCKET_CONTENTS *));
  for (i = 0; i < table->nbuckets; i++)
    table->bucket_array[i] = (BUCKET_CONTENTS *)NULL;

  for (j = 0; j < osize; j++)
    {
      for (item = old_bucket_array[j]; item; item = next)
	{
	  next = item->next;
	  i = item->khash & (table->nbuckets - 1);
	  item->next = table->bucket_array[i];
	  table->bucket_array[i] = item;
	}
    }

  free (old_bucket_array);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\hashlib.c:128
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\hashlib.c:158
parsing error 
{
  int nsize;

  nsize = table->nbuckets * HASH_REHASH_MULTIPLIER;
  if (nsize > 0)		/* overflow */
    hash_rehash (table, nsize);
}
warning: parse error {
  int nsize;

  nsize = table->nbuckets * HASH_REHASH_MULTIPLIER;
  if (nsize > 0)		/* overflow */
    hash_rehash (table, nsize);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\hashlib.c:160
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\hashlib.c:169
parsing error 
{
  int nsize;

  nsize = table->nbuckets / HASH_REHASH_MULTIPLIER;
  hash_rehash (table, nsize);
}
warning: parse error {
  int nsize;

  nsize = table->nbuckets / HASH_REHASH_MULTIPLIER;
  hash_rehash (table, nsize);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\hashlib.c:171
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\hashlib.c:179
parsing error 
{
  HASH_TABLE *new_table;
  int i;

  if (table == 0)
    return ((HASH_TABLE *)NULL);

  new_table = hash_create (table->nbuckets);

  for (i = 0; i < table->nbuckets; i++)
    new_table->bucket_array[i] = copy_bucket_array (table->bucket_array[i], cpdata);

  new_table->nentries = table->nentries;
  return new_table;
}
warning: parse error {
  HASH_TABLE *new_table;
  int i;

  if (table == 0)
    return ((HASH_TABLE *)NULL);

  new_table = hash_create (table->nbuckets);

  for (i = 0; i < table->nbuckets; i++)
    new_table->bucket_array[i] = copy_bucket_array (table->bucket_array[i], cpdata);

  new_table->nentries = table->nentries;
  return new_table;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\hashlib.c:182
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\hashlib.c:216
parsing error 
{
  register unsigned int i;

  for (i = FNV_OFFSET; *s; s++)
    {
      /* FNV-1a has the XOR first, traditional FNV-1 has the multiply first */

      /* was i *= FNV_PRIME */
      i += (i<<1) + (i<<4) + (i<<7) + (i<<8) + (i<<24);
      i ^= *s;
    }

  return i;
}
warning: parse error {
  register unsigned int i;

  for (i = FNV_OFFSET; *s; s++)
    {
      /* FNV-1a has the XOR first, traditional FNV-1 has the multiply first */

      /* was i *= FNV_PRIME */
      i += (i<<1) + (i<<4) + (i<<7) + (i<<8) + (i<<24);
      i ^= *s;
    }

  return i;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\hashlib.c:217
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\hashlib.c:237
parsing error 
{
  unsigned int h;

  return (HASH_BUCKET (string, table, h));
}
warning: parse error {
  unsigned int h;

  return (HASH_BUCKET (string, table, h));
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\hashlib.c:239
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\hashlib.c:249
parsing error 
{
  BUCKET_CONTENTS *list;
  int bucket;
  unsigned int hv;

  if (table == 0 || ((flags & HASH_CREATE) == 0 && HASH_ENTRIES (table) == 0))
    return (BUCKET_CONTENTS *)NULL;

  bucket = HASH_BUCKET (string, table, hv);

  for (list = table->bucket_array ? table->bucket_array[bucket] : 0; list; list = list->next)
    {
      /* This is the comparison function */
      if (hv == list->khash && STREQ (list->key, string))
	{
	  list->times_found++;
	  return (list);
	}
    }

  if (flags & HASH_CREATE)
    {
      if (HASH_SHOULDGROW (table))
	{
	  hash_grow (table);
	  bucket = HASH_BUCKET (string, table, hv);
	}

      list = (BUCKET_CONTENTS *)xmalloc (sizeof (BUCKET_CONTENTS));
      list->next = table->bucket_array[bucket];
      table->bucket_array[bucket] = list;

      list->data = NULL;
      list->key = (char *)string;	/* XXX fix later */
      list->khash = hv;
      list->times_found = 0;

      table->nentries++;
      return (list);
    }
      
  return (BUCKET_CONTENTS *)NULL;
}
warning: parse error {
  BUCKET_CONTENTS *list;
  int bucket;
  unsigned int hv;

  if (table == 0 || ((flags & HASH_CREATE) == 0 && HASH_ENTRIES (table) == 0))
    return (BUCKET_CONTENTS *)NULL;

  bucket = HASH_BUCKET (string, table, hv);

  for (list = table->bucket_array ? table->bucket_array[bucket] : 0; list; list = list->next)
    {
      /* This is the comparison function */
      if (hv == list->khash && STREQ (list->key, string))
	{
	  list->times_found++;
	  return (list);
	}
    }

  if (flags & HASH_CREATE)
    {
      if (HASH_SHOULDGROW (table))
	{
	  hash_grow (table);
	  bucket = HASH_BUCKET (string, table, hv);
	}

      list = (BUCKET_CONTENTS *)xmalloc (sizeof (BUCKET_CONTENTS));
      list->next = table->bucket_array[bucket];
      table->bucket_array[bucket] = list;

      list->data = NULL;
      list->key = (char *)string;	/* XXX fix later */
      list->khash = hv;
      list->times_found = 0;

      table->nentries++;
      return (list);
    }
      
  return (BUCKET_CONTENTS *)NULL;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\hashlib.c:252
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\hashlib.c:301
parsing error 
{
  int bucket;
  BUCKET_CONTENTS *prev, *temp;
  unsigned int hv;

  if (table == 0 || HASH_ENTRIES (table) == 0)
    return (BUCKET_CONTENTS *)NULL;

  bucket = HASH_BUCKET (string, table, hv);
  prev = (BUCKET_CONTENTS *)NULL;
  for (temp = table->bucket_array[bucket]; temp; temp = temp->next)
    {
      if (hv == temp->khash && STREQ (temp->key, string))
	{
	  if (prev)
	    prev->next = temp->next;
	  else
	    table->bucket_array[bucket] = temp->next;

	  table->nentries--;
	  return (temp);
	}
      prev = temp;
    }
  return ((BUCKET_CONTENTS *) NULL);
}
warning: parse error {
  int bucket;
  BUCKET_CONTENTS *prev, *temp;
  unsigned int hv;

  if (table == 0 || HASH_ENTRIES (table) == 0)
    return (BUCKET_CONTENTS *)NULL;

  bucket = HASH_BUCKET (string, table, hv);
  prev = (BUCKET_CONTENTS *)NULL;
  for (temp = table->bucket_array[bucket]; temp; temp = temp->next)
    {
      if (hv == temp->khash && STREQ (temp->key, string))
	{
	  if (prev)
	    prev->next = temp->next;
	  else
	    table->bucket_array[bucket] = temp->next;

	  table->nentries--;
	  return (temp);
	}
      prev = temp;
    }
  return ((BUCKET_CONTENTS *) NULL);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\hashlib.c:304
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\hashlib.c:334
parsing error 
{
  BUCKET_CONTENTS *item;
  int bucket;
  unsigned int hv;

  if (table == 0)
    table = hash_create (0);

  item = (flags & HASH_NOSRCH) ? (BUCKET_CONTENTS *)NULL
  			       : hash_search (string, table, 0);

  if (item == 0)
    {
      if (HASH_SHOULDGROW (table))
	hash_grow (table);

      bucket = HASH_BUCKET (string, table, hv);

      item = (BUCKET_CONTENTS *)xmalloc (sizeof (BUCKET_CONTENTS));
      item->next = table->bucket_array[bucket];
      table->bucket_array[bucket] = item;

      item->data = NULL;
      item->key = string;
      item->khash = hv;
      item->times_found = 0;

      table->nentries++;
    }

  return (item);
}
warning: parse error {
  BUCKET_CONTENTS *item;
  int bucket;
  unsigned int hv;

  if (table == 0)
    table = hash_create (0);

  item = (flags & HASH_NOSRCH) ? (BUCKET_CONTENTS *)NULL
  			       : hash_search (string, table, 0);

  if (item == 0)
    {
      if (HASH_SHOULDGROW (table))
	hash_grow (table);

      bucket = HASH_BUCKET (string, table, hv);

      item = (BUCKET_CONTENTS *)xmalloc (sizeof (BUCKET_CONTENTS));
      item->next = table->bucket_array[bucket];
      table->bucket_array[bucket] = item;

      item->data = NULL;
      item->key = string;
      item->khash = hv;
      item->times_found = 0;

      table->nentries++;
    }

  return (item);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\hashlib.c:338
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\hashlib.c:375
parsing error 
{
  int i;
  register BUCKET_CONTENTS *bucket, *item;

  if (table == 0 || HASH_ENTRIES (table) == 0)
    return;

  for (i = 0; i < table->nbuckets; i++)
    {
      bucket = table->bucket_array[i];

      while (bucket)
	{
	  item = bucket;
	  bucket = bucket->next;

	  if (free_data)
	    (*free_data) (item->data);
	  else
	    free (item->data);
	  free (item->key);
	  free (item);
	}
      table->bucket_array[i] = (BUCKET_CONTENTS *)NULL;
    }

  table->nentries = 0;
}
warning: parse error {
  int i;
  register BUCKET_CONTENTS *bucket, *item;

  if (table == 0 || HASH_ENTRIES (table) == 0)
    return;

  for (i = 0; i < table->nbuckets; i++)
    {
      bucket = table->bucket_array[i];

      while (bucket)
	{
	  item = bucket;
	  bucket = bucket->next;

	  if (free_data)
	    (*free_data) (item->data);
	  else
	    free (item->data);
	  free (item->key);
	  free (item);
	}
      table->bucket_array[i] = (BUCKET_CONTENTS *)NULL;
    }

  table->nentries = 0;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\hashlib.c:378
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\hashlib.c:409
parsing error 
{
  free (table->bucket_array);
  free (table);
}
warning: parse error {
  free (table->bucket_array);
  free (table);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\hashlib.c:411
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\hashlib.c:417
parsing error 
{
  register int i;
  BUCKET_CONTENTS *item;

  if (table == 0 || HASH_ENTRIES (table) == 0)
    return;

  for (i = 0; i < table->nbuckets; i++)
    {
      for (item = hash_items (i, table); item; item = item->next)
	if ((*func) (item) < 0)
	  return;
    }
}
warning: parse error {
  register int i;
  BUCKET_CONTENTS *item;

  if (table == 0 || HASH_ENTRIES (table) == 0)
    return;

  for (i = 0; i < table->nbuckets; i++)
    {
      for (item = hash_items (i, table); item; item = item->next)
	if ((*func) (item) < 0)
	  return;
    }
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\hashlib.c:420
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\input.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashtypes.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\filecntl.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\posixstat.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashansi.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashintl.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\shell.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\input.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\externs.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\trap.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\input.c:72
parsing error 
{
  unsigned char uc;

  CHECK_TERMSIG;

  /* Try local buffering to reduce the number of read(2) calls. */
  if (local_index == local_bufused || local_bufused == 0)
    {
      while (1)
	{
	  QUIT;
	  run_pending_traps ();

	  local_bufused = read (fileno (stream), localbuf, sizeof(localbuf));
	  if (local_bufused > 0)
	    break;
	  else if (local_bufused == 0)
	    {
	      local_index = 0;
	      return EOF;
	    }
	  else if (errno == X_EAGAIN || errno == X_EWOULDBLOCK)
	    {
	      if (sh_unset_nodelay_mode (fileno (stream)) < 0)
		{
		  sys_error (_("cannot reset nodelay mode for fd %d"), fileno (stream));
		  local_index = local_bufused = 0;
		  return EOF;
		}
	      continue;
	    }
	  else if (errno != EINTR)
	    {
	      local_index = local_bufused = 0;
	      return EOF;
	    }
	  else if (interrupt_state || terminating_signal)	/* QUIT; */
	    local_index = local_bufused = 0;
	}
      local_index = 0;
    }
  uc = localbuf[local_index++];
  return uc;
}
warning: parse error {
  unsigned char uc;

  CHECK_TERMSIG;

  /* Try local buffering to reduce the number of read(2) calls. */
  if (local_index == local_bufused || local_bufused == 0)
    {
      while (1)
	{
	  QUIT;
	  run_pending_traps ();

	  local_bufused = read (fileno (stream), localbuf, sizeof(localbuf));
	  if (local_bufused > 0)
	    break;
	  else if (local_bufused == 0)
	    {
	      local_index = 0;
	      return EOF;
	    }
	  else if (errno == X_EAGAIN || errno == X_EWOULDBLOCK)
	    {
	      if (sh_unset_nodelay_mode (fileno (stream)) < 0)
		{
		  sys_error (_("cannot reset nodelay mode for fd %d"), fileno (stream));
		  local_index = local_bufused = 0;
		  return EOF;
		}
	      continue;
	    }
	  else if (errno != EINTR)
	    {
	      local_index = local_bufused = 0;
	      return EOF;
	    }
	  else if (interrupt_state || terminating_signal)	/* QUIT; */
	    local_index = local_bufused = 0;
	}
      local_index = 0;
    }
  uc = localbuf[local_index++];
  return uc;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\input.c:74
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\input.c:120
parsing error 
{
  if (local_index == 0 || c == EOF)
    return EOF;
  localbuf[--local_index] = c;
  return c;
}
warning: parse error {
  if (local_index == 0 || c == EOF)
    return EOF;
  localbuf[--local_index] = c;
  return c;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\input.c:123
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\jobs.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashtypes.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\trap.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\posixtime.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\filecntl.h...skip
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\shtty.h...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\stdc.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashansi.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashintl.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\shell.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\parser.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\jobs.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\execute_cmd.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\flags.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\typemax.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\common.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\jobs.c:358
parsing error 
{
  pid_t pgrp;

  /* ioctl will handle setting errno correctly. */
  if (ioctl (fd, TIOCGPGRP, &pgrp) < 0)
    return (-1);
  return (pgrp);
}
warning: parse error {
  pid_t pgrp;

  /* ioctl will handle setting errno correctly. */
  if (ioctl (fd, TIOCGPGRP, &pgrp) < 0)
    return (-1);
  return (pgrp);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\jobs.c:360
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\jobs.c:479
parsing error 
{
  sigset_t set, oset;
  struct pipeline_saver *saver;

  BLOCK_CHILD (set, oset);
  saver = alloc_pipeline_saver ();
  saver->pipeline = the_pipeline;
  saver->next = saved_pipeline;
  saved_pipeline = saver;
  if (clear)
    the_pipeline = (PROCESS *)NULL;
  saved_already_making_children = already_making_children;
  UNBLOCK_CHILD (oset);
}
warning: parse error {
  sigset_t set, oset;
  struct pipeline_saver *saver;

  BLOCK_CHILD (set, oset);
  saver = alloc_pipeline_saver ();
  saver->pipeline = the_pipeline;
  saver->next = saved_pipeline;
  saved_pipeline = saver;
  if (clear)
    the_pipeline = (PROCESS *)NULL;
  saved_already_making_children = already_making_children;
  UNBLOCK_CHILD (oset);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\jobs.c:481
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\jobs.c:497
parsing error 
{
  PROCESS *old_pipeline;
  sigset_t set, oset;
  struct pipeline_saver *saver;

  BLOCK_CHILD (set, oset);
  old_pipeline = the_pipeline;
  the_pipeline = saved_pipeline->pipeline;
  saver = saved_pipeline;
  saved_pipeline = saved_pipeline->next;
  free (saver);
  already_making_children = saved_already_making_children;
  UNBLOCK_CHILD (oset);

  if (discard && old_pipeline)
    {
      discard_pipeline (old_pipeline);
      return ((PROCESS *)NULL);
    }
  return old_pipeline;
}
warning: parse error {
  PROCESS *old_pipeline;
  sigset_t set, oset;
  struct pipeline_saver *saver;

  BLOCK_CHILD (set, oset);
  old_pipeline = the_pipeline;
  the_pipeline = saved_pipeline->pipeline;
  saver = saved_pipeline;
  saved_pipeline = saved_pipeline->next;
  free (saver);
  already_making_children = saved_already_making_children;
  UNBLOCK_CHILD (oset);

  if (discard && old_pipeline)
    {
      discard_pipeline (old_pipeline);
      return ((PROCESS *)NULL);
    }
  return old_pipeline;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\jobs.c:499
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\jobs.c:553
parsing error 
{
  register int i, j;
  JOB *newjob;
  sigset_t set, oset;

  BLOCK_CHILD (set, oset);

#if defined (PGRP_PIPE)
  /* The parent closes the process group synchronization pipe. */
  sh_closepipe (pgrp_pipe);
#endif

  cleanup_dead_jobs ();

  if (js.j_jobslots == 0)
    {
      js.j_jobslots = JOB_SLOTS;
      jobs = (JOB **)xmalloc (js.j_jobslots * sizeof (JOB *));

      /* Now blank out these new entries. */
      for (i = 0; i < js.j_jobslots; i++)
	jobs[i] = (JOB *)NULL;

      js.j_firstj = js.j_lastj = js.j_njobs = 0;
    }

  /* Scan from the last slot backward, looking for the next free one. */
  /* XXX - revisit this interactive assumption */
  /* XXX - this way for now */
  if (interactive)
    {
      for (i = js.j_jobslots; i; i--)
	if (jobs[i - 1])
	  break;
    }
  else
    {
#if 0
      /* This wraps around, but makes it inconvenient to extend the array */
      for (i = js.j_lastj+1; i != js.j_lastj; i++)
	{
	  if (i >= js.j_jobslots)
	    i = 0;
	  if (jobs[i] == 0)
	    break;
	}	
      if (i == js.j_lastj)
        i = js.j_jobslots;
#else
      /* This doesn't wrap around yet. */
      for (i = js.j_lastj ? js.j_lastj + 1 : js.j_lastj; i < js.j_jobslots; i++)
	if (jobs[i] == 0)
	  break;
#endif
    }

  /* Do we need more room? */

  /* First try compaction */
  if ((interactive_shell == 0 || subshell_environment) && i == js.j_jobslots && js.j_jobslots >= MAX_JOBS_IN_ARRAY)
    i = compact_jobs_list (0);

  /* If we can't compact, reallocate */
  if (i == js.j_jobslots)
    {
      js.j_jobslots += JOB_SLOTS;
      jobs = (JOB **)xrealloc (jobs, (js.j_jobslots * sizeof (JOB *)));

      for (j = i; j < js.j_jobslots; j++)
	jobs[j] = (JOB *)NULL;
    }

  /* Add the current pipeline to the job list. */
  if (the_pipeline)
    {
      register PROCESS *p;
      int any_running, any_stopped, n;

      newjob = (JOB *)xmalloc (sizeof (JOB));

      for (n = 1, p = the_pipeline; p->next != the_pipeline; n++, p = p->next)
	;
      p->next = (PROCESS *)NULL;
      newjob->pipe = REVERSE_LIST (the_pipeline, PROCESS *);
      for (p = newjob->pipe; p->next; p = p->next)
	;
      p->next = newjob->pipe;

      the_pipeline = (PROCESS *)NULL;
      newjob->pgrp = pipeline_pgrp;
      if (pipeline_pgrp != shell_pgrp)
	pipeline_pgrp = 0;

      newjob->flags = 0;
      if (pipefail_opt)
	newjob->flags |= J_PIPEFAIL;

      /* Flag to see if in another pgrp. */
      if (job_control)
	newjob->flags |= J_JOBCONTROL;

      /* Set the state of this pipeline. */
      p = newjob->pipe;
      any_running = any_stopped = 0;
      do
	{
	  any_running |= PRUNNING (p);
	  any_stopped |= PSTOPPED (p);
	  p = p->next;
	}
      while (p != newjob->pipe);

      newjob->state = any_running ? JRUNNING : (any_stopped ? JSTOPPED : JDEAD);
      newjob->wd = job_working_directory ();
      newjob->deferred = deferred;

      newjob->j_cleanup = (sh_vptrfunc_t *)NULL;
      newjob->cleanarg = (PTR_T) NULL;

      jobs[i] = newjob;
      if (newjob->state == JDEAD && (newjob->flags & J_FOREGROUND))
	setjstatus (i);
      if (newjob->state == JDEAD)
	{
	  js.c_reaped += n;	/* wouldn't have been done since this was not part of a job */
	  js.j_ndead++;
	}
      js.c_injobs += n;

      js.j_lastj = i;
      js.j_njobs++;
    }
  else
    newjob = (JOB *)NULL;

  if (newjob)
    js.j_lastmade = newjob;

  if (async)
    {
      if (newjob)
	{
	  newjob->flags &= ~J_FOREGROUND;
	  newjob->flags |= J_ASYNC;
	  js.j_lastasync = newjob;
	}
      reset_current ();
    }
  else
    {
      if (newjob)
	{
	  newjob->flags |= J_FOREGROUND;
	  /*
	   *		!!!!! NOTE !!!!!  (chet@po.cwru.edu)
	   *
	   * The currently-accepted job control wisdom says to set the
	   * terminal's process group n+1 times in an n-step pipeline:
	   * once in the parent and once in each child.  This is where
	   * the parent gives it away.
	   *
	   * Don't give the terminal away if this shell is an asynchronous
	   * subshell or if we're a (presumably non-interactive) shell running
	   * in the background.
	   *
	   */
	  if (job_control && newjob->pgrp && (subshell_environment&SUBSHELL_ASYNC) == 0 && running_in_background == 0)
	    maybe_give_terminal_to (shell_pgrp, newjob->pgrp, 0);
	}
    }

  stop_making_children ();
  UNBLOCK_CHILD (oset);
  return (newjob ? i : js.j_current);
}
warning: parse error {
  register int i, j;
  JOB *newjob;
  sigset_t set, oset;

  BLOCK_CHILD (set, oset);

#if defined (PGRP_PIPE)
  /* The parent closes the process group synchronization pipe. */
  sh_closepipe (pgrp_pipe);
#endif

  cleanup_dead_jobs ();

  if (js.j_jobslots == 0)
    {
      js.j_jobslots = JOB_SLOTS;
      jobs = (JOB **)xmalloc (js.j_jobslots * sizeof (JOB *));

      /* Now blank out these new entries. */
      for (i = 0; i < js.j_jobslots; i++)
	jobs[i] = (JOB *)NULL;

      js.j_firstj = js.j_lastj = js.j_njobs = 0;
    }

  /* Scan from the last slot backward, looking for the next free one. */
  /* XXX - revisit this interactive assumption */
  /* XXX - this way for now */
  if (interactive)
    {
      for (i = js.j_jobslots; i; i--)
	if (jobs[i - 1])
	  break;
    }
  else
    {
#if 0
      /* This wraps around, but makes it inconvenient to extend the array */
      for (i = js.j_lastj+1; i != js.j_lastj; i++)
	{
	  if (i >= js.j_jobslots)
	    i = 0;
	  if (jobs[i] == 0)
	    break;
	}	
      if (i == js.j_lastj)
        i = js.j_jobslots;
#else
      /* This doesn't wrap around yet. */
      for (i = js.j_lastj ? js.j_lastj + 1 : js.j_lastj; i < js.j_jobslots; i++)
	if (jobs[i] == 0)
	  break;
#endif
    }

  /* Do we need more room? */

  /* First try compaction */
  if ((interactive_shell == 0 || subshell_environment) && i == js.j_jobslots && js.j_jobslots >= MAX_JOBS_IN_ARRAY)
    i = compact_jobs_list (0);

  /* If we can't compact, reallocate */
  if (i == js.j_jobslots)
    {
      js.j_jobslots += JOB_SLOTS;
      jobs = (JOB **)xrealloc (jobs, (js.j_jobslots * sizeof (JOB *)));

      for (j = i; j < js.j_jobslots; j++)
	jobs[j] = (JOB *)NULL;
    }

  /* Add the current pipeline to the job list. */
  if (the_pipeline)
    {
      register PROCESS *p;
      int any_running, any_stopped, n;

      newjob = (JOB *)xmalloc (sizeof (JOB));

      for (n = 1, p = the_pipeline; p->next != the_pipeline; n++, p = p->next)
	;
      p->next = (PROCESS *)NULL;
      newjob->pipe = REVERSE_LIST (the_pipeline, PROCESS *);
      for (p = newjob->pipe; p->next; p = p->next)
	;
      p->next = newjob->pipe;

      the_pipeline = (PROCESS *)NULL;
      newjob->pgrp = pipeline_pgrp;
      if (pipeline_pgrp != shell_pgrp)
	pipeline_pgrp = 0;

      newjob->flags = 0;
      if (pipefail_opt)
	newjob->flags |= J_PIPEFAIL;

      /* Flag to see if in another pgrp. */
      if (job_control)
	newjob->flags |= J_JOBCONTROL;

      /* Set the state of this pipeline. */
      p = newjob->pipe;
      any_running = any_stopped = 0;
      do
	{
	  any_running |= PRUNNING (p);
	  any_stopped |= PSTOPPED (p);
	  p = p->next;
	}
      while (p != newjob->pipe);

      newjob->state = any_running ? JRUNNING : (any_stopped ? JSTOPPED : JDEAD);
      newjob->wd = job_working_directory ();
      newjob->deferred = deferred;

      newjob->j_cleanup = (sh_vptrfunc_t *)NULL;
      newjob->cleanarg = (PTR_T) NULL;

      jobs[i] = newjob;
      if (newjob->state == JDEAD && (newjob->flags & J_FOREGROUND))
	setjstatus (i);
      if (newjob->state == JDEAD)
	{
	  js.c_reaped += n;	/* wouldn't have been done since this was not part of a job */
	  js.j_ndead++;
	}
      js.c_injobs += n;

      js.j_lastj = i;
      js.j_njobs++;
    }
  else
    newjob = (JOB *)NULL;

  if (newjob)
    js.j_lastmade = newjob;

  if (async)
    {
      if (newjob)
	{
	  newjob->flags &= ~J_FOREGROUND;
	  newjob->flags |= J_ASYNC;
	  js.j_lastasync = newjob;
	}
      reset_current ();
    }
  else
    {
      if (newjob)
	{
	  newjob->flags |= J_FOREGROUND;
	  /*
	   *		!!!!! NOTE !!!!!  (chet@po.cwru.edu)
	   *
	   * The currently-accepted job control wisdom says to set the
	   * terminal's process group n+1 times in an n-step pipeline:
	   * once in the parent and once in each child.  This is where
	   * the parent gives it away.
	   *
	   * Don't give the terminal away if this shell is an asynchronous
	   * subshell or if we're a (presumably non-interactive) shell running
	   * in the background.
	   *
	   */
	  if (job_control && newjob->pgrp && (subshell_environment&SUBSHELL_ASYNC) == 0 && running_in_background == 0)
	    maybe_give_terminal_to (shell_pgrp, newjob->pgrp, 0);
	}
    }

  stop_making_children ();
  UNBLOCK_CHILD (oset);
  return (newjob ? i : js.j_current);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\jobs.c:556
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\jobs.c:809
parsing error 
{
  unsigned long hash;		/* XXX - u_bits32_t */

  hash = pid * 0x9e370001UL;
  return (&pidstat_table[hash % PIDSTAT_TABLE_SZ]);
}
warning: parse error {
  unsigned long hash;		/* XXX - u_bits32_t */

  hash = pid * 0x9e370001UL;
  return (&pidstat_table[hash % PIDSTAT_TABLE_SZ]);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\jobs.c:811
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\jobs.c:819
parsing error 
{
  ps_index_t *bucket, psi;
  struct pidstat *ps;

  /* bucket == existing chain of pids hashing to same value
     psi = where were going to put this pid/status */

  bucket = pshash_getbucket (pid);	/* index into pidstat_table */
  psi = bgp_getindex ();		/* bgpids.head, index into storage */

  /* XXX - what if psi == *bucket? */
  if (psi == *bucket)
    {
#ifdef DEBUG
      internal_warning ("hashed pid %d (pid %d) collides with bgpids.head, skipping", psi, pid);
#endif
      bgpids.storage[psi].pid = NO_PID;		/* make sure */
      psi = bgp_getindex ();			/* skip to next one */
    }

  ps = &bgpids.storage[psi];

  ps->pid = pid;
  ps->status = status;
  ps->bucket_next = *bucket;
  ps->bucket_prev = NO_PIDSTAT;

  bgpids.npid++;

#if 0
  if (bgpids.npid > js.c_childmax)
    bgp_prune ();
#endif

  if (ps->bucket_next != NO_PIDSTAT)
    bgpids.storage[ps->bucket_next].bucket_prev = psi;

  *bucket = psi;		/* set chain head in hash table */

  return ps;
}
warning: parse error {
  ps_index_t *bucket, psi;
  struct pidstat *ps;

  /* bucket == existing chain of pids hashing to same value
     psi = where were going to put this pid/status */

  bucket = pshash_getbucket (pid);	/* index into pidstat_table */
  psi = bgp_getindex ();		/* bgpids.head, index into storage */

  /* XXX - what if psi == *bucket? */
  if (psi == *bucket)
    {
#ifdef DEBUG
      internal_warning ("hashed pid %d (pid %d) collides with bgpids.head, skipping", psi, pid);
#endif
      bgpids.storage[psi].pid = NO_PID;		/* make sure */
      psi = bgp_getindex ();			/* skip to next one */
    }

  ps = &bgpids.storage[psi];

  ps->pid = pid;
  ps->status = status;
  ps->bucket_next = *bucket;
  ps->bucket_prev = NO_PIDSTAT;

  bgpids.npid++;

#if 0
  if (bgpids.npid > js.c_childmax)
    bgp_prune ();
#endif

  if (ps->bucket_next != NO_PIDSTAT)
    bgpids.storage[ps->bucket_next].bucket_prev = psi;

  *bucket = psi;		/* set chain head in hash table */

  return ps;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\jobs.c:822
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\jobs.c:865
parsing error 
{
  struct pidstat *ps;
  ps_index_t *bucket;

  ps = &bgpids.storage[psi];
  if (ps->pid == NO_PID)
    return;

  if (ps->bucket_next != NO_PIDSTAT)
    bgpids.storage[ps->bucket_next].bucket_prev = ps->bucket_prev;
  if (ps->bucket_prev != NO_PIDSTAT)
    bgpids.storage[ps->bucket_prev].bucket_next = ps->bucket_next;
  else
    {
      bucket = pshash_getbucket (ps->pid);
      *bucket = ps->bucket_next;	/* deleting chain head in hash table */
    }

  /* clear out this cell, in case it gets reused. */
  ps->pid = NO_PID;
  ps->bucket_next = ps->bucket_prev = NO_PIDSTAT;
}
warning: parse error {
  struct pidstat *ps;
  ps_index_t *bucket;

  ps = &bgpids.storage[psi];
  if (ps->pid == NO_PID)
    return;

  if (ps->bucket_next != NO_PIDSTAT)
    bgpids.storage[ps->bucket_next].bucket_prev = ps->bucket_prev;
  if (ps->bucket_prev != NO_PIDSTAT)
    bgpids.storage[ps->bucket_prev].bucket_next = ps->bucket_next;
  else
    {
      bucket = pshash_getbucket (ps->pid);
      *bucket = ps->bucket_next;	/* deleting chain head in hash table */
    }

  /* clear out this cell, in case it gets reused. */
  ps->pid = NO_PID;
  ps->bucket_next = ps->bucket_prev = NO_PIDSTAT;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\jobs.c:867
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\jobs.c:891
parsing error 
{
  ps_index_t psi, orig_psi;

  if (bgpids.storage == 0 || bgpids.nalloc == 0 || bgpids.npid == 0)
    return 0;

  /* Search chain using hash to find bucket in pidstat_table */
  for (orig_psi = psi = *(pshash_getbucket (pid)); psi != NO_PIDSTAT; psi = bgpids.storage[psi].bucket_next)
    {
      if (bgpids.storage[psi].pid == pid)
	break;
      if (orig_psi == bgpids.storage[psi].bucket_next)	/* catch reported bug */
	{
	  internal_warning (_("bgp_delete: LOOP: psi (%d) == storage[psi].bucket_next"), psi);
	  return 0;
	}
    }

  if (psi == NO_PIDSTAT)
    return 0;		/* not found */

#if defined (DEBUG)
  itrace("bgp_delete: deleting %d", pid);
#endif

  pshash_delindex (psi);	/* hash table management */

  bgpids.npid--;
  return 1;
}
warning: parse error {
  ps_index_t psi, orig_psi;

  if (bgpids.storage == 0 || bgpids.nalloc == 0 || bgpids.npid == 0)
    return 0;

  /* Search chain using hash to find bucket in pidstat_table */
  for (orig_psi = psi = *(pshash_getbucket (pid)); psi != NO_PIDSTAT; psi = bgpids.storage[psi].bucket_next)
    {
      if (bgpids.storage[psi].pid == pid)
	break;
      if (orig_psi == bgpids.storage[psi].bucket_next)	/* catch reported bug */
	{
	  internal_warning (_("bgp_delete: LOOP: psi (%d) == storage[psi].bucket_next"), psi);
	  return 0;
	}
    }

  if (psi == NO_PIDSTAT)
    return 0;		/* not found */

#if defined (DEBUG)
  itrace("bgp_delete: deleting %d", pid);
#endif

  pshash_delindex (psi);	/* hash table management */

  bgpids.npid--;
  return 1;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\jobs.c:893
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\jobs.c:944
parsing error 
{
  ps_index_t psi, orig_psi;

  if (bgpids.storage == 0 || bgpids.nalloc == 0 || bgpids.npid == 0)
    return -1;

  /* Search chain using hash to find bucket in pidstat_table */
  for (orig_psi = psi = *(pshash_getbucket (pid)); psi != NO_PIDSTAT; psi = bgpids.storage[psi].bucket_next)
    {
      if (bgpids.storage[psi].pid == pid)
	return (bgpids.storage[psi].status);
      if (orig_psi == bgpids.storage[psi].bucket_next)	/* catch reported bug */
	{
	  internal_warning (_("bgp_search: LOOP: psi (%d) == storage[psi].bucket_next"), psi);
	  return -1;
	}
    }

  return -1;
}
warning: parse error {
  ps_index_t psi, orig_psi;

  if (bgpids.storage == 0 || bgpids.nalloc == 0 || bgpids.npid == 0)
    return -1;

  /* Search chain using hash to find bucket in pidstat_table */
  for (orig_psi = psi = *(pshash_getbucket (pid)); psi != NO_PIDSTAT; psi = bgpids.storage[psi].bucket_next)
    {
      if (bgpids.storage[psi].pid == pid)
	return (bgpids.storage[psi].status);
      if (orig_psi == bgpids.storage[psi].bucket_next)	/* catch reported bug */
	{
	  internal_warning (_("bgp_search: LOOP: psi (%d) == storage[psi].bucket_next"), psi);
	  return -1;
	}
    }

  return -1;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\jobs.c:946
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\jobs.c:978
parsing error 
{
  sigset_t set, oset;

  BLOCK_CHILD (set, oset);
  bgp_add (pid, status);
  UNBLOCK_CHILD (oset);  
}
warning: parse error {
  sigset_t set, oset;

  BLOCK_CHILD (set, oset);
  bgp_add (pid, status);
  UNBLOCK_CHILD (oset);  
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\jobs.c:981
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\jobs.c:1,247
parsing error 
{
  int nproc;
  register PROCESS *p;

  nproc = 0;
  p = jobs[job]->pipe;
  do
    {
      p = p->next;
      nproc++;
    }
  while (p != jobs[job]->pipe);

  return nproc;
}
warning: parse error {
  int nproc;
  register PROCESS *p;

  nproc = 0;
  p = jobs[job]->pipe;
  do
    {
      p = p->next;
      nproc++;
    }
  while (p != jobs[job]->pipe);

  return nproc;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\jobs.c:1,249
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\jobs.c:1,266
parsing error 
{
  PROCESS *p;
  int job;

  job = find_job (pid, 0, &p);
  if (job != NO_JOB)
    {
#ifdef DEBUG
      itrace ("delete_old_job: found pid %d in job %d with state %d", pid, job, jobs[job]->state);
#endif
      if (JOBSTATE (job) == JDEAD)
	delete_job (job, DEL_NOBGPID);
      else
	{
#ifdef DEBUG
	  internal_warning (_("forked pid %d appears in running job %d"), pid, job+1);
#endif
	  if (p)
	    p->pid = 0;
	}
    }
}
warning: parse error {
  PROCESS *p;
  int job;

  job = find_job (pid, 0, &p);
  if (job != NO_JOB)
    {
#ifdef DEBUG
      itrace ("delete_old_job: found pid %d in job %d with state %d", pid, job, jobs[job]->state);
#endif
      if (JOBSTATE (job) == JDEAD)
	delete_job (job, DEL_NOBGPID);
      else
	{
#ifdef DEBUG
	  internal_warning (_("forked pid %d appears in running job %d"), pid, job+1);
#endif
	  if (p)
	    p->pid = 0;
	}
    }
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\jobs.c:1,268
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\jobs.c:1,372
parsing error 
{
  if (js.j_jobslots == 0 || jobs_list_frozen)
    return js.j_jobslots;

  reap_dead_jobs ();
  realloc_jobs_list ();

#if 0
  itrace("compact_jobs_list: returning %d", (js.j_lastj || jobs[js.j_lastj]) ? js.j_lastj + 1 : 0);
#endif

  return ((js.j_lastj || jobs[js.j_lastj]) ? js.j_lastj + 1 : 0);
}
warning: parse error {
  if (js.j_jobslots == 0 || jobs_list_frozen)
    return js.j_jobslots;

  reap_dead_jobs ();
  realloc_jobs_list ();

#if 0
  itrace("compact_jobs_list: returning %d", (js.j_lastj || jobs[js.j_lastj]) ? js.j_lastj + 1 : 0);
#endif

  return ((js.j_lastj || jobs[js.j_lastj]) ? js.j_lastj + 1 : 0);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\jobs.c:1,374
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\jobs.c:1,391
parsing error 
{
  register JOB *temp;
  PROCESS *proc;
  int ndel;

  if (js.j_jobslots == 0 || jobs_list_frozen)
    return;

  if ((dflags & DEL_WARNSTOPPED) && subshell_environment == 0 && STOPPED (job_index))
    internal_warning (_("deleting stopped job %d with process group %ld"), job_index+1, (long)jobs[job_index]->pgrp);
  temp = jobs[job_index];
  if (temp == 0)
    return;

  if ((dflags & DEL_NOBGPID) == 0 && (temp->flags & (J_ASYNC|J_FOREGROUND)) == J_ASYNC)
    {
      proc = find_last_proc (job_index, 0);
      if (proc)
	bgp_add (proc->pid, process_exit_status (proc->status));
    }

  jobs[job_index] = (JOB *)NULL;
  if (temp == js.j_lastmade)
    js.j_lastmade = 0;
  else if (temp == js.j_lastasync)
    js.j_lastasync = 0;

  free (temp->wd);
  ndel = discard_pipeline (temp->pipe);

  js.c_injobs -= ndel;
  if (temp->state == JDEAD)
    {
      /* XXX - save_pipeline and restore_pipeline (e.g., for DEBUG trap) can
	 mess with this total. */
      js.c_reaped -= ndel;	/* assumes proc hadn't been reaped earlier */
      js.j_ndead--;
      if (js.c_reaped < 0)
	{
#ifdef DEBUG
	  itrace("delete_job (%d pgrp %d): js.c_reaped (%d) < 0 ndel = %d js.j_ndead = %d", job_index, temp->pgrp, js.c_reaped, ndel, js.j_ndead);
#endif
	  js.c_reaped = 0;
	}
    }

  if (temp->deferred)
    dispose_command (temp->deferred);

  free (temp);

  js.j_njobs--;
  if (js.j_njobs == 0)
    js.j_firstj = js.j_lastj = 0;
  else if (jobs[js.j_firstj] == 0 || jobs[js.j_lastj] == 0)
    reset_job_indices ();

  if (job_index == js.j_current || job_index == js.j_previous)
    reset_current ();
}
warning: parse error {
  register JOB *temp;
  PROCESS *proc;
  int ndel;

  if (js.j_jobslots == 0 || jobs_list_frozen)
    return;

  if ((dflags & DEL_WARNSTOPPED) && subshell_environment == 0 && STOPPED (job_index))
    internal_warning (_("deleting stopped job %d with process group %ld"), job_index+1, (long)jobs[job_index]->pgrp);
  temp = jobs[job_index];
  if (temp == 0)
    return;

  if ((dflags & DEL_NOBGPID) == 0 && (temp->flags & (J_ASYNC|J_FOREGROUND)) == J_ASYNC)
    {
      proc = find_last_proc (job_index, 0);
      if (proc)
	bgp_add (proc->pid, process_exit_status (proc->status));
    }

  jobs[job_index] = (JOB *)NULL;
  if (temp == js.j_lastmade)
    js.j_lastmade = 0;
  else if (temp == js.j_lastasync)
    js.j_lastasync = 0;

  free (temp->wd);
  ndel = discard_pipeline (temp->pipe);

  js.c_injobs -= ndel;
  if (temp->state == JDEAD)
    {
      /* XXX - save_pipeline and restore_pipeline (e.g., for DEBUG trap) can
	 mess with this total. */
      js.c_reaped -= ndel;	/* assumes proc hadn't been reaped earlier */
      js.j_ndead--;
      if (js.c_reaped < 0)
	{
#ifdef DEBUG
	  itrace("delete_job (%d pgrp %d): js.c_reaped (%d) < 0 ndel = %d js.j_ndead = %d", job_index, temp->pgrp, js.c_reaped, ndel, js.j_ndead);
#endif
	  js.c_reaped = 0;
	}
    }

  if (temp->deferred)
    dispose_command (temp->deferred);

  free (temp);

  js.j_njobs--;
  if (js.j_njobs == 0)
    js.j_firstj = js.j_lastj = 0;
  else if (jobs[js.j_firstj] == 0 || jobs[js.j_lastj] == 0)
    reset_job_indices ();

  if (job_index == js.j_current || job_index == js.j_previous)
    reset_current ();
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\jobs.c:1,393
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\jobs.c:1,456
parsing error 
{
  register JOB *temp;

  if (js.j_jobslots == 0)
    return;

  if (temp = jobs[job_index])
    temp->flags |= J_NOHUP;
}
warning: parse error {
  register JOB *temp;

  if (js.j_jobslots == 0)
    return;

  if (temp = jobs[job_index])
    temp->flags |= J_NOHUP;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\jobs.c:1,458
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\jobs.c:1,470
parsing error 
{
  register PROCESS *this, *next;
  int n;

  this = chain;
  n = 0;
  do
    {
      next = this->next;
      FREE (this->command);
      free (this);
      n++;
      this = next;
    }
  while (this != chain);

  return n;
}
warning: parse error {
  register PROCESS *this, *next;
  int n;

  this = chain;
  n = 0;
  do
    {
      next = this->next;
      FREE (this->command);
      free (this);
      n++;
      this = next;
    }
  while (this != chain);

  return n;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\jobs.c:1,472
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\jobs.c:1,495
parsing error 
{
  PROCESS *t, *p;

#if defined (RECYCLES_PIDS)
  int j;
  p = find_process (pid, 0, &j);
  if (p)
    {
#  ifdef DEBUG
      if (j == NO_JOB)
	internal_warning ("add_process: process %5ld (%s) in the_pipeline", (long)p->pid, p->command);
#  endif
      if (PALIVE (p))
	internal_warning (_("add_process: pid %5ld (%s) marked as still alive"), (long)p->pid, p->command);
      p->running = PS_RECYCLED;		/* mark as recycled */
    }
#endif

  t = (PROCESS *)xmalloc (sizeof (PROCESS));
  t->next = the_pipeline;
  t->pid = pid;
  WSTATUS (t->status) = 0;
  t->running = PS_RUNNING;
  t->command = name;
  the_pipeline = t;

  if (t->next == 0)
    t->next = t;
  else
    {
      p = t->next;
      while (p->next != t->next)
	p = p->next;
      p->next = t;
    }
}
warning: parse error {
  PROCESS *t, *p;

#if defined (RECYCLES_PIDS)
  int j;
  p = find_process (pid, 0, &j);
  if (p)
    {
#  ifdef DEBUG
      if (j == NO_JOB)
	internal_warning ("add_process: process %5ld (%s) in the_pipeline", (long)p->pid, p->command);
#  endif
      if (PALIVE (p))
	internal_warning (_("add_process: pid %5ld (%s) marked as still alive"), (long)p->pid, p->command);
      p->running = PS_RECYCLED;		/* mark as recycled */
    }
#endif

  t = (PROCESS *)xmalloc (sizeof (PROCESS));
  t->next = the_pipeline;
  t->pid = pid;
  WSTATUS (t->status) = 0;
  t->running = PS_RUNNING;
  t->command = name;
  the_pipeline = t;

  if (t->next == 0)
    t->next = t;
  else
    {
      p = t->next;
      while (p->next != t->next)
	p = p->next;
      p->next = t;
    }
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\jobs.c:1,498
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\jobs.c:1,538
parsing error 
{
  PROCESS *t, *p;

  t = (PROCESS *)xmalloc (sizeof (PROCESS));
  t->next = (PROCESS *)NULL;
  t->pid = pid;
  /* set process exit status using offset discovered by configure */
  t->status = (status & 0xff) << WEXITSTATUS_OFFSET;
  t->running = PS_DONE;
  t->command = name;

  js.c_reaped++;	/* XXX */

  for (p = jobs[jid]->pipe; p->next != jobs[jid]->pipe; p = p->next)
    ;
  p->next = t;
  t->next = jobs[jid]->pipe;
}
warning: parse error {
  PROCESS *t, *p;

  t = (PROCESS *)xmalloc (sizeof (PROCESS));
  t->next = (PROCESS *)NULL;
  t->pid = pid;
  /* set process exit status using offset discovered by configure */
  t->status = (status & 0xff) << WEXITSTATUS_OFFSET;
  t->running = PS_DONE;
  t->command = name;

  js.c_reaped++;	/* XXX */

  for (p = jobs[jid]->pipe; p->next != jobs[jid]->pipe; p = p->next)
    ;
  p->next = t;
  t->next = jobs[jid]->pipe;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\jobs.c:1,543
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\jobs.c:1,605
parsing error 
{
  register int i;
  int result;
  sigset_t set, oset;

  if (js.j_jobslots == 0)
    return 0;

  BLOCK_CHILD (set, oset);

  /* XXX could use js.j_firstj here */
  for (i = result = 0; i < js.j_jobslots; i++)
    {
#if defined (DEBUG)
      if (i < js.j_firstj && jobs[i])
	itrace("map_over_jobs: job %d non-null before js.j_firstj (%d)", i, js.j_firstj);
      if (i > js.j_lastj && jobs[i])
	itrace("map_over_jobs: job %d non-null after js.j_lastj (%d)", i, js.j_lastj);
#endif
      if (jobs[i])
	{
	  result = (*func)(jobs[i], arg1, arg2, i);
	  if (result)
	    break;
	}
    }

  UNBLOCK_CHILD (oset);

  return (result);
}
warning: parse error {
  register int i;
  int result;
  sigset_t set, oset;

  if (js.j_jobslots == 0)
    return 0;

  BLOCK_CHILD (set, oset);

  /* XXX could use js.j_firstj here */
  for (i = result = 0; i < js.j_jobslots; i++)
    {
#if defined (DEBUG)
      if (i < js.j_firstj && jobs[i])
	itrace("map_over_jobs: job %d non-null before js.j_firstj (%d)", i, js.j_firstj);
      if (i > js.j_lastj && jobs[i])
	itrace("map_over_jobs: job %d non-null after js.j_lastj (%d)", i, js.j_lastj);
#endif
      if (jobs[i])
	{
	  result = (*func)(jobs[i], arg1, arg2, i);
	  if (result)
	    break;
	}
    }

  UNBLOCK_CHILD (oset);

  return (result);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\jobs.c:1,608
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\jobs.c:1,697
parsing error 
{
  PROCESS *p;

  p = pipeline;
  do
    {
      /* Return it if we found it.  Don't ever return a recycled pid. */
      if (p->pid == pid && ((alive_only == 0 && PRECYCLED(p) == 0) || PALIVE(p)))
	return (p);

      p = p->next;
    }
  while (p != pipeline);
  return ((PROCESS *)NULL);
}
warning: parse error {
  PROCESS *p;

  p = pipeline;
  do
    {
      /* Return it if we found it.  Don't ever return a recycled pid. */
      if (p->pid == pid && ((alive_only == 0 && PRECYCLED(p) == 0) || PALIVE(p)))
	return (p);

      p = p->next;
    }
  while (p != pipeline);
  return ((PROCESS *)NULL);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\jobs.c:1,701
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\jobs.c:1,721
parsing error 
{
  int job;
  PROCESS *p;
  struct pipeline_saver *save;

  /* See if this process is in the pipeline that we are building. */
  p = (PROCESS *)NULL;
  if (jobp)
    *jobp = NO_JOB;

  if (the_pipeline && (p = find_pid_in_pipeline (pid, the_pipeline, alive_only)))
    return (p);

  /* Is this process in a saved pipeline? */
  for (save = saved_pipeline; save; save = save->next)
    if (save->pipeline && (p = find_pid_in_pipeline (pid, save->pipeline, alive_only)))
      return (p);

#if defined (PROCESS_SUBSTITUTION)
  if (procsubs.nproc > 0 && (p = procsub_search (pid)) && ((alive_only == 0 && PRECYCLED(p) == 0) || PALIVE(p)))
    return (p);
#endif

  job = find_job (pid, alive_only, &p);
  if (jobp)
    *jobp = job;
  return (job == NO_JOB) ? (PROCESS *)NULL : jobs[job]->pipe;
}
warning: parse error {
  int job;
  PROCESS *p;
  struct pipeline_saver *save;

  /* See if this process is in the pipeline that we are building. */
  p = (PROCESS *)NULL;
  if (jobp)
    *jobp = NO_JOB;

  if (the_pipeline && (p = find_pid_in_pipeline (pid, the_pipeline, alive_only)))
    return (p);

  /* Is this process in a saved pipeline? */
  for (save = saved_pipeline; save; save = save->next)
    if (save->pipeline && (p = find_pid_in_pipeline (pid, save->pipeline, alive_only)))
      return (p);

#if defined (PROCESS_SUBSTITUTION)
  if (procsubs.nproc > 0 && (p = procsub_search (pid)) && ((alive_only == 0 && PRECYCLED(p) == 0) || PALIVE(p)))
    return (p);
#endif

  job = find_job (pid, alive_only, &p);
  if (jobp)
    *jobp = job;
  return (job == NO_JOB) ? (PROCESS *)NULL : jobs[job]->pipe;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\jobs.c:1,725
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\jobs.c:1,758
parsing error 
{
  PROCESS *p;

  p = find_pipeline (pid, alive_only, jobp);
  while (p && p->pid != pid)
    p = p->next;
  return p;
}
warning: parse error {
  PROCESS *p;

  p = find_pipeline (pid, alive_only, jobp);
  while (p && p->pid != pid)
    p = p->next;
  return p;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\jobs.c:1,762
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\jobs.c:1,774
parsing error 
{
  register int i;
  PROCESS *p;

  /* XXX could use js.j_firstj here, and should check js.j_lastj */
  for (i = 0; i < js.j_jobslots; i++)
    {
#if defined (DEBUG)
      if (i < js.j_firstj && jobs[i])
	itrace("find_job: job %d non-null before js.j_firstj (%d)", i, js.j_firstj);
      if (i > js.j_lastj && jobs[i])
	itrace("find_job: job %d non-null after js.j_lastj (%d)", i, js.j_lastj);
#endif
      if (jobs[i])
	{
	  p = jobs[i]->pipe;

	  do
	    {
	      if (p->pid == pid && ((alive_only == 0 && PRECYCLED(p) == 0) || PALIVE(p)))
		{
		  if (procp)
		    *procp = p;
		  return (i);
		}

	      p = p->next;
	    }
	  while (p != jobs[i]->pipe);
	}
    }

  return (NO_JOB);
}
warning: parse error {
  register int i;
  PROCESS *p;

  /* XXX could use js.j_firstj here, and should check js.j_lastj */
  for (i = 0; i < js.j_jobslots; i++)
    {
#if defined (DEBUG)
      if (i < js.j_firstj && jobs[i])
	itrace("find_job: job %d non-null before js.j_firstj (%d)", i, js.j_firstj);
      if (i > js.j_lastj && jobs[i])
	itrace("find_job: job %d non-null after js.j_lastj (%d)", i, js.j_lastj);
#endif
      if (jobs[i])
	{
	  p = jobs[i]->pipe;

	  do
	    {
	      if (p->pid == pid && ((alive_only == 0 && PRECYCLED(p) == 0) || PALIVE(p)))
		{
		  if (procp)
		    *procp = p;
		  return (i);
		}

	      p = p->next;
	    }
	  while (p != jobs[i]->pipe);
	}
    }

  return (NO_JOB);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\jobs.c:1,778
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\jobs.c:1,816
parsing error 
{
  int job;
  sigset_t set, oset;

  if (block)
    BLOCK_CHILD (set, oset);

  job = find_job (pid, 0, procp);

  if (block)
    UNBLOCK_CHILD (oset);

  return job;
}
warning: parse error {
  int job;
  sigset_t set, oset;

  if (block)
    BLOCK_CHILD (set, oset);

  job = find_job (pid, 0, procp);

  if (block)
    UNBLOCK_CHILD (oset);

  return job;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\jobs.c:1,820
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\jobs.c:1,837
parsing error 
{
  int job;
  sigset_t set, oset;

  BLOCK_CHILD (set, oset);

  job = find_job (pid, 0, NULL);

  if (job != NO_JOB)
    fprintf (stderr, "[%d] %ld\n", job + 1, (long)pid);
  else
    programming_error (_("describe_pid: %ld: no such pid"), (long)pid);

  UNBLOCK_CHILD (oset);
}
warning: parse error {
  int job;
  sigset_t set, oset;

  BLOCK_CHILD (set, oset);

  job = find_job (pid, 0, NULL);

  if (job != NO_JOB)
    fprintf (stderr, "[%d] %ld\n", job + 1, (long)pid);
  else
    programming_error (_("describe_pid: %ld: no such pid"), (long)pid);

  UNBLOCK_CHILD (oset);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\jobs.c:1,839
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\jobs.c:1,856
parsing error 
{
  char *x;

  x = strsignal (s);
  if (x == 0)
    {
      x = retcode_name_buffer;
      snprintf (x, sizeof(retcode_name_buffer), _("Signal %d"), s);
    }
  return x;
}
warning: parse error {
  char *x;

  x = strsignal (s);
  if (x == 0)
    {
      x = retcode_name_buffer;
      snprintf (x, sizeof(retcode_name_buffer), _("Signal %d"), s);
    }
  return x;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\jobs.c:1,858
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\jobs.c:1,871
parsing error 
{
  static char *temp;
  int es;

  temp = _("Done");

  if (STOPPED (j) && format == 0)
    {
      if (posixly_correct == 0 || p == 0 || (WIFSTOPPED (p->status) == 0))
	temp = _("Stopped");
      else
	{
	  temp = retcode_name_buffer;
	  snprintf (temp, sizeof(retcode_name_buffer), _("Stopped(%s)"), signal_name (WSTOPSIG (p->status)));
	}
    }
  else if (RUNNING (j))
    temp = _("Running");
  else
    {
      if (WIFSTOPPED (p->status))
	temp = j_strsignal (WSTOPSIG (p->status));
      else if (WIFSIGNALED (p->status))
	temp = j_strsignal (WTERMSIG (p->status));
      else if (WIFEXITED (p->status))
	{
	  temp = retcode_name_buffer;
	  es = WEXITSTATUS (p->status);
	  if (es == 0)
	    {
	      strncpy (temp, _("Done"), sizeof (retcode_name_buffer) - 1);
	      temp[sizeof (retcode_name_buffer) - 1] = '\0';
	    }
	  else if (posixly_correct)
	    snprintf (temp, sizeof(retcode_name_buffer), _("Done(%d)"), es);
	  else
	    snprintf (temp, sizeof(retcode_name_buffer), _("Exit %d"), es);
	}
      else
	temp = _("Unknown status");
    }

  return temp;
}
warning: parse error {
  static char *temp;
  int es;

  temp = _("Done");

  if (STOPPED (j) && format == 0)
    {
      if (posixly_correct == 0 || p == 0 || (WIFSTOPPED (p->status) == 0))
	temp = _("Stopped");
      else
	{
	  temp = retcode_name_buffer;
	  snprintf (temp, sizeof(retcode_name_buffer), _("Stopped(%s)"), signal_name (WSTOPSIG (p->status)));
	}
    }
  else if (RUNNING (j))
    temp = _("Running");
  else
    {
      if (WIFSTOPPED (p->status))
	temp = j_strsignal (WSTOPSIG (p->status));
      else if (WIFSIGNALED (p->status))
	temp = j_strsignal (WTERMSIG (p->status));
      else if (WIFEXITED (p->status))
	{
	  temp = retcode_name_buffer;
	  es = WEXITSTATUS (p->status);
	  if (es == 0)
	    {
	      strncpy (temp, _("Done"), sizeof (retcode_name_buffer) - 1);
	      temp[sizeof (retcode_name_buffer) - 1] = '\0';
	    }
	  else if (posixly_correct)
	    snprintf (temp, sizeof(retcode_name_buffer), _("Done(%d)"), es);
	  else
	    snprintf (temp, sizeof(retcode_name_buffer), _("Exit %d"), es);
	}
      else
	temp = _("Unknown status");
    }

  return temp;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\jobs.c:1,875
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\jobs.c:1,944
parsing error 
{
  PROCESS *first, *last, *show;
  int es, name_padding;
  char *temp;

  if (p == 0)
    return;

  first = last = p;
  while (last->next != first)
    last = last->next;

  for (;;)
    {
      if (p != first)
	fprintf (stream, format ? "     " : " |");

      if (format != JLIST_STANDARD)
	fprintf (stream, "%5ld", (long)p->pid);

      fprintf (stream, " ");

      if (format > -1 && job_index >= 0)
	{
	  show = format ? p : last;
	  temp = printable_job_status (job_index, show, format);

	  if (p != first)
	    {
	      if (format)
		{
		  if (show->running == first->running &&
		      WSTATUS (show->status) == WSTATUS (first->status))
		    temp = "";
		}
	      else
		temp = (char *)NULL;
	    }

	  if (temp)
	    {
	      fprintf (stream, "%s", temp);

	      es = STRLEN (temp);
	      if (es == 0)
		es = 2;	/* strlen ("| ") */
	      name_padding = LONGEST_SIGNAL_DESC - es;

	      fprintf (stream, "%*s", name_padding, "");

	      if ((WIFSTOPPED (show->status) == 0) &&
		  (WIFCONTINUED (show->status) == 0) &&
		  WIFCORED (show->status))
		fprintf (stream, _("(core dumped) "));
	    }
	}

      if (p != first && format)
	fprintf (stream, "| ");

      if (p->command)
	fprintf (stream, "%s", p->command);

      if (p == last && job_index >= 0)
	{
	  temp = current_working_directory ();

	  if (RUNNING (job_index) && (IS_FOREGROUND (job_index) == 0))
	    fprintf (stream, " &");

	  if (strcmp (temp, jobs[job_index]->wd) != 0)
	    fprintf (stream,
	      _("  (wd: %s)"), polite_directory_format (jobs[job_index]->wd));
	}

      if (format || (p == last))
	{
	  /* We need to add a CR only if this is an interactive shell, and
	     we're reporting the status of a completed job asynchronously.
	     We can't really check whether this particular job is being
	     reported asynchronously, so just add the CR if the shell is
	     currently interactive and asynchronous notification is enabled. */
	  if (asynchronous_notification && interactive)
	    putc ('\r', stream);
	  fprintf (stream, "\n");
	}

      if (p == last)
	break;
      p = p->next;
    }
  fflush (stream);
}
warning: parse error {
  PROCESS *first, *last, *show;
  int es, name_padding;
  char *temp;

  if (p == 0)
    return;

  first = last = p;
  while (last->next != first)
    last = last->next;

  for (;;)
    {
      if (p != first)
	fprintf (stream, format ? "     " : " |");

      if (format != JLIST_STANDARD)
	fprintf (stream, "%5ld", (long)p->pid);

      fprintf (stream, " ");

      if (format > -1 && job_index >= 0)
	{
	  show = format ? p : last;
	  temp = printable_job_status (job_index, show, format);

	  if (p != first)
	    {
	      if (format)
		{
		  if (show->running == first->running &&
		      WSTATUS (show->status) == WSTATUS (first->status))
		    temp = "";
		}
	      else
		temp = (char *)NULL;
	    }

	  if (temp)
	    {
	      fprintf (stream, "%s", temp);

	      es = STRLEN (temp);
	      if (es == 0)
		es = 2;	/* strlen ("| ") */
	      name_padding = LONGEST_SIGNAL_DESC - es;

	      fprintf (stream, "%*s", name_padding, "");

	      if ((WIFSTOPPED (show->status) == 0) &&
		  (WIFCONTINUED (show->status) == 0) &&
		  WIFCORED (show->status))
		fprintf (stream, _("(core dumped) "));
	    }
	}

      if (p != first && format)
	fprintf (stream, "| ");

      if (p->command)
	fprintf (stream, "%s", p->command);

      if (p == last && job_index >= 0)
	{
	  temp = current_working_directory ();

	  if (RUNNING (job_index) && (IS_FOREGROUND (job_index) == 0))
	    fprintf (stream, " &");

	  if (strcmp (temp, jobs[job_index]->wd) != 0)
	    fprintf (stream,
	      _("  (wd: %s)"), polite_directory_format (jobs[job_index]->wd));
	}

      if (format || (p == last))
	{
	  /* We need to add a CR only if this is an interactive shell, and
	     we're reporting the status of a completed job asynchronously.
	     We can't really check whether this particular job is being
	     reported asynchronously, so just add the CR if the shell is
	     currently interactive and asynchronous notification is enabled. */
	  if (asynchronous_notification && interactive)
	    putc ('\r', stream);
	  fprintf (stream, "\n");
	}

      if (p == last)
	break;
      p = p->next;
    }
  fflush (stream);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\jobs.c:1,948
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\jobs.c:2,045
parsing error 
{
  register PROCESS *p;

  /* Format only pid information about the process group leader? */
  if (format == JLIST_PID_ONLY)
    {
      fprintf (stream, "%ld\n", (long)jobs[job_index]->pipe->pid);
      return;
    }

  if (format == JLIST_CHANGED_ONLY)
    {
      if (IS_NOTIFIED (job_index))
	return;
      format = JLIST_STANDARD;
    }

  if (format != JLIST_NONINTERACTIVE)
    fprintf (stream, "[%d]%c ", job_index + 1,
	      (job_index == js.j_current) ? '+':
		(job_index == js.j_previous) ? '-' : ' ');

  if (format == JLIST_NONINTERACTIVE)
    format = JLIST_LONG;

  p = jobs[job_index]->pipe;

  print_pipeline (p, job_index, format, stream);

  /* We have printed information about this job.  When the job's
     status changes, waitchld () sets the notification flag to 0. */
  jobs[job_index]->flags |= J_NOTIFIED;
}
warning: parse error {
  register PROCESS *p;

  /* Format only pid information about the process group leader? */
  if (format == JLIST_PID_ONLY)
    {
      fprintf (stream, "%ld\n", (long)jobs[job_index]->pipe->pid);
      return;
    }

  if (format == JLIST_CHANGED_ONLY)
    {
      if (IS_NOTIFIED (job_index))
	return;
      format = JLIST_STANDARD;
    }

  if (format != JLIST_NONINTERACTIVE)
    fprintf (stream, "[%d]%c ", job_index + 1,
	      (job_index == js.j_current) ? '+':
		(job_index == js.j_previous) ? '-' : ' ');

  if (format == JLIST_NONINTERACTIVE)
    format = JLIST_LONG;

  p = jobs[job_index]->pipe;

  print_pipeline (p, job_index, format, stream);

  /* We have printed information about this job.  When the job's
     status changes, waitchld () sets the notification flag to 0. */
  jobs[job_index]->flags |= J_NOTIFIED;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\jobs.c:2,048
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\jobs.c:2,083
parsing error 
{
  if (state == -1 || (JOB_STATE)state == job->state)
    pretty_print_job (job_index, format, stdout);
  return (0);
}
warning: parse error {
  if (state == -1 || (JOB_STATE)state == job->state)
    pretty_print_job (job_index, format, stdout);
  return (0);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\jobs.c:2,086
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\jobs.c:2,093
parsing error 
{
  pretty_print_job (job_index, format, stdout);
  cleanup_dead_jobs ();
}
warning: parse error {
  pretty_print_job (job_index, format, stdout);
  cleanup_dead_jobs ();
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\jobs.c:2,096
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\jobs.c:2,102
parsing error 
{
  cleanup_dead_jobs ();
  map_over_jobs (print_job, format, (int)JSTOPPED);
}
warning: parse error {
  cleanup_dead_jobs ();
  map_over_jobs (print_job, format, (int)JSTOPPED);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\jobs.c:2,104
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\jobs.c:2,110
parsing error 
{
  cleanup_dead_jobs ();
  map_over_jobs (print_job, format, (int)JRUNNING);
}
warning: parse error {
  cleanup_dead_jobs ();
  map_over_jobs (print_job, format, (int)JRUNNING);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\jobs.c:2,112
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\jobs.c:2,120
parsing error 
{
  cleanup_dead_jobs ();
  map_over_jobs (print_job, format, -1);
}
warning: parse error {
  cleanup_dead_jobs ();
  map_over_jobs (print_job, format, -1);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\jobs.c:2,122
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\jobs.c:2,132
parsing error 
{
  int async_p, forksleep;
  sigset_t set, oset, termset, chldset, oset_copy;
  pid_t pid;
  SigHandler *oterm;

  sigemptyset (&oset_copy);
  sigprocmask (SIG_BLOCK, (sigset_t *)NULL, &oset_copy);
  sigaddset (&oset_copy, SIGTERM);

  /* Block SIGTERM here and unblock in child after fork resets the
     set of pending signals. */
  sigemptyset (&set);
  sigaddset (&set, SIGCHLD);
  sigaddset (&set, SIGINT);
  sigaddset (&set, SIGTERM);

  sigemptyset (&oset);
  sigprocmask (SIG_BLOCK, &set, &oset);

  /* Blocked in the parent, child will receive it after unblocking SIGTERM */
  if (interactive_shell)
    oterm = set_signal_handler (SIGTERM, SIG_DFL);

  making_children ();

  async_p = (flags & FORK_ASYNC);
  forksleep = 1;

#if defined (BUFFERED_INPUT)
  /* If default_buffered_input is active, we are reading a script.  If
     the command is asynchronous, we have already duplicated /dev/null
     as fd 0, but have not changed the buffered stream corresponding to
     the old fd 0.  We don't want to sync the stream in this case. */
  if (default_buffered_input != -1 &&
      (!async_p || default_buffered_input > 0))
    sync_buffered_stream (default_buffered_input);
#endif /* BUFFERED_INPUT */

  /* Create the child, handle severe errors.  Retry on EAGAIN. */
  while ((pid = fork ()) < 0 && errno == EAGAIN && forksleep < FORKSLEEP_MAX)
    {
      /* bash-4.2 */
      /* keep SIGTERM blocked until we reset the handler to SIG_IGN */
      sigprocmask (SIG_SETMASK, &oset_copy, (sigset_t *)NULL);
      /* If we can't create any children, try to reap some dead ones. */
      waitchld (-1, 0);

      errno = EAGAIN;		/* restore errno */
      sys_error ("fork: retry");

      if (sleep (forksleep) != 0)
	break;
      forksleep <<= 1;

      if (interrupt_state)
	break;
      sigprocmask (SIG_SETMASK, &set, (sigset_t *)NULL);
    }

  if (pid != 0)
    if (interactive_shell)
      set_signal_handler (SIGTERM, oterm);

  if (pid < 0)
    {
      sys_error ("fork");

      /* Kill all of the processes in the current pipeline. */
      terminate_current_pipeline ();

      /* Discard the current pipeline, if any. */
      if (the_pipeline)
	kill_current_pipeline ();

      set_exit_status (EX_NOEXEC);
      throw_to_top_level ();	/* Reset signals, etc. */
    }

  if (pid == 0)
    {
      /* In the child.  Give this child the right process group, set the
	 signals to the default state for a new process. */
      pid_t mypid;

      /* If this ends up being changed to modify or use `command' in the
	 child process, go back and change callers who free `command' in
	 the child process when this returns. */
      mypid = getpid ();
#if defined (BUFFERED_INPUT)
      /* Close default_buffered_input if it's > 0.  We don't close it if it's
	 0 because that's the file descriptor used when redirecting input,
	 and it's wrong to close the file in that case. */
      unset_bash_input (0);
#endif /* BUFFERED_INPUT */

      CLRINTERRUPT;	/* XXX - children have their own interrupt state */

      /* Restore top-level signal mask, including unblocking SIGTERM */
      restore_sigmask ();
  
      if (job_control)
	{
	  /* All processes in this pipeline belong in the same
	     process group. */

	  if (pipeline_pgrp == 0)	/* This is the first child. */
	    pipeline_pgrp = mypid;

	  /* Check for running command in backquotes. */
	  if (pipeline_pgrp == shell_pgrp)
	    ignore_tty_job_signals ();
	  else
	    default_tty_job_signals ();

	  /* Set the process group before trying to mess with the terminal's
	     process group.  This is mandated by POSIX. */
	  /* This is in accordance with the Posix 1003.1 standard,
	     section B.7.2.4, which says that trying to set the terminal
	     process group with tcsetpgrp() to an unused pgrp value (like
	     this would have for the first child) is an error.  Section
	     B.4.3.3, p. 237 also covers this, in the context of job control
	     shells. */
	  if (setpgid (mypid, pipeline_pgrp) < 0)
	    sys_error (_("child setpgid (%ld to %ld)"), (long)mypid, (long)pipeline_pgrp);

	  /* By convention (and assumption above), if
	     pipeline_pgrp == shell_pgrp, we are making a child for
	     command substitution.
	     In this case, we don't want to give the terminal to the
	     shell's process group (we could be in the middle of a
	     pipeline, for example). */
	  if ((flags & FORK_NOTERM) == 0 && async_p == 0 && pipeline_pgrp != shell_pgrp && ((subshell_environment&(SUBSHELL_ASYNC|SUBSHELL_PIPE)) == 0) && running_in_background == 0)
	    give_terminal_to (pipeline_pgrp, 0);

#if defined (PGRP_PIPE)
	  if (pipeline_pgrp == mypid)
	    pipe_read (pgrp_pipe);
#endif
	}
      else			/* Without job control... */
	{
	  if (pipeline_pgrp == 0)
	    pipeline_pgrp = shell_pgrp;

	  /* If these signals are set to SIG_DFL, we encounter the curious
	     situation of an interactive ^Z to a running process *working*
	     and stopping the process, but being unable to do anything with
	     that process to change its state.  On the other hand, if they
	     are set to SIG_IGN, jobs started from scripts do not stop when
	     the shell running the script gets a SIGTSTP and stops. */

	  default_tty_job_signals ();
	}

#if defined (PGRP_PIPE)
      /* Release the process group pipe, since our call to setpgid ()
	 is done.  The last call to sh_closepipe is done in stop_pipeline. */
      sh_closepipe (pgrp_pipe);
#endif /* PGRP_PIPE */

      /* Don't set last_asynchronous_pid in the child */

#if defined (RECYCLES_PIDS)
      if (last_asynchronous_pid == mypid)
	/* Avoid pid aliasing.  1 seems like a safe, unusual pid value. */
	last_asynchronous_pid = 1;
#endif
    }
  else
    {
      /* In the parent.  Remember the pid of the child just created
	 as the proper pgrp if this is the first child. */

      if (job_control)
	{
	  if (pipeline_pgrp == 0)
	    {
	      pipeline_pgrp = pid;
	      /* Don't twiddle terminal pgrps in the parent!  This is the bug,
		 not the good thing of twiddling them in the child! */
	      /* give_terminal_to (pipeline_pgrp, 0); */
	    }
	  /* This is done on the recommendation of the Rationale section of
	     the POSIX 1003.1 standard, where it discusses job control and
	     shells.  It is done to avoid possible race conditions. (Ref.
	     1003.1 Rationale, section B.4.3.3, page 236). */
	  setpgid (pid, pipeline_pgrp);
	}
      else
	{
	  if (pipeline_pgrp == 0)
	    pipeline_pgrp = shell_pgrp;
	}

      /* Place all processes into the jobs array regardless of the
	 state of job_control. */
      add_process (command, pid);

      if (async_p)
	last_asynchronous_pid = pid;
#if defined (RECYCLES_PIDS)
      else if (last_asynchronous_pid == pid)
	/* Avoid pid aliasing.  1 seems like a safe, unusual pid value. */
	last_asynchronous_pid = 1;
#endif

      /* Delete the saved status for any job containing this PID in case it's
	 been reused. */
      delete_old_job (pid);

      /* Perform the check for pid reuse unconditionally.  Some systems reuse
	 PIDs before giving a process CHILD_MAX/_SC_CHILD_MAX unique ones. */
      bgp_delete (pid);		/* new process, discard any saved status */

      last_made_pid = pid;

      /* keep stats */
      js.c_totforked++;
      js.c_living++;

      /* Unblock SIGTERM, SIGINT, and SIGCHLD unless creating a pipeline, in
	 which case SIGCHLD remains blocked until all commands in the pipeline
	 have been created (execute_cmd.c:execute_pipeline()). */
      sigprocmask (SIG_SETMASK, &oset, (sigset_t *)NULL);
    }

  return (pid);
}
warning: parse error {
  int async_p, forksleep;
  sigset_t set, oset, termset, chldset, oset_copy;
  pid_t pid;
  SigHandler *oterm;

  sigemptyset (&oset_copy);
  sigprocmask (SIG_BLOCK, (sigset_t *)NULL, &oset_copy);
  sigaddset (&oset_copy, SIGTERM);

  /* Block SIGTERM here and unblock in child after fork resets the
     set of pending signals. */
  sigemptyset (&set);
  sigaddset (&set, SIGCHLD);
  sigaddset (&set, SIGINT);
  sigaddset (&set, SIGTERM);

  sigemptyset (&oset);
  sigprocmask (SIG_BLOCK, &set, &oset);

  /* Blocked in the parent, child will receive it after unblocking SIGTERM */
  if (interactive_shell)
    oterm = set_signal_handler (SIGTERM, SIG_DFL);

  making_children ();

  async_p = (flags & FORK_ASYNC);
  forksleep = 1;

#if defined (BUFFERED_INPUT)
  /* If default_buffered_input is active, we are reading a script.  If
     the command is asynchronous, we have already duplicated /dev/null
     as fd 0, but have not changed the buffered stream corresponding to
     the old fd 0.  We don't want to sync the stream in this case. */
  if (default_buffered_input != -1 &&
      (!async_p || default_buffered_input > 0))
    sync_buffered_stream (default_buffered_input);
#endif /* BUFFERED_INPUT */

  /* Create the child, handle severe errors.  Retry on EAGAIN. */
  while ((pid = fork ()) < 0 && errno == EAGAIN && forksleep < FORKSLEEP_MAX)
    {
      /* bash-4.2 */
      /* keep SIGTERM blocked until we reset the handler to SIG_IGN */
      sigprocmask (SIG_SETMASK, &oset_copy, (sigset_t *)NULL);
      /* If we can't create any children, try to reap some dead ones. */
      waitchld (-1, 0);

      errno = EAGAIN;		/* restore errno */
      sys_error ("fork: retry");

      if (sleep (forksleep) != 0)
	break;
      forksleep <<= 1;

      if (interrupt_state)
	break;
      sigprocmask (SIG_SETMASK, &set, (sigset_t *)NULL);
    }

  if (pid != 0)
    if (interactive_shell)
      set_signal_handler (SIGTERM, oterm);

  if (pid < 0)
    {
      sys_error ("fork");

      /* Kill all of the processes in the current pipeline. */
      terminate_current_pipeline ();

      /* Discard the current pipeline, if any. */
      if (the_pipeline)
	kill_current_pipeline ();

      set_exit_status (EX_NOEXEC);
      throw_to_top_level ();	/* Reset signals, etc. */
    }

  if (pid == 0)
    {
      /* In the child.  Give this child the right process group, set the
	 signals to the default state for a new process. */
      pid_t mypid;

      /* If this ends up being changed to modify or use `command' in the
	 child process, go back and change callers who free `command' in
	 the child process when this returns. */
      mypid = getpid ();
#if defined (BUFFERED_INPUT)
      /* Close default_buffered_input if it's > 0.  We don't close it if it's
	 0 because that's the file descriptor used when redirecting input,
	 and it's wrong to close the file in that case. */
      unset_bash_input (0);
#endif /* BUFFERED_INPUT */

      CLRINTERRUPT;	/* XXX - children have their own interrupt state */

      /* Restore top-level signal mask, including unblocking SIGTERM */
      restore_sigmask ();
  
      if (job_control)
	{
	  /* All processes in this pipeline belong in the same
	     process group. */

	  if (pipeline_pgrp == 0)	/* This is the first child. */
	    pipeline_pgrp = mypid;

	  /* Check for running command in backquotes. */
	  if (pipeline_pgrp == shell_pgrp)
	    ignore_tty_job_signals ();
	  else
	    default_tty_job_signals ();

	  /* Set the process group before trying to mess with the terminal's
	     process group.  This is mandated by POSIX. */
	  /* This is in accordance with the Posix 1003.1 standard,
	     section B.7.2.4, which says that trying to set the terminal
	     process group with tcsetpgrp() to an unused pgrp value (like
	     this would have for the first child) is an error.  Section
	     B.4.3.3, p. 237 also covers this, in the context of job control
	     shells. */
	  if (setpgid (mypid, pipeline_pgrp) < 0)
	    sys_error (_("child setpgid (%ld to %ld)"), (long)mypid, (long)pipeline_pgrp);

	  /* By convention (and assumption above), if
	     pipeline_pgrp == shell_pgrp, we are making a child for
	     command substitution.
	     In this case, we don't want to give the terminal to the
	     shell's process group (we could be in the middle of a
	     pipeline, for example). */
	  if ((flags & FORK_NOTERM) == 0 && async_p == 0 && pipeline_pgrp != shell_pgrp && ((subshell_environment&(SUBSHELL_ASYNC|SUBSHELL_PIPE)) == 0) && running_in_background == 0)
	    give_terminal_to (pipeline_pgrp, 0);

#if defined (PGRP_PIPE)
	  if (pipeline_pgrp == mypid)
	    pipe_read (pgrp_pipe);
#endif
	}
      else			/* Without job control... */
	{
	  if (pipeline_pgrp == 0)
	    pipeline_pgrp = shell_pgrp;

	  /* If these signals are set to SIG_DFL, we encounter the curious
	     situation of an interactive ^Z to a running process *working*
	     and stopping the process, but being unable to do anything with
	     that process to change its state.  On the other hand, if they
	     are set to SIG_IGN, jobs started from scripts do not stop when
	     the shell running the script gets a SIGTSTP and stops. */

	  default_tty_job_signals ();
	}

#if defined (PGRP_PIPE)
      /* Release the process group pipe, since our call to setpgid ()
	 is done.  The last call to sh_closepipe is done in stop_pipeline. */
      sh_closepipe (pgrp_pipe);
#endif /* PGRP_PIPE */

      /* Don't set last_asynchronous_pid in the child */

#if defined (RECYCLES_PIDS)
      if (last_asynchronous_pid == mypid)
	/* Avoid pid aliasing.  1 seems like a safe, unusual pid value. */
	last_asynchronous_pid = 1;
#endif
    }
  else
    {
      /* In the parent.  Remember the pid of the child just created
	 as the proper pgrp if this is the first child. */

      if (job_control)
	{
	  if (pipeline_pgrp == 0)
	    {
	      pipeline_pgrp = pid;
	      /* Don't twiddle terminal pgrps in the parent!  This is the bug,
		 not the good thing of twiddling them in the child! */
	      /* give_terminal_to (pipeline_pgrp, 0); */
	    }
	  /* This is done on the recommendation of the Rationale section of
	     the POSIX 1003.1 standard, where it discusses job control and
	     shells.  It is done to avoid possible race conditions. (Ref.
	     1003.1 Rationale, section B.4.3.3, page 236). */
	  setpgid (pid, pipeline_pgrp);
	}
      else
	{
	  if (pipeline_pgrp == 0)
	    pipeline_pgrp = shell_pgrp;
	}

      /* Place all processes into the jobs array regardless of the
	 state of job_control. */
      add_process (command, pid);

      if (async_p)
	last_asynchronous_pid = pid;
#if defined (RECYCLES_PIDS)
      else if (last_asynchronous_pid == pid)
	/* Avoid pid aliasing.  1 seems like a safe, unusual pid value. */
	last_asynchronous_pid = 1;
#endif

      /* Delete the saved status for any job containing this PID in case it's
	 been reused. */
      delete_old_job (pid);

      /* Perform the check for pid reuse unconditionally.  Some systems reuse
	 PIDs before giving a process CHILD_MAX/_SC_CHILD_MAX unique ones. */
      bgp_delete (pid);		/* new process, discard any saved status */

      last_made_pid = pid;

      /* keep stats */
      js.c_totforked++;
      js.c_living++;

      /* Unblock SIGTERM, SIGINT, and SIGCHLD unless creating a pipeline, in
	 which case SIGCHLD remains blocked until all commands in the pipeline
	 have been created (execute_cmd.c:execute_pipeline()). */
      sigprocmask (SIG_SETMASK, &oset, (sigset_t *)NULL);
    }

  return (pid);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\jobs.c:2,135
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\jobs.c:2,555
parsing error 
{
  register PROCESS *p;
  sigset_t set, oset;

  if (block)
    BLOCK_CHILD (set, oset);

  p = jobs[job]->pipe;
  while (p && p->next != jobs[job]->pipe)
    p = p->next;

  if (block)
    UNBLOCK_CHILD (oset);

  return (p);
}
warning: parse error {
  register PROCESS *p;
  sigset_t set, oset;

  if (block)
    BLOCK_CHILD (set, oset);

  p = jobs[job]->pipe;
  while (p && p->next != jobs[job]->pipe)
    p = p->next;

  if (block)
    UNBLOCK_CHILD (oset);

  return (p);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\jobs.c:2,558
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\jobs.c:2,576
parsing error 
{
  PROCESS *p;

  p = find_last_proc (job, block);
  /* Possible race condition here. */
  return p->pid;
}
warning: parse error {
  PROCESS *p;

  p = find_last_proc (job, block);
  /* Possible race condition here. */
  return p->pid;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\jobs.c:2,579
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\jobs.c:2,595
parsing error 
{
  register PROCESS *child;
  sigset_t set, oset;
  int r, job, alive;

  BLOCK_CHILD (set, oset);
  child = find_pipeline (pid, 0, (int *)NULL);
  UNBLOCK_CHILD (oset);

  if (child == 0)
    {
      r = bgp_search (pid);
      if (r >= 0)
	return r;
    }

  if (child == 0)
    {
      if (flags & JWAIT_PERROR)
	internal_error (_("wait: pid %ld is not a child of this shell"), (long)pid);
      return (127);
    }

  alive = 0;
  do
    {
      r = wait_for (pid, 0);
      if ((flags & JWAIT_FORCE) == 0)
	break;

      BLOCK_CHILD (set, oset);
      alive = PALIVE (child);
      UNBLOCK_CHILD (oset);
    }
  while (alive);

  /* POSIX.2: if we just waited for a job, we can remove it from the jobs
     table. */
  BLOCK_CHILD (set, oset);
  job = find_job (pid, 0, NULL);
  if (job != NO_JOB && jobs[job] && DEADJOB (job))
    jobs[job]->flags |= J_NOTIFIED;
  UNBLOCK_CHILD (oset);

  /* If running in posix mode, remove the job from the jobs table immediately */
  if (posixly_correct)
    {
      cleanup_dead_jobs ();
      bgp_delete (pid);
    }

  /* Check for a trapped signal interrupting the wait builtin and jump out */
  CHECK_WAIT_INTR;

  return r;
}
warning: parse error {
  register PROCESS *child;
  sigset_t set, oset;
  int r, job, alive;

  BLOCK_CHILD (set, oset);
  child = find_pipeline (pid, 0, (int *)NULL);
  UNBLOCK_CHILD (oset);

  if (child == 0)
    {
      r = bgp_search (pid);
      if (r >= 0)
	return r;
    }

  if (child == 0)
    {
      if (flags & JWAIT_PERROR)
	internal_error (_("wait: pid %ld is not a child of this shell"), (long)pid);
      return (127);
    }

  alive = 0;
  do
    {
      r = wait_for (pid, 0);
      if ((flags & JWAIT_FORCE) == 0)
	break;

      BLOCK_CHILD (set, oset);
      alive = PALIVE (child);
      UNBLOCK_CHILD (oset);
    }
  while (alive);

  /* POSIX.2: if we just waited for a job, we can remove it from the jobs
     table. */
  BLOCK_CHILD (set, oset);
  job = find_job (pid, 0, NULL);
  if (job != NO_JOB && jobs[job] && DEADJOB (job))
    jobs[job]->flags |= J_NOTIFIED;
  UNBLOCK_CHILD (oset);

  /* If running in posix mode, remove the job from the jobs table immediately */
  if (posixly_correct)
    {
      cleanup_dead_jobs ();
      bgp_delete (pid);
    }

  /* Check for a trapped signal interrupting the wait builtin and jump out */
  CHECK_WAIT_INTR;

  return r;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\jobs.c:2,598
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\jobs.c:2,657
parsing error 
{
  register int i, r;
  int any_stopped, check_async;
  sigset_t set, oset;
  pid_t pid;

  for (any_stopped = 0, check_async = 1;;)
    {
      BLOCK_CHILD (set, oset);

      /* find first running job; if none running in foreground, break */
      /* XXX could use js.j_firstj and js.j_lastj here */
      for (i = 0; i < js.j_jobslots; i++)
	{
#if defined (DEBUG)
	  if (i < js.j_firstj && jobs[i])
	    itrace("wait_for_background_pids: job %d non-null before js.j_firstj (%d)", i, js.j_firstj);
	  if (i > js.j_lastj && jobs[i])
	    itrace("wait_for_background_pids: job %d non-null after js.j_lastj (%d)", i, js.j_lastj);
#endif
	  if (jobs[i] && STOPPED (i))
	    {
	      builtin_warning ("job %d[%d] stopped", i+1, find_last_pid (i, 0));
	      any_stopped = 1;
	    }

	  if (jobs[i] && RUNNING (i) && IS_FOREGROUND (i) == 0)
	    break;
	}
      if (i == js.j_jobslots)
	{
	  UNBLOCK_CHILD (oset);
	  break;
	}

      /* now wait for the last pid in that job. */
      pid = find_last_pid (i, 0);
      UNBLOCK_CHILD (oset);
      QUIT;
      errno = 0;		/* XXX */
      r = wait_for_single_pid (pid, JWAIT_PERROR);
      if (ps)
	{
	  ps->pid = pid;
	  ps->status = (r < 0) ? 127 : r;
	}
      if (r == -1 && errno == ECHILD)
	{
	  /* If we're mistaken about job state, compensate. */
	  check_async = 0;
	  mark_all_jobs_as_dead ();
	}
    }

#if defined (PROCESS_SUBSTITUTION)
  procsub_waitall ();
#endif
      
  /* POSIX.2 says the shell can discard the statuses of all completed jobs if
     `wait' is called with no arguments. */
  mark_dead_jobs_as_notified (1);
  cleanup_dead_jobs ();
  bgp_clear ();
}
warning: parse error {
  register int i, r;
  int any_stopped, check_async;
  sigset_t set, oset;
  pid_t pid;

  for (any_stopped = 0, check_async = 1;;)
    {
      BLOCK_CHILD (set, oset);

      /* find first running job; if none running in foreground, break */
      /* XXX could use js.j_firstj and js.j_lastj here */
      for (i = 0; i < js.j_jobslots; i++)
	{
#if defined (DEBUG)
	  if (i < js.j_firstj && jobs[i])
	    itrace("wait_for_background_pids: job %d non-null before js.j_firstj (%d)", i, js.j_firstj);
	  if (i > js.j_lastj && jobs[i])
	    itrace("wait_for_background_pids: job %d non-null after js.j_lastj (%d)", i, js.j_lastj);
#endif
	  if (jobs[i] && STOPPED (i))
	    {
	      builtin_warning ("job %d[%d] stopped", i+1, find_last_pid (i, 0));
	      any_stopped = 1;
	    }

	  if (jobs[i] && RUNNING (i) && IS_FOREGROUND (i) == 0)
	    break;
	}
      if (i == js.j_jobslots)
	{
	  UNBLOCK_CHILD (oset);
	  break;
	}

      /* now wait for the last pid in that job. */
      pid = find_last_pid (i, 0);
      UNBLOCK_CHILD (oset);
      QUIT;
      errno = 0;		/* XXX */
      r = wait_for_single_pid (pid, JWAIT_PERROR);
      if (ps)
	{
	  ps->pid = pid;
	  ps->status = (r < 0) ? 127 : r;
	}
      if (r == -1 && errno == ECHILD)
	{
	  /* If we're mistaken about job state, compensate. */
	  check_async = 0;
	  mark_all_jobs_as_dead ();
	}
    }

#if defined (PROCESS_SUBSTITUTION)
  procsub_waitall ();
#endif
      
  /* POSIX.2 says the shell can discard the statuses of all completed jobs if
     `wait' is called with no arguments. */
  mark_dead_jobs_as_notified (1);
  cleanup_dead_jobs ();
  bgp_clear ();
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\jobs.c:2,659
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\jobs.c:2,756
parsing error 
{
  SigHandler *sigint_handler;

  if (this_shell_builtin && this_shell_builtin == wait_builtin)
    {
      set_exit_status (128+SIGINT);
      restore_sigint_handler ();
      /* If we got a SIGINT while in `wait', and SIGINT is trapped, do
	 what POSIX.2 says (see builtins/wait.def for more info). */
      if (this_shell_builtin && this_shell_builtin == wait_builtin &&
	  signal_is_trapped (SIGINT) &&
	  ((sigint_handler = trap_to_sighandler (SIGINT)) == trap_handler))
	{
	  trap_handler (SIGINT);	/* set pending_traps[SIGINT] */
	  wait_signal_received = SIGINT;
	  if (wait_intr_flag)
	    sh_longjmp (wait_intr_buf, 1);
	  else
	    /* Let CHECK_WAIT_INTR handle it in wait_for/waitchld */
	    SIGRETURN (0);
	}
      else /* wait_builtin but signal not trapped, treat as interrupt */
	kill (getpid (), SIGINT);
    }

  /* XXX - should this be interrupt_state?  If it is, the shell will act
     as if it got the SIGINT interrupt. */
  if (waiting_for_child)
    wait_sigint_received = 1;
  else
    {
      set_exit_status (128+SIGINT);
      restore_sigint_handler ();
      kill (getpid (), SIGINT);
    }

  /* Otherwise effectively ignore the SIGINT and allow the running job to
     be killed. */
  SIGRETURN (0);
}
warning: parse error {
  SigHandler *sigint_handler;

  if (this_shell_builtin && this_shell_builtin == wait_builtin)
    {
      set_exit_status (128+SIGINT);
      restore_sigint_handler ();
      /* If we got a SIGINT while in `wait', and SIGINT is trapped, do
	 what POSIX.2 says (see builtins/wait.def for more info). */
      if (this_shell_builtin && this_shell_builtin == wait_builtin &&
	  signal_is_trapped (SIGINT) &&
	  ((sigint_handler = trap_to_sighandler (SIGINT)) == trap_handler))
	{
	  trap_handler (SIGINT);	/* set pending_traps[SIGINT] */
	  wait_signal_received = SIGINT;
	  if (wait_intr_flag)
	    sh_longjmp (wait_intr_buf, 1);
	  else
	    /* Let CHECK_WAIT_INTR handle it in wait_for/waitchld */
	    SIGRETURN (0);
	}
      else /* wait_builtin but signal not trapped, treat as interrupt */
	kill (getpid (), SIGINT);
    }

  /* XXX - should this be interrupt_state?  If it is, the shell will act
     as if it got the SIGINT interrupt. */
  if (waiting_for_child)
    wait_sigint_received = 1;
  else
    {
      set_exit_status (128+SIGINT);
      restore_sigint_handler ();
      kill (getpid (), SIGINT);
    }

  /* Otherwise effectively ignore the SIGINT and allow the running job to
     be killed. */
  SIGRETURN (0);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\jobs.c:2,758
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\jobs.c:2,800
parsing error 
{
  return (WIFSIGNALED (status) ? WTERMSIG (status) : 0);
}
warning: parse error {
  return (WIFSIGNALED (status) ? WTERMSIG (status) : 0);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\jobs.c:2,802
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\jobs.c:2,807
parsing error 
{
  if (WIFSIGNALED (status))
    return (128 + WTERMSIG (status));
  else if (WIFSTOPPED (status) == 0)
    return (WEXITSTATUS (status));
  else
    return (EXECUTION_SUCCESS);
}
warning: parse error {
  if (WIFSIGNALED (status))
    return (128 + WTERMSIG (status));
  else if (WIFSTOPPED (status) == 0)
    return (WEXITSTATUS (status));
  else
    return (EXECUTION_SUCCESS);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\jobs.c:2,809
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\jobs.c:2,819
parsing error 
{
  register PROCESS *p;
  WAIT s;

  p = jobs[job]->pipe;
  do
    {
      s = p->status;
      if (WIFSIGNALED(s) || WIFSTOPPED(s))
	break;
      p = p->next;
    }
  while (p != jobs[job]->pipe);

  return s;
}
warning: parse error {
  register PROCESS *p;
  WAIT s;

  p = jobs[job]->pipe;
  do
    {
      s = p->status;
      if (WIFSIGNALED(s) || WIFSTOPPED(s))
	break;
      p = p->next;
    }
  while (p != jobs[job]->pipe);

  return s;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\jobs.c:2,821
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\jobs.c:2,841
parsing error 
{
  register PROCESS *p;
  int fail;
  WAIT ret;

  if (jobs[job]->flags & J_PIPEFAIL)
    {
      fail = 0;
      p = jobs[job]->pipe;
      do
	{
	  if (WSTATUS (p->status) != EXECUTION_SUCCESS)
	    fail = WSTATUS(p->status);
	  p = p->next;
	}
      while (p != jobs[job]->pipe);
      WSTATUS (ret) = fail;
      return ret;
    }

  for (p = jobs[job]->pipe; p->next != jobs[job]->pipe; p = p->next)
    ;
  return (p->status);
}
warning: parse error {
  register PROCESS *p;
  int fail;
  WAIT ret;

  if (jobs[job]->flags & J_PIPEFAIL)
    {
      fail = 0;
      p = jobs[job]->pipe;
      do
	{
	  if (WSTATUS (p->status) != EXECUTION_SUCCESS)
	    fail = WSTATUS(p->status);
	  p = p->next;
	}
      while (p != jobs[job]->pipe);
      WSTATUS (ret) = fail;
      return ret;
    }

  for (p = jobs[job]->pipe; p->next != jobs[job]->pipe; p = p->next)
    ;
  return (p->status);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\jobs.c:2,843
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\jobs.c:2,872
parsing error 
{
  return (process_exit_status (raw_job_exit_status (job)));
}
warning: parse error {
  return (process_exit_status (raw_job_exit_status (job)));
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\jobs.c:2,874
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\jobs.c:2,879
parsing error 
{
  return (process_exit_signal (raw_job_exit_status (job)));
}
warning: parse error {
  return (process_exit_signal (raw_job_exit_status (job)));
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\jobs.c:2,881
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\jobs.c:2,905
parsing error 
{
  int job, termination_state, r;
  WAIT s;
  register PROCESS *child;
  sigset_t set, oset;

  /* In the case that this code is interrupted, and we longjmp () out of it,
     we are relying on the code in throw_to_top_level () to restore the
     top-level signal mask. */
  child = 0;
  BLOCK_CHILD (set, oset);

  /* Ignore interrupts while waiting for a job run without job control
     to finish.  We don't want the shell to exit if an interrupt is
     received, only if one of the jobs run is killed via SIGINT.  If
     job control is not set, the job will be run in the same pgrp as
     the shell, and the shell will see any signals the job gets.  In
     fact, we want this set every time the waiting shell and the waited-
     for process are in the same process group, including command
     substitution. */

  /* This is possibly a race condition -- should it go in stop_pipeline? */
  wait_sigint_received = child_caught_sigint = 0;
  if (job_control == 0 || (subshell_environment&SUBSHELL_COMSUB))
    {
      SigHandler *temp_sigint_handler;

      temp_sigint_handler = set_signal_handler (SIGINT, wait_sigint_handler);
      if (temp_sigint_handler == wait_sigint_handler)
	{
#if defined (DEBUG)
	  internal_warning ("wait_for: recursively setting old_sigint_handler to wait_sigint_handler: running_trap = %d", running_trap);
#endif
	}
      else
	old_sigint_handler = temp_sigint_handler;
      waiting_for_child = 0;
      if (old_sigint_handler == SIG_IGN)
	set_signal_handler (SIGINT, old_sigint_handler);
    }

  termination_state = last_command_exit_value;

  if (interactive && job_control == 0)
    QUIT;
  /* Check for terminating signals and exit the shell if we receive one */
  CHECK_TERMSIG;

  /* Check for a trapped signal interrupting the wait builtin and jump out */
  CHECK_WAIT_INTR;

  /* If we say wait_for (), then we have a record of this child somewhere.
     If it and none of its peers are running, don't call waitchld(). */

  job = NO_JOB;
  do
    {
      if (pid != ANY_PID)
	FIND_CHILD (pid, child);

      /* If this child is part of a job, then we are really waiting for the
	 job to finish.  Otherwise, we are waiting for the child to finish.
	 We check for JDEAD in case the job state has been set by waitchld
	 after receipt of a SIGCHLD. */
      if (job == NO_JOB && pid != ANY_PID)	/* XXX -- && pid != ANY_PID ? */
	job = find_job (pid, 0, NULL);

      /* waitchld() takes care of setting the state of the job.  If the job
	 has already exited before this is called, sigchld_handler will have
	 called waitchld and the state will be set to JDEAD. */

      if (pid == ANY_PID || PRUNNING(child) || (job != NO_JOB && RUNNING (job)))
	{
	  int old_waiting;

	  queue_sigchld = 1;
	  old_waiting = waiting_for_child;
	  waiting_for_child = 1;
	  /* XXX - probably not strictly necessary but we want to catch
	     everything that happened before we switch the behavior of
	     trap_handler to longjmp on a trapped signal (waiting_for_child) */
	  CHECK_WAIT_INTR;
	  r = waitchld (pid, 1);	/* XXX */
	  waiting_for_child = old_waiting;
#if 0
itrace("wait_for: blocking wait for %d returns %d child = %p", (int)pid, r, child);
#endif
	  queue_sigchld = 0;
	  if (r == -1 && errno == ECHILD && this_shell_builtin == wait_builtin)
	    {
	      termination_state = -1;
	      /* XXX - restore sigint handler here */
	      restore_sigint_handler ();
	      goto wait_for_return;
	    }

	  /* If child is marked as running, but waitpid() returns -1/ECHILD,
	     there is something wrong.  Somewhere, wait should have returned
	     that child's pid.  Mark the child as not running and the job,
	     if it exists, as JDEAD. */
	  if (r == -1 && errno == ECHILD)
	    {
	      if (child)
		{
		  child->running = PS_DONE;
		  WSTATUS (child->status) = 0;	/* XXX -- can't find true status */
		}
	      js.c_living = 0;		/* no living child processes */
	      if (job != NO_JOB)
		{
		  jobs[job]->state = JDEAD;
		  js.c_reaped++;
		  js.j_ndead++;
		}
	      if (pid == ANY_PID)
		{
		  termination_state = -1;
		  break;
		}
	    }
	}

      /* If the shell is interactive, and job control is disabled, see
	 if the foreground process has died due to SIGINT and jump out
	 of the wait loop if it has.  waitchld has already restored the
	 old SIGINT signal handler. */
      if (interactive && job_control == 0)
	QUIT;
      /* Check for terminating signals and exit the shell if we receive one */
      CHECK_TERMSIG;

      /* Check for a trapped signal interrupting the wait builtin and jump out */
      CHECK_WAIT_INTR;

      if (pid == ANY_PID)
	{
	  /* XXX - could set child but we don't have a handle on what waitchld
	    reaps.  Leave termination_state alone. */
	  restore_sigint_handler ();
	  goto wait_for_return;
	}
    }
  while (PRUNNING (child) || (job != NO_JOB && RUNNING (job)));

  /* Restore the original SIGINT signal handler before we return. */
  restore_sigint_handler ();

  /* The exit state of the command is either the termination state of the
     child, or the termination state of the job.  If a job, the status
     of the last child in the pipeline is the significant one.  If the command
     or job was terminated by a signal, note that value also. */
  termination_state = (job != NO_JOB) ? job_exit_status (job)
				      : (child ? process_exit_status (child->status) : EXECUTION_SUCCESS);
  last_command_exit_signal = (job != NO_JOB) ? job_exit_signal (job)
					     : (child ? process_exit_signal (child->status) : 0);

  /* XXX */
  if ((job != NO_JOB && JOBSTATE (job) == JSTOPPED) || (child && WIFSTOPPED (child->status)))
    termination_state = 128 + WSTOPSIG (child->status);

  if (job == NO_JOB || IS_JOBCONTROL (job))
    {
      /* XXX - under what circumstances is a job not present in the jobs
	 table (job == NO_JOB)?
	 	1.  command substitution

	 In the case of command substitution, at least, it's probably not
	 the right thing to give the terminal to the shell's process group,
	 even though there is code in subst.c:command_substitute to work
	 around it.

	 Things that don't:
		$PROMPT_COMMAND execution
		process substitution
       */
#if 0
if (job == NO_JOB)
  itrace("wait_for: job == NO_JOB, giving the terminal to shell_pgrp (%ld)", (long)shell_pgrp);
#endif
      /* Don't modify terminal pgrp if we are running in background or a
	 subshell.  Make sure subst.c:command_substitute uses the same
	 conditions to determine whether or not it should undo this and
	 give the terminal to pipeline_pgrp. */
      
      if ((flags & JWAIT_NOTERM) == 0 && running_in_background == 0 &&
	  (subshell_environment & (SUBSHELL_ASYNC|SUBSHELL_PIPE)) == 0)
	give_terminal_to (shell_pgrp, 0);
    }

  /* If the command did not exit cleanly, or the job is just
     being stopped, then reset the tty state back to what it
     was before this command.  Reset the tty state and notify
     the user of the job termination only if the shell is
     interactive.  Clean up any dead jobs in either case. */
  if (job != NO_JOB)
    {
      if (interactive_shell && subshell_environment == 0)
	{
	  /* This used to use `child->status'.  That's wrong, however, for
	     pipelines.  `child' is the first process in the pipeline.  It's
	     likely that the process we want to check for abnormal termination
	     or stopping is the last process in the pipeline, especially if
	     it's long-lived and the first process is short-lived.  Since we
	     know we have a job here, we can check all the processes in this
	     job's pipeline and see if one of them stopped or terminated due
	     to a signal.  We might want to change this later to just check
	     the last process in the pipeline.  If no process exits due to a
	     signal, S is left as the status of the last job in the pipeline. */
	  s = job_signal_status (job);

	  if (WIFSIGNALED (s) || WIFSTOPPED (s))
	    {
	      set_tty_state ();

	      /* If the current job was stopped or killed by a signal, and
		 the user has requested it, get a possibly new window size */
	      if (check_window_size && (job == js.j_current || IS_FOREGROUND (job)))
		get_new_window_size (0, (int *)0, (int *)0);
	    }
	  else
#if defined (READLINE)
	    /* We don't want to do this if we are running a process during
	       programmable completion. */
	    if (RL_ISSTATE (RL_STATE_COMPLETING) == 0)
#endif
	    get_tty_state ();

	  /* If job control is enabled, the job was started with job
	     control, the job was the foreground job, and it was killed
	     by SIGINT, then print a newline to compensate for the kernel
	     printing the ^C without a trailing newline. */
	  if (job_control && IS_JOBCONTROL (job) && IS_FOREGROUND (job) &&
		WIFSIGNALED (s) && WTERMSIG (s) == SIGINT)
	    {
	      /* If SIGINT is not trapped and the shell is in a for, while,
		 or until loop, act as if the shell received SIGINT as
		 well, so the loop can be broken.  This doesn't call the
		 SIGINT signal handler; maybe it should. */
	      if (signal_is_trapped (SIGINT) == 0 && (loop_level || (shell_compatibility_level > 32 && executing_list)))
		ADDINTERRUPT;
	      /* Call any SIGINT trap handler if the shell is running a loop, so
		 the loop can be broken.  This seems more useful and matches the
		 behavior when the shell is running a builtin command in a loop
		 when it is interrupted.  Change ADDINTERRUPT to
		 trap_handler (SIGINT) to run the trap without interrupting the
		 loop. */
	      else if (signal_is_trapped (SIGINT) && loop_level)
		ADDINTERRUPT;
	      /* If an interactive shell with job control enabled is sourcing
		 a file, allow the interrupt to terminate the file sourcing. */
	      else if (interactive_shell && signal_is_trapped (SIGINT) == 0 && sourcelevel)
		ADDINTERRUPT;
	      else
		{
		  putchar ('\n');
		  fflush (stdout);
		}
	    }
	}
      else if ((subshell_environment & (SUBSHELL_COMSUB|SUBSHELL_PIPE)) && wait_sigint_received)
	{
	  /* If waiting for a job in a subshell started to do command
	     substitution or to run a pipeline element that consists of
	     something like a while loop or a for loop, simulate getting
	     and being killed by the SIGINT to pass the status back to our
	     parent. */
	  if (child_caught_sigint == 0 && signal_is_trapped (SIGINT) == 0)
	    {
	      UNBLOCK_CHILD (oset);
	      old_sigint_handler = set_signal_handler (SIGINT, SIG_DFL);
	      if (old_sigint_handler == SIG_IGN)
		restore_sigint_handler ();
	      else
		kill (getpid (), SIGINT);
	    }
	}
      else if (interactive_shell == 0 && subshell_environment == 0 && IS_FOREGROUND (job))
	{
	  s = job_signal_status (job);

	  /* If we are non-interactive, but job control is enabled, and the job
	     died due to SIGINT, pretend we got the SIGINT */
	  if (job_control && IS_JOBCONTROL (job) && WIFSIGNALED (s) && WTERMSIG (s) == SIGINT)
	    {
	      ADDINTERRUPT;	/* For now */
	    }

	  if (check_window_size)
	    get_new_window_size (0, (int *)0, (int *)0);
	}

      /* Moved here from set_job_status_and_cleanup, which is in the SIGCHLD
	 signal handler path */
      if (DEADJOB (job) && IS_FOREGROUND (job) /*&& subshell_environment == 0*/)
	setjstatus (job);

      /* If this job is dead, notify the user of the status.  If the shell
	 is interactive, this will display a message on the terminal.  If
	 the shell is not interactive, make sure we turn on the notify bit
	 so we don't get an unwanted message about the job's termination,
	 and so delete_job really clears the slot in the jobs table. */
      notify_and_cleanup ();
    }

wait_for_return:

  UNBLOCK_CHILD (oset);

  return (termination_state);
}
warning: parse error {
  int job, termination_state, r;
  WAIT s;
  register PROCESS *child;
  sigset_t set, oset;

  /* In the case that this code is interrupted, and we longjmp () out of it,
     we are relying on the code in throw_to_top_level () to restore the
     top-level signal mask. */
  child = 0;
  BLOCK_CHILD (set, oset);

  /* Ignore interrupts while waiting for a job run without job control
     to finish.  We don't want the shell to exit if an interrupt is
     received, only if one of the jobs run is killed via SIGINT.  If
     job control is not set, the job will be run in the same pgrp as
     the shell, and the shell will see any signals the job gets.  In
     fact, we want this set every time the waiting shell and the waited-
     for process are in the same process group, including command
     substitution. */

  /* This is possibly a race condition -- should it go in stop_pipeline? */
  wait_sigint_received = child_caught_sigint = 0;
  if (job_control == 0 || (subshell_environment&SUBSHELL_COMSUB))
    {
      SigHandler *temp_sigint_handler;

      temp_sigint_handler = set_signal_handler (SIGINT, wait_sigint_handler);
      if (temp_sigint_handler == wait_sigint_handler)
	{
#if defined (DEBUG)
	  internal_warning ("wait_for: recursively setting old_sigint_handler to wait_sigint_handler: running_trap = %d", running_trap);
#endif
	}
      else
	old_sigint_handler = temp_sigint_handler;
      waiting_for_child = 0;
      if (old_sigint_handler == SIG_IGN)
	set_signal_handler (SIGINT, old_sigint_handler);
    }

  termination_state = last_command_exit_value;

  if (interactive && job_control == 0)
    QUIT;
  /* Check for terminating signals and exit the shell if we receive one */
  CHECK_TERMSIG;

  /* Check for a trapped signal interrupting the wait builtin and jump out */
  CHECK_WAIT_INTR;

  /* If we say wait_for (), then we have a record of this child somewhere.
     If it and none of its peers are running, don't call waitchld(). */

  job = NO_JOB;
  do
    {
      if (pid != ANY_PID)
	FIND_CHILD (pid, child);

      /* If this child is part of a job, then we are really waiting for the
	 job to finish.  Otherwise, we are waiting for the child to finish.
	 We check for JDEAD in case the job state has been set by waitchld
	 after receipt of a SIGCHLD. */
      if (job == NO_JOB && pid != ANY_PID)	/* XXX -- && pid != ANY_PID ? */
	job = find_job (pid, 0, NULL);

      /* waitchld() takes care of setting the state of the job.  If the job
	 has already exited before this is called, sigchld_handler will have
	 called waitchld and the state will be set to JDEAD. */

      if (pid == ANY_PID || PRUNNING(child) || (job != NO_JOB && RUNNING (job)))
	{
	  int old_waiting;

	  queue_sigchld = 1;
	  old_waiting = waiting_for_child;
	  waiting_for_child = 1;
	  /* XXX - probably not strictly necessary but we want to catch
	     everything that happened before we switch the behavior of
	     trap_handler to longjmp on a trapped signal (waiting_for_child) */
	  CHECK_WAIT_INTR;
	  r = waitchld (pid, 1);	/* XXX */
	  waiting_for_child = old_waiting;
#if 0
itrace("wait_for: blocking wait for %d returns %d child = %p", (int)pid, r, child);
#endif
	  queue_sigchld = 0;
	  if (r == -1 && errno == ECHILD && this_shell_builtin == wait_builtin)
	    {
	      termination_state = -1;
	      /* XXX - restore sigint handler here */
	      restore_sigint_handler ();
	      goto wait_for_return;
	    }

	  /* If child is marked as running, but waitpid() returns -1/ECHILD,
	     there is something wrong.  Somewhere, wait should have returned
	     that child's pid.  Mark the child as not running and the job,
	     if it exists, as JDEAD. */
	  if (r == -1 && errno == ECHILD)
	    {
	      if (child)
		{
		  child->running = PS_DONE;
		  WSTATUS (child->status) = 0;	/* XXX -- can't find true status */
		}
	      js.c_living = 0;		/* no living child processes */
	      if (job != NO_JOB)
		{
		  jobs[job]->state = JDEAD;
		  js.c_reaped++;
		  js.j_ndead++;
		}
	      if (pid == ANY_PID)
		{
		  termination_state = -1;
		  break;
		}
	    }
	}

      /* If the shell is interactive, and job control is disabled, see
	 if the foreground process has died due to SIGINT and jump out
	 of the wait loop if it has.  waitchld has already restored the
	 old SIGINT signal handler. */
      if (interactive && job_control == 0)
	QUIT;
      /* Check for terminating signals and exit the shell if we receive one */
      CHECK_TERMSIG;

      /* Check for a trapped signal interrupting the wait builtin and jump out */
      CHECK_WAIT_INTR;

      if (pid == ANY_PID)
	{
	  /* XXX - could set child but we don't have a handle on what waitchld
	    reaps.  Leave termination_state alone. */
	  restore_sigint_handler ();
	  goto wait_for_return;
	}
    }
  while (PRUNNING (child) || (job != NO_JOB && RUNNING (job)));

  /* Restore the original SIGINT signal handler before we return. */
  restore_sigint_handler ();

  /* The exit state of the command is either the termination state of the
     child, or the termination state of the job.  If a job, the status
     of the last child in the pipeline is the significant one.  If the command
     or job was terminated by a signal, note that value also. */
  termination_state = (job != NO_JOB) ? job_exit_status (job)
				      : (child ? process_exit_status (child->status) : EXECUTION_SUCCESS);
  last_command_exit_signal = (job != NO_JOB) ? job_exit_signal (job)
					     : (child ? process_exit_signal (child->status) : 0);

  /* XXX */
  if ((job != NO_JOB && JOBSTATE (job) == JSTOPPED) || (child && WIFSTOPPED (child->status)))
    termination_state = 128 + WSTOPSIG (child->status);

  if (job == NO_JOB || IS_JOBCONTROL (job))
    {
      /* XXX - under what circumstances is a job not present in the jobs
	 table (job == NO_JOB)?
	 	1.  command substitution

	 In the case of command substitution, at least, it's probably not
	 the right thing to give the terminal to the shell's process group,
	 even though there is code in subst.c:command_substitute to work
	 around it.

	 Things that don't:
		$PROMPT_COMMAND execution
		process substitution
       */
#if 0
if (job == NO_JOB)
  itrace("wait_for: job == NO_JOB, giving the terminal to shell_pgrp (%ld)", (long)shell_pgrp);
#endif
      /* Don't modify terminal pgrp if we are running in background or a
	 subshell.  Make sure subst.c:command_substitute uses the same
	 conditions to determine whether or not it should undo this and
	 give the terminal to pipeline_pgrp. */
      
      if ((flags & JWAIT_NOTERM) == 0 && running_in_background == 0 &&
	  (subshell_environment & (SUBSHELL_ASYNC|SUBSHELL_PIPE)) == 0)
	give_terminal_to (shell_pgrp, 0);
    }

  /* If the command did not exit cleanly, or the job is just
     being stopped, then reset the tty state back to what it
     was before this command.  Reset the tty state and notify
     the user of the job termination only if the shell is
     interactive.  Clean up any dead jobs in either case. */
  if (job != NO_JOB)
    {
      if (interactive_shell && subshell_environment == 0)
	{
	  /* This used to use `child->status'.  That's wrong, however, for
	     pipelines.  `child' is the first process in the pipeline.  It's
	     likely that the process we want to check for abnormal termination
	     or stopping is the last process in the pipeline, especially if
	     it's long-lived and the first process is short-lived.  Since we
	     know we have a job here, we can check all the processes in this
	     job's pipeline and see if one of them stopped or terminated due
	     to a signal.  We might want to change this later to just check
	     the last process in the pipeline.  If no process exits due to a
	     signal, S is left as the status of the last job in the pipeline. */
	  s = job_signal_status (job);

	  if (WIFSIGNALED (s) || WIFSTOPPED (s))
	    {
	      set_tty_state ();

	      /* If the current job was stopped or killed by a signal, and
		 the user has requested it, get a possibly new window size */
	      if (check_window_size && (job == js.j_current || IS_FOREGROUND (job)))
		get_new_window_size (0, (int *)0, (int *)0);
	    }
	  else
#if defined (READLINE)
	    /* We don't want to do this if we are running a process during
	       programmable completion. */
	    if (RL_ISSTATE (RL_STATE_COMPLETING) == 0)
#endif
	    get_tty_state ();

	  /* If job control is enabled, the job was started with job
	     control, the job was the foreground job, and it was killed
	     by SIGINT, then print a newline to compensate for the kernel
	     printing the ^C without a trailing newline. */
	  if (job_control && IS_JOBCONTROL (job) && IS_FOREGROUND (job) &&
		WIFSIGNALED (s) && WTERMSIG (s) == SIGINT)
	    {
	      /* If SIGINT is not trapped and the shell is in a for, while,
		 or until loop, act as if the shell received SIGINT as
		 well, so the loop can be broken.  This doesn't call the
		 SIGINT signal handler; maybe it should. */
	      if (signal_is_trapped (SIGINT) == 0 && (loop_level || (shell_compatibility_level > 32 && executing_list)))
		ADDINTERRUPT;
	      /* Call any SIGINT trap handler if the shell is running a loop, so
		 the loop can be broken.  This seems more useful and matches the
		 behavior when the shell is running a builtin command in a loop
		 when it is interrupted.  Change ADDINTERRUPT to
		 trap_handler (SIGINT) to run the trap without interrupting the
		 loop. */
	      else if (signal_is_trapped (SIGINT) && loop_level)
		ADDINTERRUPT;
	      /* If an interactive shell with job control enabled is sourcing
		 a file, allow the interrupt to terminate the file sourcing. */
	      else if (interactive_shell && signal_is_trapped (SIGINT) == 0 && sourcelevel)
		ADDINTERRUPT;
	      else
		{
		  putchar ('\n');
		  fflush (stdout);
		}
	    }
	}
      else if ((subshell_environment & (SUBSHELL_COMSUB|SUBSHELL_PIPE)) && wait_sigint_received)
	{
	  /* If waiting for a job in a subshell started to do command
	     substitution or to run a pipeline element that consists of
	     something like a while loop or a for loop, simulate getting
	     and being killed by the SIGINT to pass the status back to our
	     parent. */
	  if (child_caught_sigint == 0 && signal_is_trapped (SIGINT) == 0)
	    {
	      UNBLOCK_CHILD (oset);
	      old_sigint_handler = set_signal_handler (SIGINT, SIG_DFL);
	      if (old_sigint_handler == SIG_IGN)
		restore_sigint_handler ();
	      else
		kill (getpid (), SIGINT);
	    }
	}
      else if (interactive_shell == 0 && subshell_environment == 0 && IS_FOREGROUND (job))
	{
	  s = job_signal_status (job);

	  /* If we are non-interactive, but job control is enabled, and the job
	     died due to SIGINT, pretend we got the SIGINT */
	  if (job_control && IS_JOBCONTROL (job) && WIFSIGNALED (s) && WTERMSIG (s) == SIGINT)
	    {
	      ADDINTERRUPT;	/* For now */
	    }

	  if (check_window_size)
	    get_new_window_size (0, (int *)0, (int *)0);
	}

      /* Moved here from set_job_status_and_cleanup, which is in the SIGCHLD
	 signal handler path */
      if (DEADJOB (job) && IS_FOREGROUND (job) /*&& subshell_environment == 0*/)
	setjstatus (job);

      /* If this job is dead, notify the user of the status.  If the shell
	 is interactive, this will display a message on the terminal.  If
	 the shell is not interactive, make sure we turn on the notify bit
	 so we don't get an unwanted message about the job's termination,
	 and so delete_job really clears the slot in the jobs table. */
      notify_and_cleanup ();
    }

wait_for_return:

  UNBLOCK_CHILD (oset);

  return (termination_state);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\jobs.c:2,908
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\jobs.c:3,225
parsing error 
{
  pid_t pid;
  int r, state;
  sigset_t set, oset;

  BLOCK_CHILD(set, oset);
  state = JOBSTATE (job);
  if (state == JSTOPPED)
    internal_warning (_("wait_for_job: job %d is stopped"), job+1);

  pid = find_last_pid (job, 0);
  UNBLOCK_CHILD(oset);

  do
    {
      r = wait_for (pid, 0);
      if (r == -1 && errno == ECHILD)
	mark_all_jobs_as_dead ();

      CHECK_WAIT_INTR;

      if ((flags & JWAIT_FORCE) == 0)
	break;

      BLOCK_CHILD (set, oset);
      state = (job != NO_JOB && jobs[job]) ? JOBSTATE (job) : JDEAD;
      UNBLOCK_CHILD (oset);
    }
  while (state != JDEAD);

  /* POSIX.2: we can remove the job from the jobs table if we just waited
     for it. */
  BLOCK_CHILD (set, oset);
  if (job != NO_JOB && jobs[job] && DEADJOB (job))
    jobs[job]->flags |= J_NOTIFIED;
  UNBLOCK_CHILD (oset);

  if (ps)
    {
      ps->pid = pid;
      ps->status = (r < 0) ? 127 : r;
    }
  return r;
}
warning: parse error {
  pid_t pid;
  int r, state;
  sigset_t set, oset;

  BLOCK_CHILD(set, oset);
  state = JOBSTATE (job);
  if (state == JSTOPPED)
    internal_warning (_("wait_for_job: job %d is stopped"), job+1);

  pid = find_last_pid (job, 0);
  UNBLOCK_CHILD(oset);

  do
    {
      r = wait_for (pid, 0);
      if (r == -1 && errno == ECHILD)
	mark_all_jobs_as_dead ();

      CHECK_WAIT_INTR;

      if ((flags & JWAIT_FORCE) == 0)
	break;

      BLOCK_CHILD (set, oset);
      state = (job != NO_JOB && jobs[job]) ? JOBSTATE (job) : JDEAD;
      UNBLOCK_CHILD (oset);
    }
  while (state != JDEAD);

  /* POSIX.2: we can remove the job from the jobs table if we just waited
     for it. */
  BLOCK_CHILD (set, oset);
  if (job != NO_JOB && jobs[job] && DEADJOB (job))
    jobs[job]->flags |= J_NOTIFIED;
  UNBLOCK_CHILD (oset);

  if (ps)
    {
      ps->pid = pid;
      ps->status = (r < 0) ? 127 : r;
    }
  return r;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\jobs.c:3,228
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\jobs.c:3,279
parsing error 
{
  pid_t pid;
  int i, r;
  sigset_t set, oset;

  if (jobs_list_frozen)
    return -1;

  /* First see if there are any unnotified dead jobs that we can report on */
  BLOCK_CHILD (set, oset);
  for (i = 0; i < js.j_jobslots; i++)
    {
      if ((flags & JWAIT_WAITING) && jobs[i] && IS_WAITING (i) == 0)
	continue;		/* if we don't want it, skip it */
      if (jobs[i] && DEADJOB (i) && IS_NOTIFIED (i) == 0)
	{
return_job:
	  r = job_exit_status (i);
	  pid = find_last_pid (i, 0);
	  if (ps)
	    {
	      ps->pid = pid;
	      ps->status = r;
	    }
	  notify_of_job_status ();		/* XXX */
	  delete_job (i, 0);
#if defined (COPROCESS_SUPPORT)
	  coproc_reap ();
#endif
	  UNBLOCK_CHILD (oset);
	  return r;
	}
    }
  UNBLOCK_CHILD (oset);

  /* At this point, we have no dead jobs in the jobs table.  Wait until we
     get one, even if it takes multiple pids exiting. */
  for (;;)
    {
      /* Make sure there is a background job to wait for */
      BLOCK_CHILD (set, oset);
      for (i = 0; i < js.j_jobslots; i++)
	if (jobs[i] && RUNNING (i) && IS_FOREGROUND (i) == 0)
	  break;
      if (i == js.j_jobslots)
	{
	  UNBLOCK_CHILD (oset);
	  return -1;
	}

      UNBLOCK_CHILD (oset);

      QUIT;
      CHECK_TERMSIG;
      CHECK_WAIT_INTR;

      errno = 0;
      r = wait_for (ANY_PID, 0);	/* special sentinel value for wait_for */
      if (r == -1 && errno == ECHILD)
	mark_all_jobs_as_dead ();
	
      /* Now we see if we have any dead jobs and return the first one */
      BLOCK_CHILD (set, oset);
      for (i = 0; i < js.j_jobslots; i++)
	{
	  if ((flags & JWAIT_WAITING) && jobs[i] && IS_WAITING (i) == 0)
	    continue;		/* if we don't want it, skip it */
	  if (jobs[i] && DEADJOB (i))
	    goto return_job;
	}
      UNBLOCK_CHILD (oset);
    }

  return -1;
}
warning: parse error {
  pid_t pid;
  int i, r;
  sigset_t set, oset;

  if (jobs_list_frozen)
    return -1;

  /* First see if there are any unnotified dead jobs that we can report on */
  BLOCK_CHILD (set, oset);
  for (i = 0; i < js.j_jobslots; i++)
    {
      if ((flags & JWAIT_WAITING) && jobs[i] && IS_WAITING (i) == 0)
	continue;		/* if we don't want it, skip it */
      if (jobs[i] && DEADJOB (i) && IS_NOTIFIED (i) == 0)
	{
return_job:
	  r = job_exit_status (i);
	  pid = find_last_pid (i, 0);
	  if (ps)
	    {
	      ps->pid = pid;
	      ps->status = r;
	    }
	  notify_of_job_status ();		/* XXX */
	  delete_job (i, 0);
#if defined (COPROCESS_SUPPORT)
	  coproc_reap ();
#endif
	  UNBLOCK_CHILD (oset);
	  return r;
	}
    }
  UNBLOCK_CHILD (oset);

  /* At this point, we have no dead jobs in the jobs table.  Wait until we
     get one, even if it takes multiple pids exiting. */
  for (;;)
    {
      /* Make sure there is a background job to wait for */
      BLOCK_CHILD (set, oset);
      for (i = 0; i < js.j_jobslots; i++)
	if (jobs[i] && RUNNING (i) && IS_FOREGROUND (i) == 0)
	  break;
      if (i == js.j_jobslots)
	{
	  UNBLOCK_CHILD (oset);
	  return -1;
	}

      UNBLOCK_CHILD (oset);

      QUIT;
      CHECK_TERMSIG;
      CHECK_WAIT_INTR;

      errno = 0;
      r = wait_for (ANY_PID, 0);	/* special sentinel value for wait_for */
      if (r == -1 && errno == ECHILD)
	mark_all_jobs_as_dead ();
	
      /* Now we see if we have any dead jobs and return the first one */
      BLOCK_CHILD (set, oset);
      for (i = 0; i < js.j_jobslots; i++)
	{
	  if ((flags & JWAIT_WAITING) && jobs[i] && IS_WAITING (i) == 0)
	    continue;		/* if we don't want it, skip it */
	  if (jobs[i] && DEADJOB (i))
	    goto return_job;
	}
      UNBLOCK_CHILD (oset);
    }

  return -1;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\jobs.c:3,282
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\jobs.c:3,387
parsing error 
{
  register int i, result;
  sigset_t set, oset;

  BLOCK_CHILD (set, oset);

  for (result = NO_JOB, i = job - 1; i >= 0; i--)
    {
      if (jobs[i] && (JOBSTATE (i) == state))
	{
	  result = i;
	  break;
	}
    }

  UNBLOCK_CHILD (oset);

  return (result);
}
warning: parse error {
  register int i, result;
  sigset_t set, oset;

  BLOCK_CHILD (set, oset);

  for (result = NO_JOB, i = job - 1; i >= 0; i--)
    {
      if (jobs[i] && (JOBSTATE (i) == state))
	{
	  result = i;
	  break;
	}
    }

  UNBLOCK_CHILD (oset);

  return (result);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\jobs.c:3,390
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\jobs.c:3,413
parsing error 
{
  return (most_recent_job_in_state (job, JSTOPPED));
}
warning: parse error {
  return (most_recent_job_in_state (job, JSTOPPED));
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\jobs.c:3,415
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\jobs.c:3,422
parsing error 
{
  return (most_recent_job_in_state (job, JRUNNING));
}
warning: parse error {
  return (most_recent_job_in_state (job, JRUNNING));
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\jobs.c:3,424
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\jobs.c:3,431
parsing error 
{
  int candidate;

  if (js.j_current != job)
    {
      js.j_previous = js.j_current;
      js.j_current = job;
    }

  /* First choice for previous job is the old current job. */
  if (js.j_previous != js.j_current &&
      js.j_previous != NO_JOB &&
      jobs[js.j_previous] &&
      STOPPED (js.j_previous))
    return;

  /* Second choice:  Newest stopped job that is older than
     the current job. */
  candidate = NO_JOB;
  if (STOPPED (js.j_current))
    {
      candidate = job_last_stopped (js.j_current);

      if (candidate != NO_JOB)
	{
	  js.j_previous = candidate;
	  return;
	}
    }

  /* If we get here, there is either only one stopped job, in which case it is
     the current job and the previous job should be set to the newest running
     job, or there are only running jobs and the previous job should be set to
     the newest running job older than the current job.  We decide on which
     alternative to use based on whether or not JOBSTATE(js.j_current) is
     JSTOPPED. */

  candidate = RUNNING (js.j_current) ? job_last_running (js.j_current)
				    : job_last_running (js.j_jobslots);

  if (candidate != NO_JOB)
    {
      js.j_previous = candidate;
      return;
    }

  /* There is only a single job, and it is both `+' and `-'. */
  js.j_previous = js.j_current;
}
warning: parse error {
  int candidate;

  if (js.j_current != job)
    {
      js.j_previous = js.j_current;
      js.j_current = job;
    }

  /* First choice for previous job is the old current job. */
  if (js.j_previous != js.j_current &&
      js.j_previous != NO_JOB &&
      jobs[js.j_previous] &&
      STOPPED (js.j_previous))
    return;

  /* Second choice:  Newest stopped job that is older than
     the current job. */
  candidate = NO_JOB;
  if (STOPPED (js.j_current))
    {
      candidate = job_last_stopped (js.j_current);

      if (candidate != NO_JOB)
	{
	  js.j_previous = candidate;
	  return;
	}
    }

  /* If we get here, there is either only one stopped job, in which case it is
     the current job and the previous job should be set to the newest running
     job, or there are only running jobs and the previous job should be set to
     the newest running job older than the current job.  We decide on which
     alternative to use based on whether or not JOBSTATE(js.j_current) is
     JSTOPPED. */

  candidate = RUNNING (js.j_current) ? job_last_running (js.j_current)
				    : job_last_running (js.j_jobslots);

  if (candidate != NO_JOB)
    {
      js.j_previous = candidate;
      return;
    }

  /* There is only a single job, and it is both `+' and `-'. */
  js.j_previous = js.j_current;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\jobs.c:3,433
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\jobs.c:3,526
parsing error 
{
  register PROCESS *p;

  /* Each member of the pipeline is now running. */
  p = jobs[job]->pipe;

  do
    {
      if (WIFSTOPPED (p->status))
	p->running = PS_RUNNING;	/* XXX - could be PS_STOPPED */
      p = p->next;
    }
  while (p != jobs[job]->pipe);

  /* This means that the job is running. */
  JOBSTATE (job) = JRUNNING;
}
warning: parse error {
  register PROCESS *p;

  /* Each member of the pipeline is now running. */
  p = jobs[job]->pipe;

  do
    {
      if (WIFSTOPPED (p->status))
	p->running = PS_RUNNING;	/* XXX - could be PS_STOPPED */
      p = p->next;
    }
  while (p != jobs[job]->pipe);

  /* This means that the job is running. */
  JOBSTATE (job) = JRUNNING;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\jobs.c:3,528
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\jobs.c:3,551
parsing error 
{
  register PROCESS *p;
  int already_running;
  sigset_t set, oset;
  char *wd, *s;
  static TTYSTRUCT save_stty;

  BLOCK_CHILD (set, oset);

  if ((subshell_environment & SUBSHELL_COMSUB) && (pipeline_pgrp == shell_pgrp))
    {
      internal_error (_("%s: no current jobs"), this_command_name);
      UNBLOCK_CHILD (oset);
      return (-1);
    }

  if (DEADJOB (job))
    {
      internal_error (_("%s: job has terminated"), this_command_name);
      UNBLOCK_CHILD (oset);
      return (-1);
    }

  already_running = RUNNING (job);

  if (foreground == 0 && already_running)
    {
      internal_error (_("%s: job %d already in background"), this_command_name, job + 1);
      UNBLOCK_CHILD (oset);
      return (0);		/* XPG6/SUSv3 says this is not an error */
    }

  wd = current_working_directory ();

  /* You don't know about the state of this job.  Do you? */
  jobs[job]->flags &= ~J_NOTIFIED;

  if (foreground)
    {
      set_current_job (job);
      jobs[job]->flags |= J_FOREGROUND;
    }

  /* Tell the outside world what we're doing. */
  p = jobs[job]->pipe;

  if (foreground == 0)
    {
      /* POSIX.2 says `bg' doesn't give any indication about current or
	 previous job. */
      if (posixly_correct == 0)
	s = (job == js.j_current) ? "+ ": ((job == js.j_previous) ? "- " : " ");       
      else
	s = " ";
      printf ("[%d]%s", job + 1, s);
    }

  do
    {
      printf ("%s%s",
	       p->command ? p->command : "",
	       p->next != jobs[job]->pipe? " | " : "");
      p = p->next;
    }
  while (p != jobs[job]->pipe);

  if (foreground == 0)
    printf (" &");

  if (strcmp (wd, jobs[job]->wd) != 0)
    printf ("	(wd: %s)", polite_directory_format (jobs[job]->wd));

  printf ("\n");

  /* Run the job. */
  if (already_running == 0)
    set_job_running (job);

  /* Save the tty settings before we start the job in the foreground. */
  if (foreground)
    {
      get_tty_state ();
      save_stty = shell_tty_info;
      /* Give the terminal to this job. */
      if (IS_JOBCONTROL (job))
	give_terminal_to (jobs[job]->pgrp, 0);
    }
  else
    jobs[job]->flags &= ~J_FOREGROUND;

  /* If the job is already running, then don't bother jump-starting it. */
  if (already_running == 0)
    {
      jobs[job]->flags |= J_NOTIFIED;
      killpg (jobs[job]->pgrp, SIGCONT);
    }

  if (foreground)
    {
      pid_t pid;
      int st;

      pid = find_last_pid (job, 0);
      UNBLOCK_CHILD (oset);
      st = wait_for (pid, 0);
      shell_tty_info = save_stty;
      set_tty_state ();
      return (st);
    }
  else
    {
      reset_current ();
      UNBLOCK_CHILD (oset);
      return (0);
    }
}
warning: parse error {
  register PROCESS *p;
  int already_running;
  sigset_t set, oset;
  char *wd, *s;
  static TTYSTRUCT save_stty;

  BLOCK_CHILD (set, oset);

  if ((subshell_environment & SUBSHELL_COMSUB) && (pipeline_pgrp == shell_pgrp))
    {
      internal_error (_("%s: no current jobs"), this_command_name);
      UNBLOCK_CHILD (oset);
      return (-1);
    }

  if (DEADJOB (job))
    {
      internal_error (_("%s: job has terminated"), this_command_name);
      UNBLOCK_CHILD (oset);
      return (-1);
    }

  already_running = RUNNING (job);

  if (foreground == 0 && already_running)
    {
      internal_error (_("%s: job %d already in background"), this_command_name, job + 1);
      UNBLOCK_CHILD (oset);
      return (0);		/* XPG6/SUSv3 says this is not an error */
    }

  wd = current_working_directory ();

  /* You don't know about the state of this job.  Do you? */
  jobs[job]->flags &= ~J_NOTIFIED;

  if (foreground)
    {
      set_current_job (job);
      jobs[job]->flags |= J_FOREGROUND;
    }

  /* Tell the outside world what we're doing. */
  p = jobs[job]->pipe;

  if (foreground == 0)
    {
      /* POSIX.2 says `bg' doesn't give any indication about current or
	 previous job. */
      if (posixly_correct == 0)
	s = (job == js.j_current) ? "+ ": ((job == js.j_previous) ? "- " : " ");       
      else
	s = " ";
      printf ("[%d]%s", job + 1, s);
    }

  do
    {
      printf ("%s%s",
	       p->command ? p->command : "",
	       p->next != jobs[job]->pipe? " | " : "");
      p = p->next;
    }
  while (p != jobs[job]->pipe);

  if (foreground == 0)
    printf (" &");

  if (strcmp (wd, jobs[job]->wd) != 0)
    printf ("	(wd: %s)", polite_directory_format (jobs[job]->wd));

  printf ("\n");

  /* Run the job. */
  if (already_running == 0)
    set_job_running (job);

  /* Save the tty settings before we start the job in the foreground. */
  if (foreground)
    {
      get_tty_state ();
      save_stty = shell_tty_info;
      /* Give the terminal to this job. */
      if (IS_JOBCONTROL (job))
	give_terminal_to (jobs[job]->pgrp, 0);
    }
  else
    jobs[job]->flags &= ~J_FOREGROUND;

  /* If the job is already running, then don't bother jump-starting it. */
  if (already_running == 0)
    {
      jobs[job]->flags |= J_NOTIFIED;
      killpg (jobs[job]->pgrp, SIGCONT);
    }

  if (foreground)
    {
      pid_t pid;
      int st;

      pid = find_last_pid (job, 0);
      UNBLOCK_CHILD (oset);
      st = wait_for (pid, 0);
      shell_tty_info = save_stty;
      set_tty_state ();
      return (st);
    }
  else
    {
      reset_current ();
      UNBLOCK_CHILD (oset);
      return (0);
    }
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\jobs.c:3,553
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\jobs.c:3,675
parsing error 
{
  register PROCESS *p;
  int job, result, negative;
  sigset_t set, oset;

  if (pid < -1)
    {
      pid = -pid;
      group = negative = 1;
    }
  else
    negative = 0;

  result = EXECUTION_SUCCESS;
  if (group)
    {
      BLOCK_CHILD (set, oset);
      p = find_pipeline (pid, 0, &job);

      if (job != NO_JOB)
	{
	  jobs[job]->flags &= ~J_NOTIFIED;

	  /* Kill process in backquotes or one started without job control? */

	  /* If we're passed a pid < -1, just call killpg and see what happens  */
	  if (negative && jobs[job]->pgrp == shell_pgrp)
	    result = killpg (pid, sig);
	  /* If we're killing using job control notification, for example,
	     without job control active, we have to do things ourselves. */
	  else if (jobs[job]->pgrp == shell_pgrp)
	    {
	      p = jobs[job]->pipe;
	      do
		{
		  if (PALIVE (p) == 0)
		    continue;		/* avoid pid recycling problem */
		  kill (p->pid, sig);
		  if (PEXITED (p) && (sig == SIGTERM || sig == SIGHUP))
		    kill (p->pid, SIGCONT);
		  p = p->next;
		}
	      while  (p != jobs[job]->pipe);
	    }
	  else
	    {
	      result = killpg (jobs[job]->pgrp, sig);
	      if (p && STOPPED (job) && (sig == SIGTERM || sig == SIGHUP))
		killpg (jobs[job]->pgrp, SIGCONT);
	      /* If we're continuing a stopped job via kill rather than bg or
		 fg, emulate the `bg' behavior. */
	      if (p && STOPPED (job) && (sig == SIGCONT))
		{
		  set_job_running (job);
		  jobs[job]->flags &= ~J_FOREGROUND;
		  jobs[job]->flags |= J_NOTIFIED;
		}
	    }
	}
      else
	result = killpg (pid, sig);

      UNBLOCK_CHILD (oset);
    }
  else
    result = kill (pid, sig);

  return (result);
}
warning: parse error {
  register PROCESS *p;
  int job, result, negative;
  sigset_t set, oset;

  if (pid < -1)
    {
      pid = -pid;
      group = negative = 1;
    }
  else
    negative = 0;

  result = EXECUTION_SUCCESS;
  if (group)
    {
      BLOCK_CHILD (set, oset);
      p = find_pipeline (pid, 0, &job);

      if (job != NO_JOB)
	{
	  jobs[job]->flags &= ~J_NOTIFIED;

	  /* Kill process in backquotes or one started without job control? */

	  /* If we're passed a pid < -1, just call killpg and see what happens  */
	  if (negative && jobs[job]->pgrp == shell_pgrp)
	    result = killpg (pid, sig);
	  /* If we're killing using job control notification, for example,
	     without job control active, we have to do things ourselves. */
	  else if (jobs[job]->pgrp == shell_pgrp)
	    {
	      p = jobs[job]->pipe;
	      do
		{
		  if (PALIVE (p) == 0)
		    continue;		/* avoid pid recycling problem */
		  kill (p->pid, sig);
		  if (PEXITED (p) && (sig == SIGTERM || sig == SIGHUP))
		    kill (p->pid, SIGCONT);
		  p = p->next;
		}
	      while  (p != jobs[job]->pipe);
	    }
	  else
	    {
	      result = killpg (jobs[job]->pgrp, sig);
	      if (p && STOPPED (job) && (sig == SIGTERM || sig == SIGHUP))
		killpg (jobs[job]->pgrp, SIGCONT);
	      /* If we're continuing a stopped job via kill rather than bg or
		 fg, emulate the `bg' behavior. */
	      if (p && STOPPED (job) && (sig == SIGCONT))
		{
		  set_job_running (job);
		  jobs[job]->flags &= ~J_FOREGROUND;
		  jobs[job]->flags |= J_NOTIFIED;
		}
	    }
	}
      else
	result = killpg (pid, sig);

      UNBLOCK_CHILD (oset);
    }
  else
    result = kill (pid, sig);

  return (result);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\jobs.c:3,678
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\jobs.c:3,751
parsing error 
{
  int n, oerrno;

  oerrno = errno;
  REINSTALL_SIGCHLD_HANDLER;
  sigchld++;
  n = 0;
  if (queue_sigchld == 0)
    n = waitchld (-1, 0);
  errno = oerrno;
  SIGRETURN (n);
}
warning: parse error {
  int n, oerrno;

  oerrno = errno;
  REINSTALL_SIGCHLD_HANDLER;
  sigchld++;
  n = 0;
  if (queue_sigchld == 0)
    n = waitchld (-1, 0);
  errno = oerrno;
  SIGRETURN (n);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\jobs.c:3,753
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\jobs.c:3,774
parsing error 
{
  WAIT status;
  PROCESS *child;
  pid_t pid;
  int ind;

  int call_set_current, last_stopped_job, job, children_exited, waitpid_flags;
  static int wcontinued = WCONTINUED;	/* run-time fix for glibc problem */

  call_set_current = children_exited = 0;
  last_stopped_job = NO_JOB;

  do
    {
      /* We don't want to be notified about jobs stopping if job control
	 is not active.  XXX - was interactive_shell instead of job_control */
      waitpid_flags = (job_control && subshell_environment == 0)
			? (WUNTRACED|wcontinued)
			: 0;
      if (sigchld || block == 0)
	waitpid_flags |= WNOHANG;

      /* Check for terminating signals and exit the shell if we receive one */
      CHECK_TERMSIG;
      /* Check for a trapped signal interrupting the wait builtin and jump out */
      CHECK_WAIT_INTR;

      if (block == 1 && queue_sigchld == 0 && (waitpid_flags & WNOHANG) == 0)
	{
	  internal_warning (_("waitchld: turning on WNOHANG to avoid indefinite block"));
	  waitpid_flags |= WNOHANG;
	}

      pid = WAITPID (-1, &status, waitpid_flags);

#if 0
if (wpid != -1 && block)
  itrace("waitchld: blocking waitpid returns %d", pid);
#endif
#if 0
if (wpid != -1)
  itrace("waitchld: %s waitpid returns %d", block?"blocking":"non-blocking", pid);
#endif
      /* WCONTINUED may be rejected by waitpid as invalid even when defined */
      if (wcontinued && pid < 0 && errno == EINVAL)
	{
	  wcontinued = 0;
	  continue;	/* jump back to the test and retry without WCONTINUED */
	}

      /* The check for WNOHANG is to make sure we decrement sigchld only
	 if it was non-zero before we called waitpid. */
      if (sigchld > 0 && (waitpid_flags & WNOHANG))
	sigchld--;

      /* If waitpid returns -1 with errno == ECHILD, there are no more
	 unwaited-for child processes of this shell. */
      if (pid < 0 && errno == ECHILD)
	{
	  if (children_exited == 0)
	    return -1;
	  else
	    break;
	}

#if 0
itrace("waitchld: waitpid returns %d block = %d children_exited = %d", pid, block, children_exited);
#endif
      /* If waitpid returns 0, there are running children.  If it returns -1,
	 the only other error POSIX says it can return is EINTR. */
      CHECK_TERMSIG;
      CHECK_WAIT_INTR;

      /* If waitpid returns -1/EINTR and the shell saw a SIGINT, then we
	 assume the child has blocked or handled SIGINT.  In that case, we
	 require the child to actually die due to SIGINT to act on the
	 SIGINT we received; otherwise we assume the child handled it and
	 let it go. */
      if (pid < 0 && errno == EINTR && wait_sigint_received)
	child_caught_sigint = 1;

      if (pid <= 0)
	continue;	/* jumps right to the test */

      /* Linux kernels appear to signal the parent but not interrupt the
	 waitpid() (or restart it even without SA_RESTART) on SIGINT, so if
	 we saw a SIGINT and the process exited or died due to some other
	 signal, assume the child caught the SIGINT. */
      if (wait_sigint_received && (WIFSIGNALED (status) == 0 || WTERMSIG (status) != SIGINT))
	child_caught_sigint = 1;

      /* If the child process did die due to SIGINT, forget our assumption
	 that it caught or otherwise handled it. */
      if (WIFSIGNALED (status) && WTERMSIG (status) == SIGINT)
	child_caught_sigint = 0;

      /* children_exited is used to run traps on SIGCHLD.  We don't want to
	 run the trap if a process is just being continued. */
      if (WIFCONTINUED(status) == 0)
	{
	  children_exited++;
	  js.c_living--;
	}

      /* Locate our PROCESS for this pid. */
      child = find_process (pid, 1, &job);	/* want living procs only */

#if defined (COPROCESS_SUPPORT)
      coproc_pidchk (pid, WSTATUS(status));
#endif

#if defined (PROCESS_SUBSTITUTION)
      /* Only manipulate the list of process substitutions while SIGCHLD
	 is blocked. We only use this as a hint that we can remove FIFOs
	 or close file descriptors corresponding to terminated process
	 substitutions. */
      if ((ind = find_procsub_child (pid)) >= 0)
	set_procsub_status (ind, pid, WSTATUS (status));
#endif

      /* It is not an error to have a child terminate that we did
	 not have a record of.  This child could have been part of
	 a pipeline in backquote substitution.  Even so, I'm not
	 sure child is ever non-zero. */
      if (child == 0)
	{
	  if (WIFEXITED (status) || WIFSIGNALED (status))
	    js.c_reaped++;
	  continue;
	}

      /* Remember status, and whether or not the process is running. */
      child->status = status;
      child->running = WIFCONTINUED(status) ? PS_RUNNING : PS_DONE;

      if (PEXITED (child))
	{
	  js.c_totreaped++;
	  if (job != NO_JOB)
	    js.c_reaped++;
	}

      if (job == NO_JOB)
	continue;

      call_set_current += set_job_status_and_cleanup (job);

      if (STOPPED (job))
	last_stopped_job = job;
      else if (DEADJOB (job) && last_stopped_job == job)
	last_stopped_job = NO_JOB;
    }
  while ((sigchld || block == 0) && pid > (pid_t)0);

  /* If a job was running and became stopped, then set the current
     job.  Otherwise, don't change a thing. */
  if (call_set_current)
    {
      if (last_stopped_job != NO_JOB)
	set_current_job (last_stopped_job);
      else
	reset_current ();
    }

  /* Call a SIGCHLD trap handler for each child that exits, if one is set. */
  if (children_exited &&
      (signal_is_trapped (SIGCHLD) || trap_list[SIGCHLD] == (char *)IMPOSSIBLE_TRAP_HANDLER) &&
      trap_list[SIGCHLD] != (char *)IGNORE_SIG)
    {
      if (posixly_correct && this_shell_builtin && this_shell_builtin == wait_builtin)
	{
	  /* This was trap_handler (SIGCHLD) but that can lose traps if
	     children_exited > 1 */
	  queue_sigchld_trap (children_exited);
	  wait_signal_received = SIGCHLD;
	  /* If we're in a signal handler, let CHECK_WAIT_INTR pick it up;
	     run_pending_traps will call run_sigchld_trap later  */
	  if (sigchld == 0 && wait_intr_flag)
	    sh_longjmp (wait_intr_buf, 1);
	}
      /* If not in posix mode and not executing the wait builtin, queue the
	 signal for later handling.  Run the trap immediately if we are
	 executing the wait builtin, but don't break out of `wait'. */
      else if (sigchld)	/* called from signal handler */
	queue_sigchld_trap (children_exited);
      else if (signal_in_progress (SIGCHLD))
	queue_sigchld_trap (children_exited);     
      else if (trap_list[SIGCHLD] == (char *)IMPOSSIBLE_TRAP_HANDLER)
	queue_sigchld_trap (children_exited);
      else if (running_trap)
	queue_sigchld_trap (children_exited);
      else if (this_shell_builtin == wait_builtin)
	run_sigchld_trap (children_exited);	/* XXX */
      else
	queue_sigchld_trap (children_exited);
    }

  /* We have successfully recorded the useful information about this process
     that has just changed state.  If we notify asynchronously, and the job
     that this process belongs to is no longer running, then notify the user
     of that fact now. */
  if (asynchronous_notification && interactive && executing_builtin == 0)
    notify_of_job_status ();

  return (children_exited);
}
warning: parse error {
  WAIT status;
  PROCESS *child;
  pid_t pid;
  int ind;

  int call_set_current, last_stopped_job, job, children_exited, waitpid_flags;
  static int wcontinued = WCONTINUED;	/* run-time fix for glibc problem */

  call_set_current = children_exited = 0;
  last_stopped_job = NO_JOB;

  do
    {
      /* We don't want to be notified about jobs stopping if job control
	 is not active.  XXX - was interactive_shell instead of job_control */
      waitpid_flags = (job_control && subshell_environment == 0)
			? (WUNTRACED|wcontinued)
			: 0;
      if (sigchld || block == 0)
	waitpid_flags |= WNOHANG;

      /* Check for terminating signals and exit the shell if we receive one */
      CHECK_TERMSIG;
      /* Check for a trapped signal interrupting the wait builtin and jump out */
      CHECK_WAIT_INTR;

      if (block == 1 && queue_sigchld == 0 && (waitpid_flags & WNOHANG) == 0)
	{
	  internal_warning (_("waitchld: turning on WNOHANG to avoid indefinite block"));
	  waitpid_flags |= WNOHANG;
	}

      pid = WAITPID (-1, &status, waitpid_flags);

#if 0
if (wpid != -1 && block)
  itrace("waitchld: blocking waitpid returns %d", pid);
#endif
#if 0
if (wpid != -1)
  itrace("waitchld: %s waitpid returns %d", block?"blocking":"non-blocking", pid);
#endif
      /* WCONTINUED may be rejected by waitpid as invalid even when defined */
      if (wcontinued && pid < 0 && errno == EINVAL)
	{
	  wcontinued = 0;
	  continue;	/* jump back to the test and retry without WCONTINUED */
	}

      /* The check for WNOHANG is to make sure we decrement sigchld only
	 if it was non-zero before we called waitpid. */
      if (sigchld > 0 && (waitpid_flags & WNOHANG))
	sigchld--;

      /* If waitpid returns -1 with errno == ECHILD, there are no more
	 unwaited-for child processes of this shell. */
      if (pid < 0 && errno == ECHILD)
	{
	  if (children_exited == 0)
	    return -1;
	  else
	    break;
	}

#if 0
itrace("waitchld: waitpid returns %d block = %d children_exited = %d", pid, block, children_exited);
#endif
      /* If waitpid returns 0, there are running children.  If it returns -1,
	 the only other error POSIX says it can return is EINTR. */
      CHECK_TERMSIG;
      CHECK_WAIT_INTR;

      /* If waitpid returns -1/EINTR and the shell saw a SIGINT, then we
	 assume the child has blocked or handled SIGINT.  In that case, we
	 require the child to actually die due to SIGINT to act on the
	 SIGINT we received; otherwise we assume the child handled it and
	 let it go. */
      if (pid < 0 && errno == EINTR && wait_sigint_received)
	child_caught_sigint = 1;

      if (pid <= 0)
	continue;	/* jumps right to the test */

      /* Linux kernels appear to signal the parent but not interrupt the
	 waitpid() (or restart it even without SA_RESTART) on SIGINT, so if
	 we saw a SIGINT and the process exited or died due to some other
	 signal, assume the child caught the SIGINT. */
      if (wait_sigint_received && (WIFSIGNALED (status) == 0 || WTERMSIG (status) != SIGINT))
	child_caught_sigint = 1;

      /* If the child process did die due to SIGINT, forget our assumption
	 that it caught or otherwise handled it. */
      if (WIFSIGNALED (status) && WTERMSIG (status) == SIGINT)
	child_caught_sigint = 0;

      /* children_exited is used to run traps on SIGCHLD.  We don't want to
	 run the trap if a process is just being continued. */
      if (WIFCONTINUED(status) == 0)
	{
	  children_exited++;
	  js.c_living--;
	}

      /* Locate our PROCESS for this pid. */
      child = find_process (pid, 1, &job);	/* want living procs only */

#if defined (COPROCESS_SUPPORT)
      coproc_pidchk (pid, WSTATUS(status));
#endif

#if defined (PROCESS_SUBSTITUTION)
      /* Only manipulate the list of process substitutions while SIGCHLD
	 is blocked. We only use this as a hint that we can remove FIFOs
	 or close file descriptors corresponding to terminated process
	 substitutions. */
      if ((ind = find_procsub_child (pid)) >= 0)
	set_procsub_status (ind, pid, WSTATUS (status));
#endif

      /* It is not an error to have a child terminate that we did
	 not have a record of.  This child could have been part of
	 a pipeline in backquote substitution.  Even so, I'm not
	 sure child is ever non-zero. */
      if (child == 0)
	{
	  if (WIFEXITED (status) || WIFSIGNALED (status))
	    js.c_reaped++;
	  continue;
	}

      /* Remember status, and whether or not the process is running. */
      child->status = status;
      child->running = WIFCONTINUED(status) ? PS_RUNNING : PS_DONE;

      if (PEXITED (child))
	{
	  js.c_totreaped++;
	  if (job != NO_JOB)
	    js.c_reaped++;
	}

      if (job == NO_JOB)
	continue;

      call_set_current += set_job_status_and_cleanup (job);

      if (STOPPED (job))
	last_stopped_job = job;
      else if (DEADJOB (job) && last_stopped_job == job)
	last_stopped_job = NO_JOB;
    }
  while ((sigchld || block == 0) && pid > (pid_t)0);

  /* If a job was running and became stopped, then set the current
     job.  Otherwise, don't change a thing. */
  if (call_set_current)
    {
      if (last_stopped_job != NO_JOB)
	set_current_job (last_stopped_job);
      else
	reset_current ();
    }

  /* Call a SIGCHLD trap handler for each child that exits, if one is set. */
  if (children_exited &&
      (signal_is_trapped (SIGCHLD) || trap_list[SIGCHLD] == (char *)IMPOSSIBLE_TRAP_HANDLER) &&
      trap_list[SIGCHLD] != (char *)IGNORE_SIG)
    {
      if (posixly_correct && this_shell_builtin && this_shell_builtin == wait_builtin)
	{
	  /* This was trap_handler (SIGCHLD) but that can lose traps if
	     children_exited > 1 */
	  queue_sigchld_trap (children_exited);
	  wait_signal_received = SIGCHLD;
	  /* If we're in a signal handler, let CHECK_WAIT_INTR pick it up;
	     run_pending_traps will call run_sigchld_trap later  */
	  if (sigchld == 0 && wait_intr_flag)
	    sh_longjmp (wait_intr_buf, 1);
	}
      /* If not in posix mode and not executing the wait builtin, queue the
	 signal for later handling.  Run the trap immediately if we are
	 executing the wait builtin, but don't break out of `wait'. */
      else if (sigchld)	/* called from signal handler */
	queue_sigchld_trap (children_exited);
      else if (signal_in_progress (SIGCHLD))
	queue_sigchld_trap (children_exited);     
      else if (trap_list[SIGCHLD] == (char *)IMPOSSIBLE_TRAP_HANDLER)
	queue_sigchld_trap (children_exited);
      else if (running_trap)
	queue_sigchld_trap (children_exited);
      else if (this_shell_builtin == wait_builtin)
	run_sigchld_trap (children_exited);	/* XXX */
      else
	queue_sigchld_trap (children_exited);
    }

  /* We have successfully recorded the useful information about this process
     that has just changed state.  If we notify asynchronously, and the job
     that this process belongs to is no longer running, then notify the user
     of that fact now. */
  if (asynchronous_notification && interactive && executing_builtin == 0)
    notify_of_job_status ();

  return (children_exited);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\jobs.c:3,777
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\jobs.c:3,990
parsing error 
{
  PROCESS *child;
  int tstatus, job_state, any_stopped, any_tstped, call_set_current;
  SigHandler *temp_handler;

  child = jobs[job]->pipe;
  jobs[job]->flags &= ~J_NOTIFIED;

  call_set_current = 0;

  /*
   * COMPUTE JOB STATUS
   */

  /* If all children are not running, but any of them is  stopped, then
     the job is stopped, not dead. */
  job_state = any_stopped = any_tstped = 0;
  do
    {
      job_state |= PRUNNING (child);
#if 0
      if (PEXITED (child) && (WIFSTOPPED (child->status)))
#else
      /* Only checking for WIFSTOPPED now, not for PS_DONE */
      if (PSTOPPED (child))
#endif
	{
	  any_stopped = 1;
	  any_tstped |= job_control && (WSTOPSIG (child->status) == SIGTSTP);
	}
      child = child->next;
    }
  while (child != jobs[job]->pipe);

  /* If job_state != 0, the job is still running, so don't bother with
     setting the process exit status and job state unless we're
     transitioning from stopped to running. */
  if (job_state != 0 && JOBSTATE(job) != JSTOPPED)
    return 0;

  /*
   * SET JOB STATUS
   */

  /* The job is either stopped or dead.  Set the state of the job accordingly. */
  if (any_stopped)
    {
      jobs[job]->state = JSTOPPED;
      jobs[job]->flags &= ~J_FOREGROUND;
      call_set_current++;
      /* Suspending a job with SIGTSTP breaks all active loops. */
      if (any_tstped && loop_level)
	breaking = loop_level;
    }
  else if (job_state != 0)	/* was stopped, now running */
    {
      jobs[job]->state = JRUNNING;
      call_set_current++;
    }
  else
    {
      jobs[job]->state = JDEAD;
      js.j_ndead++;

#if 0
      if (IS_FOREGROUND (job))
	setjstatus (job);
#endif

      /* If this job has a cleanup function associated with it, call it
	 with `cleanarg' as the single argument, then set the function
	 pointer to NULL so it is not inadvertently called twice.  The
	 cleanup function is responsible for deallocating cleanarg. */
      if (jobs[job]->j_cleanup)
	{
	  (*jobs[job]->j_cleanup) (jobs[job]->cleanarg);
	  jobs[job]->j_cleanup = (sh_vptrfunc_t *)NULL;
	}
    }

  /*
   * CLEANUP
   *
   * Currently, we just do special things if we got a SIGINT while waiting
   * for a foreground job to complete
   */

  if (JOBSTATE (job) == JDEAD)
    {
      /* If we're running a shell script and we get a SIGINT with a
	 SIGINT trap handler, but the foreground job handles it and
	 does not exit due to SIGINT, run the trap handler but do not
	 otherwise act as if we got the interrupt. */
      if (wait_sigint_received && interactive_shell == 0 &&
	  child_caught_sigint && IS_FOREGROUND (job) &&
	  signal_is_trapped (SIGINT))
	{
	  int old_frozen;
	  wait_sigint_received = 0;
	  last_command_exit_value = process_exit_status (child->status);

	  old_frozen = jobs_list_frozen;
	  jobs_list_frozen = 1;
	  tstatus = maybe_call_trap_handler (SIGINT);
	  jobs_list_frozen = old_frozen;
	}

      /* If the foreground job is killed by SIGINT when job control is not
	 active, we need to perform some special handling.

	 The check of wait_sigint_received is a way to determine if the
	 SIGINT came from the keyboard (in which case the shell has already
	 seen it, and wait_sigint_received is non-zero, because keyboard
	 signals are sent to process groups) or via kill(2) to the foreground
	 process by another process (or itself).  If the shell did receive the
	 SIGINT, it needs to perform normal SIGINT processing.  XXX - should
	 this change its behavior depending on whether the last command in an
	 pipeline exited due to SIGINT, or any process in the pipeline?  Right
	 now it does this if any process in the pipeline exits due to SIGINT. */
      else if (wait_sigint_received &&
	      child_caught_sigint == 0 &&
	      IS_FOREGROUND (job) && IS_JOBCONTROL (job) == 0)
	{
	  int old_frozen;

	  wait_sigint_received = 0;

	  /* If SIGINT is trapped, set the exit status so that the trap
	     handler can see it. */
	  if (signal_is_trapped (SIGINT))
	    last_command_exit_value = process_exit_status (child->status);

	  /* If the signal is trapped, let the trap handler get it no matter
	     what and simply return if the trap handler returns.
	     maybe_call_trap_handler() may cause dead jobs to be removed from
	     the job table because of a call to execute_command.  We work
	     around this by setting JOBS_LIST_FROZEN. */
	  old_frozen = jobs_list_frozen;
	  jobs_list_frozen = 1;
	  tstatus = maybe_call_trap_handler (SIGINT);
	  jobs_list_frozen = old_frozen;
	  if (tstatus == 0 && old_sigint_handler != INVALID_SIGNAL_HANDLER)
	    {
	      /* wait_sigint_handler () has already seen SIGINT and
		 allowed the wait builtin to jump out.  We need to
		 call the original SIGINT handler, if necessary.  If
		 the original handler is SIG_DFL, we need to resend
		 the signal to ourselves. */

	      temp_handler = old_sigint_handler;

	      /* Bogus.  If we've reset the signal handler as the result
		 of a trap caught on SIGINT, then old_sigint_handler
		 will point to trap_handler, which now knows nothing about
		 SIGINT (if we reset the sighandler to the default).
		 In this case, we have to fix things up.  What a crock. */
	      if (temp_handler == trap_handler && signal_is_trapped (SIGINT) == 0)
		  temp_handler = trap_to_sighandler (SIGINT);
	      restore_sigint_handler ();
	      if (temp_handler == SIG_DFL)
		termsig_handler (SIGINT);	/* XXX */
	      else if (temp_handler != SIG_IGN)
		(*temp_handler) (SIGINT);
	    }
	}
    }

  return call_set_current;
}
warning: parse error {
  PROCESS *child;
  int tstatus, job_state, any_stopped, any_tstped, call_set_current;
  SigHandler *temp_handler;

  child = jobs[job]->pipe;
  jobs[job]->flags &= ~J_NOTIFIED;

  call_set_current = 0;

  /*
   * COMPUTE JOB STATUS
   */

  /* If all children are not running, but any of them is  stopped, then
     the job is stopped, not dead. */
  job_state = any_stopped = any_tstped = 0;
  do
    {
      job_state |= PRUNNING (child);
#if 0
      if (PEXITED (child) && (WIFSTOPPED (child->status)))
#else
      /* Only checking for WIFSTOPPED now, not for PS_DONE */
      if (PSTOPPED (child))
#endif
	{
	  any_stopped = 1;
	  any_tstped |= job_control && (WSTOPSIG (child->status) == SIGTSTP);
	}
      child = child->next;
    }
  while (child != jobs[job]->pipe);

  /* If job_state != 0, the job is still running, so don't bother with
     setting the process exit status and job state unless we're
     transitioning from stopped to running. */
  if (job_state != 0 && JOBSTATE(job) != JSTOPPED)
    return 0;

  /*
   * SET JOB STATUS
   */

  /* The job is either stopped or dead.  Set the state of the job accordingly. */
  if (any_stopped)
    {
      jobs[job]->state = JSTOPPED;
      jobs[job]->flags &= ~J_FOREGROUND;
      call_set_current++;
      /* Suspending a job with SIGTSTP breaks all active loops. */
      if (any_tstped && loop_level)
	breaking = loop_level;
    }
  else if (job_state != 0)	/* was stopped, now running */
    {
      jobs[job]->state = JRUNNING;
      call_set_current++;
    }
  else
    {
      jobs[job]->state = JDEAD;
      js.j_ndead++;

#if 0
      if (IS_FOREGROUND (job))
	setjstatus (job);
#endif

      /* If this job has a cleanup function associated with it, call it
	 with `cleanarg' as the single argument, then set the function
	 pointer to NULL so it is not inadvertently called twice.  The
	 cleanup function is responsible for deallocating cleanarg. */
      if (jobs[job]->j_cleanup)
	{
	  (*jobs[job]->j_cleanup) (jobs[job]->cleanarg);
	  jobs[job]->j_cleanup = (sh_vptrfunc_t *)NULL;
	}
    }

  /*
   * CLEANUP
   *
   * Currently, we just do special things if we got a SIGINT while waiting
   * for a foreground job to complete
   */

  if (JOBSTATE (job) == JDEAD)
    {
      /* If we're running a shell script and we get a SIGINT with a
	 SIGINT trap handler, but the foreground job handles it and
	 does not exit due to SIGINT, run the trap handler but do not
	 otherwise act as if we got the interrupt. */
      if (wait_sigint_received && interactive_shell == 0 &&
	  child_caught_sigint && IS_FOREGROUND (job) &&
	  signal_is_trapped (SIGINT))
	{
	  int old_frozen;
	  wait_sigint_received = 0;
	  last_command_exit_value = process_exit_status (child->status);

	  old_frozen = jobs_list_frozen;
	  jobs_list_frozen = 1;
	  tstatus = maybe_call_trap_handler (SIGINT);
	  jobs_list_frozen = old_frozen;
	}

      /* If the foreground job is killed by SIGINT when job control is not
	 active, we need to perform some special handling.

	 The check of wait_sigint_received is a way to determine if the
	 SIGINT came from the keyboard (in which case the shell has already
	 seen it, and wait_sigint_received is non-zero, because keyboard
	 signals are sent to process groups) or via kill(2) to the foreground
	 process by another process (or itself).  If the shell did receive the
	 SIGINT, it needs to perform normal SIGINT processing.  XXX - should
	 this change its behavior depending on whether the last command in an
	 pipeline exited due to SIGINT, or any process in the pipeline?  Right
	 now it does this if any process in the pipeline exits due to SIGINT. */
      else if (wait_sigint_received &&
	      child_caught_sigint == 0 &&
	      IS_FOREGROUND (job) && IS_JOBCONTROL (job) == 0)
	{
	  int old_frozen;

	  wait_sigint_received = 0;

	  /* If SIGINT is trapped, set the exit status so that the trap
	     handler can see it. */
	  if (signal_is_trapped (SIGINT))
	    last_command_exit_value = process_exit_status (child->status);

	  /* If the signal is trapped, let the trap handler get it no matter
	     what and simply return if the trap handler returns.
	     maybe_call_trap_handler() may cause dead jobs to be removed from
	     the job table because of a call to execute_command.  We work
	     around this by setting JOBS_LIST_FROZEN. */
	  old_frozen = jobs_list_frozen;
	  jobs_list_frozen = 1;
	  tstatus = maybe_call_trap_handler (SIGINT);
	  jobs_list_frozen = old_frozen;
	  if (tstatus == 0 && old_sigint_handler != INVALID_SIGNAL_HANDLER)
	    {
	      /* wait_sigint_handler () has already seen SIGINT and
		 allowed the wait builtin to jump out.  We need to
		 call the original SIGINT handler, if necessary.  If
		 the original handler is SIG_DFL, we need to resend
		 the signal to ourselves. */

	      temp_handler = old_sigint_handler;

	      /* Bogus.  If we've reset the signal handler as the result
		 of a trap caught on SIGINT, then old_sigint_handler
		 will point to trap_handler, which now knows nothing about
		 SIGINT (if we reset the sighandler to the default).
		 In this case, we have to fix things up.  What a crock. */
	      if (temp_handler == trap_handler && signal_is_trapped (SIGINT) == 0)
		  temp_handler = trap_to_sighandler (SIGINT);
	      restore_sigint_handler ();
	      if (temp_handler == SIG_DFL)
		termsig_handler (SIGINT);	/* XXX */
	      else if (temp_handler != SIG_IGN)
		(*temp_handler) (SIGINT);
	    }
	}
    }

  return call_set_current;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\jobs.c:3,992
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\jobs.c:4,165
parsing error 
{
#if defined (ARRAY_VARS)
  register int i;
  register PROCESS *p;

  for (i = 1, p = jobs[j]->pipe; p->next != jobs[j]->pipe; p = p->next, i++)
    ;
  i++;
  if (statsize < i)
    {
      pstatuses = (int *)xrealloc (pstatuses, i * sizeof (int));
      statsize = i;
    }
  i = 0;
  p = jobs[j]->pipe;
  do
    {
      pstatuses[i++] = process_exit_status (p->status);
      p = p->next;
    }
  while (p != jobs[j]->pipe);

  pstatuses[i] = -1;	/* sentinel */
  set_pipestatus_array (pstatuses, i);
#endif
}
warning: parse error {
#if defined (ARRAY_VARS)
  register int i;
  register PROCESS *p;

  for (i = 1, p = jobs[j]->pipe; p->next != jobs[j]->pipe; p = p->next, i++)
    ;
  i++;
  if (statsize < i)
    {
      pstatuses = (int *)xrealloc (pstatuses, i * sizeof (int));
      statsize = i;
    }
  i = 0;
  p = jobs[j]->pipe;
  do
    {
      pstatuses[i++] = process_exit_status (p->status);
      p = p->next;
    }
  while (p != jobs[j]->pipe);

  pstatuses[i] = -1;	/* sentinel */
  set_pipestatus_array (pstatuses, i);
#endif
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\jobs.c:4,167
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\jobs.c:4,195
parsing error 
{
  char *trap_command;
  int i;

  /* Turn off the trap list during the call to parse_and_execute ()
     to avoid potentially infinite recursive calls.  Preserve the
     values of last_command_exit_value, last_made_pid, and the_pipeline
     around the execution of the trap commands. */
  trap_command = savestring (trap_list[SIGCHLD]);

  begin_unwind_frame ("SIGCHLD trap");
  unwind_protect_int (last_command_exit_value);
  unwind_protect_int (last_command_exit_signal);
  unwind_protect_var (last_made_pid);
  unwind_protect_int (jobs_list_frozen);
  unwind_protect_pointer (the_pipeline);
  unwind_protect_pointer (subst_assign_varlist);
  unwind_protect_pointer (this_shell_builtin);
  unwind_protect_pointer (temporary_env);

  /* We have to add the commands this way because they will be run
     in reverse order of adding.  We don't want maybe_set_sigchld_trap ()
     to reference freed memory. */
  add_unwind_protect (xfree, trap_command);
  add_unwind_protect (maybe_set_sigchld_trap, trap_command);

  subst_assign_varlist = (WORD_LIST *)NULL;
  the_pipeline = (PROCESS *)NULL;
  temporary_env = 0;	/* traps should not run with temporary env */

  running_trap = SIGCHLD + 1;

  set_impossible_sigchld_trap ();
  jobs_list_frozen = 1;
  for (i = 0; i < nchild; i++)
    {
      parse_and_execute (savestring (trap_command), "trap", SEVAL_NOHIST|SEVAL_RESETLINE);
    }

  run_unwind_frame ("SIGCHLD trap");
  running_trap = 0;
}
warning: parse error {
  char *trap_command;
  int i;

  /* Turn off the trap list during the call to parse_and_execute ()
     to avoid potentially infinite recursive calls.  Preserve the
     values of last_command_exit_value, last_made_pid, and the_pipeline
     around the execution of the trap commands. */
  trap_command = savestring (trap_list[SIGCHLD]);

  begin_unwind_frame ("SIGCHLD trap");
  unwind_protect_int (last_command_exit_value);
  unwind_protect_int (last_command_exit_signal);
  unwind_protect_var (last_made_pid);
  unwind_protect_int (jobs_list_frozen);
  unwind_protect_pointer (the_pipeline);
  unwind_protect_pointer (subst_assign_varlist);
  unwind_protect_pointer (this_shell_builtin);
  unwind_protect_pointer (temporary_env);

  /* We have to add the commands this way because they will be run
     in reverse order of adding.  We don't want maybe_set_sigchld_trap ()
     to reference freed memory. */
  add_unwind_protect (xfree, trap_command);
  add_unwind_protect (maybe_set_sigchld_trap, trap_command);

  subst_assign_varlist = (WORD_LIST *)NULL;
  the_pipeline = (PROCESS *)NULL;
  temporary_env = 0;	/* traps should not run with temporary env */

  running_trap = SIGCHLD + 1;

  set_impossible_sigchld_trap ();
  jobs_list_frozen = 1;
  for (i = 0; i < nchild; i++)
    {
      parse_and_execute (savestring (trap_command), "trap", SEVAL_NOHIST|SEVAL_RESETLINE);
    }

  run_unwind_frame ("SIGCHLD trap");
  running_trap = 0;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\jobs.c:4,197
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\jobs.c:4,380
parsing error 
{
  pid_t t;
  int t_errno, tty_sigs;

  t_errno = -1;
  shell_pgrp = getpgid (0);

  if (shell_pgrp == -1)
    {
      sys_error (_("initialize_job_control: getpgrp failed"));
      exit (1);
    }

  /* We can only have job control if we are interactive unless we force it. */
  if (interactive == 0 && force == 0)
    {
      job_control = 0;
      original_pgrp = NO_PID;
      shell_tty = fileno (stderr);
      terminal_pgrp = tcgetpgrp (shell_tty);	/* for checking later */
    }
  else
    {
      shell_tty = -1;

      /* If forced_interactive is set, we skip the normal check that stderr
	 is attached to a tty, so we need to check here.  If it's not, we
	 need to see whether we have a controlling tty by opening /dev/tty,
	 since trying to use job control tty pgrp manipulations on a non-tty
	 is going to fail. */
      if (forced_interactive && isatty (fileno (stderr)) == 0)
	shell_tty = open ("/dev/tty", O_RDWR|O_NONBLOCK);

      /* Get our controlling terminal.  If job_control is set, or
	 interactive is set, then this is an interactive shell no
	 matter where fd 2 is directed. */
      if (shell_tty == -1)
	shell_tty = dup (fileno (stderr));	/* fd 2 */

      if (shell_tty != -1)
	shell_tty = move_to_high_fd (shell_tty, 1, -1);

      /* Compensate for a bug in systems that compiled the BSD
	 rlogind with DEBUG defined, like NeXT and Alliant. */
      if (shell_pgrp == 0)
	{
	  shell_pgrp = getpid ();
	  setpgid (0, shell_pgrp);
	  if (shell_tty != -1)
	    tcsetpgrp (shell_tty, shell_pgrp);
	}

      tty_sigs = 0;
      while ((terminal_pgrp = tcgetpgrp (shell_tty)) != -1)
	{
	  if (shell_pgrp != terminal_pgrp)
	    {
	      SigHandler *ottin;

	      CHECK_TERMSIG;
	      ottin = set_signal_handler (SIGTTIN, SIG_DFL);
	      kill (0, SIGTTIN);
	      set_signal_handler (SIGTTIN, ottin);
	      if (tty_sigs++ > 16)
		{
		  sys_error (_("initialize_job_control: no job control in background"));
		  job_control = 0;
		  original_pgrp = terminal_pgrp;	/* for eventual give_terminal_to */
		  goto just_bail;
		}
	      continue;
	    }
	  break;
	}

      if (terminal_pgrp == -1)
	t_errno = errno;

      /* Make sure that we are using the new line discipline. */
      if (set_new_line_discipline (shell_tty) < 0)
	{
	  sys_error (_("initialize_job_control: line discipline"));
	  job_control = 0;
	}
      else
	{
	  original_pgrp = shell_pgrp;
	  shell_pgrp = getpid ();

	  if ((original_pgrp != shell_pgrp) && (setpgid (0, shell_pgrp) < 0))
	    {
	      sys_error (_("initialize_job_control: setpgid"));
	      shell_pgrp = original_pgrp;
	    }

	  job_control = 1;

	  /* If (and only if) we just set our process group to our pid,
	     thereby becoming a process group leader, and the terminal
	     is not in the same process group as our (new) process group,
	     then set the terminal's process group to our (new) process
	     group.  If that fails, set our process group back to what it
	     was originally (so we can still read from the terminal) and
	     turn off job control.  */
	  if (shell_pgrp != original_pgrp && shell_pgrp != terminal_pgrp)
	    {
	      if (give_terminal_to (shell_pgrp, 0) < 0)
		{
		  t_errno = errno;
		  setpgid (0, original_pgrp);
		  shell_pgrp = original_pgrp;
		  errno = t_errno;
		  sys_error (_("cannot set terminal process group (%d)"), shell_pgrp);
		  job_control = 0;
		}
	    }

	  if (job_control && ((t = tcgetpgrp (shell_tty)) == -1 || t != shell_pgrp))
	    {
	      if (t_errno != -1)
		errno = t_errno;
	      sys_error (_("cannot set terminal process group (%d)"), t);
	      job_control = 0;
	    }
	}
      if (job_control == 0)
	internal_error (_("no job control in this shell"));
    }

just_bail:
  running_in_background = terminal_pgrp != shell_pgrp;

  if (shell_tty != fileno (stderr))
    SET_CLOSE_ON_EXEC (shell_tty);

  set_signal_handler (SIGCHLD, sigchld_handler);

  change_flag ('m', job_control ? '-' : '+');

  if (interactive)
    get_tty_state ();

  set_maxchild (0);

  return job_control;
}
warning: parse error {
  pid_t t;
  int t_errno, tty_sigs;

  t_errno = -1;
  shell_pgrp = getpgid (0);

  if (shell_pgrp == -1)
    {
      sys_error (_("initialize_job_control: getpgrp failed"));
      exit (1);
    }

  /* We can only have job control if we are interactive unless we force it. */
  if (interactive == 0 && force == 0)
    {
      job_control = 0;
      original_pgrp = NO_PID;
      shell_tty = fileno (stderr);
      terminal_pgrp = tcgetpgrp (shell_tty);	/* for checking later */
    }
  else
    {
      shell_tty = -1;

      /* If forced_interactive is set, we skip the normal check that stderr
	 is attached to a tty, so we need to check here.  If it's not, we
	 need to see whether we have a controlling tty by opening /dev/tty,
	 since trying to use job control tty pgrp manipulations on a non-tty
	 is going to fail. */
      if (forced_interactive && isatty (fileno (stderr)) == 0)
	shell_tty = open ("/dev/tty", O_RDWR|O_NONBLOCK);

      /* Get our controlling terminal.  If job_control is set, or
	 interactive is set, then this is an interactive shell no
	 matter where fd 2 is directed. */
      if (shell_tty == -1)
	shell_tty = dup (fileno (stderr));	/* fd 2 */

      if (shell_tty != -1)
	shell_tty = move_to_high_fd (shell_tty, 1, -1);

      /* Compensate for a bug in systems that compiled the BSD
	 rlogind with DEBUG defined, like NeXT and Alliant. */
      if (shell_pgrp == 0)
	{
	  shell_pgrp = getpid ();
	  setpgid (0, shell_pgrp);
	  if (shell_tty != -1)
	    tcsetpgrp (shell_tty, shell_pgrp);
	}

      tty_sigs = 0;
      while ((terminal_pgrp = tcgetpgrp (shell_tty)) != -1)
	{
	  if (shell_pgrp != terminal_pgrp)
	    {
	      SigHandler *ottin;

	      CHECK_TERMSIG;
	      ottin = set_signal_handler (SIGTTIN, SIG_DFL);
	      kill (0, SIGTTIN);
	      set_signal_handler (SIGTTIN, ottin);
	      if (tty_sigs++ > 16)
		{
		  sys_error (_("initialize_job_control: no job control in background"));
		  job_control = 0;
		  original_pgrp = terminal_pgrp;	/* for eventual give_terminal_to */
		  goto just_bail;
		}
	      continue;
	    }
	  break;
	}

      if (terminal_pgrp == -1)
	t_errno = errno;

      /* Make sure that we are using the new line discipline. */
      if (set_new_line_discipline (shell_tty) < 0)
	{
	  sys_error (_("initialize_job_control: line discipline"));
	  job_control = 0;
	}
      else
	{
	  original_pgrp = shell_pgrp;
	  shell_pgrp = getpid ();

	  if ((original_pgrp != shell_pgrp) && (setpgid (0, shell_pgrp) < 0))
	    {
	      sys_error (_("initialize_job_control: setpgid"));
	      shell_pgrp = original_pgrp;
	    }

	  job_control = 1;

	  /* If (and only if) we just set our process group to our pid,
	     thereby becoming a process group leader, and the terminal
	     is not in the same process group as our (new) process group,
	     then set the terminal's process group to our (new) process
	     group.  If that fails, set our process group back to what it
	     was originally (so we can still read from the terminal) and
	     turn off job control.  */
	  if (shell_pgrp != original_pgrp && shell_pgrp != terminal_pgrp)
	    {
	      if (give_terminal_to (shell_pgrp, 0) < 0)
		{
		  t_errno = errno;
		  setpgid (0, original_pgrp);
		  shell_pgrp = original_pgrp;
		  errno = t_errno;
		  sys_error (_("cannot set terminal process group (%d)"), shell_pgrp);
		  job_control = 0;
		}
	    }

	  if (job_control && ((t = tcgetpgrp (shell_tty)) == -1 || t != shell_pgrp))
	    {
	      if (t_errno != -1)
		errno = t_errno;
	      sys_error (_("cannot set terminal process group (%d)"), t);
	      job_control = 0;
	    }
	}
      if (job_control == 0)
	internal_error (_("no job control in this shell"));
    }

just_bail:
  running_in_background = terminal_pgrp != shell_pgrp;

  if (shell_tty != fileno (stderr))
    SET_CLOSE_ON_EXEC (shell_tty);

  set_signal_handler (SIGCHLD, sigchld_handler);

  change_flag ('m', job_control ? '-' : '+');

  if (interactive)
    get_tty_state ();

  set_maxchild (0);

  return job_control;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\jobs.c:4,382
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\jobs.c:4,543
parsing error 
{
#if defined (NEW_TTY_DRIVER)
  int ldisc;

  if (ioctl (tty, TIOCGETD, &ldisc) < 0)
    return (-1);

  if (ldisc != NTTYDISC)
    {
      ldisc = NTTYDISC;

      if (ioctl (tty, TIOCSETD, &ldisc) < 0)
	return (-1);
    }
  return (0);
#endif /* NEW_TTY_DRIVER */

#if defined (TERMIO_TTY_DRIVER)
#  if defined (TERMIO_LDISC) && (NTTYDISC)
  if (ioctl (tty, TCGETA, &shell_tty_info) < 0)
    return (-1);

  if (shell_tty_info.c_line != NTTYDISC)
    {
      shell_tty_info.c_line = NTTYDISC;
      if (ioctl (tty, TCSETAW, &shell_tty_info) < 0)
	return (-1);
    }
#  endif /* TERMIO_LDISC && NTTYDISC */
  return (0);
#endif /* TERMIO_TTY_DRIVER */

#if defined (TERMIOS_TTY_DRIVER)
#  if defined (TERMIOS_LDISC) && defined (NTTYDISC)
  if (tcgetattr (tty, &shell_tty_info) < 0)
    return (-1);

  if (shell_tty_info.c_line != NTTYDISC)
    {
      shell_tty_info.c_line = NTTYDISC;
      if (tcsetattr (tty, TCSADRAIN, &shell_tty_info) < 0)
	return (-1);
    }
#  endif /* TERMIOS_LDISC && NTTYDISC */
  return (0);
#endif /* TERMIOS_TTY_DRIVER */

#if !defined (NEW_TTY_DRIVER) && !defined (TERMIO_TTY_DRIVER) && !defined (TERMIOS_TTY_DRIVER)
  return (-1);
#endif
}
warning: parse error {
#if defined (NEW_TTY_DRIVER)
  int ldisc;

  if (ioctl (tty, TIOCGETD, &ldisc) < 0)
    return (-1);

  if (ldisc != NTTYDISC)
    {
      ldisc = NTTYDISC;

      if (ioctl (tty, TIOCSETD, &ldisc) < 0)
	return (-1);
    }
  return (0);
#endif /* NEW_TTY_DRIVER */

#if defined (TERMIO_TTY_DRIVER)
#  if defined (TERMIO_LDISC) && (NTTYDISC)
  if (ioctl (tty, TCGETA, &shell_tty_info) < 0)
    return (-1);

  if (shell_tty_info.c_line != NTTYDISC)
    {
      shell_tty_info.c_line = NTTYDISC;
      if (ioctl (tty, TCSETAW, &shell_tty_info) < 0)
	return (-1);
    }
#  endif /* TERMIO_LDISC && NTTYDISC */
  return (0);
#endif /* TERMIO_TTY_DRIVER */

#if defined (TERMIOS_TTY_DRIVER)
#  if defined (TERMIOS_LDISC) && defined (NTTYDISC)
  if (tcgetattr (tty, &shell_tty_info) < 0)
    return (-1);

  if (shell_tty_info.c_line != NTTYDISC)
    {
      shell_tty_info.c_line = NTTYDISC;
      if (tcsetattr (tty, TCSADRAIN, &shell_tty_info) < 0)
	return (-1);
    }
#  endif /* TERMIOS_LDISC && NTTYDISC */
  return (0);
#endif /* TERMIOS_TTY_DRIVER */

#if !defined (NEW_TTY_DRIVER) && !defined (TERMIO_TTY_DRIVER) && !defined (TERMIOS_TTY_DRIVER)
  return (-1);
#endif
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\jobs.c:4,545
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\jobs.c:4,620
parsing error 
{
  initialize_job_signals ();
  set_signal_handler (SIGCONT, old_cont);
  kill (getpid (), SIGCONT);

  SIGRETURN (0);
}
warning: parse error {
  initialize_job_signals ();
  set_signal_handler (SIGCONT, old_cont);
  kill (getpid (), SIGCONT);

  SIGRETURN (0);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\jobs.c:4,622
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\jobs.c:4,632
parsing error 
{
  set_signal_handler (SIGTSTP, old_tstp);
  set_signal_handler (SIGTTOU, old_ttou);
  set_signal_handler (SIGTTIN, old_ttin);

  old_cont = set_signal_handler (SIGCONT, sigcont_sighandler);

  give_terminal_to (shell_pgrp, 0);

  kill (getpid (), sig);

  SIGRETURN (0);
}
warning: parse error {
  set_signal_handler (SIGTSTP, old_tstp);
  set_signal_handler (SIGTTOU, old_ttou);
  set_signal_handler (SIGTTIN, old_ttin);

  old_cont = set_signal_handler (SIGCONT, sigcont_sighandler);

  give_terminal_to (shell_pgrp, 0);

  kill (getpid (), sig);

  SIGRETURN (0);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\jobs.c:4,634
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\jobs.c:4,650
parsing error 
{
  sigset_t set, oset;
  int r, e;

  r = 0;
  if (job_control || force)
    {
      sigemptyset (&set);
      sigaddset (&set, SIGTTOU);
      sigaddset (&set, SIGTTIN);
      sigaddset (&set, SIGTSTP);
      sigaddset (&set, SIGCHLD);
      sigemptyset (&oset);
      sigprocmask (SIG_BLOCK, &set, &oset);

      if (tcsetpgrp (shell_tty, pgrp) < 0)
	{
	  /* Maybe we should print an error message? */
#if 0
	  sys_error ("tcsetpgrp(%d) failed: pid %ld to pgrp %ld",
	    shell_tty, (long)getpid(), (long)pgrp);
#endif
	  r = -1;
	  e = errno;
	}
      else
	terminal_pgrp = pgrp;
      sigprocmask (SIG_SETMASK, &oset, (sigset_t *)NULL);
    }

  if (r == -1)
    errno = e;

  return r;
}
warning: parse error {
  sigset_t set, oset;
  int r, e;

  r = 0;
  if (job_control || force)
    {
      sigemptyset (&set);
      sigaddset (&set, SIGTTOU);
      sigaddset (&set, SIGTTIN);
      sigaddset (&set, SIGTSTP);
      sigaddset (&set, SIGCHLD);
      sigemptyset (&oset);
      sigprocmask (SIG_BLOCK, &set, &oset);

      if (tcsetpgrp (shell_tty, pgrp) < 0)
	{
	  /* Maybe we should print an error message? */
#if 0
	  sys_error ("tcsetpgrp(%d) failed: pid %ld to pgrp %ld",
	    shell_tty, (long)getpid(), (long)pgrp);
#endif
	  r = -1;
	  e = errno;
	}
      else
	terminal_pgrp = pgrp;
      sigprocmask (SIG_SETMASK, &oset, (sigset_t *)NULL);
    }

  if (r == -1)
    errno = e;

  return r;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\jobs.c:4,653
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\jobs.c:4,692
parsing error 
{
  int tpgrp;

  tpgrp = tcgetpgrp (shell_tty);
  if (tpgrp < 0 && errno == ENOTTY)
    return -1;
  if (tpgrp == npgrp)
    {
      terminal_pgrp = npgrp;
      return 0;
    }
  else if (tpgrp != opgrp)
    {
#if defined (DEBUG)
      internal_warning ("%d: maybe_give_terminal_to: terminal pgrp == %d shell pgrp = %d new pgrp = %d in_background = %d", (int)getpid(), tpgrp, opgrp, npgrp, running_in_background);
#endif
      return -1;
    }
  else
    return (give_terminal_to (npgrp, flags));     
}
warning: parse error {
  int tpgrp;

  tpgrp = tcgetpgrp (shell_tty);
  if (tpgrp < 0 && errno == ENOTTY)
    return -1;
  if (tpgrp == npgrp)
    {
      terminal_pgrp = npgrp;
      return 0;
    }
  else if (tpgrp != opgrp)
    {
#if defined (DEBUG)
      internal_warning ("%d: maybe_give_terminal_to: terminal pgrp == %d shell pgrp = %d new pgrp = %d in_background = %d", (int)getpid(), tpgrp, opgrp, npgrp, running_in_background);
#endif
      return -1;
    }
  else
    return (give_terminal_to (npgrp, flags));     
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\jobs.c:4,695
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\jobs.c:4,723
parsing error 
{
  register int i;
  sigset_t set, oset;

  BLOCK_CHILD (set, oset);

  /* XXX - need to set j_lastj, j_firstj appropriately if running_only != 0. */
  if (js.j_jobslots)
    {
      js.j_current = js.j_previous = NO_JOB;

      /* XXX could use js.j_firstj here */
      for (i = 0; i < js.j_jobslots; i++)
	{
#if defined (DEBUG)
	  if (i < js.j_firstj && jobs[i])
	    itrace("delete_all_jobs: job %d non-null before js.j_firstj (%d)", i, js.j_firstj);
	  if (i > js.j_lastj && jobs[i])
	    itrace("delete_all_jobs: job %d non-null after js.j_lastj (%d)", i, js.j_lastj);
#endif
	  if (jobs[i] && (running_only == 0 || (running_only && RUNNING(i))))
	    /* We don't want to add any of these pids to bgpids.  If running_only
	       is non-zero, we don't want to add running jobs to the list.
	       If we are interested in all jobs, not just running jobs, and
	       we are going to clear the bgpids list below (bgp_clear()), we
	       don't need to bother. */
	    delete_job (i, DEL_WARNSTOPPED|DEL_NOBGPID);
	}
      if (running_only == 0)
	{
	  free ((char *)jobs);
	  js.j_jobslots = 0;
	  js.j_firstj = js.j_lastj = js.j_njobs = 0;
	}
    }

  if (running_only == 0)
    bgp_clear ();

  UNBLOCK_CHILD (oset);
}
warning: parse error {
  register int i;
  sigset_t set, oset;

  BLOCK_CHILD (set, oset);

  /* XXX - need to set j_lastj, j_firstj appropriately if running_only != 0. */
  if (js.j_jobslots)
    {
      js.j_current = js.j_previous = NO_JOB;

      /* XXX could use js.j_firstj here */
      for (i = 0; i < js.j_jobslots; i++)
	{
#if defined (DEBUG)
	  if (i < js.j_firstj && jobs[i])
	    itrace("delete_all_jobs: job %d non-null before js.j_firstj (%d)", i, js.j_firstj);
	  if (i > js.j_lastj && jobs[i])
	    itrace("delete_all_jobs: job %d non-null after js.j_lastj (%d)", i, js.j_lastj);
#endif
	  if (jobs[i] && (running_only == 0 || (running_only && RUNNING(i))))
	    /* We don't want to add any of these pids to bgpids.  If running_only
	       is non-zero, we don't want to add running jobs to the list.
	       If we are interested in all jobs, not just running jobs, and
	       we are going to clear the bgpids list below (bgp_clear()), we
	       don't need to bother. */
	    delete_job (i, DEL_WARNSTOPPED|DEL_NOBGPID);
	}
      if (running_only == 0)
	{
	  free ((char *)jobs);
	  js.j_jobslots = 0;
	  js.j_firstj = js.j_lastj = js.j_njobs = 0;
	}
    }

  if (running_only == 0)
    bgp_clear ();

  UNBLOCK_CHILD (oset);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\jobs.c:4,725
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\jobs.c:4,770
parsing error 
{
  register int i;
  sigset_t set, oset;

  BLOCK_CHILD (set, oset);

  if (js.j_jobslots)
    {
      /* XXX could use js.j_firstj here */
      for (i = 0; i < js.j_jobslots; i++)
	if (jobs[i] && (running_only == 0 || (running_only && RUNNING(i))))
	  nohup_job (i);
    }

  UNBLOCK_CHILD (oset);
}
warning: parse error {
  register int i;
  sigset_t set, oset;

  BLOCK_CHILD (set, oset);

  if (js.j_jobslots)
    {
      /* XXX could use js.j_firstj here */
      for (i = 0; i < js.j_jobslots; i++)
	if (jobs[i] && (running_only == 0 || (running_only && RUNNING(i))))
	  nohup_job (i);
    }

  UNBLOCK_CHILD (oset);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\jobs.c:4,772
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\jobs.c:4,840
parsing error 
{
  register int i, ndead, ndeadproc;
  sigset_t set, oset;

  if (js.j_jobslots == 0)
    return;

  BLOCK_CHILD (set, oset);

  /* If FORCE is non-zero, we don't have to keep CHILD_MAX statuses
     around; just run through the array. */
  if (force)
    {
    /* XXX could use js.j_firstj here */
      for (i = 0; i < js.j_jobslots; i++)
	{
	  if (jobs[i] && DEADJOB (i) && (interactive_shell || (find_last_pid (i, 0) != last_asynchronous_pid)))
	    jobs[i]->flags |= J_NOTIFIED;
	}
      UNBLOCK_CHILD (oset);
      return;
    }

  /* Mark enough dead jobs as notified to keep CHILD_MAX processes left in the
     array with the corresponding not marked as notified.  This is a better
     way to avoid pid aliasing and reuse problems than keeping the POSIX-
     mandated CHILD_MAX jobs around.  delete_job() takes care of keeping the
     bgpids list regulated. */

  /* Count the number of dead jobs */
  /* XXX could use js.j_firstj here */
  for (i = ndead = ndeadproc = 0; i < js.j_jobslots; i++)
    {
#if defined (DEBUG)
      if (i < js.j_firstj && jobs[i])
	itrace("mark_dead_jobs_as_notified: job %d non-null before js.j_firstj (%d)", i, js.j_firstj);
      if (i > js.j_lastj && jobs[i])
	itrace("mark_dead_jobs_as_notified: job %d non-null after js.j_lastj (%d)", i, js.j_lastj);
#endif
      if (jobs[i] && DEADJOB (i))
	{
	  ndead++;
	  ndeadproc += processes_in_job (i);
	}
    }

#ifdef DEBUG
# if 0
  if (ndeadproc != js.c_reaped)
    itrace("mark_dead_jobs_as_notified: ndeadproc (%d) != js.c_reaped (%d)", ndeadproc, js.c_reaped);
# endif
  if (ndead != js.j_ndead)
    itrace("mark_dead_jobs_as_notified: ndead (%d) != js.j_ndead (%d)", ndead, js.j_ndead);
#endif

  if (js.c_childmax < 0)
    set_maxchild (0);

  /* Don't do anything if the number of dead processes is less than CHILD_MAX
     and we're not forcing a cleanup. */
  if (ndeadproc <= js.c_childmax)
    {
      UNBLOCK_CHILD (oset);
      return;
    }

#if 0
itrace("mark_dead_jobs_as_notified: child_max = %d ndead = %d ndeadproc = %d", js.c_childmax, ndead, ndeadproc);
#endif

  /* Mark enough dead jobs as notified that we keep CHILD_MAX jobs in
     the list.  This isn't exactly right yet; changes need to be made
     to stop_pipeline so we don't mark the newer jobs after we've
     created CHILD_MAX slots in the jobs array.  This needs to be
     integrated with a way to keep the jobs array from growing without
     bound.  Maybe we wrap back around to 0 after we reach some max
     limit, and there are sufficient job slots free (keep track of total
     size of jobs array (js.j_jobslots) and running count of number of jobs
     in jobs array.  Then keep a job index corresponding to the `oldest job'
     and start this loop there, wrapping around as necessary.  In effect,
     we turn the list into a circular buffer. */
  /* XXX could use js.j_firstj here */
  for (i = 0; i < js.j_jobslots; i++)
    {
      if (jobs[i] && DEADJOB (i) && (interactive_shell || (find_last_pid (i, 0) != last_asynchronous_pid)))
	{
#if defined (DEBUG)
	  if (i < js.j_firstj && jobs[i])
	    itrace("mark_dead_jobs_as_notified: job %d non-null before js.j_firstj (%d)", i, js.j_firstj);
	  if (i > js.j_lastj && jobs[i])
	    itrace("mark_dead_jobs_as_notified: job %d non-null after js.j_lastj (%d)", i, js.j_lastj);
#endif
	  /* If marking this job as notified would drop us down below
	     child_max, don't mark it so we can keep at least child_max
	     statuses.  XXX -- need to check what Posix actually says
	     about keeping statuses. */
	  if ((ndeadproc -= processes_in_job (i)) <= js.c_childmax)
	    break;
	  jobs[i]->flags |= J_NOTIFIED;
	}
    }

  UNBLOCK_CHILD (oset);
}
warning: parse error {
  register int i, ndead, ndeadproc;
  sigset_t set, oset;

  if (js.j_jobslots == 0)
    return;

  BLOCK_CHILD (set, oset);

  /* If FORCE is non-zero, we don't have to keep CHILD_MAX statuses
     around; just run through the array. */
  if (force)
    {
    /* XXX could use js.j_firstj here */
      for (i = 0; i < js.j_jobslots; i++)
	{
	  if (jobs[i] && DEADJOB (i) && (interactive_shell || (find_last_pid (i, 0) != last_asynchronous_pid)))
	    jobs[i]->flags |= J_NOTIFIED;
	}
      UNBLOCK_CHILD (oset);
      return;
    }

  /* Mark enough dead jobs as notified to keep CHILD_MAX processes left in the
     array with the corresponding not marked as notified.  This is a better
     way to avoid pid aliasing and reuse problems than keeping the POSIX-
     mandated CHILD_MAX jobs around.  delete_job() takes care of keeping the
     bgpids list regulated. */

  /* Count the number of dead jobs */
  /* XXX could use js.j_firstj here */
  for (i = ndead = ndeadproc = 0; i < js.j_jobslots; i++)
    {
#if defined (DEBUG)
      if (i < js.j_firstj && jobs[i])
	itrace("mark_dead_jobs_as_notified: job %d non-null before js.j_firstj (%d)", i, js.j_firstj);
      if (i > js.j_lastj && jobs[i])
	itrace("mark_dead_jobs_as_notified: job %d non-null after js.j_lastj (%d)", i, js.j_lastj);
#endif
      if (jobs[i] && DEADJOB (i))
	{
	  ndead++;
	  ndeadproc += processes_in_job (i);
	}
    }

#ifdef DEBUG
# if 0
  if (ndeadproc != js.c_reaped)
    itrace("mark_dead_jobs_as_notified: ndeadproc (%d) != js.c_reaped (%d)", ndeadproc, js.c_reaped);
# endif
  if (ndead != js.j_ndead)
    itrace("mark_dead_jobs_as_notified: ndead (%d) != js.j_ndead (%d)", ndead, js.j_ndead);
#endif

  if (js.c_childmax < 0)
    set_maxchild (0);

  /* Don't do anything if the number of dead processes is less than CHILD_MAX
     and we're not forcing a cleanup. */
  if (ndeadproc <= js.c_childmax)
    {
      UNBLOCK_CHILD (oset);
      return;
    }

#if 0
itrace("mark_dead_jobs_as_notified: child_max = %d ndead = %d ndeadproc = %d", js.c_childmax, ndead, ndeadproc);
#endif

  /* Mark enough dead jobs as notified that we keep CHILD_MAX jobs in
     the list.  This isn't exactly right yet; changes need to be made
     to stop_pipeline so we don't mark the newer jobs after we've
     created CHILD_MAX slots in the jobs array.  This needs to be
     integrated with a way to keep the jobs array from growing without
     bound.  Maybe we wrap back around to 0 after we reach some max
     limit, and there are sufficient job slots free (keep track of total
     size of jobs array (js.j_jobslots) and running count of number of jobs
     in jobs array.  Then keep a job index corresponding to the `oldest job'
     and start this loop there, wrapping around as necessary.  In effect,
     we turn the list into a circular buffer. */
  /* XXX could use js.j_firstj here */
  for (i = 0; i < js.j_jobslots; i++)
    {
      if (jobs[i] && DEADJOB (i) && (interactive_shell || (find_last_pid (i, 0) != last_asynchronous_pid)))
	{
#if defined (DEBUG)
	  if (i < js.j_firstj && jobs[i])
	    itrace("mark_dead_jobs_as_notified: job %d non-null before js.j_firstj (%d)", i, js.j_firstj);
	  if (i > js.j_lastj && jobs[i])
	    itrace("mark_dead_jobs_as_notified: job %d non-null after js.j_lastj (%d)", i, js.j_lastj);
#endif
	  /* If marking this job as notified would drop us down below
	     child_max, don't mark it so we can keep at least child_max
	     statuses.  XXX -- need to check what Posix actually says
	     about keeping statuses. */
	  if ((ndeadproc -= processes_in_job (i)) <= js.c_childmax)
	    break;
	  jobs[i]->flags |= J_NOTIFIED;
	}
    }

  UNBLOCK_CHILD (oset);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\jobs.c:4,842
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\jobs.c:4,966
parsing error 
{
  jobs_list_frozen = s;
}
warning: parse error {
  jobs_list_frozen = s;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\jobs.c:4,968
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\jobs.c:4,975
parsing error 
{
  int old;

  old = job_control;
  job_control = arg;

  if (terminal_pgrp == NO_PID)
    terminal_pgrp = tcgetpgrp (shell_tty);

  /* If we're turning on job control we're going to want to know the shell's
     process group. */
  if (job_control != old && job_control)
    shell_pgrp = getpgid (0);  

  running_in_background = (terminal_pgrp != shell_pgrp);

#if 0
  if (interactive_shell == 0 && running_in_background == 0 && job_control != old)
    {
      if (job_control)
	initialize_job_signals ();
      else
	default_tty_job_signals ();
    }
#endif

  /* If we're turning on job control, reset pipeline_pgrp so make_child will
     put new child processes into the right pgrp */
  if (job_control != old && job_control)
    pipeline_pgrp = 0;

  return (old);
}
warning: parse error {
  int old;

  old = job_control;
  job_control = arg;

  if (terminal_pgrp == NO_PID)
    terminal_pgrp = tcgetpgrp (shell_tty);

  /* If we're turning on job control we're going to want to know the shell's
     process group. */
  if (job_control != old && job_control)
    shell_pgrp = getpgid (0);  

  running_in_background = (terminal_pgrp != shell_pgrp);

#if 0
  if (interactive_shell == 0 && running_in_background == 0 && job_control != old)
    {
      if (job_control)
	initialize_job_signals ();
      else
	default_tty_job_signals ();
    }
#endif

  /* If we're turning on job control, reset pipeline_pgrp so make_child will
     put new child processes into the right pgrp */
  if (job_control != old && job_control)
    pipeline_pgrp = 0;

  return (old);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\jobs.c:4,977
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\jobs.c:5,055
parsing error 
{
  static int lmaxchild = -1;

  /* Initialize once. */
  if (lmaxchild < 0)
    {
      errno = 0;
      lmaxchild = getmaxchild ();
      if (lmaxchild < 0 && errno == 0)
        lmaxchild = MAX_CHILD_MAX;		/* assume unlimited */
    }
  if (lmaxchild < 0)
    lmaxchild = DEFAULT_CHILD_MAX;

  /* Clamp value we set.  Minimum is what Posix requires, maximum is defined
     above as MAX_CHILD_MAX. */
  if (nchild < lmaxchild)
    nchild = lmaxchild;
  else if (nchild > MAX_CHILD_MAX)
    nchild = MAX_CHILD_MAX;

  js.c_childmax = nchild;
}
warning: parse error {
  static int lmaxchild = -1;

  /* Initialize once. */
  if (lmaxchild < 0)
    {
      errno = 0;
      lmaxchild = getmaxchild ();
      if (lmaxchild < 0 && errno == 0)
        lmaxchild = MAX_CHILD_MAX;		/* assume unlimited */
    }
  if (lmaxchild < 0)
    lmaxchild = DEFAULT_CHILD_MAX;

  /* Clamp value we set.  Minimum is what Posix requires, maximum is defined
     above as MAX_CHILD_MAX. */
  if (nchild < lmaxchild)
    nchild = lmaxchild;
  else if (nchild > MAX_CHILD_MAX)
    nchild = MAX_CHILD_MAX;

  js.c_childmax = nchild;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\jobs.c:5,057
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\glob\glob.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashtypes.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashansi.h...skip
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\posixdir.h...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\posixstat.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\shmbutil.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\xmalloc.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\filecntl.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\stdc.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\memalloc.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\shell.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\general.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\glob\glob.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\glob\strmatch.h...skip
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\glob\glob_loop.c...
parsing error 
static int INTERNAL_GLOB_PATTERN_P PARAMS((const GCHAR *));
warning: parse error static int INTERNAL_GLOB_PATTERN_P PARAMS((const GCHAR *));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\glob\glob_loop.c:19
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\glob\glob_loop.c:25
parsing error 
{
  register const GCHAR *p;
  register GCHAR c;
  int bopen, bsquote;

  p = pattern;
  bopen = bsquote = 0;

  while ((c = *p++) != L('\0'))
    switch (c)
      {
      case L('?'):
      case L('*'):
	return 1;

      case L('['):      /* Only accept an open brace if there is a close */
	bopen++;        /* brace to match it.  Bracket expressions must be */
	continue;       /* complete, according to Posix.2 */
      case L(']'):
	if (bopen)
	  return 1;
	continue;

      case L('+'):         /* extended matching operators */
      case L('@'):
      case L('!'):
	if (*p == L('('))  /*) */
	  return 1;
	continue;

      case L('\\'):
	/* Don't let the pattern end in a backslash (GMATCH returns no match
	   if the pattern ends in a backslash anyway), but otherwise note that 
	   we have seen this, since the matching engine uses backslash as an
	   escape character and it can be removed. We return 2 later if we
	   have seen only backslash-escaped characters, so interested callers
	   know they can shortcut and just dequote the pathname. */
	if (*p != L('\0'))
	  {
	    p++;
	    bsquote = 1;
	    continue;
	  }
	else 	/* (*p == L('\0')) */
	  return 0;
      }

#if 0
  return bsquote ? 2 : 0;
#else
  return (0);
#endif
}
warning: parse error {
  register const GCHAR *p;
  register GCHAR c;
  int bopen, bsquote;

  p = pattern;
  bopen = bsquote = 0;

  while ((c = *p++) != L('\0'))
    switch (c)
      {
      case L('?'):
      case L('*'):
	return 1;

      case L('['):      /* Only accept an open brace if there is a close */
	bopen++;        /* brace to match it.  Bracket expressions must be */
	continue;       /* complete, according to Posix.2 */
      case L(']'):
	if (bopen)
	  return 1;
	continue;

      case L('+'):         /* extended matching operators */
      case L('@'):
      case L('!'):
	if (*p == L('('))  /*) */
	  return 1;
	continue;

      case L('\\'):
	/* Don't let the pattern end in a backslash (GMATCH returns no match
	   if the pattern ends in a backslash anyway), but otherwise note that 
	   we have seen this, since the matching engine uses backslash as an
	   escape character and it can be removed. We return 2 later if we
	   have seen only backslash-escaped characters, so interested callers
	   know they can shortcut and just dequote the pathname. */
	if (*p != L('\0'))
	  {
	    p++;
	    bsquote = 1;
	    continue;
	  }
	else 	/* (*p == L('\0')) */
	  return 0;
      }

#if 0
  return bsquote ? 2 : 0;
#else
  return (0);
#endif
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\glob\glob_loop.c:26
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\glob\glob_loop.c...skip
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\glob\glob.c:162
parsing error 
{
#if HANDLE_MULTIBYTE
  size_t n;
  wchar_t *wpattern;
  int r;

  if (MB_CUR_MAX == 1 || mbsmbchar (pattern) == 0)
    return (internal_glob_pattern_p ((unsigned char *)pattern));

  /* Convert strings to wide chars, and call the multibyte version. */
  n = xdupmbstowcs (&wpattern, NULL, pattern);
  if (n == (size_t)-1)
    /* Oops.  Invalid multibyte sequence.  Try it as single-byte sequence. */
    return (internal_glob_pattern_p ((unsigned char *)pattern));

  r = internal_glob_wpattern_p (wpattern);
  free (wpattern);

  return r;
#else
  return (internal_glob_pattern_p ((unsigned char *)pattern));
#endif
}
warning: parse error {
#if HANDLE_MULTIBYTE
  size_t n;
  wchar_t *wpattern;
  int r;

  if (MB_CUR_MAX == 1 || mbsmbchar (pattern) == 0)
    return (internal_glob_pattern_p ((unsigned char *)pattern));

  /* Convert strings to wide chars, and call the multibyte version. */
  n = xdupmbstowcs (&wpattern, NULL, pattern);
  if (n == (size_t)-1)
    /* Oops.  Invalid multibyte sequence.  Try it as single-byte sequence. */
    return (internal_glob_pattern_p ((unsigned char *)pattern));

  r = internal_glob_wpattern_p (wpattern);
  free (wpattern);

  return r;
#else
  return (internal_glob_pattern_p ((unsigned char *)pattern));
#endif
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\glob\glob.c:163
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\glob\glob.c:262
parsing error 
{
#if EXTENDED_GLOB
  if (extglob_pattern_p (pat))		/* XXX */
    return (extglob_skipname (pat, dname, flags));
#endif

  if (glob_always_skip_dot_and_dotdot && DOT_OR_DOTDOT (dname))
    return 1;

  /* If a leading dot need not be explicitly matched, and the pattern
     doesn't start with a `.', don't match `.' or `..' */
  if (noglob_dot_filenames == 0 && pat[0] != '.' &&
	(pat[0] != '\\' || pat[1] != '.') &&
	DOT_OR_DOTDOT (dname))
    return 1;

  /* If a dot must be explicitly matched, check to see if they do. */
  else if (noglob_dot_filenames && dname[0] == '.' && pat[0] != '.' &&
	(pat[0] != '\\' || pat[1] != '.'))
    return 1;

  return 0;
}
warning: parse error {
#if EXTENDED_GLOB
  if (extglob_pattern_p (pat))		/* XXX */
    return (extglob_skipname (pat, dname, flags));
#endif

  if (glob_always_skip_dot_and_dotdot && DOT_OR_DOTDOT (dname))
    return 1;

  /* If a leading dot need not be explicitly matched, and the pattern
     doesn't start with a `.', don't match `.' or `..' */
  if (noglob_dot_filenames == 0 && pat[0] != '.' &&
	(pat[0] != '\\' || pat[1] != '.') &&
	DOT_OR_DOTDOT (dname))
    return 1;

  /* If a dot must be explicitly matched, check to see if they do. */
  else if (noglob_dot_filenames && dname[0] == '.' && pat[0] != '.' &&
	(pat[0] != '\\' || pat[1] != '.'))
    return 1;

  return 0;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\glob\glob.c:266
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\glob\glob.c:414
parsing error 
{
  register int i, j;

  for (i = j = 0; pathname && pathname[i]; )
    {
      if (pathname[i] == '\\')
	i++;

      pathname[j++] = pathname[i++];

      if (pathname[i - 1] == 0)
	break;
    }
  if (pathname)
    pathname[j] = '\0';
}
warning: parse error {
  register int i, j;

  for (i = j = 0; pathname && pathname[i]; )
    {
      if (pathname[i] == '\\')
	i++;

      pathname[j++] = pathname[i++];

      if (pathname[i - 1] == 0)
	break;
    }
  if (pathname)
    pathname[j] = '\0';
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\glob\glob.c:416
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\glob\glob.c:524
parsing error 
{
  struct stat finfo;
  int r;

/*itrace("glob_testdir: testing %s" flags = %d, dir, flags);*/
#if defined (HAVE_LSTAT)
  r = (flags & GX_ALLDIRS) ? lstat (dir, &finfo) : stat (dir, &finfo);
#else
  r = stat (dir, &finfo);
#endif
  if (r < 0)
    return (-1);

#if defined (S_ISLNK)
  if (S_ISLNK (finfo.st_mode))
    return (-2);
#endif

  if (S_ISDIR (finfo.st_mode) == 0)
    return (-1);

  return (0);
}
warning: parse error {
  struct stat finfo;
  int r;

/*itrace("glob_testdir: testing %s" flags = %d, dir, flags);*/
#if defined (HAVE_LSTAT)
  r = (flags & GX_ALLDIRS) ? lstat (dir, &finfo) : stat (dir, &finfo);
#else
  r = stat (dir, &finfo);
#endif
  if (r < 0)
    return (-1);

#if defined (S_ISLNK)
  if (S_ISLNK (finfo.st_mode))
    return (-2);
#endif

  if (S_ISDIR (finfo.st_mode) == 0)
    return (-1);

  return (0);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\glob\glob.c:527
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\glob\glob.c:558
parsing error 
{
  char **r, *n;
  int ndirs;
  struct globval *ret, *e, *g;

/*itrace("finddirs: pat = `%s' sdir = `%s' flags = 0x%x", pat, sdir, flags);*/
  e = ret = 0;
  r = glob_vector (pat, sdir, flags);
  if (r == 0 || r[0] == 0)
    {
      if (np)
	*np = 0;
      if (ep)
        *ep = 0;
      if (r && r != &glob_error_return)
	free (r);
      return (struct globval *)0;
    }
  for (ndirs = 0; r[ndirs] != 0; ndirs++)
    {
      g = (struct globval *) malloc (sizeof (struct globval));
      if (g == 0)
	{
	  while (ret)		/* free list built so far */
	    {
	      g = ret->next;
	      free (ret);
	      ret = g;
	    }

	  free (r);
	  if (np)
	    *np = 0;
	  if (ep)
	    *ep = 0;
	  return (&finddirs_error_return);
	}
      if (e == 0)
	e = g;

      g->next = ret;
      ret = g;

      g->name = r[ndirs];
    }

  free (r);
  if (ep)
    *ep = e;
  if (np)
    *np = ndirs;

  return ret;
}
warning: parse error {
  char **r, *n;
  int ndirs;
  struct globval *ret, *e, *g;

/*itrace("finddirs: pat = `%s' sdir = `%s' flags = 0x%x", pat, sdir, flags);*/
  e = ret = 0;
  r = glob_vector (pat, sdir, flags);
  if (r == 0 || r[0] == 0)
    {
      if (np)
	*np = 0;
      if (ep)
        *ep = 0;
      if (r && r != &glob_error_return)
	free (r);
      return (struct globval *)0;
    }
  for (ndirs = 0; r[ndirs] != 0; ndirs++)
    {
      g = (struct globval *) malloc (sizeof (struct globval));
      if (g == 0)
	{
	  while (ret)		/* free list built so far */
	    {
	      g = ret->next;
	      free (ret);
	      ret = g;
	    }

	  free (r);
	  if (np)
	    *np = 0;
	  if (ep)
	    *ep = 0;
	  return (&finddirs_error_return);
	}
      if (e == 0)
	e = g;

      g->next = ret;
      ret = g;

      g->name = r[ndirs];
    }

  free (r);
  if (ep)
    *ep = e;
  if (np)
    *np = ndirs;

  return ret;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\glob\glob.c:564
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\glob\glob.c:636
parsing error 
{
  DIR *d;
  register struct dirent *dp;
  struct globval *lastlink, *e, *dirlist;
  register struct globval *nextlink;
  register char *nextname, *npat, *subdir;
  unsigned int count;
  int lose, skip, ndirs, isdir, sdlen, add_current, patlen;
  register char **name_vector;
  register unsigned int i;
  int mflags;		/* Flags passed to strmatch (). */
  int pflags;		/* flags passed to sh_makepath () */
  int hasglob;		/* return value from glob_pattern_p */
  int nalloca;
  struct globval *firstmalloc, *tmplink;
  char *convfn;

  lastlink = 0;
  count = lose = skip = add_current = 0;

  firstmalloc = 0;
  nalloca = 0;

  name_vector = NULL;

/*itrace("glob_vector: pat = `%s' dir = `%s' flags = 0x%x", pat, dir, flags);*/
  /* If PAT is empty, skip the loop, but return one (empty) filename. */
  if (pat == 0 || *pat == '\0')
    {
      if (glob_testdir (dir, 0) < 0)
	return ((char **) &glob_error_return);

      nextlink = (struct globval *)alloca (sizeof (struct globval));
      if (nextlink == NULL)
	return ((char **) NULL);

      nextlink->next = (struct globval *)0;
      nextname = (char *) malloc (1);
      if (nextname == 0)
	lose = 1;
      else
	{
	  lastlink = nextlink;
	  nextlink->name = nextname;
	  nextname[0] = '\0';
	  count = 1;
	}

      skip = 1;
    }

  patlen = (pat && *pat) ? strlen (pat) : 0;

  /* If the filename pattern (PAT) does not contain any globbing characters,
     or contains a pattern with only backslash escapes (hasglob == 2),
     we can dispense with reading the directory, and just see if there is
     a filename `DIR/PAT'.  If there is, and we can access it, just make the
     vector to return and bail immediately. */
  hasglob = 0;
  if (skip == 0 && ((hasglob = glob_pattern_p (pat)) == 0 || hasglob == 2))
    {
      int dirlen;
      struct stat finfo;

      if (glob_testdir (dir, 0) < 0)
	return ((char **) &glob_error_return);

      dirlen = strlen (dir);
      nextname = (char *)malloc (dirlen + patlen + 2);
      npat = (char *)malloc (patlen + 1);
      if (nextname == 0 || npat == 0)
	{
	  FREE (nextname);
	  FREE (npat);
	  lose = 1;
	}
      else
	{
	  strcpy (npat, pat);
	  dequote_pathname (npat);

	  strcpy (nextname, dir);
	  nextname[dirlen++] = '/';
	  strcpy (nextname + dirlen, npat);

	  if (GLOB_TESTNAME (nextname) >= 0)
	    {
	      free (nextname);
	      nextlink = (struct globval *)alloca (sizeof (struct globval));
	      if (nextlink)
		{
		  nextlink->next = (struct globval *)0;
		  lastlink = nextlink;
		  nextlink->name = npat;
		  count = 1;
		}
	      else
		{
		  free (npat);
		  lose = 1;
		}
	    }
	  else
	    {
	      free (nextname);
	      free (npat);
	    }
	}

      skip = 1;
    }

  if (skip == 0)
    {
      /* Open the directory, punting immediately if we cannot.  If opendir
	 is not robust (i.e., it opens non-directories successfully), test
	 that DIR is a directory and punt if it's not. */
#if defined (OPENDIR_NOT_ROBUST)
      if (glob_testdir (dir, 0) < 0)
	return ((char **) &glob_error_return);
#endif

      d = opendir (dir);
      if (d == NULL)
	return ((char **) &glob_error_return);

      /* Compute the flags that will be passed to strmatch().  We don't
	 need to do this every time through the loop. */
      mflags = (noglob_dot_filenames ? FNM_PERIOD : 0) | FNM_PATHNAME;

#ifdef FNM_CASEFOLD
      if (glob_ignore_case)
	mflags |= FNM_CASEFOLD;
#endif

      if (extended_glob)
	mflags |= FNM_EXTMATCH;

      add_current = ((flags & (GX_ALLDIRS|GX_ADDCURDIR)) == (GX_ALLDIRS|GX_ADDCURDIR));

      /* Scan the directory, finding all names that match.
	 For each name that matches, allocate a struct globval
	 on the stack and store the name in it.
	 Chain those structs together; lastlink is the front of the chain.  */
      while (1)
	{
	  /* Make globbing interruptible in the shell. */
	  if (interrupt_state || terminating_signal)
	    {
	      lose = 1;
	      break;
	    }
	  else if (signal_is_pending (SIGINT))	/* XXX - make SIGINT traps responsive */
	    {
	      lose = 1;
	      break;
	    }

	  dp = readdir (d);
	  if (dp == NULL)
	    break;

	  /* If this directory entry is not to be used, try again. */
	  if (REAL_DIR_ENTRY (dp) == 0)
	    continue;

#if 0
	  if (dp->d_name == 0 || *dp->d_name == 0)
	    continue;
#endif

#if HANDLE_MULTIBYTE
	  if (MB_CUR_MAX > 1 && mbskipname (pat, dp->d_name, flags))
	    continue;
	  else
#endif
	  if (skipname (pat, dp->d_name, flags))
	    continue;

	  /* If we're only interested in directories, don't bother with files */
	  if (flags & (GX_MATCHDIRS|GX_ALLDIRS))
	    {
	      pflags = (flags & GX_ALLDIRS) ? MP_RMDOT : 0;
	      if (flags & GX_NULLDIR)
		pflags |= MP_IGNDOT;
	      subdir = sh_makepath (dir, dp->d_name, pflags);
	      isdir = glob_testdir (subdir, flags);
	      if (isdir < 0 && (flags & GX_MATCHDIRS))
		{
		  free (subdir);
		  continue;
		}
	    }

	  if (flags & GX_ALLDIRS)
	    {
	      if (isdir == 0)
		{
		  dirlist = finddirs (pat, subdir, (flags & ~GX_ADDCURDIR), &e, &ndirs);
		  if (dirlist == &finddirs_error_return)
		    {
		      free (subdir);
		      lose = 1;
		      break;
		    }
		  if (ndirs)		/* add recursive directories to list */
		    {
		      if (firstmalloc == 0)
		        firstmalloc = e;
		      e->next = lastlink;
		      lastlink = dirlist;
		      count += ndirs;
		    }
		}

	      /* XXX - should we even add this if it's not a directory? */
	      nextlink = (struct globval *) malloc (sizeof (struct globval));
	      if (firstmalloc == 0)
		firstmalloc = nextlink;
	      sdlen = strlen (subdir);
	      nextname = (char *) malloc (sdlen + 1);
	      if (nextlink == 0 || nextname == 0)
		{
		  FREE (nextlink);
		  FREE (nextname);
		  free (subdir);
		  lose = 1;
		  break;
		}
	      nextlink->next = lastlink;
	      lastlink = nextlink;
	      nextlink->name = nextname;
	      bcopy (subdir, nextname, sdlen + 1);
	      free (subdir);
	      ++count;
	      continue;
	    }
	  else if (flags & GX_MATCHDIRS)
	    free (subdir);

	  convfn = fnx_fromfs (dp->d_name, D_NAMLEN (dp));
	  if (strmatch (pat, convfn, mflags) != FNM_NOMATCH)
	    {
	      if (nalloca < ALLOCA_MAX)
		{
		  nextlink = (struct globval *) alloca (sizeof (struct globval));
		  nalloca += sizeof (struct globval);
		}
	      else
		{
		  nextlink = (struct globval *) malloc (sizeof (struct globval));
		  if (firstmalloc == 0)
		    firstmalloc = nextlink;
		}

	      nextname = (char *) malloc (D_NAMLEN (dp) + 1);
	      if (nextlink == 0 || nextname == 0)
		{
		  FREE (nextlink);
		  FREE (nextname);
		  lose = 1;
		  break;
		}
	      nextlink->next = lastlink;
	      lastlink = nextlink;
	      nextlink->name = nextname;
	      bcopy (dp->d_name, nextname, D_NAMLEN (dp) + 1);
	      ++count;
	    }
	}

      (void) closedir (d);
    }

  /* compat: if GX_ADDCURDIR, add the passed directory also.  Add an empty
     directory name as a placeholder if GX_NULLDIR (in which case the passed
     directory name is "."). */
  if (add_current)
    {
      sdlen = strlen (dir);
      nextname = (char *)malloc (sdlen + 1);
      nextlink = (struct globval *) malloc (sizeof (struct globval));
      if (nextlink == 0 || nextname == 0)
	{
	  FREE (nextlink);
	  FREE (nextname);
	  lose = 1;
	}
      else
	{
	  nextlink->name = nextname;
	  nextlink->next = lastlink;
	  lastlink = nextlink;
	  if (flags & GX_NULLDIR)
	    nextname[0] = '\0';
	  else
	    bcopy (dir, nextname, sdlen + 1);
	  ++count;
	}
    }

  if (lose == 0)
    {
      name_vector = (char **) malloc ((count + 1) * sizeof (char *));
      lose |= name_vector == NULL;
    }

  /* Have we run out of memory?	 */
  if (lose)
    {
      tmplink = 0;

      /* Here free the strings we have got.  */
      while (lastlink)
	{
	  /* Since we build the list in reverse order, the first N entries
	     will be allocated with malloc, if firstmalloc is set, from
	     lastlink to firstmalloc. */
	  if (firstmalloc)
	    {
	      if (lastlink == firstmalloc)
		firstmalloc = 0;
	      tmplink = lastlink;
	    }
	  else
	    tmplink = 0;
	  free (lastlink->name);
	  lastlink = lastlink->next;
	  FREE (tmplink);
	}

      /* Don't call QUIT; here; let higher layers deal with it. */

      return ((char **)NULL);
    }

  /* Copy the name pointers from the linked list into the vector.  */
  for (tmplink = lastlink, i = 0; i < count; ++i)
    {
      name_vector[i] = tmplink->name;
      tmplink = tmplink->next;
    }

  name_vector[count] = NULL;

  /* If we allocated some of the struct globvals, free them now. */
  if (firstmalloc)
    {
      tmplink = 0;
      while (lastlink)
	{
	  tmplink = lastlink;
	  if (lastlink == firstmalloc)
	    lastlink = firstmalloc = 0;
	  else
	    lastlink = lastlink->next;
	  free (tmplink);
	}
    }

  return (name_vector);
}
warning: parse error {
  DIR *d;
  register struct dirent *dp;
  struct globval *lastlink, *e, *dirlist;
  register struct globval *nextlink;
  register char *nextname, *npat, *subdir;
  unsigned int count;
  int lose, skip, ndirs, isdir, sdlen, add_current, patlen;
  register char **name_vector;
  register unsigned int i;
  int mflags;		/* Flags passed to strmatch (). */
  int pflags;		/* flags passed to sh_makepath () */
  int hasglob;		/* return value from glob_pattern_p */
  int nalloca;
  struct globval *firstmalloc, *tmplink;
  char *convfn;

  lastlink = 0;
  count = lose = skip = add_current = 0;

  firstmalloc = 0;
  nalloca = 0;

  name_vector = NULL;

/*itrace("glob_vector: pat = `%s' dir = `%s' flags = 0x%x", pat, dir, flags);*/
  /* If PAT is empty, skip the loop, but return one (empty) filename. */
  if (pat == 0 || *pat == '\0')
    {
      if (glob_testdir (dir, 0) < 0)
	return ((char **) &glob_error_return);

      nextlink = (struct globval *)alloca (sizeof (struct globval));
      if (nextlink == NULL)
	return ((char **) NULL);

      nextlink->next = (struct globval *)0;
      nextname = (char *) malloc (1);
      if (nextname == 0)
	lose = 1;
      else
	{
	  lastlink = nextlink;
	  nextlink->name = nextname;
	  nextname[0] = '\0';
	  count = 1;
	}

      skip = 1;
    }

  patlen = (pat && *pat) ? strlen (pat) : 0;

  /* If the filename pattern (PAT) does not contain any globbing characters,
     or contains a pattern with only backslash escapes (hasglob == 2),
     we can dispense with reading the directory, and just see if there is
     a filename `DIR/PAT'.  If there is, and we can access it, just make the
     vector to return and bail immediately. */
  hasglob = 0;
  if (skip == 0 && ((hasglob = glob_pattern_p (pat)) == 0 || hasglob == 2))
    {
      int dirlen;
      struct stat finfo;

      if (glob_testdir (dir, 0) < 0)
	return ((char **) &glob_error_return);

      dirlen = strlen (dir);
      nextname = (char *)malloc (dirlen + patlen + 2);
      npat = (char *)malloc (patlen + 1);
      if (nextname == 0 || npat == 0)
	{
	  FREE (nextname);
	  FREE (npat);
	  lose = 1;
	}
      else
	{
	  strcpy (npat, pat);
	  dequote_pathname (npat);

	  strcpy (nextname, dir);
	  nextname[dirlen++] = '/';
	  strcpy (nextname + dirlen, npat);

	  if (GLOB_TESTNAME (nextname) >= 0)
	    {
	      free (nextname);
	      nextlink = (struct globval *)alloca (sizeof (struct globval));
	      if (nextlink)
		{
		  nextlink->next = (struct globval *)0;
		  lastlink = nextlink;
		  nextlink->name = npat;
		  count = 1;
		}
	      else
		{
		  free (npat);
		  lose = 1;
		}
	    }
	  else
	    {
	      free (nextname);
	      free (npat);
	    }
	}

      skip = 1;
    }

  if (skip == 0)
    {
      /* Open the directory, punting immediately if we cannot.  If opendir
	 is not robust (i.e., it opens non-directories successfully), test
	 that DIR is a directory and punt if it's not. */
#if defined (OPENDIR_NOT_ROBUST)
      if (glob_testdir (dir, 0) < 0)
	return ((char **) &glob_error_return);
#endif

      d = opendir (dir);
      if (d == NULL)
	return ((char **) &glob_error_return);

      /* Compute the flags that will be passed to strmatch().  We don't
	 need to do this every time through the loop. */
      mflags = (noglob_dot_filenames ? FNM_PERIOD : 0) | FNM_PATHNAME;

#ifdef FNM_CASEFOLD
      if (glob_ignore_case)
	mflags |= FNM_CASEFOLD;
#endif

      if (extended_glob)
	mflags |= FNM_EXTMATCH;

      add_current = ((flags & (GX_ALLDIRS|GX_ADDCURDIR)) == (GX_ALLDIRS|GX_ADDCURDIR));

      /* Scan the directory, finding all names that match.
	 For each name that matches, allocate a struct globval
	 on the stack and store the name in it.
	 Chain those structs together; lastlink is the front of the chain.  */
      while (1)
	{
	  /* Make globbing interruptible in the shell. */
	  if (interrupt_state || terminating_signal)
	    {
	      lose = 1;
	      break;
	    }
	  else if (signal_is_pending (SIGINT))	/* XXX - make SIGINT traps responsive */
	    {
	      lose = 1;
	      break;
	    }

	  dp = readdir (d);
	  if (dp == NULL)
	    break;

	  /* If this directory entry is not to be used, try again. */
	  if (REAL_DIR_ENTRY (dp) == 0)
	    continue;

#if 0
	  if (dp->d_name == 0 || *dp->d_name == 0)
	    continue;
#endif

#if HANDLE_MULTIBYTE
	  if (MB_CUR_MAX > 1 && mbskipname (pat, dp->d_name, flags))
	    continue;
	  else
#endif
	  if (skipname (pat, dp->d_name, flags))
	    continue;

	  /* If we're only interested in directories, don't bother with files */
	  if (flags & (GX_MATCHDIRS|GX_ALLDIRS))
	    {
	      pflags = (flags & GX_ALLDIRS) ? MP_RMDOT : 0;
	      if (flags & GX_NULLDIR)
		pflags |= MP_IGNDOT;
	      subdir = sh_makepath (dir, dp->d_name, pflags);
	      isdir = glob_testdir (subdir, flags);
	      if (isdir < 0 && (flags & GX_MATCHDIRS))
		{
		  free (subdir);
		  continue;
		}
	    }

	  if (flags & GX_ALLDIRS)
	    {
	      if (isdir == 0)
		{
		  dirlist = finddirs (pat, subdir, (flags & ~GX_ADDCURDIR), &e, &ndirs);
		  if (dirlist == &finddirs_error_return)
		    {
		      free (subdir);
		      lose = 1;
		      break;
		    }
		  if (ndirs)		/* add recursive directories to list */
		    {
		      if (firstmalloc == 0)
		        firstmalloc = e;
		      e->next = lastlink;
		      lastlink = dirlist;
		      count += ndirs;
		    }
		}

	      /* XXX - should we even add this if it's not a directory? */
	      nextlink = (struct globval *) malloc (sizeof (struct globval));
	      if (firstmalloc == 0)
		firstmalloc = nextlink;
	      sdlen = strlen (subdir);
	      nextname = (char *) malloc (sdlen + 1);
	      if (nextlink == 0 || nextname == 0)
		{
		  FREE (nextlink);
		  FREE (nextname);
		  free (subdir);
		  lose = 1;
		  break;
		}
	      nextlink->next = lastlink;
	      lastlink = nextlink;
	      nextlink->name = nextname;
	      bcopy (subdir, nextname, sdlen + 1);
	      free (subdir);
	      ++count;
	      continue;
	    }
	  else if (flags & GX_MATCHDIRS)
	    free (subdir);

	  convfn = fnx_fromfs (dp->d_name, D_NAMLEN (dp));
	  if (strmatch (pat, convfn, mflags) != FNM_NOMATCH)
	    {
	      if (nalloca < ALLOCA_MAX)
		{
		  nextlink = (struct globval *) alloca (sizeof (struct globval));
		  nalloca += sizeof (struct globval);
		}
	      else
		{
		  nextlink = (struct globval *) malloc (sizeof (struct globval));
		  if (firstmalloc == 0)
		    firstmalloc = nextlink;
		}

	      nextname = (char *) malloc (D_NAMLEN (dp) + 1);
	      if (nextlink == 0 || nextname == 0)
		{
		  FREE (nextlink);
		  FREE (nextname);
		  lose = 1;
		  break;
		}
	      nextlink->next = lastlink;
	      lastlink = nextlink;
	      nextlink->name = nextname;
	      bcopy (dp->d_name, nextname, D_NAMLEN (dp) + 1);
	      ++count;
	    }
	}

      (void) closedir (d);
    }

  /* compat: if GX_ADDCURDIR, add the passed directory also.  Add an empty
     directory name as a placeholder if GX_NULLDIR (in which case the passed
     directory name is "."). */
  if (add_current)
    {
      sdlen = strlen (dir);
      nextname = (char *)malloc (sdlen + 1);
      nextlink = (struct globval *) malloc (sizeof (struct globval));
      if (nextlink == 0 || nextname == 0)
	{
	  FREE (nextlink);
	  FREE (nextname);
	  lose = 1;
	}
      else
	{
	  nextlink->name = nextname;
	  nextlink->next = lastlink;
	  lastlink = nextlink;
	  if (flags & GX_NULLDIR)
	    nextname[0] = '\0';
	  else
	    bcopy (dir, nextname, sdlen + 1);
	  ++count;
	}
    }

  if (lose == 0)
    {
      name_vector = (char **) malloc ((count + 1) * sizeof (char *));
      lose |= name_vector == NULL;
    }

  /* Have we run out of memory?	 */
  if (lose)
    {
      tmplink = 0;

      /* Here free the strings we have got.  */
      while (lastlink)
	{
	  /* Since we build the list in reverse order, the first N entries
	     will be allocated with malloc, if firstmalloc is set, from
	     lastlink to firstmalloc. */
	  if (firstmalloc)
	    {
	      if (lastlink == firstmalloc)
		firstmalloc = 0;
	      tmplink = lastlink;
	    }
	  else
	    tmplink = 0;
	  free (lastlink->name);
	  lastlink = lastlink->next;
	  FREE (tmplink);
	}

      /* Don't call QUIT; here; let higher layers deal with it. */

      return ((char **)NULL);
    }

  /* Copy the name pointers from the linked list into the vector.  */
  for (tmplink = lastlink, i = 0; i < count; ++i)
    {
      name_vector[i] = tmplink->name;
      tmplink = tmplink->next;
    }

  name_vector[count] = NULL;

  /* If we allocated some of the struct globvals, free them now. */
  if (firstmalloc)
    {
      tmplink = 0;
      while (lastlink)
	{
	  tmplink = lastlink;
	  if (lastlink == firstmalloc)
	    lastlink = firstmalloc = 0;
	  else
	    lastlink = lastlink->next;
	  free (tmplink);
	}
    }

  return (name_vector);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\glob\glob.c:640
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\glob\glob.c:1,008
parsing error 
{
  register unsigned int i, l;
  int add_slash;
  char **result, *new;
  struct stat sb;

  l = strlen (dir);
  if (l == 0)
    {
      if (flags & GX_MARKDIRS)
	for (i = 0; array[i]; i++)
	  {
	    if ((stat (array[i], &sb) == 0) && S_ISDIR (sb.st_mode))
	      {
		l = strlen (array[i]);
		new = (char *)realloc (array[i], l + 2);
		if (new == 0)
		  return NULL;
		new[l] = '/';
		new[l+1] = '\0';
		array[i] = new;
	      }
	  }
      return (array);
    }

  add_slash = dir[l - 1] != '/';

  i = 0;
  while (array[i] != NULL)
    ++i;

  result = (char **) malloc ((i + 1) * sizeof (char *));
  if (result == NULL)
    return (NULL);

  for (i = 0; array[i] != NULL; i++)
    {
      /* 3 == 1 for NUL, 1 for slash at end of DIR, 1 for GX_MARKDIRS */
      result[i] = (char *) malloc (l + strlen (array[i]) + 3);

      if (result[i] == NULL)
	{
	  int ind;
	  for (ind = 0; ind < i; ind++)
	    free (result[ind]);
	  free (result);
	  return (NULL);
	}

      strcpy (result[i], dir);
      if (add_slash)
	result[i][l] = '/';
      if (array[i][0])
	{
	  strcpy (result[i] + l + add_slash, array[i]);
	  if (flags & GX_MARKDIRS)
	    {
	      if ((stat (result[i], &sb) == 0) && S_ISDIR (sb.st_mode))
		{
		  size_t rlen;
		  rlen = strlen (result[i]);
		  result[i][rlen] = '/';
		  result[i][rlen+1] = '\0';
		}
	    }
	}
      else
        result[i][l+add_slash] = '\0';
    }
  result[i] = NULL;

  /* Free the input array.  */
  for (i = 0; array[i] != NULL; i++)
    free (array[i]);
  free ((char *) array);

  return (result);
}
warning: parse error {
  register unsigned int i, l;
  int add_slash;
  char **result, *new;
  struct stat sb;

  l = strlen (dir);
  if (l == 0)
    {
      if (flags & GX_MARKDIRS)
	for (i = 0; array[i]; i++)
	  {
	    if ((stat (array[i], &sb) == 0) && S_ISDIR (sb.st_mode))
	      {
		l = strlen (array[i]);
		new = (char *)realloc (array[i], l + 2);
		if (new == 0)
		  return NULL;
		new[l] = '/';
		new[l+1] = '\0';
		array[i] = new;
	      }
	  }
      return (array);
    }

  add_slash = dir[l - 1] != '/';

  i = 0;
  while (array[i] != NULL)
    ++i;

  result = (char **) malloc ((i + 1) * sizeof (char *));
  if (result == NULL)
    return (NULL);

  for (i = 0; array[i] != NULL; i++)
    {
      /* 3 == 1 for NUL, 1 for slash at end of DIR, 1 for GX_MARKDIRS */
      result[i] = (char *) malloc (l + strlen (array[i]) + 3);

      if (result[i] == NULL)
	{
	  int ind;
	  for (ind = 0; ind < i; ind++)
	    free (result[ind]);
	  free (result);
	  return (NULL);
	}

      strcpy (result[i], dir);
      if (add_slash)
	result[i][l] = '/';
      if (array[i][0])
	{
	  strcpy (result[i] + l + add_slash, array[i]);
	  if (flags & GX_MARKDIRS)
	    {
	      if ((stat (result[i], &sb) == 0) && S_ISDIR (sb.st_mode))
		{
		  size_t rlen;
		  rlen = strlen (result[i]);
		  result[i][rlen] = '/';
		  result[i][rlen+1] = '\0';
		}
	    }
	}
      else
        result[i][l+add_slash] = '\0';
    }
  result[i] = NULL;

  /* Free the input array.  */
  for (i = 0; array[i] != NULL; i++)
    free (array[i]);
  free ((char *) array);

  return (result);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\glob\glob.c:1,011
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\glob\glob.c:1,097
parsing error 
{
  char **result, **new_result;
  unsigned int result_size;
  char *directory_name, *filename, *dname, *fn;
  unsigned int directory_len;
  int free_dirname;			/* flag */
  int dflags, hasglob;

  result = (char **) malloc (sizeof (char *));
  result_size = 1;
  if (result == NULL)
    return (NULL);

  result[0] = NULL;

  directory_name = NULL;

  /* Find the filename.  */
  filename = strrchr (pathname, '/');
#if defined (EXTENDED_GLOB)
  if (filename && extended_glob)
    {
      fn = glob_dirscan (pathname, '/');
#if DEBUG_MATCHING
      if (fn != filename)
	fprintf (stderr, "glob_filename: glob_dirscan: fn (%s) != filename (%s)\n", fn ? fn : "(null)", filename);
#endif
      filename = fn;
    }
#endif

  if (filename == NULL)
    {
      filename = pathname;
      directory_name = "";
      directory_len = 0;
      free_dirname = 0;
    }
  else
    {
      directory_len = (filename - pathname) + 1;
      directory_name = (char *) malloc (directory_len + 1);

      if (directory_name == 0)		/* allocation failed? */
	{
	  free (result);
	  return (NULL);
	}

      bcopy (pathname, directory_name, directory_len);
      directory_name[directory_len] = '\0';
      ++filename;
      free_dirname = 1;
    }

  hasglob = 0;
  /* If directory_name contains globbing characters, then we
     have to expand the previous levels.  Just recurse.
     If glob_pattern_p returns != [0,1] we have a pattern that has backslash
     quotes but no unquoted glob pattern characters. We dequote it below. */
  if (directory_len > 0 && (hasglob = glob_pattern_p (directory_name)) == 1)
    {
      char **directories, *d, *p;
      register unsigned int i;
      int all_starstar, last_starstar;

      all_starstar = last_starstar = 0;
      d = directory_name;
      dflags = flags & ~GX_MARKDIRS;
      /* Collapse a sequence of ** patterns separated by one or more slashes
	 to a single ** terminated by a slash or NUL */
      if ((flags & GX_GLOBSTAR) && d[0] == '*' && d[1] == '*' && (d[2] == '/' || d[2] == '\0'))
	{
	  p = d;
	  while (d[0] == '*' && d[1] == '*' && (d[2] == '/' || d[2] == '\0'))
	    {
	      p = d;
	      if (d[2])
		{
		  d += 3;
		  while (*d == '/')
		    d++;
		  if (*d == 0)
		    break;
		}
	    }
	  if (*d == 0)
	    all_starstar = 1;
	  d = p;
	  dflags |= GX_ALLDIRS|GX_ADDCURDIR;
	  directory_len = strlen (d);
	}

      /* If there is a non [star][star]/ component in directory_name, we
	 still need to collapse trailing sequences of [star][star]/ into
	 a single one and note that the directory name ends with [star][star],
	 so we can compensate if filename is [star][star] */
      if ((flags & GX_GLOBSTAR) && all_starstar == 0)
	{
	  int dl, prev;
	  prev = dl = directory_len;
	  while (dl >= 4 && d[dl - 1] == '/' &&
			   d[dl - 2] == '*' &&
			   d[dl - 3] == '*' &&
			   d[dl - 4] == '/')
	    prev = dl, dl -= 3;
	  if (dl != directory_len)
	    last_starstar = 1;
	  directory_len = prev;
	}

      /* If the directory name ends in [star][star]/ but the filename is
	 [star][star], just remove the final [star][star] from the directory
	 so we don't have to scan everything twice. */
      if (last_starstar && directory_len > 4 &&
	    filename[0] == '*' && filename[1] == '*' && filename[2] == 0)
	{
	  directory_len -= 3;
	}

      if (d[directory_len - 1] == '/')
	d[directory_len - 1] = '\0';

      directories = glob_filename (d, dflags|GX_RECURSE);

      if (free_dirname)
	{
	  free (directory_name);
	  directory_name = NULL;
	}

      if (directories == NULL)
	goto memory_error;
      else if (directories == (char **)&glob_error_return)
	{
	  free ((char *) result);
	  return ((char **) &glob_error_return);
	}
      else if (*directories == NULL)
	{
	  free ((char *) directories);
	  free ((char *) result);
	  return ((char **) &glob_error_return);
	}

      /* If we have something like [star][star]/[star][star], it's no use to
         glob **, then do it again, and throw half the results away.  */
      if (all_starstar && filename[0] == '*' && filename[1] == '*' && filename[2] == 0)
	{
	  free ((char *) directories);
	  free (directory_name);
	  directory_name = NULL;
	  directory_len = 0;
	  goto only_filename;
	}

      /* We have successfully globbed the preceding directory name.
	 For each name in DIRECTORIES, call glob_vector on it and
	 FILENAME.  Concatenate the results together.  */
      for (i = 0; directories[i] != NULL; ++i)
	{
	  char **temp_results;
	  int shouldbreak;

	  shouldbreak = 0;
	  /* XXX -- we've recursively scanned any directories resulting from
	     a `**', so turn off the flag.  We turn it on again below if
	     filename is `**' */
	  /* Scan directory even on a NULL filename.  That way, `*h/'
	     returns only directories ending in `h', instead of all
	     files ending in `h' with a `/' appended. */
	  dname = directories[i];
	  dflags = flags & ~(GX_MARKDIRS|GX_ALLDIRS|GX_ADDCURDIR);
	  /* last_starstar? */
	  if ((flags & GX_GLOBSTAR) && filename[0] == '*' && filename[1] == '*' && filename[2] == '\0')
	    dflags |= GX_ALLDIRS|GX_ADDCURDIR;
	  if (dname[0] == '\0' && filename[0])
	    {
	      dflags |= GX_NULLDIR;
	      dname = ".";	/* treat null directory name and non-null filename as current directory */
	    }

	  /* Special handling for symlinks to directories with globstar on */
	  if (all_starstar && (dflags & GX_NULLDIR) == 0)
	    {
	      int dlen;

	      /* If we have a directory name that is not null (GX_NULLDIR above)
		 and is a symlink to a directory, we return the symlink if
		 we're not `descending' into it (filename[0] == 0) and return
		 glob_error_return (which causes the code below to skip the
		 name) otherwise. I should fold this into a test that does both
		 checks instead of calling stat twice. */
	      if (glob_testdir (dname, flags|GX_ALLDIRS) == -2 && glob_testdir (dname, 0) == 0)
		{
		  if (filename[0] != 0)
		    temp_results = (char **)&glob_error_return;		/* skip */
		  else
		    {
		      /* Construct array to pass to glob_dir_to_array */
		      temp_results = (char **)malloc (2 * sizeof (char *));
		      if (temp_results == NULL)
			goto memory_error;
		      temp_results[0] = (char *)malloc (1);
		      if (temp_results[0] == 0)
			{
			  free (temp_results);
			  goto memory_error;
			}
		      **temp_results = '\0';
		      temp_results[1] = NULL;
		      dflags |= GX_SYMLINK;	/* mostly for debugging */
		    }
		}
	      else
		temp_results = glob_vector (filename, dname, dflags);
	    }
	  else
	    temp_results = glob_vector (filename, dname, dflags);

	  /* Handle error cases. */
	  if (temp_results == NULL)
	    goto memory_error;
	  else if (temp_results == (char **)&glob_error_return)
	    /* This filename is probably not a directory.  Ignore it.  */
	    ;
	  else
	    {
	      char **array;
	      register unsigned int l;

	      /* If we're expanding **, we don't need to glue the directory
		 name to the results; we've already done it in glob_vector */
	      if ((dflags & GX_ALLDIRS) && filename[0] == '*' && filename[1] == '*' && (filename[2] == '\0' || filename[2] == '/'))
		{
		  /* When do we remove null elements from temp_results?  And
		     how to avoid duplicate elements in the final result? */
		  /* If (dflags & GX_NULLDIR) glob_filename potentially left a
		     NULL placeholder in the temp results just in case
		     glob_vector/glob_dir_to_array did something with it, but
		     if it didn't, and we're not supposed to be passing them
		     through for some reason ((flags & GX_NULLDIR) == 0) we
		     need to remove all the NULL elements from the beginning
		     of TEMP_RESULTS. */
		  /* If we have a null directory name and ** as the filename,
		     we have just searched for everything from the current
		     directory on down. Break now (shouldbreak = 1) to avoid
		     duplicate entries in the final result. */
#define NULL_PLACEHOLDER(x)	((x) && *(x) && **(x) == 0)
		  if ((dflags & GX_NULLDIR) && (flags & GX_NULLDIR) == 0 &&
			NULL_PLACEHOLDER (temp_results))
#undef NULL_PLACEHOLDER
		    {
		      register int i, n;
		      for (n = 0; temp_results[n] && *temp_results[n] == 0; n++)
			;
		      i = n;
		      do
			temp_results[i - n] = temp_results[i];
		      while (temp_results[i++] != 0);
		      array = temp_results;
		      shouldbreak = 1;
		    }
	          else
		    array = temp_results;
		}
	      else if (dflags & GX_SYMLINK)
		array = glob_dir_to_array (directories[i], temp_results, flags);
	      else
		array = glob_dir_to_array (directories[i], temp_results, flags);
	      l = 0;
	      while (array[l] != NULL)
		++l;

	      new_result = (char **)realloc (result, (result_size + l) * sizeof (char *));

	      if (new_result == NULL)
		{
		  for (l = 0; array[l]; ++l)
		    free (array[l]);
		  free ((char *)array);
		  goto memory_error;
		}
	      result = new_result;

	      for (l = 0; array[l] != NULL; ++l)
		result[result_size++ - 1] = array[l];

	      result[result_size - 1] = NULL;

	      /* Note that the elements of ARRAY are not freed.  */
	      if (array != temp_results)
		free ((char *) array);
	      else if ((dflags & GX_ALLDIRS) && filename[0] == '*' && filename[1] == '*' && filename[2] == '\0')
		free (temp_results);	/* expanding ** case above */

	      if (shouldbreak)
		break;
	    }
	}
      /* Free the directories.  */
      for (i = 0; directories[i]; i++)
	free (directories[i]);

      free ((char *) directories);

      return (result);
    }

only_filename:
  /* If there is only a directory name, return it. */
  if (*filename == '\0')
    {
      result = (char **) realloc ((char *) result, 2 * sizeof (char *));
      if (result == NULL)
	{
	  if (free_dirname)
	    free (directory_name);
	  return (NULL);
	}
      /* If we have a directory name with quoted characters, and we are
	 being called recursively to glob the directory portion of a pathname,
	 we need to dequote the directory name before returning it so the
	 caller can read the directory */
      if (directory_len > 0 && hasglob == 2 && (flags & GX_RECURSE) != 0)
	{
	  dequote_pathname (directory_name);
	  directory_len = strlen (directory_name);
	}

      /* We could check whether or not the dequoted directory_name is a
	 directory and return it here, returning the original directory_name
	 if not, but we don't do that. We do return the dequoted directory
	 name if we're not being called recursively and the dequoted name
	 corresponds to an actual directory. For better backwards compatibility,
	 we can return &glob_error_return unconditionally in this case. */

      if (directory_len > 0 && hasglob == 2 && (flags & GX_RECURSE) == 0)
	{
	  dequote_pathname (directory_name);
	  if (glob_testdir (directory_name, 0) < 0)
	    {
	      if (free_dirname)
		free (directory_name);
	      return ((char **)&glob_error_return);
	    }
	}

      /* Handle GX_MARKDIRS here. */
      result[0] = (char *) malloc (directory_len + 1);
      if (result[0] == NULL)
	goto memory_error;
      bcopy (directory_name, result[0], directory_len + 1);
      if (free_dirname)
	free (directory_name);
      result[1] = NULL;
      return (result);
    }
  else
    {
      char **temp_results;

      /* There are no unquoted globbing characters in DIRECTORY_NAME.
	 Dequote it before we try to open the directory since there may
	 be quoted globbing characters which should be treated verbatim. */
      if (directory_len > 0)
	dequote_pathname (directory_name);

      /* We allocated a small array called RESULT, which we won't be using.
	 Free that memory now. */
      free (result);

      /* Just return what glob_vector () returns appended to the
	 directory name. */
      /* If flags & GX_ALLDIRS, we're called recursively */
      dflags = flags & ~GX_MARKDIRS;
      if (directory_len == 0)
	dflags |= GX_NULLDIR;
      if ((flags & GX_GLOBSTAR) && filename[0] == '*' && filename[1] == '*' && filename[2] == '\0')
	{
	  dflags |= GX_ALLDIRS|GX_ADDCURDIR;
#if 0
	  /* If we want all directories (dflags & GX_ALLDIRS) and we're not
	     being called recursively as something like `echo [star][star]/[star].o'
	     ((flags & GX_ALLDIRS) == 0), we want to prevent glob_vector from
	     adding a null directory name to the front of the temp_results
	     array.  We turn off ADDCURDIR if not called recursively and
	     dlen == 0 */
#endif
	  if (directory_len == 0 && (flags & GX_ALLDIRS) == 0)
	    dflags &= ~GX_ADDCURDIR;
	}
      temp_results = glob_vector (filename,
				  (directory_len == 0 ? "." : directory_name),
				  dflags);

      if (temp_results == NULL || temp_results == (char **)&glob_error_return)
	{
	  if (free_dirname)
	    free (directory_name);
	  QUIT;			/* XXX - shell */
	  run_pending_traps ();
	  return (temp_results);
	}

      result = glob_dir_to_array ((dflags & GX_ALLDIRS) ? "" : directory_name, temp_results, flags);

      if (free_dirname)
	free (directory_name);
      return (result);
    }

  /* We get to memory_error if the program has run out of memory, or
     if this is the shell, and we have been interrupted. */
 memory_error:
  if (result != NULL)
    {
      register unsigned int i;
      for (i = 0; result[i] != NULL; ++i)
	free (result[i]);
      free ((char *) result);
    }

  if (free_dirname && directory_name)
    free (directory_name);

  QUIT;
  run_pending_traps ();

  return (NULL);
}
warning: parse error {
  char **result, **new_result;
  unsigned int result_size;
  char *directory_name, *filename, *dname, *fn;
  unsigned int directory_len;
  int free_dirname;			/* flag */
  int dflags, hasglob;

  result = (char **) malloc (sizeof (char *));
  result_size = 1;
  if (result == NULL)
    return (NULL);

  result[0] = NULL;

  directory_name = NULL;

  /* Find the filename.  */
  filename = strrchr (pathname, '/');
#if defined (EXTENDED_GLOB)
  if (filename && extended_glob)
    {
      fn = glob_dirscan (pathname, '/');
#if DEBUG_MATCHING
      if (fn != filename)
	fprintf (stderr, "glob_filename: glob_dirscan: fn (%s) != filename (%s)\n", fn ? fn : "(null)", filename);
#endif
      filename = fn;
    }
#endif

  if (filename == NULL)
    {
      filename = pathname;
      directory_name = "";
      directory_len = 0;
      free_dirname = 0;
    }
  else
    {
      directory_len = (filename - pathname) + 1;
      directory_name = (char *) malloc (directory_len + 1);

      if (directory_name == 0)		/* allocation failed? */
	{
	  free (result);
	  return (NULL);
	}

      bcopy (pathname, directory_name, directory_len);
      directory_name[directory_len] = '\0';
      ++filename;
      free_dirname = 1;
    }

  hasglob = 0;
  /* If directory_name contains globbing characters, then we
     have to expand the previous levels.  Just recurse.
     If glob_pattern_p returns != [0,1] we have a pattern that has backslash
     quotes but no unquoted glob pattern characters. We dequote it below. */
  if (directory_len > 0 && (hasglob = glob_pattern_p (directory_name)) == 1)
    {
      char **directories, *d, *p;
      register unsigned int i;
      int all_starstar, last_starstar;

      all_starstar = last_starstar = 0;
      d = directory_name;
      dflags = flags & ~GX_MARKDIRS;
      /* Collapse a sequence of ** patterns separated by one or more slashes
	 to a single ** terminated by a slash or NUL */
      if ((flags & GX_GLOBSTAR) && d[0] == '*' && d[1] == '*' && (d[2] == '/' || d[2] == '\0'))
	{
	  p = d;
	  while (d[0] == '*' && d[1] == '*' && (d[2] == '/' || d[2] == '\0'))
	    {
	      p = d;
	      if (d[2])
		{
		  d += 3;
		  while (*d == '/')
		    d++;
		  if (*d == 0)
		    break;
		}
	    }
	  if (*d == 0)
	    all_starstar = 1;
	  d = p;
	  dflags |= GX_ALLDIRS|GX_ADDCURDIR;
	  directory_len = strlen (d);
	}

      /* If there is a non [star][star]/ component in directory_name, we
	 still need to collapse trailing sequences of [star][star]/ into
	 a single one and note that the directory name ends with [star][star],
	 so we can compensate if filename is [star][star] */
      if ((flags & GX_GLOBSTAR) && all_starstar == 0)
	{
	  int dl, prev;
	  prev = dl = directory_len;
	  while (dl >= 4 && d[dl - 1] == '/' &&
			   d[dl - 2] == '*' &&
			   d[dl - 3] == '*' &&
			   d[dl - 4] == '/')
	    prev = dl, dl -= 3;
	  if (dl != directory_len)
	    last_starstar = 1;
	  directory_len = prev;
	}

      /* If the directory name ends in [star][star]/ but the filename is
	 [star][star], just remove the final [star][star] from the directory
	 so we don't have to scan everything twice. */
      if (last_starstar && directory_len > 4 &&
	    filename[0] == '*' && filename[1] == '*' && filename[2] == 0)
	{
	  directory_len -= 3;
	}

      if (d[directory_len - 1] == '/')
	d[directory_len - 1] = '\0';

      directories = glob_filename (d, dflags|GX_RECURSE);

      if (free_dirname)
	{
	  free (directory_name);
	  directory_name = NULL;
	}

      if (directories == NULL)
	goto memory_error;
      else if (directories == (char **)&glob_error_return)
	{
	  free ((char *) result);
	  return ((char **) &glob_error_return);
	}
      else if (*directories == NULL)
	{
	  free ((char *) directories);
	  free ((char *) result);
	  return ((char **) &glob_error_return);
	}

      /* If we have something like [star][star]/[star][star], it's no use to
         glob **, then do it again, and throw half the results away.  */
      if (all_starstar && filename[0] == '*' && filename[1] == '*' && filename[2] == 0)
	{
	  free ((char *) directories);
	  free (directory_name);
	  directory_name = NULL;
	  directory_len = 0;
	  goto only_filename;
	}

      /* We have successfully globbed the preceding directory name.
	 For each name in DIRECTORIES, call glob_vector on it and
	 FILENAME.  Concatenate the results together.  */
      for (i = 0; directories[i] != NULL; ++i)
	{
	  char **temp_results;
	  int shouldbreak;

	  shouldbreak = 0;
	  /* XXX -- we've recursively scanned any directories resulting from
	     a `**', so turn off the flag.  We turn it on again below if
	     filename is `**' */
	  /* Scan directory even on a NULL filename.  That way, `*h/'
	     returns only directories ending in `h', instead of all
	     files ending in `h' with a `/' appended. */
	  dname = directories[i];
	  dflags = flags & ~(GX_MARKDIRS|GX_ALLDIRS|GX_ADDCURDIR);
	  /* last_starstar? */
	  if ((flags & GX_GLOBSTAR) && filename[0] == '*' && filename[1] == '*' && filename[2] == '\0')
	    dflags |= GX_ALLDIRS|GX_ADDCURDIR;
	  if (dname[0] == '\0' && filename[0])
	    {
	      dflags |= GX_NULLDIR;
	      dname = ".";	/* treat null directory name and non-null filename as current directory */
	    }

	  /* Special handling for symlinks to directories with globstar on */
	  if (all_starstar && (dflags & GX_NULLDIR) == 0)
	    {
	      int dlen;

	      /* If we have a directory name that is not null (GX_NULLDIR above)
		 and is a symlink to a directory, we return the symlink if
		 we're not `descending' into it (filename[0] == 0) and return
		 glob_error_return (which causes the code below to skip the
		 name) otherwise. I should fold this into a test that does both
		 checks instead of calling stat twice. */
	      if (glob_testdir (dname, flags|GX_ALLDIRS) == -2 && glob_testdir (dname, 0) == 0)
		{
		  if (filename[0] != 0)
		    temp_results = (char **)&glob_error_return;		/* skip */
		  else
		    {
		      /* Construct array to pass to glob_dir_to_array */
		      temp_results = (char **)malloc (2 * sizeof (char *));
		      if (temp_results == NULL)
			goto memory_error;
		      temp_results[0] = (char *)malloc (1);
		      if (temp_results[0] == 0)
			{
			  free (temp_results);
			  goto memory_error;
			}
		      **temp_results = '\0';
		      temp_results[1] = NULL;
		      dflags |= GX_SYMLINK;	/* mostly for debugging */
		    }
		}
	      else
		temp_results = glob_vector (filename, dname, dflags);
	    }
	  else
	    temp_results = glob_vector (filename, dname, dflags);

	  /* Handle error cases. */
	  if (temp_results == NULL)
	    goto memory_error;
	  else if (temp_results == (char **)&glob_error_return)
	    /* This filename is probably not a directory.  Ignore it.  */
	    ;
	  else
	    {
	      char **array;
	      register unsigned int l;

	      /* If we're expanding **, we don't need to glue the directory
		 name to the results; we've already done it in glob_vector */
	      if ((dflags & GX_ALLDIRS) && filename[0] == '*' && filename[1] == '*' && (filename[2] == '\0' || filename[2] == '/'))
		{
		  /* When do we remove null elements from temp_results?  And
		     how to avoid duplicate elements in the final result? */
		  /* If (dflags & GX_NULLDIR) glob_filename potentially left a
		     NULL placeholder in the temp results just in case
		     glob_vector/glob_dir_to_array did something with it, but
		     if it didn't, and we're not supposed to be passing them
		     through for some reason ((flags & GX_NULLDIR) == 0) we
		     need to remove all the NULL elements from the beginning
		     of TEMP_RESULTS. */
		  /* If we have a null directory name and ** as the filename,
		     we have just searched for everything from the current
		     directory on down. Break now (shouldbreak = 1) to avoid
		     duplicate entries in the final result. */
#define NULL_PLACEHOLDER(x)	((x) && *(x) && **(x) == 0)
		  if ((dflags & GX_NULLDIR) && (flags & GX_NULLDIR) == 0 &&
			NULL_PLACEHOLDER (temp_results))
#undef NULL_PLACEHOLDER
		    {
		      register int i, n;
		      for (n = 0; temp_results[n] && *temp_results[n] == 0; n++)
			;
		      i = n;
		      do
			temp_results[i - n] = temp_results[i];
		      while (temp_results[i++] != 0);
		      array = temp_results;
		      shouldbreak = 1;
		    }
	          else
		    array = temp_results;
		}
	      else if (dflags & GX_SYMLINK)
		array = glob_dir_to_array (directories[i], temp_results, flags);
	      else
		array = glob_dir_to_array (directories[i], temp_results, flags);
	      l = 0;
	      while (array[l] != NULL)
		++l;

	      new_result = (char **)realloc (result, (result_size + l) * sizeof (char *));

	      if (new_result == NULL)
		{
		  for (l = 0; array[l]; ++l)
		    free (array[l]);
		  free ((char *)array);
		  goto memory_error;
		}
	      result = new_result;

	      for (l = 0; array[l] != NULL; ++l)
		result[result_size++ - 1] = array[l];

	      result[result_size - 1] = NULL;

	      /* Note that the elements of ARRAY are not freed.  */
	      if (array != temp_results)
		free ((char *) array);
	      else if ((dflags & GX_ALLDIRS) && filename[0] == '*' && filename[1] == '*' && filename[2] == '\0')
		free (temp_results);	/* expanding ** case above */

	      if (shouldbreak)
		break;
	    }
	}
      /* Free the directories.  */
      for (i = 0; directories[i]; i++)
	free (directories[i]);

      free ((char *) directories);

      return (result);
    }

only_filename:
  /* If there is only a directory name, return it. */
  if (*filename == '\0')
    {
      result = (char **) realloc ((char *) result, 2 * sizeof (char *));
      if (result == NULL)
	{
	  if (free_dirname)
	    free (directory_name);
	  return (NULL);
	}
      /* If we have a directory name with quoted characters, and we are
	 being called recursively to glob the directory portion of a pathname,
	 we need to dequote the directory name before returning it so the
	 caller can read the directory */
      if (directory_len > 0 && hasglob == 2 && (flags & GX_RECURSE) != 0)
	{
	  dequote_pathname (directory_name);
	  directory_len = strlen (directory_name);
	}

      /* We could check whether or not the dequoted directory_name is a
	 directory and return it here, returning the original directory_name
	 if not, but we don't do that. We do return the dequoted directory
	 name if we're not being called recursively and the dequoted name
	 corresponds to an actual directory. For better backwards compatibility,
	 we can return &glob_error_return unconditionally in this case. */

      if (directory_len > 0 && hasglob == 2 && (flags & GX_RECURSE) == 0)
	{
	  dequote_pathname (directory_name);
	  if (glob_testdir (directory_name, 0) < 0)
	    {
	      if (free_dirname)
		free (directory_name);
	      return ((char **)&glob_error_return);
	    }
	}

      /* Handle GX_MARKDIRS here. */
      result[0] = (char *) malloc (directory_len + 1);
      if (result[0] == NULL)
	goto memory_error;
      bcopy (directory_name, result[0], directory_len + 1);
      if (free_dirname)
	free (directory_name);
      result[1] = NULL;
      return (result);
    }
  else
    {
      char **temp_results;

      /* There are no unquoted globbing characters in DIRECTORY_NAME.
	 Dequote it before we try to open the directory since there may
	 be quoted globbing characters which should be treated verbatim. */
      if (directory_len > 0)
	dequote_pathname (directory_name);

      /* We allocated a small array called RESULT, which we won't be using.
	 Free that memory now. */
      free (result);

      /* Just return what glob_vector () returns appended to the
	 directory name. */
      /* If flags & GX_ALLDIRS, we're called recursively */
      dflags = flags & ~GX_MARKDIRS;
      if (directory_len == 0)
	dflags |= GX_NULLDIR;
      if ((flags & GX_GLOBSTAR) && filename[0] == '*' && filename[1] == '*' && filename[2] == '\0')
	{
	  dflags |= GX_ALLDIRS|GX_ADDCURDIR;
#if 0
	  /* If we want all directories (dflags & GX_ALLDIRS) and we're not
	     being called recursively as something like `echo [star][star]/[star].o'
	     ((flags & GX_ALLDIRS) == 0), we want to prevent glob_vector from
	     adding a null directory name to the front of the temp_results
	     array.  We turn off ADDCURDIR if not called recursively and
	     dlen == 0 */
#endif
	  if (directory_len == 0 && (flags & GX_ALLDIRS) == 0)
	    dflags &= ~GX_ADDCURDIR;
	}
      temp_results = glob_vector (filename,
				  (directory_len == 0 ? "." : directory_name),
				  dflags);

      if (temp_results == NULL || temp_results == (char **)&glob_error_return)
	{
	  if (free_dirname)
	    free (directory_name);
	  QUIT;			/* XXX - shell */
	  run_pending_traps ();
	  return (temp_results);
	}

      result = glob_dir_to_array ((dflags & GX_ALLDIRS) ? "" : directory_name, temp_results, flags);

      if (free_dirname)
	free (directory_name);
      return (result);
    }

  /* We get to memory_error if the program has run out of memory, or
     if this is the shell, and we have been interrupted. */
 memory_error:
  if (result != NULL)
    {
      register unsigned int i;
      for (i = 0; result[i] != NULL; ++i)
	free (result[i]);
      free ((char *) result);
    }

  if (free_dirname && directory_name)
    free (directory_name);

  QUIT;
  run_pending_traps ();

  return (NULL);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\glob\glob.c:1,100
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\glob\glob_loop.c...skip
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\glob\gmisc.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashtypes.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashansi.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\shmbutil.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\chartypes.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\stdc.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\glob\glob.h...skip
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\glob\gm_loop.c...
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\glob\gm_loop.c:45
parsing error 
{
  CHAR c;

  if (*string == 0)
    return (*pat == L('*'));	/* XXX  - allow only * to match empty string */

  switch (c = *pat++)
    {
    default:
      return (FOLD(*string) == FOLD(c));
    case L('\\'):
      return (FOLD(*string) == FOLD(*pat));
    case L('?'):
      return (*pat == L('(') ? 1 : (*string != L'\0'));
    case L('*'):
      return (1);
    case L('+'):
    case L('!'):
    case L('@'):
      return (*pat ==  L('(') ? 1 : (FOLD(*string) == FOLD(c)));
    case L('['):
      return (*string != L('\0'));
    }
}
warning: parse error {
  CHAR c;

  if (*string == 0)
    return (*pat == L('*'));	/* XXX  - allow only * to match empty string */

  switch (c = *pat++)
    {
    default:
      return (FOLD(*string) == FOLD(c));
    case L('\\'):
      return (FOLD(*string) == FOLD(*pat));
    case L('?'):
      return (*pat == L('(') ? 1 : (*string != L'\0'));
    case L('*'):
      return (1);
    case L('+'):
    case L('!'):
    case L('@'):
      return (*pat ==  L('(') ? 1 : (FOLD(*string) == FOLD(c)));
    case L('['):
      return (*string != L('\0'));
    }
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\glob\gm_loop.c:48
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\glob\gm_loop.c:74
parsing error 
{
  CHAR c;
  int matlen, bracklen, t, in_cclass, in_collsym, in_equiv;

  if (*pat == 0)
    return (0);

  matlen = in_cclass = in_collsym = in_equiv = 0;
  while (c = *pat++)
    {
      switch (c)
	{
	default:
	  matlen++;
	  break;
	case L('\\'):
	  if (*pat == 0)
	    return ++matlen;
	  else
	    {
	      matlen++;
	      pat++;
	    }
	  break;
	case L('?'):
	  if (*pat == LPAREN)
	    return (matlen = -1);		/* XXX for now */
	  else
	    matlen++;
	  break;
	case L('*'):
	  return (matlen = -1);
	case L('+'):
	case L('!'):
	case L('@'):
	  if (*pat == LPAREN)
	    return (matlen = -1);		/* XXX for now */
	  else
	    matlen++;
	  break;
	case L('['):
	  /* scan for ending `]', skipping over embedded [:...:] */
	  bracklen = 1;
	  c = *pat++;
	  do
	    {
	      if (c == 0)
		{
		  pat--;			/* back up to NUL */
	          matlen += bracklen;
	          goto bad_bracket;
	        }
	      else if (c == L('\\'))
		{
		  /* *pat == backslash-escaped character */
		  bracklen++;
		  /* If the backslash or backslash-escape ends the string,
		     bail.  The ++pat skips over the backslash escape */
		  if (*pat == 0 || *++pat == 0)
		    {
		      matlen += bracklen;
		      goto bad_bracket;
		    }
		}
	      else if (c == L('[') && *pat == L(':'))	/* character class */
		{
		  pat++;
		  bracklen++;
		  in_cclass = 1;
		}
	      else if (in_cclass && c == L(':') && *pat == L(']'))
		{
		  pat++;
		  bracklen++;
		  in_cclass = 0;
		}
	      else if (c == L('[') && *pat == L('.'))	/* collating symbol */
		{
		  pat++;
		  bracklen++;
		  if (*pat == L(']'))	/* right bracket can appear as collating symbol */
		    {
		      pat++;
		      bracklen++;
		    }
		  in_collsym = 1;
		}
	      else if (in_collsym && c == L('.') && *pat == L(']'))
		{
		  pat++;
		  bracklen++;
		  in_collsym = 0;
		}
	      else if (c == L('[') && *pat == L('='))	/* equivalence class */
		{
		  pat++;
		  bracklen++;
		  if (*pat == L(']'))	/* right bracket can appear as equivalence class */
		    {
		      pat++;
		      bracklen++;
		    }
		  in_equiv = 1;
		}
	      else if (in_equiv && c == L('=') && *pat == L(']'))
		{
		  pat++;
		  bracklen++;
		  in_equiv = 0;
		}
	      else
		bracklen++;
	    }
	  while ((c = *pat++) != L(']'));
	  matlen++;		/* bracket expression can only match one char */
bad_bracket:
	  break;
	}
    }

  return matlen;
}
warning: parse error {
  CHAR c;
  int matlen, bracklen, t, in_cclass, in_collsym, in_equiv;

  if (*pat == 0)
    return (0);

  matlen = in_cclass = in_collsym = in_equiv = 0;
  while (c = *pat++)
    {
      switch (c)
	{
	default:
	  matlen++;
	  break;
	case L('\\'):
	  if (*pat == 0)
	    return ++matlen;
	  else
	    {
	      matlen++;
	      pat++;
	    }
	  break;
	case L('?'):
	  if (*pat == LPAREN)
	    return (matlen = -1);		/* XXX for now */
	  else
	    matlen++;
	  break;
	case L('*'):
	  return (matlen = -1);
	case L('+'):
	case L('!'):
	case L('@'):
	  if (*pat == LPAREN)
	    return (matlen = -1);		/* XXX for now */
	  else
	    matlen++;
	  break;
	case L('['):
	  /* scan for ending `]', skipping over embedded [:...:] */
	  bracklen = 1;
	  c = *pat++;
	  do
	    {
	      if (c == 0)
		{
		  pat--;			/* back up to NUL */
	          matlen += bracklen;
	          goto bad_bracket;
	        }
	      else if (c == L('\\'))
		{
		  /* *pat == backslash-escaped character */
		  bracklen++;
		  /* If the backslash or backslash-escape ends the string,
		     bail.  The ++pat skips over the backslash escape */
		  if (*pat == 0 || *++pat == 0)
		    {
		      matlen += bracklen;
		      goto bad_bracket;
		    }
		}
	      else if (c == L('[') && *pat == L(':'))	/* character class */
		{
		  pat++;
		  bracklen++;
		  in_cclass = 1;
		}
	      else if (in_cclass && c == L(':') && *pat == L(']'))
		{
		  pat++;
		  bracklen++;
		  in_cclass = 0;
		}
	      else if (c == L('[') && *pat == L('.'))	/* collating symbol */
		{
		  pat++;
		  bracklen++;
		  if (*pat == L(']'))	/* right bracket can appear as collating symbol */
		    {
		      pat++;
		      bracklen++;
		    }
		  in_collsym = 1;
		}
	      else if (in_collsym && c == L('.') && *pat == L(']'))
		{
		  pat++;
		  bracklen++;
		  in_collsym = 0;
		}
	      else if (c == L('[') && *pat == L('='))	/* equivalence class */
		{
		  pat++;
		  bracklen++;
		  if (*pat == L(']'))	/* right bracket can appear as equivalence class */
		    {
		      pat++;
		      bracklen++;
		    }
		  in_equiv = 1;
		}
	      else if (in_equiv && c == L('=') && *pat == L(']'))
		{
		  pat++;
		  bracklen++;
		  in_equiv = 0;
		}
	      else
		bracklen++;
	    }
	  while ((c = *pat++) != L(']'));
	  matlen++;		/* bracket expression can only match one char */
bad_bracket:
	  break;
	}
    }

  return matlen;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\glob\gm_loop.c:77
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\glob\gm_loop.c...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\glob\gm_loop.c...skip
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\glob\smatch.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\glob\strmatch.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\chartypes.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashansi.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\shmbutil.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\xmalloc.h...skip
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\glob\collsyms.h...
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\glob\sm_loop.c...
parsing error 
int FCT PARAMS((CHAR *, CHAR *, int));
warning: parse error int FCT PARAMS((CHAR *, CHAR *, int));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\glob\sm_loop.c:25
parsing error 
static int GMATCH PARAMS((CHAR *, CHAR *, CHAR *, CHAR *, struct STRUCT *, int));
warning: parse error static int GMATCH PARAMS((CHAR *, CHAR *, CHAR *, CHAR *, struct STRUCT *, int));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\glob\sm_loop.c:27
parsing error 
static CHAR *PARSE_COLLSYM PARAMS((CHAR *, INT *));
warning: parse error static CHAR *PARSE_COLLSYM PARAMS((CHAR *, INT *));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\glob\sm_loop.c:28
parsing error 
static CHAR *BRACKMATCH PARAMS((CHAR *, U_CHAR, int));
warning: parse error static CHAR *BRACKMATCH PARAMS((CHAR *, U_CHAR, int));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\glob\sm_loop.c:29
parsing error 
static int EXTMATCH PARAMS((INT, CHAR *, CHAR *, CHAR *, CHAR *, int));
warning: parse error static int EXTMATCH PARAMS((INT, CHAR *, CHAR *, CHAR *, CHAR *, int));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\glob\sm_loop.c:30
parsing error 
extern void DEQUOTE_PATHNAME PARAMS((CHAR *));
warning: parse error extern void DEQUOTE_PATHNAME PARAMS((CHAR *));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\glob\sm_loop.c:32
parsing error 
CHAR *PATSCAN PARAMS((CHAR *, CHAR *, INT));
warning: parse error CHAR *PATSCAN PARAMS((CHAR *, CHAR *, INT));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\glob\sm_loop.c:34
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\glob\sm_loop.c:37
parsing error 
{
  CHAR *se, *pe;

  if (string == 0 || pattern == 0)
    return FNM_NOMATCH;

  se = string + STRLEN ((XCHAR *)string);
  pe = pattern + STRLEN ((XCHAR *)pattern);

  return (GMATCH (string, se, pattern, pe, (struct  STRUCT *)NULL, flags));
}
warning: parse error {
  CHAR *se, *pe;

  if (string == 0 || pattern == 0)
    return FNM_NOMATCH;

  se = string + STRLEN ((XCHAR *)string);
  pe = pattern + STRLEN ((XCHAR *)pattern);

  return (GMATCH (string, se, pattern, pe, (struct  STRUCT *)NULL, flags));
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\glob\sm_loop.c:41
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\glob\sm_loop.c:56
parsing error 
{
  CHAR *p, *n;		/* pattern, string */
  INT c;		/* current pattern character - XXX U_CHAR? */
  INT sc;		/* current string character - XXX U_CHAR? */

  p = pattern;
  n = string;

  if (string == 0 || pattern == 0)
    return FNM_NOMATCH;

#if DEBUG_MATCHING
fprintf(stderr, "gmatch: string = %s; se = %s\n", string, se);
fprintf(stderr, "gmatch: pattern = %s; pe = %s\n", pattern, pe);
#endif

  while (p < pe)
    {
      c = *p++;
      c = FOLD (c);

      sc = n < se ? *n : '\0';

#ifdef EXTENDED_GLOB
      /* EXTMATCH () will handle recursively calling GMATCH, so we can
	 just return what EXTMATCH() returns. */
      if ((flags & FNM_EXTMATCH) && *p == L('(') &&
	  (c == L('+') || c == L('*') || c == L('?') || c == L('@') || c == L('!'))) /* ) */
	{
	  int lflags;
	  /* If we're not matching the start of the string, we're not
	     concerned about the special cases for matching `.' */
	  lflags = (n == string) ? flags : (flags & ~FNM_PERIOD);
	  return (EXTMATCH (c, n, se, p, pe, lflags));
	}
#endif /* EXTENDED_GLOB */

      switch (c)
	{
	case L('?'):		/* Match single character */
	  if (sc == '\0')
	    return FNM_NOMATCH;
	  else if ((flags & FNM_PATHNAME) && sc == L('/'))
	    /* If we are matching a pathname, `?' can never match a `/'. */
	    return FNM_NOMATCH;
	  else if ((flags & FNM_PERIOD) && sc == L('.') &&
		   (n == string || ((flags & FNM_PATHNAME) && n[-1] == L('/'))))
	    /* `?' cannot match a `.' if it is the first character of the
	       string or if it is the first character following a slash and
	       we are matching a pathname. */
	    return FNM_NOMATCH;
	  break;

	case L('\\'):		/* backslash escape removes special meaning */
	  if (p == pe && sc == '\\' && (n+1 == se))
	    break;

	  if (p == pe)
	    return FNM_NOMATCH;

	  if ((flags & FNM_NOESCAPE) == 0)
	    {
	      c = *p++;
	      /* A trailing `\' cannot match. */
	      if (p > pe)
		return FNM_NOMATCH;
	      c = FOLD (c);
	    }
	  if (FOLD (sc) != (U_CHAR)c)
	    return FNM_NOMATCH;
	  break;

	case L('*'):		/* Match zero or more characters */
	  /* See below for the reason for using this. It avoids backtracking
	     back to a previous `*'.  Picked up from glibc. */
	  if (ends != NULL)
	    {
	      ends->pattern = p - 1;
	      ends->string = n;
	      return (0);
	    }

	  if ((flags & FNM_PERIOD) && sc == L('.') &&
	      (n == string || ((flags & FNM_PATHNAME) && n[-1] == L('/'))))
	    /* `*' cannot match a `.' if it is the first character of the
	       string or if it is the first character following a slash and
	       we are matching a pathname. */
	    return FNM_NOMATCH;

	  if (p == pe)
	    return 0;

	  /* Collapse multiple consecutive `*' and `?', but make sure that
	     one character of the string is consumed for each `?'. */
	  for (c = *p++; (c == L('?') || c == L('*')); c = *p++)
	    {
	      if ((flags & FNM_PATHNAME) && sc == L('/'))
		/* A slash does not match a wildcard under FNM_PATHNAME. */
		return FNM_NOMATCH;
#ifdef EXTENDED_GLOB
	      else if ((flags & FNM_EXTMATCH) && c == L('?') && *p == L('(')) /* ) */
		{
		  CHAR *newn;

		  /* We can match 0 or 1 times.  If we match, return success */
		  if (EXTMATCH (c, n, se, p, pe, flags) == 0)
		    return (0);

		  /* We didn't match the extended glob pattern, but
		     that's OK, since we can match 0 or 1 occurrences.
		     We need to skip the glob pattern and see if we
		     match the rest of the string. */
		  newn = PATSCAN (p + 1, pe, 0);
		  /* If NEWN is 0, we have an ill-formed pattern. */
		  p = newn ? newn : pe;
		}
#endif
	      else if (c == L('?'))
		{
		  if (sc == L('\0'))
		    return FNM_NOMATCH;
		  /* One character of the string is consumed in matching
		     this ? wildcard, so *??? won't match if there are
		     fewer than three characters. */
		  n++;
		  sc = n < se ? *n : '\0';
		}

#ifdef EXTENDED_GLOB
	      /* Handle ******(patlist) */
	      if ((flags & FNM_EXTMATCH) && c == L('*') && *p == L('('))  /*)*/
		{
		  CHAR *newn;
		  /* We need to check whether or not the extended glob
		     pattern matches the remainder of the string.
		     If it does, we match the entire pattern. */
		  for (newn = n; newn < se; ++newn)
		    {
		      if (EXTMATCH (c, newn, se, p, pe, flags) == 0)
			return (0);
		    }
		  /* We didn't match the extended glob pattern, but
		     that's OK, since we can match 0 or more occurrences.
		     We need to skip the glob pattern and see if we
		     match the rest of the string. */
		  newn = PATSCAN (p + 1, pe, 0);
		  /* If NEWN is 0, we have an ill-formed pattern. */
		  p = newn ? newn : pe;
		}
#endif
	      if (p == pe)
		break;
	    }

	  /* The wildcards are the last element of the pattern.  The name
	     cannot match completely if we are looking for a pathname and
	     it contains another slash, unless FNM_LEADING_DIR is set. */
	  if (c == L('\0'))
	    {
	      int r = (flags & FNM_PATHNAME) == 0 ? 0 : FNM_NOMATCH;
	      if (flags & FNM_PATHNAME)
		{
		  if (flags & FNM_LEADING_DIR)
		    r = 0;
		  else if (MEMCHR (n, L('/'), se - n) == NULL)
		    r = 0;
		}
	      return r;
	    }

	  /* If we've hit the end of the pattern and the last character of
	     the pattern was handled by the loop above, we've succeeded.
	     Otherwise, we need to match that last character. */
	  if (p == pe && (c == L('?') || c == L('*')))
	    return (0);

	  /* If we've hit the end of the string and the rest of the pattern
	     is something that matches the empty string, we can succeed. */
#if defined (EXTENDED_GLOB)
	  if (n == se && ((flags & FNM_EXTMATCH) && (c == L('!') || c == L('?')) && *p == L('(')))
	    {
	      --p;
	      if (EXTMATCH (c, n, se, p, pe, flags) == 0)
		return (c == L('!') ? FNM_NOMATCH : 0);
	      return (c == L('!') ? 0 : FNM_NOMATCH);
	    }
#endif

	  /* If we stop at a slash in the pattern and we are looking for a
	     pathname ([star]/foo), then consume enough of the string to stop
	     at any slash and then try to match the rest of the pattern.  If
	     the string doesn't contain a slash, fail */
	  if (c == L('/') && (flags & FNM_PATHNAME))
	    {
	      while (n < se && *n != L('/'))
		++n;
	      if (n < se && *n == L('/') && (GMATCH (n+1, se, p, pe, NULL, flags) == 0))
		return 0;
	      return FNM_NOMATCH;	/* XXX */
	    }

	  /* General case, use recursion. */
	  {
	    U_CHAR c1;
	    const CHAR *endp;
	    struct STRUCT end;

	    end.pattern = NULL;
	    endp = MEMCHR (n, (flags & FNM_PATHNAME) ? L('/') : L('\0'), se - n);
	    if (endp == 0)
	      endp = se;

	    c1 = ((flags & FNM_NOESCAPE) == 0 && c == L('\\')) ? *p : c;
	    c1 = FOLD (c1);
	    for (--p; n < endp; ++n)
	      {
		/* Only call strmatch if the first character indicates a
		   possible match.  We can check the first character if
		   we're not doing an extended glob match. */
		if ((flags & FNM_EXTMATCH) == 0 && c != L('[') && FOLD (*n) != c1) /*]*/
		  continue;

		/* If we're doing an extended glob match and the pattern is not
		   one of the extended glob patterns, we can check the first
		   character. */
		if ((flags & FNM_EXTMATCH) && p[1] != L('(') && /*)*/
		    STRCHR (L("?*+@!"), *p) == 0 && c != L('[') && FOLD (*n) != c1) /*]*/
		  continue;

		/* Otherwise, we just recurse. */
		if (GMATCH (n, se, p, pe, &end, flags & ~FNM_PERIOD) == 0)
		  {
		    if (end.pattern == NULL)
		      return (0);
		    break;
		  }
	      }
	    /* This is a clever idea from glibc, used to avoid backtracking
	       to a `*' that appears earlier in the pattern.  We get away
	       without saving se and pe because they are always the same,
	       even in the recursive calls to gmatch */ 
	    if (end.pattern != NULL)
	      {
		p = end.pattern;
		n = end.string;
		continue;
	      }

	    return FNM_NOMATCH;
	  }

	case L('['):
	  {
	    if (sc == L('\0') || n == se)
	      return FNM_NOMATCH;

	    /* A character class cannot match a `.' if it is the first
	       character of the string or if it is the first character
	       following a slash and we are matching a pathname. */
	    if ((flags & FNM_PERIOD) && sc == L('.') &&
		(n == string || ((flags & FNM_PATHNAME) && n[-1] == L('/'))))
	      return (FNM_NOMATCH);

	    p = BRACKMATCH (p, sc, flags);
	    if (p == 0)
	      return FNM_NOMATCH;
	  }
	  break;

	default:
	  if ((U_CHAR)c != FOLD (sc))
	    return (FNM_NOMATCH);
	}

      ++n;
    }

  if (n == se)
    return (0);

  if ((flags & FNM_LEADING_DIR) && *n == L('/'))
    /* The FNM_LEADING_DIR flag says that "foo*" matches "foobar/frobozz".  */
    return 0;
	  
  return (FNM_NOMATCH);
}
warning: parse error {
  CHAR *p, *n;		/* pattern, string */
  INT c;		/* current pattern character - XXX U_CHAR? */
  INT sc;		/* current string character - XXX U_CHAR? */

  p = pattern;
  n = string;

  if (string == 0 || pattern == 0)
    return FNM_NOMATCH;

#if DEBUG_MATCHING
fprintf(stderr, "gmatch: string = %s; se = %s\n", string, se);
fprintf(stderr, "gmatch: pattern = %s; pe = %s\n", pattern, pe);
#endif

  while (p < pe)
    {
      c = *p++;
      c = FOLD (c);

      sc = n < se ? *n : '\0';

#ifdef EXTENDED_GLOB
      /* EXTMATCH () will handle recursively calling GMATCH, so we can
	 just return what EXTMATCH() returns. */
      if ((flags & FNM_EXTMATCH) && *p == L('(') &&
	  (c == L('+') || c == L('*') || c == L('?') || c == L('@') || c == L('!'))) /* ) */
	{
	  int lflags;
	  /* If we're not matching the start of the string, we're not
	     concerned about the special cases for matching `.' */
	  lflags = (n == string) ? flags : (flags & ~FNM_PERIOD);
	  return (EXTMATCH (c, n, se, p, pe, lflags));
	}
#endif /* EXTENDED_GLOB */

      switch (c)
	{
	case L('?'):		/* Match single character */
	  if (sc == '\0')
	    return FNM_NOMATCH;
	  else if ((flags & FNM_PATHNAME) && sc == L('/'))
	    /* If we are matching a pathname, `?' can never match a `/'. */
	    return FNM_NOMATCH;
	  else if ((flags & FNM_PERIOD) && sc == L('.') &&
		   (n == string || ((flags & FNM_PATHNAME) && n[-1] == L('/'))))
	    /* `?' cannot match a `.' if it is the first character of the
	       string or if it is the first character following a slash and
	       we are matching a pathname. */
	    return FNM_NOMATCH;
	  break;

	case L('\\'):		/* backslash escape removes special meaning */
	  if (p == pe && sc == '\\' && (n+1 == se))
	    break;

	  if (p == pe)
	    return FNM_NOMATCH;

	  if ((flags & FNM_NOESCAPE) == 0)
	    {
	      c = *p++;
	      /* A trailing `\' cannot match. */
	      if (p > pe)
		return FNM_NOMATCH;
	      c = FOLD (c);
	    }
	  if (FOLD (sc) != (U_CHAR)c)
	    return FNM_NOMATCH;
	  break;

	case L('*'):		/* Match zero or more characters */
	  /* See below for the reason for using this. It avoids backtracking
	     back to a previous `*'.  Picked up from glibc. */
	  if (ends != NULL)
	    {
	      ends->pattern = p - 1;
	      ends->string = n;
	      return (0);
	    }

	  if ((flags & FNM_PERIOD) && sc == L('.') &&
	      (n == string || ((flags & FNM_PATHNAME) && n[-1] == L('/'))))
	    /* `*' cannot match a `.' if it is the first character of the
	       string or if it is the first character following a slash and
	       we are matching a pathname. */
	    return FNM_NOMATCH;

	  if (p == pe)
	    return 0;

	  /* Collapse multiple consecutive `*' and `?', but make sure that
	     one character of the string is consumed for each `?'. */
	  for (c = *p++; (c == L('?') || c == L('*')); c = *p++)
	    {
	      if ((flags & FNM_PATHNAME) && sc == L('/'))
		/* A slash does not match a wildcard under FNM_PATHNAME. */
		return FNM_NOMATCH;
#ifdef EXTENDED_GLOB
	      else if ((flags & FNM_EXTMATCH) && c == L('?') && *p == L('(')) /* ) */
		{
		  CHAR *newn;

		  /* We can match 0 or 1 times.  If we match, return success */
		  if (EXTMATCH (c, n, se, p, pe, flags) == 0)
		    return (0);

		  /* We didn't match the extended glob pattern, but
		     that's OK, since we can match 0 or 1 occurrences.
		     We need to skip the glob pattern and see if we
		     match the rest of the string. */
		  newn = PATSCAN (p + 1, pe, 0);
		  /* If NEWN is 0, we have an ill-formed pattern. */
		  p = newn ? newn : pe;
		}
#endif
	      else if (c == L('?'))
		{
		  if (sc == L('\0'))
		    return FNM_NOMATCH;
		  /* One character of the string is consumed in matching
		     this ? wildcard, so *??? won't match if there are
		     fewer than three characters. */
		  n++;
		  sc = n < se ? *n : '\0';
		}

#ifdef EXTENDED_GLOB
	      /* Handle ******(patlist) */
	      if ((flags & FNM_EXTMATCH) && c == L('*') && *p == L('('))  /*)*/
		{
		  CHAR *newn;
		  /* We need to check whether or not the extended glob
		     pattern matches the remainder of the string.
		     If it does, we match the entire pattern. */
		  for (newn = n; newn < se; ++newn)
		    {
		      if (EXTMATCH (c, newn, se, p, pe, flags) == 0)
			return (0);
		    }
		  /* We didn't match the extended glob pattern, but
		     that's OK, since we can match 0 or more occurrences.
		     We need to skip the glob pattern and see if we
		     match the rest of the string. */
		  newn = PATSCAN (p + 1, pe, 0);
		  /* If NEWN is 0, we have an ill-formed pattern. */
		  p = newn ? newn : pe;
		}
#endif
	      if (p == pe)
		break;
	    }

	  /* The wildcards are the last element of the pattern.  The name
	     cannot match completely if we are looking for a pathname and
	     it contains another slash, unless FNM_LEADING_DIR is set. */
	  if (c == L('\0'))
	    {
	      int r = (flags & FNM_PATHNAME) == 0 ? 0 : FNM_NOMATCH;
	      if (flags & FNM_PATHNAME)
		{
		  if (flags & FNM_LEADING_DIR)
		    r = 0;
		  else if (MEMCHR (n, L('/'), se - n) == NULL)
		    r = 0;
		}
	      return r;
	    }

	  /* If we've hit the end of the pattern and the last character of
	     the pattern was handled by the loop above, we've succeeded.
	     Otherwise, we need to match that last character. */
	  if (p == pe && (c == L('?') || c == L('*')))
	    return (0);

	  /* If we've hit the end of the string and the rest of the pattern
	     is something that matches the empty string, we can succeed. */
#if defined (EXTENDED_GLOB)
	  if (n == se && ((flags & FNM_EXTMATCH) && (c == L('!') || c == L('?')) && *p == L('(')))
	    {
	      --p;
	      if (EXTMATCH (c, n, se, p, pe, flags) == 0)
		return (c == L('!') ? FNM_NOMATCH : 0);
	      return (c == L('!') ? 0 : FNM_NOMATCH);
	    }
#endif

	  /* If we stop at a slash in the pattern and we are looking for a
	     pathname ([star]/foo), then consume enough of the string to stop
	     at any slash and then try to match the rest of the pattern.  If
	     the string doesn't contain a slash, fail */
	  if (c == L('/') && (flags & FNM_PATHNAME))
	    {
	      while (n < se && *n != L('/'))
		++n;
	      if (n < se && *n == L('/') && (GMATCH (n+1, se, p, pe, NULL, flags) == 0))
		return 0;
	      return FNM_NOMATCH;	/* XXX */
	    }

	  /* General case, use recursion. */
	  {
	    U_CHAR c1;
	    const CHAR *endp;
	    struct STRUCT end;

	    end.pattern = NULL;
	    endp = MEMCHR (n, (flags & FNM_PATHNAME) ? L('/') : L('\0'), se - n);
	    if (endp == 0)
	      endp = se;

	    c1 = ((flags & FNM_NOESCAPE) == 0 && c == L('\\')) ? *p : c;
	    c1 = FOLD (c1);
	    for (--p; n < endp; ++n)
	      {
		/* Only call strmatch if the first character indicates a
		   possible match.  We can check the first character if
		   we're not doing an extended glob match. */
		if ((flags & FNM_EXTMATCH) == 0 && c != L('[') && FOLD (*n) != c1) /*]*/
		  continue;

		/* If we're doing an extended glob match and the pattern is not
		   one of the extended glob patterns, we can check the first
		   character. */
		if ((flags & FNM_EXTMATCH) && p[1] != L('(') && /*)*/
		    STRCHR (L("?*+@!"), *p) == 0 && c != L('[') && FOLD (*n) != c1) /*]*/
		  continue;

		/* Otherwise, we just recurse. */
		if (GMATCH (n, se, p, pe, &end, flags & ~FNM_PERIOD) == 0)
		  {
		    if (end.pattern == NULL)
		      return (0);
		    break;
		  }
	      }
	    /* This is a clever idea from glibc, used to avoid backtracking
	       to a `*' that appears earlier in the pattern.  We get away
	       without saving se and pe because they are always the same,
	       even in the recursive calls to gmatch */ 
	    if (end.pattern != NULL)
	      {
		p = end.pattern;
		n = end.string;
		continue;
	      }

	    return FNM_NOMATCH;
	  }

	case L('['):
	  {
	    if (sc == L('\0') || n == se)
	      return FNM_NOMATCH;

	    /* A character class cannot match a `.' if it is the first
	       character of the string or if it is the first character
	       following a slash and we are matching a pathname. */
	    if ((flags & FNM_PERIOD) && sc == L('.') &&
		(n == string || ((flags & FNM_PATHNAME) && n[-1] == L('/'))))
	      return (FNM_NOMATCH);

	    p = BRACKMATCH (p, sc, flags);
	    if (p == 0)
	      return FNM_NOMATCH;
	  }
	  break;

	default:
	  if ((U_CHAR)c != FOLD (sc))
	    return (FNM_NOMATCH);
	}

      ++n;
    }

  if (n == se)
    return (0);

  if ((flags & FNM_LEADING_DIR) && *n == L('/'))
    /* The FNM_LEADING_DIR flag says that "foo*" matches "foobar/frobozz".  */
    return 0;
	  
  return (FNM_NOMATCH);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\glob\sm_loop.c:61
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\glob\sm_loop.c:352
parsing error 
{
  register int pc;
  INT val;

  p++;				/* move past the `.' */
	  
  for (pc = 0; p[pc]; pc++)
    if (p[pc] == L('.') && p[pc+1] == L(']'))
      break;
   if (p[pc] == 0)
    {
      if (vp)
	*vp = INVALID;
      return (p + pc);
    }
   val = COLLSYM (p, pc);
   if (vp)
     *vp = val;
   return (p + pc + 2);
}
warning: parse error {
  register int pc;
  INT val;

  p++;				/* move past the `.' */
	  
  for (pc = 0; p[pc]; pc++)
    if (p[pc] == L('.') && p[pc+1] == L(']'))
      break;
   if (p[pc] == 0)
    {
      if (vp)
	*vp = INVALID;
      return (p + pc);
    }
   val = COLLSYM (p, pc);
   if (vp)
     *vp = val;
   return (p + pc + 2);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\glob\sm_loop.c:355
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\glob\sm_loop.c:381
parsing error 
{
  register CHAR cstart, cend, c;
  register int not;    /* Nonzero if the sense of the character class is inverted.  */
  int brcnt, forcecoll, isrange;
  INT pc;
  CHAR *savep;
  CHAR *brchrp;
  U_CHAR orig_test;

  orig_test = test;
  test = FOLD (orig_test);

  savep = p;

  /* POSIX.2 3.13.1 says that an exclamation mark (`!') shall replace the
     circumflex (`^') in its role in a `nonmatching list'.  A bracket
     expression starting with an unquoted circumflex character produces
     unspecified results.  This implementation treats the two identically. */
  if (not = (*p == L('!') || *p == L('^')))
    ++p;

  c = *p++;
  for (;;)
    {
      /* Initialize cstart and cend in case `-' is the last
	 character of the pattern. */
      cstart = cend = c;
      forcecoll = 0;

      /* POSIX.2 equivalence class:  [=c=].  See POSIX.2 2.8.3.2.  Find
	 the end of the equivalence class, move the pattern pointer past
	 it, and check for equivalence.  XXX - this handles only
	 single-character equivalence classes, which is wrong, or at
	 least incomplete. */
      if (c == L('[') && *p == L('=') && p[2] == L('=') && p[3] == L(']'))
	{
	  pc = FOLD (p[1]);
	  p += 4;
	  if (COLLEQUIV (test, pc))
	    {
/*[*/	      /* Move past the closing `]', since the first thing we do at
		 the `matched:' label is back p up one. */
	      p++;
	      goto matched;
	    }
	  else
	    {
	      c = *p++;
	      if (c == L('\0'))
		return ((test == L('[')) ? savep : (CHAR *)0); /*]*/
	      c = FOLD (c);
	      continue;
	    }
	}

      /* POSIX.2 character class expression.  See POSIX.2 2.8.3.2. */
      if (c == L('[') && *p == L(':'))
	{
	  CHAR *close, *ccname;

	  pc = 0;	/* make sure invalid char classes don't match. */
	  /* Find end of character class name */
	  for (close = p + 1; *close != '\0'; close++)
	    if (*close == L(':') && *(close+1) == L(']'))
	      break;

	  if (*close != L('\0'))
	    {
	      ccname = (CHAR *)malloc ((close - p) * sizeof (CHAR));
	      if (ccname == 0)
		pc = 0;
	      else
		{
		  bcopy (p + 1, ccname, (close - p - 1) * sizeof (CHAR));
		  *(ccname + (close - p - 1)) = L('\0');
		  /* As a result of a POSIX discussion, char class names are
		     allowed to be quoted (?) */
		  DEQUOTE_PATHNAME (ccname);
		  pc = IS_CCLASS (orig_test, (XCHAR *)ccname);
		}
	      if (pc == -1)
		{
		  /* CCNAME is not a valid character class in the current
		     locale. In addition to noting no match (pc = 0), we have
		     a choice about what to do with the invalid charclass.
		     Posix leaves the behavior unspecified, but we're going
		     to skip over the charclass and keep going instead of
		     testing ORIG_TEST against each character in the class
		     string. If we don't want to do that, take out the update
		     of P. */
		  pc = 0;
		  p = close + 2;
		}
	      else
		p = close + 2;		/* move past the closing `]' */

	      free (ccname);
	    }
	    
	  if (pc)
	    {
/*[*/	      /* Move past the closing `]', since the first thing we do at
		 the `matched:' label is back p up one. */
	      p++;
	      goto matched;
	    }
	  else
	    {
	      /* continue the loop here, since this expression can't be
		 the first part of a range expression. */
	      c = *p++;
	      if (c == L('\0'))
		return ((test == L('[')) ? savep : (CHAR *)0);
	      else if (c == L(']'))
		break;
	      c = FOLD (c);
	      continue;
	    }
	}
 
      /* POSIX.2 collating symbols.  See POSIX.2 2.8.3.2.  Find the end of
	 the symbol name, make sure it is terminated by `.]', translate
	 the name to a character using the external table, and do the
	 comparison. */
      if (c == L('[') && *p == L('.'))
	{
	  p = PARSE_COLLSYM (p, &pc);
	  /* An invalid collating symbol cannot be the first point of a
	     range.  If it is, we set cstart to one greater than `test',
	     so any comparisons later will fail. */
	  cstart = (pc == INVALID) ? test + 1 : pc;
	  forcecoll = 1;
	}

      if (!(flags & FNM_NOESCAPE) && c == L('\\'))
	{
	  if (*p == '\0')
	    return (CHAR *)0;
	  cstart = cend = *p++;
	}

      cstart = cend = FOLD (cstart);
      isrange = 0;

      /* POSIX.2 2.8.3.1.2 says: `An expression containing a `[' that
	 is not preceded by a backslash and is not part of a bracket
	 expression produces undefined results.'  This implementation
	 treats the `[' as just a character to be matched if there is
	 not a closing `]'. */
      if (c == L('\0'))
	return ((test == L('[')) ? savep : (CHAR *)0);

      c = *p++;
      c = FOLD (c);

      if (c == L('\0'))
	return ((test == L('[')) ? savep : (CHAR *)0);

      if ((flags & FNM_PATHNAME) && c == L('/'))
	/* [/] can never match when matching a pathname.  */
	return (CHAR *)0;

      /* This introduces a range, unless the `-' is the last
	 character of the class.  Find the end of the range
	 and move past it. */
      if (c == L('-') && *p != L(']'))
	{
	  cend = *p++;
	  if (!(flags & FNM_NOESCAPE) && cend == L('\\'))
	    cend = *p++;
	  if (cend == L('\0'))
	    return (CHAR *)0;
	  if (cend == L('[') && *p == L('.'))
	    {
	      p = PARSE_COLLSYM (p, &pc);
	      /* An invalid collating symbol cannot be the second part of a
		 range expression.  If we get one, we set cend to one fewer
		 than the test character to make sure the range test fails. */
	      cend = (pc == INVALID) ? test - 1 : pc;
	      forcecoll = 1;
	    }
	  cend = FOLD (cend);

	  c = *p++;

	  /* POSIX.2 2.8.3.2:  ``The ending range point shall collate
	     equal to or higher than the starting range point; otherwise
	     the expression shall be treated as invalid.''  Note that this
	     applies to only the range expression; the rest of the bracket
	     expression is still checked for matches. */
	  if (RANGECMP (cstart, cend, forcecoll) > 0)
	    {
	      if (c == L(']'))
		break;
	      c = FOLD (c);
	      continue;
	    }
	  isrange = 1;
	}

      if (isrange == 0 && test == cstart)
        goto matched;
      if (isrange && RANGECMP (test, cstart, forcecoll) >= 0 && RANGECMP (test, cend, forcecoll) <= 0)
	goto matched;

      if (c == L(']'))
	break;
    }
  /* No match. */
  return (!not ? (CHAR *)0 : p);

matched:
  /* Skip the rest of the [...] that already matched.  */
  c = *--p;
  brcnt = 1;
  brchrp = 0;
  while (brcnt > 0)
    {
      int oc;

      /* A `[' without a matching `]' is just another character to match. */
      if (c == L('\0'))
	return ((test == L('[')) ? savep : (CHAR *)0);

      oc = c;
      c = *p++;
      if (c == L('[') && (*p == L('=') || *p == L(':') || *p == L('.')))
	{
	  brcnt++;
	  brchrp = p++;		/* skip over the char after the left bracket */
	  if ((c = *p) == L('\0'))
	    return ((test == L('[')) ? savep : (CHAR *)0);
	  /* If *brchrp == ':' we should check that the rest of the characters
	     form a valid character class name. We don't do that yet, but we
	     keep BRCHRP in case we want to. */
	}
      /* We only want to check brchrp if we set it above. */
      else if (c == L(']') && brcnt > 1 && brchrp != 0 && oc == *brchrp)
	{
	  brcnt--;
	  brchrp = 0;		/* just in case */
	}
      /* Left bracket loses its special meaning inside a bracket expression.
         It is only valid when followed by a `.', `=', or `:', which we check
         for above. Technically the right bracket can appear in a collating
         symbol, so we check for that here. Otherwise, it terminates the
         bracket expression. */
      else if (c == L(']') && (brchrp == 0 || *brchrp != L('.')) && brcnt >= 1)
	brcnt = 0;
      else if (!(flags & FNM_NOESCAPE) && c == L('\\'))
	{
	  if (*p == '\0')
	    return (CHAR *)0;
	  /* XXX 1003.2d11 is unclear if this is right. */
	  ++p;
	}
    }
  return (not ? (CHAR *)0 : p);
}
warning: parse error {
  register CHAR cstart, cend, c;
  register int not;    /* Nonzero if the sense of the character class is inverted.  */
  int brcnt, forcecoll, isrange;
  INT pc;
  CHAR *savep;
  CHAR *brchrp;
  U_CHAR orig_test;

  orig_test = test;
  test = FOLD (orig_test);

  savep = p;

  /* POSIX.2 3.13.1 says that an exclamation mark (`!') shall replace the
     circumflex (`^') in its role in a `nonmatching list'.  A bracket
     expression starting with an unquoted circumflex character produces
     unspecified results.  This implementation treats the two identically. */
  if (not = (*p == L('!') || *p == L('^')))
    ++p;

  c = *p++;
  for (;;)
    {
      /* Initialize cstart and cend in case `-' is the last
	 character of the pattern. */
      cstart = cend = c;
      forcecoll = 0;

      /* POSIX.2 equivalence class:  [=c=].  See POSIX.2 2.8.3.2.  Find
	 the end of the equivalence class, move the pattern pointer past
	 it, and check for equivalence.  XXX - this handles only
	 single-character equivalence classes, which is wrong, or at
	 least incomplete. */
      if (c == L('[') && *p == L('=') && p[2] == L('=') && p[3] == L(']'))
	{
	  pc = FOLD (p[1]);
	  p += 4;
	  if (COLLEQUIV (test, pc))
	    {
/*[*/	      /* Move past the closing `]', since the first thing we do at
		 the `matched:' label is back p up one. */
	      p++;
	      goto matched;
	    }
	  else
	    {
	      c = *p++;
	      if (c == L('\0'))
		return ((test == L('[')) ? savep : (CHAR *)0); /*]*/
	      c = FOLD (c);
	      continue;
	    }
	}

      /* POSIX.2 character class expression.  See POSIX.2 2.8.3.2. */
      if (c == L('[') && *p == L(':'))
	{
	  CHAR *close, *ccname;

	  pc = 0;	/* make sure invalid char classes don't match. */
	  /* Find end of character class name */
	  for (close = p + 1; *close != '\0'; close++)
	    if (*close == L(':') && *(close+1) == L(']'))
	      break;

	  if (*close != L('\0'))
	    {
	      ccname = (CHAR *)malloc ((close - p) * sizeof (CHAR));
	      if (ccname == 0)
		pc = 0;
	      else
		{
		  bcopy (p + 1, ccname, (close - p - 1) * sizeof (CHAR));
		  *(ccname + (close - p - 1)) = L('\0');
		  /* As a result of a POSIX discussion, char class names are
		     allowed to be quoted (?) */
		  DEQUOTE_PATHNAME (ccname);
		  pc = IS_CCLASS (orig_test, (XCHAR *)ccname);
		}
	      if (pc == -1)
		{
		  /* CCNAME is not a valid character class in the current
		     locale. In addition to noting no match (pc = 0), we have
		     a choice about what to do with the invalid charclass.
		     Posix leaves the behavior unspecified, but we're going
		     to skip over the charclass and keep going instead of
		     testing ORIG_TEST against each character in the class
		     string. If we don't want to do that, take out the update
		     of P. */
		  pc = 0;
		  p = close + 2;
		}
	      else
		p = close + 2;		/* move past the closing `]' */

	      free (ccname);
	    }
	    
	  if (pc)
	    {
/*[*/	      /* Move past the closing `]', since the first thing we do at
		 the `matched:' label is back p up one. */
	      p++;
	      goto matched;
	    }
	  else
	    {
	      /* continue the loop here, since this expression can't be
		 the first part of a range expression. */
	      c = *p++;
	      if (c == L('\0'))
		return ((test == L('[')) ? savep : (CHAR *)0);
	      else if (c == L(']'))
		break;
	      c = FOLD (c);
	      continue;
	    }
	}
 
      /* POSIX.2 collating symbols.  See POSIX.2 2.8.3.2.  Find the end of
	 the symbol name, make sure it is terminated by `.]', translate
	 the name to a character using the external table, and do the
	 comparison. */
      if (c == L('[') && *p == L('.'))
	{
	  p = PARSE_COLLSYM (p, &pc);
	  /* An invalid collating symbol cannot be the first point of a
	     range.  If it is, we set cstart to one greater than `test',
	     so any comparisons later will fail. */
	  cstart = (pc == INVALID) ? test + 1 : pc;
	  forcecoll = 1;
	}

      if (!(flags & FNM_NOESCAPE) && c == L('\\'))
	{
	  if (*p == '\0')
	    return (CHAR *)0;
	  cstart = cend = *p++;
	}

      cstart = cend = FOLD (cstart);
      isrange = 0;

      /* POSIX.2 2.8.3.1.2 says: `An expression containing a `[' that
	 is not preceded by a backslash and is not part of a bracket
	 expression produces undefined results.'  This implementation
	 treats the `[' as just a character to be matched if there is
	 not a closing `]'. */
      if (c == L('\0'))
	return ((test == L('[')) ? savep : (CHAR *)0);

      c = *p++;
      c = FOLD (c);

      if (c == L('\0'))
	return ((test == L('[')) ? savep : (CHAR *)0);

      if ((flags & FNM_PATHNAME) && c == L('/'))
	/* [/] can never match when matching a pathname.  */
	return (CHAR *)0;

      /* This introduces a range, unless the `-' is the last
	 character of the class.  Find the end of the range
	 and move past it. */
      if (c == L('-') && *p != L(']'))
	{
	  cend = *p++;
	  if (!(flags & FNM_NOESCAPE) && cend == L('\\'))
	    cend = *p++;
	  if (cend == L('\0'))
	    return (CHAR *)0;
	  if (cend == L('[') && *p == L('.'))
	    {
	      p = PARSE_COLLSYM (p, &pc);
	      /* An invalid collating symbol cannot be the second part of a
		 range expression.  If we get one, we set cend to one fewer
		 than the test character to make sure the range test fails. */
	      cend = (pc == INVALID) ? test - 1 : pc;
	      forcecoll = 1;
	    }
	  cend = FOLD (cend);

	  c = *p++;

	  /* POSIX.2 2.8.3.2:  ``The ending range point shall collate
	     equal to or higher than the starting range point; otherwise
	     the expression shall be treated as invalid.''  Note that this
	     applies to only the range expression; the rest of the bracket
	     expression is still checked for matches. */
	  if (RANGECMP (cstart, cend, forcecoll) > 0)
	    {
	      if (c == L(']'))
		break;
	      c = FOLD (c);
	      continue;
	    }
	  isrange = 1;
	}

      if (isrange == 0 && test == cstart)
        goto matched;
      if (isrange && RANGECMP (test, cstart, forcecoll) >= 0 && RANGECMP (test, cend, forcecoll) <= 0)
	goto matched;

      if (c == L(']'))
	break;
    }
  /* No match. */
  return (!not ? (CHAR *)0 : p);

matched:
  /* Skip the rest of the [...] that already matched.  */
  c = *--p;
  brcnt = 1;
  brchrp = 0;
  while (brcnt > 0)
    {
      int oc;

      /* A `[' without a matching `]' is just another character to match. */
      if (c == L('\0'))
	return ((test == L('[')) ? savep : (CHAR *)0);

      oc = c;
      c = *p++;
      if (c == L('[') && (*p == L('=') || *p == L(':') || *p == L('.')))
	{
	  brcnt++;
	  brchrp = p++;		/* skip over the char after the left bracket */
	  if ((c = *p) == L('\0'))
	    return ((test == L('[')) ? savep : (CHAR *)0);
	  /* If *brchrp == ':' we should check that the rest of the characters
	     form a valid character class name. We don't do that yet, but we
	     keep BRCHRP in case we want to. */
	}
      /* We only want to check brchrp if we set it above. */
      else if (c == L(']') && brcnt > 1 && brchrp != 0 && oc == *brchrp)
	{
	  brcnt--;
	  brchrp = 0;		/* just in case */
	}
      /* Left bracket loses its special meaning inside a bracket expression.
         It is only valid when followed by a `.', `=', or `:', which we check
         for above. Technically the right bracket can appear in a collating
         symbol, so we check for that here. Otherwise, it terminates the
         bracket expression. */
      else if (c == L(']') && (brchrp == 0 || *brchrp != L('.')) && brcnt >= 1)
	brcnt = 0;
      else if (!(flags & FNM_NOESCAPE) && c == L('\\'))
	{
	  if (*p == '\0')
	    return (CHAR *)0;
	  /* XXX 1003.2d11 is unclear if this is right. */
	  ++p;
	}
    }
  return (not ? (CHAR *)0 : p);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\glob\sm_loop.c:386
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\glob\sm_loop.c...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\glob\smatch.c:170
parsing error 
{
  register struct _collsym *csp;
  char *x;

  x = (char *)s;
  for (csp = posix_collsyms; csp->name; csp++)
    {
      if (STREQN(csp->name, x, len) && csp->name[len] == '\0')
	return (csp->code);
    }
  if (len == 1)
    return s[0];
  return INVALID;
}
warning: parse error {
  register struct _collsym *csp;
  char *x;

  x = (char *)s;
  for (csp = posix_collsyms; csp->name; csp++)
    {
      if (STREQN(csp->name, x, len) && csp->name[len] == '\0')
	return (csp->code);
    }
  if (len == 1)
    return s[0];
  return INVALID;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\glob\smatch.c:173
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\glob\smatch.c:211
parsing error 
{
  enum char_class ret;
  int i;

  ret = CC_NO_CLASS;

  for (i = 1; i < N_CHAR_CLASS; i++)
    {
      if (STREQ (name, cclass_name[i]))
	{
	  ret = (enum char_class)i;
	  break;
	}
    }

  return ret;
}
warning: parse error {
  enum char_class ret;
  int i;

  ret = CC_NO_CLASS;

  for (i = 1; i < N_CHAR_CLASS; i++)
    {
      if (STREQ (name, cclass_name[i]))
	{
	  ret = (enum char_class)i;
	  break;
	}
    }

  return ret;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\glob\smatch.c:212
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\glob\smatch.c:231
parsing error 
{
  int result;

  switch (char_class)
    {
      case CC_ASCII:
	result = isascii (c);
	break;
      case CC_ALNUM:
	result = ISALNUM (c);
	break;
      case CC_ALPHA:
	result = ISALPHA (c);
	break;
      case CC_BLANK:  
	result = ISBLANK (c);
	break;
      case CC_CNTRL:
	result = ISCNTRL (c);
	break;
      case CC_DIGIT:
	result = ISDIGIT (c);
	break;
      case CC_GRAPH:
	result = ISGRAPH (c);
	break;
      case CC_LOWER:
	result = ISLOWER (c);
	break;
      case CC_PRINT: 
	result = ISPRINT (c);
	break;
      case CC_PUNCT:
	result = ISPUNCT (c);
	break;
      case CC_SPACE:
	result = ISSPACE (c);
	break;
      case CC_UPPER:
	result = ISUPPER (c);
	break;
      case CC_WORD:
        result = (ISALNUM (c) || c == '_');
	break;
      case CC_XDIGIT:
	result = ISXDIGIT (c);
	break;
      default:
	result = -1;
	break;
    }

  return result;  
}
warning: parse error {
  int result;

  switch (char_class)
    {
      case CC_ASCII:
	result = isascii (c);
	break;
      case CC_ALNUM:
	result = ISALNUM (c);
	break;
      case CC_ALPHA:
	result = ISALPHA (c);
	break;
      case CC_BLANK:  
	result = ISBLANK (c);
	break;
      case CC_CNTRL:
	result = ISCNTRL (c);
	break;
      case CC_DIGIT:
	result = ISDIGIT (c);
	break;
      case CC_GRAPH:
	result = ISGRAPH (c);
	break;
      case CC_LOWER:
	result = ISLOWER (c);
	break;
      case CC_PRINT: 
	result = ISPRINT (c);
	break;
      case CC_PUNCT:
	result = ISPUNCT (c);
	break;
      case CC_SPACE:
	result = ISSPACE (c);
	break;
      case CC_UPPER:
	result = ISUPPER (c);
	break;
      case CC_WORD:
        result = (ISALNUM (c) || c == '_');
	break;
      case CC_XDIGIT:
	result = ISXDIGIT (c);
	break;
      default:
	result = -1;
	break;
    }

  return result;  
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\glob\smatch.c:234
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\glob\smatch.c:290
parsing error 
{
  enum char_class char_class;
  int result;

  char_class = is_valid_cclass (name);
  if (char_class == CC_NO_CLASS)
    return -1;

  result = cclass_test (c, char_class);
  return (result);
}
warning: parse error {
  enum char_class char_class;
  int result;

  char_class = is_valid_cclass (name);
  if (char_class == CC_NO_CLASS)
    return -1;

  result = cclass_test (c, char_class);
  return (result);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\glob\smatch.c:293
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\glob\smatch.c:580
parsing error 
{
#if HANDLE_MULTIBYTE
  int ret;
  size_t n;
  wchar_t *wpattern, *wstring;
  size_t plen, slen, mplen, mslen;

  if (MB_CUR_MAX == 1)
    return (internal_strmatch ((unsigned char *)pattern, (unsigned char *)string, flags));

  if (mbsmbchar (string) == 0 && mbsmbchar (pattern) == 0 && posix_cclass_only (pattern))
    return (internal_strmatch ((unsigned char *)pattern, (unsigned char *)string, flags));

  n = xdupmbstowcs (&wpattern, NULL, pattern);
  if (n == (size_t)-1 || n == (size_t)-2)
    return (internal_strmatch ((unsigned char *)pattern, (unsigned char *)string, flags));

  n = xdupmbstowcs (&wstring, NULL, string);
  if (n == (size_t)-1 || n == (size_t)-2)
    {
      free (wpattern);
      return (internal_strmatch ((unsigned char *)pattern, (unsigned char *)string, flags));
    }

  ret = internal_wstrmatch (wpattern, wstring, flags);

  free (wpattern);
  free (wstring);

  return ret;
#else
  return (internal_strmatch ((unsigned char *)pattern, (unsigned char *)string, flags));
#endif /* !HANDLE_MULTIBYTE */
}
warning: parse error {
#if HANDLE_MULTIBYTE
  int ret;
  size_t n;
  wchar_t *wpattern, *wstring;
  size_t plen, slen, mplen, mslen;

  if (MB_CUR_MAX == 1)
    return (internal_strmatch ((unsigned char *)pattern, (unsigned char *)string, flags));

  if (mbsmbchar (string) == 0 && mbsmbchar (pattern) == 0 && posix_cclass_only (pattern))
    return (internal_strmatch ((unsigned char *)pattern, (unsigned char *)string, flags));

  n = xdupmbstowcs (&wpattern, NULL, pattern);
  if (n == (size_t)-1 || n == (size_t)-2)
    return (internal_strmatch ((unsigned char *)pattern, (unsigned char *)string, flags));

  n = xdupmbstowcs (&wstring, NULL, string);
  if (n == (size_t)-1 || n == (size_t)-2)
    {
      free (wpattern);
      return (internal_strmatch ((unsigned char *)pattern, (unsigned char *)string, flags));
    }

  ret = internal_wstrmatch (wpattern, wstring, flags);

  free (wpattern);
  free (wstring);

  return ret;
#else
  return (internal_strmatch ((unsigned char *)pattern, (unsigned char *)string, flags));
#endif /* !HANDLE_MULTIBYTE */
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\glob\smatch.c:584
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\glob\sm_loop.c...skip
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\glob\strmatch.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\stdc.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\glob\strmatch.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\glob\strmatch.c:33
parsing error 
{
  if (string == 0 || pattern == 0)
    return FNM_NOMATCH;

  return (xstrmatch (pattern, string, flags));
}
warning: parse error {
  if (string == 0 || pattern == 0)
    return FNM_NOMATCH;

  return (xstrmatch (pattern, string, flags));
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\glob\strmatch.c:37
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\glob\xmbsrtowcs.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashansi.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\shmbutil.h...skip
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\intl\bindtextdom.c...
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\intl\gettextP.h...
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\intl\loadinfo.h...
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\intl\gmo.h...
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\intl\gettextP.h:82
parsing error 
{
  return (i << 24) | ((i & 0xff00) << 8) | ((i >> 8) & 0xff00) | (i >> 24);
}
warning: parse error {
  return (i << 24) | ((i & 0xff00) << 8) | ((i >> 8) & 0xff00) | (i >> 24);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\intl\gettextP.h:84
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\intl\bindtextdom.c:104
parsing error 
{
  struct binding *binding;
  int modified;

  /* Some sanity checks.  */
  if (domainname == NULL || domainname[0] == '\0')
    {
      if (dirnamep)
	*dirnamep = NULL;
      if (codesetp)
	*codesetp = NULL;
      return;
    }

  __libc_rwlock_wrlock (_nl_state_lock);

  modified = 0;

  for (binding = _nl_domain_bindings; binding != NULL; binding = binding->next)
    {
      int compare = strcmp (domainname, binding->domainname);
      if (compare == 0)
	/* We found it!  */
	break;
      if (compare < 0)
	{
	  /* It is not in the list.  */
	  binding = NULL;
	  break;
	}
    }

  if (binding != NULL)
    {
      if (dirnamep)
	{
	  const char *dirname = *dirnamep;

	  if (dirname == NULL)
	    /* The current binding has be to returned.  */
	    *dirnamep = binding->dirname;
	  else
	    {
	      /* The domain is already bound.  If the new value and the old
		 one are equal we simply do nothing.  Otherwise replace the
		 old binding.  */
	      char *result = binding->dirname;
	      if (strcmp (dirname, result) != 0)
		{
		  if (strcmp (dirname, INTUSE(_nl_default_dirname)) == 0)
		    result = (char *) INTUSE(_nl_default_dirname);
		  else
		    {
#if defined _LIBC || defined HAVE_STRDUP
		      result = strdup (dirname);
#else
		      size_t len = strlen (dirname) + 1;
		      result = (char *) malloc (len);
		      if (__builtin_expect (result != NULL, 1))
			memcpy (result, dirname, len);
#endif
		    }

		  if (__builtin_expect (result != NULL, 1))
		    {
		      if (binding->dirname != INTUSE(_nl_default_dirname))
			free (binding->dirname);

		      binding->dirname = result;
		      modified = 1;
		    }
		}
	      *dirnamep = result;
	    }
	}

      if (codesetp)
	{
	  const char *codeset = *codesetp;

	  if (codeset == NULL)
	    /* The current binding has be to returned.  */
	    *codesetp = binding->codeset;
	  else
	    {
	      /* The domain is already bound.  If the new value and the old
		 one are equal we simply do nothing.  Otherwise replace the
		 old binding.  */
	      char *result = binding->codeset;
	      if (result == NULL || strcmp (codeset, result) != 0)
		{
#if defined _LIBC || defined HAVE_STRDUP
		  result = strdup (codeset);
#else
		  size_t len = strlen (codeset) + 1;
		  result = (char *) malloc (len);
		  if (__builtin_expect (result != NULL, 1))
		    memcpy (result, codeset, len);
#endif

		  if (__builtin_expect (result != NULL, 1))
		    {
		      if (binding->codeset != NULL)
			free (binding->codeset);

		      binding->codeset = result;
		      binding->codeset_cntr++;
		      modified = 1;
		    }
		}
	      *codesetp = result;
	    }
	}
    }
  else if ((dirnamep == NULL || *dirnamep == NULL)
	   && (codesetp == NULL || *codesetp == NULL))
    {
      /* Simply return the default values.  */
      if (dirnamep)
	*dirnamep = INTUSE(_nl_default_dirname);
      if (codesetp)
	*codesetp = NULL;
    }
  else
    {
      /* We have to create a new binding.  */
      size_t len = strlen (domainname) + 1;
      struct binding *new_binding =
	(struct binding *) malloc (offsetof (struct binding, domainname) + len);

      if (__builtin_expect (new_binding == NULL, 0))
	goto failed;

      memcpy (new_binding->domainname, domainname, len);

      if (dirnamep)
	{
	  const char *dirname = *dirnamep;

	  if (dirname == NULL)
	    /* The default value.  */
	    dirname = INTUSE(_nl_default_dirname);
	  else
	    {
	      if (strcmp (dirname, INTUSE(_nl_default_dirname)) == 0)
		dirname = INTUSE(_nl_default_dirname);
	      else
		{
		  char *result;
#if defined _LIBC || defined HAVE_STRDUP
		  result = strdup (dirname);
		  if (__builtin_expect (result == NULL, 0))
		    goto failed_dirname;
#else
		  size_t len = strlen (dirname) + 1;
		  result = (char *) malloc (len);
		  if (__builtin_expect (result == NULL, 0))
		    goto failed_dirname;
		  memcpy (result, dirname, len);
#endif
		  dirname = result;
		}
	    }
	  *dirnamep = dirname;
	  new_binding->dirname = (char *) dirname;
	}
      else
	/* The default value.  */
	new_binding->dirname = (char *) INTUSE(_nl_default_dirname);

      new_binding->codeset_cntr = 0;

      if (codesetp)
	{
	  const char *codeset = *codesetp;

	  if (codeset != NULL)
	    {
	      char *result;

#if defined _LIBC || defined HAVE_STRDUP
	      result = strdup (codeset);
	      if (__builtin_expect (result == NULL, 0))
		goto failed_codeset;
#else
	      size_t len = strlen (codeset) + 1;
	      result = (char *) malloc (len);
	      if (__builtin_expect (result == NULL, 0))
		goto failed_codeset;
	      memcpy (result, codeset, len);
#endif
	      codeset = result;
	      new_binding->codeset_cntr++;
	    }
	  *codesetp = codeset;
	  new_binding->codeset = (char *) codeset;
	}
      else
	new_binding->codeset = NULL;

      /* Now enqueue it.  */
      if (_nl_domain_bindings == NULL
	  || strcmp (domainname, _nl_domain_bindings->domainname) < 0)
	{
	  new_binding->next = _nl_domain_bindings;
	  _nl_domain_bindings = new_binding;
	}
      else
	{
	  binding = _nl_domain_bindings;
	  while (binding->next != NULL
		 && strcmp (domainname, binding->next->domainname) > 0)
	    binding = binding->next;

	  new_binding->next = binding->next;
	  binding->next = new_binding;
	}

      modified = 1;

      /* Here we deal with memory allocation failures.  */
      if (0)
	{
	failed_codeset:
	  if (new_binding->dirname != INTUSE(_nl_default_dirname))
	    free (new_binding->dirname);
	failed_dirname:
	  free (new_binding);
	failed:
	  if (dirnamep)
	    *dirnamep = NULL;
	  if (codesetp)
	    *codesetp = NULL;
	}
    }

  /* If we modified any binding, we flush the caches.  */
  if (modified)
    ++_nl_msg_cat_cntr;

  __libc_rwlock_unlock (_nl_state_lock);
}
warning: parse error {
  struct binding *binding;
  int modified;

  /* Some sanity checks.  */
  if (domainname == NULL || domainname[0] == '\0')
    {
      if (dirnamep)
	*dirnamep = NULL;
      if (codesetp)
	*codesetp = NULL;
      return;
    }

  __libc_rwlock_wrlock (_nl_state_lock);

  modified = 0;

  for (binding = _nl_domain_bindings; binding != NULL; binding = binding->next)
    {
      int compare = strcmp (domainname, binding->domainname);
      if (compare == 0)
	/* We found it!  */
	break;
      if (compare < 0)
	{
	  /* It is not in the list.  */
	  binding = NULL;
	  break;
	}
    }

  if (binding != NULL)
    {
      if (dirnamep)
	{
	  const char *dirname = *dirnamep;

	  if (dirname == NULL)
	    /* The current binding has be to returned.  */
	    *dirnamep = binding->dirname;
	  else
	    {
	      /* The domain is already bound.  If the new value and the old
		 one are equal we simply do nothing.  Otherwise replace the
		 old binding.  */
	      char *result = binding->dirname;
	      if (strcmp (dirname, result) != 0)
		{
		  if (strcmp (dirname, INTUSE(_nl_default_dirname)) == 0)
		    result = (char *) INTUSE(_nl_default_dirname);
		  else
		    {
#if defined _LIBC || defined HAVE_STRDUP
		      result = strdup (dirname);
#else
		      size_t len = strlen (dirname) + 1;
		      result = (char *) malloc (len);
		      if (__builtin_expect (result != NULL, 1))
			memcpy (result, dirname, len);
#endif
		    }

		  if (__builtin_expect (result != NULL, 1))
		    {
		      if (binding->dirname != INTUSE(_nl_default_dirname))
			free (binding->dirname);

		      binding->dirname = result;
		      modified = 1;
		    }
		}
	      *dirnamep = result;
	    }
	}

      if (codesetp)
	{
	  const char *codeset = *codesetp;

	  if (codeset == NULL)
	    /* The current binding has be to returned.  */
	    *codesetp = binding->codeset;
	  else
	    {
	      /* The domain is already bound.  If the new value and the old
		 one are equal we simply do nothing.  Otherwise replace the
		 old binding.  */
	      char *result = binding->codeset;
	      if (result == NULL || strcmp (codeset, result) != 0)
		{
#if defined _LIBC || defined HAVE_STRDUP
		  result = strdup (codeset);
#else
		  size_t len = strlen (codeset) + 1;
		  result = (char *) malloc (len);
		  if (__builtin_expect (result != NULL, 1))
		    memcpy (result, codeset, len);
#endif

		  if (__builtin_expect (result != NULL, 1))
		    {
		      if (binding->codeset != NULL)
			free (binding->codeset);

		      binding->codeset = result;
		      binding->codeset_cntr++;
		      modified = 1;
		    }
		}
	      *codesetp = result;
	    }
	}
    }
  else if ((dirnamep == NULL || *dirnamep == NULL)
	   && (codesetp == NULL || *codesetp == NULL))
    {
      /* Simply return the default values.  */
      if (dirnamep)
	*dirnamep = INTUSE(_nl_default_dirname);
      if (codesetp)
	*codesetp = NULL;
    }
  else
    {
      /* We have to create a new binding.  */
      size_t len = strlen (domainname) + 1;
      struct binding *new_binding =
	(struct binding *) malloc (offsetof (struct binding, domainname) + len);

      if (__builtin_expect (new_binding == NULL, 0))
	goto failed;

      memcpy (new_binding->domainname, domainname, len);

      if (dirnamep)
	{
	  const char *dirname = *dirnamep;

	  if (dirname == NULL)
	    /* The default value.  */
	    dirname = INTUSE(_nl_default_dirname);
	  else
	    {
	      if (strcmp (dirname, INTUSE(_nl_default_dirname)) == 0)
		dirname = INTUSE(_nl_default_dirname);
	      else
		{
		  char *result;
#if defined _LIBC || defined HAVE_STRDUP
		  result = strdup (dirname);
		  if (__builtin_expect (result == NULL, 0))
		    goto failed_dirname;
#else
		  size_t len = strlen (dirname) + 1;
		  result = (char *) malloc (len);
		  if (__builtin_expect (result == NULL, 0))
		    goto failed_dirname;
		  memcpy (result, dirname, len);
#endif
		  dirname = result;
		}
	    }
	  *dirnamep = dirname;
	  new_binding->dirname = (char *) dirname;
	}
      else
	/* The default value.  */
	new_binding->dirname = (char *) INTUSE(_nl_default_dirname);

      new_binding->codeset_cntr = 0;

      if (codesetp)
	{
	  const char *codeset = *codesetp;

	  if (codeset != NULL)
	    {
	      char *result;

#if defined _LIBC || defined HAVE_STRDUP
	      result = strdup (codeset);
	      if (__builtin_expect (result == NULL, 0))
		goto failed_codeset;
#else
	      size_t len = strlen (codeset) + 1;
	      result = (char *) malloc (len);
	      if (__builtin_expect (result == NULL, 0))
		goto failed_codeset;
	      memcpy (result, codeset, len);
#endif
	      codeset = result;
	      new_binding->codeset_cntr++;
	    }
	  *codesetp = codeset;
	  new_binding->codeset = (char *) codeset;
	}
      else
	new_binding->codeset = NULL;

      /* Now enqueue it.  */
      if (_nl_domain_bindings == NULL
	  || strcmp (domainname, _nl_domain_bindings->domainname) < 0)
	{
	  new_binding->next = _nl_domain_bindings;
	  _nl_domain_bindings = new_binding;
	}
      else
	{
	  binding = _nl_domain_bindings;
	  while (binding->next != NULL
		 && strcmp (domainname, binding->next->domainname) > 0)
	    binding = binding->next;

	  new_binding->next = binding->next;
	  binding->next = new_binding;
	}

      modified = 1;

      /* Here we deal with memory allocation failures.  */
      if (0)
	{
	failed_codeset:
	  if (new_binding->dirname != INTUSE(_nl_default_dirname))
	    free (new_binding->dirname);
	failed_dirname:
	  free (new_binding);
	failed:
	  if (dirnamep)
	    *dirnamep = NULL;
	  if (codesetp)
	    *codesetp = NULL;
	}
    }

  /* If we modified any binding, we flush the caches.  */
  if (modified)
    ++_nl_msg_cat_cntr;

  __libc_rwlock_unlock (_nl_state_lock);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\intl\bindtextdom.c:107
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\intl\bindtextdom.c:354
parsing error 
{
  set_binding_values (domainname, &dirname, NULL);
  return (char *) dirname;
}
warning: parse error {
  set_binding_values (domainname, &dirname, NULL);
  return (char *) dirname;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\intl\bindtextdom.c:356
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\intl\bindtextdom.c:365
parsing error 
{
  set_binding_values (domainname, NULL, &codeset);
  return (char *) codeset;
}
warning: parse error {
  set_binding_values (domainname, NULL, &codeset);
  return (char *) codeset;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\intl\bindtextdom.c:367
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\intl\dcgettext.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\intl\gettextP.h...skip
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\intl\dcgettext.c:50
parsing error 
{
  return DCIGETTEXT (domainname, msgid, NULL, 0, 0, category);
}
warning: parse error {
  return DCIGETTEXT (domainname, msgid, NULL, 0, 0, category);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\intl\dcgettext.c:53
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\intl\dcigettext.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\intl\gettextP.h...skip
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\intl\plural-exp.h...
parsing error 
enum operator
  {
    /* Without arguments:  */
    var,			/* The variable "n".  */
    num,			/* Decimal number.  */
    /* Unary operators:  */
    lnot,			/* Logical NOT.  */
    /* Binary operators:  */
    mult,			/* Multiplication.  */
    divide,			/* Division.  */
    module,			/* Modulo operation.  */
    plus,			/* Addition.  */
    minus,			/* Subtraction.  */
    less_than,			/* Comparison.  */
    greater_than,		/* Comparison.  */
    less_or_equal,		/* Comparison.  */
    greater_or_equal,		/* Comparison.  */
    equal,			/* Comparison for equality.  */
    not_equal,			/* Comparison for inequality.  */
    land,			/* Logical AND.  */
    lor,			/* Logical OR.  */
    /* Ternary operators:  */
    qmop			/* Question mark operator.  */
  }
warning: parse error enum operator
  {
    /* Without arguments:  */
    var,			/* The variable "n".  */
    num,			/* Decimal number.  */
    /* Unary operators:  */
    lnot,			/* Logical NOT.  */
    /* Binary operators:  */
    mult,			/* Multiplication.  */
    divide,			/* Division.  */
    module,			/* Modulo operation.  */
    plus,			/* Addition.  */
    minus,			/* Subtraction.  */
    less_than,			/* Comparison.  */
    greater_than,		/* Comparison.  */
    less_or_equal,		/* Comparison.  */
    greater_or_equal,		/* Comparison.  */
    equal,			/* Comparison for equality.  */
    not_equal,			/* Comparison for inequality.  */
    land,			/* Logical AND.  */
    lor,			/* Logical OR.  */
    /* Ternary operators:  */
    qmop			/* Question mark operator.  */
  }Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\intl\plural-exp.h:56
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\intl\hash-string.h...
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\intl\hash-string.h:51
parsing error 
{
  unsigned long int hval, g;
  const char *str = str_param;

  /* Compute the hash value for the given string.  */
  hval = 0;
  while (*str != '\0')
    {
      hval <<= 4;
      hval += (unsigned long int) *str++;
      g = hval & ((unsigned long int) 0xf << (HASHWORDBITS - 4));
      if (g != 0)
	{
	  hval ^= g >> (HASHWORDBITS - 8);
	  hval ^= g;
	}
    }
  return hval;
}
warning: parse error {
  unsigned long int hval, g;
  const char *str = str_param;

  /* Compute the hash value for the given string.  */
  hval = 0;
  while (*str != '\0')
    {
      hval <<= 4;
      hval += (unsigned long int) *str++;
      g = hval & ((unsigned long int) 0xf << (HASHWORDBITS - 4));
      if (g != 0)
	{
	  hval ^= g >> (HASHWORDBITS - 8);
	  hval ^= g;
	}
    }
  return hval;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\intl\hash-string.h:52
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\intl\eval-plural.h...
parsing error 
STATIC unsigned long int plural_eval PARAMS ((struct expression *pexp,
					      unsigned long int n))
     internal_function;
warning: parse error STATIC unsigned long int plural_eval PARAMS ((struct expression *pexp,
					      unsigned long int n))
     internal_function;Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\intl\eval-plural.h:35
parsing error 
n
warning: parse error nMissing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\intl\eval-plural.h:41
parsing error 
plural_eval (pexp, n)
     struct expression *pexp;
warning: parse error plural_eval (pexp, n)
     struct expression *pexp;Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\intl\eval-plural.h:42
parsing error 
{
  switch (pexp->nargs)
    {
    case 0:
      switch (pexp->operation)
	{
	case var:
	  return n;
	case num:
	  return pexp->val.num;
	default:
	  break;
	}
      /* NOTREACHED */
      break;
    case 1:
      {
	/* pexp->operation must be lnot.  */
	unsigned long int arg = plural_eval (pexp->val.args[0], n);
	return ! arg;
      }
    case 2:
      {
	unsigned long int leftarg = plural_eval (pexp->val.args[0], n);
	if (pexp->operation == lor)
	  return leftarg || plural_eval (pexp->val.args[1], n);
	else if (pexp->operation == land)
	  return leftarg && plural_eval (pexp->val.args[1], n);
	else
	  {
	    unsigned long int rightarg = plural_eval (pexp->val.args[1], n);

	    switch (pexp->operation)
	      {
	      case mult:
		return leftarg * rightarg;
	      case divide:
#if !INTDIV0_RAISES_SIGFPE
		if (rightarg == 0)
		  raise (SIGFPE);
#endif
		return leftarg / rightarg;
	      case module:
#if !INTDIV0_RAISES_SIGFPE
		if (rightarg == 0)
		  raise (SIGFPE);
#endif
		return leftarg % rightarg;
	      case plus:
		return leftarg + rightarg;
	      case minus:
		return leftarg - rightarg;
	      case less_than:
		return leftarg < rightarg;
	      case greater_than:
		return leftarg > rightarg;
	      case less_or_equal:
		return leftarg <= rightarg;
	      case greater_or_equal:
		return leftarg >= rightarg;
	      case equal:
		return leftarg == rightarg;
	      case not_equal:
		return leftarg != rightarg;
	      default:
		break;
	      }
	  }
	/* NOTREACHED */
	break;
      }
    case 3:
      {
	/* pexp->operation must be qmop.  */
	unsigned long int boolarg = plural_eval (pexp->val.args[0], n);
	return plural_eval (pexp->val.args[boolarg ? 1 : 2], n);
      }
    }
  /* NOTREACHED */
  return 0;
}
warning: parse error {
  switch (pexp->nargs)
    {
    case 0:
      switch (pexp->operation)
	{
	case var:
	  return n;
	case num:
	  return pexp->val.num;
	default:
	  break;
	}
      /* NOTREACHED */
      break;
    case 1:
      {
	/* pexp->operation must be lnot.  */
	unsigned long int arg = plural_eval (pexp->val.args[0], n);
	return ! arg;
      }
    case 2:
      {
	unsigned long int leftarg = plural_eval (pexp->val.args[0], n);
	if (pexp->operation == lor)
	  return leftarg || plural_eval (pexp->val.args[1], n);
	else if (pexp->operation == land)
	  return leftarg && plural_eval (pexp->val.args[1], n);
	else
	  {
	    unsigned long int rightarg = plural_eval (pexp->val.args[1], n);

	    switch (pexp->operation)
	      {
	      case mult:
		return leftarg * rightarg;
	      case divide:
#if !INTDIV0_RAISES_SIGFPE
		if (rightarg == 0)
		  raise (SIGFPE);
#endif
		return leftarg / rightarg;
	      case module:
#if !INTDIV0_RAISES_SIGFPE
		if (rightarg == 0)
		  raise (SIGFPE);
#endif
		return leftarg % rightarg;
	      case plus:
		return leftarg + rightarg;
	      case minus:
		return leftarg - rightarg;
	      case less_than:
		return leftarg < rightarg;
	      case greater_than:
		return leftarg > rightarg;
	      case less_or_equal:
		return leftarg <= rightarg;
	      case greater_or_equal:
		return leftarg >= rightarg;
	      case equal:
		return leftarg == rightarg;
	      case not_equal:
		return leftarg != rightarg;
	      default:
		break;
	      }
	  }
	/* NOTREACHED */
	break;
      }
    case 3:
      {
	/* pexp->operation must be qmop.  */
	unsigned long int boolarg = plural_eval (pexp->val.args[0], n);
	return plural_eval (pexp->val.args[boolarg ? 1 : 2], n);
      }
    }
  /* NOTREACHED */
  return 0;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\intl\eval-plural.h:45
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\intl\dcigettext.c:438
parsing error 
{
#ifndef HAVE_ALLOCA
  struct block_list *block_list = NULL;
#endif
  struct loaded_l10nfile *domain;
  struct binding *binding;
  const char *categoryname;
  const char *categoryvalue;
  char *dirname, *xdomainname;
  char *single_locale;
  char *retval;
  size_t retlen;
  int saved_errno;
#if defined HAVE_TSEARCH || defined _LIBC
  struct known_translation_t *search;
  struct known_translation_t **foundp = NULL;
  size_t msgid_len;
#endif
  size_t domainname_len;

  /* If no real MSGID is given return NULL.  */
  if (msgid1 == NULL)
    return NULL;

#ifdef _LIBC
  if (category < 0 || category >= __LC_LAST || category == LC_ALL)
    /* Bogus.  */
    return (plural == 0
	    ? (char *) msgid1
	    /* Use the Germanic plural rule.  */
	    : n == 1 ? (char *) msgid1 : (char *) msgid2);
#endif

  __libc_rwlock_rdlock (_nl_state_lock);

  /* If DOMAINNAME is NULL, we are interested in the default domain.  If
     CATEGORY is not LC_MESSAGES this might not make much sense but the
     definition left this undefined.  */
  if (domainname == NULL)
    domainname = _nl_current_default_domain;

  /* OS/2 specific: backward compatibility with older libintl versions  */
#ifdef LC_MESSAGES_COMPAT
  if (category == LC_MESSAGES_COMPAT)
    category = LC_MESSAGES;
#endif

#if defined HAVE_TSEARCH || defined _LIBC
  msgid_len = strlen (msgid1) + 1;

  /* Try to find the translation among those which we found at
     some time.  */
  search = (struct known_translation_t *)
	   alloca (offsetof (struct known_translation_t, msgid) + msgid_len);
  memcpy (search->msgid, msgid1, msgid_len);
  search->domainname = (char *) domainname;
  search->category = category;

  foundp = (struct known_translation_t **) tfind (search, &root, transcmp);
  freea (search);
  if (foundp != NULL && (*foundp)->counter == _nl_msg_cat_cntr)
    {
      /* Now deal with plural.  */
      if (plural)
	retval = plural_lookup ((*foundp)->domain, n, (*foundp)->translation,
				(*foundp)->translation_length);
      else
	retval = (char *) (*foundp)->translation;

      __libc_rwlock_unlock (_nl_state_lock);
      return retval;
    }
#endif

  /* Preserve the `errno' value.  */
  saved_errno = errno;

  /* See whether this is a SUID binary or not.  */
  DETERMINE_SECURE;

  /* First find matching binding.  */
  for (binding = _nl_domain_bindings; binding != NULL; binding = binding->next)
    {
      int compare = strcmp (domainname, binding->domainname);
      if (compare == 0)
	/* We found it!  */
	break;
      if (compare < 0)
	{
	  /* It is not in the list.  */
	  binding = NULL;
	  break;
	}
    }

  if (binding == NULL)
    dirname = (char *) INTUSE(_nl_default_dirname);
  else if (IS_ABSOLUTE_PATH (binding->dirname))
    dirname = binding->dirname;
  else
    {
      /* We have a relative path.  Make it absolute now.  */
      size_t dirname_len = strlen (binding->dirname) + 1;
      size_t path_max;
      char *ret;

      path_max = (unsigned int) PATH_MAX;
      path_max += 2;		/* The getcwd docs say to do this.  */

      for (;;)
	{
	  dirname = (char *) alloca (path_max + dirname_len);
	  ADD_BLOCK (block_list, dirname);

	  __set_errno (0);
	  ret = getcwd (dirname, path_max);
	  if (ret != NULL || errno != ERANGE)
	    break;

	  path_max += path_max / 2;
	  path_max += PATH_INCR;
	}

      if (ret == NULL)
	/* We cannot get the current working directory.  Don't signal an
	   error but simply return the default string.  */
	goto return_untranslated;

      stpcpy (stpcpy (strchr (dirname, '\0'), "/"), binding->dirname);
    }

  /* Now determine the symbolic name of CATEGORY and its value.  */
  categoryname = category_to_name (category);
  categoryvalue = guess_category_value (category, categoryname);

  domainname_len = strlen (domainname);
  xdomainname = (char *) alloca (strlen (categoryname)
				 + domainname_len + 5);
  ADD_BLOCK (block_list, xdomainname);

  stpcpy (mempcpy (stpcpy (stpcpy (xdomainname, categoryname), "/"),
		  domainname, domainname_len),
	  ".mo");

  /* Creating working area.  */
  single_locale = (char *) alloca (strlen (categoryvalue) + 1);
  ADD_BLOCK (block_list, single_locale);


  /* Search for the given string.  This is a loop because we perhaps
     got an ordered list of languages to consider for the translation.  */
  while (1)
    {
      /* Make CATEGORYVALUE point to the next element of the list.  */
      while (categoryvalue[0] != '\0' && categoryvalue[0] == ':')
	++categoryvalue;
      if (categoryvalue[0] == '\0')
	{
	  /* The whole contents of CATEGORYVALUE has been searched but
	     no valid entry has been found.  We solve this situation
	     by implicitly appending a "C" entry, i.e. no translation
	     will take place.  */
	  single_locale[0] = 'C';
	  single_locale[1] = '\0';
	}
      else
	{
	  char *cp = single_locale;
	  while (categoryvalue[0] != '\0' && categoryvalue[0] != ':')
	    *cp++ = *categoryvalue++;
	  *cp = '\0';

	  /* When this is a SUID binary we must not allow accessing files
	     outside the dedicated directories.  */
	  if (ENABLE_SECURE && IS_PATH_WITH_DIR (single_locale))
	    /* Ingore this entry.  */
	    continue;
	}

      /* If the current locale value is C (or POSIX) we don't load a
	 domain.  Return the MSGID.  */
      if (strcmp (single_locale, "C") == 0
	  || strcmp (single_locale, "POSIX") == 0)
	break;

      /* Find structure describing the message catalog matching the
	 DOMAINNAME and CATEGORY.  */
      domain = _nl_find_domain (dirname, single_locale, xdomainname, binding);

      if (domain != NULL)
	{
	  retval = _nl_find_msg (domain, binding, msgid1, &retlen);

	  if (retval == NULL)
	    {
	      int cnt;

	      for (cnt = 0; domain->successor[cnt] != NULL; ++cnt)
		{
		  retval = _nl_find_msg (domain->successor[cnt], binding,
					 msgid1, &retlen);

		  if (retval != NULL)
		    {
		      domain = domain->successor[cnt];
		      break;
		    }
		}
	    }

	  if (retval != NULL)
	    {
	      /* Found the translation of MSGID1 in domain DOMAIN:
		 starting at RETVAL, RETLEN bytes.  */
	      FREE_BLOCKS (block_list);
#if defined HAVE_TSEARCH || defined _LIBC
	      if (foundp == NULL)
		{
		  /* Create a new entry and add it to the search tree.  */
		  struct known_translation_t *newp;

		  newp = (struct known_translation_t *)
		    malloc (offsetof (struct known_translation_t, msgid)
			    + msgid_len + domainname_len + 1);
		  if (newp != NULL)
		    {
		      newp->domainname =
			mempcpy (newp->msgid, msgid1, msgid_len);
		      memcpy (newp->domainname, domainname, domainname_len + 1);
		      newp->category = category;
		      newp->counter = _nl_msg_cat_cntr;
		      newp->domain = domain;
		      newp->translation = retval;
		      newp->translation_length = retlen;

		      /* Insert the entry in the search tree.  */
		      foundp = (struct known_translation_t **)
			tsearch (newp, &root, transcmp);
		      if (foundp == NULL
			  || __builtin_expect (*foundp != newp, 0))
			/* The insert failed.  */
			free (newp);
		    }
		}
	      else
		{
		  /* We can update the existing entry.  */
		  (*foundp)->counter = _nl_msg_cat_cntr;
		  (*foundp)->domain = domain;
		  (*foundp)->translation = retval;
		  (*foundp)->translation_length = retlen;
		}
#endif
	      __set_errno (saved_errno);

	      /* Now deal with plural.  */
	      if (plural)
		retval = plural_lookup (domain, n, retval, retlen);

	      __libc_rwlock_unlock (_nl_state_lock);
	      return retval;
	    }
	}
    }

 return_untranslated:
  /* Return the untranslated MSGID.  */
  FREE_BLOCKS (block_list);
  __libc_rwlock_unlock (_nl_state_lock);
#ifndef _LIBC
  if (!ENABLE_SECURE)
    {
      extern void _nl_log_untranslated PARAMS ((const char *logfilename,
						const char *domainname,
						const char *msgid1,
						const char *msgid2,
						int plural));
      const char *logfilename = getenv ("GETTEXT_LOG_UNTRANSLATED");

      if (logfilename != NULL && logfilename[0] != '\0')
	_nl_log_untranslated (logfilename, domainname, msgid1, msgid2, plural);
    }
#endif
  __set_errno (saved_errno);
  return (plural == 0
	  ? (char *) msgid1
	  /* Use the Germanic plural rule.  */
	  : n == 1 ? (char *) msgid1 : (char *) msgid2);
}
warning: parse error {
#ifndef HAVE_ALLOCA
  struct block_list *block_list = NULL;
#endif
  struct loaded_l10nfile *domain;
  struct binding *binding;
  const char *categoryname;
  const char *categoryvalue;
  char *dirname, *xdomainname;
  char *single_locale;
  char *retval;
  size_t retlen;
  int saved_errno;
#if defined HAVE_TSEARCH || defined _LIBC
  struct known_translation_t *search;
  struct known_translation_t **foundp = NULL;
  size_t msgid_len;
#endif
  size_t domainname_len;

  /* If no real MSGID is given return NULL.  */
  if (msgid1 == NULL)
    return NULL;

#ifdef _LIBC
  if (category < 0 || category >= __LC_LAST || category == LC_ALL)
    /* Bogus.  */
    return (plural == 0
	    ? (char *) msgid1
	    /* Use the Germanic plural rule.  */
	    : n == 1 ? (char *) msgid1 : (char *) msgid2);
#endif

  __libc_rwlock_rdlock (_nl_state_lock);

  /* If DOMAINNAME is NULL, we are interested in the default domain.  If
     CATEGORY is not LC_MESSAGES this might not make much sense but the
     definition left this undefined.  */
  if (domainname == NULL)
    domainname = _nl_current_default_domain;

  /* OS/2 specific: backward compatibility with older libintl versions  */
#ifdef LC_MESSAGES_COMPAT
  if (category == LC_MESSAGES_COMPAT)
    category = LC_MESSAGES;
#endif

#if defined HAVE_TSEARCH || defined _LIBC
  msgid_len = strlen (msgid1) + 1;

  /* Try to find the translation among those which we found at
     some time.  */
  search = (struct known_translation_t *)
	   alloca (offsetof (struct known_translation_t, msgid) + msgid_len);
  memcpy (search->msgid, msgid1, msgid_len);
  search->domainname = (char *) domainname;
  search->category = category;

  foundp = (struct known_translation_t **) tfind (search, &root, transcmp);
  freea (search);
  if (foundp != NULL && (*foundp)->counter == _nl_msg_cat_cntr)
    {
      /* Now deal with plural.  */
      if (plural)
	retval = plural_lookup ((*foundp)->domain, n, (*foundp)->translation,
				(*foundp)->translation_length);
      else
	retval = (char *) (*foundp)->translation;

      __libc_rwlock_unlock (_nl_state_lock);
      return retval;
    }
#endif

  /* Preserve the `errno' value.  */
  saved_errno = errno;

  /* See whether this is a SUID binary or not.  */
  DETERMINE_SECURE;

  /* First find matching binding.  */
  for (binding = _nl_domain_bindings; binding != NULL; binding = binding->next)
    {
      int compare = strcmp (domainname, binding->domainname);
      if (compare == 0)
	/* We found it!  */
	break;
      if (compare < 0)
	{
	  /* It is not in the list.  */
	  binding = NULL;
	  break;
	}
    }

  if (binding == NULL)
    dirname = (char *) INTUSE(_nl_default_dirname);
  else if (IS_ABSOLUTE_PATH (binding->dirname))
    dirname = binding->dirname;
  else
    {
      /* We have a relative path.  Make it absolute now.  */
      size_t dirname_len = strlen (binding->dirname) + 1;
      size_t path_max;
      char *ret;

      path_max = (unsigned int) PATH_MAX;
      path_max += 2;		/* The getcwd docs say to do this.  */

      for (;;)
	{
	  dirname = (char *) alloca (path_max + dirname_len);
	  ADD_BLOCK (block_list, dirname);

	  __set_errno (0);
	  ret = getcwd (dirname, path_max);
	  if (ret != NULL || errno != ERANGE)
	    break;

	  path_max += path_max / 2;
	  path_max += PATH_INCR;
	}

      if (ret == NULL)
	/* We cannot get the current working directory.  Don't signal an
	   error but simply return the default string.  */
	goto return_untranslated;

      stpcpy (stpcpy (strchr (dirname, '\0'), "/"), binding->dirname);
    }

  /* Now determine the symbolic name of CATEGORY and its value.  */
  categoryname = category_to_name (category);
  categoryvalue = guess_category_value (category, categoryname);

  domainname_len = strlen (domainname);
  xdomainname = (char *) alloca (strlen (categoryname)
				 + domainname_len + 5);
  ADD_BLOCK (block_list, xdomainname);

  stpcpy (mempcpy (stpcpy (stpcpy (xdomainname, categoryname), "/"),
		  domainname, domainname_len),
	  ".mo");

  /* Creating working area.  */
  single_locale = (char *) alloca (strlen (categoryvalue) + 1);
  ADD_BLOCK (block_list, single_locale);


  /* Search for the given string.  This is a loop because we perhaps
     got an ordered list of languages to consider for the translation.  */
  while (1)
    {
      /* Make CATEGORYVALUE point to the next element of the list.  */
      while (categoryvalue[0] != '\0' && categoryvalue[0] == ':')
	++categoryvalue;
      if (categoryvalue[0] == '\0')
	{
	  /* The whole contents of CATEGORYVALUE has been searched but
	     no valid entry has been found.  We solve this situation
	     by implicitly appending a "C" entry, i.e. no translation
	     will take place.  */
	  single_locale[0] = 'C';
	  single_locale[1] = '\0';
	}
      else
	{
	  char *cp = single_locale;
	  while (categoryvalue[0] != '\0' && categoryvalue[0] != ':')
	    *cp++ = *categoryvalue++;
	  *cp = '\0';

	  /* When this is a SUID binary we must not allow accessing files
	     outside the dedicated directories.  */
	  if (ENABLE_SECURE && IS_PATH_WITH_DIR (single_locale))
	    /* Ingore this entry.  */
	    continue;
	}

      /* If the current locale value is C (or POSIX) we don't load a
	 domain.  Return the MSGID.  */
      if (strcmp (single_locale, "C") == 0
	  || strcmp (single_locale, "POSIX") == 0)
	break;

      /* Find structure describing the message catalog matching the
	 DOMAINNAME and CATEGORY.  */
      domain = _nl_find_domain (dirname, single_locale, xdomainname, binding);

      if (domain != NULL)
	{
	  retval = _nl_find_msg (domain, binding, msgid1, &retlen);

	  if (retval == NULL)
	    {
	      int cnt;

	      for (cnt = 0; domain->successor[cnt] != NULL; ++cnt)
		{
		  retval = _nl_find_msg (domain->successor[cnt], binding,
					 msgid1, &retlen);

		  if (retval != NULL)
		    {
		      domain = domain->successor[cnt];
		      break;
		    }
		}
	    }

	  if (retval != NULL)
	    {
	      /* Found the translation of MSGID1 in domain DOMAIN:
		 starting at RETVAL, RETLEN bytes.  */
	      FREE_BLOCKS (block_list);
#if defined HAVE_TSEARCH || defined _LIBC
	      if (foundp == NULL)
		{
		  /* Create a new entry and add it to the search tree.  */
		  struct known_translation_t *newp;

		  newp = (struct known_translation_t *)
		    malloc (offsetof (struct known_translation_t, msgid)
			    + msgid_len + domainname_len + 1);
		  if (newp != NULL)
		    {
		      newp->domainname =
			mempcpy (newp->msgid, msgid1, msgid_len);
		      memcpy (newp->domainname, domainname, domainname_len + 1);
		      newp->category = category;
		      newp->counter = _nl_msg_cat_cntr;
		      newp->domain = domain;
		      newp->translation = retval;
		      newp->translation_length = retlen;

		      /* Insert the entry in the search tree.  */
		      foundp = (struct known_translation_t **)
			tsearch (newp, &root, transcmp);
		      if (foundp == NULL
			  || __builtin_expect (*foundp != newp, 0))
			/* The insert failed.  */
			free (newp);
		    }
		}
	      else
		{
		  /* We can update the existing entry.  */
		  (*foundp)->counter = _nl_msg_cat_cntr;
		  (*foundp)->domain = domain;
		  (*foundp)->translation = retval;
		  (*foundp)->translation_length = retlen;
		}
#endif
	      __set_errno (saved_errno);

	      /* Now deal with plural.  */
	      if (plural)
		retval = plural_lookup (domain, n, retval, retlen);

	      __libc_rwlock_unlock (_nl_state_lock);
	      return retval;
	    }
	}
    }

 return_untranslated:
  /* Return the untranslated MSGID.  */
  FREE_BLOCKS (block_list);
  __libc_rwlock_unlock (_nl_state_lock);
#ifndef _LIBC
  if (!ENABLE_SECURE)
    {
      extern void _nl_log_untranslated PARAMS ((const char *logfilename,
						const char *domainname,
						const char *msgid1,
						const char *msgid2,
						int plural));
      const char *logfilename = getenv ("GETTEXT_LOG_UNTRANSLATED");

      if (logfilename != NULL && logfilename[0] != '\0')
	_nl_log_untranslated (logfilename, domainname, msgid1, msgid2, plural);
    }
#endif
  __set_errno (saved_errno);
  return (plural == 0
	  ? (char *) msgid1
	  /* Use the Germanic plural rule.  */
	  : n == 1 ? (char *) msgid1 : (char *) msgid2);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\intl\dcigettext.c:444
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\intl\dcigettext.c:737
parsing error 
{
  struct loaded_domain *domain;
  nls_uint32 nstrings;
  size_t act;
  char *result;
  size_t resultlen;

  if (domain_file->decided == 0)
    _nl_load_domain (domain_file, domainbinding);

  if (domain_file->data == NULL)
    return NULL;

  domain = (struct loaded_domain *) domain_file->data;

  nstrings = domain->nstrings;

  /* Locate the MSGID and its translation.  */
  if (domain->hash_tab != NULL)
    {
      /* Use the hashing table.  */
      nls_uint32 len = strlen (msgid);
      nls_uint32 hash_val = hash_string (msgid);
      nls_uint32 idx = hash_val % domain->hash_size;
      nls_uint32 incr = 1 + (hash_val % (domain->hash_size - 2));

      while (1)
	{
	  nls_uint32 nstr =
	    W (domain->must_swap_hash_tab, domain->hash_tab[idx]);

	  if (nstr == 0)
	    /* Hash table entry is empty.  */
	    return NULL;

	  nstr--;

	  /* Compare msgid with the original string at index nstr.
	     We compare the lengths with >=, not ==, because plural entries
	     are represented by strings with an embedded NUL.  */
	  if (nstr < nstrings
	      ? W (domain->must_swap, domain->orig_tab[nstr].length) >= len
		&& (strcmp (msgid,
			    domain->data + W (domain->must_swap,
					      domain->orig_tab[nstr].offset))
		    == 0)
	      : domain->orig_sysdep_tab[nstr - nstrings].length > len
		&& (strcmp (msgid,
			    domain->orig_sysdep_tab[nstr - nstrings].pointer)
		    == 0))
	    {
	      act = nstr;
	      goto found;
	    }

	  if (idx >= domain->hash_size - incr)
	    idx -= domain->hash_size - incr;
	  else
	    idx += incr;
	}
      /* NOTREACHED */
    }
  else
    {
      /* Try the default method:  binary search in the sorted array of
	 messages.  */
      size_t top, bottom;

      bottom = 0;
      top = nstrings;
      while (bottom < top)
	{
	  int cmp_val;

	  act = (bottom + top) / 2;
	  cmp_val = strcmp (msgid, (domain->data
				    + W (domain->must_swap,
					 domain->orig_tab[act].offset)));
	  if (cmp_val < 0)
	    top = act;
	  else if (cmp_val > 0)
	    bottom = act + 1;
	  else
	    goto found;
	}
      /* No translation was found.  */
      return NULL;
    }

 found:
  /* The translation was found at index ACT.  If we have to convert the
     string to use a different character set, this is the time.  */
  if (act < nstrings)
    {
      result = (char *)
	(domain->data + W (domain->must_swap, domain->trans_tab[act].offset));
      resultlen = W (domain->must_swap, domain->trans_tab[act].length) + 1;
    }
  else
    {
      result = (char *) domain->trans_sysdep_tab[act - nstrings].pointer;
      resultlen = domain->trans_sysdep_tab[act - nstrings].length;
    }

#if defined _LIBC || HAVE_ICONV
  if (domain->codeset_cntr
      != (domainbinding != NULL ? domainbinding->codeset_cntr : 0))
    {
      /* The domain's codeset has changed through bind_textdomain_codeset()
	 since the message catalog was initialized or last accessed.  We
	 have to reinitialize the converter.  */
      _nl_free_domain_conv (domain);
      _nl_init_domain_conv (domain_file, domain, domainbinding);
    }

  if (
# ifdef _LIBC
      domain->conv != (__gconv_t) -1
# else
#  if HAVE_ICONV
      domain->conv != (iconv_t) -1
#  endif
# endif
      )
    {
      /* We are supposed to do a conversion.  First allocate an
	 appropriate table with the same structure as the table
	 of translations in the file, where we can put the pointers
	 to the converted strings in.
	 There is a slight complication with plural entries.  They
	 are represented by consecutive NUL terminated strings.  We
	 handle this case by converting RESULTLEN bytes, including
	 NULs.  */

      if (domain->conv_tab == NULL
	  && ((domain->conv_tab =
		 (char **) calloc (nstrings + domain->n_sysdep_strings,
				   sizeof (char *)))
	      == NULL))
	/* Mark that we didn't succeed allocating a table.  */
	domain->conv_tab = (char **) -1;

      if (__builtin_expect (domain->conv_tab == (char **) -1, 0))
	/* Nothing we can do, no more memory.  */
	goto converted;

      if (domain->conv_tab[act] == NULL)
	{
	  /* We haven't used this string so far, so it is not
	     translated yet.  Do this now.  */
	  /* We use a bit more efficient memory handling.
	     We allocate always larger blocks which get used over
	     time.  This is faster than many small allocations.   */
	  __libc_lock_define_initialized (static, lock)
# define INITIAL_BLOCK_SIZE	4080
	  static unsigned char *freemem;
	  static size_t freemem_size;

	  const unsigned char *inbuf;
	  unsigned char *outbuf;
	  int malloc_count;
# ifndef _LIBC
	  transmem_block_t *transmem_list = NULL;
# endif

	  __libc_lock_lock (lock);

	  inbuf = (const unsigned char *) result;
	  outbuf = freemem + sizeof (size_t);

	  malloc_count = 0;
	  while (1)
	    {
	      transmem_block_t *newmem;
# ifdef _LIBC
	      size_t non_reversible;
	      int res;

	      if (freemem_size < sizeof (size_t))
		goto resize_freemem;

	      res = __gconv (domain->conv,
			     &inbuf, inbuf + resultlen,
			     &outbuf,
			     outbuf + freemem_size - sizeof (size_t),
			     &non_reversible);

	      if (res == __GCONV_OK || res == __GCONV_EMPTY_INPUT)
		break;

	      if (res != __GCONV_FULL_OUTPUT)
		{
		  __libc_lock_unlock (lock);
		  goto converted;
		}

	      inbuf = result;
# else
#  if HAVE_ICONV
	      const char *inptr = (const char *) inbuf;
	      size_t inleft = resultlen;
	      char *outptr = (char *) outbuf;
	      size_t outleft;

	      if (freemem_size < sizeof (size_t))
		goto resize_freemem;

	      outleft = freemem_size - sizeof (size_t);
	      if (iconv (domain->conv,
			 (ICONV_CONST char **) &inptr, &inleft,
			 &outptr, &outleft)
		  != (size_t) (-1))
		{
		  outbuf = (unsigned char *) outptr;
		  break;
		}
	      if (errno != E2BIG)
		{
		  __libc_lock_unlock (lock);
		  goto converted;
		}
#  endif
# endif

	    resize_freemem:
	      /* We must allocate a new buffer or resize the old one.  */
	      if (malloc_count > 0)
		{
		  ++malloc_count;
		  freemem_size = malloc_count * INITIAL_BLOCK_SIZE;
		  newmem = (transmem_block_t *) realloc (transmem_list,
							 freemem_size);
# ifdef _LIBC
		  if (newmem != NULL)
		    transmem_list = transmem_list->next;
		  else
		    {
		      struct transmem_list *old = transmem_list;

		      transmem_list = transmem_list->next;
		      free (old);
		    }
# endif
		}
	      else
		{
		  malloc_count = 1;
		  freemem_size = INITIAL_BLOCK_SIZE;
		  newmem = (transmem_block_t *) malloc (freemem_size);
		}
	      if (__builtin_expect (newmem == NULL, 0))
		{
		  freemem = NULL;
		  freemem_size = 0;
		  __libc_lock_unlock (lock);
		  goto converted;
		}

# ifdef _LIBC
	      /* Add the block to the list of blocks we have to free
                 at some point.  */
	      newmem->next = transmem_list;
	      transmem_list = newmem;

	      freemem = newmem->data;
	      freemem_size -= offsetof (struct transmem_list, data);
# else
	      transmem_list = newmem;
	      freemem = newmem;
# endif

	      outbuf = freemem + sizeof (size_t);
	    }

	  /* We have now in our buffer a converted string.  Put this
	     into the table of conversions.  */
	  *(size_t *) freemem = outbuf - freemem - sizeof (size_t);
	  domain->conv_tab[act] = (char *) freemem;
	  /* Shrink freemem, but keep it aligned.  */
	  freemem_size -= outbuf - freemem;
	  freemem = outbuf;
	  freemem += freemem_size & (alignof (size_t) - 1);
	  freemem_size = freemem_size & ~ (alignof (size_t) - 1);

	  __libc_lock_unlock (lock);
	}

      /* Now domain->conv_tab[act] contains the translation of all
	 the plural variants.  */
      result = domain->conv_tab[act] + sizeof (size_t);
      resultlen = *(size_t *) domain->conv_tab[act];
    }

 converted:
  /* The result string is converted.  */

#endif /* _LIBC || HAVE_ICONV */

  *lengthp = resultlen;
  return result;
}
warning: parse error {
  struct loaded_domain *domain;
  nls_uint32 nstrings;
  size_t act;
  char *result;
  size_t resultlen;

  if (domain_file->decided == 0)
    _nl_load_domain (domain_file, domainbinding);

  if (domain_file->data == NULL)
    return NULL;

  domain = (struct loaded_domain *) domain_file->data;

  nstrings = domain->nstrings;

  /* Locate the MSGID and its translation.  */
  if (domain->hash_tab != NULL)
    {
      /* Use the hashing table.  */
      nls_uint32 len = strlen (msgid);
      nls_uint32 hash_val = hash_string (msgid);
      nls_uint32 idx = hash_val % domain->hash_size;
      nls_uint32 incr = 1 + (hash_val % (domain->hash_size - 2));

      while (1)
	{
	  nls_uint32 nstr =
	    W (domain->must_swap_hash_tab, domain->hash_tab[idx]);

	  if (nstr == 0)
	    /* Hash table entry is empty.  */
	    return NULL;

	  nstr--;

	  /* Compare msgid with the original string at index nstr.
	     We compare the lengths with >=, not ==, because plural entries
	     are represented by strings with an embedded NUL.  */
	  if (nstr < nstrings
	      ? W (domain->must_swap, domain->orig_tab[nstr].length) >= len
		&& (strcmp (msgid,
			    domain->data + W (domain->must_swap,
					      domain->orig_tab[nstr].offset))
		    == 0)
	      : domain->orig_sysdep_tab[nstr - nstrings].length > len
		&& (strcmp (msgid,
			    domain->orig_sysdep_tab[nstr - nstrings].pointer)
		    == 0))
	    {
	      act = nstr;
	      goto found;
	    }

	  if (idx >= domain->hash_size - incr)
	    idx -= domain->hash_size - incr;
	  else
	    idx += incr;
	}
      /* NOTREACHED */
    }
  else
    {
      /* Try the default method:  binary search in the sorted array of
	 messages.  */
      size_t top, bottom;

      bottom = 0;
      top = nstrings;
      while (bottom < top)
	{
	  int cmp_val;

	  act = (bottom + top) / 2;
	  cmp_val = strcmp (msgid, (domain->data
				    + W (domain->must_swap,
					 domain->orig_tab[act].offset)));
	  if (cmp_val < 0)
	    top = act;
	  else if (cmp_val > 0)
	    bottom = act + 1;
	  else
	    goto found;
	}
      /* No translation was found.  */
      return NULL;
    }

 found:
  /* The translation was found at index ACT.  If we have to convert the
     string to use a different character set, this is the time.  */
  if (act < nstrings)
    {
      result = (char *)
	(domain->data + W (domain->must_swap, domain->trans_tab[act].offset));
      resultlen = W (domain->must_swap, domain->trans_tab[act].length) + 1;
    }
  else
    {
      result = (char *) domain->trans_sysdep_tab[act - nstrings].pointer;
      resultlen = domain->trans_sysdep_tab[act - nstrings].length;
    }

#if defined _LIBC || HAVE_ICONV
  if (domain->codeset_cntr
      != (domainbinding != NULL ? domainbinding->codeset_cntr : 0))
    {
      /* The domain's codeset has changed through bind_textdomain_codeset()
	 since the message catalog was initialized or last accessed.  We
	 have to reinitialize the converter.  */
      _nl_free_domain_conv (domain);
      _nl_init_domain_conv (domain_file, domain, domainbinding);
    }

  if (
# ifdef _LIBC
      domain->conv != (__gconv_t) -1
# else
#  if HAVE_ICONV
      domain->conv != (iconv_t) -1
#  endif
# endif
      )
    {
      /* We are supposed to do a conversion.  First allocate an
	 appropriate table with the same structure as the table
	 of translations in the file, where we can put the pointers
	 to the converted strings in.
	 There is a slight complication with plural entries.  They
	 are represented by consecutive NUL terminated strings.  We
	 handle this case by converting RESULTLEN bytes, including
	 NULs.  */

      if (domain->conv_tab == NULL
	  && ((domain->conv_tab =
		 (char **) calloc (nstrings + domain->n_sysdep_strings,
				   sizeof (char *)))
	      == NULL))
	/* Mark that we didn't succeed allocating a table.  */
	domain->conv_tab = (char **) -1;

      if (__builtin_expect (domain->conv_tab == (char **) -1, 0))
	/* Nothing we can do, no more memory.  */
	goto converted;

      if (domain->conv_tab[act] == NULL)
	{
	  /* We haven't used this string so far, so it is not
	     translated yet.  Do this now.  */
	  /* We use a bit more efficient memory handling.
	     We allocate always larger blocks which get used over
	     time.  This is faster than many small allocations.   */
	  __libc_lock_define_initialized (static, lock)
# define INITIAL_BLOCK_SIZE	4080
	  static unsigned char *freemem;
	  static size_t freemem_size;

	  const unsigned char *inbuf;
	  unsigned char *outbuf;
	  int malloc_count;
# ifndef _LIBC
	  transmem_block_t *transmem_list = NULL;
# endif

	  __libc_lock_lock (lock);

	  inbuf = (const unsigned char *) result;
	  outbuf = freemem + sizeof (size_t);

	  malloc_count = 0;
	  while (1)
	    {
	      transmem_block_t *newmem;
# ifdef _LIBC
	      size_t non_reversible;
	      int res;

	      if (freemem_size < sizeof (size_t))
		goto resize_freemem;

	      res = __gconv (domain->conv,
			     &inbuf, inbuf + resultlen,
			     &outbuf,
			     outbuf + freemem_size - sizeof (size_t),
			     &non_reversible);

	      if (res == __GCONV_OK || res == __GCONV_EMPTY_INPUT)
		break;

	      if (res != __GCONV_FULL_OUTPUT)
		{
		  __libc_lock_unlock (lock);
		  goto converted;
		}

	      inbuf = result;
# else
#  if HAVE_ICONV
	      const char *inptr = (const char *) inbuf;
	      size_t inleft = resultlen;
	      char *outptr = (char *) outbuf;
	      size_t outleft;

	      if (freemem_size < sizeof (size_t))
		goto resize_freemem;

	      outleft = freemem_size - sizeof (size_t);
	      if (iconv (domain->conv,
			 (ICONV_CONST char **) &inptr, &inleft,
			 &outptr, &outleft)
		  != (size_t) (-1))
		{
		  outbuf = (unsigned char *) outptr;
		  break;
		}
	      if (errno != E2BIG)
		{
		  __libc_lock_unlock (lock);
		  goto converted;
		}
#  endif
# endif

	    resize_freemem:
	      /* We must allocate a new buffer or resize the old one.  */
	      if (malloc_count > 0)
		{
		  ++malloc_count;
		  freemem_size = malloc_count * INITIAL_BLOCK_SIZE;
		  newmem = (transmem_block_t *) realloc (transmem_list,
							 freemem_size);
# ifdef _LIBC
		  if (newmem != NULL)
		    transmem_list = transmem_list->next;
		  else
		    {
		      struct transmem_list *old = transmem_list;

		      transmem_list = transmem_list->next;
		      free (old);
		    }
# endif
		}
	      else
		{
		  malloc_count = 1;
		  freemem_size = INITIAL_BLOCK_SIZE;
		  newmem = (transmem_block_t *) malloc (freemem_size);
		}
	      if (__builtin_expect (newmem == NULL, 0))
		{
		  freemem = NULL;
		  freemem_size = 0;
		  __libc_lock_unlock (lock);
		  goto converted;
		}

# ifdef _LIBC
	      /* Add the block to the list of blocks we have to free
                 at some point.  */
	      newmem->next = transmem_list;
	      transmem_list = newmem;

	      freemem = newmem->data;
	      freemem_size -= offsetof (struct transmem_list, data);
# else
	      transmem_list = newmem;
	      freemem = newmem;
# endif

	      outbuf = freemem + sizeof (size_t);
	    }

	  /* We have now in our buffer a converted string.  Put this
	     into the table of conversions.  */
	  *(size_t *) freemem = outbuf - freemem - sizeof (size_t);
	  domain->conv_tab[act] = (char *) freemem;
	  /* Shrink freemem, but keep it aligned.  */
	  freemem_size -= outbuf - freemem;
	  freemem = outbuf;
	  freemem += freemem_size & (alignof (size_t) - 1);
	  freemem_size = freemem_size & ~ (alignof (size_t) - 1);

	  __libc_lock_unlock (lock);
	}

      /* Now domain->conv_tab[act] contains the translation of all
	 the plural variants.  */
      result = domain->conv_tab[act] + sizeof (size_t);
      resultlen = *(size_t *) domain->conv_tab[act];
    }

 converted:
  /* The result string is converted.  */

#endif /* _LIBC || HAVE_ICONV */

  *lengthp = resultlen;
  return result;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\intl\dcigettext.c:742
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\intl\dcigettext.c:1,048
parsing error 
{
  struct loaded_domain *domaindata = (struct loaded_domain *) domain->data;
  unsigned long int index;
  const char *p;

  index = plural_eval (domaindata->plural, n);
  if (index >= domaindata->nplurals)
    /* This should never happen.  It means the plural expression and the
       given maximum value do not match.  */
    index = 0;

  /* Skip INDEX strings at TRANSLATION.  */
  p = translation;
  while (index-- > 0)
    {
#ifdef _LIBC
      p = __rawmemchr (p, '\0');
#else
      p = strchr (p, '\0');
#endif
      /* And skip over the NUL byte.  */
      p++;

      if (p >= translation + translation_len)
	/* This should never happen.  It means the plural expression
	   evaluated to a value larger than the number of variants
	   available for MSGID1.  */
	return (char *) translation;
    }
  return (char *) p;
}
warning: parse error {
  struct loaded_domain *domaindata = (struct loaded_domain *) domain->data;
  unsigned long int index;
  const char *p;

  index = plural_eval (domaindata->plural, n);
  if (index >= domaindata->nplurals)
    /* This should never happen.  It means the plural expression and the
       given maximum value do not match.  */
    index = 0;

  /* Skip INDEX strings at TRANSLATION.  */
  p = translation;
  while (index-- > 0)
    {
#ifdef _LIBC
      p = __rawmemchr (p, '\0');
#else
      p = strchr (p, '\0');
#endif
      /* And skip over the NUL byte.  */
      p++;

      if (p >= translation + translation_len)
	/* This should never happen.  It means the plural expression
	   evaluated to a value larger than the number of variants
	   available for MSGID1.  */
	return (char *) translation;
    }
  return (char *) p;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\intl\dcigettext.c:1,053
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\intl\dcigettext.c:1,089
parsing error 
{
  const char *retval;

  switch (category)
  {
#ifdef LC_COLLATE
  case LC_COLLATE:
    retval = "LC_COLLATE";
    break;
#endif
#ifdef LC_CTYPE
  case LC_CTYPE:
    retval = "LC_CTYPE";
    break;
#endif
#ifdef LC_MONETARY
  case LC_MONETARY:
    retval = "LC_MONETARY";
    break;
#endif
#ifdef LC_NUMERIC
  case LC_NUMERIC:
    retval = "LC_NUMERIC";
    break;
#endif
#ifdef LC_TIME
  case LC_TIME:
    retval = "LC_TIME";
    break;
#endif
#ifdef LC_MESSAGES
  case LC_MESSAGES:
    retval = "LC_MESSAGES";
    break;
#endif
#ifdef LC_RESPONSE
  case LC_RESPONSE:
    retval = "LC_RESPONSE";
    break;
#endif
#ifdef LC_ALL
  case LC_ALL:
    /* This might not make sense but is perhaps better than any other
       value.  */
    retval = "LC_ALL";
    break;
#endif
  default:
    /* If you have a better idea for a default value let me know.  */
    retval = "LC_XXX";
  }

  return retval;
}
warning: parse error {
  const char *retval;

  switch (category)
  {
#ifdef LC_COLLATE
  case LC_COLLATE:
    retval = "LC_COLLATE";
    break;
#endif
#ifdef LC_CTYPE
  case LC_CTYPE:
    retval = "LC_CTYPE";
    break;
#endif
#ifdef LC_MONETARY
  case LC_MONETARY:
    retval = "LC_MONETARY";
    break;
#endif
#ifdef LC_NUMERIC
  case LC_NUMERIC:
    retval = "LC_NUMERIC";
    break;
#endif
#ifdef LC_TIME
  case LC_TIME:
    retval = "LC_TIME";
    break;
#endif
#ifdef LC_MESSAGES
  case LC_MESSAGES:
    retval = "LC_MESSAGES";
    break;
#endif
#ifdef LC_RESPONSE
  case LC_RESPONSE:
    retval = "LC_RESPONSE";
    break;
#endif
#ifdef LC_ALL
  case LC_ALL:
    /* This might not make sense but is perhaps better than any other
       value.  */
    retval = "LC_ALL";
    break;
#endif
  default:
    /* If you have a better idea for a default value let me know.  */
    retval = "LC_XXX";
  }

  return retval;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\intl\dcigettext.c:1,091
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\intl\dcigettext.c:1,150
parsing error 
{
  const char *language;
  const char *retval;

  /* The highest priority value is the `LANGUAGE' environment
     variable.  But we don't use the value if the currently selected
     locale is the C locale.  This is a GNU extension.  */
  language = getenv ("LANGUAGE");
  if (language != NULL && language[0] == '\0')
    language = NULL;

  /* We have to proceed with the POSIX methods of looking to `LC_ALL',
     `LC_xxx', and `LANG'.  On some systems this can be done by the
     `setlocale' function itself.  */
#ifdef _LIBC
  retval = __current_locale_name (category);
#else
  retval = _nl_locale_name (category, categoryname);
#endif

  /* Ignore LANGUAGE if the locale is set to "C" because
     1. "C" locale usually uses the ASCII encoding, and most international
	messages use non-ASCII characters. These characters get displayed
	as question marks (if using glibc's iconv()) or as invalid 8-bit
	characters (because other iconv()s refuse to convert most non-ASCII
	characters to ASCII). In any case, the output is ugly.
     2. The precise output of some programs in the "C" locale is specified
	by POSIX and should not depend on environment variables like
	"LANGUAGE".  We allow such programs to use gettext().  */
  return language != NULL && strcmp (retval, "C") != 0 ? language : retval;
}
warning: parse error {
  const char *language;
  const char *retval;

  /* The highest priority value is the `LANGUAGE' environment
     variable.  But we don't use the value if the currently selected
     locale is the C locale.  This is a GNU extension.  */
  language = getenv ("LANGUAGE");
  if (language != NULL && language[0] == '\0')
    language = NULL;

  /* We have to proceed with the POSIX methods of looking to `LC_ALL',
     `LC_xxx', and `LANG'.  On some systems this can be done by the
     `setlocale' function itself.  */
#ifdef _LIBC
  retval = __current_locale_name (category);
#else
  retval = _nl_locale_name (category, categoryname);
#endif

  /* Ignore LANGUAGE if the locale is set to "C" because
     1. "C" locale usually uses the ASCII encoding, and most international
	messages use non-ASCII characters. These characters get displayed
	as question marks (if using glibc's iconv()) or as invalid 8-bit
	characters (because other iconv()s refuse to convert most non-ASCII
	characters to ASCII). In any case, the output is ugly.
     2. The precise output of some programs in the "C" locale is specified
	by POSIX and should not depend on environment variables like
	"LANGUAGE".  We allow such programs to use gettext().  */
  return language != NULL && strcmp (retval, "C") != 0 ? language : retval;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\intl\dcigettext.c:1,153
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\intl\dcigettext.c:1,193
parsing error 
{
  while ((*dest++ = *src++) != '\0')
    /* Do nothing. */ ;
  return dest - 1;
}
warning: parse error {
  while ((*dest++ = *src++) != '\0')
    /* Do nothing. */ ;
  return dest - 1;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\intl\dcigettext.c:1,196
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\intl\dcigettext.c:1,205
parsing error 
{
  return (void *) ((char *) memcpy (dest, src, n) + n);
}
warning: parse error {
  return (void *) ((char *) memcpy (dest, src, n) + n);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\intl\dcigettext.c:1,209
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\intl\dcngettext.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\intl\gettextP.h...skip
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\intl\dcngettext.c:50
parsing error 
{
  return DCIGETTEXT (domainname, msgid1, msgid2, 1, n, category);
}
warning: parse error {
  return DCIGETTEXT (domainname, msgid1, msgid2, 1, n, category);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\intl\dcngettext.c:55
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\intl\dgettext.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\intl\gettextP.h...skip
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\intl\dgettext.c:52
parsing error 
{
  return DCGETTEXT (domainname, msgid, LC_MESSAGES);
}
warning: parse error {
  return DCGETTEXT (domainname, msgid, LC_MESSAGES);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\intl\dgettext.c:54
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\intl\dngettext.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\intl\gettextP.h...skip
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\intl\dngettext.c:52
parsing error 
{
  return DCNGETTEXT (domainname, msgid1, msgid2, n, LC_MESSAGES);
}
warning: parse error {
  return DCNGETTEXT (domainname, msgid1, msgid2, n, LC_MESSAGES);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\intl\dngettext.c:56
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\intl\explodename.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\intl\loadinfo.h...skip
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\intl\explodename.c:45
parsing error 
{
  while (name[0] != '\0' && name[0] != '_' && name[0] != '@'
	 && name[0] != '+' && name[0] != ',')
    ++name;

  return (char *) name;
}
warning: parse error {
  while (name[0] != '\0' && name[0] != '_' && name[0] != '@'
	 && name[0] != '+' && name[0] != ',')
    ++name;

  return (char *) name;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\intl\explodename.c:46
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\intl\explodename.c:57
parsing error 
{
  enum { undecided, xpg, cen } syntax;
  char *cp;
  int mask;

  *modifier = NULL;
  *territory = NULL;
  *codeset = NULL;
  *normalized_codeset = NULL;
  *special = NULL;
  *sponsor = NULL;
  *revision = NULL;

  /* Now we determine the single parts of the locale name.  First
     look for the language.  Termination symbols are `_' and `@' if
     we use XPG4 style, and `_', `+', and `,' if we use CEN syntax.  */
  mask = 0;
  syntax = undecided;
  *language = cp = name;
  cp = _nl_find_language (*language);

  if (*language == cp)
    /* This does not make sense: language has to be specified.  Use
       this entry as it is without exploding.  Perhaps it is an alias.  */
    cp = strchr (*language, '\0');
  else if (cp[0] == '_')
    {
      /* Next is the territory.  */
      cp[0] = '\0';
      *territory = ++cp;

      while (cp[0] != '\0' && cp[0] != '.' && cp[0] != '@'
	     && cp[0] != '+' && cp[0] != ',' && cp[0] != '_')
	++cp;

      mask |= TERRITORY;

      if (cp[0] == '.')
	{
	  /* Next is the codeset.  */
	  syntax = xpg;
	  cp[0] = '\0';
	  *codeset = ++cp;

	  while (cp[0] != '\0' && cp[0] != '@')
	    ++cp;

	  mask |= XPG_CODESET;

	  if (*codeset != cp && (*codeset)[0] != '\0')
	    {
	      *normalized_codeset = _nl_normalize_codeset (*codeset,
							   cp - *codeset);
	      if (strcmp (*codeset, *normalized_codeset) == 0)
		free ((char *) *normalized_codeset);
	      else
		mask |= XPG_NORM_CODESET;
	    }
	}
    }

  if (cp[0] == '@' || (syntax != xpg && cp[0] == '+'))
    {
      /* Next is the modifier.  */
      syntax = cp[0] == '@' ? xpg : cen;
      cp[0] = '\0';
      *modifier = ++cp;

      while (syntax == cen && cp[0] != '\0' && cp[0] != '+'
	     && cp[0] != ',' && cp[0] != '_')
	++cp;

      mask |= XPG_MODIFIER | CEN_AUDIENCE;
    }

  if (syntax != xpg && (cp[0] == '+' || cp[0] == ',' || cp[0] == '_'))
    {
      syntax = cen;

      if (cp[0] == '+')
	{
 	  /* Next is special application (CEN syntax).  */
	  cp[0] = '\0';
	  *special = ++cp;

	  while (cp[0] != '\0' && cp[0] != ',' && cp[0] != '_')
	    ++cp;

	  mask |= CEN_SPECIAL;
	}

      if (cp[0] == ',')
	{
 	  /* Next is sponsor (CEN syntax).  */
	  cp[0] = '\0';
	  *sponsor = ++cp;

	  while (cp[0] != '\0' && cp[0] != '_')
	    ++cp;

	  mask |= CEN_SPONSOR;
	}

      if (cp[0] == '_')
	{
 	  /* Next is revision (CEN syntax).  */
	  cp[0] = '\0';
	  *revision = ++cp;

	  mask |= CEN_REVISION;
	}
    }

  /* For CEN syntax values it might be important to have the
     separator character in the file name, not for XPG syntax.  */
  if (syntax == xpg)
    {
      if (*territory != NULL && (*territory)[0] == '\0')
	mask &= ~TERRITORY;

      if (*codeset != NULL && (*codeset)[0] == '\0')
	mask &= ~XPG_CODESET;

      if (*modifier != NULL && (*modifier)[0] == '\0')
	mask &= ~XPG_MODIFIER;
    }

  return mask;
}
warning: parse error {
  enum { undecided, xpg, cen } syntax;
  char *cp;
  int mask;

  *modifier = NULL;
  *territory = NULL;
  *codeset = NULL;
  *normalized_codeset = NULL;
  *special = NULL;
  *sponsor = NULL;
  *revision = NULL;

  /* Now we determine the single parts of the locale name.  First
     look for the language.  Termination symbols are `_' and `@' if
     we use XPG4 style, and `_', `+', and `,' if we use CEN syntax.  */
  mask = 0;
  syntax = undecided;
  *language = cp = name;
  cp = _nl_find_language (*language);

  if (*language == cp)
    /* This does not make sense: language has to be specified.  Use
       this entry as it is without exploding.  Perhaps it is an alias.  */
    cp = strchr (*language, '\0');
  else if (cp[0] == '_')
    {
      /* Next is the territory.  */
      cp[0] = '\0';
      *territory = ++cp;

      while (cp[0] != '\0' && cp[0] != '.' && cp[0] != '@'
	     && cp[0] != '+' && cp[0] != ',' && cp[0] != '_')
	++cp;

      mask |= TERRITORY;

      if (cp[0] == '.')
	{
	  /* Next is the codeset.  */
	  syntax = xpg;
	  cp[0] = '\0';
	  *codeset = ++cp;

	  while (cp[0] != '\0' && cp[0] != '@')
	    ++cp;

	  mask |= XPG_CODESET;

	  if (*codeset != cp && (*codeset)[0] != '\0')
	    {
	      *normalized_codeset = _nl_normalize_codeset (*codeset,
							   cp - *codeset);
	      if (strcmp (*codeset, *normalized_codeset) == 0)
		free ((char *) *normalized_codeset);
	      else
		mask |= XPG_NORM_CODESET;
	    }
	}
    }

  if (cp[0] == '@' || (syntax != xpg && cp[0] == '+'))
    {
      /* Next is the modifier.  */
      syntax = cp[0] == '@' ? xpg : cen;
      cp[0] = '\0';
      *modifier = ++cp;

      while (syntax == cen && cp[0] != '\0' && cp[0] != '+'
	     && cp[0] != ',' && cp[0] != '_')
	++cp;

      mask |= XPG_MODIFIER | CEN_AUDIENCE;
    }

  if (syntax != xpg && (cp[0] == '+' || cp[0] == ',' || cp[0] == '_'))
    {
      syntax = cen;

      if (cp[0] == '+')
	{
 	  /* Next is special application (CEN syntax).  */
	  cp[0] = '\0';
	  *special = ++cp;

	  while (cp[0] != '\0' && cp[0] != ',' && cp[0] != '_')
	    ++cp;

	  mask |= CEN_SPECIAL;
	}

      if (cp[0] == ',')
	{
 	  /* Next is sponsor (CEN syntax).  */
	  cp[0] = '\0';
	  *sponsor = ++cp;

	  while (cp[0] != '\0' && cp[0] != '_')
	    ++cp;

	  mask |= CEN_SPONSOR;
	}

      if (cp[0] == '_')
	{
 	  /* Next is revision (CEN syntax).  */
	  cp[0] = '\0';
	  *revision = ++cp;

	  mask |= CEN_REVISION;
	}
    }

  /* For CEN syntax values it might be important to have the
     separator character in the file name, not for XPG syntax.  */
  if (syntax == xpg)
    {
      if (*territory != NULL && (*territory)[0] == '\0')
	mask &= ~TERRITORY;

      if (*codeset != NULL && (*codeset)[0] == '\0')
	mask &= ~XPG_CODESET;

      if (*modifier != NULL && (*modifier)[0] == '\0')
	mask &= ~XPG_MODIFIER;
    }

  return mask;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\intl\explodename.c:67
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\intl\finddomain.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\intl\gettextP.h...skip
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\intl\finddomain.c:53
parsing error 
{
  struct loaded_l10nfile *retval;
  const char *language;
  const char *modifier;
  const char *territory;
  const char *codeset;
  const char *normalized_codeset;
  const char *special;
  const char *sponsor;
  const char *revision;
  const char *alias_value;
  int mask;

  /* LOCALE can consist of up to four recognized parts for the XPG syntax:

		language[_territory[.codeset]][@modifier]

     and six parts for the CEN syntax:

	language[_territory][+audience][+special][,[sponsor][_revision]]

     Beside the first part all of them are allowed to be missing.  If
     the full specified locale is not found, the less specific one are
     looked for.  The various parts will be stripped off according to
     the following order:
		(1) revision
		(2) sponsor
		(3) special
		(4) codeset
		(5) normalized codeset
		(6) territory
		(7) audience/modifier
   */

  /* If we have already tested for this locale entry there has to
     be one data set in the list of loaded domains.  */
  retval = _nl_make_l10nflist (&_nl_loaded_domains, dirname,
			       strlen (dirname) + 1, 0, locale, NULL, NULL,
			       NULL, NULL, NULL, NULL, NULL, domainname, 0);
  if (retval != NULL)
    {
      /* We know something about this locale.  */
      int cnt;

      if (retval->decided == 0)
	_nl_load_domain (retval, domainbinding);

      if (retval->data != NULL)
	return retval;

      for (cnt = 0; retval->successor[cnt] != NULL; ++cnt)
	{
	  if (retval->successor[cnt]->decided == 0)
	    _nl_load_domain (retval->successor[cnt], domainbinding);

	  if (retval->successor[cnt]->data != NULL)
	    break;
	}
      return cnt >= 0 ? retval : NULL;
      /* NOTREACHED */
    }

  /* See whether the locale value is an alias.  If yes its value
     *overwrites* the alias name.  No test for the original value is
     done.  */
  alias_value = _nl_expand_alias (locale);
  if (alias_value != NULL)
    {
#if defined _LIBC || defined HAVE_STRDUP
      locale = strdup (alias_value);
      if (locale == NULL)
	return NULL;
#else
      size_t len = strlen (alias_value) + 1;
      locale = (char *) malloc (len);
      if (locale == NULL)
	return NULL;

      memcpy (locale, alias_value, len);
#endif
    }

  /* Now we determine the single parts of the locale name.  First
     look for the language.  Termination symbols are `_' and `@' if
     we use XPG4 style, and `_', `+', and `,' if we use CEN syntax.  */
  mask = _nl_explode_name (locale, &language, &modifier, &territory,
			   &codeset, &normalized_codeset, &special,
			   &sponsor, &revision);

  /* Create all possible locale entries which might be interested in
     generalization.  */
  retval = _nl_make_l10nflist (&_nl_loaded_domains, dirname,
			       strlen (dirname) + 1, mask, language, territory,
			       codeset, normalized_codeset, modifier, special,
			       sponsor, revision, domainname, 1);
  if (retval == NULL)
    /* This means we are out of core.  */
    return NULL;

  if (retval->decided == 0)
    _nl_load_domain (retval, domainbinding);
  if (retval->data == NULL)
    {
      int cnt;
      for (cnt = 0; retval->successor[cnt] != NULL; ++cnt)
	{
	  if (retval->successor[cnt]->decided == 0)
	    _nl_load_domain (retval->successor[cnt], domainbinding);
	  if (retval->successor[cnt]->data != NULL)
	    break;
	}
    }

  /* The room for an alias was dynamically allocated.  Free it now.  */
  if (alias_value != NULL)
    free (locale);

  /* The space for normalized_codeset is dynamically allocated.  Free it.  */
  if (mask & XPG_NORM_CODESET)
    free ((void *) normalized_codeset);

  return retval;
}
warning: parse error {
  struct loaded_l10nfile *retval;
  const char *language;
  const char *modifier;
  const char *territory;
  const char *codeset;
  const char *normalized_codeset;
  const char *special;
  const char *sponsor;
  const char *revision;
  const char *alias_value;
  int mask;

  /* LOCALE can consist of up to four recognized parts for the XPG syntax:

		language[_territory[.codeset]][@modifier]

     and six parts for the CEN syntax:

	language[_territory][+audience][+special][,[sponsor][_revision]]

     Beside the first part all of them are allowed to be missing.  If
     the full specified locale is not found, the less specific one are
     looked for.  The various parts will be stripped off according to
     the following order:
		(1) revision
		(2) sponsor
		(3) special
		(4) codeset
		(5) normalized codeset
		(6) territory
		(7) audience/modifier
   */

  /* If we have already tested for this locale entry there has to
     be one data set in the list of loaded domains.  */
  retval = _nl_make_l10nflist (&_nl_loaded_domains, dirname,
			       strlen (dirname) + 1, 0, locale, NULL, NULL,
			       NULL, NULL, NULL, NULL, NULL, domainname, 0);
  if (retval != NULL)
    {
      /* We know something about this locale.  */
      int cnt;

      if (retval->decided == 0)
	_nl_load_domain (retval, domainbinding);

      if (retval->data != NULL)
	return retval;

      for (cnt = 0; retval->successor[cnt] != NULL; ++cnt)
	{
	  if (retval->successor[cnt]->decided == 0)
	    _nl_load_domain (retval->successor[cnt], domainbinding);

	  if (retval->successor[cnt]->data != NULL)
	    break;
	}
      return cnt >= 0 ? retval : NULL;
      /* NOTREACHED */
    }

  /* See whether the locale value is an alias.  If yes its value
     *overwrites* the alias name.  No test for the original value is
     done.  */
  alias_value = _nl_expand_alias (locale);
  if (alias_value != NULL)
    {
#if defined _LIBC || defined HAVE_STRDUP
      locale = strdup (alias_value);
      if (locale == NULL)
	return NULL;
#else
      size_t len = strlen (alias_value) + 1;
      locale = (char *) malloc (len);
      if (locale == NULL)
	return NULL;

      memcpy (locale, alias_value, len);
#endif
    }

  /* Now we determine the single parts of the locale name.  First
     look for the language.  Termination symbols are `_' and `@' if
     we use XPG4 style, and `_', `+', and `,' if we use CEN syntax.  */
  mask = _nl_explode_name (locale, &language, &modifier, &territory,
			   &codeset, &normalized_codeset, &special,
			   &sponsor, &revision);

  /* Create all possible locale entries which might be interested in
     generalization.  */
  retval = _nl_make_l10nflist (&_nl_loaded_domains, dirname,
			       strlen (dirname) + 1, mask, language, territory,
			       codeset, normalized_codeset, modifier, special,
			       sponsor, revision, domainname, 1);
  if (retval == NULL)
    /* This means we are out of core.  */
    return NULL;

  if (retval->decided == 0)
    _nl_load_domain (retval, domainbinding);
  if (retval->data == NULL)
    {
      int cnt;
      for (cnt = 0; retval->successor[cnt] != NULL; ++cnt)
	{
	  if (retval->successor[cnt]->decided == 0)
	    _nl_load_domain (retval->successor[cnt], domainbinding);
	  if (retval->successor[cnt]->data != NULL)
	    break;
	}
    }

  /* The room for an alias was dynamically allocated.  Free it now.  */
  if (alias_value != NULL)
    free (locale);

  /* The space for normalized_codeset is dynamically allocated.  Free it.  */
  if (mask & XPG_NORM_CODESET)
    free ((void *) normalized_codeset);

  return retval;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\intl\finddomain.c:57
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\intl\gettext.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\intl\gettextP.h...skip
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\intl\gettext.c:58
parsing error 
{
  return DCGETTEXT (NULL, msgid, LC_MESSAGES);
}
warning: parse error {
  return DCGETTEXT (NULL, msgid, LC_MESSAGES);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\intl\gettext.c:59
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\intl\intl-compat.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\intl\gettextP.h...skip
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\intl\intl-compat.c:63
parsing error 
{
  return libintl_gettext (msgid);
}
warning: parse error {
  return libintl_gettext (msgid);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\intl\intl-compat.c:64
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\intl\intl-compat.c:72
parsing error 
{
  return libintl_dgettext (domainname, msgid);
}
warning: parse error {
  return libintl_dgettext (domainname, msgid);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\intl\intl-compat.c:74
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\intl\intl-compat.c:82
parsing error 
{
  return libintl_dcgettext (domainname, msgid, category);
}
warning: parse error {
  return libintl_dcgettext (domainname, msgid, category);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\intl\intl-compat.c:85
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\intl\intl-compat.c:93
parsing error 
{
  return libintl_ngettext (msgid1, msgid2, n);
}
warning: parse error {
  return libintl_ngettext (msgid1, msgid2, n);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\intl\intl-compat.c:96
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\intl\intl-compat.c:104
parsing error 
{
  return libintl_dngettext (domainname, msgid1, msgid2, n);
}
warning: parse error {
  return libintl_dngettext (domainname, msgid1, msgid2, n);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\intl\intl-compat.c:108
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\intl\intl-compat.c:116
parsing error 
{
  return libintl_dcngettext (domainname, msgid1, msgid2, n, category);
}
warning: parse error {
  return libintl_dcngettext (domainname, msgid1, msgid2, n, category);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\intl\intl-compat.c:121
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\intl\intl-compat.c:129
parsing error 
{
  return libintl_textdomain (domainname);
}
warning: parse error {
  return libintl_textdomain (domainname);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\intl\intl-compat.c:130
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\intl\intl-compat.c:138
parsing error 
{
  return libintl_bindtextdomain (domainname, dirname);
}
warning: parse error {
  return libintl_bindtextdomain (domainname, dirname);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\intl\intl-compat.c:140
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\intl\intl-compat.c:148
parsing error 
{
  return libintl_bind_textdomain_codeset (domainname, codeset);
}
warning: parse error {
  return libintl_bind_textdomain_codeset (domainname, codeset);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\intl\intl-compat.c:150
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\intl\l10nflist.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\intl\loadinfo.h...skip
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\intl\l10nflist.c:94
parsing error 
{
  size_t count = 0;
  while (len > 0)
    {
      size_t part_len = strlen (argz);
      argz += part_len + 1;
      len -= part_len + 1;
      count++;
    }
  return count;
}
warning: parse error {
  size_t count = 0;
  while (len > 0)
    {
      size_t part_len = strlen (argz);
      argz += part_len + 1;
      len -= part_len + 1;
      count++;
    }
  return count;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\intl\l10nflist.c:96
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\intl\l10nflist.c:121
parsing error 
{
  while (len > 0)
    {
      size_t part_len = strlen (argz);
      argz += part_len;
      len -= part_len + 1;
      if (len > 0)
	*argz++ = sep;
    }
}
warning: parse error {
  while (len > 0)
    {
      size_t part_len = strlen (argz);
      argz += part_len;
      len -= part_len + 1;
      if (len > 0)
	*argz++ = sep;
    }
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\intl\l10nflist.c:125
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\intl\l10nflist.c:149
parsing error 
{
  if (entry)
    {
      if (entry < argz + argz_len)
        entry = strchr (entry, '\0') + 1;

      return entry >= argz + argz_len ? NULL : (char *) entry;
    }
  else
    if (argz_len > 0)
      return argz;
    else
      return 0;
}
warning: parse error {
  if (entry)
    {
      if (entry < argz + argz_len)
        entry = strchr (entry, '\0') + 1;

      return entry >= argz + argz_len ? NULL : (char *) entry;
    }
  else
    if (argz_len > 0)
      return argz;
    else
      return 0;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\intl\l10nflist.c:153
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\intl\l10nflist.c:176
parsing error 
{
  /* We assume that no more than 16 bits are used.  */
  x = ((x & ~0x5555) >> 1) + (x & 0x5555);
  x = ((x & ~0x3333) >> 2) + (x & 0x3333);
  x = ((x >> 4) + x) & 0x0f0f;
  x = ((x >> 8) + x) & 0xff;

  return x;
}
warning: parse error {
  /* We assume that no more than 16 bits are used.  */
  x = ((x & ~0x5555) >> 1) + (x & 0x5555);
  x = ((x & ~0x3333) >> 2) + (x & 0x3333);
  x = ((x >> 4) + x) & 0x0f0f;
  x = ((x >> 8) + x) & 0xff;

  return x;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\intl\l10nflist.c:178
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\intl\l10nflist.c:192
parsing error 
{
  char *abs_filename;
  struct loaded_l10nfile **lastp;
  struct loaded_l10nfile *retval;
  char *cp;
  size_t dirlist_count;
  size_t entries;
  int cnt;

  /* If LANGUAGE contains an absolute directory specification, we ignore
     DIRLIST.  */
  if (IS_ABSOLUTE_PATH (language))
    dirlist_len = 0;

  /* Allocate room for the full file name.  */
  abs_filename = (char *) malloc (dirlist_len
				  + strlen (language)
				  + ((mask & TERRITORY) != 0
				     ? strlen (territory) + 1 : 0)
				  + ((mask & XPG_CODESET) != 0
				     ? strlen (codeset) + 1 : 0)
				  + ((mask & XPG_NORM_CODESET) != 0
				     ? strlen (normalized_codeset) + 1 : 0)
				  + (((mask & XPG_MODIFIER) != 0
				      || (mask & CEN_AUDIENCE) != 0)
				     ? strlen (modifier) + 1 : 0)
				  + ((mask & CEN_SPECIAL) != 0
				     ? strlen (special) + 1 : 0)
				  + (((mask & CEN_SPONSOR) != 0
				      || (mask & CEN_REVISION) != 0)
				     ? (1 + ((mask & CEN_SPONSOR) != 0
					     ? strlen (sponsor) : 0)
					+ ((mask & CEN_REVISION) != 0
					   ? strlen (revision) + 1 : 0)) : 0)
				  + 1 + strlen (filename) + 1);

  if (abs_filename == NULL)
    return NULL;

  /* Construct file name.  */
  cp = abs_filename;
  if (dirlist_len > 0)
    {
      memcpy (cp, dirlist, dirlist_len);
      __argz_stringify (cp, dirlist_len, PATH_SEPARATOR);
      cp += dirlist_len;
      cp[-1] = '/';
    }

  cp = stpcpy (cp, language);

  if ((mask & TERRITORY) != 0)
    {
      *cp++ = '_';
      cp = stpcpy (cp, territory);
    }
  if ((mask & XPG_CODESET) != 0)
    {
      *cp++ = '.';
      cp = stpcpy (cp, codeset);
    }
  if ((mask & XPG_NORM_CODESET) != 0)
    {
      *cp++ = '.';
      cp = stpcpy (cp, normalized_codeset);
    }
  if ((mask & (XPG_MODIFIER | CEN_AUDIENCE)) != 0)
    {
      /* This component can be part of both syntaxes but has different
	 leading characters.  For CEN we use `+', else `@'.  */
      *cp++ = (mask & CEN_AUDIENCE) != 0 ? '+' : '@';
      cp = stpcpy (cp, modifier);
    }
  if ((mask & CEN_SPECIAL) != 0)
    {
      *cp++ = '+';
      cp = stpcpy (cp, special);
    }
  if ((mask & (CEN_SPONSOR | CEN_REVISION)) != 0)
    {
      *cp++ = ',';
      if ((mask & CEN_SPONSOR) != 0)
	cp = stpcpy (cp, sponsor);
      if ((mask & CEN_REVISION) != 0)
	{
	  *cp++ = '_';
	  cp = stpcpy (cp, revision);
	}
    }

  *cp++ = '/';
  stpcpy (cp, filename);

  /* Look in list of already loaded domains whether it is already
     available.  */
  lastp = l10nfile_list;
  for (retval = *l10nfile_list; retval != NULL; retval = retval->next)
    if (retval->filename != NULL)
      {
	int compare = strcmp (retval->filename, abs_filename);
	if (compare == 0)
	  /* We found it!  */
	  break;
	if (compare < 0)
	  {
	    /* It's not in the list.  */
	    retval = NULL;
	    break;
	  }

	lastp = &retval->next;
      }

  if (retval != NULL || do_allocate == 0)
    {
      free (abs_filename);
      return retval;
    }

  dirlist_count = (dirlist_len > 0 ? __argz_count (dirlist, dirlist_len) : 1);

  /* Allocate a new loaded_l10nfile.  */
  retval =
    (struct loaded_l10nfile *)
    malloc (sizeof (*retval)
	    + (((dirlist_count << pop (mask)) + (dirlist_count > 1 ? 1 : 0))
	       * sizeof (struct loaded_l10nfile *)));
  if (retval == NULL)
    {
      free (abs_filename);
      return NULL;
    }

  retval->filename = abs_filename;

  /* We set retval->data to NULL here; it is filled in later.
     Setting retval->decided to 1 here means that retval does not
     correspond to a real file (dirlist_count > 1) or is not worth
     looking up (if an unnormalized codeset was specified).  */
  retval->decided = (dirlist_count > 1
		     || ((mask & XPG_CODESET) != 0
			 && (mask & XPG_NORM_CODESET) != 0));
  retval->data = NULL;

  retval->next = *lastp;
  *lastp = retval;

  entries = 0;
  /* Recurse to fill the inheritance list of RETVAL.
     If the DIRLIST is a real list (i.e. DIRLIST_COUNT > 1), the RETVAL
     entry does not correspond to a real file; retval->filename contains
     colons.  In this case we loop across all elements of DIRLIST and
     across all bit patterns dominated by MASK.
     If the DIRLIST is a single directory or entirely redundant (i.e.
     DIRLIST_COUNT == 1), we loop across all bit patterns dominated by
     MASK, excluding MASK itself.
     In either case, we loop down from MASK to 0.  This has the effect
     that the extra bits in the locale name are dropped in this order:
     first the modifier, then the territory, then the codeset, then the
     normalized_codeset.  */
  for (cnt = dirlist_count > 1 ? mask : mask - 1; cnt >= 0; --cnt)
    if ((cnt & ~mask) == 0
	&& ((cnt & CEN_SPECIFIC) == 0 || (cnt & XPG_SPECIFIC) == 0)
	&& ((cnt & XPG_CODESET) == 0 || (cnt & XPG_NORM_CODESET) == 0))
      {
	if (dirlist_count > 1)
	  {
	    /* Iterate over all elements of the DIRLIST.  */
	    char *dir = NULL;

	    while ((dir = __argz_next ((char *) dirlist, dirlist_len, dir))
		   != NULL)
	      retval->successor[entries++]
		= _nl_make_l10nflist (l10nfile_list, dir, strlen (dir) + 1,
				      cnt, language, territory, codeset,
				      normalized_codeset, modifier, special,
				      sponsor, revision, filename, 1);
	  }
	else
	  retval->successor[entries++]
	    = _nl_make_l10nflist (l10nfile_list, dirlist, dirlist_len,
				  cnt, language, territory, codeset,
				  normalized_codeset, modifier, special,
				  sponsor, revision, filename, 1);
      }
  retval->successor[entries] = NULL;

  return retval;
}
warning: parse error {
  char *abs_filename;
  struct loaded_l10nfile **lastp;
  struct loaded_l10nfile *retval;
  char *cp;
  size_t dirlist_count;
  size_t entries;
  int cnt;

  /* If LANGUAGE contains an absolute directory specification, we ignore
     DIRLIST.  */
  if (IS_ABSOLUTE_PATH (language))
    dirlist_len = 0;

  /* Allocate room for the full file name.  */
  abs_filename = (char *) malloc (dirlist_len
				  + strlen (language)
				  + ((mask & TERRITORY) != 0
				     ? strlen (territory) + 1 : 0)
				  + ((mask & XPG_CODESET) != 0
				     ? strlen (codeset) + 1 : 0)
				  + ((mask & XPG_NORM_CODESET) != 0
				     ? strlen (normalized_codeset) + 1 : 0)
				  + (((mask & XPG_MODIFIER) != 0
				      || (mask & CEN_AUDIENCE) != 0)
				     ? strlen (modifier) + 1 : 0)
				  + ((mask & CEN_SPECIAL) != 0
				     ? strlen (special) + 1 : 0)
				  + (((mask & CEN_SPONSOR) != 0
				      || (mask & CEN_REVISION) != 0)
				     ? (1 + ((mask & CEN_SPONSOR) != 0
					     ? strlen (sponsor) : 0)
					+ ((mask & CEN_REVISION) != 0
					   ? strlen (revision) + 1 : 0)) : 0)
				  + 1 + strlen (filename) + 1);

  if (abs_filename == NULL)
    return NULL;

  /* Construct file name.  */
  cp = abs_filename;
  if (dirlist_len > 0)
    {
      memcpy (cp, dirlist, dirlist_len);
      __argz_stringify (cp, dirlist_len, PATH_SEPARATOR);
      cp += dirlist_len;
      cp[-1] = '/';
    }

  cp = stpcpy (cp, language);

  if ((mask & TERRITORY) != 0)
    {
      *cp++ = '_';
      cp = stpcpy (cp, territory);
    }
  if ((mask & XPG_CODESET) != 0)
    {
      *cp++ = '.';
      cp = stpcpy (cp, codeset);
    }
  if ((mask & XPG_NORM_CODESET) != 0)
    {
      *cp++ = '.';
      cp = stpcpy (cp, normalized_codeset);
    }
  if ((mask & (XPG_MODIFIER | CEN_AUDIENCE)) != 0)
    {
      /* This component can be part of both syntaxes but has different
	 leading characters.  For CEN we use `+', else `@'.  */
      *cp++ = (mask & CEN_AUDIENCE) != 0 ? '+' : '@';
      cp = stpcpy (cp, modifier);
    }
  if ((mask & CEN_SPECIAL) != 0)
    {
      *cp++ = '+';
      cp = stpcpy (cp, special);
    }
  if ((mask & (CEN_SPONSOR | CEN_REVISION)) != 0)
    {
      *cp++ = ',';
      if ((mask & CEN_SPONSOR) != 0)
	cp = stpcpy (cp, sponsor);
      if ((mask & CEN_REVISION) != 0)
	{
	  *cp++ = '_';
	  cp = stpcpy (cp, revision);
	}
    }

  *cp++ = '/';
  stpcpy (cp, filename);

  /* Look in list of already loaded domains whether it is already
     available.  */
  lastp = l10nfile_list;
  for (retval = *l10nfile_list; retval != NULL; retval = retval->next)
    if (retval->filename != NULL)
      {
	int compare = strcmp (retval->filename, abs_filename);
	if (compare == 0)
	  /* We found it!  */
	  break;
	if (compare < 0)
	  {
	    /* It's not in the list.  */
	    retval = NULL;
	    break;
	  }

	lastp = &retval->next;
      }

  if (retval != NULL || do_allocate == 0)
    {
      free (abs_filename);
      return retval;
    }

  dirlist_count = (dirlist_len > 0 ? __argz_count (dirlist, dirlist_len) : 1);

  /* Allocate a new loaded_l10nfile.  */
  retval =
    (struct loaded_l10nfile *)
    malloc (sizeof (*retval)
	    + (((dirlist_count << pop (mask)) + (dirlist_count > 1 ? 1 : 0))
	       * sizeof (struct loaded_l10nfile *)));
  if (retval == NULL)
    {
      free (abs_filename);
      return NULL;
    }

  retval->filename = abs_filename;

  /* We set retval->data to NULL here; it is filled in later.
     Setting retval->decided to 1 here means that retval does not
     correspond to a real file (dirlist_count > 1) or is not worth
     looking up (if an unnormalized codeset was specified).  */
  retval->decided = (dirlist_count > 1
		     || ((mask & XPG_CODESET) != 0
			 && (mask & XPG_NORM_CODESET) != 0));
  retval->data = NULL;

  retval->next = *lastp;
  *lastp = retval;

  entries = 0;
  /* Recurse to fill the inheritance list of RETVAL.
     If the DIRLIST is a real list (i.e. DIRLIST_COUNT > 1), the RETVAL
     entry does not correspond to a real file; retval->filename contains
     colons.  In this case we loop across all elements of DIRLIST and
     across all bit patterns dominated by MASK.
     If the DIRLIST is a single directory or entirely redundant (i.e.
     DIRLIST_COUNT == 1), we loop across all bit patterns dominated by
     MASK, excluding MASK itself.
     In either case, we loop down from MASK to 0.  This has the effect
     that the extra bits in the locale name are dropped in this order:
     first the modifier, then the territory, then the codeset, then the
     normalized_codeset.  */
  for (cnt = dirlist_count > 1 ? mask : mask - 1; cnt >= 0; --cnt)
    if ((cnt & ~mask) == 0
	&& ((cnt & CEN_SPECIFIC) == 0 || (cnt & XPG_SPECIFIC) == 0)
	&& ((cnt & XPG_CODESET) == 0 || (cnt & XPG_NORM_CODESET) == 0))
      {
	if (dirlist_count > 1)
	  {
	    /* Iterate over all elements of the DIRLIST.  */
	    char *dir = NULL;

	    while ((dir = __argz_next ((char *) dirlist, dirlist_len, dir))
		   != NULL)
	      retval->successor[entries++]
		= _nl_make_l10nflist (l10nfile_list, dir, strlen (dir) + 1,
				      cnt, language, territory, codeset,
				      normalized_codeset, modifier, special,
				      sponsor, revision, filename, 1);
	  }
	else
	  retval->successor[entries++]
	    = _nl_make_l10nflist (l10nfile_list, dirlist, dirlist_len,
				  cnt, language, territory, codeset,
				  normalized_codeset, modifier, special,
				  sponsor, revision, filename, 1);
      }
  retval->successor[entries] = NULL;

  return retval;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\intl\l10nflist.c:207
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\intl\l10nflist.c:403
parsing error 
{
  int len = 0;
  int only_digit = 1;
  char *retval;
  char *wp;
  size_t cnt;

  for (cnt = 0; cnt < name_len; ++cnt)
    if (isalnum ((unsigned char) codeset[cnt]))
      {
	++len;

	if (isalpha ((unsigned char) codeset[cnt]))
	  only_digit = 0;
      }

  retval = (char *) malloc ((only_digit ? 3 : 0) + len + 1);

  if (retval != NULL)
    {
      if (only_digit)
	wp = stpcpy (retval, "iso");
      else
	wp = retval;

      for (cnt = 0; cnt < name_len; ++cnt)
	if (isalpha ((unsigned char) codeset[cnt]))
	  *wp++ = tolower ((unsigned char) codeset[cnt]);
	else if (isdigit ((unsigned char) codeset[cnt]))
	  *wp++ = codeset[cnt];

      *wp = '\0';
    }

  return (const char *) retval;
}
warning: parse error {
  int len = 0;
  int only_digit = 1;
  char *retval;
  char *wp;
  size_t cnt;

  for (cnt = 0; cnt < name_len; ++cnt)
    if (isalnum ((unsigned char) codeset[cnt]))
      {
	++len;

	if (isalpha ((unsigned char) codeset[cnt]))
	  only_digit = 0;
      }

  retval = (char *) malloc ((only_digit ? 3 : 0) + len + 1);

  if (retval != NULL)
    {
      if (only_digit)
	wp = stpcpy (retval, "iso");
      else
	wp = retval;

      for (cnt = 0; cnt < name_len; ++cnt)
	if (isalpha ((unsigned char) codeset[cnt]))
	  *wp++ = tolower ((unsigned char) codeset[cnt]);
	else if (isdigit ((unsigned char) codeset[cnt]))
	  *wp++ = codeset[cnt];

      *wp = '\0';
    }

  return (const char *) retval;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\intl\l10nflist.c:405
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\intl\l10nflist.c:451
parsing error 
{
  while ((*dest++ = *src++) != '\0')
    /* Do nothing. */ ;
  return dest - 1;
}
warning: parse error {
  while ((*dest++ = *src++) != '\0')
    /* Do nothing. */ ;
  return dest - 1;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\intl\l10nflist.c:454
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\intl\loadmsgcat.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\intl\gmo.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\intl\gettextP.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\intl\hash-string.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\intl\plural-exp.h...skip
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\intl\loadmsgcat.c:510
parsing error 
{
  /* Test for an ISO C 99 section 7.8.1 format string directive.
     Syntax:
     P R I { d | i | o | u | x | X }
     { { | LEAST | FAST } { 8 | 16 | 32 | 64 } | MAX | PTR }  */
  /* We don't use a table of 14 times 6 'const char *' strings here, because
     data relocations cost startup time.  */
  if (name[0] == 'P' && name[1] == 'R' && name[2] == 'I')
    {
      if (name[3] == 'd' || name[3] == 'i' || name[3] == 'o' || name[3] == 'u'
	  || name[3] == 'x' || name[3] == 'X')
	{
	  if (name[4] == '8' && name[5] == '\0')
	    {
	      if (name[3] == 'd')
		return PRId8;
	      if (name[3] == 'i')
		return PRIi8;
	      if (name[3] == 'o')
		return PRIo8;
	      if (name[3] == 'u')
		return PRIu8;
	      if (name[3] == 'x')
		return PRIx8;
	      if (name[3] == 'X')
		return PRIX8;
	      abort ();
	    }
	  if (name[4] == '1' && name[5] == '6' && name[6] == '\0')
	    {
	      if (name[3] == 'd')
		return PRId16;
	      if (name[3] == 'i')
		return PRIi16;
	      if (name[3] == 'o')
		return PRIo16;
	      if (name[3] == 'u')
		return PRIu16;
	      if (name[3] == 'x')
		return PRIx16;
	      if (name[3] == 'X')
		return PRIX16;
	      abort ();
	    }
	  if (name[4] == '3' && name[5] == '2' && name[6] == '\0')
	    {
	      if (name[3] == 'd')
		return PRId32;
	      if (name[3] == 'i')
		return PRIi32;
	      if (name[3] == 'o')
		return PRIo32;
	      if (name[3] == 'u')
		return PRIu32;
	      if (name[3] == 'x')
		return PRIx32;
	      if (name[3] == 'X')
		return PRIX32;
	      abort ();
	    }
	  if (name[4] == '6' && name[5] == '4' && name[6] == '\0')
	    {
	      if (name[3] == 'd')
		return PRId64;
	      if (name[3] == 'i')
		return PRIi64;
	      if (name[3] == 'o')
		return PRIo64;
	      if (name[3] == 'u')
		return PRIu64;
	      if (name[3] == 'x')
		return PRIx64;
	      if (name[3] == 'X')
		return PRIX64;
	      abort ();
	    }
	  if (name[4] == 'L' && name[5] == 'E' && name[6] == 'A'
	      && name[7] == 'S' && name[8] == 'T')
	    {
	      if (name[9] == '8' && name[10] == '\0')
		{
		  if (name[3] == 'd')
		    return PRIdLEAST8;
		  if (name[3] == 'i')
		    return PRIiLEAST8;
		  if (name[3] == 'o')
		    return PRIoLEAST8;
		  if (name[3] == 'u')
		    return PRIuLEAST8;
		  if (name[3] == 'x')
		    return PRIxLEAST8;
		  if (name[3] == 'X')
		    return PRIXLEAST8;
		  abort ();
		}
	      if (name[9] == '1' && name[10] == '6' && name[11] == '\0')
		{
		  if (name[3] == 'd')
		    return PRIdLEAST16;
		  if (name[3] == 'i')
		    return PRIiLEAST16;
		  if (name[3] == 'o')
		    return PRIoLEAST16;
		  if (name[3] == 'u')
		    return PRIuLEAST16;
		  if (name[3] == 'x')
		    return PRIxLEAST16;
		  if (name[3] == 'X')
		    return PRIXLEAST16;
		  abort ();
		}
	      if (name[9] == '3' && name[10] == '2' && name[11] == '\0')
		{
		  if (name[3] == 'd')
		    return PRIdLEAST32;
		  if (name[3] == 'i')
		    return PRIiLEAST32;
		  if (name[3] == 'o')
		    return PRIoLEAST32;
		  if (name[3] == 'u')
		    return PRIuLEAST32;
		  if (name[3] == 'x')
		    return PRIxLEAST32;
		  if (name[3] == 'X')
		    return PRIXLEAST32;
		  abort ();
		}
	      if (name[9] == '6' && name[10] == '4' && name[11] == '\0')
		{
		  if (name[3] == 'd')
		    return PRIdLEAST64;
		  if (name[3] == 'i')
		    return PRIiLEAST64;
		  if (name[3] == 'o')
		    return PRIoLEAST64;
		  if (name[3] == 'u')
		    return PRIuLEAST64;
		  if (name[3] == 'x')
		    return PRIxLEAST64;
		  if (name[3] == 'X')
		    return PRIXLEAST64;
		  abort ();
		}
	    }
	  if (name[4] == 'F' && name[5] == 'A' && name[6] == 'S'
	      && name[7] == 'T')
	    {
	      if (name[8] == '8' && name[9] == '\0')
		{
		  if (name[3] == 'd')
		    return PRIdFAST8;
		  if (name[3] == 'i')
		    return PRIiFAST8;
		  if (name[3] == 'o')
		    return PRIoFAST8;
		  if (name[3] == 'u')
		    return PRIuFAST8;
		  if (name[3] == 'x')
		    return PRIxFAST8;
		  if (name[3] == 'X')
		    return PRIXFAST8;
		  abort ();
		}
	      if (name[8] == '1' && name[9] == '6' && name[10] == '\0')
		{
		  if (name[3] == 'd')
		    return PRIdFAST16;
		  if (name[3] == 'i')
		    return PRIiFAST16;
		  if (name[3] == 'o')
		    return PRIoFAST16;
		  if (name[3] == 'u')
		    return PRIuFAST16;
		  if (name[3] == 'x')
		    return PRIxFAST16;
		  if (name[3] == 'X')
		    return PRIXFAST16;
		  abort ();
		}
	      if (name[8] == '3' && name[9] == '2' && name[10] == '\0')
		{
		  if (name[3] == 'd')
		    return PRIdFAST32;
		  if (name[3] == 'i')
		    return PRIiFAST32;
		  if (name[3] == 'o')
		    return PRIoFAST32;
		  if (name[3] == 'u')
		    return PRIuFAST32;
		  if (name[3] == 'x')
		    return PRIxFAST32;
		  if (name[3] == 'X')
		    return PRIXFAST32;
		  abort ();
		}
	      if (name[8] == '6' && name[9] == '4' && name[10] == '\0')
		{
		  if (name[3] == 'd')
		    return PRIdFAST64;
		  if (name[3] == 'i')
		    return PRIiFAST64;
		  if (name[3] == 'o')
		    return PRIoFAST64;
		  if (name[3] == 'u')
		    return PRIuFAST64;
		  if (name[3] == 'x')
		    return PRIxFAST64;
		  if (name[3] == 'X')
		    return PRIXFAST64;
		  abort ();
		}
	    }
	  if (name[4] == 'M' && name[5] == 'A' && name[6] == 'X'
	      && name[7] == '\0')
	    {
	      if (name[3] == 'd')
		return PRIdMAX;
	      if (name[3] == 'i')
		return PRIiMAX;
	      if (name[3] == 'o')
		return PRIoMAX;
	      if (name[3] == 'u')
		return PRIuMAX;
	      if (name[3] == 'x')
		return PRIxMAX;
	      if (name[3] == 'X')
		return PRIXMAX;
	      abort ();
	    }
	  if (name[4] == 'P' && name[5] == 'T' && name[6] == 'R'
	      && name[7] == '\0')
	    {
	      if (name[3] == 'd')
		return PRIdPTR;
	      if (name[3] == 'i')
		return PRIiPTR;
	      if (name[3] == 'o')
		return PRIoPTR;
	      if (name[3] == 'u')
		return PRIuPTR;
	      if (name[3] == 'x')
		return PRIxPTR;
	      if (name[3] == 'X')
		return PRIXPTR;
	      abort ();
	    }
	}
    }
  /* Other system dependent strings are not valid.  */
  return NULL;
}
warning: parse error {
  /* Test for an ISO C 99 section 7.8.1 format string directive.
     Syntax:
     P R I { d | i | o | u | x | X }
     { { | LEAST | FAST } { 8 | 16 | 32 | 64 } | MAX | PTR }  */
  /* We don't use a table of 14 times 6 'const char *' strings here, because
     data relocations cost startup time.  */
  if (name[0] == 'P' && name[1] == 'R' && name[2] == 'I')
    {
      if (name[3] == 'd' || name[3] == 'i' || name[3] == 'o' || name[3] == 'u'
	  || name[3] == 'x' || name[3] == 'X')
	{
	  if (name[4] == '8' && name[5] == '\0')
	    {
	      if (name[3] == 'd')
		return PRId8;
	      if (name[3] == 'i')
		return PRIi8;
	      if (name[3] == 'o')
		return PRIo8;
	      if (name[3] == 'u')
		return PRIu8;
	      if (name[3] == 'x')
		return PRIx8;
	      if (name[3] == 'X')
		return PRIX8;
	      abort ();
	    }
	  if (name[4] == '1' && name[5] == '6' && name[6] == '\0')
	    {
	      if (name[3] == 'd')
		return PRId16;
	      if (name[3] == 'i')
		return PRIi16;
	      if (name[3] == 'o')
		return PRIo16;
	      if (name[3] == 'u')
		return PRIu16;
	      if (name[3] == 'x')
		return PRIx16;
	      if (name[3] == 'X')
		return PRIX16;
	      abort ();
	    }
	  if (name[4] == '3' && name[5] == '2' && name[6] == '\0')
	    {
	      if (name[3] == 'd')
		return PRId32;
	      if (name[3] == 'i')
		return PRIi32;
	      if (name[3] == 'o')
		return PRIo32;
	      if (name[3] == 'u')
		return PRIu32;
	      if (name[3] == 'x')
		return PRIx32;
	      if (name[3] == 'X')
		return PRIX32;
	      abort ();
	    }
	  if (name[4] == '6' && name[5] == '4' && name[6] == '\0')
	    {
	      if (name[3] == 'd')
		return PRId64;
	      if (name[3] == 'i')
		return PRIi64;
	      if (name[3] == 'o')
		return PRIo64;
	      if (name[3] == 'u')
		return PRIu64;
	      if (name[3] == 'x')
		return PRIx64;
	      if (name[3] == 'X')
		return PRIX64;
	      abort ();
	    }
	  if (name[4] == 'L' && name[5] == 'E' && name[6] == 'A'
	      && name[7] == 'S' && name[8] == 'T')
	    {
	      if (name[9] == '8' && name[10] == '\0')
		{
		  if (name[3] == 'd')
		    return PRIdLEAST8;
		  if (name[3] == 'i')
		    return PRIiLEAST8;
		  if (name[3] == 'o')
		    return PRIoLEAST8;
		  if (name[3] == 'u')
		    return PRIuLEAST8;
		  if (name[3] == 'x')
		    return PRIxLEAST8;
		  if (name[3] == 'X')
		    return PRIXLEAST8;
		  abort ();
		}
	      if (name[9] == '1' && name[10] == '6' && name[11] == '\0')
		{
		  if (name[3] == 'd')
		    return PRIdLEAST16;
		  if (name[3] == 'i')
		    return PRIiLEAST16;
		  if (name[3] == 'o')
		    return PRIoLEAST16;
		  if (name[3] == 'u')
		    return PRIuLEAST16;
		  if (name[3] == 'x')
		    return PRIxLEAST16;
		  if (name[3] == 'X')
		    return PRIXLEAST16;
		  abort ();
		}
	      if (name[9] == '3' && name[10] == '2' && name[11] == '\0')
		{
		  if (name[3] == 'd')
		    return PRIdLEAST32;
		  if (name[3] == 'i')
		    return PRIiLEAST32;
		  if (name[3] == 'o')
		    return PRIoLEAST32;
		  if (name[3] == 'u')
		    return PRIuLEAST32;
		  if (name[3] == 'x')
		    return PRIxLEAST32;
		  if (name[3] == 'X')
		    return PRIXLEAST32;
		  abort ();
		}
	      if (name[9] == '6' && name[10] == '4' && name[11] == '\0')
		{
		  if (name[3] == 'd')
		    return PRIdLEAST64;
		  if (name[3] == 'i')
		    return PRIiLEAST64;
		  if (name[3] == 'o')
		    return PRIoLEAST64;
		  if (name[3] == 'u')
		    return PRIuLEAST64;
		  if (name[3] == 'x')
		    return PRIxLEAST64;
		  if (name[3] == 'X')
		    return PRIXLEAST64;
		  abort ();
		}
	    }
	  if (name[4] == 'F' && name[5] == 'A' && name[6] == 'S'
	      && name[7] == 'T')
	    {
	      if (name[8] == '8' && name[9] == '\0')
		{
		  if (name[3] == 'd')
		    return PRIdFAST8;
		  if (name[3] == 'i')
		    return PRIiFAST8;
		  if (name[3] == 'o')
		    return PRIoFAST8;
		  if (name[3] == 'u')
		    return PRIuFAST8;
		  if (name[3] == 'x')
		    return PRIxFAST8;
		  if (name[3] == 'X')
		    return PRIXFAST8;
		  abort ();
		}
	      if (name[8] == '1' && name[9] == '6' && name[10] == '\0')
		{
		  if (name[3] == 'd')
		    return PRIdFAST16;
		  if (name[3] == 'i')
		    return PRIiFAST16;
		  if (name[3] == 'o')
		    return PRIoFAST16;
		  if (name[3] == 'u')
		    return PRIuFAST16;
		  if (name[3] == 'x')
		    return PRIxFAST16;
		  if (name[3] == 'X')
		    return PRIXFAST16;
		  abort ();
		}
	      if (name[8] == '3' && name[9] == '2' && name[10] == '\0')
		{
		  if (name[3] == 'd')
		    return PRIdFAST32;
		  if (name[3] == 'i')
		    return PRIiFAST32;
		  if (name[3] == 'o')
		    return PRIoFAST32;
		  if (name[3] == 'u')
		    return PRIuFAST32;
		  if (name[3] == 'x')
		    return PRIxFAST32;
		  if (name[3] == 'X')
		    return PRIXFAST32;
		  abort ();
		}
	      if (name[8] == '6' && name[9] == '4' && name[10] == '\0')
		{
		  if (name[3] == 'd')
		    return PRIdFAST64;
		  if (name[3] == 'i')
		    return PRIiFAST64;
		  if (name[3] == 'o')
		    return PRIoFAST64;
		  if (name[3] == 'u')
		    return PRIuFAST64;
		  if (name[3] == 'x')
		    return PRIxFAST64;
		  if (name[3] == 'X')
		    return PRIXFAST64;
		  abort ();
		}
	    }
	  if (name[4] == 'M' && name[5] == 'A' && name[6] == 'X'
	      && name[7] == '\0')
	    {
	      if (name[3] == 'd')
		return PRIdMAX;
	      if (name[3] == 'i')
		return PRIiMAX;
	      if (name[3] == 'o')
		return PRIoMAX;
	      if (name[3] == 'u')
		return PRIuMAX;
	      if (name[3] == 'x')
		return PRIxMAX;
	      if (name[3] == 'X')
		return PRIXMAX;
	      abort ();
	    }
	  if (name[4] == 'P' && name[5] == 'T' && name[6] == 'R'
	      && name[7] == '\0')
	    {
	      if (name[3] == 'd')
		return PRIdPTR;
	      if (name[3] == 'i')
		return PRIiPTR;
	      if (name[3] == 'o')
		return PRIoPTR;
	      if (name[3] == 'u')
		return PRIuPTR;
	      if (name[3] == 'x')
		return PRIxPTR;
	      if (name[3] == 'X')
		return PRIXPTR;
	      abort ();
	    }
	}
    }
  /* Other system dependent strings are not valid.  */
  return NULL;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\intl\loadmsgcat.c:511
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\intl\loadmsgcat.c:767
parsing error 
{
  /* Find out about the character set the file is encoded with.
     This can be found (in textual form) in the entry "".  If this
     entry does not exist or if this does not contain the `charset='
     information, we will assume the charset matches the one the
     current locale and we don't have to perform any conversion.  */
  char *nullentry;
  size_t nullentrylen;

  /* Preinitialize fields, to avoid recursion during _nl_find_msg.  */
  domain->codeset_cntr =
    (domainbinding != NULL ? domainbinding->codeset_cntr : 0);
#ifdef _LIBC
  domain->conv = (__gconv_t) -1;
#else
# if HAVE_ICONV
  domain->conv = (iconv_t) -1;
# endif
#endif
  domain->conv_tab = NULL;

  /* Get the header entry.  */
  nullentry = _nl_find_msg (domain_file, domainbinding, "", &nullentrylen);

  if (nullentry != NULL)
    {
#if defined _LIBC || HAVE_ICONV
      const char *charsetstr;

      charsetstr = strstr (nullentry, "charset=");
      if (charsetstr != NULL)
	{
	  size_t len;
	  char *charset;
	  const char *outcharset;

	  charsetstr += strlen ("charset=");
	  len = strcspn (charsetstr, " \t\n");

	  charset = (char *) alloca (len + 1);
# if defined _LIBC || HAVE_MEMPCPY
	  *((char *) mempcpy (charset, charsetstr, len)) = '\0';
# else
	  memcpy (charset, charsetstr, len);
	  charset[len] = '\0';
# endif

	  /* The output charset should normally be determined by the
	     locale.  But sometimes the locale is not used or not correctly
	     set up, so we provide a possibility for the user to override
	     this.  Moreover, the value specified through
	     bind_textdomain_codeset overrides both.  */
	  if (domainbinding != NULL && domainbinding->codeset != NULL)
	    outcharset = domainbinding->codeset;
	  else
	    {
	      outcharset = getenv ("OUTPUT_CHARSET");
	      if (outcharset == NULL || outcharset[0] == '\0')
		{
# ifdef _LIBC
		  outcharset = _NL_CURRENT (LC_CTYPE, CODESET);
# else
#  if HAVE_ICONV
		  extern const char *locale_charset PARAMS ((void));
		  outcharset = locale_charset ();
#  endif
# endif
		}
	    }

# ifdef _LIBC
	  /* We always want to use transliteration.  */
	  outcharset = norm_add_slashes (outcharset, "TRANSLIT");
	  charset = norm_add_slashes (charset, NULL);
	  if (__gconv_open (outcharset, charset, &domain->conv,
			    GCONV_AVOID_NOCONV)
	      != __GCONV_OK)
	    domain->conv = (__gconv_t) -1;
# else
#  if HAVE_ICONV
	  /* When using GNU libc >= 2.2 or GNU libiconv >= 1.5,
	     we want to use transliteration.  */
#   if (__GLIBC__ == 2 && __GLIBC_MINOR__ >= 2) || __GLIBC__ > 2 \
       || _LIBICONV_VERSION >= 0x0105
	  if (strchr (outcharset, '/') == NULL)
	    {
	      char *tmp;

	      len = strlen (outcharset);
	      tmp = (char *) alloca (len + 10 + 1);
	      memcpy (tmp, outcharset, len);
	      memcpy (tmp + len, "//TRANSLIT", 10 + 1);
	      outcharset = tmp;

	      domain->conv = iconv_open (outcharset, charset);

	      freea (outcharset);
	    }
	  else
#   endif
	    domain->conv = iconv_open (outcharset, charset);
#  endif
# endif

	  freea (charset);
	}
#endif /* _LIBC || HAVE_ICONV */
    }

  return nullentry;
}
warning: parse error {
  /* Find out about the character set the file is encoded with.
     This can be found (in textual form) in the entry "".  If this
     entry does not exist or if this does not contain the `charset='
     information, we will assume the charset matches the one the
     current locale and we don't have to perform any conversion.  */
  char *nullentry;
  size_t nullentrylen;

  /* Preinitialize fields, to avoid recursion during _nl_find_msg.  */
  domain->codeset_cntr =
    (domainbinding != NULL ? domainbinding->codeset_cntr : 0);
#ifdef _LIBC
  domain->conv = (__gconv_t) -1;
#else
# if HAVE_ICONV
  domain->conv = (iconv_t) -1;
# endif
#endif
  domain->conv_tab = NULL;

  /* Get the header entry.  */
  nullentry = _nl_find_msg (domain_file, domainbinding, "", &nullentrylen);

  if (nullentry != NULL)
    {
#if defined _LIBC || HAVE_ICONV
      const char *charsetstr;

      charsetstr = strstr (nullentry, "charset=");
      if (charsetstr != NULL)
	{
	  size_t len;
	  char *charset;
	  const char *outcharset;

	  charsetstr += strlen ("charset=");
	  len = strcspn (charsetstr, " \t\n");

	  charset = (char *) alloca (len + 1);
# if defined _LIBC || HAVE_MEMPCPY
	  *((char *) mempcpy (charset, charsetstr, len)) = '\0';
# else
	  memcpy (charset, charsetstr, len);
	  charset[len] = '\0';
# endif

	  /* The output charset should normally be determined by the
	     locale.  But sometimes the locale is not used or not correctly
	     set up, so we provide a possibility for the user to override
	     this.  Moreover, the value specified through
	     bind_textdomain_codeset overrides both.  */
	  if (domainbinding != NULL && domainbinding->codeset != NULL)
	    outcharset = domainbinding->codeset;
	  else
	    {
	      outcharset = getenv ("OUTPUT_CHARSET");
	      if (outcharset == NULL || outcharset[0] == '\0')
		{
# ifdef _LIBC
		  outcharset = _NL_CURRENT (LC_CTYPE, CODESET);
# else
#  if HAVE_ICONV
		  extern const char *locale_charset PARAMS ((void));
		  outcharset = locale_charset ();
#  endif
# endif
		}
	    }

# ifdef _LIBC
	  /* We always want to use transliteration.  */
	  outcharset = norm_add_slashes (outcharset, "TRANSLIT");
	  charset = norm_add_slashes (charset, NULL);
	  if (__gconv_open (outcharset, charset, &domain->conv,
			    GCONV_AVOID_NOCONV)
	      != __GCONV_OK)
	    domain->conv = (__gconv_t) -1;
# else
#  if HAVE_ICONV
	  /* When using GNU libc >= 2.2 or GNU libiconv >= 1.5,
	     we want to use transliteration.  */
#   if (__GLIBC__ == 2 && __GLIBC_MINOR__ >= 2) || __GLIBC__ > 2 \
       || _LIBICONV_VERSION >= 0x0105
	  if (strchr (outcharset, '/') == NULL)
	    {
	      char *tmp;

	      len = strlen (outcharset);
	      tmp = (char *) alloca (len + 10 + 1);
	      memcpy (tmp, outcharset, len);
	      memcpy (tmp + len, "//TRANSLIT", 10 + 1);
	      outcharset = tmp;

	      domain->conv = iconv_open (outcharset, charset);

	      freea (outcharset);
	    }
	  else
#   endif
	    domain->conv = iconv_open (outcharset, charset);
#  endif
# endif

	  freea (charset);
	}
#endif /* _LIBC || HAVE_ICONV */
    }

  return nullentry;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\intl\loadmsgcat.c:771
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\intl\loadmsgcat.c:886
parsing error 
{
  if (domain->conv_tab != NULL && domain->conv_tab != (char **) -1)
    free (domain->conv_tab);

#ifdef _LIBC
  if (domain->conv != (__gconv_t) -1)
    __gconv_close (domain->conv);
#else
# if HAVE_ICONV
  if (domain->conv != (iconv_t) -1)
    iconv_close (domain->conv);
# endif
#endif
}
warning: parse error {
  if (domain->conv_tab != NULL && domain->conv_tab != (char **) -1)
    free (domain->conv_tab);

#ifdef _LIBC
  if (domain->conv != (__gconv_t) -1)
    __gconv_close (domain->conv);
#else
# if HAVE_ICONV
  if (domain->conv != (iconv_t) -1)
    iconv_close (domain->conv);
# endif
#endif
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\intl\loadmsgcat.c:888
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\intl\loadmsgcat.c:907
parsing error 
{
  int fd;
  size_t size;
#ifdef _LIBC
  struct stat64 st;
#else
  struct stat st;
#endif
  struct mo_file_header *data = (struct mo_file_header *) -1;
  int use_mmap = 0;
  struct loaded_domain *domain;
  int revision;
  const char *nullentry;

  domain_file->decided = 1;
  domain_file->data = NULL;

  /* Note that it would be useless to store domainbinding in domain_file
     because domainbinding might be == NULL now but != NULL later (after
     a call to bind_textdomain_codeset).  */

  /* If the record does not represent a valid locale the FILENAME
     might be NULL.  This can happen when according to the given
     specification the locale file name is different for XPG and CEN
     syntax.  */
  if (domain_file->filename == NULL)
    return;

  /* Try to open the addressed file.  */
  fd = open (domain_file->filename, O_RDONLY | O_BINARY);
  if (fd == -1)
    return;

  /* We must know about the size of the file.  */
  if (
#ifdef _LIBC
      __builtin_expect (fstat64 (fd, &st) != 0, 0)
#else
      __builtin_expect (fstat (fd, &st) != 0, 0)
#endif
      || __builtin_expect ((size = (size_t) st.st_size) != st.st_size, 0)
      || __builtin_expect (size < sizeof (struct mo_file_header), 0))
    {
      /* Something went wrong.  */
      close (fd);
      return;
    }

#ifdef HAVE_MMAP
  /* Now we are ready to load the file.  If mmap() is available we try
     this first.  If not available or it failed we try to load it.  */
  data = (struct mo_file_header *) mmap (NULL, size, PROT_READ,
					 MAP_PRIVATE, fd, 0);

  if (__builtin_expect (data != (struct mo_file_header *) -1, 1))
    {
      /* mmap() call was successful.  */
      close (fd);
      use_mmap = 1;
    }
#endif

  /* If the data is not yet available (i.e. mmap'ed) we try to load
     it manually.  */
  if (data == (struct mo_file_header *) -1)
    {
      size_t to_read;
      char *read_ptr;

      data = (struct mo_file_header *) malloc (size);
      if (data == NULL)
	{
	  if (use_mmap == 0)
	    close (fd);
	  return;
	}

      to_read = size;
      read_ptr = (char *) data;
      do
	{
	  long int nb = (long int) read (fd, read_ptr, to_read);
	  if (nb <= 0)
	    {
#ifdef EINTR
	      if (nb == -1 && errno == EINTR)
		continue;
#endif
	      close (fd);
	      return;
	    }
	  read_ptr += nb;
	  to_read -= nb;
	}
      while (to_read > 0);

      close (fd);
    }

  /* Using the magic number we can test whether it really is a message
     catalog file.  */
  if (__builtin_expect (data->magic != _MAGIC && data->magic != _MAGIC_SWAPPED,
			0))
    {
      /* The magic number is wrong: not a message catalog file.  */
#ifdef HAVE_MMAP
      if (use_mmap)
	munmap ((caddr_t) data, size);
      else
#endif
	free (data);
      return;
    }

  domain = (struct loaded_domain *) malloc (sizeof (struct loaded_domain));
  if (domain == NULL)
    {
#ifdef HAVE_MMAP
      if (use_mmap)
	munmap ((caddr_t) data, size);
      else
#endif
	free (data);
      return;
    }
  domain_file->data = domain;

  domain->data = (char *) data;
  domain->use_mmap = use_mmap;
  domain->mmap_size = size;
  domain->must_swap = data->magic != _MAGIC;
  domain->malloced = NULL;

  /* Fill in the information about the available tables.  */
  revision = W (domain->must_swap, data->revision);
  /* We support only the major revision 0.  */
  switch (revision >> 16)
    {
    case 0:
      domain->nstrings = W (domain->must_swap, data->nstrings);
      domain->orig_tab = (const struct string_desc *)
	((char *) data + W (domain->must_swap, data->orig_tab_offset));
      domain->trans_tab = (const struct string_desc *)
	((char *) data + W (domain->must_swap, data->trans_tab_offset));
      domain->hash_size = W (domain->must_swap, data->hash_tab_size);
      domain->hash_tab =
	(domain->hash_size > 2
	 ? (const nls_uint32 *)
	   ((char *) data + W (domain->must_swap, data->hash_tab_offset))
	 : NULL);
      domain->must_swap_hash_tab = domain->must_swap;

      /* Now dispatch on the minor revision.  */
      switch (revision & 0xffff)
	{
	case 0:
	  domain->n_sysdep_strings = 0;
	  domain->orig_sysdep_tab = NULL;
	  domain->trans_sysdep_tab = NULL;
	  break;
	case 1:
	default:
	  {
	    nls_uint32 n_sysdep_strings;

	    if (domain->hash_tab == NULL)
	      /* This is invalid.  These minor revisions need a hash table.  */
	      goto invalid;

	    n_sysdep_strings =
	      W (domain->must_swap, data->n_sysdep_strings);
	    if (n_sysdep_strings > 0)
	      {
		nls_uint32 n_sysdep_segments;
		const struct sysdep_segment *sysdep_segments;
		const char **sysdep_segment_values;
		const nls_uint32 *orig_sysdep_tab;
		const nls_uint32 *trans_sysdep_tab;
		size_t memneed;
		char *mem;
		struct sysdep_string_desc *inmem_orig_sysdep_tab;
		struct sysdep_string_desc *inmem_trans_sysdep_tab;
		nls_uint32 *inmem_hash_tab;
		unsigned int i;

		/* Get the values of the system dependent segments.  */
		n_sysdep_segments =
		  W (domain->must_swap, data->n_sysdep_segments);
		sysdep_segments = (const struct sysdep_segment *)
		  ((char *) data
		   + W (domain->must_swap, data->sysdep_segments_offset));
		sysdep_segment_values =
		  alloca (n_sysdep_segments * sizeof (const char *));
		for (i = 0; i < n_sysdep_segments; i++)
		  {
		    const char *name =
		      (char *) data
		      + W (domain->must_swap, sysdep_segments[i].offset);
		    nls_uint32 namelen =
		      W (domain->must_swap, sysdep_segments[i].length);

		    if (!(namelen > 0 && name[namelen - 1] == '\0'))
		      {
			freea (sysdep_segment_values);
			goto invalid;
		      }

		    sysdep_segment_values[i] = get_sysdep_segment_value (name);
		  }

		orig_sysdep_tab = (const nls_uint32 *)
		  ((char *) data
		   + W (domain->must_swap, data->orig_sysdep_tab_offset));
		trans_sysdep_tab = (const nls_uint32 *)
		  ((char *) data
		   + W (domain->must_swap, data->trans_sysdep_tab_offset));

		/* Compute the amount of additional memory needed for the
		   system dependent strings and the augmented hash table.  */
		memneed = 2 * n_sysdep_strings
			  * sizeof (struct sysdep_string_desc)
			  + domain->hash_size * sizeof (nls_uint32);
		for (i = 0; i < 2 * n_sysdep_strings; i++)
		  {
		    const struct sysdep_string *sysdep_string =
		      (const struct sysdep_string *)
		      ((char *) data
		       + W (domain->must_swap,
			    i < n_sysdep_strings
			    ? orig_sysdep_tab[i]
			    : trans_sysdep_tab[i - n_sysdep_strings]));
		    size_t need = 0;
		    const struct segment_pair *p = sysdep_string->segments;

		    if (W (domain->must_swap, p->sysdepref) != SEGMENTS_END)
		      for (p = sysdep_string->segments;; p++)
			{
			  nls_uint32 sysdepref;

			  need += W (domain->must_swap, p->segsize);

			  sysdepref = W (domain->must_swap, p->sysdepref);
			  if (sysdepref == SEGMENTS_END)
			    break;

			  if (sysdepref >= n_sysdep_segments)
			    {
			      /* Invalid.  */
			      freea (sysdep_segment_values);
			      goto invalid;
			    }

			  need += strlen (sysdep_segment_values[sysdepref]);
			}

		    memneed += need;
		  }

		/* Allocate additional memory.  */
		mem = (char *) malloc (memneed);
		if (mem == NULL)
		  goto invalid;

		domain->malloced = mem;
		inmem_orig_sysdep_tab = (struct sysdep_string_desc *) mem;
		mem += n_sysdep_strings * sizeof (struct sysdep_string_desc);
		inmem_trans_sysdep_tab = (struct sysdep_string_desc *) mem;
		mem += n_sysdep_strings * sizeof (struct sysdep_string_desc);
		inmem_hash_tab = (nls_uint32 *) mem;
		mem += domain->hash_size * sizeof (nls_uint32);

		/* Compute the system dependent strings.  */
		for (i = 0; i < 2 * n_sysdep_strings; i++)
		  {
		    const struct sysdep_string *sysdep_string =
		      (const struct sysdep_string *)
		      ((char *) data
		       + W (domain->must_swap,
			    i < n_sysdep_strings
			    ? orig_sysdep_tab[i]
			    : trans_sysdep_tab[i - n_sysdep_strings]));
		    const char *static_segments =
		      (char *) data
		      + W (domain->must_swap, sysdep_string->offset);
		    const struct segment_pair *p = sysdep_string->segments;

		    /* Concatenate the segments, and fill
		       inmem_orig_sysdep_tab[i] (for i < n_sysdep_strings) and
		       inmem_trans_sysdep_tab[i-n_sysdep_strings] (for
		       i >= n_sysdep_strings).  */

		    if (W (domain->must_swap, p->sysdepref) == SEGMENTS_END)
		      {
			/* Only one static segment.  */
			inmem_orig_sysdep_tab[i].length =
			  W (domain->must_swap, p->segsize);
			inmem_orig_sysdep_tab[i].pointer = static_segments;
		      }
		    else
		      {
			inmem_orig_sysdep_tab[i].pointer = mem;

			for (p = sysdep_string->segments;; p++)
			  {
			    nls_uint32 segsize =
			      W (domain->must_swap, p->segsize);
			    nls_uint32 sysdepref =
			      W (domain->must_swap, p->sysdepref);
			    size_t n;

			    if (segsize > 0)
			      {
				memcpy (mem, static_segments, segsize);
				mem += segsize;
				static_segments += segsize;
			      }

			    if (sysdepref == SEGMENTS_END)
			      break;

			    n = strlen (sysdep_segment_values[sysdepref]);
			    memcpy (mem, sysdep_segment_values[sysdepref], n);
			    mem += n;
			  }

			inmem_orig_sysdep_tab[i].length =
			  mem - inmem_orig_sysdep_tab[i].pointer;
		      }
		  }

		/* Compute the augmented hash table.  */
		for (i = 0; i < domain->hash_size; i++)
		  inmem_hash_tab[i] =
		    W (domain->must_swap_hash_tab, domain->hash_tab[i]);
		for (i = 0; i < n_sysdep_strings; i++)
		  {
		    const char *msgid = inmem_orig_sysdep_tab[i].pointer;
		    nls_uint32 hash_val = hash_string (msgid);
		    nls_uint32 idx = hash_val % domain->hash_size;
		    nls_uint32 incr = 1 + (hash_val % (domain->hash_size - 2));

		    for (;;)
		      {
			if (inmem_hash_tab[idx] == 0)
			  {
			    /* Hash table entry is empty.  Use it.  */
			    inmem_hash_tab[idx] = 1 + domain->nstrings + i;
			    break;
			  }

			if (idx >= domain->hash_size - incr)
			  idx -= domain->hash_size - incr;
			else
			  idx += incr;
		      }
		  }

		freea (sysdep_segment_values);

		domain->n_sysdep_strings = n_sysdep_strings;
		domain->orig_sysdep_tab = inmem_orig_sysdep_tab;
		domain->trans_sysdep_tab = inmem_trans_sysdep_tab;

		domain->hash_tab = inmem_hash_tab;
		domain->must_swap_hash_tab = 0;
	      }
	    else
	      {
		domain->n_sysdep_strings = 0;
		domain->orig_sysdep_tab = NULL;
		domain->trans_sysdep_tab = NULL;
	      }
	  }
	  break;
	}
      break;
    default:
      /* This is an invalid revision.  */
    invalid:
      /* This is an invalid .mo file.  */
      if (domain->malloced)
	free (domain->malloced);
#ifdef HAVE_MMAP
      if (use_mmap)
	munmap ((caddr_t) data, size);
      else
#endif
	free (data);
      free (domain);
      domain_file->data = NULL;
      return;
    }

  /* Now initialize the character set converter from the character set
     the file is encoded with (found in the header entry) to the domain's
     specified character set or the locale's character set.  */
  nullentry = _nl_init_domain_conv (domain_file, domain, domainbinding);

  /* Also look for a plural specification.  */
  EXTRACT_PLURAL_EXPRESSION (nullentry, &domain->plural, &domain->nplurals);
}
warning: parse error {
  int fd;
  size_t size;
#ifdef _LIBC
  struct stat64 st;
#else
  struct stat st;
#endif
  struct mo_file_header *data = (struct mo_file_header *) -1;
  int use_mmap = 0;
  struct loaded_domain *domain;
  int revision;
  const char *nullentry;

  domain_file->decided = 1;
  domain_file->data = NULL;

  /* Note that it would be useless to store domainbinding in domain_file
     because domainbinding might be == NULL now but != NULL later (after
     a call to bind_textdomain_codeset).  */

  /* If the record does not represent a valid locale the FILENAME
     might be NULL.  This can happen when according to the given
     specification the locale file name is different for XPG and CEN
     syntax.  */
  if (domain_file->filename == NULL)
    return;

  /* Try to open the addressed file.  */
  fd = open (domain_file->filename, O_RDONLY | O_BINARY);
  if (fd == -1)
    return;

  /* We must know about the size of the file.  */
  if (
#ifdef _LIBC
      __builtin_expect (fstat64 (fd, &st) != 0, 0)
#else
      __builtin_expect (fstat (fd, &st) != 0, 0)
#endif
      || __builtin_expect ((size = (size_t) st.st_size) != st.st_size, 0)
      || __builtin_expect (size < sizeof (struct mo_file_header), 0))
    {
      /* Something went wrong.  */
      close (fd);
      return;
    }

#ifdef HAVE_MMAP
  /* Now we are ready to load the file.  If mmap() is available we try
     this first.  If not available or it failed we try to load it.  */
  data = (struct mo_file_header *) mmap (NULL, size, PROT_READ,
					 MAP_PRIVATE, fd, 0);

  if (__builtin_expect (data != (struct mo_file_header *) -1, 1))
    {
      /* mmap() call was successful.  */
      close (fd);
      use_mmap = 1;
    }
#endif

  /* If the data is not yet available (i.e. mmap'ed) we try to load
     it manually.  */
  if (data == (struct mo_file_header *) -1)
    {
      size_t to_read;
      char *read_ptr;

      data = (struct mo_file_header *) malloc (size);
      if (data == NULL)
	{
	  if (use_mmap == 0)
	    close (fd);
	  return;
	}

      to_read = size;
      read_ptr = (char *) data;
      do
	{
	  long int nb = (long int) read (fd, read_ptr, to_read);
	  if (nb <= 0)
	    {
#ifdef EINTR
	      if (nb == -1 && errno == EINTR)
		continue;
#endif
	      close (fd);
	      return;
	    }
	  read_ptr += nb;
	  to_read -= nb;
	}
      while (to_read > 0);

      close (fd);
    }

  /* Using the magic number we can test whether it really is a message
     catalog file.  */
  if (__builtin_expect (data->magic != _MAGIC && data->magic != _MAGIC_SWAPPED,
			0))
    {
      /* The magic number is wrong: not a message catalog file.  */
#ifdef HAVE_MMAP
      if (use_mmap)
	munmap ((caddr_t) data, size);
      else
#endif
	free (data);
      return;
    }

  domain = (struct loaded_domain *) malloc (sizeof (struct loaded_domain));
  if (domain == NULL)
    {
#ifdef HAVE_MMAP
      if (use_mmap)
	munmap ((caddr_t) data, size);
      else
#endif
	free (data);
      return;
    }
  domain_file->data = domain;

  domain->data = (char *) data;
  domain->use_mmap = use_mmap;
  domain->mmap_size = size;
  domain->must_swap = data->magic != _MAGIC;
  domain->malloced = NULL;

  /* Fill in the information about the available tables.  */
  revision = W (domain->must_swap, data->revision);
  /* We support only the major revision 0.  */
  switch (revision >> 16)
    {
    case 0:
      domain->nstrings = W (domain->must_swap, data->nstrings);
      domain->orig_tab = (const struct string_desc *)
	((char *) data + W (domain->must_swap, data->orig_tab_offset));
      domain->trans_tab = (const struct string_desc *)
	((char *) data + W (domain->must_swap, data->trans_tab_offset));
      domain->hash_size = W (domain->must_swap, data->hash_tab_size);
      domain->hash_tab =
	(domain->hash_size > 2
	 ? (const nls_uint32 *)
	   ((char *) data + W (domain->must_swap, data->hash_tab_offset))
	 : NULL);
      domain->must_swap_hash_tab = domain->must_swap;

      /* Now dispatch on the minor revision.  */
      switch (revision & 0xffff)
	{
	case 0:
	  domain->n_sysdep_strings = 0;
	  domain->orig_sysdep_tab = NULL;
	  domain->trans_sysdep_tab = NULL;
	  break;
	case 1:
	default:
	  {
	    nls_uint32 n_sysdep_strings;

	    if (domain->hash_tab == NULL)
	      /* This is invalid.  These minor revisions need a hash table.  */
	      goto invalid;

	    n_sysdep_strings =
	      W (domain->must_swap, data->n_sysdep_strings);
	    if (n_sysdep_strings > 0)
	      {
		nls_uint32 n_sysdep_segments;
		const struct sysdep_segment *sysdep_segments;
		const char **sysdep_segment_values;
		const nls_uint32 *orig_sysdep_tab;
		const nls_uint32 *trans_sysdep_tab;
		size_t memneed;
		char *mem;
		struct sysdep_string_desc *inmem_orig_sysdep_tab;
		struct sysdep_string_desc *inmem_trans_sysdep_tab;
		nls_uint32 *inmem_hash_tab;
		unsigned int i;

		/* Get the values of the system dependent segments.  */
		n_sysdep_segments =
		  W (domain->must_swap, data->n_sysdep_segments);
		sysdep_segments = (const struct sysdep_segment *)
		  ((char *) data
		   + W (domain->must_swap, data->sysdep_segments_offset));
		sysdep_segment_values =
		  alloca (n_sysdep_segments * sizeof (const char *));
		for (i = 0; i < n_sysdep_segments; i++)
		  {
		    const char *name =
		      (char *) data
		      + W (domain->must_swap, sysdep_segments[i].offset);
		    nls_uint32 namelen =
		      W (domain->must_swap, sysdep_segments[i].length);

		    if (!(namelen > 0 && name[namelen - 1] == '\0'))
		      {
			freea (sysdep_segment_values);
			goto invalid;
		      }

		    sysdep_segment_values[i] = get_sysdep_segment_value (name);
		  }

		orig_sysdep_tab = (const nls_uint32 *)
		  ((char *) data
		   + W (domain->must_swap, data->orig_sysdep_tab_offset));
		trans_sysdep_tab = (const nls_uint32 *)
		  ((char *) data
		   + W (domain->must_swap, data->trans_sysdep_tab_offset));

		/* Compute the amount of additional memory needed for the
		   system dependent strings and the augmented hash table.  */
		memneed = 2 * n_sysdep_strings
			  * sizeof (struct sysdep_string_desc)
			  + domain->hash_size * sizeof (nls_uint32);
		for (i = 0; i < 2 * n_sysdep_strings; i++)
		  {
		    const struct sysdep_string *sysdep_string =
		      (const struct sysdep_string *)
		      ((char *) data
		       + W (domain->must_swap,
			    i < n_sysdep_strings
			    ? orig_sysdep_tab[i]
			    : trans_sysdep_tab[i - n_sysdep_strings]));
		    size_t need = 0;
		    const struct segment_pair *p = sysdep_string->segments;

		    if (W (domain->must_swap, p->sysdepref) != SEGMENTS_END)
		      for (p = sysdep_string->segments;; p++)
			{
			  nls_uint32 sysdepref;

			  need += W (domain->must_swap, p->segsize);

			  sysdepref = W (domain->must_swap, p->sysdepref);
			  if (sysdepref == SEGMENTS_END)
			    break;

			  if (sysdepref >= n_sysdep_segments)
			    {
			      /* Invalid.  */
			      freea (sysdep_segment_values);
			      goto invalid;
			    }

			  need += strlen (sysdep_segment_values[sysdepref]);
			}

		    memneed += need;
		  }

		/* Allocate additional memory.  */
		mem = (char *) malloc (memneed);
		if (mem == NULL)
		  goto invalid;

		domain->malloced = mem;
		inmem_orig_sysdep_tab = (struct sysdep_string_desc *) mem;
		mem += n_sysdep_strings * sizeof (struct sysdep_string_desc);
		inmem_trans_sysdep_tab = (struct sysdep_string_desc *) mem;
		mem += n_sysdep_strings * sizeof (struct sysdep_string_desc);
		inmem_hash_tab = (nls_uint32 *) mem;
		mem += domain->hash_size * sizeof (nls_uint32);

		/* Compute the system dependent strings.  */
		for (i = 0; i < 2 * n_sysdep_strings; i++)
		  {
		    const struct sysdep_string *sysdep_string =
		      (const struct sysdep_string *)
		      ((char *) data
		       + W (domain->must_swap,
			    i < n_sysdep_strings
			    ? orig_sysdep_tab[i]
			    : trans_sysdep_tab[i - n_sysdep_strings]));
		    const char *static_segments =
		      (char *) data
		      + W (domain->must_swap, sysdep_string->offset);
		    const struct segment_pair *p = sysdep_string->segments;

		    /* Concatenate the segments, and fill
		       inmem_orig_sysdep_tab[i] (for i < n_sysdep_strings) and
		       inmem_trans_sysdep_tab[i-n_sysdep_strings] (for
		       i >= n_sysdep_strings).  */

		    if (W (domain->must_swap, p->sysdepref) == SEGMENTS_END)
		      {
			/* Only one static segment.  */
			inmem_orig_sysdep_tab[i].length =
			  W (domain->must_swap, p->segsize);
			inmem_orig_sysdep_tab[i].pointer = static_segments;
		      }
		    else
		      {
			inmem_orig_sysdep_tab[i].pointer = mem;

			for (p = sysdep_string->segments;; p++)
			  {
			    nls_uint32 segsize =
			      W (domain->must_swap, p->segsize);
			    nls_uint32 sysdepref =
			      W (domain->must_swap, p->sysdepref);
			    size_t n;

			    if (segsize > 0)
			      {
				memcpy (mem, static_segments, segsize);
				mem += segsize;
				static_segments += segsize;
			      }

			    if (sysdepref == SEGMENTS_END)
			      break;

			    n = strlen (sysdep_segment_values[sysdepref]);
			    memcpy (mem, sysdep_segment_values[sysdepref], n);
			    mem += n;
			  }

			inmem_orig_sysdep_tab[i].length =
			  mem - inmem_orig_sysdep_tab[i].pointer;
		      }
		  }

		/* Compute the augmented hash table.  */
		for (i = 0; i < domain->hash_size; i++)
		  inmem_hash_tab[i] =
		    W (domain->must_swap_hash_tab, domain->hash_tab[i]);
		for (i = 0; i < n_sysdep_strings; i++)
		  {
		    const char *msgid = inmem_orig_sysdep_tab[i].pointer;
		    nls_uint32 hash_val = hash_string (msgid);
		    nls_uint32 idx = hash_val % domain->hash_size;
		    nls_uint32 incr = 1 + (hash_val % (domain->hash_size - 2));

		    for (;;)
		      {
			if (inmem_hash_tab[idx] == 0)
			  {
			    /* Hash table entry is empty.  Use it.  */
			    inmem_hash_tab[idx] = 1 + domain->nstrings + i;
			    break;
			  }

			if (idx >= domain->hash_size - incr)
			  idx -= domain->hash_size - incr;
			else
			  idx += incr;
		      }
		  }

		freea (sysdep_segment_values);

		domain->n_sysdep_strings = n_sysdep_strings;
		domain->orig_sysdep_tab = inmem_orig_sysdep_tab;
		domain->trans_sysdep_tab = inmem_trans_sysdep_tab;

		domain->hash_tab = inmem_hash_tab;
		domain->must_swap_hash_tab = 0;
	      }
	    else
	      {
		domain->n_sysdep_strings = 0;
		domain->orig_sysdep_tab = NULL;
		domain->trans_sysdep_tab = NULL;
	      }
	  }
	  break;
	}
      break;
    default:
      /* This is an invalid revision.  */
    invalid:
      /* This is an invalid .mo file.  */
      if (domain->malloced)
	free (domain->malloced);
#ifdef HAVE_MMAP
      if (use_mmap)
	munmap ((caddr_t) data, size);
      else
#endif
	free (data);
      free (domain);
      domain_file->data = NULL;
      return;
    }

  /* Now initialize the character set converter from the character set
     the file is encoded with (found in the header entry) to the domain's
     specified character set or the locale's character set.  */
  nullentry = _nl_init_domain_conv (domain_file, domain, domainbinding);

  /* Also look for a plural specification.  */
  EXTRACT_PLURAL_EXPRESSION (nullentry, &domain->plural, &domain->nplurals);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\intl\loadmsgcat.c:910
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\intl\localcharset.c...
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\intl\localcharset.h...
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\intl\localealias.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\intl\gettextP.h...skip
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\intl\localealias.c:154
parsing error 
{
  static const char *locale_alias_path;
  struct alias_map *retval;
  const char *result = NULL;
  size_t added;

#ifdef _LIBC
  __libc_lock_lock (lock);
#endif

  if (locale_alias_path == NULL)
    locale_alias_path = LOCALE_ALIAS_PATH;

  do
    {
      struct alias_map item;

      item.alias = name;

      if (nmap > 0)
	retval = (struct alias_map *) bsearch (&item, map, nmap,
					       sizeof (struct alias_map),
					       (int (*) PARAMS ((const void *,
								 const void *))
						) alias_compare);
      else
	retval = NULL;

      /* We really found an alias.  Return the value.  */
      if (retval != NULL)
	{
	  result = retval->value;
	  break;
	}

      /* Perhaps we can find another alias file.  */
      added = 0;
      while (added == 0 && locale_alias_path[0] != '\0')
	{
	  const char *start;

	  while (locale_alias_path[0] == PATH_SEPARATOR)
	    ++locale_alias_path;
	  start = locale_alias_path;

	  while (locale_alias_path[0] != '\0'
		 && locale_alias_path[0] != PATH_SEPARATOR)
	    ++locale_alias_path;

	  if (start < locale_alias_path)
	    added = read_alias_file (start, locale_alias_path - start);
	}
    }
  while (added != 0);

#ifdef _LIBC
  __libc_lock_unlock (lock);
#endif

  return result;
}
warning: parse error {
  static const char *locale_alias_path;
  struct alias_map *retval;
  const char *result = NULL;
  size_t added;

#ifdef _LIBC
  __libc_lock_lock (lock);
#endif

  if (locale_alias_path == NULL)
    locale_alias_path = LOCALE_ALIAS_PATH;

  do
    {
      struct alias_map item;

      item.alias = name;

      if (nmap > 0)
	retval = (struct alias_map *) bsearch (&item, map, nmap,
					       sizeof (struct alias_map),
					       (int (*) PARAMS ((const void *,
								 const void *))
						) alias_compare);
      else
	retval = NULL;

      /* We really found an alias.  Return the value.  */
      if (retval != NULL)
	{
	  result = retval->value;
	  break;
	}

      /* Perhaps we can find another alias file.  */
      added = 0;
      while (added == 0 && locale_alias_path[0] != '\0')
	{
	  const char *start;

	  while (locale_alias_path[0] == PATH_SEPARATOR)
	    ++locale_alias_path;
	  start = locale_alias_path;

	  while (locale_alias_path[0] != '\0'
		 && locale_alias_path[0] != PATH_SEPARATOR)
	    ++locale_alias_path;

	  if (start < locale_alias_path)
	    added = read_alias_file (start, locale_alias_path - start);
	}
    }
  while (added != 0);

#ifdef _LIBC
  __libc_lock_unlock (lock);
#endif

  return result;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\intl\localealias.c:155
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\intl\localealias.c:221
parsing error 
{
  FILE *fp;
  char *full_fname;
  size_t added;
  static const char aliasfile[] = "/locale.alias";

  full_fname = (char *) alloca (fname_len + sizeof aliasfile);
#ifdef HAVE_MEMPCPY
  mempcpy (mempcpy (full_fname, fname, fname_len),
	   aliasfile, sizeof aliasfile);
#else
  memcpy (full_fname, fname, fname_len);
  memcpy (&full_fname[fname_len], aliasfile, sizeof aliasfile);
#endif

  fp = fopen (relocate (full_fname), "r");
  freea (full_fname);
  if (fp == NULL)
    return 0;

#ifdef HAVE___FSETLOCKING
  /* No threads present.  */
  __fsetlocking (fp, FSETLOCKING_BYCALLER);
#endif

  added = 0;
  while (!FEOF (fp))
    {
      /* It is a reasonable approach to use a fix buffer here because
	 a) we are only interested in the first two fields
	 b) these fields must be usable as file names and so must not
	    be that long
	 We avoid a multi-kilobyte buffer here since this would use up
	 stack space which we might not have if the program ran out of
	 memory.  */
      char buf[400];
      char *alias;
      char *value;
      char *cp;

      if (FGETS (buf, sizeof buf, fp) == NULL)
	/* EOF reached.  */
	break;

      cp = buf;
      /* Ignore leading white space.  */
      while (isspace ((unsigned char) cp[0]))
	++cp;

      /* A leading '#' signals a comment line.  */
      if (cp[0] != '\0' && cp[0] != '#')
	{
	  alias = cp++;
	  while (cp[0] != '\0' && !isspace ((unsigned char) cp[0]))
	    ++cp;
	  /* Terminate alias name.  */
	  if (cp[0] != '\0')
	    *cp++ = '\0';

	  /* Now look for the beginning of the value.  */
	  while (isspace ((unsigned char) cp[0]))
	    ++cp;

	  if (cp[0] != '\0')
	    {
	      size_t alias_len;
	      size_t value_len;

	      value = cp++;
	      while (cp[0] != '\0' && !isspace ((unsigned char) cp[0]))
		++cp;
	      /* Terminate value.  */
	      if (cp[0] == '\n')
		{
		  /* This has to be done to make the following test
		     for the end of line possible.  We are looking for
		     the terminating '\n' which do not overwrite here.  */
		  *cp++ = '\0';
		  *cp = '\n';
		}
	      else if (cp[0] != '\0')
		*cp++ = '\0';

	      if (nmap >= maxmap)
		if (__builtin_expect (extend_alias_table (), 0))
		  {
		    fclose (fp);
		    return added;
		  }

	      alias_len = strlen (alias) + 1;
	      value_len = strlen (value) + 1;

	      if (string_space_act + alias_len + value_len > string_space_max)
		{
		  /* Increase size of memory pool.  */
		  size_t new_size = (string_space_max
				     + (alias_len + value_len > 1024
					? alias_len + value_len : 1024));
		  char *new_pool = (char *) realloc (string_space, new_size);
		  if (new_pool == NULL)
		    {
		      fclose (fp);
		      return added;
		    }

		  if (__builtin_expect (string_space != new_pool, 0))
		    {
		      size_t i;

		      for (i = 0; i < nmap; i++)
			{
			  map[i].alias += new_pool - string_space;
			  map[i].value += new_pool - string_space;
			}
		    }

		  string_space = new_pool;
		  string_space_max = new_size;
		}

	      map[nmap].alias = memcpy (&string_space[string_space_act],
					alias, alias_len);
	      string_space_act += alias_len;

	      map[nmap].value = memcpy (&string_space[string_space_act],
					value, value_len);
	      string_space_act += value_len;

	      ++nmap;
	      ++added;
	    }
	}

      /* Possibly not the whole line fits into the buffer.  Ignore
	 the rest of the line.  */
      while (strchr (buf, '\n') == NULL)
	if (FGETS (buf, sizeof buf, fp) == NULL)
	  /* Make sure the inner loop will be left.  The outer loop
	     will exit at the `feof' test.  */
	  break;
    }

  /* Should we test for ferror()?  I think we have to silently ignore
     errors.  --drepper  */
  fclose (fp);

  if (added > 0)
    qsort (map, nmap, sizeof (struct alias_map),
	   (int (*) PARAMS ((const void *, const void *))) alias_compare);

  return added;
}
warning: parse error {
  FILE *fp;
  char *full_fname;
  size_t added;
  static const char aliasfile[] = "/locale.alias";

  full_fname = (char *) alloca (fname_len + sizeof aliasfile);
#ifdef HAVE_MEMPCPY
  mempcpy (mempcpy (full_fname, fname, fname_len),
	   aliasfile, sizeof aliasfile);
#else
  memcpy (full_fname, fname, fname_len);
  memcpy (&full_fname[fname_len], aliasfile, sizeof aliasfile);
#endif

  fp = fopen (relocate (full_fname), "r");
  freea (full_fname);
  if (fp == NULL)
    return 0;

#ifdef HAVE___FSETLOCKING
  /* No threads present.  */
  __fsetlocking (fp, FSETLOCKING_BYCALLER);
#endif

  added = 0;
  while (!FEOF (fp))
    {
      /* It is a reasonable approach to use a fix buffer here because
	 a) we are only interested in the first two fields
	 b) these fields must be usable as file names and so must not
	    be that long
	 We avoid a multi-kilobyte buffer here since this would use up
	 stack space which we might not have if the program ran out of
	 memory.  */
      char buf[400];
      char *alias;
      char *value;
      char *cp;

      if (FGETS (buf, sizeof buf, fp) == NULL)
	/* EOF reached.  */
	break;

      cp = buf;
      /* Ignore leading white space.  */
      while (isspace ((unsigned char) cp[0]))
	++cp;

      /* A leading '#' signals a comment line.  */
      if (cp[0] != '\0' && cp[0] != '#')
	{
	  alias = cp++;
	  while (cp[0] != '\0' && !isspace ((unsigned char) cp[0]))
	    ++cp;
	  /* Terminate alias name.  */
	  if (cp[0] != '\0')
	    *cp++ = '\0';

	  /* Now look for the beginning of the value.  */
	  while (isspace ((unsigned char) cp[0]))
	    ++cp;

	  if (cp[0] != '\0')
	    {
	      size_t alias_len;
	      size_t value_len;

	      value = cp++;
	      while (cp[0] != '\0' && !isspace ((unsigned char) cp[0]))
		++cp;
	      /* Terminate value.  */
	      if (cp[0] == '\n')
		{
		  /* This has to be done to make the following test
		     for the end of line possible.  We are looking for
		     the terminating '\n' which do not overwrite here.  */
		  *cp++ = '\0';
		  *cp = '\n';
		}
	      else if (cp[0] != '\0')
		*cp++ = '\0';

	      if (nmap >= maxmap)
		if (__builtin_expect (extend_alias_table (), 0))
		  {
		    fclose (fp);
		    return added;
		  }

	      alias_len = strlen (alias) + 1;
	      value_len = strlen (value) + 1;

	      if (string_space_act + alias_len + value_len > string_space_max)
		{
		  /* Increase size of memory pool.  */
		  size_t new_size = (string_space_max
				     + (alias_len + value_len > 1024
					? alias_len + value_len : 1024));
		  char *new_pool = (char *) realloc (string_space, new_size);
		  if (new_pool == NULL)
		    {
		      fclose (fp);
		      return added;
		    }

		  if (__builtin_expect (string_space != new_pool, 0))
		    {
		      size_t i;

		      for (i = 0; i < nmap; i++)
			{
			  map[i].alias += new_pool - string_space;
			  map[i].value += new_pool - string_space;
			}
		    }

		  string_space = new_pool;
		  string_space_max = new_size;
		}

	      map[nmap].alias = memcpy (&string_space[string_space_act],
					alias, alias_len);
	      string_space_act += alias_len;

	      map[nmap].value = memcpy (&string_space[string_space_act],
					value, value_len);
	      string_space_act += value_len;

	      ++nmap;
	      ++added;
	    }
	}

      /* Possibly not the whole line fits into the buffer.  Ignore
	 the rest of the line.  */
      while (strchr (buf, '\n') == NULL)
	if (FGETS (buf, sizeof buf, fp) == NULL)
	  /* Make sure the inner loop will be left.  The outer loop
	     will exit at the `feof' test.  */
	  break;
    }

  /* Should we test for ferror()?  I think we have to silently ignore
     errors.  --drepper  */
  fclose (fp);

  if (added > 0)
    qsort (map, nmap, sizeof (struct alias_map),
	   (int (*) PARAMS ((const void *, const void *))) alias_compare);

  return added;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\intl\localealias.c:223
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\intl\localealias.c:399
parsing error 
{
#if defined _LIBC || defined HAVE_STRCASECMP
  return strcasecmp (map1->alias, map2->alias);
#else
  const unsigned char *p1 = (const unsigned char *) map1->alias;
  const unsigned char *p2 = (const unsigned char *) map2->alias;
  unsigned char c1, c2;

  if (p1 == p2)
    return 0;

  do
    {
      /* I know this seems to be odd but the tolower() function in
	 some systems libc cannot handle nonalpha characters.  */
      c1 = isupper (*p1) ? tolower (*p1) : *p1;
      c2 = isupper (*p2) ? tolower (*p2) : *p2;
      if (c1 == '\0')
	break;
      ++p1;
      ++p2;
    }
  while (c1 == c2);

  return c1 - c2;
#endif
}
warning: parse error {
#if defined _LIBC || defined HAVE_STRCASECMP
  return strcasecmp (map1->alias, map2->alias);
#else
  const unsigned char *p1 = (const unsigned char *) map1->alias;
  const unsigned char *p2 = (const unsigned char *) map2->alias;
  unsigned char c1, c2;

  if (p1 == p2)
    return 0;

  do
    {
      /* I know this seems to be odd but the tolower() function in
	 some systems libc cannot handle nonalpha characters.  */
      c1 = isupper (*p1) ? tolower (*p1) : *p1;
      c2 = isupper (*p2) ? tolower (*p2) : *p2;
      if (c1 == '\0')
	break;
      ++p1;
      ++p2;
    }
  while (c1 == c2);

  return c1 - c2;
#endif
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\intl\localealias.c:401
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\intl\localename.c...
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\intl\localename.c:386
parsing error 
{
  const char *retval;

#ifndef WIN32

  /* Use the POSIX methods of looking to 'LC_ALL', 'LC_xxx', and 'LANG'.
     On some systems this can be done by the 'setlocale' function itself.  */
# if defined HAVE_SETLOCALE && defined HAVE_LC_MESSAGES && defined HAVE_LOCALE_NULL
  retval = setlocale (category, NULL);
# else
  /* Setting of LC_ALL overwrites all other.  */
  retval = getenv ("LC_ALL");
  if (retval == NULL || retval[0] == '\0')
    {
      /* Next comes the name of the desired category.  */
      retval = getenv (categoryname);
      if (retval == NULL || retval[0] == '\0')
	{
	  /* Last possibility is the LANG environment variable.  */
	  retval = getenv ("LANG");
	  if (retval == NULL || retval[0] == '\0')
	    /* We use C as the default domain.  POSIX says this is
	       implementation defined.  */
	    retval = "C";
	}
    }
# endif

  return retval;

#else /* WIN32 */

  /* Return an XPG style locale name language[_territory][@modifier].
     Don't even bother determining the codeset; it's not useful in this
     context, because message catalogs are not specific to a single
     codeset.  */

  LCID lcid;
  LANGID langid;
  int primary, sub;

  /* Let the user override the system settings through environment
     variables, as on POSIX systems.  */
  retval = getenv ("LC_ALL");
  if (retval != NULL && retval[0] != '\0')
    return retval;
  retval = getenv (categoryname);
  if (retval != NULL && retval[0] != '\0')
    return retval;
  retval = getenv ("LANG");
  if (retval != NULL && retval[0] != '\0')
    return retval;

  /* Use native Win32 API locale ID.  */
  lcid = GetThreadLocale ();

  /* Strip off the sorting rules, keep only the language part.  */
  langid = LANGIDFROMLCID (lcid);

  /* Split into language and territory part.  */
  primary = PRIMARYLANGID (langid);
  sub = SUBLANGID (langid);

  /* Dispatch on language.
     See also http://www.unicode.org/unicode/onlinedat/languages.html .
     For details about languages, see http://www.ethnologue.com/ .  */
  switch (primary)
    {
    case LANG_AFRIKAANS: return "af_ZA";
    case LANG_ALBANIAN: return "sq_AL";
    case 0x5e: /* AMHARIC */ return "am_ET";
    case LANG_ARABIC:
      switch (sub)
	{
	case SUBLANG_ARABIC_SAUDI_ARABIA: return "ar_SA";
	case SUBLANG_ARABIC_IRAQ: return "ar_IQ";
	case SUBLANG_ARABIC_EGYPT: return "ar_EG";
	case SUBLANG_ARABIC_LIBYA: return "ar_LY";
	case SUBLANG_ARABIC_ALGERIA: return "ar_DZ";
	case SUBLANG_ARABIC_MOROCCO: return "ar_MA";
	case SUBLANG_ARABIC_TUNISIA: return "ar_TN";
	case SUBLANG_ARABIC_OMAN: return "ar_OM";
	case SUBLANG_ARABIC_YEMEN: return "ar_YE";
	case SUBLANG_ARABIC_SYRIA: return "ar_SY";
	case SUBLANG_ARABIC_JORDAN: return "ar_JO";
	case SUBLANG_ARABIC_LEBANON: return "ar_LB";
	case SUBLANG_ARABIC_KUWAIT: return "ar_KW";
	case SUBLANG_ARABIC_UAE: return "ar_AE";
	case SUBLANG_ARABIC_BAHRAIN: return "ar_BH";
	case SUBLANG_ARABIC_QATAR: return "ar_QA";
	}
      return "ar";
    case LANG_ARMENIAN: return "hy_AM";
    case LANG_ASSAMESE: return "as_IN";
    case LANG_AZERI:
      switch (sub)
	{
	/* FIXME: Adjust this when Azerbaijani locales appear on Unix.  */
	case SUBLANG_AZERI_LATIN: return "az_AZ@latin";
	case SUBLANG_AZERI_CYRILLIC: return "az_AZ@cyrillic";
	}
      return "az";
    case LANG_BASQUE:
      return "eu"; /* Ambiguous: could be "eu_ES" or "eu_FR".  */
    case LANG_BELARUSIAN: return "be_BY";
    case LANG_BENGALI: return "bn_IN";
    case LANG_BULGARIAN: return "bg_BG";
    case 0x55: /* BURMESE */ return "my_MM";
    case 0x53: /* CAMBODIAN */ return "km_KH";
    case LANG_CATALAN: return "ca_ES";
    case 0x5c: /* CHEROKEE */ return "chr_US";
    case LANG_CHINESE:
      switch (sub)
	{
	case SUBLANG_CHINESE_TRADITIONAL: return "zh_TW";
	case SUBLANG_CHINESE_SIMPLIFIED: return "zh_CN";
	case SUBLANG_CHINESE_HONGKONG: return "zh_HK";
	case SUBLANG_CHINESE_SINGAPORE: return "zh_SG";
	case SUBLANG_CHINESE_MACAU: return "zh_MO";
	}
      return "zh";
    case LANG_CROATIAN:		/* LANG_CROATIAN == LANG_SERBIAN
				 * What used to be called Serbo-Croatian
				 * should really now be two separate
				 * languages because of political reasons.
				 * (Says tml, who knows nothing about Serbian
				 * or Croatian.)
				 * (I can feel those flames coming already.)
				 */
      switch (sub)
	{
	case SUBLANG_DEFAULT: return "hr_HR";
	case SUBLANG_SERBIAN_LATIN: return "sr_YU";
	case SUBLANG_SERBIAN_CYRILLIC: return "sr_YU@cyrillic";
	}
      return "hr";
    case LANG_CZECH: return "cs_CZ";
    case LANG_DANISH: return "da_DK";
    case LANG_DIVEHI: return "div_MV";
    case LANG_DUTCH:
      switch (sub)
	{
	case SUBLANG_DUTCH: return "nl_NL";
	case SUBLANG_DUTCH_BELGIAN: /* FLEMISH, VLAAMS */ return "nl_BE";
	}
      return "nl";
    case 0x66: /* EDO */ return "bin_NG";
    case LANG_ENGLISH:
      switch (sub)
	{
	/* SUBLANG_ENGLISH_US == SUBLANG_DEFAULT. Heh. I thought
	 * English was the language spoken in England.
	 * Oh well.
	 */
	case SUBLANG_ENGLISH_US: return "en_US";
	case SUBLANG_ENGLISH_UK: return "en_GB";
	case SUBLANG_ENGLISH_AUS: return "en_AU";
	case SUBLANG_ENGLISH_CAN: return "en_CA";
	case SUBLANG_ENGLISH_NZ: return "en_NZ";
	case SUBLANG_ENGLISH_EIRE: return "en_IE";
	case SUBLANG_ENGLISH_SOUTH_AFRICA: return "en_ZA";
	case SUBLANG_ENGLISH_JAMAICA: return "en_JM";
	case SUBLANG_ENGLISH_CARIBBEAN: return "en_GD"; /* Grenada? */
	case SUBLANG_ENGLISH_BELIZE: return "en_BZ";
	case SUBLANG_ENGLISH_TRINIDAD: return "en_TT";
	case SUBLANG_ENGLISH_ZIMBABWE: return "en_ZW";
	case SUBLANG_ENGLISH_PHILIPPINES: return "en_PH";
	}
      return "en";
    case LANG_ESTONIAN: return "et_EE";
    case LANG_FAEROESE: return "fo_FO";
    case LANG_FARSI: return "fa_IR";
    case LANG_FINNISH: return "fi_FI";
    case LANG_FRENCH:
      switch (sub)
	{
	case SUBLANG_FRENCH: return "fr_FR";
	case SUBLANG_FRENCH_BELGIAN: /* WALLOON */ return "fr_BE";
	case SUBLANG_FRENCH_CANADIAN: return "fr_CA";
	case SUBLANG_FRENCH_SWISS: return "fr_CH";
	case SUBLANG_FRENCH_LUXEMBOURG: return "fr_LU";
	case SUBLANG_FRENCH_MONACO: return "fr_MC";
	}
      return "fr";
    case 0x62: /* FRISIAN */ return "fy_NL";
    case 0x67: /* FULFULDE */ return "ful_NG";
    case 0x3c: /* GAELIC */
      switch (sub)
	{
	case 0x01: /* SCOTTISH */ return "gd_GB";
	case 0x02: /* IRISH */ return "ga_IE";
	}
      return "C";
    case LANG_GALICIAN: return "gl_ES";
    case LANG_GEORGIAN: return "ka_GE";
    case LANG_GERMAN:
      switch (sub)
	{
	case SUBLANG_GERMAN: return "de_DE";
	case SUBLANG_GERMAN_SWISS: return "de_CH";
	case SUBLANG_GERMAN_AUSTRIAN: return "de_AT";
	case SUBLANG_GERMAN_LUXEMBOURG: return "de_LU";
	case SUBLANG_GERMAN_LIECHTENSTEIN: return "de_LI";
	}
      return "de";
    case LANG_GREEK: return "el_GR";
    case 0x74: /* GUARANI */ return "gn_PY";
    case LANG_GUJARATI: return "gu_IN";
    case 0x68: /* HAUSA */ return "ha_NG";
    case 0x75: /* HAWAIIAN */
      /* FIXME: Do they mean Hawaiian ("haw_US", 1000 speakers)
	 or Hawaii Creole English ("cpe_US", 600000 speakers)?  */
      return "cpe_US";
    case LANG_HEBREW: return "he_IL";
    case LANG_HINDI: return "hi_IN";
    case LANG_HUNGARIAN: return "hu_HU";
    case 0x69: /* IBIBIO */ return "nic_NG";
    case LANG_ICELANDIC: return "is_IS";
    case 0x70: /* IGBO */ return "ibo_NG";
    case LANG_INDONESIAN: return "id_ID";
    case 0x5d: /* INUKTITUT */ return "iu_CA";
    case LANG_ITALIAN:
      switch (sub)
	{
	case SUBLANG_ITALIAN: return "it_IT";
	case SUBLANG_ITALIAN_SWISS: return "it_CH";
	}
      return "it";
    case LANG_JAPANESE: return "ja_JP";
    case LANG_KANNADA: return "kn_IN";
    case 0x71: /* KANURI */ return "kau_NG";
    case LANG_KASHMIRI:
      switch (sub)
	{
	case SUBLANG_DEFAULT: return "ks_PK";
	case SUBLANG_KASHMIRI_INDIA: return "ks_IN";
	}
      return "ks";
    case LANG_KAZAK: return "kk_KZ";
    case LANG_KONKANI:
      /* FIXME: Adjust this when such locales appear on Unix.  */
      return "kok_IN";
    case LANG_KOREAN: return "ko_KR";
    case LANG_KYRGYZ: return "ky_KG";
    case 0x54: /* LAO */ return "lo_LA";
    case 0x76: /* LATIN */ return "la_VA";
    case LANG_LATVIAN: return "lv_LV";
    case LANG_LITHUANIAN: return "lt_LT";
    case LANG_MACEDONIAN: return "mk_MK";
    case LANG_MALAY:
      switch (sub)
	{
	case SUBLANG_MALAY_MALAYSIA: return "ms_MY";
	case SUBLANG_MALAY_BRUNEI_DARUSSALAM: return "ms_BN";
	}
      return "ms";
    case LANG_MALAYALAM: return "ml_IN";
    case 0x3a: /* MALTESE */ return "mt_MT";
    case LANG_MANIPURI:
      /* FIXME: Adjust this when such locales appear on Unix.  */
      return "mni_IN";
    case LANG_MARATHI: return "mr_IN";
    case LANG_MONGOLIAN:
      return "mn"; /* Ambiguous: could be "mn_CN" or "mn_MN".  */
    case LANG_NEPALI:
      switch (sub)
	{
	case SUBLANG_DEFAULT: return "ne_NP";
	case SUBLANG_NEPALI_INDIA: return "ne_IN";
	}
      return "ne";
    case LANG_NORWEGIAN:
      switch (sub)
	{
	case SUBLANG_NORWEGIAN_BOKMAL: return "no_NO";
	case SUBLANG_NORWEGIAN_NYNORSK: return "nn_NO";
	}
      return "no";
    case LANG_ORIYA: return "or_IN";
    case 0x72: /* OROMO */ return "om_ET";
    case 0x79: /* PAPIAMENTU */ return "pap_AN";
    case 0x63: /* PASHTO */
      return "ps"; /* Ambiguous: could be "ps_PK" or "ps_AF".  */
    case LANG_POLISH: return "pl_PL";
    case LANG_PORTUGUESE:
      switch (sub)
	{
	case SUBLANG_PORTUGUESE: return "pt_PT";
	/* Hmm. SUBLANG_PORTUGUESE_BRAZILIAN == SUBLANG_DEFAULT.
	   Same phenomenon as SUBLANG_ENGLISH_US == SUBLANG_DEFAULT. */
	case SUBLANG_PORTUGUESE_BRAZILIAN: return "pt_BR";
	}
      return "pt";
    case LANG_PUNJABI: return "pa_IN";
    case 0x17: /* RHAETO-ROMANCE */ return "rm_CH";
    case LANG_ROMANIAN: return "ro_RO";
    case LANG_RUSSIAN:
      return "ru"; /* Ambiguous: could be "ru_RU" or "ru_UA".  */
    case 0x3b: /* SAMI */ return "se_NO";
    case LANG_SANSKRIT: return "sa_IN";
    case LANG_SINDHI: return "sd";
    case 0x5b: /* SINHALESE */ return "si_LK";
    case LANG_SLOVAK: return "sk_SK";
    case LANG_SLOVENIAN: return "sl_SI";
    case 0x77: /* SOMALI */ return "so_SO";
    case LANG_SORBIAN:
      /* FIXME: Adjust this when such locales appear on Unix.  */
      return "wen_DE";
    case LANG_SPANISH:
      switch (sub)
	{
	case SUBLANG_SPANISH: return "es_ES";
	case SUBLANG_SPANISH_MEXICAN: return "es_MX";
	case SUBLANG_SPANISH_MODERN:
	  return "es_ES@modern";	/* not seen on Unix */
	case SUBLANG_SPANISH_GUATEMALA: return "es_GT";
	case SUBLANG_SPANISH_COSTA_RICA: return "es_CR";
	case SUBLANG_SPANISH_PANAMA: return "es_PA";
	case SUBLANG_SPANISH_DOMINICAN_REPUBLIC: return "es_DO";
	case SUBLANG_SPANISH_VENEZUELA: return "es_VE";
	case SUBLANG_SPANISH_COLOMBIA: return "es_CO";
	case SUBLANG_SPANISH_PERU: return "es_PE";
	case SUBLANG_SPANISH_ARGENTINA: return "es_AR";
	case SUBLANG_SPANISH_ECUADOR: return "es_EC";
	case SUBLANG_SPANISH_CHILE: return "es_CL";
	case SUBLANG_SPANISH_URUGUAY: return "es_UY";
	case SUBLANG_SPANISH_PARAGUAY: return "es_PY";
	case SUBLANG_SPANISH_BOLIVIA: return "es_BO";
	case SUBLANG_SPANISH_EL_SALVADOR: return "es_SV";
	case SUBLANG_SPANISH_HONDURAS: return "es_HN";
	case SUBLANG_SPANISH_NICARAGUA: return "es_NI";
	case SUBLANG_SPANISH_PUERTO_RICO: return "es_PR";
	}
      return "es";
    case 0x30: /* SUTU */ return "bnt_TZ";
    case LANG_SWAHILI: return "sw_KE";
    case LANG_SWEDISH:
      switch (sub)
	{
	case SUBLANG_DEFAULT: return "sv_SE";
	case SUBLANG_SWEDISH_FINLAND: return "sv_FI";
	}
      return "sv";
    case LANG_SYRIAC: return "syr_TR"; /* An extinct language.  */
    case 0x64: /* TAGALOG */ return "tl_PH";
    case 0x28: /* TAJIK */ return "tg_TJ";
    case 0x5f: /* TAMAZIGHT */ return "ber_MA";
    case LANG_TAMIL:
      return "ta"; /* Ambiguous: could be "ta_IN" or "ta_LK" or "ta_SG".  */
    case LANG_TATAR: return "tt_RU";
    case LANG_TELUGU: return "te_IN";
    case LANG_THAI: return "th_TH";
    case 0x51: /* TIBETAN */ return "bo_CN";
    case 0x73: /* TIGRINYA */ return "ti_ET";
    case 0x31: /* TSONGA */ return "ts_ZA";
    case LANG_TURKISH: return "tr_TR";
    case 0x42: /* TURKMEN */ return "tk_TM";
    case LANG_UKRAINIAN: return "uk_UA";
    case LANG_URDU:
      switch (sub)
	{
	case SUBLANG_URDU_PAKISTAN: return "ur_PK";
	case SUBLANG_URDU_INDIA: return "ur_IN";
	}
      return "ur";
    case LANG_UZBEK:
      switch (sub)
	{
	/* FIXME: Adjust this when Uzbek locales appear on Unix.  */
	case SUBLANG_UZBEK_LATIN: return "uz_UZ@latin";
	case SUBLANG_UZBEK_CYRILLIC: return "uz_UZ@cyrillic";
	}
      return "uz";
    case 0x33: /* VENDA */ return "ven_ZA";
    case LANG_VIETNAMESE: return "vi_VN";
    case 0x52: /* WELSH */ return "cy_GB";
    case 0x34: /* XHOSA */ return "xh_ZA";
    case 0x78: /* YI */ return "sit_CN";
    case 0x3d: /* YIDDISH */ return "yi_IL";
    case 0x6a: /* YORUBA */ return "yo_NG";
    case 0x35: /* ZULU */ return "zu_ZA";
    default: return "C";
    }

#endif
}
warning: parse error {
  const char *retval;

#ifndef WIN32

  /* Use the POSIX methods of looking to 'LC_ALL', 'LC_xxx', and 'LANG'.
     On some systems this can be done by the 'setlocale' function itself.  */
# if defined HAVE_SETLOCALE && defined HAVE_LC_MESSAGES && defined HAVE_LOCALE_NULL
  retval = setlocale (category, NULL);
# else
  /* Setting of LC_ALL overwrites all other.  */
  retval = getenv ("LC_ALL");
  if (retval == NULL || retval[0] == '\0')
    {
      /* Next comes the name of the desired category.  */
      retval = getenv (categoryname);
      if (retval == NULL || retval[0] == '\0')
	{
	  /* Last possibility is the LANG environment variable.  */
	  retval = getenv ("LANG");
	  if (retval == NULL || retval[0] == '\0')
	    /* We use C as the default domain.  POSIX says this is
	       implementation defined.  */
	    retval = "C";
	}
    }
# endif

  return retval;

#else /* WIN32 */

  /* Return an XPG style locale name language[_territory][@modifier].
     Don't even bother determining the codeset; it's not useful in this
     context, because message catalogs are not specific to a single
     codeset.  */

  LCID lcid;
  LANGID langid;
  int primary, sub;

  /* Let the user override the system settings through environment
     variables, as on POSIX systems.  */
  retval = getenv ("LC_ALL");
  if (retval != NULL && retval[0] != '\0')
    return retval;
  retval = getenv (categoryname);
  if (retval != NULL && retval[0] != '\0')
    return retval;
  retval = getenv ("LANG");
  if (retval != NULL && retval[0] != '\0')
    return retval;

  /* Use native Win32 API locale ID.  */
  lcid = GetThreadLocale ();

  /* Strip off the sorting rules, keep only the language part.  */
  langid = LANGIDFROMLCID (lcid);

  /* Split into language and territory part.  */
  primary = PRIMARYLANGID (langid);
  sub = SUBLANGID (langid);

  /* Dispatch on language.
     See also http://www.unicode.org/unicode/onlinedat/languages.html .
     For details about languages, see http://www.ethnologue.com/ .  */
  switch (primary)
    {
    case LANG_AFRIKAANS: return "af_ZA";
    case LANG_ALBANIAN: return "sq_AL";
    case 0x5e: /* AMHARIC */ return "am_ET";
    case LANG_ARABIC:
      switch (sub)
	{
	case SUBLANG_ARABIC_SAUDI_ARABIA: return "ar_SA";
	case SUBLANG_ARABIC_IRAQ: return "ar_IQ";
	case SUBLANG_ARABIC_EGYPT: return "ar_EG";
	case SUBLANG_ARABIC_LIBYA: return "ar_LY";
	case SUBLANG_ARABIC_ALGERIA: return "ar_DZ";
	case SUBLANG_ARABIC_MOROCCO: return "ar_MA";
	case SUBLANG_ARABIC_TUNISIA: return "ar_TN";
	case SUBLANG_ARABIC_OMAN: return "ar_OM";
	case SUBLANG_ARABIC_YEMEN: return "ar_YE";
	case SUBLANG_ARABIC_SYRIA: return "ar_SY";
	case SUBLANG_ARABIC_JORDAN: return "ar_JO";
	case SUBLANG_ARABIC_LEBANON: return "ar_LB";
	case SUBLANG_ARABIC_KUWAIT: return "ar_KW";
	case SUBLANG_ARABIC_UAE: return "ar_AE";
	case SUBLANG_ARABIC_BAHRAIN: return "ar_BH";
	case SUBLANG_ARABIC_QATAR: return "ar_QA";
	}
      return "ar";
    case LANG_ARMENIAN: return "hy_AM";
    case LANG_ASSAMESE: return "as_IN";
    case LANG_AZERI:
      switch (sub)
	{
	/* FIXME: Adjust this when Azerbaijani locales appear on Unix.  */
	case SUBLANG_AZERI_LATIN: return "az_AZ@latin";
	case SUBLANG_AZERI_CYRILLIC: return "az_AZ@cyrillic";
	}
      return "az";
    case LANG_BASQUE:
      return "eu"; /* Ambiguous: could be "eu_ES" or "eu_FR".  */
    case LANG_BELARUSIAN: return "be_BY";
    case LANG_BENGALI: return "bn_IN";
    case LANG_BULGARIAN: return "bg_BG";
    case 0x55: /* BURMESE */ return "my_MM";
    case 0x53: /* CAMBODIAN */ return "km_KH";
    case LANG_CATALAN: return "ca_ES";
    case 0x5c: /* CHEROKEE */ return "chr_US";
    case LANG_CHINESE:
      switch (sub)
	{
	case SUBLANG_CHINESE_TRADITIONAL: return "zh_TW";
	case SUBLANG_CHINESE_SIMPLIFIED: return "zh_CN";
	case SUBLANG_CHINESE_HONGKONG: return "zh_HK";
	case SUBLANG_CHINESE_SINGAPORE: return "zh_SG";
	case SUBLANG_CHINESE_MACAU: return "zh_MO";
	}
      return "zh";
    case LANG_CROATIAN:		/* LANG_CROATIAN == LANG_SERBIAN
				 * What used to be called Serbo-Croatian
				 * should really now be two separate
				 * languages because of political reasons.
				 * (Says tml, who knows nothing about Serbian
				 * or Croatian.)
				 * (I can feel those flames coming already.)
				 */
      switch (sub)
	{
	case SUBLANG_DEFAULT: return "hr_HR";
	case SUBLANG_SERBIAN_LATIN: return "sr_YU";
	case SUBLANG_SERBIAN_CYRILLIC: return "sr_YU@cyrillic";
	}
      return "hr";
    case LANG_CZECH: return "cs_CZ";
    case LANG_DANISH: return "da_DK";
    case LANG_DIVEHI: return "div_MV";
    case LANG_DUTCH:
      switch (sub)
	{
	case SUBLANG_DUTCH: return "nl_NL";
	case SUBLANG_DUTCH_BELGIAN: /* FLEMISH, VLAAMS */ return "nl_BE";
	}
      return "nl";
    case 0x66: /* EDO */ return "bin_NG";
    case LANG_ENGLISH:
      switch (sub)
	{
	/* SUBLANG_ENGLISH_US == SUBLANG_DEFAULT. Heh. I thought
	 * English was the language spoken in England.
	 * Oh well.
	 */
	case SUBLANG_ENGLISH_US: return "en_US";
	case SUBLANG_ENGLISH_UK: return "en_GB";
	case SUBLANG_ENGLISH_AUS: return "en_AU";
	case SUBLANG_ENGLISH_CAN: return "en_CA";
	case SUBLANG_ENGLISH_NZ: return "en_NZ";
	case SUBLANG_ENGLISH_EIRE: return "en_IE";
	case SUBLANG_ENGLISH_SOUTH_AFRICA: return "en_ZA";
	case SUBLANG_ENGLISH_JAMAICA: return "en_JM";
	case SUBLANG_ENGLISH_CARIBBEAN: return "en_GD"; /* Grenada? */
	case SUBLANG_ENGLISH_BELIZE: return "en_BZ";
	case SUBLANG_ENGLISH_TRINIDAD: return "en_TT";
	case SUBLANG_ENGLISH_ZIMBABWE: return "en_ZW";
	case SUBLANG_ENGLISH_PHILIPPINES: return "en_PH";
	}
      return "en";
    case LANG_ESTONIAN: return "et_EE";
    case LANG_FAEROESE: return "fo_FO";
    case LANG_FARSI: return "fa_IR";
    case LANG_FINNISH: return "fi_FI";
    case LANG_FRENCH:
      switch (sub)
	{
	case SUBLANG_FRENCH: return "fr_FR";
	case SUBLANG_FRENCH_BELGIAN: /* WALLOON */ return "fr_BE";
	case SUBLANG_FRENCH_CANADIAN: return "fr_CA";
	case SUBLANG_FRENCH_SWISS: return "fr_CH";
	case SUBLANG_FRENCH_LUXEMBOURG: return "fr_LU";
	case SUBLANG_FRENCH_MONACO: return "fr_MC";
	}
      return "fr";
    case 0x62: /* FRISIAN */ return "fy_NL";
    case 0x67: /* FULFULDE */ return "ful_NG";
    case 0x3c: /* GAELIC */
      switch (sub)
	{
	case 0x01: /* SCOTTISH */ return "gd_GB";
	case 0x02: /* IRISH */ return "ga_IE";
	}
      return "C";
    case LANG_GALICIAN: return "gl_ES";
    case LANG_GEORGIAN: return "ka_GE";
    case LANG_GERMAN:
      switch (sub)
	{
	case SUBLANG_GERMAN: return "de_DE";
	case SUBLANG_GERMAN_SWISS: return "de_CH";
	case SUBLANG_GERMAN_AUSTRIAN: return "de_AT";
	case SUBLANG_GERMAN_LUXEMBOURG: return "de_LU";
	case SUBLANG_GERMAN_LIECHTENSTEIN: return "de_LI";
	}
      return "de";
    case LANG_GREEK: return "el_GR";
    case 0x74: /* GUARANI */ return "gn_PY";
    case LANG_GUJARATI: return "gu_IN";
    case 0x68: /* HAUSA */ return "ha_NG";
    case 0x75: /* HAWAIIAN */
      /* FIXME: Do they mean Hawaiian ("haw_US", 1000 speakers)
	 or Hawaii Creole English ("cpe_US", 600000 speakers)?  */
      return "cpe_US";
    case LANG_HEBREW: return "he_IL";
    case LANG_HINDI: return "hi_IN";
    case LANG_HUNGARIAN: return "hu_HU";
    case 0x69: /* IBIBIO */ return "nic_NG";
    case LANG_ICELANDIC: return "is_IS";
    case 0x70: /* IGBO */ return "ibo_NG";
    case LANG_INDONESIAN: return "id_ID";
    case 0x5d: /* INUKTITUT */ return "iu_CA";
    case LANG_ITALIAN:
      switch (sub)
	{
	case SUBLANG_ITALIAN: return "it_IT";
	case SUBLANG_ITALIAN_SWISS: return "it_CH";
	}
      return "it";
    case LANG_JAPANESE: return "ja_JP";
    case LANG_KANNADA: return "kn_IN";
    case 0x71: /* KANURI */ return "kau_NG";
    case LANG_KASHMIRI:
      switch (sub)
	{
	case SUBLANG_DEFAULT: return "ks_PK";
	case SUBLANG_KASHMIRI_INDIA: return "ks_IN";
	}
      return "ks";
    case LANG_KAZAK: return "kk_KZ";
    case LANG_KONKANI:
      /* FIXME: Adjust this when such locales appear on Unix.  */
      return "kok_IN";
    case LANG_KOREAN: return "ko_KR";
    case LANG_KYRGYZ: return "ky_KG";
    case 0x54: /* LAO */ return "lo_LA";
    case 0x76: /* LATIN */ return "la_VA";
    case LANG_LATVIAN: return "lv_LV";
    case LANG_LITHUANIAN: return "lt_LT";
    case LANG_MACEDONIAN: return "mk_MK";
    case LANG_MALAY:
      switch (sub)
	{
	case SUBLANG_MALAY_MALAYSIA: return "ms_MY";
	case SUBLANG_MALAY_BRUNEI_DARUSSALAM: return "ms_BN";
	}
      return "ms";
    case LANG_MALAYALAM: return "ml_IN";
    case 0x3a: /* MALTESE */ return "mt_MT";
    case LANG_MANIPURI:
      /* FIXME: Adjust this when such locales appear on Unix.  */
      return "mni_IN";
    case LANG_MARATHI: return "mr_IN";
    case LANG_MONGOLIAN:
      return "mn"; /* Ambiguous: could be "mn_CN" or "mn_MN".  */
    case LANG_NEPALI:
      switch (sub)
	{
	case SUBLANG_DEFAULT: return "ne_NP";
	case SUBLANG_NEPALI_INDIA: return "ne_IN";
	}
      return "ne";
    case LANG_NORWEGIAN:
      switch (sub)
	{
	case SUBLANG_NORWEGIAN_BOKMAL: return "no_NO";
	case SUBLANG_NORWEGIAN_NYNORSK: return "nn_NO";
	}
      return "no";
    case LANG_ORIYA: return "or_IN";
    case 0x72: /* OROMO */ return "om_ET";
    case 0x79: /* PAPIAMENTU */ return "pap_AN";
    case 0x63: /* PASHTO */
      return "ps"; /* Ambiguous: could be "ps_PK" or "ps_AF".  */
    case LANG_POLISH: return "pl_PL";
    case LANG_PORTUGUESE:
      switch (sub)
	{
	case SUBLANG_PORTUGUESE: return "pt_PT";
	/* Hmm. SUBLANG_PORTUGUESE_BRAZILIAN == SUBLANG_DEFAULT.
	   Same phenomenon as SUBLANG_ENGLISH_US == SUBLANG_DEFAULT. */
	case SUBLANG_PORTUGUESE_BRAZILIAN: return "pt_BR";
	}
      return "pt";
    case LANG_PUNJABI: return "pa_IN";
    case 0x17: /* RHAETO-ROMANCE */ return "rm_CH";
    case LANG_ROMANIAN: return "ro_RO";
    case LANG_RUSSIAN:
      return "ru"; /* Ambiguous: could be "ru_RU" or "ru_UA".  */
    case 0x3b: /* SAMI */ return "se_NO";
    case LANG_SANSKRIT: return "sa_IN";
    case LANG_SINDHI: return "sd";
    case 0x5b: /* SINHALESE */ return "si_LK";
    case LANG_SLOVAK: return "sk_SK";
    case LANG_SLOVENIAN: return "sl_SI";
    case 0x77: /* SOMALI */ return "so_SO";
    case LANG_SORBIAN:
      /* FIXME: Adjust this when such locales appear on Unix.  */
      return "wen_DE";
    case LANG_SPANISH:
      switch (sub)
	{
	case SUBLANG_SPANISH: return "es_ES";
	case SUBLANG_SPANISH_MEXICAN: return "es_MX";
	case SUBLANG_SPANISH_MODERN:
	  return "es_ES@modern";	/* not seen on Unix */
	case SUBLANG_SPANISH_GUATEMALA: return "es_GT";
	case SUBLANG_SPANISH_COSTA_RICA: return "es_CR";
	case SUBLANG_SPANISH_PANAMA: return "es_PA";
	case SUBLANG_SPANISH_DOMINICAN_REPUBLIC: return "es_DO";
	case SUBLANG_SPANISH_VENEZUELA: return "es_VE";
	case SUBLANG_SPANISH_COLOMBIA: return "es_CO";
	case SUBLANG_SPANISH_PERU: return "es_PE";
	case SUBLANG_SPANISH_ARGENTINA: return "es_AR";
	case SUBLANG_SPANISH_ECUADOR: return "es_EC";
	case SUBLANG_SPANISH_CHILE: return "es_CL";
	case SUBLANG_SPANISH_URUGUAY: return "es_UY";
	case SUBLANG_SPANISH_PARAGUAY: return "es_PY";
	case SUBLANG_SPANISH_BOLIVIA: return "es_BO";
	case SUBLANG_SPANISH_EL_SALVADOR: return "es_SV";
	case SUBLANG_SPANISH_HONDURAS: return "es_HN";
	case SUBLANG_SPANISH_NICARAGUA: return "es_NI";
	case SUBLANG_SPANISH_PUERTO_RICO: return "es_PR";
	}
      return "es";
    case 0x30: /* SUTU */ return "bnt_TZ";
    case LANG_SWAHILI: return "sw_KE";
    case LANG_SWEDISH:
      switch (sub)
	{
	case SUBLANG_DEFAULT: return "sv_SE";
	case SUBLANG_SWEDISH_FINLAND: return "sv_FI";
	}
      return "sv";
    case LANG_SYRIAC: return "syr_TR"; /* An extinct language.  */
    case 0x64: /* TAGALOG */ return "tl_PH";
    case 0x28: /* TAJIK */ return "tg_TJ";
    case 0x5f: /* TAMAZIGHT */ return "ber_MA";
    case LANG_TAMIL:
      return "ta"; /* Ambiguous: could be "ta_IN" or "ta_LK" or "ta_SG".  */
    case LANG_TATAR: return "tt_RU";
    case LANG_TELUGU: return "te_IN";
    case LANG_THAI: return "th_TH";
    case 0x51: /* TIBETAN */ return "bo_CN";
    case 0x73: /* TIGRINYA */ return "ti_ET";
    case 0x31: /* TSONGA */ return "ts_ZA";
    case LANG_TURKISH: return "tr_TR";
    case 0x42: /* TURKMEN */ return "tk_TM";
    case LANG_UKRAINIAN: return "uk_UA";
    case LANG_URDU:
      switch (sub)
	{
	case SUBLANG_URDU_PAKISTAN: return "ur_PK";
	case SUBLANG_URDU_INDIA: return "ur_IN";
	}
      return "ur";
    case LANG_UZBEK:
      switch (sub)
	{
	/* FIXME: Adjust this when Uzbek locales appear on Unix.  */
	case SUBLANG_UZBEK_LATIN: return "uz_UZ@latin";
	case SUBLANG_UZBEK_CYRILLIC: return "uz_UZ@cyrillic";
	}
      return "uz";
    case 0x33: /* VENDA */ return "ven_ZA";
    case LANG_VIETNAMESE: return "vi_VN";
    case 0x52: /* WELSH */ return "cy_GB";
    case 0x34: /* XHOSA */ return "xh_ZA";
    case 0x78: /* YI */ return "sit_CN";
    case 0x3d: /* YIDDISH */ return "yi_IL";
    case 0x6a: /* YORUBA */ return "yo_NG";
    case 0x35: /* ZULU */ return "zu_ZA";
    default: return "C";
    }

#endif
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\intl\localename.c:389
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\intl\log.c...
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\intl\log.c:33
parsing error 
{
  putc ('"', stream);
  for (; *str != '\0'; str++)
    if (*str == '\n')
      {
	fputs ("\\n\"", stream);
	if (str[1] == '\0')
	  return;
	fputs ("\n\"", stream);
      }
    else
      {
	if (*str == '"' || *str == '\\')
	  putc ('\\', stream);
	putc (*str, stream);
      }
  putc ('"', stream);
}
warning: parse error {
  putc ('"', stream);
  for (; *str != '\0'; str++)
    if (*str == '\n')
      {
	fputs ("\\n\"", stream);
	if (str[1] == '\0')
	  return;
	fputs ("\n\"", stream);
      }
    else
      {
	if (*str == '"' || *str == '\\')
	  putc ('\\', stream);
	putc (*str, stream);
      }
  putc ('"', stream);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\intl\log.c:36
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\intl\log.c:58
parsing error 
{
  static char *last_logfilename = NULL;
  static FILE *last_logfile = NULL;
  FILE *logfile;

  /* Can we reuse the last opened logfile?  */
  if (last_logfilename == NULL || strcmp (logfilename, last_logfilename) != 0)
    {
      /* Close the last used logfile.  */
      if (last_logfilename != NULL)
	{
	  if (last_logfile != NULL)
	    {
	      fclose (last_logfile);
	      last_logfile = NULL;
	    }
	  free (last_logfilename);
	  last_logfilename = NULL;
	}
      /* Open the logfile.  */
      last_logfilename = (char *) malloc (strlen (logfilename) + 1);
      if (last_logfilename == NULL)
	return;
      strcpy (last_logfilename, logfilename);
      last_logfile = fopen (logfilename, "a");
      if (last_logfile == NULL)
	return;
    }
  logfile = last_logfile;

  fprintf (logfile, "domain ");
  print_escaped (logfile, domainname);
  fprintf (logfile, "\nmsgid ");
  print_escaped (logfile, msgid1);
  if (plural)
    {
      fprintf (logfile, "\nmsgid_plural ");
      print_escaped (logfile, msgid2);
      fprintf (logfile, "\nmsgstr[0] \"\"\n");
    }
  else
    fprintf (logfile, "\nmsgstr \"\"\n");
  putc ('\n', logfile);
}
warning: parse error {
  static char *last_logfilename = NULL;
  static FILE *last_logfile = NULL;
  FILE *logfile;

  /* Can we reuse the last opened logfile?  */
  if (last_logfilename == NULL || strcmp (logfilename, last_logfilename) != 0)
    {
      /* Close the last used logfile.  */
      if (last_logfilename != NULL)
	{
	  if (last_logfile != NULL)
	    {
	      fclose (last_logfile);
	      last_logfile = NULL;
	    }
	  free (last_logfilename);
	  last_logfilename = NULL;
	}
      /* Open the logfile.  */
      last_logfilename = (char *) malloc (strlen (logfilename) + 1);
      if (last_logfilename == NULL)
	return;
      strcpy (last_logfilename, logfilename);
      last_logfile = fopen (logfilename, "a");
      if (last_logfile == NULL)
	return;
    }
  logfile = last_logfile;

  fprintf (logfile, "domain ");
  print_escaped (logfile, domainname);
  fprintf (logfile, "\nmsgid ");
  print_escaped (logfile, msgid1);
  if (plural)
    {
      fprintf (logfile, "\nmsgid_plural ");
      print_escaped (logfile, msgid2);
      fprintf (logfile, "\nmsgstr[0] \"\"\n");
    }
  else
    fprintf (logfile, "\nmsgstr \"\"\n");
  putc ('\n', logfile);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\intl\log.c:63
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\intl\ngettext.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\intl\gettextP.h...skip
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\intl\ngettext.c:60
parsing error 
{
  return DCNGETTEXT (NULL, msgid1, msgid2, n, LC_MESSAGES);
}
warning: parse error {
  return DCNGETTEXT (NULL, msgid1, msgid2, n, LC_MESSAGES);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\intl\ngettext.c:63
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\intl\os2compat.c...
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\intl\osdep.c...
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\intl\plural-exp.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\intl\plural-exp.h...skip
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\intl\plural-exp.c:102
parsing error 
{
  if (nullentry != NULL)
    {
      const char *plural;
      const char *nplurals;

      plural = strstr (nullentry, "plural=");
      nplurals = strstr (nullentry, "nplurals=");
      if (plural == NULL || nplurals == NULL)
	goto no_plural;
      else
	{
	  char *endp;
	  unsigned long int n;
	  struct parse_args args;

	  /* First get the number.  */
	  nplurals += 9;
	  while (*nplurals != '\0' && isspace ((unsigned char) *nplurals))
	    ++nplurals;
	  if (!(*nplurals >= '0' && *nplurals <= '9'))
	    goto no_plural;
#if defined HAVE_STRTOUL || defined _LIBC
	  n = strtoul (nplurals, &endp, 10);
#else
	  for (endp = nplurals, n = 0; *endp >= '0' && *endp <= '9'; endp++)
	    n = n * 10 + (*endp - '0');
#endif
	  if (nplurals == endp)
	    goto no_plural;
	  *npluralsp = n;

	  /* Due to the restrictions bison imposes onto the interface of the
	     scanner function we have to put the input string and the result
	     passed up from the parser into the same structure which address
	     is passed down to the parser.  */
	  plural += 7;
	  args.cp = plural;
	  if (PLURAL_PARSE (&args) != 0)
	    goto no_plural;
	  *pluralp = args.res;
	}
    }
  else
    {
      /* By default we are using the Germanic form: singular form only
         for `one', the plural form otherwise.  Yes, this is also what
         English is using since English is a Germanic language.  */
    no_plural:
      INIT_GERMANIC_PLURAL ();
      *pluralp = &GERMANIC_PLURAL;
      *npluralsp = 2;
    }
}
warning: parse error {
  if (nullentry != NULL)
    {
      const char *plural;
      const char *nplurals;

      plural = strstr (nullentry, "plural=");
      nplurals = strstr (nullentry, "nplurals=");
      if (plural == NULL || nplurals == NULL)
	goto no_plural;
      else
	{
	  char *endp;
	  unsigned long int n;
	  struct parse_args args;

	  /* First get the number.  */
	  nplurals += 9;
	  while (*nplurals != '\0' && isspace ((unsigned char) *nplurals))
	    ++nplurals;
	  if (!(*nplurals >= '0' && *nplurals <= '9'))
	    goto no_plural;
#if defined HAVE_STRTOUL || defined _LIBC
	  n = strtoul (nplurals, &endp, 10);
#else
	  for (endp = nplurals, n = 0; *endp >= '0' && *endp <= '9'; endp++)
	    n = n * 10 + (*endp - '0');
#endif
	  if (nplurals == endp)
	    goto no_plural;
	  *npluralsp = n;

	  /* Due to the restrictions bison imposes onto the interface of the
	     scanner function we have to put the input string and the result
	     passed up from the parser into the same structure which address
	     is passed down to the parser.  */
	  plural += 7;
	  args.cp = plural;
	  if (PLURAL_PARSE (&args) != 0)
	    goto no_plural;
	  *pluralp = args.res;
	}
    }
  else
    {
      /* By default we are using the Germanic form: singular form only
         for `one', the plural form otherwise.  Yes, this is also what
         English is using since English is a Germanic language.  */
    no_plural:
      INIT_GERMANIC_PLURAL ();
      *pluralp = &GERMANIC_PLURAL;
      *npluralsp = 2;
    }
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\intl\plural-exp.c:105
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\intl\plural.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\intl\plural-exp.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\intl\plural.c:182
parsing error 
{
  int i;
  struct expression *newp;

  /* If any of the argument could not be malloc'ed, just return NULL.  */
  for (i = nargs - 1; i >= 0; i--)
    if (args[i] == NULL)
      goto fail;

  /* Allocate a new expression.  */
  newp = (struct expression *) malloc (sizeof (*newp));
  if (newp != NULL)
    {
      newp->nargs = nargs;
      newp->operation = op;
      for (i = nargs - 1; i >= 0; i--)
	newp->val.args[i] = args[i];
      return newp;
    }

 fail:
  for (i = nargs - 1; i >= 0; i--)
    FREE_EXPRESSION (args[i]);

  return NULL;
}
warning: parse error {
  int i;
  struct expression *newp;

  /* If any of the argument could not be malloc'ed, just return NULL.  */
  for (i = nargs - 1; i >= 0; i--)
    if (args[i] == NULL)
      goto fail;

  /* Allocate a new expression.  */
  newp = (struct expression *) malloc (sizeof (*newp));
  if (newp != NULL)
    {
      newp->nargs = nargs;
      newp->operation = op;
      for (i = nargs - 1; i >= 0; i--)
	newp->val.args[i] = args[i];
      return newp;
    }

 fail:
  for (i = nargs - 1; i >= 0; i--)
    FREE_EXPRESSION (args[i]);

  return NULL;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\intl\plural.c:186
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\intl\plural.c:214
parsing error 
{
  return new_exp (0, op, NULL);
}
warning: parse error {
  return new_exp (0, op, NULL);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\intl\plural.c:216
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\intl\plural.c:221
parsing error 
{
  struct expression *args[1];

  args[0] = right;
  return new_exp (1, op, args);
}
warning: parse error {
  struct expression *args[1];

  args[0] = right;
  return new_exp (1, op, args);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\intl\plural.c:224
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\intl\plural.c:232
parsing error 
{
  struct expression *args[2];

  args[0] = left;
  args[1] = right;
  return new_exp (2, op, args);
}
warning: parse error {
  struct expression *args[2];

  args[0] = left;
  args[1] = right;
  return new_exp (2, op, args);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\intl\plural.c:236
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\intl\plural.c:245
parsing error 
{
  struct expression *args[3];

  args[0] = bexp;
  args[1] = tbranch;
  args[2] = fbranch;
  return new_exp (3, op, args);
}
warning: parse error {
  struct expression *args[3];

  args[0] = bexp;
  args[1] = tbranch;
  args[2] = fbranch;
  return new_exp (3, op, args);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\intl\plural.c:250
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\intl\plural.c:1,503
parsing error 
{
  if (exp == NULL)
    return;

  /* Handle the recursive case.  */
  switch (exp->nargs)
    {
    case 3:
      FREE_EXPRESSION (exp->val.args[2]);
      /* FALLTHROUGH */
    case 2:
      FREE_EXPRESSION (exp->val.args[1]);
      /* FALLTHROUGH */
    case 1:
      FREE_EXPRESSION (exp->val.args[0]);
      /* FALLTHROUGH */
    default:
      break;
    }

  free (exp);
}
warning: parse error {
  if (exp == NULL)
    return;

  /* Handle the recursive case.  */
  switch (exp->nargs)
    {
    case 3:
      FREE_EXPRESSION (exp->val.args[2]);
      /* FALLTHROUGH */
    case 2:
      FREE_EXPRESSION (exp->val.args[1]);
      /* FALLTHROUGH */
    case 1:
      FREE_EXPRESSION (exp->val.args[0]);
      /* FALLTHROUGH */
    default:
      break;
    }

  free (exp);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\intl\plural.c:1,505
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\intl\plural.c:1,530
parsing error 
{
  const char *exp = *pexp;
  int result;

  while (1)
    {
      if (exp[0] == '\0')
	{
	  *pexp = exp;
	  return YYEOF;
	}

      if (exp[0] != ' ' && exp[0] != '\t')
	break;

      ++exp;
    }

  result = *exp++;
  switch (result)
    {
    case '0': case '1': case '2': case '3': case '4':
    case '5': case '6': case '7': case '8': case '9':
      {
	unsigned long int n = result - '0';
	while (exp[0] >= '0' && exp[0] <= '9')
	  {
	    n *= 10;
	    n += exp[0] - '0';
	    ++exp;
	  }
	lval->num = n;
	result = NUMBER;
      }
      break;

    case '=':
      if (exp[0] == '=')
	{
	  ++exp;
	  lval->op = equal;
	  result = EQUOP2;
	}
      else
	result = YYERRCODE;
      break;

    case '!':
      if (exp[0] == '=')
	{
	  ++exp;
	  lval->op = not_equal;
	  result = EQUOP2;
	}
      break;

    case '&':
    case '|':
      if (exp[0] == result)
	++exp;
      else
	result = YYERRCODE;
      break;

    case '<':
      if (exp[0] == '=')
	{
	  ++exp;
	  lval->op = less_or_equal;
	}
      else
	lval->op = less_than;
      result = CMPOP2;
      break;

    case '>':
      if (exp[0] == '=')
	{
	  ++exp;
	  lval->op = greater_or_equal;
	}
      else
	lval->op = greater_than;
      result = CMPOP2;
      break;

    case '*':
      lval->op = mult;
      result = MULOP2;
      break;

    case '/':
      lval->op = divide;
      result = MULOP2;
      break;

    case '%':
      lval->op = module;
      result = MULOP2;
      break;

    case '+':
      lval->op = plus;
      result = ADDOP2;
      break;

    case '-':
      lval->op = minus;
      result = ADDOP2;
      break;

    case 'n':
    case '?':
    case ':':
    case '(':
    case ')':
      /* Nothing, just return the character.  */
      break;

    case ';':
    case '\n':
    case '\0':
      /* Be safe and let the user call this function again.  */
      --exp;
      result = YYEOF;
      break;

    default:
      result = YYERRCODE;
#if YYDEBUG != 0
      --exp;
#endif
      break;
    }

  *pexp = exp;

  return result;
}
warning: parse error {
  const char *exp = *pexp;
  int result;

  while (1)
    {
      if (exp[0] == '\0')
	{
	  *pexp = exp;
	  return YYEOF;
	}

      if (exp[0] != ' ' && exp[0] != '\t')
	break;

      ++exp;
    }

  result = *exp++;
  switch (result)
    {
    case '0': case '1': case '2': case '3': case '4':
    case '5': case '6': case '7': case '8': case '9':
      {
	unsigned long int n = result - '0';
	while (exp[0] >= '0' && exp[0] <= '9')
	  {
	    n *= 10;
	    n += exp[0] - '0';
	    ++exp;
	  }
	lval->num = n;
	result = NUMBER;
      }
      break;

    case '=':
      if (exp[0] == '=')
	{
	  ++exp;
	  lval->op = equal;
	  result = EQUOP2;
	}
      else
	result = YYERRCODE;
      break;

    case '!':
      if (exp[0] == '=')
	{
	  ++exp;
	  lval->op = not_equal;
	  result = EQUOP2;
	}
      break;

    case '&':
    case '|':
      if (exp[0] == result)
	++exp;
      else
	result = YYERRCODE;
      break;

    case '<':
      if (exp[0] == '=')
	{
	  ++exp;
	  lval->op = less_or_equal;
	}
      else
	lval->op = less_than;
      result = CMPOP2;
      break;

    case '>':
      if (exp[0] == '=')
	{
	  ++exp;
	  lval->op = greater_or_equal;
	}
      else
	lval->op = greater_than;
      result = CMPOP2;
      break;

    case '*':
      lval->op = mult;
      result = MULOP2;
      break;

    case '/':
      lval->op = divide;
      result = MULOP2;
      break;

    case '%':
      lval->op = module;
      result = MULOP2;
      break;

    case '+':
      lval->op = plus;
      result = ADDOP2;
      break;

    case '-':
      lval->op = minus;
      result = ADDOP2;
      break;

    case 'n':
    case '?':
    case ':':
    case '(':
    case ')':
      /* Nothing, just return the character.  */
      break;

    case ';':
    case '\n':
    case '\0':
      /* Be safe and let the user call this function again.  */
      --exp;
      result = YYEOF;
      break;

    default:
      result = YYERRCODE;
#if YYDEBUG != 0
      --exp;
#endif
      break;
    }

  *pexp = exp;

  return result;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\intl\plural.c:1,533
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\intl\plural.c:1,676
parsing error 
{
  /* Do nothing.  We don't print error messages here.  */
}
warning: parse error {
  /* Do nothing.  We don't print error messages here.  */
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\intl\plural.c:1,677
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\intl\relocatable.c...
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\intl\relocatable.h...
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\intl\textdomain.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\intl\gettextP.h...skip
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\intl\textdomain.c:83
parsing error 
{
  char *new_domain;
  char *old_domain;

  /* A NULL pointer requests the current setting.  */
  if (domainname == NULL)
    return (char *) _nl_current_default_domain;

  __libc_rwlock_wrlock (_nl_state_lock);

  old_domain = (char *) _nl_current_default_domain;

  /* If domain name is the null string set to default domain "messages".  */
  if (domainname[0] == '\0'
      || strcmp (domainname, _nl_default_default_domain) == 0)
    {
      _nl_current_default_domain = _nl_default_default_domain;
      new_domain = (char *) _nl_current_default_domain;
    }
  else if (strcmp (domainname, old_domain) == 0)
    /* This can happen and people will use it to signal that some
       environment variable changed.  */
    new_domain = old_domain;
  else
    {
      /* If the following malloc fails `_nl_current_default_domain'
	 will be NULL.  This value will be returned and so signals we
	 are out of core.  */
#if defined _LIBC || defined HAVE_STRDUP
      new_domain = strdup (domainname);
#else
      size_t len = strlen (domainname) + 1;
      new_domain = (char *) malloc (len);
      if (new_domain != NULL)
	memcpy (new_domain, domainname, len);
#endif

      if (new_domain != NULL)
	_nl_current_default_domain = new_domain;
    }

  /* We use this possibility to signal a change of the loaded catalogs
     since this is most likely the case and there is no other easy we
     to do it.  Do it only when the call was successful.  */
  if (new_domain != NULL)
    {
      ++_nl_msg_cat_cntr;

      if (old_domain != new_domain && old_domain != _nl_default_default_domain)
	free (old_domain);
    }

  __libc_rwlock_unlock (_nl_state_lock);

  return new_domain;
}
warning: parse error {
  char *new_domain;
  char *old_domain;

  /* A NULL pointer requests the current setting.  */
  if (domainname == NULL)
    return (char *) _nl_current_default_domain;

  __libc_rwlock_wrlock (_nl_state_lock);

  old_domain = (char *) _nl_current_default_domain;

  /* If domain name is the null string set to default domain "messages".  */
  if (domainname[0] == '\0'
      || strcmp (domainname, _nl_default_default_domain) == 0)
    {
      _nl_current_default_domain = _nl_default_default_domain;
      new_domain = (char *) _nl_current_default_domain;
    }
  else if (strcmp (domainname, old_domain) == 0)
    /* This can happen and people will use it to signal that some
       environment variable changed.  */
    new_domain = old_domain;
  else
    {
      /* If the following malloc fails `_nl_current_default_domain'
	 will be NULL.  This value will be returned and so signals we
	 are out of core.  */
#if defined _LIBC || defined HAVE_STRDUP
      new_domain = strdup (domainname);
#else
      size_t len = strlen (domainname) + 1;
      new_domain = (char *) malloc (len);
      if (new_domain != NULL)
	memcpy (new_domain, domainname, len);
#endif

      if (new_domain != NULL)
	_nl_current_default_domain = new_domain;
    }

  /* We use this possibility to signal a change of the loaded catalogs
     since this is most likely the case and there is no other easy we
     to do it.  Do it only when the call was successful.  */
  if (new_domain != NULL)
    {
      ++_nl_msg_cat_cntr;

      if (old_domain != new_domain && old_domain != _nl_default_default_domain)
	free (old_domain);
    }

  __libc_rwlock_unlock (_nl_state_lock);

  return new_domain;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\intl\textdomain.c:84
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\malloc\alloca.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashtypes.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\malloc\alloca.c:159
parsing error 
{
  auto char probe;		/* Probes stack depth: */
  register char *depth = ADDRESS_FUNCTION (probe);

#if STACK_DIRECTION == 0
  if (STACK_DIR == 0)		/* Unknown growth direction.  */
    find_stack_direction ();
#endif

  /* Reclaim garbage, defined as all alloca'd storage that
     was allocated from deeper in the stack than currently. */

  {
    register header *hp;	/* Traverses linked list.  */

    for (hp = last_alloca_header; hp != NULL;)
      if ((STACK_DIR > 0 && hp->h.deep > depth)
	  || (STACK_DIR < 0 && hp->h.deep < depth))
	{
	  register header *np = hp->h.next;

	  free ((pointer) hp);	/* Collect garbage.  */

	  hp = np;		/* -> next header.  */
	}
      else
	break;			/* Rest are not deeper.  */

    last_alloca_header = hp;	/* -> last valid storage.  */
  }

  if (size == 0)
    return NULL;		/* No allocation required.  */

  /* Allocate combined header + user data storage.  */

  {
    register pointer new = malloc (sizeof (header) + size);
    /* Address of header.  */

    ((header *) new)->h.next = last_alloca_header;
    ((header *) new)->h.deep = depth;

    last_alloca_header = (header *) new;

    /* User storage begins just after header.  */

    return (pointer) ((char *) new + sizeof (header));
  }
}
warning: parse error {
  auto char probe;		/* Probes stack depth: */
  register char *depth = ADDRESS_FUNCTION (probe);

#if STACK_DIRECTION == 0
  if (STACK_DIR == 0)		/* Unknown growth direction.  */
    find_stack_direction ();
#endif

  /* Reclaim garbage, defined as all alloca'd storage that
     was allocated from deeper in the stack than currently. */

  {
    register header *hp;	/* Traverses linked list.  */

    for (hp = last_alloca_header; hp != NULL;)
      if ((STACK_DIR > 0 && hp->h.deep > depth)
	  || (STACK_DIR < 0 && hp->h.deep < depth))
	{
	  register header *np = hp->h.next;

	  free ((pointer) hp);	/* Collect garbage.  */

	  hp = np;		/* -> next header.  */
	}
      else
	break;			/* Rest are not deeper.  */

    last_alloca_header = hp;	/* -> last valid storage.  */
  }

  if (size == 0)
    return NULL;		/* No allocation required.  */

  /* Allocate combined header + user data storage.  */

  {
    register pointer new = malloc (sizeof (header) + size);
    /* Address of header.  */

    ((header *) new)->h.next = last_alloca_header;
    ((header *) new)->h.deep = depth;

    last_alloca_header = (header *) new;

    /* User storage begins just after header.  */

    return (pointer) ((char *) new + sizeof (header));
  }
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\malloc\alloca.c:161
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\malloc\malloc.c...
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\malloc\imalloc.h...
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\malloc\malloc.c:349
parsing error 
{
  fprintf (stderr, _("malloc: failed assertion: %s\n"), s);
  (void)fflush (stderr);
  abort ();
}
warning: parse error {
  fprintf (stderr, _("malloc: failed assertion: %s\n"), s);
  (void)fflush (stderr);
  abort ();
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\malloc\malloc.c:352
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\malloc\malloc.c:362
parsing error 
{
  fprintf (stderr, _("\r\nmalloc: %s:%d: assertion botched\r\n"),
			file ? file : _("unknown"), line);
#ifdef MALLOC_REGISTER
  if (mem != NULL && malloc_register)
    mregister_describe_mem (mem, stderr);
#endif
  (void)fflush (stderr);
  botch(s, file, line);
}
warning: parse error {
  fprintf (stderr, _("\r\nmalloc: %s:%d: assertion botched\r\n"),
			file ? file : _("unknown"), line);
#ifdef MALLOC_REGISTER
  if (mem != NULL && malloc_register)
    mregister_describe_mem (mem, stderr);
#endif
  (void)fflush (stderr);
  botch(s, file, line);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\malloc\malloc.c:368
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\malloc\malloc.c:384
parsing error 
{
  register union mhead *mp, *mp1, *mp2;
  register int nbuck;
  unsigned long siz;

  nbuck = nu - 1;
  if (nextf[nbuck] == 0 || busy[nbuck])
    return;

  busy[nbuck] = 1;
  siz = binsize (nbuck);

  mp2 = mp1 = nextf[nbuck];
  mp = CHAIN (mp1);
  while (mp && mp != (union mhead *)((char *)mp1 + siz))
    {
      mp2 = mp1;
      mp1 = mp;
      mp = CHAIN (mp);
    }

  if (mp == 0)
    {
      busy[nbuck] = 0;
      return;
    }

  /* OK, now we have mp1 pointing to the block we want to add to nextf[NU].
     CHAIN(mp2) must equal mp1.  Check that mp1 and mp are adjacent. */
  if (mp2 != mp1 && CHAIN(mp2) != mp1)
    {
      busy[nbuck] = 0;
      xbotch ((PTR_T)0, 0, "bcoalesce: CHAIN(mp2) != mp1", (char *)NULL, 0);
    }

#ifdef MALLOC_DEBUG
  if (CHAIN (mp1) != (union mhead *)((char *)mp1 + siz))
    {
      busy[nbuck] = 0;
      return;	/* not adjacent */
    }
#endif

  /* Since they are adjacent, remove them from the free list */
  if (mp1 == nextf[nbuck])
    nextf[nbuck] = CHAIN (mp);
  else
    CHAIN (mp2) = CHAIN (mp);
  busy[nbuck] = 0;

#ifdef MALLOC_STATS
  _mstats.tbcoalesce++;
  _mstats.ncoalesce[nbuck]++;
#endif

  /* And add the combined two blocks to nextf[NU]. */
  mp1->mh_alloc = ISFREE;
  mp1->mh_index = nu;
  CHAIN (mp1) = nextf[nu];
  nextf[nu] = mp1;
}
warning: parse error {
  register union mhead *mp, *mp1, *mp2;
  register int nbuck;
  unsigned long siz;

  nbuck = nu - 1;
  if (nextf[nbuck] == 0 || busy[nbuck])
    return;

  busy[nbuck] = 1;
  siz = binsize (nbuck);

  mp2 = mp1 = nextf[nbuck];
  mp = CHAIN (mp1);
  while (mp && mp != (union mhead *)((char *)mp1 + siz))
    {
      mp2 = mp1;
      mp1 = mp;
      mp = CHAIN (mp);
    }

  if (mp == 0)
    {
      busy[nbuck] = 0;
      return;
    }

  /* OK, now we have mp1 pointing to the block we want to add to nextf[NU].
     CHAIN(mp2) must equal mp1.  Check that mp1 and mp are adjacent. */
  if (mp2 != mp1 && CHAIN(mp2) != mp1)
    {
      busy[nbuck] = 0;
      xbotch ((PTR_T)0, 0, "bcoalesce: CHAIN(mp2) != mp1", (char *)NULL, 0);
    }

#ifdef MALLOC_DEBUG
  if (CHAIN (mp1) != (union mhead *)((char *)mp1 + siz))
    {
      busy[nbuck] = 0;
      return;	/* not adjacent */
    }
#endif

  /* Since they are adjacent, remove them from the free list */
  if (mp1 == nextf[nbuck])
    nextf[nbuck] = CHAIN (mp);
  else
    CHAIN (mp2) = CHAIN (mp);
  busy[nbuck] = 0;

#ifdef MALLOC_STATS
  _mstats.tbcoalesce++;
  _mstats.ncoalesce[nbuck]++;
#endif

  /* And add the combined two blocks to nextf[NU]. */
  mp1->mh_alloc = ISFREE;
  mp1->mh_index = nu;
  CHAIN (mp1) = nextf[nu];
  nextf[nu] = mp1;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\malloc\malloc.c:386
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\malloc\malloc.c:453
parsing error 
{
  register union mhead *mp;
  int nbuck, nblks, split_max;
  unsigned long siz;

  split_max = (maxbuck > SPLIT_MAX) ? maxbuck : SPLIT_MAX;

  if (nu >= SPLIT_MID)
    {
      for (nbuck = split_max; nbuck > nu; nbuck--)
	{
	  if (busy[nbuck] || nextf[nbuck] == 0)
	    continue;
	  break;
	}
    }
  else
    {
      for (nbuck = nu + 1; nbuck <= split_max; nbuck++)
	{
	  if (busy[nbuck] || nextf[nbuck] == 0)
	    continue;
	  break;
	}
    }

  if (nbuck > split_max || nbuck <= nu)
    return;

  /* XXX might want to split only if nextf[nbuck] has >= 2 blocks free
     and nbuck is below some threshold. */

  /* Remove the block from the chain of larger blocks. */
  busy[nbuck] = 1;
  mp = nextf[nbuck];
  nextf[nbuck] = CHAIN (mp);
  busy[nbuck] = 0;

#ifdef MALLOC_STATS
  _mstats.tbsplit++;
  _mstats.nsplit[nbuck]++;
#endif

  /* Figure out how many blocks we'll get. */
  siz = binsize (nu);
  nblks = binsize (nbuck) / siz;

  /* Split the block and put it on the requested chain. */
  nextf[nu] = mp;
  while (1)
    {
      mp->mh_alloc = ISFREE;
      mp->mh_index = nu;
      if (--nblks <= 0) break;
      CHAIN (mp) = (union mhead *)((char *)mp + siz);
      mp = (union mhead *)((char *)mp + siz);
    }
  CHAIN (mp) = 0;
}
warning: parse error {
  register union mhead *mp;
  int nbuck, nblks, split_max;
  unsigned long siz;

  split_max = (maxbuck > SPLIT_MAX) ? maxbuck : SPLIT_MAX;

  if (nu >= SPLIT_MID)
    {
      for (nbuck = split_max; nbuck > nu; nbuck--)
	{
	  if (busy[nbuck] || nextf[nbuck] == 0)
	    continue;
	  break;
	}
    }
  else
    {
      for (nbuck = nu + 1; nbuck <= split_max; nbuck++)
	{
	  if (busy[nbuck] || nextf[nbuck] == 0)
	    continue;
	  break;
	}
    }

  if (nbuck > split_max || nbuck <= nu)
    return;

  /* XXX might want to split only if nextf[nbuck] has >= 2 blocks free
     and nbuck is below some threshold. */

  /* Remove the block from the chain of larger blocks. */
  busy[nbuck] = 1;
  mp = nextf[nbuck];
  nextf[nbuck] = CHAIN (mp);
  busy[nbuck] = 0;

#ifdef MALLOC_STATS
  _mstats.tbsplit++;
  _mstats.nsplit[nbuck]++;
#endif

  /* Figure out how many blocks we'll get. */
  siz = binsize (nu);
  nblks = binsize (nbuck) / siz;

  /* Split the block and put it on the requested chain. */
  nextf[nu] = mp;
  while (1)
    {
      mp->mh_alloc = ISFREE;
      mp->mh_index = nu;
      if (--nblks <= 0) break;
      CHAIN (mp) = (union mhead *)((char *)mp + siz);
      mp = (union mhead *)((char *)mp + siz);
    }
  CHAIN (mp) = 0;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\malloc\malloc.c:455
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\malloc\malloc.c:518
parsing error 
{
  union mhead *nh;
  int nbuck, nblks, split_max;
  unsigned long siz;

  nbuck = nu - 1;
  while (nbuck >= SPLIT_MIN && busy[nbuck])
    nbuck--;
  if (nbuck < SPLIT_MIN)
    return;

#ifdef MALLOC_STATS
  _mstats.tbsplit++;
  _mstats.nsplit[nu]++;
#endif

  /* Figure out how many blocks we'll get. */
  siz = binsize (nu);			/* original block size */
  nblks = siz / binsize (nbuck);	/* should be 2 most of the time */

  /* And add it to nextf[nbuck] */
  siz = binsize (nbuck);		/* XXX - resetting here */
  nh = mp;
  while (1)
    {
      mp->mh_alloc = ISFREE;
      mp->mh_index = nbuck;
      if (--nblks <= 0) break;
      CHAIN (mp) = (union mhead *)((char *)mp + siz);
      mp = (union mhead *)((char *)mp + siz);
    }
  busy[nbuck] = 1;
  CHAIN (mp) = nextf[nbuck];
  nextf[nbuck] = nh;
  busy[nbuck] = 0;
}
warning: parse error {
  union mhead *nh;
  int nbuck, nblks, split_max;
  unsigned long siz;

  nbuck = nu - 1;
  while (nbuck >= SPLIT_MIN && busy[nbuck])
    nbuck--;
  if (nbuck < SPLIT_MIN)
    return;

#ifdef MALLOC_STATS
  _mstats.tbsplit++;
  _mstats.nsplit[nu]++;
#endif

  /* Figure out how many blocks we'll get. */
  siz = binsize (nu);			/* original block size */
  nblks = siz / binsize (nbuck);	/* should be 2 most of the time */

  /* And add it to nextf[nbuck] */
  siz = binsize (nbuck);		/* XXX - resetting here */
  nh = mp;
  while (1)
    {
      mp->mh_alloc = ISFREE;
      mp->mh_index = nbuck;
      if (--nblks <= 0) break;
      CHAIN (mp) = (union mhead *)((char *)mp + siz);
      mp = (union mhead *)((char *)mp + siz);
    }
  busy[nbuck] = 1;
  CHAIN (mp) = nextf[nbuck];
  nextf[nbuck] = nh;
  busy[nbuck] = 0;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\malloc\malloc.c:521
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\malloc\malloc.c:559
parsing error 
{
#ifdef HAVE_POSIX_SIGNALS
  sigfillset (setp);
  sigemptyset (osetp);
  sigprocmask (SIG_BLOCK, setp, osetp);
#else
#  if defined (HAVE_BSD_SIGNALS)
  *osetp = sigsetmask (-1);
#  endif
#endif
}
warning: parse error {
#ifdef HAVE_POSIX_SIGNALS
  sigfillset (setp);
  sigemptyset (osetp);
  sigprocmask (SIG_BLOCK, setp, osetp);
#else
#  if defined (HAVE_BSD_SIGNALS)
  *osetp = sigsetmask (-1);
#  endif
#endif
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\malloc\malloc.c:561
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\malloc\malloc.c:574
parsing error 
{
#ifdef HAVE_POSIX_SIGNALS
  sigprocmask (SIG_SETMASK, osetp, (sigset_t *)NULL);
#else
#  if defined (HAVE_BSD_SIGNALS)
  sigsetmask (*osetp);
#  endif
#endif
}
warning: parse error {
#ifdef HAVE_POSIX_SIGNALS
  sigprocmask (SIG_SETMASK, osetp, (sigset_t *)NULL);
#else
#  if defined (HAVE_BSD_SIGNALS)
  sigsetmask (*osetp);
#  endif
#endif
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\malloc\malloc.c:576
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\malloc\malloc.c:590
parsing error 
{
  long siz;

  siz = binsize (nu);
  /* Should check for errors here, I guess. */
  sbrk (-siz);
  memtop -= siz;

#ifdef MALLOC_STATS
  _mstats.nsbrk++;
  _mstats.tsbrk -= siz;
  _mstats.nlesscore[nu]++;
#endif
}
warning: parse error {
  long siz;

  siz = binsize (nu);
  /* Should check for errors here, I guess. */
  sbrk (-siz);
  memtop -= siz;

#ifdef MALLOC_STATS
  _mstats.nsbrk++;
  _mstats.tsbrk -= siz;
  _mstats.nlesscore[nu]++;
#endif
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\malloc\malloc.c:592
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\malloc\malloc.c:609
parsing error 
{
  register union mhead *mp;
  register int nblks;
  register long siz;
  long sbrk_amt;		/* amount to get via sbrk() */
  sigset_t set, oset;
  int blocked_sigs;

  /* Block all signals in case we are executed from a signal handler. */
  blocked_sigs = 0;
#ifdef SHELL
#  if defined (SIGCHLD)
  if (running_trap || signal_is_trapped (SIGINT) || signal_is_trapped (SIGCHLD))
#  else
  if (running_trap || signal_is_trapped (SIGINT))
#  endif
#endif
    {
      _malloc_block_signals (&set, &oset);
      blocked_sigs = 1;
    }

  siz = binsize (nu);	/* size of desired block for nextf[nu] */

  if (siz < 0)
    goto morecore_done;		/* oops */

#ifdef MALLOC_STATS
  _mstats.nmorecore[nu]++;
#endif

  /* Try to split a larger block here, if we're within the range of sizes
     to split. */
  if (nu >= SPLIT_MIN && nu <= malloc_mmap_threshold)
    {
      bsplit (nu);
      if (nextf[nu] != 0)
	goto morecore_done;
    }

  /* Try to coalesce two adjacent blocks from the free list on nextf[nu - 1],
     if we can, and we're within the range of the block coalescing limits. */
  if (nu >= COMBINE_MIN && nu < COMBINE_MAX && nu <= malloc_mmap_threshold && busy[nu - 1] == 0 && nextf[nu - 1])
    {
      bcoalesce (nu);
      if (nextf[nu] != 0)
	goto morecore_done;
    }

  /* Take at least a page, and figure out how many blocks of the requested
     size we're getting. */
  if (siz <= pagesz)
    {
      sbrk_amt = pagesz;
      nblks = sbrk_amt / siz;
    }
  else
    {
      /* We always want to request an integral multiple of the page size
	 from the kernel, so let's compute whether or not `siz' is such
	 an amount.  If it is, we can just request it.  If not, we want
	 the smallest integral multiple of pagesize that is larger than
	 `siz' and will satisfy the request. */
      sbrk_amt = siz & (pagesz - 1);
      if (sbrk_amt == 0)
	sbrk_amt = siz;
      else
	sbrk_amt = siz + pagesz - sbrk_amt;
      nblks = 1;
    }

#if defined (USE_MMAP)
  if (nu > malloc_mmap_threshold)
    {
      mp = (union mhead *)mmap (0, sbrk_amt, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0);
      if ((void *)mp == MAP_FAILED)
	goto morecore_done;
      nextf[nu] = mp;
      mp->mh_alloc = ISFREE;
      mp->mh_index = nu;
      CHAIN (mp) = 0;
#ifdef MALLOC_STATS
      _mstats.nmmap++;
      _mstats.tmmap += sbrk_amt;
#endif
      goto morecore_done;
    }
#endif
	

#ifdef MALLOC_STATS
  _mstats.nsbrk++;
  _mstats.tsbrk += sbrk_amt;
#endif

  mp = (union mhead *) sbrk (sbrk_amt);

  /* Totally out of memory. */
  if ((long)mp == -1)
    goto morecore_done;

  memtop += sbrk_amt;

  /* shouldn't happen, but just in case -- require 8- or 16-byte alignment */
  if ((long)mp & MALIGN_MASK)
    {
      mp = (union mhead *) (((long)mp + MALIGN_MASK) & ~MALIGN_MASK);
      nblks--;
    }

  /* save new header and link the nblks blocks together */
  nextf[nu] = mp;
  while (1)
    {
      mp->mh_alloc = ISFREE;
      mp->mh_index = nu;
      if (--nblks <= 0) break;
      CHAIN (mp) = (union mhead *)((char *)mp + siz);
      mp = (union mhead *)((char *)mp + siz);
    }
  CHAIN (mp) = 0;

morecore_done:
  if (blocked_sigs)
    _malloc_unblock_signals (&set, &oset);
}
warning: parse error {
  register union mhead *mp;
  register int nblks;
  register long siz;
  long sbrk_amt;		/* amount to get via sbrk() */
  sigset_t set, oset;
  int blocked_sigs;

  /* Block all signals in case we are executed from a signal handler. */
  blocked_sigs = 0;
#ifdef SHELL
#  if defined (SIGCHLD)
  if (running_trap || signal_is_trapped (SIGINT) || signal_is_trapped (SIGCHLD))
#  else
  if (running_trap || signal_is_trapped (SIGINT))
#  endif
#endif
    {
      _malloc_block_signals (&set, &oset);
      blocked_sigs = 1;
    }

  siz = binsize (nu);	/* size of desired block for nextf[nu] */

  if (siz < 0)
    goto morecore_done;		/* oops */

#ifdef MALLOC_STATS
  _mstats.nmorecore[nu]++;
#endif

  /* Try to split a larger block here, if we're within the range of sizes
     to split. */
  if (nu >= SPLIT_MIN && nu <= malloc_mmap_threshold)
    {
      bsplit (nu);
      if (nextf[nu] != 0)
	goto morecore_done;
    }

  /* Try to coalesce two adjacent blocks from the free list on nextf[nu - 1],
     if we can, and we're within the range of the block coalescing limits. */
  if (nu >= COMBINE_MIN && nu < COMBINE_MAX && nu <= malloc_mmap_threshold && busy[nu - 1] == 0 && nextf[nu - 1])
    {
      bcoalesce (nu);
      if (nextf[nu] != 0)
	goto morecore_done;
    }

  /* Take at least a page, and figure out how many blocks of the requested
     size we're getting. */
  if (siz <= pagesz)
    {
      sbrk_amt = pagesz;
      nblks = sbrk_amt / siz;
    }
  else
    {
      /* We always want to request an integral multiple of the page size
	 from the kernel, so let's compute whether or not `siz' is such
	 an amount.  If it is, we can just request it.  If not, we want
	 the smallest integral multiple of pagesize that is larger than
	 `siz' and will satisfy the request. */
      sbrk_amt = siz & (pagesz - 1);
      if (sbrk_amt == 0)
	sbrk_amt = siz;
      else
	sbrk_amt = siz + pagesz - sbrk_amt;
      nblks = 1;
    }

#if defined (USE_MMAP)
  if (nu > malloc_mmap_threshold)
    {
      mp = (union mhead *)mmap (0, sbrk_amt, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0);
      if ((void *)mp == MAP_FAILED)
	goto morecore_done;
      nextf[nu] = mp;
      mp->mh_alloc = ISFREE;
      mp->mh_index = nu;
      CHAIN (mp) = 0;
#ifdef MALLOC_STATS
      _mstats.nmmap++;
      _mstats.tmmap += sbrk_amt;
#endif
      goto morecore_done;
    }
#endif
	

#ifdef MALLOC_STATS
  _mstats.nsbrk++;
  _mstats.tsbrk += sbrk_amt;
#endif

  mp = (union mhead *) sbrk (sbrk_amt);

  /* Totally out of memory. */
  if ((long)mp == -1)
    goto morecore_done;

  memtop += sbrk_amt;

  /* shouldn't happen, but just in case -- require 8- or 16-byte alignment */
  if ((long)mp & MALIGN_MASK)
    {
      mp = (union mhead *) (((long)mp + MALIGN_MASK) & ~MALIGN_MASK);
      nblks--;
    }

  /* save new header and link the nblks blocks together */
  nextf[nu] = mp;
  while (1)
    {
      mp->mh_alloc = ISFREE;
      mp->mh_index = nu;
      if (--nblks <= 0) break;
      CHAIN (mp) = (union mhead *)((char *)mp + siz);
      mp = (union mhead *)((char *)mp + siz);
    }
  CHAIN (mp) = 0;

morecore_done:
  if (blocked_sigs)
    _malloc_unblock_signals (&set, &oset);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\malloc\malloc.c:611
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\malloc\malloc.c:820
parsing error 
{
  register union mhead *p;
  register int nunits;
  register char *m, *z;
  long nbytes;
  mguard_t mg;

  /* Get the system page size and align break pointer so future sbrks will
     be page-aligned.  The page size must be at least 1K -- anything
     smaller is increased. */
  if (pagesz == 0)
    if (pagealign () < 0)
      return ((PTR_T)NULL);
 
  /* Figure out how many bytes are required, rounding up to the nearest
     multiple of 8, then figure out which nextf[] area to use.  Try to
     be smart about where to start searching -- if the number of bytes
     needed is greater than the page size, we can start at pagebucket. */
  nbytes = ALLOCATED_BYTES(n);
  nunits = (nbytes <= (pagesz >> 1)) ? STARTBUCK : pagebucket;
  for ( ; nunits < NBUCKETS; nunits++)
    if (nbytes <= binsize(nunits))
      break;

  /* Silently reject too-large requests. XXX - can increase this if HAVE_MMAP */
  if (nunits >= NBUCKETS)
    return ((PTR_T) NULL);

  /* In case this is reentrant use of malloc from signal handler,
     pick a block size that no other malloc level is currently
     trying to allocate.  That's the easiest harmless way not to
     interfere with the other level of execution.  */
#ifdef MALLOC_STATS
  if (busy[nunits]) _mstats.nrecurse++;
#endif
  while (busy[nunits]) nunits++;
  busy[nunits] = 1;

  if (nunits > maxbuck)
    maxbuck = nunits;

  /* If there are no blocks of the appropriate size, go get some */
  if (nextf[nunits] == 0)
    morecore (nunits);

  /* Get one block off the list, and set the new list head */
  if ((p = nextf[nunits]) == NULL)
    {
      busy[nunits] = 0;
      return NULL;
    }
  nextf[nunits] = CHAIN (p);
  busy[nunits] = 0;

  /* Check for free block clobbered */
  /* If not for this check, we would gobble a clobbered free chain ptr
     and bomb out on the NEXT allocate of this size block */
  if (p->mh_alloc != ISFREE || p->mh_index != nunits)
    xbotch ((PTR_T)(p+1), 0, _("malloc: block on free list clobbered"), file, line);

  /* Fill in the info, and set up the magic numbers for range checking. */
  p->mh_alloc = ISALLOC;
  p->mh_magic2 = MAGIC2;
  p->mh_nbytes = n;

#if SIZEOF_CHAR_P == 8
  /* Begin guard */
  MALLOC_MEMSET ((char *)p->mh_magic8, MAGIC1, 8);
#endif

  /* End guard */
  mg.i = n;
  z = mg.s;
  m = (char *) (p + 1) + n;
  *m++ = *z++, *m++ = *z++, *m++ = *z++, *m++ = *z++;

#ifdef MEMSCRAMBLE
  if (n)
    MALLOC_MEMSET ((char *)(p + 1), 0xdf, n);	/* scramble previous contents */
#endif
#ifdef MALLOC_STATS
  _mstats.nmalloc[nunits]++;
  _mstats.tmalloc[nunits]++;
  _mstats.nmal++;
  _mstats.bytesreq += n;
#endif /* MALLOC_STATS */

#ifdef MALLOC_TRACE
  if (malloc_trace && (flags & MALLOC_NOTRACE) == 0)
    mtrace_alloc ("malloc", p + 1, n, file, line);
  else if (_malloc_trace_buckets[nunits])
    mtrace_alloc ("malloc", p + 1, n, file, line);
#endif

#ifdef MALLOC_REGISTER
  if (malloc_register && (flags & MALLOC_NOREG) == 0)
    mregister_alloc ("malloc", p + 1, n, file, line);
#endif

#ifdef MALLOC_WATCH
  if (_malloc_nwatch > 0)
    _malloc_ckwatch (p + 1, file, line, W_ALLOC, n);
#endif

#if defined (MALLOC_DEBUG)
  z = (char *) (p + 1);
  /* Check alignment of returned pointer */
  if ((unsigned long)z & MALIGN_MASK)
    fprintf (stderr, "malloc: %s:%d: warning: request for %d bytes not aligned on %d byte boundary\r\n",
	file ? file : _("unknown"), line, p->mh_nbytes, MALIGN_MASK+1);
#endif

  return (PTR_T) (p + 1);
}
warning: parse error {
  register union mhead *p;
  register int nunits;
  register char *m, *z;
  long nbytes;
  mguard_t mg;

  /* Get the system page size and align break pointer so future sbrks will
     be page-aligned.  The page size must be at least 1K -- anything
     smaller is increased. */
  if (pagesz == 0)
    if (pagealign () < 0)
      return ((PTR_T)NULL);
 
  /* Figure out how many bytes are required, rounding up to the nearest
     multiple of 8, then figure out which nextf[] area to use.  Try to
     be smart about where to start searching -- if the number of bytes
     needed is greater than the page size, we can start at pagebucket. */
  nbytes = ALLOCATED_BYTES(n);
  nunits = (nbytes <= (pagesz >> 1)) ? STARTBUCK : pagebucket;
  for ( ; nunits < NBUCKETS; nunits++)
    if (nbytes <= binsize(nunits))
      break;

  /* Silently reject too-large requests. XXX - can increase this if HAVE_MMAP */
  if (nunits >= NBUCKETS)
    return ((PTR_T) NULL);

  /* In case this is reentrant use of malloc from signal handler,
     pick a block size that no other malloc level is currently
     trying to allocate.  That's the easiest harmless way not to
     interfere with the other level of execution.  */
#ifdef MALLOC_STATS
  if (busy[nunits]) _mstats.nrecurse++;
#endif
  while (busy[nunits]) nunits++;
  busy[nunits] = 1;

  if (nunits > maxbuck)
    maxbuck = nunits;

  /* If there are no blocks of the appropriate size, go get some */
  if (nextf[nunits] == 0)
    morecore (nunits);

  /* Get one block off the list, and set the new list head */
  if ((p = nextf[nunits]) == NULL)
    {
      busy[nunits] = 0;
      return NULL;
    }
  nextf[nunits] = CHAIN (p);
  busy[nunits] = 0;

  /* Check for free block clobbered */
  /* If not for this check, we would gobble a clobbered free chain ptr
     and bomb out on the NEXT allocate of this size block */
  if (p->mh_alloc != ISFREE || p->mh_index != nunits)
    xbotch ((PTR_T)(p+1), 0, _("malloc: block on free list clobbered"), file, line);

  /* Fill in the info, and set up the magic numbers for range checking. */
  p->mh_alloc = ISALLOC;
  p->mh_magic2 = MAGIC2;
  p->mh_nbytes = n;

#if SIZEOF_CHAR_P == 8
  /* Begin guard */
  MALLOC_MEMSET ((char *)p->mh_magic8, MAGIC1, 8);
#endif

  /* End guard */
  mg.i = n;
  z = mg.s;
  m = (char *) (p + 1) + n;
  *m++ = *z++, *m++ = *z++, *m++ = *z++, *m++ = *z++;

#ifdef MEMSCRAMBLE
  if (n)
    MALLOC_MEMSET ((char *)(p + 1), 0xdf, n);	/* scramble previous contents */
#endif
#ifdef MALLOC_STATS
  _mstats.nmalloc[nunits]++;
  _mstats.tmalloc[nunits]++;
  _mstats.nmal++;
  _mstats.bytesreq += n;
#endif /* MALLOC_STATS */

#ifdef MALLOC_TRACE
  if (malloc_trace && (flags & MALLOC_NOTRACE) == 0)
    mtrace_alloc ("malloc", p + 1, n, file, line);
  else if (_malloc_trace_buckets[nunits])
    mtrace_alloc ("malloc", p + 1, n, file, line);
#endif

#ifdef MALLOC_REGISTER
  if (malloc_register && (flags & MALLOC_NOREG) == 0)
    mregister_alloc ("malloc", p + 1, n, file, line);
#endif

#ifdef MALLOC_WATCH
  if (_malloc_nwatch > 0)
    _malloc_ckwatch (p + 1, file, line, W_ALLOC, n);
#endif

#if defined (MALLOC_DEBUG)
  z = (char *) (p + 1);
  /* Check alignment of returned pointer */
  if ((unsigned long)z & MALIGN_MASK)
    fprintf (stderr, "malloc: %s:%d: warning: request for %d bytes not aligned on %d byte boundary\r\n",
	file ? file : _("unknown"), line, p->mh_nbytes, MALIGN_MASK+1);
#endif

  return (PTR_T) (p + 1);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\malloc\malloc.c:824
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\malloc\malloc.c:940
parsing error 
{
  register union mhead *p;
  register char *ap, *z;
  register int nunits;
  register unsigned int nbytes;
  int ubytes;		/* caller-requested size */
  mguard_t mg;

  if ((ap = (char *)mem) == 0)
    return;

  p = (union mhead *) ap - 1;

  if (p->mh_alloc == ISMEMALIGN)
    {
      ap -= p->mh_nbytes;
      p = (union mhead *) ap - 1;
    }

#if defined (MALLOC_TRACE) || defined (MALLOC_REGISTER) || defined (MALLOC_WATCH)
  if (malloc_trace || malloc_register || _malloc_nwatch > 0)
    ubytes = p->mh_nbytes;
#endif

  if (p->mh_alloc != ISALLOC)
    {
      if (p->mh_alloc == ISFREE)
	xbotch (mem, ERR_DUPFREE,
		_("free: called with already freed block argument"), file, line);
      else
	xbotch (mem, ERR_UNALLOC,
		_("free: called with unallocated block argument"), file, line);
    }

  ASSERT (p->mh_magic2 == MAGIC2);

  nunits = p->mh_index;
  nbytes = ALLOCATED_BYTES(p->mh_nbytes);
  /* Since the sizeof(u_bits32_t) bytes before the memory handed to the user
     are now used for the number of bytes allocated, a simple check of
     mh_magic2 is no longer sufficient to catch things like p[-1] = 'x'.
     We sanity-check the value of mh_nbytes against the size of the blocks
     in the appropriate bucket before we use it.  This can still cause problems
     and obscure errors if mh_nbytes is wrong but still within range; the
     checks against the size recorded at the end of the chunk will probably
     fail then.  Using MALLOC_REGISTER will help here, since it saves the
     original number of bytes requested. */

  if (IN_BUCKET(nbytes, nunits) == 0)
    xbotch (mem, ERR_UNDERFLOW,
	    _("free: underflow detected; mh_nbytes out of range"), file, line);
#if SIZEOF_CHAR_P == 8
  {
    int i;
    for (i = 0, z = p->mh_magic8; i < 8; i++)
      if (*z++ != MAGIC1)
	xbotch (mem, ERR_UNDERFLOW,
		_("free: underflow detected; magic8 corrupted"), file, line);
  }
#endif

  ap += p->mh_nbytes;
  z = mg.s;
  *z++ = *ap++, *z++ = *ap++, *z++ = *ap++, *z++ = *ap++;  
  if (mg.i != p->mh_nbytes)
    xbotch (mem, ERR_ASSERT_FAILED, _("free: start and end chunk sizes differ"), file, line);

#if defined (USE_MMAP)
  if (nunits > malloc_mmap_threshold)
    {
      munmap (p, binsize (nunits));
#if defined (MALLOC_STATS)
      _mstats.nlesscore[nunits]++;
#endif
      goto free_return;
    }
#endif

#if GLIBC21
  if (nunits >= LESSCORE_MIN && ((char *)p + binsize(nunits) == sbrk (0)))
#else
  if (nunits >= LESSCORE_MIN && ((char *)p + binsize(nunits) == memtop))
#endif
    {
      /* If above LESSCORE_FRC, give back unconditionally.  This should be set
	 high enough to be infrequently encountered.  If between LESSCORE_MIN
	 and LESSCORE_FRC, call lesscore if the bucket is marked as busy or if
	 there's already a block on the free list. */
      if ((nunits >= LESSCORE_FRC) || busy[nunits] || nextf[nunits] != 0)
	{
	  lesscore (nunits);
	  /* keeps the tracing and registering code in one place */
	  goto free_return;
	}
    }

#ifdef MEMSCRAMBLE
  if (p->mh_nbytes)
    MALLOC_MEMSET (mem, 0xcf, p->mh_nbytes);
#endif

  ASSERT (nunits < NBUCKETS);

  if (busy[nunits] == 1)
    {
      xsplit (p, nunits);	/* split block and add to different chain */
      goto free_return;
    }

  p->mh_alloc = ISFREE;
  /* Protect against signal handlers calling malloc.  */
  busy[nunits] = 1;
  /* Put this block on the free list.  */
  CHAIN (p) = nextf[nunits];
  nextf[nunits] = p;
  busy[nunits] = 0;

free_return:
  ;		/* Empty statement in case this is the end of the function */

#ifdef MALLOC_STATS
  _mstats.nmalloc[nunits]--;
  _mstats.nfre++;
#endif /* MALLOC_STATS */

#ifdef MALLOC_TRACE
  if (malloc_trace && (flags & MALLOC_NOTRACE) == 0)
    mtrace_free (mem, ubytes, file, line);
  else if (_malloc_trace_buckets[nunits])
    mtrace_free (mem, ubytes, file, line);
#endif

#ifdef MALLOC_REGISTER
  if (malloc_register && (flags & MALLOC_NOREG) == 0)
    mregister_free (mem, ubytes, file, line);
#endif

#ifdef MALLOC_WATCH
  if (_malloc_nwatch > 0)
    _malloc_ckwatch (mem, file, line, W_FREE, ubytes);
#endif
}
warning: parse error {
  register union mhead *p;
  register char *ap, *z;
  register int nunits;
  register unsigned int nbytes;
  int ubytes;		/* caller-requested size */
  mguard_t mg;

  if ((ap = (char *)mem) == 0)
    return;

  p = (union mhead *) ap - 1;

  if (p->mh_alloc == ISMEMALIGN)
    {
      ap -= p->mh_nbytes;
      p = (union mhead *) ap - 1;
    }

#if defined (MALLOC_TRACE) || defined (MALLOC_REGISTER) || defined (MALLOC_WATCH)
  if (malloc_trace || malloc_register || _malloc_nwatch > 0)
    ubytes = p->mh_nbytes;
#endif

  if (p->mh_alloc != ISALLOC)
    {
      if (p->mh_alloc == ISFREE)
	xbotch (mem, ERR_DUPFREE,
		_("free: called with already freed block argument"), file, line);
      else
	xbotch (mem, ERR_UNALLOC,
		_("free: called with unallocated block argument"), file, line);
    }

  ASSERT (p->mh_magic2 == MAGIC2);

  nunits = p->mh_index;
  nbytes = ALLOCATED_BYTES(p->mh_nbytes);
  /* Since the sizeof(u_bits32_t) bytes before the memory handed to the user
     are now used for the number of bytes allocated, a simple check of
     mh_magic2 is no longer sufficient to catch things like p[-1] = 'x'.
     We sanity-check the value of mh_nbytes against the size of the blocks
     in the appropriate bucket before we use it.  This can still cause problems
     and obscure errors if mh_nbytes is wrong but still within range; the
     checks against the size recorded at the end of the chunk will probably
     fail then.  Using MALLOC_REGISTER will help here, since it saves the
     original number of bytes requested. */

  if (IN_BUCKET(nbytes, nunits) == 0)
    xbotch (mem, ERR_UNDERFLOW,
	    _("free: underflow detected; mh_nbytes out of range"), file, line);
#if SIZEOF_CHAR_P == 8
  {
    int i;
    for (i = 0, z = p->mh_magic8; i < 8; i++)
      if (*z++ != MAGIC1)
	xbotch (mem, ERR_UNDERFLOW,
		_("free: underflow detected; magic8 corrupted"), file, line);
  }
#endif

  ap += p->mh_nbytes;
  z = mg.s;
  *z++ = *ap++, *z++ = *ap++, *z++ = *ap++, *z++ = *ap++;  
  if (mg.i != p->mh_nbytes)
    xbotch (mem, ERR_ASSERT_FAILED, _("free: start and end chunk sizes differ"), file, line);

#if defined (USE_MMAP)
  if (nunits > malloc_mmap_threshold)
    {
      munmap (p, binsize (nunits));
#if defined (MALLOC_STATS)
      _mstats.nlesscore[nunits]++;
#endif
      goto free_return;
    }
#endif

#if GLIBC21
  if (nunits >= LESSCORE_MIN && ((char *)p + binsize(nunits) == sbrk (0)))
#else
  if (nunits >= LESSCORE_MIN && ((char *)p + binsize(nunits) == memtop))
#endif
    {
      /* If above LESSCORE_FRC, give back unconditionally.  This should be set
	 high enough to be infrequently encountered.  If between LESSCORE_MIN
	 and LESSCORE_FRC, call lesscore if the bucket is marked as busy or if
	 there's already a block on the free list. */
      if ((nunits >= LESSCORE_FRC) || busy[nunits] || nextf[nunits] != 0)
	{
	  lesscore (nunits);
	  /* keeps the tracing and registering code in one place */
	  goto free_return;
	}
    }

#ifdef MEMSCRAMBLE
  if (p->mh_nbytes)
    MALLOC_MEMSET (mem, 0xcf, p->mh_nbytes);
#endif

  ASSERT (nunits < NBUCKETS);

  if (busy[nunits] == 1)
    {
      xsplit (p, nunits);	/* split block and add to different chain */
      goto free_return;
    }

  p->mh_alloc = ISFREE;
  /* Protect against signal handlers calling malloc.  */
  busy[nunits] = 1;
  /* Put this block on the free list.  */
  CHAIN (p) = nextf[nunits];
  nextf[nunits] = p;
  busy[nunits] = 0;

free_return:
  ;		/* Empty statement in case this is the end of the function */

#ifdef MALLOC_STATS
  _mstats.nmalloc[nunits]--;
  _mstats.nfre++;
#endif /* MALLOC_STATS */

#ifdef MALLOC_TRACE
  if (malloc_trace && (flags & MALLOC_NOTRACE) == 0)
    mtrace_free (mem, ubytes, file, line);
  else if (_malloc_trace_buckets[nunits])
    mtrace_free (mem, ubytes, file, line);
#endif

#ifdef MALLOC_REGISTER
  if (malloc_register && (flags & MALLOC_NOREG) == 0)
    mregister_free (mem, ubytes, file, line);
#endif

#ifdef MALLOC_WATCH
  if (_malloc_nwatch > 0)
    _malloc_ckwatch (mem, file, line, W_FREE, ubytes);
#endif
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\malloc\malloc.c:944
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\malloc\malloc.c:1,088
parsing error 
{
  register union mhead *p;
  register u_bits32_t tocopy;
  register unsigned int nbytes;
  register int nunits;
  register char *m, *z;
  mguard_t mg;

#ifdef MALLOC_STATS
  _mstats.nrealloc++;
#endif

  if (n == 0)
    {
      internal_free (mem, file, line, MALLOC_INTERNAL);
      return (NULL);
    }
  if ((p = (union mhead *) mem) == 0)
    return internal_malloc (n, file, line, MALLOC_INTERNAL);

  p--;
  nunits = p->mh_index;
  ASSERT (nunits < NBUCKETS);

  if (p->mh_alloc != ISALLOC)
    xbotch (mem, ERR_UNALLOC,
	    _("realloc: called with unallocated block argument"), file, line);

  ASSERT (p->mh_magic2 == MAGIC2);
  nbytes = ALLOCATED_BYTES(p->mh_nbytes);
  /* Since the sizeof(u_bits32_t) bytes before the memory handed to the user
     are now used for the number of bytes allocated, a simple check of
     mh_magic2 is no longer sufficient to catch things like p[-1] = 'x'.
     We sanity-check the value of mh_nbytes against the size of the blocks
     in the appropriate bucket before we use it.  This can still cause problems
     and obscure errors if mh_nbytes is wrong but still within range; the
     checks against the size recorded at the end of the chunk will probably
     fail then.  Using MALLOC_REGISTER will help here, since it saves the
     original number of bytes requested. */
  if (IN_BUCKET(nbytes, nunits) == 0)
    xbotch (mem, ERR_UNDERFLOW,
	    _("realloc: underflow detected; mh_nbytes out of range"), file, line);
#if SIZEOF_CHAR_P == 8
  {
    int i;
    for (i = 0, z = p->mh_magic8; i < 8; i++)
      if (*z++ != MAGIC1)
	xbotch (mem, ERR_UNDERFLOW,
		_("realloc: underflow detected; magic8 corrupted"), file, line);

  }
#endif

  m = (char *)mem + (tocopy = p->mh_nbytes);
  z = mg.s;
  *z++ = *m++, *z++ = *m++, *z++ = *m++, *z++ = *m++;
  if (mg.i != p->mh_nbytes)
    xbotch (mem, ERR_ASSERT_FAILED, _("realloc: start and end chunk sizes differ"), file, line);

#ifdef MALLOC_WATCH
  if (_malloc_nwatch > 0)
    _malloc_ckwatch (p + 1, file, line, W_REALLOC, n);
#endif
#ifdef MALLOC_STATS
  _mstats.bytesreq += (n < tocopy) ? 0 : n - tocopy;
#endif

  /* If we're reallocating to the same size as previously, return now */
  if (n == p->mh_nbytes)
    return mem;

  /* See if desired size rounds to same power of 2 as actual size. */
  nbytes = ALLOCATED_BYTES(n);

  /* If ok, use the same block, just marking its size as changed.  */
  if (RIGHT_BUCKET(nbytes, nunits) || RIGHT_BUCKET(nbytes, nunits-1))
    {
      /* Compensate for increment above. */
      m -= 4;

      *m++ = 0;  *m++ = 0;  *m++ = 0;  *m++ = 0;
      m = (char *)mem + (p->mh_nbytes = n);

      mg.i = n;
      z = mg.s;
      *m++ = *z++, *m++ = *z++, *m++ = *z++, *m++ = *z++;      

      return mem;
    }

  if (n < tocopy)
    tocopy = n;

#ifdef MALLOC_STATS
  _mstats.nrcopy++;
#endif

  /* If we are using mmap and have mremap, we could use it here. */

  if ((m = internal_malloc (n, file, line, MALLOC_INTERNAL|MALLOC_NOTRACE|MALLOC_NOREG)) == 0)
    return 0;
  FASTCOPY (mem, m, tocopy);
  internal_free (mem, file, line, MALLOC_INTERNAL);

#ifdef MALLOC_TRACE
  if (malloc_trace && (flags & MALLOC_NOTRACE) == 0)
    mtrace_alloc ("realloc", m, n, file, line);
  else if (_malloc_trace_buckets[nunits])
    mtrace_alloc ("realloc", m, n, file, line);
#endif

#ifdef MALLOC_REGISTER
  if (malloc_register && (flags & MALLOC_NOREG) == 0)
    mregister_alloc ("realloc", m, n, file, line);
#endif

#ifdef MALLOC_WATCH
  if (_malloc_nwatch > 0)
    _malloc_ckwatch (m, file, line, W_RESIZED, n);
#endif

  return m;
}
warning: parse error {
  register union mhead *p;
  register u_bits32_t tocopy;
  register unsigned int nbytes;
  register int nunits;
  register char *m, *z;
  mguard_t mg;

#ifdef MALLOC_STATS
  _mstats.nrealloc++;
#endif

  if (n == 0)
    {
      internal_free (mem, file, line, MALLOC_INTERNAL);
      return (NULL);
    }
  if ((p = (union mhead *) mem) == 0)
    return internal_malloc (n, file, line, MALLOC_INTERNAL);

  p--;
  nunits = p->mh_index;
  ASSERT (nunits < NBUCKETS);

  if (p->mh_alloc != ISALLOC)
    xbotch (mem, ERR_UNALLOC,
	    _("realloc: called with unallocated block argument"), file, line);

  ASSERT (p->mh_magic2 == MAGIC2);
  nbytes = ALLOCATED_BYTES(p->mh_nbytes);
  /* Since the sizeof(u_bits32_t) bytes before the memory handed to the user
     are now used for the number of bytes allocated, a simple check of
     mh_magic2 is no longer sufficient to catch things like p[-1] = 'x'.
     We sanity-check the value of mh_nbytes against the size of the blocks
     in the appropriate bucket before we use it.  This can still cause problems
     and obscure errors if mh_nbytes is wrong but still within range; the
     checks against the size recorded at the end of the chunk will probably
     fail then.  Using MALLOC_REGISTER will help here, since it saves the
     original number of bytes requested. */
  if (IN_BUCKET(nbytes, nunits) == 0)
    xbotch (mem, ERR_UNDERFLOW,
	    _("realloc: underflow detected; mh_nbytes out of range"), file, line);
#if SIZEOF_CHAR_P == 8
  {
    int i;
    for (i = 0, z = p->mh_magic8; i < 8; i++)
      if (*z++ != MAGIC1)
	xbotch (mem, ERR_UNDERFLOW,
		_("realloc: underflow detected; magic8 corrupted"), file, line);

  }
#endif

  m = (char *)mem + (tocopy = p->mh_nbytes);
  z = mg.s;
  *z++ = *m++, *z++ = *m++, *z++ = *m++, *z++ = *m++;
  if (mg.i != p->mh_nbytes)
    xbotch (mem, ERR_ASSERT_FAILED, _("realloc: start and end chunk sizes differ"), file, line);

#ifdef MALLOC_WATCH
  if (_malloc_nwatch > 0)
    _malloc_ckwatch (p + 1, file, line, W_REALLOC, n);
#endif
#ifdef MALLOC_STATS
  _mstats.bytesreq += (n < tocopy) ? 0 : n - tocopy;
#endif

  /* If we're reallocating to the same size as previously, return now */
  if (n == p->mh_nbytes)
    return mem;

  /* See if desired size rounds to same power of 2 as actual size. */
  nbytes = ALLOCATED_BYTES(n);

  /* If ok, use the same block, just marking its size as changed.  */
  if (RIGHT_BUCKET(nbytes, nunits) || RIGHT_BUCKET(nbytes, nunits-1))
    {
      /* Compensate for increment above. */
      m -= 4;

      *m++ = 0;  *m++ = 0;  *m++ = 0;  *m++ = 0;
      m = (char *)mem + (p->mh_nbytes = n);

      mg.i = n;
      z = mg.s;
      *m++ = *z++, *m++ = *z++, *m++ = *z++, *m++ = *z++;      

      return mem;
    }

  if (n < tocopy)
    tocopy = n;

#ifdef MALLOC_STATS
  _mstats.nrcopy++;
#endif

  /* If we are using mmap and have mremap, we could use it here. */

  if ((m = internal_malloc (n, file, line, MALLOC_INTERNAL|MALLOC_NOTRACE|MALLOC_NOREG)) == 0)
    return 0;
  FASTCOPY (mem, m, tocopy);
  internal_free (mem, file, line, MALLOC_INTERNAL);

#ifdef MALLOC_TRACE
  if (malloc_trace && (flags & MALLOC_NOTRACE) == 0)
    mtrace_alloc ("realloc", m, n, file, line);
  else if (_malloc_trace_buckets[nunits])
    mtrace_alloc ("realloc", m, n, file, line);
#endif

#ifdef MALLOC_REGISTER
  if (malloc_register && (flags & MALLOC_NOREG) == 0)
    mregister_alloc ("realloc", m, n, file, line);
#endif

#ifdef MALLOC_WATCH
  if (_malloc_nwatch > 0)
    _malloc_ckwatch (m, file, line, W_RESIZED, n);
#endif

  return m;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\malloc\malloc.c:1,093
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\malloc\malloc.c:1,218
parsing error 
{
  register char *ptr;
  register char *aligned;
  register union mhead *p;

  ptr = internal_malloc (size + alignment, file, line, MALLOC_INTERNAL);

  if (ptr == 0)
    return 0;
  /* If entire block has the desired alignment, just accept it.  */
  if (((long) ptr & (alignment - 1)) == 0)
    return ptr;
  /* Otherwise, get address of byte in the block that has that alignment.  */
  aligned = (char *) (((long) ptr + alignment - 1) & (~alignment + 1));

  /* Store a suitable indication of how to free the block,
     so that free can find the true beginning of it.  */
  p = (union mhead *) aligned - 1;
  p->mh_nbytes = aligned - ptr;
  p->mh_alloc = ISMEMALIGN;

  return aligned;
}
warning: parse error {
  register char *ptr;
  register char *aligned;
  register union mhead *p;

  ptr = internal_malloc (size + alignment, file, line, MALLOC_INTERNAL);

  if (ptr == 0)
    return 0;
  /* If entire block has the desired alignment, just accept it.  */
  if (((long) ptr & (alignment - 1)) == 0)
    return ptr;
  /* Otherwise, get address of byte in the block that has that alignment.  */
  aligned = (char *) (((long) ptr + alignment - 1) & (~alignment + 1));

  /* Store a suitable indication of how to free the block,
     so that free can find the true beginning of it.  */
  p = (union mhead *) aligned - 1;
  p->mh_nbytes = aligned - ptr;
  p->mh_alloc = ISMEMALIGN;

  return aligned;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\malloc\malloc.c:1,223
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\malloc\malloc.c:1,248
parsing error 
{
  void *mem;

  /* Perform posix-mandated error checking here */
  if ((alignment % sizeof (void *) != 0) || alignment == 0)
    return EINVAL;
  else if (powerof2 (alignment) == 0)
    return EINVAL;

  mem = internal_memalign (alignment, size, (char *)0, 0, 0);
  if (mem != 0)
    {
      *memptr = mem;
      return 0;
    }
  return ENOMEM;
}
warning: parse error {
  void *mem;

  /* Perform posix-mandated error checking here */
  if ((alignment % sizeof (void *) != 0) || alignment == 0)
    return EINVAL;
  else if (powerof2 (alignment) == 0)
    return EINVAL;

  mem = internal_memalign (alignment, size, (char *)0, 0, 0);
  if (mem != 0)
    {
      *memptr = mem;
      return 0;
    }
  return ENOMEM;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\malloc\malloc.c:1,251
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\malloc\malloc.c:1,270
parsing error 
{
  register union mhead *p;
  register char *ap;
  register int maxbytes;


  if ((ap = (char *)mem) == 0)
    return 0;

  /* Find the true start of the memory block to discover which bin */
  p = (union mhead *) ap - 1;
  if (p->mh_alloc == ISMEMALIGN)
    {
      ap -= p->mh_nbytes;
      p = (union mhead *) ap - 1;
    }

  /* XXX - should we return 0 if ISFREE? */
  maxbytes = binsize(p->mh_index);

  /* So the usable size is the maximum number of bytes in the bin less the
     malloc overhead */
  maxbytes -= MOVERHEAD + MSLOP;
  return (maxbytes);
}
warning: parse error {
  register union mhead *p;
  register char *ap;
  register int maxbytes;


  if ((ap = (char *)mem) == 0)
    return 0;

  /* Find the true start of the memory block to discover which bin */
  p = (union mhead *) ap - 1;
  if (p->mh_alloc == ISMEMALIGN)
    {
      ap -= p->mh_nbytes;
      p = (union mhead *) ap - 1;
    }

  /* XXX - should we return 0 if ISFREE? */
  maxbytes = binsize(p->mh_index);

  /* So the usable size is the maximum number of bytes in the bin less the
     malloc overhead */
  maxbytes -= MOVERHEAD + MSLOP;
  return (maxbytes);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\malloc\malloc.c:1,272
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\malloc\malloc.c:1,302
parsing error 
{
  return internal_memalign (getpagesize (), size, file, line, flags|MALLOC_INTERNAL);
}
warning: parse error {
  return internal_memalign (getpagesize (), size, file, line, flags|MALLOC_INTERNAL);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\malloc\malloc.c:1,306
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\malloc\malloc.c:1,313
parsing error 
{
  size_t total;
  PTR_T result;

  total = n * s;
  result = internal_malloc (total, file, line, flags|MALLOC_INTERNAL);
  if (result)
    memset (result, 0, total);
  return result;  
}
warning: parse error {
  size_t total;
  PTR_T result;

  total = n * s;
  result = internal_malloc (total, file, line, flags|MALLOC_INTERNAL);
  if (result)
    memset (result, 0, total);
  return result;  
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\malloc\malloc.c:1,317
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\malloc\malloc.c:1,329
parsing error 
{
  internal_free (p, file, line, flags|MALLOC_INTERNAL);
}
warning: parse error {
  internal_free (p, file, line, flags|MALLOC_INTERNAL);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\malloc\malloc.c:1,333
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\malloc\malloc.c:1,340
parsing error 
{
  int nfree;
  register union mhead *p;

  nfree = 0;
  for (p = nextf[size]; p; p = CHAIN (p))
    nfree++;

  return nfree;
}
warning: parse error {
  int nfree;
  register union mhead *p;

  nfree = 0;
  for (p = nextf[size]; p; p = CHAIN (p))
    nfree++;

  return nfree;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\malloc\malloc.c:1,342
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\malloc\malloc.c:1,356
parsing error 
{
  return internal_malloc (bytes, file, line, MALLOC_WRAPPER);
}
warning: parse error {
  return internal_malloc (bytes, file, line, MALLOC_WRAPPER);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\malloc\malloc.c:1,360
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\malloc\malloc.c:1,365
parsing error 
{
  return internal_realloc (ptr, size, file, line, MALLOC_WRAPPER);
}
warning: parse error {
  return internal_realloc (ptr, size, file, line, MALLOC_WRAPPER);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\malloc\malloc.c:1,370
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\malloc\malloc.c:1,375
parsing error 
{
  internal_free (mem, file, line, MALLOC_WRAPPER);
}
warning: parse error {
  internal_free (mem, file, line, MALLOC_WRAPPER);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\malloc\malloc.c:1,379
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\malloc\malloc.c:1,384
parsing error 
{
  return internal_memalign (alignment, size, file, line, MALLOC_WRAPPER);
}
warning: parse error {
  return internal_memalign (alignment, size, file, line, MALLOC_WRAPPER);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\malloc\malloc.c:1,389
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\malloc\malloc.c:1,395
parsing error 
{
  return internal_calloc (n, s, file, line, MALLOC_WRAPPER);
}
warning: parse error {
  return internal_calloc (n, s, file, line, MALLOC_WRAPPER);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\malloc\malloc.c:1,399
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\malloc\malloc.c:1,404
parsing error 
{
  internal_cfree (mem, file, line, MALLOC_WRAPPER);
}
warning: parse error {
  internal_cfree (mem, file, line, MALLOC_WRAPPER);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\malloc\malloc.c:1,408
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\malloc\malloc.c:1,415
parsing error 
{
  return internal_valloc (size, file, line, MALLOC_WRAPPER);
}
warning: parse error {
  return internal_valloc (size, file, line, MALLOC_WRAPPER);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\malloc\malloc.c:1,419
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\malloc\malloc.c:1,429
parsing error 
{
  return internal_malloc (size, (char *)NULL, 0, 0);
}
warning: parse error {
  return internal_malloc (size, (char *)NULL, 0, 0);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\malloc\malloc.c:1,431
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\malloc\malloc.c:1,436
parsing error 
{
  return internal_realloc (mem, nbytes, (char *)NULL, 0, 0);
}
warning: parse error {
  return internal_realloc (mem, nbytes, (char *)NULL, 0, 0);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\malloc\malloc.c:1,439
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\malloc\malloc.c:1,444
parsing error 
{
  internal_free (mem,  (char *)NULL, 0, 0);
}
warning: parse error {
  internal_free (mem,  (char *)NULL, 0, 0);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\malloc\malloc.c:1,446
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\malloc\malloc.c:1,451
parsing error 
{
  return internal_memalign (alignment, size, (char *)NULL, 0, 0);
}
warning: parse error {
  return internal_memalign (alignment, size, (char *)NULL, 0, 0);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\malloc\malloc.c:1,454
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\malloc\malloc.c:1,460
parsing error 
{
  return internal_valloc (size, (char *)NULL, 0, 0);
}
warning: parse error {
  return internal_valloc (size, (char *)NULL, 0, 0);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\malloc\malloc.c:1,462
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\malloc\malloc.c:1,469
parsing error 
{
  return internal_calloc (n, s, (char *)NULL, 0, 0);
}
warning: parse error {
  return internal_calloc (n, s, (char *)NULL, 0, 0);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\malloc\malloc.c:1,471
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\malloc\malloc.c:1,476
parsing error 
{
  internal_cfree (mem, (char *)NULL, 0, 0);
}
warning: parse error {
  internal_cfree (mem, (char *)NULL, 0, 0);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\malloc\malloc.c:1,478
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\malloc\stats.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\malloc\imalloc.h...skip
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\malloc\mstats.h...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\malloc\imalloc.h...skip
parsing error 
s
warning: parse error sMissing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\malloc\stats.c:45
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\malloc\stats.c:46
parsing error 
{
  struct bucket_stats v;

  v.nfree = 0;

  if (size < 0 || size >= NBUCKETS)
    {
      v.blocksize = 0;
      v.nused = v.nmal = v.nmorecore = v.nlesscore = v.nsplit = 0;
      return v;
    }

  v.blocksize = 1 << (size + 3);
  v.nused = _mstats.nmalloc[size];
  v.nmal = _mstats.tmalloc[size];
  v.nmorecore = _mstats.nmorecore[size];
  v.nlesscore = _mstats.nlesscore[size];
  v.nsplit = _mstats.nsplit[size];
  v.ncoalesce = _mstats.ncoalesce[size];

  v.nfree = malloc_free_blocks (size);	/* call back to malloc.c */

  return v;
}
warning: parse error {
  struct bucket_stats v;

  v.nfree = 0;

  if (size < 0 || size >= NBUCKETS)
    {
      v.blocksize = 0;
      v.nused = v.nmal = v.nmorecore = v.nlesscore = v.nsplit = 0;
      return v;
    }

  v.blocksize = 1 << (size + 3);
  v.nused = _mstats.nmalloc[size];
  v.nmal = _mstats.tmalloc[size];
  v.nmorecore = _mstats.nmorecore[size];
  v.nlesscore = _mstats.nlesscore[size];
  v.nsplit = _mstats.nsplit[size];
  v.ncoalesce = _mstats.ncoalesce[size];

  v.nfree = malloc_free_blocks (size);	/* call back to malloc.c */

  return v;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\malloc\stats.c:48
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\malloc\stats.c:96
parsing error 
{
  register int i;
  unsigned long totused, totfree;
  struct bucket_stats v;

  fprintf (fp, "Memory allocation statistics: %s\n    size\tfree\tin use\ttotal\tmorecore lesscore split\tcoalesce\n", s ? s : "");
  for (i = totused = totfree = 0; i < NBUCKETS; i++)
    {
      v = malloc_bucket_stats (i);
      /* Show where the mmap threshold is; sizes greater than this use mmap to
	 allocate and munmap to free (munmap shows up as lesscore). */
      if (i == malloc_mmap_threshold+1)
	fprintf (fp, "--------\n");
      if (v.nmal > 0)
	fprintf (fp, "%8lu\t%4d\t%6d\t%5d%8d\t%8d %5d %8d\n", (unsigned long)v.blocksize, v.nfree, v.nused, v.nmal, v.nmorecore, v.nlesscore, v.nsplit, v.ncoalesce);
      totfree += v.nfree * v.blocksize;
      totused += v.nused * v.blocksize;
    }
  fprintf (fp, "\nTotal bytes in use: %lu, total bytes free: %lu\n",
	   totused, totfree);
  fprintf (fp, "\nTotal bytes requested by application: %lu\n", (unsigned long)_mstats.bytesreq);
  fprintf (fp, "Total mallocs: %d, total frees: %d, total reallocs: %d (%d copies)\n",
	   _mstats.nmal, _mstats.nfre, _mstats.nrealloc, _mstats.nrcopy);
  fprintf (fp, "Total sbrks: %d, total bytes via sbrk: %d\n",
  	   _mstats.nsbrk, _mstats.tsbrk);
  fprintf (fp, "Total mmaps: %d, total bytes via mmap: %d\n",
  	   _mstats.nmmap, _mstats.tmmap);
  fprintf (fp, "Total blocks split: %d, total block coalesces: %d\n",
  	   _mstats.tbsplit, _mstats.tbcoalesce);
}
warning: parse error {
  register int i;
  unsigned long totused, totfree;
  struct bucket_stats v;

  fprintf (fp, "Memory allocation statistics: %s\n    size\tfree\tin use\ttotal\tmorecore lesscore split\tcoalesce\n", s ? s : "");
  for (i = totused = totfree = 0; i < NBUCKETS; i++)
    {
      v = malloc_bucket_stats (i);
      /* Show where the mmap threshold is; sizes greater than this use mmap to
	 allocate and munmap to free (munmap shows up as lesscore). */
      if (i == malloc_mmap_threshold+1)
	fprintf (fp, "--------\n");
      if (v.nmal > 0)
	fprintf (fp, "%8lu\t%4d\t%6d\t%5d%8d\t%8d %5d %8d\n", (unsigned long)v.blocksize, v.nfree, v.nused, v.nmal, v.nmorecore, v.nlesscore, v.nsplit, v.ncoalesce);
      totfree += v.nfree * v.blocksize;
      totused += v.nused * v.blocksize;
    }
  fprintf (fp, "\nTotal bytes in use: %lu, total bytes free: %lu\n",
	   totused, totfree);
  fprintf (fp, "\nTotal bytes requested by application: %lu\n", (unsigned long)_mstats.bytesreq);
  fprintf (fp, "Total mallocs: %d, total frees: %d, total reallocs: %d (%d copies)\n",
	   _mstats.nmal, _mstats.nfre, _mstats.nrealloc, _mstats.nrcopy);
  fprintf (fp, "Total sbrks: %d, total bytes via sbrk: %d\n",
  	   _mstats.nsbrk, _mstats.tsbrk);
  fprintf (fp, "Total mmaps: %d, total bytes via mmap: %d\n",
  	   _mstats.nmmap, _mstats.tmmap);
  fprintf (fp, "Total blocks split: %d, total block coalesces: %d\n",
  	   _mstats.tbsplit, _mstats.tbcoalesce);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\malloc\stats.c:99
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\malloc\stats.c:131
parsing error 
{
  _print_malloc_stats (s, stderr);
}
warning: parse error {
  _print_malloc_stats (s, stderr);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\malloc\stats.c:133
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\malloc\stats.c:138
parsing error 
{
  _print_malloc_stats (s, fp);
}
warning: parse error {
  _print_malloc_stats (s, fp);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\malloc\stats.c:141
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\malloc\stats.c:148
parsing error 
{
  FILE *fp;
  char defname[sizeof (TRACEROOT) + 64];
  static char mallbuf[1024];

  fp = _imalloc_fopen (s, fn, TRACEROOT, defname, sizeof (defname));
  if (fp)
    {
      setvbuf (fp, mallbuf, _IOFBF, sizeof (mallbuf));
      _print_malloc_stats (s, fp);
      fflush(fp);
      fclose(fp);
    }
}
warning: parse error {
  FILE *fp;
  char defname[sizeof (TRACEROOT) + 64];
  static char mallbuf[1024];

  fp = _imalloc_fopen (s, fn, TRACEROOT, defname, sizeof (defname));
  if (fp)
    {
      setvbuf (fp, mallbuf, _IOFBF, sizeof (mallbuf));
      _print_malloc_stats (s, fp);
      fflush(fp);
      fclose(fp);
    }
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\malloc\stats.c:150
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\malloc\stats.c:169
parsing error 
{
  char fname[1024];
  long l;
  FILE *fp;

  l = (long)getpid ();
  if (fn == 0)
    {
      sprintf (defbuf, "%s%ld", def, l);
      fp = fopen(defbuf, "w");
    }
  else
    {
      char *p, *q, *r;
      char pidbuf[32];
      int sp;

      sprintf (pidbuf, "%ld", l);
      if ((strlen (pidbuf) + strlen (fn) + 2) >= sizeof (fname))
	return ((FILE *)0);
      for (sp = 0, p = fname, q = fn; *q; )
	{
	  if (sp == 0 && *q == '%' && q[1] == 'p')
	    {
	      sp = 1;
	      for (r = pidbuf; *r; )
		*p++ = *r++;
	      q += 2;
	    }
	  else
	    *p++ = *q++;
	}
      *p = '\0';
      fp = fopen (fname, "w");
    }

  return fp;
}
warning: parse error {
  char fname[1024];
  long l;
  FILE *fp;

  l = (long)getpid ();
  if (fn == 0)
    {
      sprintf (defbuf, "%s%ld", def, l);
      fp = fopen(defbuf, "w");
    }
  else
    {
      char *p, *q, *r;
      char pidbuf[32];
      int sp;

      sprintf (pidbuf, "%ld", l);
      if ((strlen (pidbuf) + strlen (fn) + 2) >= sizeof (fname))
	return ((FILE *)0);
      for (sp = 0, p = fname, q = fn; *q; )
	{
	  if (sp == 0 && *q == '%' && q[1] == 'p')
	    {
	      sp = 1;
	      for (r = pidbuf; *r; )
		*p++ = *r++;
	      q += 2;
	    }
	  else
	    *p++ = *q++;
	}
      *p = '\0';
      fp = fopen (fname, "w");
    }

  return fp;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\malloc\stats.c:175
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\malloc\stub.c...
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\malloc\table.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\malloc\imalloc.h...skip
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\malloc\table.h...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\malloc\imalloc.h...skip
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\malloc\table.c:64
parsing error 
{
  unsigned int a, b, c;
  unsigned long x;

  /* set up the internal state */
  a = 0x9e3779b9;	/* the golden ratio; an arbitrary value */
  x = (unsigned long)key;		/* truncation is OK */
  b = x >> 8;
  c = x >> 3;				/* XXX - was >> 4 */

  HASH_MIX(a, b, c);
  return c;
}
warning: parse error {
  unsigned int a, b, c;
  unsigned long x;

  /* set up the internal state */
  a = 0x9e3779b9;	/* the golden ratio; an arbitrary value */
  x = (unsigned long)key;		/* truncation is OK */
  b = x >> 8;
  c = x >> 3;				/* XXX - was >> 4 */

  HASH_MIX(a, b, c);
  return c;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\malloc\table.c:65
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\malloc\table.c:98
parsing error 
{
  unsigned int bucket;
  register mr_table_t *tp;
  mr_table_t *endp;

  if (mem_overflow.mem == mem)
    return (&mem_overflow);

  /* If we want to insert an allocation entry just use the next slot */
  if (flags & FIND_ALLOC)
    {
      table_bucket_index = next_bucket();
      table_count++;
      tp = mem_table + table_bucket_index;
      memset(tp, 0, sizeof (mr_table_t));	/* overwrite next existing entry */
      return tp;
    }
    
  tp = endp = mem_table + table_bucket_index;

  /* search for last allocation corresponding to MEM, return entry pointer */
  while (1)
    {
      if (tp->mem == mem)
	return (tp);

      tp = prev_entry (tp);

      /* if we went all the way around and didn't find it, return NULL */
      if (tp == endp)
        return ((mr_table_t *)NULL);
    }

  return (mr_table_t *)NULL;
}
warning: parse error {
  unsigned int bucket;
  register mr_table_t *tp;
  mr_table_t *endp;

  if (mem_overflow.mem == mem)
    return (&mem_overflow);

  /* If we want to insert an allocation entry just use the next slot */
  if (flags & FIND_ALLOC)
    {
      table_bucket_index = next_bucket();
      table_count++;
      tp = mem_table + table_bucket_index;
      memset(tp, 0, sizeof (mr_table_t));	/* overwrite next existing entry */
      return tp;
    }
    
  tp = endp = mem_table + table_bucket_index;

  /* search for last allocation corresponding to MEM, return entry pointer */
  while (1)
    {
      if (tp->mem == mem)
	return (tp);

      tp = prev_entry (tp);

      /* if we went all the way around and didn't find it, return NULL */
      if (tp == endp)
        return ((mr_table_t *)NULL);
    }

  return (mr_table_t *)NULL;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\malloc\table.c:101
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\malloc\table.c:138
parsing error 
{
  return (find_entry (mem, FIND_EXIST));
}
warning: parse error {
  return (find_entry (mem, FIND_EXIST));
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\malloc\table.c:140
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\malloc\table.c:145
parsing error 
{
  mr_table_t *entry;

  entry = find_entry (mem, FIND_EXIST);
  if (entry == 0)
    return;
  fprintf (fp, "malloc: %p: %s: last %s from %s:%d\n",
  		mem,
		(entry->flags & MT_ALLOC) ? "allocated" : "free",
		(entry->flags & MT_ALLOC) ? "allocated" : "freed",
		entry->file ? entry->file : "unknown",
		entry->line);
}
warning: parse error {
  mr_table_t *entry;

  entry = find_entry (mem, FIND_EXIST);
  if (entry == 0)
    return;
  fprintf (fp, "malloc: %p: %s: last %s from %s:%d\n",
  		mem,
		(entry->flags & MT_ALLOC) ? "allocated" : "free",
		(entry->flags & MT_ALLOC) ? "allocated" : "freed",
		entry->file ? entry->file : "unknown",
		entry->line);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\malloc\table.c:148
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\malloc\table.c:164
parsing error 
{
  mr_table_t *tentry;
  sigset_t set, oset;
  int blocked_sigs;

  /* Block all signals in case we are executed from a signal handler. */
  blocked_sigs = 0;
#ifdef SHELL
  if (running_trap || signal_is_trapped (SIGINT) || signal_is_trapped (SIGCHLD))
#endif
    {
      _malloc_block_signals (&set, &oset);
      blocked_sigs = 1;
    }

  mlocation_register_alloc (file, line);

  tentry = find_entry (mem, FIND_ALLOC);

  if (tentry == 0)
    {
      /* oops.  table is full.  punt. */
      fprintf (stderr, _("register_alloc: alloc table is full with FIND_ALLOC?\n"));
      if (blocked_sigs)
	_malloc_unblock_signals (&set, &oset);
      return;
    }
  
  if (tentry->flags & MT_ALLOC)
    {
      /* oops.  bad bookkeeping. ignore for now */
      fprintf (stderr, _("register_alloc: %p already in table as allocated?\n"), mem);
    }

  tentry->mem = mem;
  tentry->size = size;
  tentry->func = tag;
  tentry->flags = MT_ALLOC;
  tentry->file = file;
  tentry->line = line;
  tentry->nalloc++;

  if (tentry != &mem_overflow)
    table_allocated++;

  if (blocked_sigs)
    _malloc_unblock_signals (&set, &oset);
}
warning: parse error {
  mr_table_t *tentry;
  sigset_t set, oset;
  int blocked_sigs;

  /* Block all signals in case we are executed from a signal handler. */
  blocked_sigs = 0;
#ifdef SHELL
  if (running_trap || signal_is_trapped (SIGINT) || signal_is_trapped (SIGCHLD))
#endif
    {
      _malloc_block_signals (&set, &oset);
      blocked_sigs = 1;
    }

  mlocation_register_alloc (file, line);

  tentry = find_entry (mem, FIND_ALLOC);

  if (tentry == 0)
    {
      /* oops.  table is full.  punt. */
      fprintf (stderr, _("register_alloc: alloc table is full with FIND_ALLOC?\n"));
      if (blocked_sigs)
	_malloc_unblock_signals (&set, &oset);
      return;
    }
  
  if (tentry->flags & MT_ALLOC)
    {
      /* oops.  bad bookkeeping. ignore for now */
      fprintf (stderr, _("register_alloc: %p already in table as allocated?\n"), mem);
    }

  tentry->mem = mem;
  tentry->size = size;
  tentry->func = tag;
  tentry->flags = MT_ALLOC;
  tentry->file = file;
  tentry->line = line;
  tentry->nalloc++;

  if (tentry != &mem_overflow)
    table_allocated++;

  if (blocked_sigs)
    _malloc_unblock_signals (&set, &oset);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\malloc\table.c:169
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\malloc\table.c:219
parsing error 
{
  mr_table_t *tentry;
  sigset_t set, oset;
  int blocked_sigs;

  /* Block all signals in case we are executed from a signal handler. */
  blocked_sigs = 0;
#ifdef SHELL
  if (running_trap || signal_is_trapped (SIGINT) || signal_is_trapped (SIGCHLD))
#endif
    {
      _malloc_block_signals (&set, &oset);
      blocked_sigs = 1;
    }

  tentry = find_entry (mem, FIND_EXIST);
  if (tentry == 0)
    {
      /* oops.  not found. */
#if 0
      fprintf (stderr, "register_free: %p not in allocation table?\n", mem);
#endif
      if (blocked_sigs)
	_malloc_unblock_signals (&set, &oset);
      return;
    }
  if (tentry->flags & MT_FREE)
    {
      /* oops.  bad bookkeeping. ignore for now */
      fprintf (stderr, _("register_free: %p already in table as free?\n"), mem);
    }
    	
  tentry->flags = MT_FREE;
  tentry->func = "free";
  tentry->file = file;
  tentry->line = line;
  tentry->nfree++;

  if (tentry != &mem_overflow)
    table_allocated--;

  if (blocked_sigs)
    _malloc_unblock_signals (&set, &oset);
}
warning: parse error {
  mr_table_t *tentry;
  sigset_t set, oset;
  int blocked_sigs;

  /* Block all signals in case we are executed from a signal handler. */
  blocked_sigs = 0;
#ifdef SHELL
  if (running_trap || signal_is_trapped (SIGINT) || signal_is_trapped (SIGCHLD))
#endif
    {
      _malloc_block_signals (&set, &oset);
      blocked_sigs = 1;
    }

  tentry = find_entry (mem, FIND_EXIST);
  if (tentry == 0)
    {
      /* oops.  not found. */
#if 0
      fprintf (stderr, "register_free: %p not in allocation table?\n", mem);
#endif
      if (blocked_sigs)
	_malloc_unblock_signals (&set, &oset);
      return;
    }
  if (tentry->flags & MT_FREE)
    {
      /* oops.  bad bookkeeping. ignore for now */
      fprintf (stderr, _("register_free: %p already in table as free?\n"), mem);
    }
    	
  tentry->flags = MT_FREE;
  tentry->func = "free";
  tentry->file = file;
  tentry->line = line;
  tentry->nfree++;

  if (tentry != &mem_overflow)
    table_allocated--;

  if (blocked_sigs)
    _malloc_unblock_signals (&set, &oset);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\malloc\table.c:224
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\malloc\table.c:271
parsing error 
{
  if (x & MT_FREE)
    return "free";
  else if (x & MT_ALLOC)
    return "allocated";
  else
    return "undetermined?";
}
warning: parse error {
  if (x & MT_FREE)
    return "free";
  else if (x & MT_ALLOC)
    return "allocated";
  else
    return "undetermined?";
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\malloc\table.c:273
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\malloc\table.c:283
parsing error 
{
  register int i;
  mr_table_t entry;

  for (i = 0; i < REG_TABLE_SIZE; i++)
    {
      entry = mem_table[i];
      if (entry.mem)
	fprintf (fp, "%s[%d] %p:%zu:%s:%s:%s:%d:%d:%d\n",
						(i == table_bucket_index) ? "*" : "",
						i,
						entry.mem, entry.size,
						_entry_flags(entry.flags),
						entry.func ? entry.func : "unknown",
						entry.file ? entry.file : "unknown",
						entry.line,
						entry.nalloc, entry.nfree);
    }
}
warning: parse error {
  register int i;
  mr_table_t entry;

  for (i = 0; i < REG_TABLE_SIZE; i++)
    {
      entry = mem_table[i];
      if (entry.mem)
	fprintf (fp, "%s[%d] %p:%zu:%s:%s:%s:%d:%d:%d\n",
						(i == table_bucket_index) ? "*" : "",
						i,
						entry.mem, entry.size,
						_entry_flags(entry.flags),
						entry.func ? entry.func : "unknown",
						entry.file ? entry.file : "unknown",
						entry.line,
						entry.nalloc, entry.nfree);
    }
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\malloc\table.c:285
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\malloc\table.c:323
parsing error 
{
  register ma_table_t *tp, *endp;

  endp = mlocation_table + location_table_count;
  for (tp = mlocation_table; tp <= endp; tp++)
    {
      if (tp->line == line && STREQ (file, tp->file))
        return tp;
    }
  return (ma_table_t *)NULL;
}
warning: parse error {
  register ma_table_t *tp, *endp;

  endp = mlocation_table + location_table_count;
  for (tp = mlocation_table; tp <= endp; tp++)
    {
      if (tp->line == line && STREQ (file, tp->file))
        return tp;
    }
  return (ma_table_t *)NULL;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\malloc\table.c:325
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\malloc\table.c:339
parsing error 
{
  ma_table_t *lentry;
  const char *nfile;

  if (file == 0)
    {
      mlocation_table[0].nalloc++;
      return;
    }

  nfile = strrchr (file, '/');
  if (nfile)
    nfile++;
  else
    nfile = file;

  lentry = find_location_entry (nfile, line);
  if (lentry == 0)
    {
      location_table_index++;
      if (location_table_index == REG_TABLE_SIZE)
        location_table_index = 1;	/* slot 0 reserved */
      lentry = mlocation_table + location_table_index;
      lentry->file = nfile;
      lentry->line = line;
      lentry->nalloc = 1;
      if (location_table_count < REG_TABLE_SIZE)
	location_table_count++;		/* clamp at REG_TABLE_SIZE for now */
    }
  else
    lentry->nalloc++;
}
warning: parse error {
  ma_table_t *lentry;
  const char *nfile;

  if (file == 0)
    {
      mlocation_table[0].nalloc++;
      return;
    }

  nfile = strrchr (file, '/');
  if (nfile)
    nfile++;
  else
    nfile = file;

  lentry = find_location_entry (nfile, line);
  if (lentry == 0)
    {
      location_table_index++;
      if (location_table_index == REG_TABLE_SIZE)
        location_table_index = 1;	/* slot 0 reserved */
      lentry = mlocation_table + location_table_index;
      lentry->file = nfile;
      lentry->line = line;
      lentry->nalloc = 1;
      if (location_table_count < REG_TABLE_SIZE)
	location_table_count++;		/* clamp at REG_TABLE_SIZE for now */
    }
  else
    lentry->nalloc++;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\malloc\table.c:341
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\malloc\table.c:375
parsing error 
{
  register ma_table_t *tp, *endp;

  endp = mlocation_table + location_table_count;
  for (tp = mlocation_table; tp < endp; tp++)
    fprintf (fp, "%s:%d\t%d\n", tp->file ? tp->file : "unknown",
				tp->line ? tp->line : 0,
				tp->nalloc);
}
warning: parse error {
  register ma_table_t *tp, *endp;

  endp = mlocation_table + location_table_count;
  for (tp = mlocation_table; tp < endp; tp++)
    fprintf (fp, "%s:%d\t%d\n", tp->file ? tp->file : "unknown",
				tp->line ? tp->line : 0,
				tp->nalloc);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\malloc\table.c:377
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\malloc\table.c:421
parsing error 
{
  int old;

  old = malloc_register;
  malloc_register = n;
  return old;
}
warning: parse error {
  int old;

  old = malloc_register;
  malloc_register = n;
  return old;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\malloc\table.c:423
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\malloc\trace.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\malloc\imalloc.h...skip
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\malloc\trace.c:45
parsing error 
{
  if (_mtrace_fp == NULL)
    _mtrace_fp = stderr;

  if (_mtrace_verbose)
    fprintf (_mtrace_fp, "alloc: %s: %p (%zu bytes) from '%s:%d'\n",
		tag, mem, size, file ? file : "unknown", line);
  else
    fprintf (_mtrace_fp, "alloc:%p:%zu:%s:%d\n",
		mem, size, file ? file : "unknown", line);
}
warning: parse error {
  if (_mtrace_fp == NULL)
    _mtrace_fp = stderr;

  if (_mtrace_verbose)
    fprintf (_mtrace_fp, "alloc: %s: %p (%zu bytes) from '%s:%d'\n",
		tag, mem, size, file ? file : "unknown", line);
  else
    fprintf (_mtrace_fp, "alloc:%p:%zu:%s:%d\n",
		mem, size, file ? file : "unknown", line);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\malloc\trace.c:50
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\malloc\trace.c:63
parsing error 
{
  if (_mtrace_fp == NULL)
    _mtrace_fp = stderr;

  if (_mtrace_verbose)
    fprintf (_mtrace_fp, "free: %p (%d bytes) from '%s:%d'\n",
		mem, size, file ? file : "unknown", line);
  else
    fprintf (_mtrace_fp, "free:%p:%d:%s:%d\n",
		mem, size, file ? file : "unknown", line);
}
warning: parse error {
  if (_mtrace_fp == NULL)
    _mtrace_fp = stderr;

  if (_mtrace_verbose)
    fprintf (_mtrace_fp, "free: %p (%d bytes) from '%s:%d'\n",
		mem, size, file ? file : "unknown", line);
  else
    fprintf (_mtrace_fp, "free:%p:%d:%s:%d\n",
		mem, size, file ? file : "unknown", line);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\malloc\trace.c:68
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\malloc\trace.c:82
parsing error 
{
  int old;

  old = malloc_trace;
  malloc_trace = n;
  _mtrace_verbose = (n > 1);
  return old;
}
warning: parse error {
  int old;

  old = malloc_trace;
  malloc_trace = n;
  _mtrace_verbose = (n > 1);
  return old;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\malloc\trace.c:84
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\malloc\trace.c:94
parsing error 
{
#ifdef MALLOC_TRACE
  _mtrace_fp = fp ? fp : stderr;
#endif
}
warning: parse error {
#ifdef MALLOC_TRACE
  _mtrace_fp = fp ? fp : stderr;
#endif
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\malloc\trace.c:96
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\malloc\trace.c:103
parsing error 
{
#ifdef MALLOC_TRACE
  _malloc_trace_buckets[n] = 1;
#endif
}
warning: parse error {
#ifdef MALLOC_TRACE
  _malloc_trace_buckets[n] = 1;
#endif
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\malloc\trace.c:105
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\malloc\trace.c:114
parsing error 
{
#ifdef MALLOC_TRACE
  FILE *fp;
  char defname[sizeof (TRACEROOT) + 64];

  fp = _imalloc_fopen (s, fn, TRACEROOT, defname, sizeof (defname));
  if (fp)
    malloc_set_tracefp (fp);
#endif
}
warning: parse error {
#ifdef MALLOC_TRACE
  FILE *fp;
  char defname[sizeof (TRACEROOT) + 64];

  fp = _imalloc_fopen (s, fn, TRACEROOT, defname, sizeof (defname));
  if (fp)
    malloc_set_tracefp (fp);
#endif
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\malloc\trace.c:117
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\malloc\watch.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\malloc\imalloc.h...skip
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\malloc\watch.h...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\malloc\imalloc.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\malloc\watch.c:38
parsing error 
{
  char *tag;

  if (type == W_ALLOC)
    tag = "allocated";
  else if (type == W_FREE)
    tag = "freed";
  else if (type == W_REALLOC)
    tag = "requesting resize";
  else if (type == W_RESIZED)
    tag = "just resized";
  else
    tag = "bug: unknown operation";

  fprintf (stderr, "malloc: watch alert: %p %s ", addr, tag);
  if (data != (unsigned long)-1)
    fprintf (stderr, "(size %lu) ", data);
  fprintf (stderr, "from '%s:%d'\n", file ? file : "unknown", line);
}
warning: parse error {
  char *tag;

  if (type == W_ALLOC)
    tag = "allocated";
  else if (type == W_FREE)
    tag = "freed";
  else if (type == W_REALLOC)
    tag = "requesting resize";
  else if (type == W_RESIZED)
    tag = "just resized";
  else
    tag = "bug: unknown operation";

  fprintf (stderr, "malloc: watch alert: %p %s ", addr, tag);
  if (data != (unsigned long)-1)
    fprintf (stderr, "(size %lu) ", data);
  fprintf (stderr, "from '%s:%d'\n", file ? file : "unknown", line);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\malloc\watch.c:43
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\malloc\watch.c:64
parsing error 
{
  register int i;

  for (i = _malloc_nwatch - 1; i >= 0; i--)
    {
      if (_malloc_watch_list[i] == addr)
	{
	  watch_warn (addr, file, line, type, data);
	  return;
	}
    }
}
warning: parse error {
  register int i;

  for (i = _malloc_nwatch - 1; i >= 0; i--)
    {
      if (_malloc_watch_list[i] == addr)
	{
	  watch_warn (addr, file, line, type, data);
	  return;
	}
    }
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\malloc\watch.c:69
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\malloc\watch.c:84
parsing error 
{
  register int i;
  PTR_T ret;

  if (addr == 0)
    return addr;
  ret = (PTR_T)0;

#ifdef MALLOC_WATCH
  for (i = _malloc_nwatch - 1; i >= 0; i--)
    {
      if (_malloc_watch_list[i] == addr)
        break;
    }
  if (i < 0)
    {
      if (_malloc_nwatch == WATCH_MAX)	/* full, take out first */
	{
	  ret = _malloc_watch_list[0];
	  _malloc_nwatch--;
	  for (i = 0; i < _malloc_nwatch; i++)
	    _malloc_watch_list[i] = _malloc_watch_list[i+1];
	}
      _malloc_watch_list[_malloc_nwatch++] = addr;
    }
#endif

  return ret;  
}
warning: parse error {
  register int i;
  PTR_T ret;

  if (addr == 0)
    return addr;
  ret = (PTR_T)0;

#ifdef MALLOC_WATCH
  for (i = _malloc_nwatch - 1; i >= 0; i--)
    {
      if (_malloc_watch_list[i] == addr)
        break;
    }
  if (i < 0)
    {
      if (_malloc_nwatch == WATCH_MAX)	/* full, take out first */
	{
	  ret = _malloc_watch_list[0];
	  _malloc_nwatch--;
	  for (i = 0; i < _malloc_nwatch; i++)
	    _malloc_watch_list[i] = _malloc_watch_list[i+1];
	}
      _malloc_watch_list[_malloc_nwatch++] = addr;
    }
#endif

  return ret;  
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\malloc\watch.c:86
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\malloc\watch.c:120
parsing error 
{
#ifdef MALLOC_WATCH
  register int i;

  if (addr == 0)
    {
      for (i = 0; i < _malloc_nwatch; i++)
        _malloc_watch_list[i] = (PTR_T)0;
      _malloc_nwatch = 0;
      return ((PTR_T)0);
    }
  else
    {
      for (i = 0; i < _malloc_nwatch; i++)
	{
	  if (_malloc_watch_list[i] == addr)
	    break;
	}
      if (i == _malloc_nwatch)
        return ((PTR_T)0);		/* not found */
      /* shuffle everything from i+1 to end down 1 */
      _malloc_nwatch--;
      for ( ; i < _malloc_nwatch; i++)
        _malloc_watch_list[i] = _malloc_watch_list[i+1];
      return addr;
    }
#else
  return ((PTR_T)0);
#endif
}
warning: parse error {
#ifdef MALLOC_WATCH
  register int i;

  if (addr == 0)
    {
      for (i = 0; i < _malloc_nwatch; i++)
        _malloc_watch_list[i] = (PTR_T)0;
      _malloc_nwatch = 0;
      return ((PTR_T)0);
    }
  else
    {
      for (i = 0; i < _malloc_nwatch; i++)
	{
	  if (_malloc_watch_list[i] == addr)
	    break;
	}
      if (i == _malloc_nwatch)
        return ((PTR_T)0);		/* not found */
      /* shuffle everything from i+1 to end down 1 */
      _malloc_nwatch--;
      for ( ; i < _malloc_nwatch; i++)
        _malloc_watch_list[i] = _malloc_watch_list[i+1];
      return addr;
    }
#else
  return ((PTR_T)0);
#endif
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\malloc\watch.c:122
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\malloc\xmalloc.c...
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\malloc\xmalloc.c:52
parsing error 
{
  fprintf (stderr, "%s: out of virtual memory\n", fname);
  exit (2);
}
warning: parse error {
  fprintf (stderr, "%s: out of virtual memory\n", fname);
  exit (2);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\malloc\xmalloc.c:54
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\malloc\xmalloc.c:63
parsing error 
{
  PTR_T temp;

  temp = malloc (bytes);
  if (temp == 0)
    memory_error_and_abort ("xmalloc");
  return (temp);
}
warning: parse error {
  PTR_T temp;

  temp = malloc (bytes);
  if (temp == 0)
    memory_error_and_abort ("xmalloc");
  return (temp);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\malloc\xmalloc.c:65
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\malloc\xmalloc.c:75
parsing error 
{
  PTR_T temp;

  temp = pointer ? realloc (pointer, bytes) : malloc (bytes);

  if (temp == 0)
    memory_error_and_abort ("xrealloc");
  return (temp);
}
warning: parse error {
  PTR_T temp;

  temp = pointer ? realloc (pointer, bytes) : malloc (bytes);

  if (temp == 0)
    memory_error_and_abort ("xrealloc");
  return (temp);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\malloc\xmalloc.c:78
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\malloc\xmalloc.c:89
parsing error 
{
  if (string)
    free (string);
}
warning: parse error {
  if (string)
    free (string);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\malloc\xmalloc.c:91
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\bind.c...
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\posixstat.h...
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\rldefs.h...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\rlstdc.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\rlconf.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\history.h...skip
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\rlprivate.h...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\rlconf.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\rlstdc.h...skip
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\posixjmp.h...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\rlmbutil.h...skip
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\rlshell.h...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\rlstdc.h...skip
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\xmalloc.h...
parsing error 
extern PTR_T xmalloc PARAMS((size_t));
warning: parse error extern PTR_T xmalloc PARAMS((size_t));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\xmalloc.h:50
parsing error 
extern PTR_T xrealloc PARAMS((void *, size_t));
warning: parse error extern PTR_T xrealloc PARAMS((void *, size_t));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\xmalloc.h:51
parsing error 
extern void xfree PARAMS((void *));
warning: parse error extern void xfree PARAMS((void *));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\xmalloc.h:52
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\bind.c:1,092
parsing error 
{
  int i, peekc, op;

  if (OPSTART (s[*indp]) == 0)
    return -1;
  i = *indp;
  peekc = s[i] ? s[i+1] : 0;
  op = -1;

  if (s[i] == '=')
    {
      op = OP_EQ;
      if (peekc == '=')
        i++;
      i++;
    }
  else if (s[i] == '!' && peekc == '=')
    {
      op = OP_NE;
      i += 2;
    }
  else if (s[i] == '<' && peekc == '=')
    {
      op = OP_LE;
      i += 2;
    }
  else if (s[i] == '>' && peekc == '=')
    {
      op = OP_GE;
      i += 2;
    }
  else if (s[i] == '<')
    {
      op = OP_LT;
      i += 1;
    }
  else if (s[i] == '>')
    {
      op = OP_GT;
      i += 1;
    }

  *indp = i;
  return op;        
}
warning: parse error {
  int i, peekc, op;

  if (OPSTART (s[*indp]) == 0)
    return -1;
  i = *indp;
  peekc = s[i] ? s[i+1] : 0;
  op = -1;

  if (s[i] == '=')
    {
      op = OP_EQ;
      if (peekc == '=')
        i++;
      i++;
    }
  else if (s[i] == '!' && peekc == '=')
    {
      op = OP_NE;
      i += 2;
    }
  else if (s[i] == '<' && peekc == '=')
    {
      op = OP_LE;
      i += 2;
    }
  else if (s[i] == '>' && peekc == '=')
    {
      op = OP_GE;
      i += 2;
    }
  else if (s[i] == '<')
    {
      op = OP_LT;
      i += 1;
    }
  else if (s[i] == '>')
    {
      op = OP_GT;
      i += 1;
    }

  *indp = i;
  return op;        
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\bind.c:1,094
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\callback.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\rlconf.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\rldefs.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\rlprivate.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\xmalloc.h...skip
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\colors.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\rlconf.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\posixstat.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\rldefs.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\xmalloc.h...skip
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\colors.h...
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\compat.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\rlstdc.h...skip
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\rltypedefs.h...
parsing error 
typedef int rl_command_func_t PARAMS((int, int));
warning: parse error typedef int rl_command_func_t PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\rltypedefs.h:63
parsing error 
typedef char *rl_compentry_func_t PARAMS((const char *, int));
warning: parse error typedef char *rl_compentry_func_t PARAMS((const char *, int));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\rltypedefs.h:66
parsing error 
typedef char **rl_completion_func_t PARAMS((const char *, int, int));
warning: parse error typedef char **rl_completion_func_t PARAMS((const char *, int, int));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\rltypedefs.h:67
parsing error 
typedef char *rl_quote_func_t PARAMS((char *, int, char *));
warning: parse error typedef char *rl_quote_func_t PARAMS((char *, int, char *));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\rltypedefs.h:69
parsing error 
typedef char *rl_dequote_func_t PARAMS((char *, int));
warning: parse error typedef char *rl_dequote_func_t PARAMS((char *, int));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\rltypedefs.h:70
parsing error 
typedef int rl_compignore_func_t PARAMS((char **));
warning: parse error typedef int rl_compignore_func_t PARAMS((char **));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\rltypedefs.h:72
parsing error 
typedef void rl_compdisp_func_t PARAMS((char **, int, int));
warning: parse error typedef void rl_compdisp_func_t PARAMS((char **, int, int));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\rltypedefs.h:74
parsing error 
typedef int rl_hook_func_t PARAMS((void));
warning: parse error typedef int rl_hook_func_t PARAMS((void));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\rltypedefs.h:77
parsing error 
typedef int rl_getc_func_t PARAMS((FILE *));
warning: parse error typedef int rl_getc_func_t PARAMS((FILE *));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\rltypedefs.h:80
parsing error 
typedef int rl_linebuf_func_t PARAMS((char *, int));
warning: parse error typedef int rl_linebuf_func_t PARAMS((char *, int));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\rltypedefs.h:85
parsing error 
typedef int rl_intfunc_t PARAMS((int));
warning: parse error typedef int rl_intfunc_t PARAMS((int));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\rltypedefs.h:88
parsing error 
typedef int rl_icpfunc_t PARAMS((char *));
warning: parse error typedef int rl_icpfunc_t PARAMS((char *));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\rltypedefs.h:90
parsing error 
typedef int rl_icppfunc_t PARAMS((char **));
warning: parse error typedef int rl_icppfunc_t PARAMS((char **));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\rltypedefs.h:91
parsing error 
typedef void rl_voidfunc_t PARAMS((void));
warning: parse error typedef void rl_voidfunc_t PARAMS((void));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\rltypedefs.h:93
parsing error 
typedef void rl_vintfunc_t PARAMS((int));
warning: parse error typedef void rl_vintfunc_t PARAMS((int));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\rltypedefs.h:94
parsing error 
typedef void rl_vcpfunc_t PARAMS((char *));
warning: parse error typedef void rl_vcpfunc_t PARAMS((char *));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\rltypedefs.h:95
parsing error 
typedef void rl_vcppfunc_t PARAMS((char **));
warning: parse error typedef void rl_vcppfunc_t PARAMS((char **));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\rltypedefs.h:96
parsing error 
typedef char *rl_cpvfunc_t PARAMS((void));
warning: parse error typedef char *rl_cpvfunc_t PARAMS((void));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\rltypedefs.h:98
parsing error 
typedef char *rl_cpifunc_t PARAMS((int));
warning: parse error typedef char *rl_cpifunc_t PARAMS((int));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\rltypedefs.h:99
parsing error 
typedef char *rl_cpcpfunc_t PARAMS((char  *));
warning: parse error typedef char *rl_cpcpfunc_t PARAMS((char  *));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\rltypedefs.h:100
parsing error 
typedef char *rl_cpcppfunc_t PARAMS((char  **));
warning: parse error typedef char *rl_cpcppfunc_t PARAMS((char  **));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\rltypedefs.h:101
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\complete.c...
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\posixdir.h...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\posixstat.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\rldefs.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\rlmbutil.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\xmalloc.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\rlprivate.h...skip
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\display.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\posixstat.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\rldefs.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\rlmbutil.h...skip
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\tcap.h...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\history.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\rlprivate.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\xmalloc.h...skip
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\emacs_keymap.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h...skip
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\examples\excallback.c...
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\examples\fileman.c...
parsing error 
extern char *xmalloc PARAMS((size_t));
warning: parse error extern char *xmalloc PARAMS((size_t));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\examples\fileman.c:64
parsing error 
void initialize_readline PARAMS((void));
warning: parse error void initialize_readline PARAMS((void));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\examples\fileman.c:66
parsing error 
void too_dangerous PARAMS((char *));
warning: parse error void too_dangerous PARAMS((char *));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\examples\fileman.c:67
parsing error 
int execute_line PARAMS((char *));
warning: parse error int execute_line PARAMS((char *));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\examples\fileman.c:69
parsing error 
int valid_argument PARAMS((char *, char *));
warning: parse error int valid_argument PARAMS((char *, char *));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\examples\fileman.c:70
parsing error 
int com_list PARAMS((char *));
warning: parse error int com_list PARAMS((char *));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\examples\fileman.c:73
parsing error 
int com_view PARAMS((char *));
warning: parse error int com_view PARAMS((char *));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\examples\fileman.c:74
parsing error 
int com_rename PARAMS((char *));
warning: parse error int com_rename PARAMS((char *));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\examples\fileman.c:75
parsing error 
int com_stat PARAMS((char *));
warning: parse error int com_stat PARAMS((char *));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\examples\fileman.c:76
parsing error 
int com_pwd PARAMS((char *));
warning: parse error int com_pwd PARAMS((char *));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\examples\fileman.c:77
parsing error 
int com_delete PARAMS((char *));
warning: parse error int com_delete PARAMS((char *));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\examples\fileman.c:78
parsing error 
int com_help PARAMS((char *));
warning: parse error int com_help PARAMS((char *));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\examples\fileman.c:79
parsing error 
int com_cd PARAMS((char *));
warning: parse error int com_cd PARAMS((char *));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\examples\fileman.c:80
parsing error 
int com_quit PARAMS((char *));
warning: parse error int com_quit PARAMS((char *));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\examples\fileman.c:81
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\examples\fileman.c:118
parsing error 
{
  char *r;

  r = xmalloc (strlen (s) + 1);
  strcpy (r, s);
  return (r);
}
warning: parse error {
  char *r;

  r = xmalloc (strlen (s) + 1);
  strcpy (r, s);
  return (r);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\examples\fileman.c:120
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\examples\fileman.c:129
parsing error 
{
  char *line, *s;

  progname = argv[0];

  initialize_readline ();	/* Bind our completer. */

  /* Loop reading and executing lines until the user quits. */
  for ( ; done == 0; )
    {
      line = readline ("FileMan: ");

      if (!line)
        break;

      /* Remove leading and trailing whitespace from the line.
         Then, if there is anything left, add it to the history list
         and execute it. */
      s = stripwhite (line);

      if (*s)
        {
          add_history (s);
          execute_line (s);
        }

      free (line);
    }
  exit (0);
}
warning: parse error {
  char *line, *s;

  progname = argv[0];

  initialize_readline ();	/* Bind our completer. */

  /* Loop reading and executing lines until the user quits. */
  for ( ; done == 0; )
    {
      line = readline ("FileMan: ");

      if (!line)
        break;

      /* Remove leading and trailing whitespace from the line.
         Then, if there is anything left, add it to the history list
         and execute it. */
      s = stripwhite (line);

      if (*s)
        {
          add_history (s);
          execute_line (s);
        }

      free (line);
    }
  exit (0);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\examples\fileman.c:132
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\examples\fileman.c:165
parsing error 
{
  register int i;
  COMMAND *command;
  char *word;

  /* Isolate the command word. */
  i = 0;
  while (line[i] && whitespace (line[i]))
    i++;
  word = line + i;

  while (line[i] && !whitespace (line[i]))
    i++;

  if (line[i])
    line[i++] = '\0';

  command = find_command (word);

  if (!command)
    {
      fprintf (stderr, "%s: No such command for FileMan.\n", word);
      return (-1);
    }

  /* Get argument to command, if any. */
  while (whitespace (line[i]))
    i++;

  word = line + i;

  /* Call the function. */
  return ((*(command->func)) (word));
}
warning: parse error {
  register int i;
  COMMAND *command;
  char *word;

  /* Isolate the command word. */
  i = 0;
  while (line[i] && whitespace (line[i]))
    i++;
  word = line + i;

  while (line[i] && !whitespace (line[i]))
    i++;

  if (line[i])
    line[i++] = '\0';

  command = find_command (word);

  if (!command)
    {
      fprintf (stderr, "%s: No such command for FileMan.\n", word);
      return (-1);
    }

  /* Get argument to command, if any. */
  while (whitespace (line[i]))
    i++;

  word = line + i;

  /* Call the function. */
  return ((*(command->func)) (word));
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\examples\fileman.c:167
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\examples\fileman.c:205
parsing error 
{
  register int i;

  for (i = 0; commands[i].name; i++)
    if (strcmp (name, commands[i].name) == 0)
      return (&commands[i]);

  return ((COMMAND *)NULL);
}
warning: parse error {
  register int i;

  for (i = 0; commands[i].name; i++)
    if (strcmp (name, commands[i].name) == 0)
      return (&commands[i]);

  return ((COMMAND *)NULL);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\examples\fileman.c:207
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\examples\fileman.c:220
parsing error 
{
  register char *s, *t;

  for (s = string; whitespace (*s); s++)
    ;
    
  if (*s == 0)
    return (s);

  t = s + strlen (s) - 1;
  while (t > s && whitespace (*t))
    t--;
  *++t = '\0';

  return s;
}
warning: parse error {
  register char *s, *t;

  for (s = string; whitespace (*s); s++)
    ;
    
  if (*s == 0)
    return (s);

  t = s + strlen (s) - 1;
  while (t > s && whitespace (*t))
    t--;
  *++t = '\0';

  return s;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\examples\fileman.c:222
parsing error 
char *command_generator PARAMS((const char *, int));
warning: parse error char *command_generator PARAMS((const char *, int));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\examples\fileman.c:245
parsing error 
char **fileman_completion PARAMS((const char *, int, int));
warning: parse error char **fileman_completion PARAMS((const char *, int, int));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\examples\fileman.c:246
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\examples\fileman.c:268
parsing error 
{
  char **matches;

  matches = (char **)NULL;

  /* If this word is at the start of the line, then it is a command
     to complete.  Otherwise it is the name of a file in the current
     directory. */
  if (start == 0)
    matches = rl_completion_matches (text, command_generator);

  return (matches);
}
warning: parse error {
  char **matches;

  matches = (char **)NULL;

  /* If this word is at the start of the line, then it is a command
     to complete.  Otherwise it is the name of a file in the current
     directory. */
  if (start == 0)
    matches = rl_completion_matches (text, command_generator);

  return (matches);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\examples\fileman.c:270
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\examples\fileman.c:289
parsing error 
{
  static int list_index, len;
  char *name;

  /* If this is a new word to complete, initialize now.  This includes
     saving the length of TEXT for efficiency, and initializing the index
     variable to 0. */
  if (!state)
    {
      list_index = 0;
      len = strlen (text);
    }

  /* Return the next name which partially matches from the command list. */
  while (name = commands[list_index].name)
    {
      list_index++;

      if (strncmp (name, text, len) == 0)
        return (dupstr(name));
    }

  /* If no names matched, then return NULL. */
  return ((char *)NULL);
}
warning: parse error {
  static int list_index, len;
  char *name;

  /* If this is a new word to complete, initialize now.  This includes
     saving the length of TEXT for efficiency, and initializing the index
     variable to 0. */
  if (!state)
    {
      list_index = 0;
      len = strlen (text);
    }

  /* Return the next name which partially matches from the command list. */
  while (name = commands[list_index].name)
    {
      list_index++;

      if (strncmp (name, text, len) == 0)
        return (dupstr(name));
    }

  /* If no names matched, then return NULL. */
  return ((char *)NULL);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\examples\fileman.c:291
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\examples\fileman.c:329
parsing error 
{
  if (!arg)
    arg = "";

  sprintf (syscom, "ls -FClg %s", arg);
  return (system (syscom));
}
warning: parse error {
  if (!arg)
    arg = "";

  sprintf (syscom, "ls -FClg %s", arg);
  return (system (syscom));
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\examples\fileman.c:331
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\examples\fileman.c:340
parsing error 
{
  if (!valid_argument ("view", arg))
    return 1;

#if defined (__MSDOS__)
  /* more.com doesn't grok slashes in pathnames */
  sprintf (syscom, "less %s", arg);
#else
  sprintf (syscom, "more %s", arg);
#endif
  return (system (syscom));
}
warning: parse error {
  if (!valid_argument ("view", arg))
    return 1;

#if defined (__MSDOS__)
  /* more.com doesn't grok slashes in pathnames */
  sprintf (syscom, "less %s", arg);
#else
  sprintf (syscom, "more %s", arg);
#endif
  return (system (syscom));
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\examples\fileman.c:342
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\examples\fileman.c:356
parsing error 
{
  too_dangerous ("rename");
  return (1);
}
warning: parse error {
  too_dangerous ("rename");
  return (1);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\examples\fileman.c:358
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\examples\fileman.c:364
parsing error 
{
  struct stat finfo;

  if (!valid_argument ("stat", arg))
    return (1);

  if (stat (arg, &finfo) == -1)
    {
      perror (arg);
      return (1);
    }

  printf ("Statistics for `%s':\n", arg);

  printf ("%s has %d link%s, and is %lu byte%s in length.\n",
	  arg,
          finfo.st_nlink,
          (finfo.st_nlink == 1) ? "" : "s",
          (unsigned long)finfo.st_size,
          (finfo.st_size == 1) ? "" : "s");
  printf ("Inode Last Change at: %s", ctime (&finfo.st_ctime));
  printf ("      Last access at: %s", ctime (&finfo.st_atime));
  printf ("    Last modified at: %s", ctime (&finfo.st_mtime));
  return (0);
}
warning: parse error {
  struct stat finfo;

  if (!valid_argument ("stat", arg))
    return (1);

  if (stat (arg, &finfo) == -1)
    {
      perror (arg);
      return (1);
    }

  printf ("Statistics for `%s':\n", arg);

  printf ("%s has %d link%s, and is %lu byte%s in length.\n",
	  arg,
          finfo.st_nlink,
          (finfo.st_nlink == 1) ? "" : "s",
          (unsigned long)finfo.st_size,
          (finfo.st_size == 1) ? "" : "s");
  printf ("Inode Last Change at: %s", ctime (&finfo.st_ctime));
  printf ("      Last access at: %s", ctime (&finfo.st_atime));
  printf ("    Last modified at: %s", ctime (&finfo.st_mtime));
  return (0);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\examples\fileman.c:366
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\examples\fileman.c:393
parsing error 
{
  too_dangerous ("delete");
  return (1);
}
warning: parse error {
  too_dangerous ("delete");
  return (1);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\examples\fileman.c:395
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\examples\fileman.c:403
parsing error 
{
  register int i;
  int printed = 0;

  for (i = 0; commands[i].name; i++)
    {
      if (!*arg || (strcmp (arg, commands[i].name) == 0))
        {
          printf ("%s\t\t%s.\n", commands[i].name, commands[i].doc);
          printed++;
        }
    }

  if (!printed)
    {
      printf ("No commands match `%s'.  Possibilities are:\n", arg);

      for (i = 0; commands[i].name; i++)
        {
          /* Print in six columns. */
          if (printed == 6)
            {
              printed = 0;
              printf ("\n");
            }

          printf ("%s\t", commands[i].name);
          printed++;
        }

      if (printed)
        printf ("\n");
    }
  return (0);
}
warning: parse error {
  register int i;
  int printed = 0;

  for (i = 0; commands[i].name; i++)
    {
      if (!*arg || (strcmp (arg, commands[i].name) == 0))
        {
          printf ("%s\t\t%s.\n", commands[i].name, commands[i].doc);
          printed++;
        }
    }

  if (!printed)
    {
      printf ("No commands match `%s'.  Possibilities are:\n", arg);

      for (i = 0; commands[i].name; i++)
        {
          /* Print in six columns. */
          if (printed == 6)
            {
              printed = 0;
              printf ("\n");
            }

          printf ("%s\t", commands[i].name);
          printed++;
        }

      if (printed)
        printf ("\n");
    }
  return (0);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\examples\fileman.c:405
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\examples\fileman.c:443
parsing error 
{
  if (chdir (arg) == -1)
    {
      perror (arg);
      return 1;
    }

  com_pwd ("");
  return (0);
}
warning: parse error {
  if (chdir (arg) == -1)
    {
      perror (arg);
      return 1;
    }

  com_pwd ("");
  return (0);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\examples\fileman.c:445
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\examples\fileman.c:458
parsing error 
{
  char dir[1024], *s;

  s = getcwd (dir, sizeof(dir) - 1);
  if (s == 0)
    {
      printf ("Error getting pwd: %s\n", dir);
      return 1;
    }

  printf ("Current directory is %s\n", dir);
  return 0;
}
warning: parse error {
  char dir[1024], *s;

  s = getcwd (dir, sizeof(dir) - 1);
  if (s == 0)
    {
      printf ("Error getting pwd: %s\n", dir);
      return 1;
    }

  printf ("Current directory is %s\n", dir);
  return 0;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\examples\fileman.c:460
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\examples\fileman.c:476
parsing error 
{
  done = 1;
  return (0);
}
warning: parse error {
  done = 1;
  return (0);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\examples\fileman.c:478
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\examples\fileman.c:485
parsing error 
{
  fprintf (stderr,
           "%s: Too dangerous for me to distribute.  Write it yourself.\n",
           caller);
}
warning: parse error {
  fprintf (stderr,
           "%s: Too dangerous for me to distribute.  Write it yourself.\n",
           caller);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\examples\fileman.c:487
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\examples\fileman.c:496
parsing error 
{
  if (!arg || !*arg)
    {
      fprintf (stderr, "%s: Argument required.\n", caller);
      return (0);
    }

  return (1);
}
warning: parse error {
  if (!arg || !*arg)
    {
      fprintf (stderr, "%s: Argument required.\n", caller);
      return (0);
    }

  return (1);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\examples\fileman.c:498
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\examples\histexamp.c...
parsing error 
main (argc, argv)
     int argc;
warning: parse error main (argc, argv)
     int argc;Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\examples\histexamp.c:32
parsing error 
{
  char line[1024], *t;
  int len, done;

  line[0] = 0;
  done = 0;

  using_history ();
  while (!done)
    {
      printf ("history$ ");
      fflush (stdout);
      t = fgets (line, sizeof (line) - 1, stdin);
      if (t && *t)
	{
	  len = strlen (t);
	  if (t[len - 1] == '\n')
	    t[len - 1] = '\0';
	}

      if (!t)
	strcpy (line, "quit");

      if (line[0])
	{
	  char *expansion;
	  int result;

	  using_history ();

	  result = history_expand (line, &expansion);
	  if (result)
	    fprintf (stderr, "%s\n", expansion);

	  if (result < 0 || result == 2)
	    {
	      free (expansion);
	      continue;
	    }

	  add_history (expansion);
	  strncpy (line, expansion, sizeof (line) - 1);
	  free (expansion);
	}

      if (strcmp (line, "quit") == 0)
	done = 1;
      else if (strcmp (line, "save") == 0)
	write_history ("history_file");
      else if (strcmp (line, "read") == 0)
	read_history ("history_file");
      else if (strcmp (line, "list") == 0)
	{
	  register HIST_ENTRY **the_list;
	  register int i;
	  time_t tt;
	  char timestr[128];

	  the_list = history_list ();
	  if (the_list)
	    for (i = 0; the_list[i]; i++)
	      {
	      	tt = history_get_time (the_list[i]);
		if (tt)
		  strftime (timestr, sizeof (timestr), "%a %R", localtime(&tt));
		else
		  strcpy (timestr, "??");
	        printf ("%d: %s: %s\n", i + history_base, timestr, the_list[i]->line);
	      }
	}
      else if (strncmp (line, "delete", 6) == 0)
	{
	  int which;
	  if ((sscanf (line + 6, "%d", &which)) == 1)
	    {
	      HIST_ENTRY *entry = remove_history (which);
	      if (!entry)
		fprintf (stderr, "No such entry %d\n", which);
	      else
		{
		  free (entry->line);
		  free (entry);
		}
	    }
	  else
	    {
	      fprintf (stderr, "non-numeric arg given to `delete'\n");
	    }
	}
    }
}
warning: parse error {
  char line[1024], *t;
  int len, done;

  line[0] = 0;
  done = 0;

  using_history ();
  while (!done)
    {
      printf ("history$ ");
      fflush (stdout);
      t = fgets (line, sizeof (line) - 1, stdin);
      if (t && *t)
	{
	  len = strlen (t);
	  if (t[len - 1] == '\n')
	    t[len - 1] = '\0';
	}

      if (!t)
	strcpy (line, "quit");

      if (line[0])
	{
	  char *expansion;
	  int result;

	  using_history ();

	  result = history_expand (line, &expansion);
	  if (result)
	    fprintf (stderr, "%s\n", expansion);

	  if (result < 0 || result == 2)
	    {
	      free (expansion);
	      continue;
	    }

	  add_history (expansion);
	  strncpy (line, expansion, sizeof (line) - 1);
	  free (expansion);
	}

      if (strcmp (line, "quit") == 0)
	done = 1;
      else if (strcmp (line, "save") == 0)
	write_history ("history_file");
      else if (strcmp (line, "read") == 0)
	read_history ("history_file");
      else if (strcmp (line, "list") == 0)
	{
	  register HIST_ENTRY **the_list;
	  register int i;
	  time_t tt;
	  char timestr[128];

	  the_list = history_list ();
	  if (the_list)
	    for (i = 0; the_list[i]; i++)
	      {
	      	tt = history_get_time (the_list[i]);
		if (tt)
		  strftime (timestr, sizeof (timestr), "%a %R", localtime(&tt));
		else
		  strcpy (timestr, "??");
	        printf ("%d: %s: %s\n", i + history_base, timestr, the_list[i]->line);
	      }
	}
      else if (strncmp (line, "delete", 6) == 0)
	{
	  int which;
	  if ((sscanf (line + 6, "%d", &which)) == 1)
	    {
	      HIST_ENTRY *entry = remove_history (which);
	      if (!entry)
		fprintf (stderr, "No such entry %d\n", which);
	      else
		{
		  free (entry->line);
		  free (entry);
		}
	    }
	  else
	    {
	      fprintf (stderr, "non-numeric arg given to `delete'\n");
	    }
	}
    }
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\examples\histexamp.c:35
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\examples\manexamp.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h...skip
parsing error 
invert_case_line (count, key)
     int count, key;
warning: parse error invert_case_line (count, key)
     int count, key;Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\examples\manexamp.c:63
parsing error 
{
  register int start, end;

  start = rl_point;

  if (count < 0)
    {
      direction = -1;
      count = -count;
    }
  else
    direction = 1;
      
  /* Find the end of the range to modify. */
  end = start + (count * direction);

  /* Force it to be within range. */
  if (end > rl_end)
    end = rl_end;
  else if (end < 0)
    end = -1;

  if (start > end)
    {
      int temp = start;
      start = end;
      end = temp;
    }

  if (start == end)
    return;

  /* Tell readline that we are modifying the line, so save the undo
     information. */
  rl_modifying (start, end);

  for (; start != end; start += direction)
    {
      if (_rl_uppercase_p (rl_line_buffer[start]))
	rl_line_buffer[start] = _rl_to_lower (rl_line_buffer[start]);
      else if (_rl_lowercase_p (rl_line_buffer[start]))
	rl_line_buffer[start] = _rl_to_upper (rl_line_buffer[start]);
    }

  /* Move point to on top of the last character changed. */
  rl_point = end - direction;
}
warning: parse error {
  register int start, end;

  start = rl_point;

  if (count < 0)
    {
      direction = -1;
      count = -count;
    }
  else
    direction = 1;
      
  /* Find the end of the range to modify. */
  end = start + (count * direction);

  /* Force it to be within range. */
  if (end > rl_end)
    end = rl_end;
  else if (end < 0)
    end = -1;

  if (start > end)
    {
      int temp = start;
      start = end;
      end = temp;
    }

  if (start == end)
    return;

  /* Tell readline that we are modifying the line, so save the undo
     information. */
  rl_modifying (start, end);

  for (; start != end; start += direction)
    {
      if (_rl_uppercase_p (rl_line_buffer[start]))
	rl_line_buffer[start] = _rl_to_lower (rl_line_buffer[start]);
      else if (_rl_lowercase_p (rl_line_buffer[start]))
	rl_line_buffer[start] = _rl_to_upper (rl_line_buffer[start]);
    }

  /* Move point to on top of the last character changed. */
  rl_point = end - direction;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\examples\manexamp.c:65
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\examples\rl-callbacktest.c...
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\examples\rl.c...
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\examples\rl.c:81
parsing error 
{
  char *temp, *prompt;
  struct stat sb;
  int opt, fd, nch;
  FILE *ifp;

  progname = strrchr(argv[0], '/');
  if (progname == 0)
    progname = argv[0];
  else
    progname++;

  /* defaults */
  prompt = "readline$ ";
  fd = nch = 0;
  deftext = (char *)0;

  while ((opt = getopt(argc, argv, "p:u:d:n:")) != EOF)
    {
      switch (opt)
	{
	case 'p':
	  prompt = optarg;
	  break;
	case 'u':
	  fd = atoi(optarg);
	  if (fd < 0)
	    {
	      fprintf (stderr, "%s: bad file descriptor `%s'\n", progname, optarg);
	      exit (2);
	    }
	  break;
	case 'd':
	  deftext = optarg;
	  break;
	case 'n':
	  nch = atoi(optarg);
	  if (nch < 0)
	    {
	      fprintf (stderr, "%s: bad value for -n: `%s'\n", progname, optarg);
	      exit (2);
	    }
	  break;
	default:
	  usage ();
	  exit (2);
	}
    }

  if (fd != 0)
    {
      if (fstat (fd, &sb) < 0)
	{
	  fprintf (stderr, "%s: %d: bad file descriptor\n", progname, fd);
	  exit (1);
	}
      ifp = fdopen (fd, "r");
      rl_instream = ifp;
    }

  if (deftext && *deftext)
    rl_startup_hook = set_deftext;

  if (nch > 0)
    rl_num_chars_to_read = nch;

  temp = readline (prompt);

  /* Test for EOF. */
  if (temp == 0)
    exit (1);

  printf ("%s\n", temp);
  exit (0);
}
warning: parse error {
  char *temp, *prompt;
  struct stat sb;
  int opt, fd, nch;
  FILE *ifp;

  progname = strrchr(argv[0], '/');
  if (progname == 0)
    progname = argv[0];
  else
    progname++;

  /* defaults */
  prompt = "readline$ ";
  fd = nch = 0;
  deftext = (char *)0;

  while ((opt = getopt(argc, argv, "p:u:d:n:")) != EOF)
    {
      switch (opt)
	{
	case 'p':
	  prompt = optarg;
	  break;
	case 'u':
	  fd = atoi(optarg);
	  if (fd < 0)
	    {
	      fprintf (stderr, "%s: bad file descriptor `%s'\n", progname, optarg);
	      exit (2);
	    }
	  break;
	case 'd':
	  deftext = optarg;
	  break;
	case 'n':
	  nch = atoi(optarg);
	  if (nch < 0)
	    {
	      fprintf (stderr, "%s: bad value for -n: `%s'\n", progname, optarg);
	      exit (2);
	    }
	  break;
	default:
	  usage ();
	  exit (2);
	}
    }

  if (fd != 0)
    {
      if (fstat (fd, &sb) < 0)
	{
	  fprintf (stderr, "%s: %d: bad file descriptor\n", progname, fd);
	  exit (1);
	}
      ifp = fdopen (fd, "r");
      rl_instream = ifp;
    }

  if (deftext && *deftext)
    rl_startup_hook = set_deftext;

  if (nch > 0)
    rl_num_chars_to_read = nch;

  temp = readline (prompt);

  /* Test for EOF. */
  if (temp == 0)
    exit (1);

  printf ("%s\n", temp);
  exit (0);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\examples\rl.c:84
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\examples\rlcat.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\posixstat.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\examples\rlcat.c:75
parsing error 
{
  char *temp;
  int opt, Vflag, Nflag;

  progname = strrchr(argv[0], '/');
  if (progname == 0)
    progname = argv[0];
  else
    progname++;

  vflag = Vflag = Nflag = 0;
  while ((opt = getopt(argc, argv, "vEVN")) != EOF)
    {
      switch (opt)
	{
	case 'v':
	  vflag = 1;
	  break;
	case 'V':
	  Vflag = 1;
	  break;
	case 'E':
	  Vflag = 0;
	  break;
	case 'N':
	  Nflag = 1;
	  break;
	default:
	  usage ();
	  exit (2);
	}
    }

  argc -= optind;
  argv += optind;

  if (isatty(0) == 0 || argc || Nflag)
    return stdcat(argc, argv);

  rl_variable_bind ("editing-mode", Vflag ? "vi" : "emacs");
  while (temp = readline (""))
    {
      if (*temp)
        add_history (temp);
      printf ("%s\n", temp);
    }

  return (ferror (stdout));
}
warning: parse error {
  char *temp;
  int opt, Vflag, Nflag;

  progname = strrchr(argv[0], '/');
  if (progname == 0)
    progname = argv[0];
  else
    progname++;

  vflag = Vflag = Nflag = 0;
  while ((opt = getopt(argc, argv, "vEVN")) != EOF)
    {
      switch (opt)
	{
	case 'v':
	  vflag = 1;
	  break;
	case 'V':
	  Vflag = 1;
	  break;
	case 'E':
	  Vflag = 0;
	  break;
	case 'N':
	  Nflag = 1;
	  break;
	default:
	  usage ();
	  exit (2);
	}
    }

  argc -= optind;
  argv += optind;

  if (isatty(0) == 0 || argc || Nflag)
    return stdcat(argc, argv);

  rl_variable_bind ("editing-mode", Vflag ? "vi" : "emacs");
  while (temp = readline (""))
    {
      if (*temp)
        add_history (temp);
      printf ("%s\n", temp);
    }

  return (ferror (stdout));
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\examples\rlcat.c:78
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\examples\rlcat.c:129
parsing error 
{
  int c;
  char *x;

  while ((c = getc(fp)) != EOF)
    {
      if (vflag && isascii ((unsigned char)c) && isprint((unsigned char)c) == 0)
	{
	  x = rl_untranslate_keyseq (c);
	  if (fputs (x, stdout) == EOF)
	    return 1;
	}
      else if (putchar (c) == EOF)
        return 1;
    }
  return (ferror (stdout));
}
warning: parse error {
  int c;
  char *x;

  while ((c = getc(fp)) != EOF)
    {
      if (vflag && isascii ((unsigned char)c) && isprint((unsigned char)c) == 0)
	{
	  x = rl_untranslate_keyseq (c);
	  if (fputs (x, stdout) == EOF)
	    return 1;
	}
      else if (putchar (c) == EOF)
        return 1;
    }
  return (ferror (stdout));
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\examples\rlcat.c:131
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\examples\rlcat.c:150
parsing error 
{
  int  i, fd, r;
  char *s;
  FILE *fp;

  if (argc == 0)
    return (fcopy(stdin));

  for (i = 0, r = 1; i < argc; i++)
    {
      if (*argv[i] == '-' && argv[i][1] == 0)
	fp = stdin;
      else
	{
	  fp = fopen (argv[i], "r");
	  if (fp == 0)
	    {
	      fprintf (stderr, "%s: %s: cannot open: %s\n", progname, argv[i], strerror(errno));
	      continue;
	    }
        }
      r = fcopy (fp);
      if (fp != stdin)
	fclose(fp);
    }
  return r;
}
warning: parse error {
  int  i, fd, r;
  char *s;
  FILE *fp;

  if (argc == 0)
    return (fcopy(stdin));

  for (i = 0, r = 1; i < argc; i++)
    {
      if (*argv[i] == '-' && argv[i][1] == 0)
	fp = stdin;
      else
	{
	  fp = fopen (argv[i], "r");
	  if (fp == 0)
	    {
	      fprintf (stderr, "%s: %s: cannot open: %s\n", progname, argv[i], strerror(errno));
	      continue;
	    }
        }
      r = fcopy (fp);
      if (fp != stdin)
	fclose(fp);
    }
  return r;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\examples\rlcat.c:153
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\examples\rltest.c...
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\funmap.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\rlconf.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\xmalloc.h...skip
parsing error 
extern int _rl_qsort_string_compare PARAMS((char **, char **));
warning: parse error extern int _rl_qsort_string_compare PARAMS((char **, char **));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\funmap.c:49
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\histexpand.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\rlmbutil.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\history.h...skip
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\histlib.h...
parsing error 
extern int _hs_history_patsearch PARAMS((const char *, int, int));
warning: parse error extern int _hs_history_patsearch PARAMS((const char *, int, int));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\histlib.h:92
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\chardefs.h...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\rlshell.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\xmalloc.h...skip
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\histfile.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\posixstat.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\history.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\histlib.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\rlshell.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\xmalloc.h...skip
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\history.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\history.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\histlib.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\xmalloc.h...skip
parsing error 
static char *hist_inittime PARAMS((void));
warning: parse error static char *hist_inittime PARAMS((void));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\history.c:65
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\histsearch.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\history.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\histlib.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\xmalloc.h...skip
parsing error 
static int history_search_internal PARAMS((const char *, int, int));
warning: parse error static int history_search_internal PARAMS((const char *, int, int));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\histsearch.c:54
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\input.c...
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\posixselect.h...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\rldefs.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\rlmbutil.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\rlprivate.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\rlshell.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\xmalloc.h...skip
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\isearch.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\rldefs.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\rlmbutil.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\history.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\rlprivate.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\xmalloc.h...skip
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\keymaps.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\rlconf.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\emacs_keymap.c...skip
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\vi_keymap.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\xmalloc.h...skip
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\kill.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\rldefs.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\history.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\rlprivate.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\xmalloc.h...skip
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\macro.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\rldefs.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\history.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\rlprivate.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\xmalloc.h...skip
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\mbutil.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\posixjmp.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\rldefs.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\rlmbutil.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\rlprivate.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\xmalloc.h...skip
parsing error 
wchar_t
_rl_char_value (char *buf, int ind)
{
  size_t tmp;
  wchar_t wc;
  mbstate_t ps;
  int l;

  if (MB_LEN_MAX == 1 || rl_byte_oriented)
    return ((wchar_t) buf[ind]);
  if (_rl_utf8locale && UTF8_SINGLEBYTE(buf[ind]))
    return ((wchar_t) buf[ind]);
  l = strlen (buf);
  if (ind >= l - 1)
    return ((wchar_t) buf[ind]);
  if (l < ind)			/* Sanity check */
    l = strlen (buf+ind);
  memset (&ps, 0, sizeof (mbstate_t));
  tmp = mbrtowc (&wc, buf + ind, l - ind, &ps);
  if (MB_INVALIDCH (tmp) || MB_NULLWCH (tmp))  
    return ((wchar_t) buf[ind]);
  return wc;
}
warning: parse error wchar_t
_rl_char_value (char *buf, int ind)
{
  size_t tmp;
  wchar_t wc;
  mbstate_t ps;
  int l;

  if (MB_LEN_MAX == 1 || rl_byte_oriented)
    return ((wchar_t) buf[ind]);
  if (_rl_utf8locale && UTF8_SINGLEBYTE(buf[ind]))
    return ((wchar_t) buf[ind]);
  l = strlen (buf);
  if (ind >= l - 1)
    return ((wchar_t) buf[ind]);
  if (l < ind)			/* Sanity check */
    l = strlen (buf+ind);
  memset (&ps, 0, sizeof (mbstate_t));
  tmp = mbrtowc (&wc, buf + ind, l - ind, &ps);
  if (MB_INVALIDCH (tmp) || MB_NULLWCH (tmp))  
    return ((wchar_t) buf[ind]);
  return wc;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\mbutil.c:473
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\misc.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\rldefs.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\rlmbutil.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\history.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\rlprivate.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\rlshell.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\xmalloc.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\misc.c:667
parsing error 
{
  /* Accept the current line. */
  rl_newline (1, c);

  saved_history_logical_offset = rl_explicit_arg ? count : where_history () + history_base + 1;


  _rl_saved_internal_startup_hook = _rl_internal_startup_hook;
  _rl_internal_startup_hook = set_saved_history;

  return 0;
}
warning: parse error {
  /* Accept the current line. */
  rl_newline (1, c);

  saved_history_logical_offset = rl_explicit_arg ? count : where_history () + history_base + 1;


  _rl_saved_internal_startup_hook = _rl_internal_startup_hook;
  _rl_internal_startup_hook = set_saved_history;

  return 0;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\misc.c:669
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\nls.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\rldefs.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\rlshell.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\rlprivate.h...skip
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\parens.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\rlconf.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\posixselect.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\rlprivate.h...skip
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\parse-colors.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\rldefs.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\rlprivate.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\rlshell.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\xmalloc.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\colors.h...skip
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\parse-colors.h...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h...skip
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\posixstat.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\posixjmp.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\rldefs.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\rlmbutil.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\history.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\rlprivate.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\rlshell.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\xmalloc.h...skip
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\rltty.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\rldefs.h...skip
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\rltty.h...
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\rlwinsize.h...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\rlprivate.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\rltty.c:83
parsing error 
{
#if defined (TIOCGWINSZ)
  struct winsize w;

  if (ioctl (tty, TIOCGWINSZ, &w) == 0)
      (void) ioctl (tty, TIOCSWINSZ, &w);
#endif /* TIOCGWINSZ */
}
warning: parse error {
#if defined (TIOCGWINSZ)
  struct winsize w;

  if (ioctl (tty, TIOCGWINSZ, &w) == 0)
      (void) ioctl (tty, TIOCSWINSZ, &w);
#endif /* TIOCGWINSZ */
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\rltty.c:85
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\savestring.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\xmalloc.h...skip
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\search.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\rldefs.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\rlmbutil.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\history.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\histlib.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\rlprivate.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\xmalloc.h...skip
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\shell.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\rlstdc.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\rlshell.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\rldefs.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\xmalloc.h...skip
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\signals.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\rldefs.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\history.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\rlprivate.h...skip
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\terminal.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\posixstat.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\rldefs.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\rltty.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\tcap.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\history.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\rlprivate.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\rlshell.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\xmalloc.h...skip
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\text.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\rldefs.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\rlmbutil.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\history.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\rlprivate.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\rlshell.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\xmalloc.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\text.c:1,759
parsing error 
{
  _rl_callback_func = 0;
  _rl_want_redisplay = 1;

  return (_rl_char_search (data->count, data->i1, data->i2));
}
warning: parse error {
  _rl_callback_func = 0;
  _rl_want_redisplay = 1;

  return (_rl_char_search (data->count, data->i1, data->i2));
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\text.c:1,761
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\tilde.c...
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\tilde.h...
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\undo.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\rldefs.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\history.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\rlprivate.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\xmalloc.h...skip
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\util.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\posixjmp.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\rldefs.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\rlmbutil.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\rlprivate.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\xmalloc.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\rlshell.h...skip
parsing error 
char *
_rl_strpbrk (const char *string1, const char *string2)
{
  register const char *scan;
#if defined (HANDLE_MULTIBYTE)
  mbstate_t ps;
  register int i, v;

  memset (&ps, 0, sizeof (mbstate_t));
#endif

  for (; *string1; string1++)
    {
      for (scan = string2; *scan; scan++)
	{
	  if (*string1 == *scan)
	    return ((char *)string1);
	}
#if defined (HANDLE_MULTIBYTE)
      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
	{
	  v = _rl_get_char_len (string1, &ps);
	  if (v > 1)
	    string1 += v - 1;	/* -1 to account for auto-increment in loop */
	}
#endif
    }
  return ((char *)NULL);
}
warning: parse error char *
_rl_strpbrk (const char *string1, const char *string2)
{
  register const char *scan;
#if defined (HANDLE_MULTIBYTE)
  mbstate_t ps;
  register int i, v;

  memset (&ps, 0, sizeof (mbstate_t));
#endif

  for (; *string1; string1++)
    {
      for (scan = string2; *scan; scan++)
	{
	  if (*string1 == *scan)
	    return ((char *)string1);
	}
#if defined (HANDLE_MULTIBYTE)
      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
	{
	  v = _rl_get_char_len (string1, &ps);
	  if (v > 1)
	    string1 += v - 1;	/* -1 to account for auto-increment in loop */
	}
#endif
    }
  return ((char *)NULL);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\util.c:334
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\vi_keymap.c...skip
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\vi_mode.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\rlconf.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\rldefs.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\rlmbutil.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\history.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\rlprivate.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\xmalloc.h...skip
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\xfree.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\xmalloc.h...skip
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\xmalloc.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\xmalloc.h...skip
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\casemod.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\stdc.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashansi.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashintl.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashtypes.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\xmalloc.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\shmbchar.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\shmbutil.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\chartypes.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\typemax.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\glob\strmatch.h...skip
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\casemod.c:104
parsing error 
{
  int start, next, end, retind;
  int inword, c, nc, nop, match, usewords;
  char *ret, *s;
  wchar_t wc;
  int mb_cur_max;
#if defined (HANDLE_MULTIBYTE)
  wchar_t nwc;
  char mb[MB_LEN_MAX+1];
  int mlen;
  size_t m;
  mbstate_t state;
#endif

  if (string == 0 || *string == 0)
    {
      ret = (char *)xmalloc (1);
      ret[0] = '\0';
      return ret;
    }

#if defined (HANDLE_MULTIBYTE)
  memset (&state, 0, sizeof (mbstate_t));
#endif

  start = 0;
  end = strlen (string);
  mb_cur_max = MB_CUR_MAX;

  ret = (char *)xmalloc (2*end + 1);
  retind = 0;

  /* See if we are supposed to split on alphanumerics and operate on each word */
  usewords = (flags & CASE_USEWORDS);
  flags &= ~CASE_USEWORDS;

  inword = 0;
  while (start < end)
    {
      wc = cval ((char *)string, start);

      if (iswalnum (wc) == 0)
	inword = 0;

      if (pat)
	{
	  next = start;
	  ADVANCE_CHAR (string, end, next);
	  s = substring ((char *)string, start, next);
	  match = strmatch (pat, s, FNM_EXTMATCH) != FNM_NOMATCH;
	  free (s);
	  if (match == 0)
            {
              /* copy unmatched portion */
              memcpy (ret + retind, string + start, next - start);
              retind += next - start;
              start = next;
              inword = 1;
              continue;
            }
	}

      /* XXX - for now, the toggling operators work on the individual
	 words in the string, breaking on alphanumerics.  Should I
	 leave the capitalization operators to do that also? */
      if (flags == CASE_CAPITALIZE)
	{
	  if (usewords)
	    nop = inword ? CASE_LOWER : CASE_UPPER;
	  else
	    nop = (start > 0) ? CASE_LOWER : CASE_UPPER;
	  inword = 1;
	}
      else if (flags == CASE_UNCAP)
	{
	  if (usewords)
	    nop = inword ? CASE_UPPER : CASE_LOWER;
	  else
	    nop = (start > 0) ? CASE_UPPER : CASE_LOWER;
	  inword = 1;
	}
      else if (flags == CASE_UPFIRST)
 	{
 	  if (usewords)
	    nop = inword ? CASE_NOOP : CASE_UPPER;
	  else
	    nop = (start > 0) ? CASE_NOOP : CASE_UPPER;
 	  inword = 1;
 	}
      else if (flags == CASE_LOWFIRST)
 	{
 	  if (usewords)
	    nop = inword ? CASE_NOOP : CASE_LOWER;
	  else
	    nop = (start > 0) ? CASE_NOOP : CASE_LOWER;
 	  inword = 1;
 	}
      else if (flags == CASE_TOGGLE)
	{
	  nop = inword ? CASE_NOOP : CASE_TOGGLE;
	  inword = 1;
	}
      else
	nop = flags;

      /* Can't short-circuit, some locales have multibyte upper and lower
	 case equivalents of single-byte ascii characters (e.g., Turkish) */
      if (mb_cur_max == 1)
	{
singlebyte:
	  switch (nop)
	    {
	    default:
	    case CASE_NOOP:  nc = wc; break;
	    case CASE_UPPER:  nc = TOUPPER (wc); break;
	    case CASE_LOWER:  nc = TOLOWER (wc); break;
	    case CASE_TOGGLEALL:
	    case CASE_TOGGLE: nc = TOGGLE (wc); break;
	    }
	  ret[retind++] = nc;
	}
#if defined (HANDLE_MULTIBYTE)
      else
	{
	  m = mbrtowc (&wc, string + start, end - start, &state);
	  /* Have to go through wide case conversion even for single-byte
	     chars, to accommodate single-byte characters where the
	     corresponding upper or lower case equivalent is multibyte. */
	  if (MB_INVALIDCH (m))
	    {
	      wc = (unsigned char)string[start];
	      goto singlebyte;
	    }
	  else if (MB_NULLWCH (m))
	    wc = L'\0';
	  switch (nop)
	    {
	    default:
	    case CASE_NOOP:  nwc = wc; break;
	    case CASE_UPPER:  nwc = _to_wupper (wc); break;
	    case CASE_LOWER:  nwc = _to_wlower (wc); break;
	    case CASE_TOGGLEALL:
	    case CASE_TOGGLE: nwc = TOGGLE (wc); break;
	    }

	  /* We don't have to convert `wide' characters that are in the
	     unsigned char range back to single-byte `multibyte' characters. */
	  if ((int)nwc <= UCHAR_MAX && is_basic ((int)nwc))
	    ret[retind++] = nwc;
	  else
	    {
	      mlen = wcrtomb (mb, nwc, &state);
	      if (mlen > 0)
		mb[mlen] = '\0';
	      /* Don't assume the same width */
	      strncpy (ret + retind, mb, mlen);
	      retind += mlen;
	    }
	}
#endif

      ADVANCE_CHAR (string, end, start);
    }

  ret[retind] = '\0';
  return ret;
}
warning: parse error {
  int start, next, end, retind;
  int inword, c, nc, nop, match, usewords;
  char *ret, *s;
  wchar_t wc;
  int mb_cur_max;
#if defined (HANDLE_MULTIBYTE)
  wchar_t nwc;
  char mb[MB_LEN_MAX+1];
  int mlen;
  size_t m;
  mbstate_t state;
#endif

  if (string == 0 || *string == 0)
    {
      ret = (char *)xmalloc (1);
      ret[0] = '\0';
      return ret;
    }

#if defined (HANDLE_MULTIBYTE)
  memset (&state, 0, sizeof (mbstate_t));
#endif

  start = 0;
  end = strlen (string);
  mb_cur_max = MB_CUR_MAX;

  ret = (char *)xmalloc (2*end + 1);
  retind = 0;

  /* See if we are supposed to split on alphanumerics and operate on each word */
  usewords = (flags & CASE_USEWORDS);
  flags &= ~CASE_USEWORDS;

  inword = 0;
  while (start < end)
    {
      wc = cval ((char *)string, start);

      if (iswalnum (wc) == 0)
	inword = 0;

      if (pat)
	{
	  next = start;
	  ADVANCE_CHAR (string, end, next);
	  s = substring ((char *)string, start, next);
	  match = strmatch (pat, s, FNM_EXTMATCH) != FNM_NOMATCH;
	  free (s);
	  if (match == 0)
            {
              /* copy unmatched portion */
              memcpy (ret + retind, string + start, next - start);
              retind += next - start;
              start = next;
              inword = 1;
              continue;
            }
	}

      /* XXX - for now, the toggling operators work on the individual
	 words in the string, breaking on alphanumerics.  Should I
	 leave the capitalization operators to do that also? */
      if (flags == CASE_CAPITALIZE)
	{
	  if (usewords)
	    nop = inword ? CASE_LOWER : CASE_UPPER;
	  else
	    nop = (start > 0) ? CASE_LOWER : CASE_UPPER;
	  inword = 1;
	}
      else if (flags == CASE_UNCAP)
	{
	  if (usewords)
	    nop = inword ? CASE_UPPER : CASE_LOWER;
	  else
	    nop = (start > 0) ? CASE_UPPER : CASE_LOWER;
	  inword = 1;
	}
      else if (flags == CASE_UPFIRST)
 	{
 	  if (usewords)
	    nop = inword ? CASE_NOOP : CASE_UPPER;
	  else
	    nop = (start > 0) ? CASE_NOOP : CASE_UPPER;
 	  inword = 1;
 	}
      else if (flags == CASE_LOWFIRST)
 	{
 	  if (usewords)
	    nop = inword ? CASE_NOOP : CASE_LOWER;
	  else
	    nop = (start > 0) ? CASE_NOOP : CASE_LOWER;
 	  inword = 1;
 	}
      else if (flags == CASE_TOGGLE)
	{
	  nop = inword ? CASE_NOOP : CASE_TOGGLE;
	  inword = 1;
	}
      else
	nop = flags;

      /* Can't short-circuit, some locales have multibyte upper and lower
	 case equivalents of single-byte ascii characters (e.g., Turkish) */
      if (mb_cur_max == 1)
	{
singlebyte:
	  switch (nop)
	    {
	    default:
	    case CASE_NOOP:  nc = wc; break;
	    case CASE_UPPER:  nc = TOUPPER (wc); break;
	    case CASE_LOWER:  nc = TOLOWER (wc); break;
	    case CASE_TOGGLEALL:
	    case CASE_TOGGLE: nc = TOGGLE (wc); break;
	    }
	  ret[retind++] = nc;
	}
#if defined (HANDLE_MULTIBYTE)
      else
	{
	  m = mbrtowc (&wc, string + start, end - start, &state);
	  /* Have to go through wide case conversion even for single-byte
	     chars, to accommodate single-byte characters where the
	     corresponding upper or lower case equivalent is multibyte. */
	  if (MB_INVALIDCH (m))
	    {
	      wc = (unsigned char)string[start];
	      goto singlebyte;
	    }
	  else if (MB_NULLWCH (m))
	    wc = L'\0';
	  switch (nop)
	    {
	    default:
	    case CASE_NOOP:  nwc = wc; break;
	    case CASE_UPPER:  nwc = _to_wupper (wc); break;
	    case CASE_LOWER:  nwc = _to_wlower (wc); break;
	    case CASE_TOGGLEALL:
	    case CASE_TOGGLE: nwc = TOGGLE (wc); break;
	    }

	  /* We don't have to convert `wide' characters that are in the
	     unsigned char range back to single-byte `multibyte' characters. */
	  if ((int)nwc <= UCHAR_MAX && is_basic ((int)nwc))
	    ret[retind++] = nwc;
	  else
	    {
	      mlen = wcrtomb (mb, nwc, &state);
	      if (mlen > 0)
		mb[mlen] = '\0';
	      /* Don't assume the same width */
	      strncpy (ret + retind, mb, mlen);
	      retind += mlen;
	    }
	}
#endif

      ADVANCE_CHAR (string, end, start);
    }

  ret[retind] = '\0';
  return ret;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\casemod.c:107
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\clktck.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashtypes.h...skip
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\clock.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\posixtime.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\stdc.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashintl.h...skip
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\dprintf.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\stdc.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\dprintf.c:43
parsing error 
va_dcl
#endif
{
  FILE *fp;
  int fd2, rc, r2;
  va_list args;

  if ((fd2 = dup(fd)) < 0)
    return -1;
  fp = fdopen (fd2, "w");
  if (fp == 0)
    {
      close (fd2);
      return -1;
    }

  SH_VA_START (args, format);
  rc = vfprintf (fp, format, args);
  fflush (fp);
  va_end (args);

  r2 = fclose (fp);	/* check here */

  return rc;
}
warning: parse error va_dcl
#endif
{
  FILE *fp;
  int fd2, rc, r2;
  va_list args;

  if ((fd2 = dup(fd)) < 0)
    return -1;
  fp = fdopen (fd2, "w");
  if (fp == 0)
    {
      close (fd2);
      return -1;
    }

  SH_VA_START (args, format);
  rc = vfprintf (fp, format, args);
  fflush (fp);
  va_end (args);

  r2 = fclose (fp);	/* check here */

  return rc;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\dprintf.c:46
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\eaccess.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashtypes.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashansi.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\posixstat.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\filecntl.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\shell.h...skip
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\eaccess.c:63
parsing error 
{
  if (path[0] == '/' && path[1] == 'd' && strncmp (path, "/dev/fd/", 8) == 0)
    return 1;
  else if (STREQN (path, "/dev/std", 8))
    {
      if (STREQ (path+8, "in") || STREQ (path+8, "out") || STREQ (path+8, "err"))
	return 1;
      else
	return 0;
    }
  else
    return 0;
}
warning: parse error {
  if (path[0] == '/' && path[1] == 'd' && strncmp (path, "/dev/fd/", 8) == 0)
    return 1;
  else if (STREQN (path, "/dev/std", 8))
    {
      if (STREQ (path+8, "in") || STREQ (path+8, "out") || STREQ (path+8, "err"))
	return 1;
      else
	return 0;
    }
  else
    return 0;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\eaccess.c:64
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\eaccess.c:82
parsing error 
{
  static char *pbuf = 0;

  if (*path == '\0')
    {
      errno = ENOENT;
      return (-1);
    }
  if (path[0] == '/' && path[1] == 'd' && strncmp (path, "/dev/fd/", 8) == 0)
    {
      /* If stating /dev/fd/n doesn't produce the same results as fstat of
	 FD N, then define DEV_FD_STAT_BROKEN */
#if !defined (HAVE_DEV_FD) || defined (DEV_FD_STAT_BROKEN)
      intmax_t fd;
      int r;

      if (legal_number (path + 8, &fd) && fd == (int)fd)
        {
          r = fstat ((int)fd, finfo);
          if (r == 0 || errno != EBADF)
            return (r);
        }
      errno = ENOENT;
      return (-1);
#else
  /* If HAVE_DEV_FD is defined, DEV_FD_PREFIX is defined also, and has a
     trailing slash.  Make sure /dev/fd/xx really uses DEV_FD_PREFIX/xx.
     On most systems, with the notable exception of linux, this is
     effectively a no-op. */
      pbuf = xrealloc (pbuf, sizeof (DEV_FD_PREFIX) + strlen (path + 8));
      strcpy (pbuf, DEV_FD_PREFIX);
      strcat (pbuf, path + 8);
      return (stat (pbuf, finfo));
#endif /* !HAVE_DEV_FD */
    }
#if !defined (HAVE_DEV_STDIN)
  else if (STREQN (path, "/dev/std", 8))
    {
      if (STREQ (path+8, "in"))
	return (fstat (0, finfo));
      else if (STREQ (path+8, "out"))
	return (fstat (1, finfo));
      else if (STREQ (path+8, "err"))
	return (fstat (2, finfo));
      else
	return (stat (path, finfo));
    }
#endif /* !HAVE_DEV_STDIN */
  return (stat (path, finfo));
}
warning: parse error {
  static char *pbuf = 0;

  if (*path == '\0')
    {
      errno = ENOENT;
      return (-1);
    }
  if (path[0] == '/' && path[1] == 'd' && strncmp (path, "/dev/fd/", 8) == 0)
    {
      /* If stating /dev/fd/n doesn't produce the same results as fstat of
	 FD N, then define DEV_FD_STAT_BROKEN */
#if !defined (HAVE_DEV_FD) || defined (DEV_FD_STAT_BROKEN)
      intmax_t fd;
      int r;

      if (legal_number (path + 8, &fd) && fd == (int)fd)
        {
          r = fstat ((int)fd, finfo);
          if (r == 0 || errno != EBADF)
            return (r);
        }
      errno = ENOENT;
      return (-1);
#else
  /* If HAVE_DEV_FD is defined, DEV_FD_PREFIX is defined also, and has a
     trailing slash.  Make sure /dev/fd/xx really uses DEV_FD_PREFIX/xx.
     On most systems, with the notable exception of linux, this is
     effectively a no-op. */
      pbuf = xrealloc (pbuf, sizeof (DEV_FD_PREFIX) + strlen (path + 8));
      strcpy (pbuf, DEV_FD_PREFIX);
      strcat (pbuf, path + 8);
      return (stat (pbuf, finfo));
#endif /* !HAVE_DEV_FD */
    }
#if !defined (HAVE_DEV_STDIN)
  else if (STREQN (path, "/dev/std", 8))
    {
      if (STREQ (path+8, "in"))
	return (fstat (0, finfo));
      else if (STREQ (path+8, "out"))
	return (fstat (1, finfo));
      else if (STREQ (path+8, "err"))
	return (fstat (2, finfo));
      else
	return (stat (path, finfo));
    }
#endif /* !HAVE_DEV_STDIN */
  return (stat (path, finfo));
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\eaccess.c:84
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\eaccess.c:140
parsing error 
{
  struct stat st;

  if (sh_stat (path, &st) < 0)
    return (-1);

  if (current_user.euid == 0)
    {
      /* Root can read or write any file. */
      if ((mode & X_OK) == 0)
	return (0);

      /* Root can execute any file that has any one of the execute
	 bits set. */
      if (st.st_mode & S_IXUGO)
	return (0);
    }

  if (st.st_uid == current_user.euid)	/* owner */
    mode <<= 6;
  else if (group_member (st.st_gid))
    mode <<= 3;

  if (st.st_mode & mode)
    return (0);

  errno = EACCES;
  return (-1);
}
warning: parse error {
  struct stat st;

  if (sh_stat (path, &st) < 0)
    return (-1);

  if (current_user.euid == 0)
    {
      /* Root can read or write any file. */
      if ((mode & X_OK) == 0)
	return (0);

      /* Root can execute any file that has any one of the execute
	 bits set. */
      if (st.st_mode & S_IXUGO)
	return (0);
    }

  if (st.st_uid == current_user.euid)	/* owner */
    mode <<= 6;
  else if (group_member (st.st_gid))
    mode <<= 3;

  if (st.st_mode & mode)
    return (0);

  errno = EACCES;
  return (-1);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\eaccess.c:142
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\eaccess.c:202
parsing error 
{
  int ret;

  if (path_is_devfd (path))
    return (sh_stataccess (path, mode));

#if (defined (HAVE_FACCESSAT) && defined (AT_EACCESS)) || defined (HAVE_EACCESS)
#  if defined (HAVE_FACCESSAT) && defined (AT_EACCESS)
  ret = faccessat (AT_FDCWD, path, mode, AT_EACCESS);
#  else		/* HAVE_EACCESS */	/* FreeBSD */
  ret = eaccess (path, mode);	/* XXX -- not always correct for X_OK */
#  endif	/* HAVE_EACCESS */
#  if defined (__FreeBSD__) || defined (SOLARIS) || defined (_AIX)
  if (ret == 0 && current_user.euid == 0 && mode == X_OK)
    return (sh_stataccess (path, mode));
#  endif	/* __FreeBSD__ || SOLARIS || _AIX */
  return ret;
#elif defined (EFF_ONLY_OK)		/* SVR4(?), SVR4.2 */
  return access (path, mode|EFF_ONLY_OK);
#else
  if (mode == F_OK)
    return (sh_stataccess (path, mode));
    
#  if HAVE_DECL_SETREGID
  if (current_user.uid != current_user.euid || current_user.gid != current_user.egid)
    return (sh_euidaccess (path, mode));
#  endif

  if (current_user.uid == current_user.euid && current_user.gid == current_user.egid)
    {
      ret = access (path, mode);
#if defined (__FreeBSD__) || defined (SOLARIS)
      if (ret == 0 && current_user.euid == 0 && mode == X_OK)
	return (sh_stataccess (path, mode));
#endif
      return ret;
    }

  return (sh_stataccess (path, mode));
#endif
}
warning: parse error {
  int ret;

  if (path_is_devfd (path))
    return (sh_stataccess (path, mode));

#if (defined (HAVE_FACCESSAT) && defined (AT_EACCESS)) || defined (HAVE_EACCESS)
#  if defined (HAVE_FACCESSAT) && defined (AT_EACCESS)
  ret = faccessat (AT_FDCWD, path, mode, AT_EACCESS);
#  else		/* HAVE_EACCESS */	/* FreeBSD */
  ret = eaccess (path, mode);	/* XXX -- not always correct for X_OK */
#  endif	/* HAVE_EACCESS */
#  if defined (__FreeBSD__) || defined (SOLARIS) || defined (_AIX)
  if (ret == 0 && current_user.euid == 0 && mode == X_OK)
    return (sh_stataccess (path, mode));
#  endif	/* __FreeBSD__ || SOLARIS || _AIX */
  return ret;
#elif defined (EFF_ONLY_OK)		/* SVR4(?), SVR4.2 */
  return access (path, mode|EFF_ONLY_OK);
#else
  if (mode == F_OK)
    return (sh_stataccess (path, mode));
    
#  if HAVE_DECL_SETREGID
  if (current_user.uid != current_user.euid || current_user.gid != current_user.egid)
    return (sh_euidaccess (path, mode));
#  endif

  if (current_user.uid == current_user.euid && current_user.gid == current_user.egid)
    {
      ret = access (path, mode);
#if defined (__FreeBSD__) || defined (SOLARIS)
      if (ret == 0 && current_user.euid == 0 && mode == X_OK)
	return (sh_stataccess (path, mode));
#endif
      return ret;
    }

  return (sh_stataccess (path, mode));
#endif
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\eaccess.c:204
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\fmtullong.c...
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\fmtulong.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashansi.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\chartypes.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashintl.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\stdc.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\typemax.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\fmtulong.c:84
parsing error 
{
  char *p;
  int sign;
  LONG si;

  if (base == 0)
    base = 10;

  if (base < 2 || base > 64)
    {
#if 1
      /* XXX - truncation possible with long translation */
      strncpy (buf, _("invalid base"), len - 1);
      buf[len-1] = '\0';
      errno = EINVAL;
      return (p = buf);
#else
      base = 10;
#endif
    }

  sign = 0;
  if ((flags & FL_UNSIGNED) == 0 && (LONG)ui < 0)
    {
      ui = -ui;
      sign = '-';
    }

  p = buf + len - 2;
  p[1] = '\0';

  /* handle common cases explicitly */
  switch (base)
    {
    case 10:
      if (ui < 10)
	{
	  *p-- = TOCHAR (ui);
	  break;
	}
      /* Favor signed arithmetic over unsigned arithmetic; it is faster on
	 many machines. */
      if ((LONG)ui < 0)
	{
	  *p-- = TOCHAR (ui % 10);
	  si = ui / 10;
	}
      else
        si = ui;
      do
	*p-- = TOCHAR (si % 10);
      while (si /= 10);
      break;

    case 8:
      do
	*p-- = TOCHAR (ui & 7);
      while (ui >>= 3);
      break;

    case 16:
      do
	*p-- = (flags & FL_HEXUPPER) ? X_digs[ui & 15] : x_digs[ui & 15];
      while (ui >>= 4);
      break;

    case 2:
      do
	*p-- = TOCHAR (ui & 1);
      while (ui >>= 1);
      break;

    default:
      do
	*p-- = FMTCHAR (ui % base);
      while (ui /= base);
      break;
    }

  if ((flags & FL_PREFIX) && (base == 8 || base == 16))
    {
      if (base == 16)
	{
	  *p-- = (flags & FL_HEXUPPER) ? 'X' : 'x';
	  *p-- = '0';
	}
      else if (p[1] != '0')
	*p-- = '0';
    }
  else if ((flags & FL_ADDBASE) && base != 10)
    {
      *p-- = '#';
      *p-- = TOCHAR (base % 10);
      if (base > 10)
        *p-- = TOCHAR (base / 10);
    }

  if (sign)
    *p-- = '-';

  return (p + 1);
}
warning: parse error {
  char *p;
  int sign;
  LONG si;

  if (base == 0)
    base = 10;

  if (base < 2 || base > 64)
    {
#if 1
      /* XXX - truncation possible with long translation */
      strncpy (buf, _("invalid base"), len - 1);
      buf[len-1] = '\0';
      errno = EINVAL;
      return (p = buf);
#else
      base = 10;
#endif
    }

  sign = 0;
  if ((flags & FL_UNSIGNED) == 0 && (LONG)ui < 0)
    {
      ui = -ui;
      sign = '-';
    }

  p = buf + len - 2;
  p[1] = '\0';

  /* handle common cases explicitly */
  switch (base)
    {
    case 10:
      if (ui < 10)
	{
	  *p-- = TOCHAR (ui);
	  break;
	}
      /* Favor signed arithmetic over unsigned arithmetic; it is faster on
	 many machines. */
      if ((LONG)ui < 0)
	{
	  *p-- = TOCHAR (ui % 10);
	  si = ui / 10;
	}
      else
        si = ui;
      do
	*p-- = TOCHAR (si % 10);
      while (si /= 10);
      break;

    case 8:
      do
	*p-- = TOCHAR (ui & 7);
      while (ui >>= 3);
      break;

    case 16:
      do
	*p-- = (flags & FL_HEXUPPER) ? X_digs[ui & 15] : x_digs[ui & 15];
      while (ui >>= 4);
      break;

    case 2:
      do
	*p-- = TOCHAR (ui & 1);
      while (ui >>= 1);
      break;

    default:
      do
	*p-- = FMTCHAR (ui % base);
      while (ui /= base);
      break;
    }

  if ((flags & FL_PREFIX) && (base == 8 || base == 16))
    {
      if (base == 16)
	{
	  *p-- = (flags & FL_HEXUPPER) ? 'X' : 'x';
	  *p-- = '0';
	}
      else if (p[1] != '0')
	*p-- = '0';
    }
  else if ((flags & FL_ADDBASE) && base != 10)
    {
      *p-- = '#';
      *p-- = TOCHAR (base % 10);
      if (base > 10)
        *p-- = TOCHAR (base / 10);
    }

  if (sign)
    *p-- = '-';

  return (p + 1);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\fmtulong.c:90
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\fmtulong.c...skip
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\fmtumax.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\fmtulong.c...skip
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\fnxform.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashansi.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashtypes.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\stdc.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashintl.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\xmalloc.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\fnxform.c:187
parsing error 
{
  return string;
}
warning: parse error {
  return string;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\fnxform.c:189
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\fnxform.c:194
parsing error 
{
  return string;
}
warning: parse error {
  return string;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\fnxform.c:196
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\fpurge.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\stdc.h...skip
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\getcwd.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashtypes.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\posixdir.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\posixstat.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\maxpath.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\memalloc.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashansi.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\xmalloc.h...skip
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\getenv.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashansi.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\shell.h...skip
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\gettimeofday.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\posixtime.h...skip
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\inet_aton.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashansi.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\stdc.h...skip
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\input_avail.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashansi.h...skip
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\posixselect.h...
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\input_avail.c:66
parsing error 
{
  int result, chars_avail;
#if defined(HAVE_SELECT)
  fd_set readfds, exceptfds;
  struct timeval timeout;
#endif

  if (fd < 0)
    return -1;

  chars_avail = 0;

#if defined (HAVE_SELECT)
  FD_ZERO (&readfds);
  FD_ZERO (&exceptfds);
  FD_SET (fd, &readfds);
  FD_SET (fd, &exceptfds);
  timeout.tv_sec = 0;
  timeout.tv_usec = 0;
  result = select (fd + 1, &readfds, (fd_set *)NULL, &exceptfds, &timeout);
  return ((result <= 0) ? 0 : 1);
#endif

#if defined (FIONREAD)
  errno = 0;
  result = ioctl (fd, FIONREAD, &chars_avail);
  if (result == -1 && errno == EIO)
    return -1;
  return (chars_avail);
#endif

  return 0;
}
warning: parse error {
  int result, chars_avail;
#if defined(HAVE_SELECT)
  fd_set readfds, exceptfds;
  struct timeval timeout;
#endif

  if (fd < 0)
    return -1;

  chars_avail = 0;

#if defined (HAVE_SELECT)
  FD_ZERO (&readfds);
  FD_ZERO (&exceptfds);
  FD_SET (fd, &readfds);
  FD_SET (fd, &exceptfds);
  timeout.tv_sec = 0;
  timeout.tv_usec = 0;
  result = select (fd + 1, &readfds, (fd_set *)NULL, &exceptfds, &timeout);
  return ((result <= 0) ? 0 : 1);
#endif

#if defined (FIONREAD)
  errno = 0;
  result = ioctl (fd, FIONREAD, &chars_avail);
  if (result == -1 && errno == EIO)
    return -1;
  return (chars_avail);
#endif

  return 0;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\input_avail.c:68
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\input_avail.c:105
parsing error 
{
  int result, chars_avail;
#if defined(HAVE_SELECT)
  fd_set readfds, exceptfds;
#endif
#if defined (HAVE_PSELECT)
  sigset_t set, oset;
#endif

  if (fd < 0 || nchars < 0)
    return -1;
  if (nchars == 0)
    return (input_avail (fd));

  chars_avail = 0;

#if defined (HAVE_SELECT)
  FD_ZERO (&readfds);
  FD_ZERO (&exceptfds);
  FD_SET (fd, &readfds);
  FD_SET (fd, &exceptfds);
#endif
#if defined (HAVE_SELECT) || defined (HAVE_PSELECT)
  sigprocmask (SIG_BLOCK, (sigset_t *)NULL, &set);
#  ifdef SIGCHLD
  sigaddset (&set, SIGCHLD);
#  endif
  sigemptyset (&oset);
#endif

  while (1)
    {
      result = 0;
#if defined (HAVE_PSELECT)
      /* XXX - use pselect(2) to block SIGCHLD atomically */
      result = pselect (fd + 1, &readfds, (fd_set *)NULL, &exceptfds, (struct timespec *)NULL, &set);
#elif defined (HAVE_SELECT)
      sigprocmask (SIG_BLOCK, &set, &oset);
      result = select (fd + 1, &readfds, (fd_set *)NULL, &exceptfds, (struct timeval *)NULL);
      sigprocmask (SIG_BLOCK, &oset, (sigset_t *)NULL);
#endif
      if (result < 0)
        return -1;

#if defined (FIONREAD)
      errno = 0;
      result = ioctl (fd, FIONREAD, &chars_avail);
      if (result == -1 && errno == EIO)
        return -1;
      if (chars_avail >= nchars)
        break;
#else
      break;
#endif
    }

  return 0;
}
warning: parse error {
  int result, chars_avail;
#if defined(HAVE_SELECT)
  fd_set readfds, exceptfds;
#endif
#if defined (HAVE_PSELECT)
  sigset_t set, oset;
#endif

  if (fd < 0 || nchars < 0)
    return -1;
  if (nchars == 0)
    return (input_avail (fd));

  chars_avail = 0;

#if defined (HAVE_SELECT)
  FD_ZERO (&readfds);
  FD_ZERO (&exceptfds);
  FD_SET (fd, &readfds);
  FD_SET (fd, &exceptfds);
#endif
#if defined (HAVE_SELECT) || defined (HAVE_PSELECT)
  sigprocmask (SIG_BLOCK, (sigset_t *)NULL, &set);
#  ifdef SIGCHLD
  sigaddset (&set, SIGCHLD);
#  endif
  sigemptyset (&oset);
#endif

  while (1)
    {
      result = 0;
#if defined (HAVE_PSELECT)
      /* XXX - use pselect(2) to block SIGCHLD atomically */
      result = pselect (fd + 1, &readfds, (fd_set *)NULL, &exceptfds, (struct timespec *)NULL, &set);
#elif defined (HAVE_SELECT)
      sigprocmask (SIG_BLOCK, &set, &oset);
      result = select (fd + 1, &readfds, (fd_set *)NULL, &exceptfds, (struct timeval *)NULL);
      sigprocmask (SIG_BLOCK, &oset, (sigset_t *)NULL);
#endif
      if (result < 0)
        return -1;

#if defined (FIONREAD)
      errno = 0;
      result = ioctl (fd, FIONREAD, &chars_avail);
      if (result == -1 && errno == EIO)
        return -1;
      if (chars_avail >= nchars)
        break;
#else
      break;
#endif
    }

  return 0;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\input_avail.c:108
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\itos.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashansi.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\shell.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\itos.c:33
parsing error 
{
  return (fmtumax (i, 10, buf, len, 0));
}
warning: parse error {
  return (fmtumax (i, 10, buf, len, 0));
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\itos.c:37
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\itos.c:44
parsing error 
{
  char *p, lbuf[INT_STRLEN_BOUND(intmax_t) + 1];

  p = fmtumax (i, 10, lbuf, sizeof(lbuf), 0);
  return (savestring (p));
}
warning: parse error {
  char *p, lbuf[INT_STRLEN_BOUND(intmax_t) + 1];

  p = fmtumax (i, 10, lbuf, sizeof(lbuf), 0);
  return (savestring (p));
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\itos.c:46
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\itos.c:56
parsing error 
{
  char *p, lbuf[INT_STRLEN_BOUND(intmax_t) + 1];

  p = fmtumax (i, 10, lbuf, sizeof(lbuf), 0);
  return (strdup (p));
}
warning: parse error {
  char *p, lbuf[INT_STRLEN_BOUND(intmax_t) + 1];

  p = fmtumax (i, 10, lbuf, sizeof(lbuf), 0);
  return (strdup (p));
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\itos.c:58
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\itos.c:66
parsing error 
{
  return (fmtumax (i, 10, buf, len, FL_UNSIGNED));
}
warning: parse error {
  return (fmtumax (i, 10, buf, len, FL_UNSIGNED));
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\itos.c:70
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\itos.c:77
parsing error 
{
  char *p, lbuf[INT_STRLEN_BOUND(uintmax_t) + 1];

  p = fmtumax (i, 10, lbuf, sizeof(lbuf), FL_UNSIGNED);
  return (savestring (p));
}
warning: parse error {
  char *p, lbuf[INT_STRLEN_BOUND(uintmax_t) + 1];

  p = fmtumax (i, 10, lbuf, sizeof(lbuf), FL_UNSIGNED);
  return (savestring (p));
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\itos.c:79
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\mailstat.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashtypes.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\posixstat.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\posixdir.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashansi.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\maxpath.h...skip
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\mailstat.c:56
parsing error 
{
  static struct stat st_new_last, st_ret_last;
  struct stat st_ret, st_tmp;
  DIR *dd;
  struct dirent *fn;
  char dir[PATH_MAX * 2], file[PATH_MAX * 2 + 1];
  int i, l;
  time_t atime, mtime;

  atime = mtime = 0;

  /* First see if it's a directory. */
  if ((i = stat(path, st)) != 0 || S_ISDIR(st->st_mode) == 0)
    return i;

  if (strlen(path) > sizeof(dir) - 5)
    {
#ifdef ENAMETOOLONG
      errno = ENAMETOOLONG;
#else
      errno = EINVAL;
#endif
      return -1;
    }

  st_ret = *st;
  st_ret.st_nlink = 1;
  st_ret.st_size  = 0;
#ifdef HAVE_STRUCT_STAT_ST_BLOCKS
  st_ret.st_blocks  = 0;
#else
  st_ret.st_nlink = 0;
#endif
  st_ret.st_mode  &= ~S_IFDIR;
  st_ret.st_mode  |= S_IFREG;

  /* See if cur/ is present */
  sprintf(dir, "%s/cur", path);
  if (stat(dir, &st_tmp) || S_ISDIR(st_tmp.st_mode) == 0)
    return 0;
  st_ret.st_atime = st_tmp.st_atime;

  /* See if tmp/ is present */
  sprintf(dir, "%s/tmp", path);
  if (stat(dir, &st_tmp) || S_ISDIR(st_tmp.st_mode) == 0)
    return 0;
  st_ret.st_mtime = st_tmp.st_mtime;

  /* And new/ */
  sprintf(dir, "%s/new", path);
  if (stat(dir, &st_tmp) || S_ISDIR(st_tmp.st_mode) == 0)
    return 0;
  st_ret.st_mtime = st_tmp.st_mtime;

  /* Optimization - if new/ didn't change, nothing else did. */
  if (st_tmp.st_dev == st_new_last.st_dev &&
      st_tmp.st_ino == st_new_last.st_ino &&
      st_tmp.st_atime == st_new_last.st_atime &&
      st_tmp.st_mtime == st_new_last.st_mtime)
    {
      *st = st_ret_last;
      return 0;
    }
  st_new_last = st_tmp;

  /* Loop over new/ and cur/ */
  for (i = 0; i < 2; i++)
    {
      sprintf(dir, "%s/%s", path, i ? "cur" : "new");
      sprintf(file, "%s/", dir);
      l = strlen(file);
      if ((dd = opendir(dir)) == NULL)
	return 0;
      while ((fn = readdir(dd)) != NULL)
	{
	  if (fn->d_name[0] == '.' || strlen(fn->d_name) + l >= sizeof(file))
	    continue;
	  strcpy(file + l, fn->d_name);
	  if (stat(file, &st_tmp) != 0)
	    continue;
	  st_ret.st_size += st_tmp.st_size;
#ifdef HAVE_STRUCT_STAT_ST_BLOCKS
	  st_ret.st_blocks++;
#else
	  st_ret.st_nlink++;
#endif
	  if (st_tmp.st_atime != st_tmp.st_mtime && st_tmp.st_atime > atime)
	    atime = st_tmp.st_atime;
	  if (st_tmp.st_mtime > mtime)
	    mtime = st_tmp.st_mtime;
	}
      closedir(dd);
    }

/*  if (atime) */	/* Set atime even if cur/ is empty */
      st_ret.st_atime = atime;
    if (mtime)
      st_ret.st_mtime = mtime;

    *st = st_ret_last = st_ret;
    return 0;
}
warning: parse error {
  static struct stat st_new_last, st_ret_last;
  struct stat st_ret, st_tmp;
  DIR *dd;
  struct dirent *fn;
  char dir[PATH_MAX * 2], file[PATH_MAX * 2 + 1];
  int i, l;
  time_t atime, mtime;

  atime = mtime = 0;

  /* First see if it's a directory. */
  if ((i = stat(path, st)) != 0 || S_ISDIR(st->st_mode) == 0)
    return i;

  if (strlen(path) > sizeof(dir) - 5)
    {
#ifdef ENAMETOOLONG
      errno = ENAMETOOLONG;
#else
      errno = EINVAL;
#endif
      return -1;
    }

  st_ret = *st;
  st_ret.st_nlink = 1;
  st_ret.st_size  = 0;
#ifdef HAVE_STRUCT_STAT_ST_BLOCKS
  st_ret.st_blocks  = 0;
#else
  st_ret.st_nlink = 0;
#endif
  st_ret.st_mode  &= ~S_IFDIR;
  st_ret.st_mode  |= S_IFREG;

  /* See if cur/ is present */
  sprintf(dir, "%s/cur", path);
  if (stat(dir, &st_tmp) || S_ISDIR(st_tmp.st_mode) == 0)
    return 0;
  st_ret.st_atime = st_tmp.st_atime;

  /* See if tmp/ is present */
  sprintf(dir, "%s/tmp", path);
  if (stat(dir, &st_tmp) || S_ISDIR(st_tmp.st_mode) == 0)
    return 0;
  st_ret.st_mtime = st_tmp.st_mtime;

  /* And new/ */
  sprintf(dir, "%s/new", path);
  if (stat(dir, &st_tmp) || S_ISDIR(st_tmp.st_mode) == 0)
    return 0;
  st_ret.st_mtime = st_tmp.st_mtime;

  /* Optimization - if new/ didn't change, nothing else did. */
  if (st_tmp.st_dev == st_new_last.st_dev &&
      st_tmp.st_ino == st_new_last.st_ino &&
      st_tmp.st_atime == st_new_last.st_atime &&
      st_tmp.st_mtime == st_new_last.st_mtime)
    {
      *st = st_ret_last;
      return 0;
    }
  st_new_last = st_tmp;

  /* Loop over new/ and cur/ */
  for (i = 0; i < 2; i++)
    {
      sprintf(dir, "%s/%s", path, i ? "cur" : "new");
      sprintf(file, "%s/", dir);
      l = strlen(file);
      if ((dd = opendir(dir)) == NULL)
	return 0;
      while ((fn = readdir(dd)) != NULL)
	{
	  if (fn->d_name[0] == '.' || strlen(fn->d_name) + l >= sizeof(file))
	    continue;
	  strcpy(file + l, fn->d_name);
	  if (stat(file, &st_tmp) != 0)
	    continue;
	  st_ret.st_size += st_tmp.st_size;
#ifdef HAVE_STRUCT_STAT_ST_BLOCKS
	  st_ret.st_blocks++;
#else
	  st_ret.st_nlink++;
#endif
	  if (st_tmp.st_atime != st_tmp.st_mtime && st_tmp.st_atime > atime)
	    atime = st_tmp.st_atime;
	  if (st_tmp.st_mtime > mtime)
	    mtime = st_tmp.st_mtime;
	}
      closedir(dd);
    }

/*  if (atime) */	/* Set atime even if cur/ is empty */
      st_ret.st_atime = atime;
    if (mtime)
      st_ret.st_mtime = mtime;

    *st = st_ret_last = st_ret;
    return 0;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\mailstat.c:58
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\makepath.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashansi.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\shell.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\tilde\tilde.h...skip
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\makepath.c:71
parsing error 
{
  int dirlen, pathlen;
  char *ret, *xpath, *xdir, *r, *s;

  if (path == 0 || *path == '\0')
    {
      if (flags & MP_DOCWD)
	{
	  xpath = get_working_directory ("sh_makepath");
	  if (xpath == 0)
	    {
	      ret = get_string_value ("PWD");
	      if (ret)
		xpath = savestring (ret);
	    }
	  if (xpath == 0)
	    MAKEDOT();
	  else
	    pathlen = strlen (xpath);
	}
      else
	MAKEDOT();
    }
  else if ((flags & MP_IGNDOT) && path[0] == '.' && (path[1] == '\0' ||
						     (path[1] == '/' && path[2] == '\0')))
    {
      xpath = nullpath;
      pathlen = 0;
    }
  else
    {
      xpath = ((flags & MP_DOTILDE) && *path == '~') ? bash_tilde_expand (path, 0) : (char *)path;
      pathlen = strlen (xpath);
    }

  xdir = (char *)dir;
  dirlen = strlen (xdir);
  if ((flags & MP_RMDOT) && dir[0] == '.' && dir[1] == '/')
    {
      xdir += 2;
      dirlen -= 2;
    }

  r = ret = (char *)xmalloc (2 + dirlen + pathlen);
  s = xpath;
  while (*s)
    *r++ = *s++;
  if (s > xpath && s[-1] != '/')
    *r++ = '/';      
  s = xdir;
  while (*r++ = *s++)
    ;
  if (xpath != path && xpath != nullpath)
    free (xpath);
  return (ret);
}
warning: parse error {
  int dirlen, pathlen;
  char *ret, *xpath, *xdir, *r, *s;

  if (path == 0 || *path == '\0')
    {
      if (flags & MP_DOCWD)
	{
	  xpath = get_working_directory ("sh_makepath");
	  if (xpath == 0)
	    {
	      ret = get_string_value ("PWD");
	      if (ret)
		xpath = savestring (ret);
	    }
	  if (xpath == 0)
	    MAKEDOT();
	  else
	    pathlen = strlen (xpath);
	}
      else
	MAKEDOT();
    }
  else if ((flags & MP_IGNDOT) && path[0] == '.' && (path[1] == '\0' ||
						     (path[1] == '/' && path[2] == '\0')))
    {
      xpath = nullpath;
      pathlen = 0;
    }
  else
    {
      xpath = ((flags & MP_DOTILDE) && *path == '~') ? bash_tilde_expand (path, 0) : (char *)path;
      pathlen = strlen (xpath);
    }

  xdir = (char *)dir;
  dirlen = strlen (xdir);
  if ((flags & MP_RMDOT) && dir[0] == '.' && dir[1] == '/')
    {
      xdir += 2;
      dirlen -= 2;
    }

  r = ret = (char *)xmalloc (2 + dirlen + pathlen);
  s = xpath;
  while (*s)
    *r++ = *s++;
  if (s > xpath && s[-1] != '/')
    *r++ = '/';      
  s = xdir;
  while (*r++ = *s++)
    ;
  if (xpath != path && xpath != nullpath)
    free (xpath);
  return (ret);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\makepath.c:73
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\mbscasecmp.c...
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\mbschr.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashansi.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\shmbutil.h...skip
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\mbschr.c:46
parsing error 
{
#if HANDLE_MULTIBYTE
  char *pos;
  mbstate_t state;
  size_t strlength, mblength;

  if (locale_utf8locale && c < 0x80)
    return (utf8_mbschr (s, c));		/* XXX */

  /* The locale encodings with said weird property are BIG5, BIG5-HKSCS,
     GBK, GB18030, SHIFT_JIS, and JOHAB.  They exhibit the problem only
     when c >= 0x30.  We can therefore use the faster bytewise search if
     c <= 0x30. */
  if ((unsigned char)c >= '0' && locale_mb_cur_max > 1)
    {
      pos = (char *)s;
      memset (&state, '\0', sizeof(mbstate_t));
      strlength = strlen (s);

      while (strlength > 0)
	{
	  if (is_basic (*pos))
	    mblength = 1;
	  else
	    {
	      mblength = mbrlen (pos, strlength, &state);
	      if (mblength == (size_t)-2 || mblength == (size_t)-1 || mblength == (size_t)0)
	        mblength = 1;
	    }

	  if (mblength == 1 && c == (unsigned char)*pos)
	    return pos;

	  strlength -= mblength;
	  pos += mblength;
	}

      return ((char *)NULL);
    }
  else
#endif
  return (strchr (s, c));
}
warning: parse error {
#if HANDLE_MULTIBYTE
  char *pos;
  mbstate_t state;
  size_t strlength, mblength;

  if (locale_utf8locale && c < 0x80)
    return (utf8_mbschr (s, c));		/* XXX */

  /* The locale encodings with said weird property are BIG5, BIG5-HKSCS,
     GBK, GB18030, SHIFT_JIS, and JOHAB.  They exhibit the problem only
     when c >= 0x30.  We can therefore use the faster bytewise search if
     c <= 0x30. */
  if ((unsigned char)c >= '0' && locale_mb_cur_max > 1)
    {
      pos = (char *)s;
      memset (&state, '\0', sizeof(mbstate_t));
      strlength = strlen (s);

      while (strlength > 0)
	{
	  if (is_basic (*pos))
	    mblength = 1;
	  else
	    {
	      mblength = mbrlen (pos, strlength, &state);
	      if (mblength == (size_t)-2 || mblength == (size_t)-1 || mblength == (size_t)0)
	        mblength = 1;
	    }

	  if (mblength == 1 && c == (unsigned char)*pos)
	    return pos;

	  strlength -= mblength;
	  pos += mblength;
	}

      return ((char *)NULL);
    }
  else
#endif
  return (strchr (s, c));
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\mbschr.c:49
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\mbscmp.c...
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\memset.c...
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\mktime.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashansi.h...skip
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\mktime.c:129
parsing error 
{
  struct tm *l = localtime (t);
  if (! l)
    return 0;
  *tp = *l;
  return tp;
}
warning: parse error {
  struct tm *l = localtime (t);
  if (! l)
    return 0;
  *tp = *l;
  return tp;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\mktime.c:131
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\mktime.c:146
parsing error 
{
  /* Compute intervening leap days correctly even if year is negative.
     Take care to avoid int overflow.  time_t overflow is OK, since
     only the low order bits of the correct time_t answer are needed.
     Don't convert to time_t until after all divisions are done, since
     time_t might be unsigned.  */
  int a4 = (year >> 2) + (TM_YEAR_BASE >> 2) - ! (year & 3);
  int b4 = (tp->tm_year >> 2) + (TM_YEAR_BASE >> 2) - ! (tp->tm_year & 3);
  int a100 = a4 / 25 - (a4 % 25 < 0);
  int b100 = b4 / 25 - (b4 % 25 < 0);
  int a400 = a100 >> 2;
  int b400 = b100 >> 2;
  int intervening_leap_days = (a4 - b4) - (a100 - b100) + (a400 - b400);
  time_t years = year - (time_t) tp->tm_year;
  time_t days = (365 * years + intervening_leap_days
		 + (yday - tp->tm_yday));
  return (60 * (60 * (24 * days + (hour - tp->tm_hour))
		+ (min - tp->tm_min))
	  + (sec - tp->tm_sec));
}
warning: parse error {
  /* Compute intervening leap days correctly even if year is negative.
     Take care to avoid int overflow.  time_t overflow is OK, since
     only the low order bits of the correct time_t answer are needed.
     Don't convert to time_t until after all divisions are done, since
     time_t might be unsigned.  */
  int a4 = (year >> 2) + (TM_YEAR_BASE >> 2) - ! (year & 3);
  int b4 = (tp->tm_year >> 2) + (TM_YEAR_BASE >> 2) - ! (tp->tm_year & 3);
  int a100 = a4 / 25 - (a4 % 25 < 0);
  int b100 = b4 / 25 - (b4 % 25 < 0);
  int a400 = a100 >> 2;
  int b400 = b100 >> 2;
  int intervening_leap_days = (a4 - b4) - (a100 - b100) + (a400 - b400);
  time_t years = year - (time_t) tp->tm_year;
  time_t days = (365 * years + intervening_leap_days
		 + (yday - tp->tm_yday));
  return (60 * (60 * (24 * days + (hour - tp->tm_hour))
		+ (min - tp->tm_min))
	  + (sec - tp->tm_sec));
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\mktime.c:149
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\mktime.c:175
parsing error 
{
#ifdef _LIBC
  /* POSIX.1 8.1.1 requires that whenever mktime() is called, the
     time zone names contained in the external variable `tzname' shall
     be set as if the tzset() function had been called.  */
  __tzset ();
#endif

  return __mktime_internal (tp, my_localtime_r, &localtime_offset);
}
warning: parse error {
#ifdef _LIBC
  /* POSIX.1 8.1.1 requires that whenever mktime() is called, the
     time zone names contained in the external variable `tzname' shall
     be set as if the tzset() function had been called.  */
  __tzset ();
#endif

  return __mktime_internal (tp, my_localtime_r, &localtime_offset);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\mktime.c:177
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\mktime.c:194
parsing error 
{
  time_t t, dt, t0;
  struct tm tm;

  /* The maximum number of probes (calls to CONVERT) should be enough
     to handle any combinations of time zone rule changes, solar time,
     and leap seconds.  Posix.1 prohibits leap seconds, but some hosts
     have them anyway.  */
  int remaining_probes = 4;

  /* Time requested.  Copy it in case CONVERT modifies *TP; this can
     occur if TP is localtime's returned value and CONVERT is localtime.  */
  int sec = tp->tm_sec;
  int min = tp->tm_min;
  int hour = tp->tm_hour;
  int mday = tp->tm_mday;
  int mon = tp->tm_mon;
  int year_requested = tp->tm_year;
  int isdst = tp->tm_isdst;

  /* Ensure that mon is in range, and set year accordingly.  */
  int mon_remainder = mon % 12;
  int negative_mon_remainder = mon_remainder < 0;
  int mon_years = mon / 12 - negative_mon_remainder;
  int year = year_requested + mon_years;

  /* The other values need not be in range:
     the remaining code handles minor overflows correctly,
     assuming int and time_t arithmetic wraps around.
     Major overflows are caught at the end.  */

  /* Calculate day of year from year, month, and day of month.
     The result need not be in range.  */
  int yday = ((__mon_yday[__isleap (year + TM_YEAR_BASE)]
	       [mon_remainder + 12 * negative_mon_remainder])
	      + mday - 1);

#if LEAP_SECONDS_POSSIBLE
  /* Handle out-of-range seconds specially,
     since ydhms_tm_diff assumes every minute has 60 seconds.  */
  int sec_requested = sec;
  if (sec < 0)
    sec = 0;
  if (59 < sec)
    sec = 59;
#endif

  /* Invert CONVERT by probing.  First assume the same offset as last time.
     Then repeatedly use the error to improve the guess.  */

  tm.tm_year = EPOCH_YEAR - TM_YEAR_BASE;
  tm.tm_yday = tm.tm_hour = tm.tm_min = tm.tm_sec = 0;
  t0 = ydhms_tm_diff (year, yday, hour, min, sec, &tm);

  for (t = t0 + *offset;
       (dt = ydhms_tm_diff (year, yday, hour, min, sec, (*convert) (&t, &tm)));
       t += dt)
    if (--remaining_probes == 0)
      return -1;

  /* Check whether tm.tm_isdst has the requested value, if any.  */
  if (0 <= isdst && 0 <= tm.tm_isdst)
    {
      int dst_diff = (isdst != 0) - (tm.tm_isdst != 0);
      if (dst_diff)
	{
	  /* Move two hours in the direction indicated by the disagreement,
	     probe some more, and switch to a new time if found.
	     The largest known fallback due to daylight savings is two hours:
	     once, in Newfoundland, 1988-10-30 02:00 -> 00:00.  */
	  time_t ot = t - 2 * 60 * 60 * dst_diff;
	  while (--remaining_probes != 0)
	    {
	      struct tm otm;
	      if (! (dt = ydhms_tm_diff (year, yday, hour, min, sec,
					 (*convert) (&ot, &otm))))
		{
		  t = ot;
		  tm = otm;
		  break;
		}
	      if ((ot += dt) == t)
		break;  /* Avoid a redundant probe.  */
	    }
	}
    }

  *offset = t - t0;

#if LEAP_SECONDS_POSSIBLE
  if (sec_requested != tm.tm_sec)
    {
      /* Adjust time to reflect the tm_sec requested, not the normalized value.
	 Also, repair any damage from a false match due to a leap second.  */
      t += sec_requested - sec + (sec == 0 && tm.tm_sec == 60);
      (*convert) (&t, &tm);
    }
#endif

  if (TIME_T_MAX / INT_MAX / 366 / 24 / 60 / 60 < 3)
    {
      /* time_t isn't large enough to rule out overflows in ydhms_tm_diff,
	 so check for major overflows.  A gross check suffices,
	 since if t has overflowed, it is off by a multiple of
	 TIME_T_MAX - TIME_T_MIN + 1.  So ignore any component of
	 the difference that is bounded by a small value.  */

      double dyear = (double) year_requested + mon_years - tm.tm_year;
      double dday = 366 * dyear + mday;
      double dsec = 60 * (60 * (24 * dday + hour) + min) + sec_requested;

      if (TIME_T_MAX / 3 - TIME_T_MIN / 3 < (dsec < 0 ? - dsec : dsec))
	return -1;
    }

  *tp = tm;
  return t;
}
warning: parse error {
  time_t t, dt, t0;
  struct tm tm;

  /* The maximum number of probes (calls to CONVERT) should be enough
     to handle any combinations of time zone rule changes, solar time,
     and leap seconds.  Posix.1 prohibits leap seconds, but some hosts
     have them anyway.  */
  int remaining_probes = 4;

  /* Time requested.  Copy it in case CONVERT modifies *TP; this can
     occur if TP is localtime's returned value and CONVERT is localtime.  */
  int sec = tp->tm_sec;
  int min = tp->tm_min;
  int hour = tp->tm_hour;
  int mday = tp->tm_mday;
  int mon = tp->tm_mon;
  int year_requested = tp->tm_year;
  int isdst = tp->tm_isdst;

  /* Ensure that mon is in range, and set year accordingly.  */
  int mon_remainder = mon % 12;
  int negative_mon_remainder = mon_remainder < 0;
  int mon_years = mon / 12 - negative_mon_remainder;
  int year = year_requested + mon_years;

  /* The other values need not be in range:
     the remaining code handles minor overflows correctly,
     assuming int and time_t arithmetic wraps around.
     Major overflows are caught at the end.  */

  /* Calculate day of year from year, month, and day of month.
     The result need not be in range.  */
  int yday = ((__mon_yday[__isleap (year + TM_YEAR_BASE)]
	       [mon_remainder + 12 * negative_mon_remainder])
	      + mday - 1);

#if LEAP_SECONDS_POSSIBLE
  /* Handle out-of-range seconds specially,
     since ydhms_tm_diff assumes every minute has 60 seconds.  */
  int sec_requested = sec;
  if (sec < 0)
    sec = 0;
  if (59 < sec)
    sec = 59;
#endif

  /* Invert CONVERT by probing.  First assume the same offset as last time.
     Then repeatedly use the error to improve the guess.  */

  tm.tm_year = EPOCH_YEAR - TM_YEAR_BASE;
  tm.tm_yday = tm.tm_hour = tm.tm_min = tm.tm_sec = 0;
  t0 = ydhms_tm_diff (year, yday, hour, min, sec, &tm);

  for (t = t0 + *offset;
       (dt = ydhms_tm_diff (year, yday, hour, min, sec, (*convert) (&t, &tm)));
       t += dt)
    if (--remaining_probes == 0)
      return -1;

  /* Check whether tm.tm_isdst has the requested value, if any.  */
  if (0 <= isdst && 0 <= tm.tm_isdst)
    {
      int dst_diff = (isdst != 0) - (tm.tm_isdst != 0);
      if (dst_diff)
	{
	  /* Move two hours in the direction indicated by the disagreement,
	     probe some more, and switch to a new time if found.
	     The largest known fallback due to daylight savings is two hours:
	     once, in Newfoundland, 1988-10-30 02:00 -> 00:00.  */
	  time_t ot = t - 2 * 60 * 60 * dst_diff;
	  while (--remaining_probes != 0)
	    {
	      struct tm otm;
	      if (! (dt = ydhms_tm_diff (year, yday, hour, min, sec,
					 (*convert) (&ot, &otm))))
		{
		  t = ot;
		  tm = otm;
		  break;
		}
	      if ((ot += dt) == t)
		break;  /* Avoid a redundant probe.  */
	    }
	}
    }

  *offset = t - t0;

#if LEAP_SECONDS_POSSIBLE
  if (sec_requested != tm.tm_sec)
    {
      /* Adjust time to reflect the tm_sec requested, not the normalized value.
	 Also, repair any damage from a false match due to a leap second.  */
      t += sec_requested - sec + (sec == 0 && tm.tm_sec == 60);
      (*convert) (&t, &tm);
    }
#endif

  if (TIME_T_MAX / INT_MAX / 366 / 24 / 60 / 60 < 3)
    {
      /* time_t isn't large enough to rule out overflows in ydhms_tm_diff,
	 so check for major overflows.  A gross check suffices,
	 since if t has overflowed, it is off by a multiple of
	 TIME_T_MAX - TIME_T_MIN + 1.  So ignore any component of
	 the difference that is bounded by a small value.  */

      double dyear = (double) year_requested + mon_years - tm.tm_year;
      double dday = 366 * dyear + mday;
      double dsec = 60 * (60 * (24 * dday + hour) + min) + sec_requested;

      if (TIME_T_MAX / 3 - TIME_T_MIN / 3 < (dsec < 0 ? - dsec : dsec))
	return -1;
    }

  *tp = tm;
  return t;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\mktime.c:198
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\netconn.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashtypes.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\posixstat.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\filecntl.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\netconn.c:44
parsing error 
{
#if defined (HAVE_SYS_SOCKET_H) && defined (HAVE_GETPEERNAME) && !defined (SVR4_2) && !defined (__BEOS__)
  int rv;
  socklen_t l;
  struct sockaddr sa;

  l = sizeof(sa);
  rv = getpeername(fd, &sa, &l);
  /* Posix.2 says getpeername can return these errors. */
  return ((rv < 0 && (errno == ENOTSOCK || errno == ENOTCONN || errno == EINVAL || errno == EBADF)) ? 0 : 1);
#else /* !HAVE_GETPEERNAME || SVR4_2 || __BEOS__ */
#  if defined (SVR4) || defined (SVR4_2)
  /* Sockets on SVR4 and SVR4.2 are character special (streams) devices. */
  struct stat sb;

  if (isatty (fd))
    return (0);
  if (fstat (fd, &sb) < 0)
    return (0);
#    if defined (S_ISFIFO)
  if (S_ISFIFO (sb.st_mode))
    return (0);
#    endif /* S_ISFIFO */
  return (S_ISCHR (sb.st_mode));
#  else /* !SVR4 && !SVR4_2 */
#    if defined (S_ISSOCK) && !defined (__BEOS__)
  struct stat sb;

  if (fstat (fd, &sb) < 0)
    return (0);
  return (S_ISSOCK (sb.st_mode));
#    else /* !S_ISSOCK || __BEOS__ */
  return (0);
#    endif /* !S_ISSOCK || __BEOS__ */
#  endif /* !SVR4 && !SVR4_2 */
#endif /* !HAVE_GETPEERNAME || SVR4_2 || __BEOS__ */
}
warning: parse error {
#if defined (HAVE_SYS_SOCKET_H) && defined (HAVE_GETPEERNAME) && !defined (SVR4_2) && !defined (__BEOS__)
  int rv;
  socklen_t l;
  struct sockaddr sa;

  l = sizeof(sa);
  rv = getpeername(fd, &sa, &l);
  /* Posix.2 says getpeername can return these errors. */
  return ((rv < 0 && (errno == ENOTSOCK || errno == ENOTCONN || errno == EINVAL || errno == EBADF)) ? 0 : 1);
#else /* !HAVE_GETPEERNAME || SVR4_2 || __BEOS__ */
#  if defined (SVR4) || defined (SVR4_2)
  /* Sockets on SVR4 and SVR4.2 are character special (streams) devices. */
  struct stat sb;

  if (isatty (fd))
    return (0);
  if (fstat (fd, &sb) < 0)
    return (0);
#    if defined (S_ISFIFO)
  if (S_ISFIFO (sb.st_mode))
    return (0);
#    endif /* S_ISFIFO */
  return (S_ISCHR (sb.st_mode));
#  else /* !SVR4 && !SVR4_2 */
#    if defined (S_ISSOCK) && !defined (__BEOS__)
  struct stat sb;

  if (fstat (fd, &sb) < 0)
    return (0);
  return (S_ISSOCK (sb.st_mode));
#    else /* !S_ISSOCK || __BEOS__ */
  return (0);
#    endif /* !S_ISSOCK || __BEOS__ */
#  endif /* !SVR4 && !SVR4_2 */
#endif /* !HAVE_GETPEERNAME || SVR4_2 || __BEOS__ */
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\netconn.c:46
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\netopen.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashansi.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashintl.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\shell.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\xmalloc.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\netopen.c:344
parsing error 
{
  internal_error (_("network operations not supported"));
  return -1;
}
warning: parse error {
  internal_error (_("network operations not supported"));
  return -1;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\netopen.c:346
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\oslib.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashtypes.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\posixstat.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\filecntl.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashansi.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\chartypes.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\shell.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\oslib.c:57
parsing error 
{
  register char *s;

  for (s = string; s && *s; s++)
    if (*s == c)
      return (s);

  return ((char *) NULL);
}
warning: parse error {
  register char *s;

  for (s = string; s && *s; s++)
    if (*s == c)
      return (s);

  return ((char *) NULL);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\oslib.c:60
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\oslib.c:71
parsing error 
{
  register char *s, *t;

  for (s = string, t = (char *)NULL; s && *s; s++)
    if (*s == c)
      t = s;
  return (t);
}
warning: parse error {
  register char *s, *t;

  for (s = string, t = (char *)NULL; s && *s; s++)
    if (*s == c)
      t = s;
  return (t);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\oslib.c:74
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\oslib.c:88
parsing error 
{
  int saved_errno, r;

  /* If FD1 is not a valid file descriptor, then return immediately with
     an error. */
  if (fcntl (fd1, F_GETFL, 0) == -1)
    return (-1);

  if (fd2 < 0 || fd2 >= getdtablesize ())
    {
      errno = EBADF;
      return (-1);
    }

  if (fd1 == fd2)
    return (0);

  saved_errno = errno;

  (void) close (fd2);
  r = fcntl (fd1, F_DUPFD, fd2);

  if (r >= 0)
    errno = saved_errno;
  else
    if (errno == EINVAL)
      errno = EBADF;

  /* Force the new file descriptor to remain open across exec () calls. */
  SET_OPEN_ON_EXEC (fd2);
  return (r);
}
warning: parse error {
  int saved_errno, r;

  /* If FD1 is not a valid file descriptor, then return immediately with
     an error. */
  if (fcntl (fd1, F_GETFL, 0) == -1)
    return (-1);

  if (fd2 < 0 || fd2 >= getdtablesize ())
    {
      errno = EBADF;
      return (-1);
    }

  if (fd1 == fd2)
    return (0);

  saved_errno = errno;

  (void) close (fd2);
  r = fcntl (fd1, F_DUPFD, fd2);

  if (r >= 0)
    errno = saved_errno;
  else
    if (errno == EINVAL)
      errno = EBADF;

  /* Force the new file descriptor to remain open across exec () calls. */
  SET_OPEN_ON_EXEC (fd2);
  return (r);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\oslib.c:90
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\oslib.c:169
parsing error 
{
  FASTCOPY (s, d, n);
}
warning: parse error {
  FASTCOPY (s, d, n);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\oslib.c:172
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\oslib.c:182
parsing error 
{
  register int i;
  register char *r;

  for (i = 0, r = s; i < n; i++)
    *r++ = '\0';
}
warning: parse error {
  register int i;
  register char *r;

  for (i = 0, r = s; i < n; i++)
    *r++ = '\0';
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\oslib.c:185
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\oslib.c:215
parsing error 
{
  strncpy (name, "unknown", namelen);
  name[namelen] = '\0';
  return 0;
}
warning: parse error {
  strncpy (name, "unknown", namelen);
  name[namelen] = '\0';
  return 0;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\oslib.c:218
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\oslib.c:228
parsing error 
{
  return (kill (-pgrp, sig));
}
warning: parse error {
  return (kill (-pgrp, sig));
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\oslib.c:231
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\pathcanon.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashtypes.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\posixstat.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\filecntl.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashansi.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\chartypes.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\shell.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\pathcanon.c:75
parsing error 
{
  int l;
  struct stat sb;

  /* This should leave errno set to the correct value. */
  errno = 0;
  l = stat (path, &sb) == 0 && S_ISDIR (sb.st_mode);
#if defined (__CYGWIN__)
  if (l == 0)
    l = _is_cygdrive (path);
#endif
  return l;
}
warning: parse error {
  int l;
  struct stat sb;

  /* This should leave errno set to the correct value. */
  errno = 0;
  l = stat (path, &sb) == 0 && S_ISDIR (sb.st_mode);
#if defined (__CYGWIN__)
  if (l == 0)
    l = _is_cygdrive (path);
#endif
  return l;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\pathcanon.c:77
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\pathcanon.c:104
parsing error 
{
  char stub_char;
  char *result, *p, *q, *base, *dotdot;
  int rooted, double_slash_path;

  /* The result cannot be larger than the input PATH. */
  result = (flags & PATH_NOALLOC) ? path : savestring (path);

  /* POSIX.2 says to leave a leading `//' alone.  On cygwin, we skip over any
     leading `x:' (dos drive name). */
  if (rooted = ROOTEDPATH(path))
    {
      stub_char = DIRSEP;
#if defined (__CYGWIN__)
      base = (ISALPHA((unsigned char)result[0]) && result[1] == ':') ? result + 3 : result + 1;
#else
      base = result + 1;
#endif
      double_slash_path = DOUBLE_SLASH (path);
      base += double_slash_path;
    }
  else
    {
      stub_char = '.';
#if defined (__CYGWIN__)
      base = (ISALPHA((unsigned char)result[0]) && result[1] == ':') ? result + 2 : result;
#else
      base = result;
#endif
      double_slash_path = 0;
    }

  /*
   * invariants:
   *	  base points to the portion of the path we want to modify
   *      p points at beginning of path element we're considering.
   *      q points just past the last path element we wrote (no slash).
   *      dotdot points just past the point where .. cannot backtrack
   *	  any further (no slash).
   */
  p = q = dotdot = base;

  while (*p)
    {
      if (ISDIRSEP(p[0])) /* null element */
	p++;
      else if(p[0] == '.' && PATHSEP(p[1]))	/* . and ./ */
	p += 1; 	/* don't count the separator in case it is nul */
      else if (p[0] == '.' && p[1] == '.' && PATHSEP(p[2])) /* .. and ../ */
	{
	  p += 2; /* skip `..' */
	  if (q > dotdot)	/* can backtrack */
	    {
	      if (flags & PATH_CHECKDOTDOT)
		{
		  char c;

		  /* Make sure what we have so far corresponds to a valid
		     path before we chop some of it off. */
		  c = *q;
		  *q = '\0';
		  if (_path_isdir (result) == 0)
		    {
		      if ((flags & PATH_NOALLOC) == 0)
			free (result);
		      return ((char *)NULL);
		    }
		  *q = c;
		}

	      while (--q > dotdot && ISDIRSEP(*q) == 0)
		;
	    }
	  else if (rooted == 0)
	    {
	      /* /.. is / but ./../ is .. */
	      if (q != base)
		*q++ = DIRSEP;
	      *q++ = '.';
	      *q++ = '.';
	      dotdot = q;
	    }
	}
      else	/* real path element */
	{
	  /* add separator if not at start of work portion of result */
	  if (q != base)
	    *q++ = DIRSEP;
	  while (*p && (ISDIRSEP(*p) == 0))
	    *q++ = *p++;
	  /* Check here for a valid directory with _path_isdir. */
	  if (flags & PATH_CHECKEXISTS)
	    {
	      char c;

	      /* Make sure what we have so far corresponds to a valid
		 path before we chop some of it off. */
	      c = *q;
	      *q = '\0';
	      if (_path_isdir (result) == 0)
		{
		  if ((flags & PATH_NOALLOC) == 0)
		    free (result);
		  return ((char *)NULL);
		}
	      *q = c;
	    }
	}
    }

  /* Empty string is really ``.'' or `/', depending on what we started with. */
  if (q == result)
    *q++ = stub_char;
  *q = '\0';

  /* If the result starts with `//', but the original path does not, we
     can turn the // into /.  Because of how we set `base', this should never
     be true, but it's a sanity check. */
  if (DOUBLE_SLASH(result) && double_slash_path == 0)
    {
      if (result[2] == '\0')	/* short-circuit for bare `//' */
	result[1] = '\0';
      else
	memmove (result, result + 1, strlen (result + 1) + 1);
    }

  return (result);
}
warning: parse error {
  char stub_char;
  char *result, *p, *q, *base, *dotdot;
  int rooted, double_slash_path;

  /* The result cannot be larger than the input PATH. */
  result = (flags & PATH_NOALLOC) ? path : savestring (path);

  /* POSIX.2 says to leave a leading `//' alone.  On cygwin, we skip over any
     leading `x:' (dos drive name). */
  if (rooted = ROOTEDPATH(path))
    {
      stub_char = DIRSEP;
#if defined (__CYGWIN__)
      base = (ISALPHA((unsigned char)result[0]) && result[1] == ':') ? result + 3 : result + 1;
#else
      base = result + 1;
#endif
      double_slash_path = DOUBLE_SLASH (path);
      base += double_slash_path;
    }
  else
    {
      stub_char = '.';
#if defined (__CYGWIN__)
      base = (ISALPHA((unsigned char)result[0]) && result[1] == ':') ? result + 2 : result;
#else
      base = result;
#endif
      double_slash_path = 0;
    }

  /*
   * invariants:
   *	  base points to the portion of the path we want to modify
   *      p points at beginning of path element we're considering.
   *      q points just past the last path element we wrote (no slash).
   *      dotdot points just past the point where .. cannot backtrack
   *	  any further (no slash).
   */
  p = q = dotdot = base;

  while (*p)
    {
      if (ISDIRSEP(p[0])) /* null element */
	p++;
      else if(p[0] == '.' && PATHSEP(p[1]))	/* . and ./ */
	p += 1; 	/* don't count the separator in case it is nul */
      else if (p[0] == '.' && p[1] == '.' && PATHSEP(p[2])) /* .. and ../ */
	{
	  p += 2; /* skip `..' */
	  if (q > dotdot)	/* can backtrack */
	    {
	      if (flags & PATH_CHECKDOTDOT)
		{
		  char c;

		  /* Make sure what we have so far corresponds to a valid
		     path before we chop some of it off. */
		  c = *q;
		  *q = '\0';
		  if (_path_isdir (result) == 0)
		    {
		      if ((flags & PATH_NOALLOC) == 0)
			free (result);
		      return ((char *)NULL);
		    }
		  *q = c;
		}

	      while (--q > dotdot && ISDIRSEP(*q) == 0)
		;
	    }
	  else if (rooted == 0)
	    {
	      /* /.. is / but ./../ is .. */
	      if (q != base)
		*q++ = DIRSEP;
	      *q++ = '.';
	      *q++ = '.';
	      dotdot = q;
	    }
	}
      else	/* real path element */
	{
	  /* add separator if not at start of work portion of result */
	  if (q != base)
	    *q++ = DIRSEP;
	  while (*p && (ISDIRSEP(*p) == 0))
	    *q++ = *p++;
	  /* Check here for a valid directory with _path_isdir. */
	  if (flags & PATH_CHECKEXISTS)
	    {
	      char c;

	      /* Make sure what we have so far corresponds to a valid
		 path before we chop some of it off. */
	      c = *q;
	      *q = '\0';
	      if (_path_isdir (result) == 0)
		{
		  if ((flags & PATH_NOALLOC) == 0)
		    free (result);
		  return ((char *)NULL);
		}
	      *q = c;
	    }
	}
    }

  /* Empty string is really ``.'' or `/', depending on what we started with. */
  if (q == result)
    *q++ = stub_char;
  *q = '\0';

  /* If the result starts with `//', but the original path does not, we
     can turn the // into /.  Because of how we set `base', this should never
     be true, but it's a sanity check. */
  if (DOUBLE_SLASH(result) && double_slash_path == 0)
    {
      if (result[2] == '\0')	/* short-circuit for bare `//' */
	result[1] = '\0';
      else
	memmove (result, result + 1, strlen (result + 1) + 1);
    }

  return (result);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\pathcanon.c:107
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\pathphys.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashtypes.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\posixstat.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\filecntl.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashansi.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\chartypes.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\shell.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\pathphys.c:52
parsing error 
{
#ifdef HAVE_READLINK
  return readlink (path, buf, bufsiz);
#else
  errno = EINVAL;
  return -1;
#endif
}
warning: parse error {
#ifdef HAVE_READLINK
  return readlink (path, buf, bufsiz);
#else
  errno = EINVAL;
  return -1;
#endif
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\pathphys.c:56
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\pathphys.c:75
parsing error 
{
  char tbuf[PATH_MAX+1], linkbuf[PATH_MAX+1];
  char *result, *p, *q, *qsave, *qbase, *workpath;
  int double_slash_path, linklen, nlink;

  linklen = strlen (path);

#if 0
  /* First sanity check -- punt immediately if the name is too long. */
  if (linklen >= PATH_MAX)
    return (savestring (path));
#endif

  nlink = 0;
  q = result = (char *)xmalloc (PATH_MAX + 1);

  /* Even if we get something longer than PATH_MAX, we might be able to
     shorten it, so we try. */
  if (linklen >= PATH_MAX)
    workpath = savestring (path);
  else
    {
      workpath = (char *)xmalloc (PATH_MAX + 1);
      strcpy (workpath, path);
    }

  /* This always gets an absolute pathname. */

  /* POSIX.2 says to leave a leading `//' alone.  On cygwin, we skip over any
     leading `x:' (dos drive name). */
#if defined (__CYGWIN__)
  qbase = (ISALPHA((unsigned char)workpath[0]) && workpath[1] == ':') ? workpath + 3 : workpath + 1;
#else
  qbase = workpath + 1;
#endif
  double_slash_path = DOUBLE_SLASH (workpath);
  qbase += double_slash_path;

  for (p = workpath; p < qbase; )
    *q++ = *p++;
  qbase = q;

  /*
   * invariants:
   *	  qbase points to the portion of the result path we want to modify
   *      p points at beginning of path element we're considering.
   *      q points just past the last path element we wrote (no slash).
   *
   * XXX -- need to fix error checking for too-long pathnames
   */

  while (*p)
    {
      if (ISDIRSEP(p[0])) /* null element */
	p++;
      else if(p[0] == '.' && PATHSEP(p[1]))	/* . and ./ */
	p += 1; 	/* don't count the separator in case it is nul */
      else if (p[0] == '.' && p[1] == '.' && PATHSEP(p[2])) /* .. and ../ */
	{
	  p += 2; /* skip `..' */
	  if (q > qbase)
	    {
	      while (--q > qbase && ISDIRSEP(*q) == 0)
		;
	    }
	}
      else	/* real path element */
	{
	  /* add separator if not at start of work portion of result */
	  qsave = q;
	  if (q != qbase)
	    *q++ = DIRSEP;
	  while (*p && (ISDIRSEP(*p) == 0))
	    {
	      if (q - result >= PATH_MAX)
		{
#ifdef ENAMETOOLONG
		  errno = ENAMETOOLONG;
#else
		  errno = EINVAL;
#endif
		  goto error;
		}
		
	      *q++ = *p++;
	    }

	  *q = '\0';

	  linklen = _path_readlink (result, linkbuf, PATH_MAX);
	  if (linklen < 0)	/* if errno == EINVAL, it's not a symlink */
	    {
	      if (errno != EINVAL)
		goto error;
	      continue;
	    }

	  /* It's a symlink, and the value is in LINKBUF. */
	  nlink++;
	  if (nlink > MAXSYMLINKS)
	    {
#ifdef ELOOP
	      errno = ELOOP;
#else
	      errno = EINVAL;
#endif
error:
	      free (result);
	      free (workpath);
	      return ((char *)NULL);
	    }

	  linkbuf[linklen] = '\0';

	  /* If the new path length would overrun PATH_MAX, punt now. */
	  if ((strlen (p) + linklen + 2) >= PATH_MAX)
	    {
#ifdef ENAMETOOLONG
	      errno = ENAMETOOLONG;
#else
	      errno = EINVAL;
#endif
	      goto error;
	    }

	  /* Form the new pathname by copying the link value to a temporary
	     buffer and appending the rest of `workpath'.  Reset p to point
	     to the start of the rest of the path.  If the link value is an
	     absolute pathname, reset p, q, and qbase.  If not, reset p
	     and q. */
	  strcpy (tbuf, linkbuf);
	  tbuf[linklen] = '/';
	  strcpy (tbuf + linklen, p);
	  strcpy (workpath, tbuf);

	  if (ABSPATH(linkbuf))
	    {
	      q = result;
	      /* Duplicating some code here... */
#if defined (__CYGWIN__)
	      qbase = (ISALPHA((unsigned char)workpath[0]) && workpath[1] == ':') ? workpath + 3 : workpath + 1;
#else
	      qbase = workpath + 1;
#endif
	      double_slash_path = DOUBLE_SLASH (workpath);
	      qbase += double_slash_path;
    
	      for (p = workpath; p < qbase; )
		*q++ = *p++;
	      qbase = q;
	    }
	  else
	    {
	      p = workpath;
	      q = qsave;
	    }
	}
    }

  *q = '\0';
  free (workpath);

  /* If the result starts with `//', but the original path does not, we
     can turn the // into /.  Because of how we set `qbase', this should never
     be true, but it's a sanity check. */
  if (DOUBLE_SLASH(result) && double_slash_path == 0)
    {
      if (result[2] == '\0')	/* short-circuit for bare `//' */
	result[1] = '\0';
      else
	memmove (result, result + 1, strlen (result + 1) + 1);
    }

  return (result);
}
warning: parse error {
  char tbuf[PATH_MAX+1], linkbuf[PATH_MAX+1];
  char *result, *p, *q, *qsave, *qbase, *workpath;
  int double_slash_path, linklen, nlink;

  linklen = strlen (path);

#if 0
  /* First sanity check -- punt immediately if the name is too long. */
  if (linklen >= PATH_MAX)
    return (savestring (path));
#endif

  nlink = 0;
  q = result = (char *)xmalloc (PATH_MAX + 1);

  /* Even if we get something longer than PATH_MAX, we might be able to
     shorten it, so we try. */
  if (linklen >= PATH_MAX)
    workpath = savestring (path);
  else
    {
      workpath = (char *)xmalloc (PATH_MAX + 1);
      strcpy (workpath, path);
    }

  /* This always gets an absolute pathname. */

  /* POSIX.2 says to leave a leading `//' alone.  On cygwin, we skip over any
     leading `x:' (dos drive name). */
#if defined (__CYGWIN__)
  qbase = (ISALPHA((unsigned char)workpath[0]) && workpath[1] == ':') ? workpath + 3 : workpath + 1;
#else
  qbase = workpath + 1;
#endif
  double_slash_path = DOUBLE_SLASH (workpath);
  qbase += double_slash_path;

  for (p = workpath; p < qbase; )
    *q++ = *p++;
  qbase = q;

  /*
   * invariants:
   *	  qbase points to the portion of the result path we want to modify
   *      p points at beginning of path element we're considering.
   *      q points just past the last path element we wrote (no slash).
   *
   * XXX -- need to fix error checking for too-long pathnames
   */

  while (*p)
    {
      if (ISDIRSEP(p[0])) /* null element */
	p++;
      else if(p[0] == '.' && PATHSEP(p[1]))	/* . and ./ */
	p += 1; 	/* don't count the separator in case it is nul */
      else if (p[0] == '.' && p[1] == '.' && PATHSEP(p[2])) /* .. and ../ */
	{
	  p += 2; /* skip `..' */
	  if (q > qbase)
	    {
	      while (--q > qbase && ISDIRSEP(*q) == 0)
		;
	    }
	}
      else	/* real path element */
	{
	  /* add separator if not at start of work portion of result */
	  qsave = q;
	  if (q != qbase)
	    *q++ = DIRSEP;
	  while (*p && (ISDIRSEP(*p) == 0))
	    {
	      if (q - result >= PATH_MAX)
		{
#ifdef ENAMETOOLONG
		  errno = ENAMETOOLONG;
#else
		  errno = EINVAL;
#endif
		  goto error;
		}
		
	      *q++ = *p++;
	    }

	  *q = '\0';

	  linklen = _path_readlink (result, linkbuf, PATH_MAX);
	  if (linklen < 0)	/* if errno == EINVAL, it's not a symlink */
	    {
	      if (errno != EINVAL)
		goto error;
	      continue;
	    }

	  /* It's a symlink, and the value is in LINKBUF. */
	  nlink++;
	  if (nlink > MAXSYMLINKS)
	    {
#ifdef ELOOP
	      errno = ELOOP;
#else
	      errno = EINVAL;
#endif
error:
	      free (result);
	      free (workpath);
	      return ((char *)NULL);
	    }

	  linkbuf[linklen] = '\0';

	  /* If the new path length would overrun PATH_MAX, punt now. */
	  if ((strlen (p) + linklen + 2) >= PATH_MAX)
	    {
#ifdef ENAMETOOLONG
	      errno = ENAMETOOLONG;
#else
	      errno = EINVAL;
#endif
	      goto error;
	    }

	  /* Form the new pathname by copying the link value to a temporary
	     buffer and appending the rest of `workpath'.  Reset p to point
	     to the start of the rest of the path.  If the link value is an
	     absolute pathname, reset p, q, and qbase.  If not, reset p
	     and q. */
	  strcpy (tbuf, linkbuf);
	  tbuf[linklen] = '/';
	  strcpy (tbuf + linklen, p);
	  strcpy (workpath, tbuf);

	  if (ABSPATH(linkbuf))
	    {
	      q = result;
	      /* Duplicating some code here... */
#if defined (__CYGWIN__)
	      qbase = (ISALPHA((unsigned char)workpath[0]) && workpath[1] == ':') ? workpath + 3 : workpath + 1;
#else
	      qbase = workpath + 1;
#endif
	      double_slash_path = DOUBLE_SLASH (workpath);
	      qbase += double_slash_path;
    
	      for (p = workpath; p < qbase; )
		*q++ = *p++;
	      qbase = q;
	    }
	  else
	    {
	      p = workpath;
	      q = qsave;
	    }
	}
    }

  *q = '\0';
  free (workpath);

  /* If the result starts with `//', but the original path does not, we
     can turn the // into /.  Because of how we set `qbase', this should never
     be true, but it's a sanity check. */
  if (DOUBLE_SLASH(result) && double_slash_path == 0)
    {
      if (result[2] == '\0')	/* short-circuit for bare `//' */
	result[1] = '\0';
      else
	memmove (result, result + 1, strlen (result + 1) + 1);
    }

  return (result);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\pathphys.c:78
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\pathphys.c:256
parsing error 
{
  char *tdir, *wd;

  if (pathname == 0 || *pathname == '\0')
    {
      errno = (pathname == 0) ? EINVAL : ENOENT;
      return ((char *)NULL);
    }

  if (ABSPATH (pathname) == 0)
    {
      wd = get_working_directory ("sh_realpath");
      if (wd == 0)
	return ((char *)NULL);
      tdir = sh_makepath (wd, (char *)pathname, 0);
      free (wd);
    }
  else
    tdir = savestring (pathname);

  wd = sh_physpath (tdir, 0);
  free (tdir);

  if (resolved == 0)
    return (wd);

  if (wd)
    {
      strncpy (resolved, wd, PATH_MAX - 1);
      resolved[PATH_MAX - 1] = '\0';
      free (wd);
      return resolved;
    }
  else
    {
      resolved[0] = '\0';
      return wd;
    }
}
warning: parse error {
  char *tdir, *wd;

  if (pathname == 0 || *pathname == '\0')
    {
      errno = (pathname == 0) ? EINVAL : ENOENT;
      return ((char *)NULL);
    }

  if (ABSPATH (pathname) == 0)
    {
      wd = get_working_directory ("sh_realpath");
      if (wd == 0)
	return ((char *)NULL);
      tdir = sh_makepath (wd, (char *)pathname, 0);
      free (wd);
    }
  else
    tdir = savestring (pathname);

  wd = sh_physpath (tdir, 0);
  free (tdir);

  if (resolved == 0)
    return (wd);

  if (wd)
    {
      strncpy (resolved, wd, PATH_MAX - 1);
      resolved[PATH_MAX - 1] = '\0';
      free (wd);
      return resolved;
    }
  else
    {
      resolved[0] = '\0';
      return wd;
    }
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\pathphys.c:258
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\random.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashtypes.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\filecntl.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashansi.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\shell.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\random.c:55
parsing error 
{
  /* Minimal Standard generator from
     "Random number generators: good ones are hard to find",
     Park and Miller, Communications of the ACM, vol. 31, no. 10,
     October 1988, p. 1195. Filtered through FreeBSD.

     x(n+1) = 16807 * x(n) mod (m).

     We split up the calculations to avoid overflow.

     h = last / q; l = x - h * q; t = a * l - h * r
     m = 2147483647, a = 16807, q = 127773, r = 2836

     There are lots of other combinations of constants to use; look at
     https://www.gnu.org/software/gsl/manual/html_node/Other-random-number-generators.html#Other-random-number-generators */

  bits32_t h, l, t;
  u_bits32_t ret;

  /* Can't seed with 0. */
  ret = (last == 0) ? 123459876 : last;
  h = ret / 127773;
  l = ret - (127773 * h);
  t = 16807 * l - 2836 * h;
  ret = (t < 0) ? t + 0x7fffffff : t;

  return (ret);
}
warning: parse error {
  /* Minimal Standard generator from
     "Random number generators: good ones are hard to find",
     Park and Miller, Communications of the ACM, vol. 31, no. 10,
     October 1988, p. 1195. Filtered through FreeBSD.

     x(n+1) = 16807 * x(n) mod (m).

     We split up the calculations to avoid overflow.

     h = last / q; l = x - h * q; t = a * l - h * r
     m = 2147483647, a = 16807, q = 127773, r = 2836

     There are lots of other combinations of constants to use; look at
     https://www.gnu.org/software/gsl/manual/html_node/Other-random-number-generators.html#Other-random-number-generators */

  bits32_t h, l, t;
  u_bits32_t ret;

  /* Can't seed with 0. */
  ret = (last == 0) ? 123459876 : last;
  h = ret / 127773;
  l = ret - (127773 * h);
  t = 16807 * l - 2836 * h;
  ret = (t < 0) ? t + 0x7fffffff : t;

  return (ret);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\random.c:57
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\random.c:116
parsing error 
{
  rseed = seed;
  last_random_value = 0;
}
warning: parse error {
  rseed = seed;
  last_random_value = 0;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\random.c:118
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\random.c:150
parsing error 
{
  last_rand32 = rseed32 = seed;
}
warning: parse error {
  last_rand32 = rseed32 = seed;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\random.c:152
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\random.c:188
parsing error 
{
  int oflags;
  ssize_t r;
  static int urand_unavail = 0;

#if HAVE_GETENTROPY
  r = getentropy (buf, len);
  return (r == 0) ? len : -1;
#endif

  if (urandfd == -1 && urand_unavail == 0)
    {
      oflags = O_RDONLY;
      if (flags & GRND_NONBLOCK)
	oflags |= O_NONBLOCK;
      urandfd = open ("/dev/urandom", oflags, 0);
      if (urandfd >= 0)
	SET_CLOSE_ON_EXEC (urandfd);
      else
	{
	  urand_unavail = 1;
	  return -1;
	}
    }
  if (urandfd >= 0 && (r = read (urandfd, buf, len)) == len)
    return (r);
  return -1;
}
warning: parse error {
  int oflags;
  ssize_t r;
  static int urand_unavail = 0;

#if HAVE_GETENTROPY
  r = getentropy (buf, len);
  return (r == 0) ? len : -1;
#endif

  if (urandfd == -1 && urand_unavail == 0)
    {
      oflags = O_RDONLY;
      if (flags & GRND_NONBLOCK)
	oflags |= O_NONBLOCK;
      urandfd = open ("/dev/urandom", oflags, 0);
      if (urandfd >= 0)
	SET_CLOSE_ON_EXEC (urandfd);
      else
	{
	  urand_unavail = 1;
	  return -1;
	}
    }
  if (urandfd >= 0 && (r = read (urandfd, buf, len)) == len)
    return (r);
  return -1;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\random.c:192
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\rename.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashtypes.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\posixstat.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\stdc.h...skip
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\rename.c:43
parsing error 
{
  struct stat fb, tb;

  if (stat (from, &fb) < 0)
    return -1;  

  if (stat (to, &tb) < 0)
    {
      if (errno != ENOENT)
	return -1;
    }
  else
    {
      if (fb.st_dev == tb.st_dev && fb.st_ino == tb.st_ino)
        return 0;		/* same file */
      if (unlink (to) < 0 && errno != ENOENT)
        return -1;
    }

  if (link (from, to) < 0)
    return (-1);

  if (unlink (from) < 0 && errno != ENOENT)
    {
      int e = errno;
      unlink (to);
      errno = e;
      return (-1);
    }

  return (0);
}
warning: parse error {
  struct stat fb, tb;

  if (stat (from, &fb) < 0)
    return -1;  

  if (stat (to, &tb) < 0)
    {
      if (errno != ENOENT)
	return -1;
    }
  else
    {
      if (fb.st_dev == tb.st_dev && fb.st_ino == tb.st_ino)
        return 0;		/* same file */
      if (unlink (to) < 0 && errno != ENOENT)
        return -1;
    }

  if (link (from, to) < 0)
    return (-1);

  if (unlink (from) < 0 && errno != ENOENT)
    {
      int e = errno;
      unlink (to);
      errno = e;
      return (-1);
    }

  return (0);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\rename.c:44
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\setlinebuf.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\xmalloc.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\setlinebuf.c:35
parsing error 
{
  char *local_linebuf;

#if !defined (HAVE_SETLINEBUF) && !defined (HAVE_SETVBUF)
  return (0);
#endif

#if defined (USING_BASH_MALLOC)
  local_linebuf = (char *)xmalloc (LBUF_BUFSIZE);
#else
  local_linebuf = (char *)NULL;
#endif

#if defined (HAVE_SETVBUF)

#  if defined (SETVBUF_REVERSED)
  return (setvbuf (stream, _IOLBF, local_linebuf, LBUF_BUFSIZE));
#  else /* !SETVBUF_REVERSED */
  return (setvbuf (stream, local_linebuf, _IOLBF, LBUF_BUFSIZE));
#  endif /* !SETVBUF_REVERSED */
# else /* !HAVE_SETVBUF */

  setlinebuf (stream);
  return (0);

#endif /* !HAVE_SETVBUF */
}
warning: parse error {
  char *local_linebuf;

#if !defined (HAVE_SETLINEBUF) && !defined (HAVE_SETVBUF)
  return (0);
#endif

#if defined (USING_BASH_MALLOC)
  local_linebuf = (char *)xmalloc (LBUF_BUFSIZE);
#else
  local_linebuf = (char *)NULL;
#endif

#if defined (HAVE_SETVBUF)

#  if defined (SETVBUF_REVERSED)
  return (setvbuf (stream, _IOLBF, local_linebuf, LBUF_BUFSIZE));
#  else /* !SETVBUF_REVERSED */
  return (setvbuf (stream, local_linebuf, _IOLBF, LBUF_BUFSIZE));
#  endif /* !SETVBUF_REVERSED */
# else /* !HAVE_SETVBUF */

  setlinebuf (stream);
  return (0);

#endif /* !HAVE_SETVBUF */
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\setlinebuf.c:37
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\shmatch.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashansi.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\shell.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\externs.h...skip
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\shmbchar.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\shmbutil.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\shmbchar.h...skip
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\shquote.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\stdc.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\syntax.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\xmalloc.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\shmbchar.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\shmbutil.h...skip
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\shquote.c:96
parsing error 
{
  register int c;
  char *result, *r;
  const char *s;

  result = (char *)xmalloc (3 + (4 * strlen (string)));
  r = result;

  if (string[0] == '\'' && string[1] == 0)
    {
      *r++ = '\\';
      *r++ = '\'';
      *r++ = 0;
      return result;
    }

  *r++ = '\'';

  for (s = string; s && (c = *s); s++)
    {
      *r++ = c;

      if (c == '\'')
	{
	  *r++ = '\\';	/* insert escaped single quote */
	  *r++ = '\'';
	  *r++ = '\'';	/* start new quoted string */
	}
    }

  *r++ = '\'';
  *r = '\0';

  return (result);
}
warning: parse error {
  register int c;
  char *result, *r;
  const char *s;

  result = (char *)xmalloc (3 + (4 * strlen (string)));
  r = result;

  if (string[0] == '\'' && string[1] == 0)
    {
      *r++ = '\\';
      *r++ = '\'';
      *r++ = 0;
      return result;
    }

  *r++ = '\'';

  for (s = string; s && (c = *s); s++)
    {
      *r++ = c;

      if (c == '\'')
	{
	  *r++ = '\\';	/* insert escaped single quote */
	  *r++ = '\'';
	  *r++ = '\'';	/* start new quoted string */
	}
    }

  *r++ = '\'';
  *r = '\0';

  return (result);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\shquote.c:97
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\shquote.c:136
parsing error 
{
  register unsigned char c;
  int mb_cur_max;
  char *result, *r;
  size_t slen;
  const char *s, *send;
  DECLARE_MBSTATE;

  slen = strlen (string);
  send = string + slen;
  mb_cur_max = MB_CUR_MAX;

  result = (char *)xmalloc (3 + (2 * strlen (string)));
  r = result;
  *r++ = '"';

  for (s = string; s && (c = *s); s++)
    {
      /* Backslash-newline disappears within double quotes, so don't add one. */
      if ((sh_syntaxtab[c] & CBSDQUOTE) && c != '\n')
	*r++ = '\\';

#if defined (HANDLE_MULTIBYTE)
      if ((locale_utf8locale && (c & 0x80)) ||
	  (locale_utf8locale == 0 && mb_cur_max > 1 && is_basic (c) == 0))
	{
	  COPY_CHAR_P (r, s, send);
	  s--;		/* compensate for auto-increment in loop above */
	  continue;
	}
#endif

      /* Assume that the string will not be further expanded, so no need to
	 add CTLESC to protect CTLESC or CTLNUL. */
      *r++ = c;
    }

  *r++ = '"';
  *r = '\0';

  return (result);
}
warning: parse error {
  register unsigned char c;
  int mb_cur_max;
  char *result, *r;
  size_t slen;
  const char *s, *send;
  DECLARE_MBSTATE;

  slen = strlen (string);
  send = string + slen;
  mb_cur_max = MB_CUR_MAX;

  result = (char *)xmalloc (3 + (2 * strlen (string)));
  r = result;
  *r++ = '"';

  for (s = string; s && (c = *s); s++)
    {
      /* Backslash-newline disappears within double quotes, so don't add one. */
      if ((sh_syntaxtab[c] & CBSDQUOTE) && c != '\n')
	*r++ = '\\';

#if defined (HANDLE_MULTIBYTE)
      if ((locale_utf8locale && (c & 0x80)) ||
	  (locale_utf8locale == 0 && mb_cur_max > 1 && is_basic (c) == 0))
	{
	  COPY_CHAR_P (r, s, send);
	  s--;		/* compensate for auto-increment in loop above */
	  continue;
	}
#endif

      /* Assume that the string will not be further expanded, so no need to
	 add CTLESC to protect CTLESC or CTLNUL. */
      *r++ = c;
    }

  *r++ = '"';
  *r = '\0';

  return (result);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\shquote.c:137
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\shquote.c:184
parsing error 
{
  char *r, *ret;
  const char *send;
  int rlen, mb_cur_max;
  DECLARE_MBSTATE;

  send = s + slen;
  mb_cur_max = flags ? MB_CUR_MAX : 1;
  rlen = (flags == 0) ? slen + 3 : (2 * slen) + 1;
  ret = r = (char *)xmalloc (rlen);

  *r++ = '"';
  while (*s)
    {
      if (flags && *s == '"')
	*r++ = '\\';

#if defined (HANDLE_MULTIBYTE)
      if  (flags && ((locale_utf8locale && (*s & 0x80)) ||
		     (locale_utf8locale == 0 && mb_cur_max > 1 && is_basic (*s) == 0)))
	{
	  COPY_CHAR_P (r, s, send);
	  continue;
	}
#endif
      *r++ = *s++;
    }
  *r++ = '"';
  *r = '\0';

  return ret;
}
warning: parse error {
  char *r, *ret;
  const char *send;
  int rlen, mb_cur_max;
  DECLARE_MBSTATE;

  send = s + slen;
  mb_cur_max = flags ? MB_CUR_MAX : 1;
  rlen = (flags == 0) ? slen + 3 : (2 * slen) + 1;
  ret = r = (char *)xmalloc (rlen);

  *r++ = '"';
  while (*s)
    {
      if (flags && *s == '"')
	*r++ = '\\';

#if defined (HANDLE_MULTIBYTE)
      if  (flags && ((locale_utf8locale && (*s & 0x80)) ||
		     (locale_utf8locale == 0 && mb_cur_max > 1 && is_basic (*s) == 0)))
	{
	  COPY_CHAR_P (r, s, send);
	  continue;
	}
#endif
      *r++ = *s++;
    }
  *r++ = '"';
  *r = '\0';

  return ret;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\shquote.c:186
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\shquote.c:223
parsing error 
{
  register int c, pass_next;
  char *result, *r, *s;

  r = result = (char *)xmalloc (strlen (string) + 1);

  for (pass_next = 0, s = string; s && (c = *s); s++)
    {
      if (pass_next)
	{
	  *r++ = c;
	  pass_next = 0;
	  continue;
	}
      if (c == '\\' && (sh_syntaxtab[(unsigned char) s[1]] & CBSDQUOTE))
	{
	  pass_next = 1;
	  continue;
	}
      *r++ = c;
    }

  *r = '\0';
  return result;
}
warning: parse error {
  register int c, pass_next;
  char *result, *r, *s;

  r = result = (char *)xmalloc (strlen (string) + 1);

  for (pass_next = 0, s = string; s && (c = *s); s++)
    {
      if (pass_next)
	{
	  *r++ = c;
	  pass_next = 0;
	  continue;
	}
      if (c == '\\' && (sh_syntaxtab[(unsigned char) s[1]] & CBSDQUOTE))
	{
	  pass_next = 1;
	  continue;
	}
      *r++ = c;
    }

  *r = '\0';
  return result;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\shquote.c:225
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\shquote.c:262
parsing error 
{
  int c, mb_cur_max;
  size_t slen;
  char *result, *r, *s, *backslash_table, *send;
  DECLARE_MBSTATE;

  slen = strlen (string);
  send = string + slen;
  result = (char *)xmalloc (2 * slen + 1);

  backslash_table = table ? table : (char *)bstab;
  mb_cur_max = MB_CUR_MAX;

  for (r = result, s = string; s && (c = *s); s++)
    {
#if defined (HANDLE_MULTIBYTE)
      /* XXX - isascii, even if is_basic(c) == 0 - works in most cases. */
      if (c >= 0 && c <= 127 && backslash_table[(unsigned char)c] == 1)
	{
	  *r++ = '\\';
	  *r++ = c;
	  continue;
	}
      if ((locale_utf8locale && (c & 0x80)) ||
	  (locale_utf8locale == 0 && mb_cur_max > 1 && is_basic (c) == 0))
	{
	  COPY_CHAR_P (r, s, send);
	  s--;		/* compensate for auto-increment in loop above */
	  continue;
	}
#endif
      if (backslash_table[(unsigned char)c] == 1)
	*r++ = '\\';
      else if (c == '#' && s == string)			/* comment char */
	*r++ = '\\';
      else if ((flags&1) && c == '~' && (s == string || s[-1] == ':' || s[-1] == '='))
        /* Tildes are special at the start of a word or after a `:' or `='
	   (technically unquoted, but it doesn't make a difference in practice) */
	*r++ = '\\';
      else if ((flags&2) && shellblank((unsigned char)c))
	*r++ = '\\';
      *r++ = c;
    }

  *r = '\0';
  return (result);
}
warning: parse error {
  int c, mb_cur_max;
  size_t slen;
  char *result, *r, *s, *backslash_table, *send;
  DECLARE_MBSTATE;

  slen = strlen (string);
  send = string + slen;
  result = (char *)xmalloc (2 * slen + 1);

  backslash_table = table ? table : (char *)bstab;
  mb_cur_max = MB_CUR_MAX;

  for (r = result, s = string; s && (c = *s); s++)
    {
#if defined (HANDLE_MULTIBYTE)
      /* XXX - isascii, even if is_basic(c) == 0 - works in most cases. */
      if (c >= 0 && c <= 127 && backslash_table[(unsigned char)c] == 1)
	{
	  *r++ = '\\';
	  *r++ = c;
	  continue;
	}
      if ((locale_utf8locale && (c & 0x80)) ||
	  (locale_utf8locale == 0 && mb_cur_max > 1 && is_basic (c) == 0))
	{
	  COPY_CHAR_P (r, s, send);
	  s--;		/* compensate for auto-increment in loop above */
	  continue;
	}
#endif
      if (backslash_table[(unsigned char)c] == 1)
	*r++ = '\\';
      else if (c == '#' && s == string)			/* comment char */
	*r++ = '\\';
      else if ((flags&1) && c == '~' && (s == string || s[-1] == ':' || s[-1] == '='))
        /* Tildes are special at the start of a word or after a `:' or `='
	   (technically unquoted, but it doesn't make a difference in practice) */
	*r++ = '\\';
      else if ((flags&2) && shellblank((unsigned char)c))
	*r++ = '\\';
      *r++ = c;
    }

  *r = '\0';
  return (result);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\shquote.c:266
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\shquote.c:360
parsing error 
{
  char *ret;

  if (s == 0)
    return s;
  else if (*s == 0)
    {
      ret = (char *)xmalloc (3);
      ret[0] = ret[1] = '\'';
      ret[2] = '\0';
    }
  else if (ansic_shouldquote (s))
    ret = ansic_quote (s, 0, (int *)0);
  else if (flags)
    ret = sh_backslash_quote (s, 0, 1);
  else
    ret = sh_single_quote (s);

  return ret;
}
warning: parse error {
  char *ret;

  if (s == 0)
    return s;
  else if (*s == 0)
    {
      ret = (char *)xmalloc (3);
      ret[0] = ret[1] = '\'';
      ret[2] = '\0';
    }
  else if (ansic_shouldquote (s))
    ret = ansic_quote (s, 0, (int *)0);
  else if (flags)
    ret = sh_backslash_quote (s, 0, 1);
  else
    ret = sh_single_quote (s);

  return ret;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\shquote.c:363
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\shquote.c:386
parsing error 
{
  const char *s;

  for (s = string; s && *s; s++)
    {
      switch (*s)
	{
	case ' ': case '\t': case '\n':		/* IFS white space */
	case '\'': case '"': case '\\':		/* quoting chars */
	case '|': case '&': case ';':		/* shell metacharacters */
	case '(': case ')': case '<': case '>':
	case '!': case '{': case '}':		/* reserved words */
	case '*': case '[': case '?': case ']':	/* globbing chars */
	case '^':
	case '$': case '`':			/* expansion chars */
	  return (1);
	case '~':				/* tilde expansion */
	  if (s == string || s[-1] == '=' || s[-1] == ':')
	    return (1);
	  break;
	case '#':
	  if (s == string)			/* comment char */
	    return (1);
	  /* FALLTHROUGH */
	default:
	  break;
	}
    }

  return (0);
}
warning: parse error {
  const char *s;

  for (s = string; s && *s; s++)
    {
      switch (*s)
	{
	case ' ': case '\t': case '\n':		/* IFS white space */
	case '\'': case '"': case '\\':		/* quoting chars */
	case '|': case '&': case ';':		/* shell metacharacters */
	case '(': case ')': case '<': case '>':
	case '!': case '{': case '}':		/* reserved words */
	case '*': case '[': case '?': case ']':	/* globbing chars */
	case '^':
	case '$': case '`':			/* expansion chars */
	  return (1);
	case '~':				/* tilde expansion */
	  if (s == string || s[-1] == '=' || s[-1] == ':')
	    return (1);
	  break;
	case '#':
	  if (s == string)			/* comment char */
	    return (1);
	  /* FALLTHROUGH */
	default:
	  break;
	}
    }

  return (0);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\shquote.c:387
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\shquote.c:421
parsing error 
{
  const char *s;

  for (s = string; s && *s; s++)
    {
      if (*s == '\'' || *s == '"' || *s == '\\')
	return 1;
    }
  return 0;
}
warning: parse error {
  const char *s;

  for (s = string; s && *s; s++)
    {
      if (*s == '\'' || *s == '"' || *s == '\\')
	return 1;
    }
  return 0;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\shquote.c:422
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\shtty.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\shtty.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\shtty.c:37
parsing error 
{
#ifdef TERMIOS_TTY_DRIVER
  return tcgetattr(fd, ttp);
#else
#  ifdef TERMIO_TTY_DRIVER
  return ioctl(fd, TCGETA, ttp);
#  else
  return ioctl(fd, TIOCGETP, ttp);
#  endif
#endif
}
warning: parse error {
#ifdef TERMIOS_TTY_DRIVER
  return tcgetattr(fd, ttp);
#else
#  ifdef TERMIO_TTY_DRIVER
  return ioctl(fd, TCGETA, ttp);
#  else
  return ioctl(fd, TIOCGETP, ttp);
#  endif
#endif
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\shtty.c:40
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\shtty.c:53
parsing error 
{
#ifdef TERMIOS_TTY_DRIVER
  return tcsetattr(fd, TCSADRAIN, ttp);
#else
#  ifdef TERMIO_TTY_DRIVER
  return ioctl(fd, TCSETAW, ttp);
#  else
  return ioctl(fd, TIOCSETN, ttp);
#  endif
#endif
}
warning: parse error {
#ifdef TERMIOS_TTY_DRIVER
  return tcsetattr(fd, TCSADRAIN, ttp);
#else
#  ifdef TERMIO_TTY_DRIVER
  return ioctl(fd, TCSETAW, ttp);
#  else
  return ioctl(fd, TIOCSETN, ttp);
#  endif
#endif
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\shtty.c:56
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\shtty.c:90
parsing error 
{
  if (ttsaved == 0)
    return ((TTYSTRUCT *)0);
  if (fd == 0)
    return &ttin;
  else if (fd == 1)
    return &ttout;
  else
    return ((TTYSTRUCT *)0);
}
warning: parse error {
  if (ttsaved == 0)
    return ((TTYSTRUCT *)0);
  if (fd == 0)
    return &ttin;
  else if (fd == 1)
    return &ttout;
  else
    return ((TTYSTRUCT *)0);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\shtty.c:92
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\shtty.c:108
parsing error 
{
#if defined (TERMIOS_TTY_DRIVER) || defined (TERMIO_TTY_DRIVER)

  /* XXX - might not want this -- it disables erase and kill processing. */
  ttp->c_lflag &= ~ICANON;

  ttp->c_lflag |= ISIG;
#  ifdef IEXTEN
  ttp->c_lflag |= IEXTEN;
#  endif

  ttp->c_iflag |= ICRNL;	/* make sure we get CR->NL on input */
  ttp->c_iflag &= ~INLCR;	/* but no NL->CR */

#  ifdef OPOST
  ttp->c_oflag |= OPOST;
#  endif
#  ifdef ONLCR
  ttp->c_oflag |= ONLCR;
#  endif
#  ifdef OCRNL
  ttp->c_oflag &= ~OCRNL;
#  endif
#  ifdef ONOCR
  ttp->c_oflag &= ~ONOCR;
#  endif
#  ifdef ONLRET
  ttp->c_oflag &= ~ONLRET;
#  endif

  ttp->c_cc[VMIN] = 1;
  ttp->c_cc[VTIME] = 0;

#else

  ttp->sg_flags |= CBREAK;

#endif

  return 0;
}
warning: parse error {
#if defined (TERMIOS_TTY_DRIVER) || defined (TERMIO_TTY_DRIVER)

  /* XXX - might not want this -- it disables erase and kill processing. */
  ttp->c_lflag &= ~ICANON;

  ttp->c_lflag |= ISIG;
#  ifdef IEXTEN
  ttp->c_lflag |= IEXTEN;
#  endif

  ttp->c_iflag |= ICRNL;	/* make sure we get CR->NL on input */
  ttp->c_iflag &= ~INLCR;	/* but no NL->CR */

#  ifdef OPOST
  ttp->c_oflag |= OPOST;
#  endif
#  ifdef ONLCR
  ttp->c_oflag |= ONLCR;
#  endif
#  ifdef OCRNL
  ttp->c_oflag &= ~OCRNL;
#  endif
#  ifdef ONOCR
  ttp->c_oflag &= ~ONOCR;
#  endif
#  ifdef ONLRET
  ttp->c_oflag &= ~ONLRET;
#  endif

  ttp->c_cc[VMIN] = 1;
  ttp->c_cc[VTIME] = 0;

#else

  ttp->sg_flags |= CBREAK;

#endif

  return 0;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\shtty.c:110
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\shtty.c:154
parsing error 
{
  if (tt_setonechar(ttp) < 0)
    return -1;
  return (ttsetattr (fd, ttp));
}
warning: parse error {
  if (tt_setonechar(ttp) < 0)
    return -1;
  return (ttsetattr (fd, ttp));
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\shtty.c:157
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\shtty.c:180
parsing error 
{
#if defined (TERMIOS_TTY_DRIVER) || defined (TERMIO_TTY_DRIVER)
  ttp->c_lflag &= ~(ECHO|ECHOK|ECHONL);
#else
  ttp->sg_flags &= ~ECHO;
#endif

  return 0;
}
warning: parse error {
#if defined (TERMIOS_TTY_DRIVER) || defined (TERMIO_TTY_DRIVER)
  ttp->c_lflag &= ~(ECHO|ECHOK|ECHONL);
#else
  ttp->sg_flags &= ~ECHO;
#endif

  return 0;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\shtty.c:182
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\shtty.c:194
parsing error 
{
  if (tt_setnoecho (ttp) < 0)
    return -1;
  return (ttsetattr (fd, ttp));
}
warning: parse error {
  if (tt_setnoecho (ttp) < 0)
    return -1;
  return (ttsetattr (fd, ttp));
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\shtty.c:197
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\shtty.c:220
parsing error 
{
#if defined (TERMIOS_TTY_DRIVER) || defined (TERMIO_TTY_DRIVER)
  ttp->c_iflag &= ~ISTRIP;
  ttp->c_cflag |= CS8;
  ttp->c_cflag &= ~PARENB;
#else
  ttp->sg_flags |= ANYP;
#endif

  return 0;
}
warning: parse error {
#if defined (TERMIOS_TTY_DRIVER) || defined (TERMIO_TTY_DRIVER)
  ttp->c_iflag &= ~ISTRIP;
  ttp->c_cflag |= CS8;
  ttp->c_cflag &= ~PARENB;
#else
  ttp->sg_flags |= ANYP;
#endif

  return 0;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\shtty.c:222
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\shtty.c:236
parsing error 
{
  if (tt_seteightbit (ttp) < 0)
    return -1;
  return (ttsetattr (fd, ttp));
}
warning: parse error {
  if (tt_seteightbit (ttp) < 0)
    return -1;
  return (ttsetattr (fd, ttp));
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\shtty.c:239
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\shtty.c:262
parsing error 
{
#if defined (TERMIOS_TTY_DRIVER) || defined (TERMIO_TTY_DRIVER)
  ttp->c_lflag &= ~ICANON;
#endif

  return 0;
}
warning: parse error {
#if defined (TERMIOS_TTY_DRIVER) || defined (TERMIO_TTY_DRIVER)
  ttp->c_lflag &= ~ICANON;
#endif

  return 0;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\shtty.c:264
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\shtty.c:274
parsing error 
{
  if (tt_setnocanon (ttp) < 0)
    return -1;
  return (ttsetattr (fd, ttp));
}
warning: parse error {
  if (tt_setnocanon (ttp) < 0)
    return -1;
  return (ttsetattr (fd, ttp));
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\shtty.c:277
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\shtty.c:300
parsing error 
{
  if (tt_setonechar (ttp) < 0)
    return -1;
  return (tt_setnoecho (ttp));
}
warning: parse error {
  if (tt_setonechar (ttp) < 0)
    return -1;
  return (tt_setnoecho (ttp));
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\shtty.c:302
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\shtty.c:311
parsing error 
{
  if (tt_setcbreak (ttp) < 0)
    return -1;
  return (ttsetattr (fd, ttp));
}
warning: parse error {
  if (tt_setcbreak (ttp) < 0)
    return -1;
  return (ttsetattr (fd, ttp));
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\shtty.c:314
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\snprintf.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashtypes.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashansi.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\chartypes.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\typemax.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\stdc.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\shmbutil.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\snprintf.c:473
parsing error 
{ 
  double P;

  /* handle common cases with fast switch statement. */
  switch (n)
    {
    case -3:	return .001;
    case -2:	return .01;
    case -1:	return .1;
    case 0:	return 1.;
    case 1:	return 10.;
    case 2:	return 100.;
    case 3:	return 1000.;
    }

  if (n < 0)
    {
      P = .0001;
      for (n += 4; n < 0; n++)
	P /= 10.;
    }
  else
    {
      P = 10000.;
      for (n -= 4; n > 0; n--)
	P *= 10.;
    }

  return P;
}
warning: parse error { 
  double P;

  /* handle common cases with fast switch statement. */
  switch (n)
    {
    case -3:	return .001;
    case -2:	return .01;
    case -1:	return .1;
    case 0:	return 1.;
    case 1:	return 10.;
    case 2:	return 100.;
    case 3:	return 1000.;
    }

  if (n < 0)
    {
      P = .0001;
      for (n += 4; n < 0; n++)
	P /= 10.;
    }
  else
    {
      P = 10000.;
      for (n -= 4; n > 0; n--)
	P *= 10.;
    }

  return P;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\snprintf.c:475
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\snprintf.c:517
parsing error 
{ 
  int i = 0;
  double result = 1.;

  if (r < 0.)
    r = -r;

  if (r < 1.)
    {
      while (result >= r)
	{
	  result /= 10.;
	  i++;
	}
      return (-i);
    }
  else
    {
      while (result <= r)
	{
	  result *= 10.;
	  i++;
	}
      return (i - 1);
    }
}
warning: parse error { 
  int i = 0;
  double result = 1.;

  if (r < 0.)
    r = -r;

  if (r < 1.)
    {
      while (result >= r)
	{
	  result /= 10.;
	  i++;
	}
      return (-i);
    }
  else
    {
      while (result <= r)
	{
	  result *= 10.;
	  i++;
	}
      return (i - 1);
    }
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\snprintf.c:519
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\snprintf.c:552
parsing error 
{ 
  int j;
  double i, s, p;
  double real_integral = 0.;

  /* take care of the obvious */
  /* equal to zero ? */
  if (real == 0.)
    {
      *ip = 0.;
      return (0.);
    }

  /* negative number ? */
  if (real < 0.)
    real = -real;

  /* a fraction ? */
  if ( real < 1.)
    {
      *ip = 0.;
      return real;
    }

  /* the real work :-) */
  for (j = log_10(real); j >= 0; j--)
    {
      p = pow_10(j);
      s = (real - real_integral)/p;
      i = 0.;
      while (i + 1. <= s)
	i++;
      real_integral += i*p;
    }
  *ip = real_integral;
  return (real - real_integral);
}
warning: parse error { 
  int j;
  double i, s, p;
  double real_integral = 0.;

  /* take care of the obvious */
  /* equal to zero ? */
  if (real == 0.)
    {
      *ip = 0.;
      return (0.);
    }

  /* negative number ? */
  if (real < 0.)
    real = -real;

  /* a fraction ? */
  if ( real < 1.)
    {
      *ip = 0.;
      return real;
    }

  /* the real work :-) */
  for (j = log_10(real); j >= 0; j--)
    {
      p = pow_10(j);
      s = (real - real_integral)/p;
      i = 0.;
      while (i + 1. <= s)
	i++;
      real_integral += i*p;
    }
  *ip = real_integral;
  return (real - real_integral);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\snprintf.c:555
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\snprintf.c:601
parsing error 
{
  register int i, j;
  double ip, fp; /* integer and fraction part */
  double fraction;
  int digits, sign;
  static char integral_part[MAX_INT];
  static char fraction_part[MAX_FRACT];
  int ch;

  /* taking care of the obvious case: 0.0 */
  if (number == 0.)
    { 
      integral_part[0] = '0';
      integral_part[1] = '\0';
      /* The fractional part has to take the precision into account */
      for (ch = 0; ch < precision-1; ch++)
 	fraction_part[ch] = '0';
      fraction_part[ch] = '0';
      fraction_part[ch+1] = '\0';
      if (fract)
	*fract = fraction_part;
      return integral_part;
    }

  /* -0 is tricky */
  sign = (number == -0.) ? '-' : ((number < 0.) ? '-' : '+');
  digits = MAX_INT - 1;

  /* for negative numbers */
  if (sign == '-')
    {
      number = -number;
      digits--; /* sign consume one digit */
    }

  fraction = integral(number, &ip);
  number = ip;

  /* do the integral part */
  if (ip == 0.)
    {
      integral_part[0] = '0';
      i = 1;
    }
  else
    {
      for ( i = 0; i < digits && number != 0.; ++i)
	{
	  number /= base;
	  fp = integral(number, &ip);
	  ch = (int)((fp + PRECISION)*base); /* force to round */
	  integral_part[i] = (ch <= 9) ? ch + '0' : ch + 'a' - 10;
	  if (! ISXDIGIT((unsigned char)integral_part[i]))
	    break;	/* bail out overflow !! */
	  number = ip;
	 }
    }
     
  /* Oh No !! out of bound, ho well fill it up ! */
  if (number != 0.)
    for (i = 0; i < digits; ++i)
      integral_part[i] = '9';

  /* put the sign ? */
  if (sign == '-')
    integral_part[i++] = '-';

  integral_part[i] = '\0';

  /* reverse every thing */
  for ( i--, j = 0; j < i; j++, i--)
    SWAP_INT(integral_part[i], integral_part[j]);  

  /* the fractional part */
  for (i=0, fp=fraction; precision > 0 && i < MAX_FRACT ; i++, precision--)
    {
      fraction_part[i] = (int)((fp + PRECISION)*10. + '0');
      if (! DIGIT(fraction_part[i])) /* underflow ? */
	break;
      fp = (fp*10.0) - (double)(long)((fp + PRECISION)*10.);
    }
  fraction_part[i] = '\0';

  if (fract != (char **)0)
    *fract = fraction_part;

  return integral_part;
}
warning: parse error {
  register int i, j;
  double ip, fp; /* integer and fraction part */
  double fraction;
  int digits, sign;
  static char integral_part[MAX_INT];
  static char fraction_part[MAX_FRACT];
  int ch;

  /* taking care of the obvious case: 0.0 */
  if (number == 0.)
    { 
      integral_part[0] = '0';
      integral_part[1] = '\0';
      /* The fractional part has to take the precision into account */
      for (ch = 0; ch < precision-1; ch++)
 	fraction_part[ch] = '0';
      fraction_part[ch] = '0';
      fraction_part[ch+1] = '\0';
      if (fract)
	*fract = fraction_part;
      return integral_part;
    }

  /* -0 is tricky */
  sign = (number == -0.) ? '-' : ((number < 0.) ? '-' : '+');
  digits = MAX_INT - 1;

  /* for negative numbers */
  if (sign == '-')
    {
      number = -number;
      digits--; /* sign consume one digit */
    }

  fraction = integral(number, &ip);
  number = ip;

  /* do the integral part */
  if (ip == 0.)
    {
      integral_part[0] = '0';
      i = 1;
    }
  else
    {
      for ( i = 0; i < digits && number != 0.; ++i)
	{
	  number /= base;
	  fp = integral(number, &ip);
	  ch = (int)((fp + PRECISION)*base); /* force to round */
	  integral_part[i] = (ch <= 9) ? ch + '0' : ch + 'a' - 10;
	  if (! ISXDIGIT((unsigned char)integral_part[i]))
	    break;	/* bail out overflow !! */
	  number = ip;
	 }
    }
     
  /* Oh No !! out of bound, ho well fill it up ! */
  if (number != 0.)
    for (i = 0; i < digits; ++i)
      integral_part[i] = '9';

  /* put the sign ? */
  if (sign == '-')
    integral_part[i++] = '-';

  integral_part[i] = '\0';

  /* reverse every thing */
  for ( i--, j = 0; j < i; j++, i--)
    SWAP_INT(integral_part[i], integral_part[j]);  

  /* the fractional part */
  for (i=0, fp=fraction; precision > 0 && i < MAX_FRACT ; i++, precision--)
    {
      fraction_part[i] = (int)((fp + PRECISION)*10. + '0');
      if (! DIGIT(fraction_part[i])) /* underflow ? */
	break;
      fp = (fp*10.0) - (double)(long)((fp + PRECISION)*10.);
    }
  fraction_part[i] = '\0';

  if (fract != (char **)0)
    *fract = fraction_part;

  return integral_part;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\snprintf.c:605
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\snprintf.c:699
parsing error 
{
  char *tmp, *t;
  long sd;
  int flags;

  /* An explicit precision turns off the zero-padding flag and sets the
     pad character back to space. */
  if ((p->flags & PF_ZEROPAD) && p->precision >= 0 && (p->flags & PF_DOT))
    {
      p->flags &= ~PF_ZEROPAD;
      p->pad = ' ';
    }

  sd = d;	/* signed for ' ' padding in base 10 */
  flags = 0;
  flags = (*p->pf == 'x' || *p->pf == 'X' || *p->pf == 'o' || *p->pf == 'u' || *p->pf == 'U') ? FL_UNSIGNED : 0;
  if (*p->pf == 'X')
    flags |= FL_HEXUPPER;

  tmp = fmtulong (d, base, intbuf, sizeof(intbuf), flags);
  t = 0;
  if ((p->flags & PF_THOUSANDS))
    {
      GETLOCALEDATA(decpoint, thoussep, grouping);
      if (grouping && (t = groupnum (tmp)))
	tmp = t;
    }

  /* need to add one for any `+', but we only add one in base 10 */
  p->width -= strlen(tmp) + (base == 10 && d > 0 && (p->flags & PF_PLUS));
  PAD_RIGHT(p);

  if ((p->flags & PF_DOT) && p->precision > 0)
    {
      p->precision -= strlen(tmp);
      PAD_ZERO(p);
    }

  switch (base)
    {
    case 10:
      PUT_PLUS(sd, p, 0);
      PUT_SPACE(sd, p, 0);
      break;
    case 8:
      if (p->flags & PF_ALTFORM)
	PUT_CHAR('0', p);
      break;
    case 16:
      if (p->flags & PF_ALTFORM)
	{
	  PUT_CHAR('0', p);
	  PUT_CHAR(*p->pf, p);
	}
      break;
    }

  while (*tmp)
    {
      PUT_CHAR(*tmp, p);
      tmp++;
    }

  PAD_LEFT(p);
  FREE (t);
}
warning: parse error {
  char *tmp, *t;
  long sd;
  int flags;

  /* An explicit precision turns off the zero-padding flag and sets the
     pad character back to space. */
  if ((p->flags & PF_ZEROPAD) && p->precision >= 0 && (p->flags & PF_DOT))
    {
      p->flags &= ~PF_ZEROPAD;
      p->pad = ' ';
    }

  sd = d;	/* signed for ' ' padding in base 10 */
  flags = 0;
  flags = (*p->pf == 'x' || *p->pf == 'X' || *p->pf == 'o' || *p->pf == 'u' || *p->pf == 'U') ? FL_UNSIGNED : 0;
  if (*p->pf == 'X')
    flags |= FL_HEXUPPER;

  tmp = fmtulong (d, base, intbuf, sizeof(intbuf), flags);
  t = 0;
  if ((p->flags & PF_THOUSANDS))
    {
      GETLOCALEDATA(decpoint, thoussep, grouping);
      if (grouping && (t = groupnum (tmp)))
	tmp = t;
    }

  /* need to add one for any `+', but we only add one in base 10 */
  p->width -= strlen(tmp) + (base == 10 && d > 0 && (p->flags & PF_PLUS));
  PAD_RIGHT(p);

  if ((p->flags & PF_DOT) && p->precision > 0)
    {
      p->precision -= strlen(tmp);
      PAD_ZERO(p);
    }

  switch (base)
    {
    case 10:
      PUT_PLUS(sd, p, 0);
      PUT_SPACE(sd, p, 0);
      break;
    case 8:
      if (p->flags & PF_ALTFORM)
	PUT_CHAR('0', p);
      break;
    case 16:
      if (p->flags & PF_ALTFORM)
	{
	  PUT_CHAR('0', p);
	  PUT_CHAR(*p->pf, p);
	}
      break;
    }

  while (*tmp)
    {
      PUT_CHAR(*tmp, p);
      tmp++;
    }

  PAD_LEFT(p);
  FREE (t);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\snprintf.c:703
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\snprintf.c:847
parsing error 
{
  char *tmp;

  tmp = fmtulong(d, 16, intbuf, sizeof(intbuf), 0);
  p->width -= strlen(tmp);
  PAD_RIGHT(p);

  /* prefix '0x' for pointers */
  PUT_CHAR('0', p);
  PUT_CHAR('x', p);

  while (*tmp)
    {
      PUT_CHAR(*tmp, p);
      tmp++;
    }

  PAD_LEFT(p);
}
warning: parse error {
  char *tmp;

  tmp = fmtulong(d, 16, intbuf, sizeof(intbuf), 0);
  p->width -= strlen(tmp);
  PAD_RIGHT(p);

  /* prefix '0x' for pointers */
  PUT_CHAR('0', p);
  PUT_CHAR('x', p);

  while (*tmp)
    {
      PUT_CHAR(*tmp, p);
      tmp++;
    }

  PAD_LEFT(p);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\snprintf.c:850
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\snprintf.c:872
parsing error 
{
  size_t len;

  len = strlen(tmp);
  if (p->precision != NOT_FOUND) /* the smallest number */
    len = (len < p->precision ? len : p->precision);
  p->width -= len;

  PUT_STRING (tmp, len, p);
}
warning: parse error {
  size_t len;

  len = strlen(tmp);
  if (p->precision != NOT_FOUND) /* the smallest number */
    len = (len < p->precision ? len : p->precision);
  p->width -= len;

  PUT_STRING (tmp, len, p);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\snprintf.c:875
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\snprintf.c:959
parsing error 
{
  int i;
  char *tmp;
  char *big, *small;

  i = (mode == 1) ? isinf(d) : isnan(d);
  if (i == 0)
    return 0;
  big = (mode == 1) ? "INF" : "NAN";
  small = (mode == 1) ? "inf" : "nan";

  tmp = (*p->pf == 'F' || *p->pf == 'G' || *p->pf == 'E') ? big : small;

  if (i < 0)
    PUT_CHAR('-', p);

  while (*tmp)
    {
      PUT_CHAR (*tmp, p);
      tmp++;
    }

  return 1;
}
warning: parse error {
  int i;
  char *tmp;
  char *big, *small;

  i = (mode == 1) ? isinf(d) : isnan(d);
  if (i == 0)
    return 0;
  big = (mode == 1) ? "INF" : "NAN";
  small = (mode == 1) ? "inf" : "nan";

  tmp = (*p->pf == 'F' || *p->pf == 'G' || *p->pf == 'E') ? big : small;

  if (i < 0)
    PUT_CHAR('-', p);

  while (*tmp)
    {
      PUT_CHAR (*tmp, p);
      tmp++;
    }

  return 1;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\snprintf.c:963
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\snprintf.c:990
parsing error 
{
  char *tmp, *tmp2, *t;
  int i;

  if (d != 0 && (chkinfnan(p, d, 1) || chkinfnan(p, d, 2)))
    return;	/* already printed nan or inf */

  GETLOCALEDATA(decpoint, thoussep, grouping);
  DEF_PREC(p);
  d = ROUND(d, p);
  tmp = dtoa(d, p->precision, &tmp2);
  t = 0;
  if ((p->flags & PF_THOUSANDS) && grouping && (t = groupnum (tmp)))
    tmp = t;

  if ((*p->pf == 'g' || *p->pf == 'G') && (p->flags & PF_ALTFORM) == 0)
    {
      /* smash the trailing zeros unless altform */
      for (i = strlen(tmp2) - 1; i >= 0 && tmp2[i] == '0'; i--)
	tmp2[i] = '\0'; 
      if (tmp2[0] == '\0')
	p->precision = 0;
    }

  /* calculate the padding. 1 for the dot */
  p->width = p->width -
  	    /* XXX - should this be d>0. && (p->flags & PF_PLUS) ? */
#if 0
	    ((d > 0. && p->justify == RIGHT) ? 1:0) -
#else
	    ((d > 0. && (p->flags & PF_PLUS)) ? 1:0) -
#endif
	    ((p->flags & PF_SPACE) ? 1:0) -
	    strlen(tmp) - p->precision -
	    ((p->precision != 0 || (p->flags & PF_ALTFORM)) ? 1 : 0);	/* radix char */

  if (p->pad == ' ')
    {
      PAD_RIGHT(p);
      PUT_PLUS(d, p, 0.);
    }
  else
    {
      if (*tmp == '-')
	PUT_CHAR(*tmp++, p);
      PUT_PLUS(d, p, 0.);
      PAD_RIGHT(p);
    }
  PUT_SPACE(d, p, 0.);

  while (*tmp)
    {
      PUT_CHAR(*tmp, p);	/* the integral */
      tmp++;
    }
  FREE (t);

  if (p->precision != 0 || (p->flags & PF_ALTFORM))
    PUT_CHAR(decpoint, p);  /* put the '.' */

  for (; *tmp2; tmp2++)
    PUT_CHAR(*tmp2, p); /* the fraction */
  
  PAD_LEFT(p);
}
warning: parse error {
  char *tmp, *tmp2, *t;
  int i;

  if (d != 0 && (chkinfnan(p, d, 1) || chkinfnan(p, d, 2)))
    return;	/* already printed nan or inf */

  GETLOCALEDATA(decpoint, thoussep, grouping);
  DEF_PREC(p);
  d = ROUND(d, p);
  tmp = dtoa(d, p->precision, &tmp2);
  t = 0;
  if ((p->flags & PF_THOUSANDS) && grouping && (t = groupnum (tmp)))
    tmp = t;

  if ((*p->pf == 'g' || *p->pf == 'G') && (p->flags & PF_ALTFORM) == 0)
    {
      /* smash the trailing zeros unless altform */
      for (i = strlen(tmp2) - 1; i >= 0 && tmp2[i] == '0'; i--)
	tmp2[i] = '\0'; 
      if (tmp2[0] == '\0')
	p->precision = 0;
    }

  /* calculate the padding. 1 for the dot */
  p->width = p->width -
  	    /* XXX - should this be d>0. && (p->flags & PF_PLUS) ? */
#if 0
	    ((d > 0. && p->justify == RIGHT) ? 1:0) -
#else
	    ((d > 0. && (p->flags & PF_PLUS)) ? 1:0) -
#endif
	    ((p->flags & PF_SPACE) ? 1:0) -
	    strlen(tmp) - p->precision -
	    ((p->precision != 0 || (p->flags & PF_ALTFORM)) ? 1 : 0);	/* radix char */

  if (p->pad == ' ')
    {
      PAD_RIGHT(p);
      PUT_PLUS(d, p, 0.);
    }
  else
    {
      if (*tmp == '-')
	PUT_CHAR(*tmp++, p);
      PUT_PLUS(d, p, 0.);
      PAD_RIGHT(p);
    }
  PUT_SPACE(d, p, 0.);

  while (*tmp)
    {
      PUT_CHAR(*tmp, p);	/* the integral */
      tmp++;
    }
  FREE (t);

  if (p->precision != 0 || (p->flags & PF_ALTFORM))
    PUT_CHAR(decpoint, p);  /* put the '.' */

  for (; *tmp2; tmp2++)
    PUT_CHAR(*tmp2, p); /* the fraction */
  
  PAD_LEFT(p);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\snprintf.c:993
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\snprintf.c:1,061
parsing error 
{
  char *tmp, *tmp2;
  int j, i;

  if (d != 0 && (chkinfnan(p, d, 1) || chkinfnan(p, d, 2)))
    return;	/* already printed nan or inf */

  GETLOCALEDATA(decpoint, thoussep, grouping);
  DEF_PREC(p);
  if (d == 0.)
    j = 0;
  else
    {
      j = log_10(d);
      d = d / pow_10(j);  /* get the Mantissa */
      d = ROUND(d, p);		  
    }
  tmp = dtoa(d, p->precision, &tmp2);

  /* 1 for unit, 1 for the '.', 1 for 'e|E',
   * 1 for '+|-', 2 for 'exp'  (but no `.' if precision == 0 */
  /* calculate how much padding need */
  p->width = p->width - 
  	    /* XXX - should this be d>0. && (p->flags & PF_PLUS) ? */
#if 0
	     ((d > 0. && p->justify == RIGHT) ? 1:0) -
#else
	     ((d > 0. && (p->flags & PF_PLUS)) ? 1:0) -
#endif
	     (p->precision != 0 || (p->flags & PF_ALTFORM)) -
	     ((p->flags & PF_SPACE) ? 1:0) - p->precision - 5;

  if (p->pad == ' ')
    {
      PAD_RIGHT(p);
      PUT_PLUS(d, p, 0.);
    }
  else
    {
      if (*tmp == '-')
	PUT_CHAR(*tmp++, p);
      PUT_PLUS(d, p, 0.);
      PAD_RIGHT(p);
    }
  PUT_SPACE(d, p, 0.);

  while (*tmp)
    {
      PUT_CHAR(*tmp, p);
      tmp++;
    }

  if (p->precision != 0 || (p->flags & PF_ALTFORM))
      PUT_CHAR(decpoint, p);  /* the '.' */

  if ((*p->pf == 'g' || *p->pf == 'G') && (p->flags & PF_ALTFORM) == 0)
    /* smash the trailing zeros unless altform */
    for (i = strlen(tmp2) - 1; i >= 0 && tmp2[i] == '0'; i--)
      tmp2[i] = '\0'; 

  for (; *tmp2; tmp2++)
    PUT_CHAR(*tmp2, p); /* the fraction */

  /* the exponent put the 'e|E' */
  if (*p->pf == 'g' || *p->pf == 'e')
    PUT_CHAR('e', p);
  else
    PUT_CHAR('E', p);

  /* the sign of the exp */
  if (j >= 0)
    PUT_CHAR('+', p);
  else
    {
      PUT_CHAR('-', p);
      j = -j;
    }

   tmp = itoa(j);
   /* pad out to at least two spaces.  pad with `0' if the exponent is a
      single digit. */
   if (j <= 9)
     PUT_CHAR('0', p);

   /* the exponent */
   while (*tmp)
     {
       PUT_CHAR(*tmp, p);
       tmp++;
     }

   PAD_LEFT(p);
}
warning: parse error {
  char *tmp, *tmp2;
  int j, i;

  if (d != 0 && (chkinfnan(p, d, 1) || chkinfnan(p, d, 2)))
    return;	/* already printed nan or inf */

  GETLOCALEDATA(decpoint, thoussep, grouping);
  DEF_PREC(p);
  if (d == 0.)
    j = 0;
  else
    {
      j = log_10(d);
      d = d / pow_10(j);  /* get the Mantissa */
      d = ROUND(d, p);		  
    }
  tmp = dtoa(d, p->precision, &tmp2);

  /* 1 for unit, 1 for the '.', 1 for 'e|E',
   * 1 for '+|-', 2 for 'exp'  (but no `.' if precision == 0 */
  /* calculate how much padding need */
  p->width = p->width - 
  	    /* XXX - should this be d>0. && (p->flags & PF_PLUS) ? */
#if 0
	     ((d > 0. && p->justify == RIGHT) ? 1:0) -
#else
	     ((d > 0. && (p->flags & PF_PLUS)) ? 1:0) -
#endif
	     (p->precision != 0 || (p->flags & PF_ALTFORM)) -
	     ((p->flags & PF_SPACE) ? 1:0) - p->precision - 5;

  if (p->pad == ' ')
    {
      PAD_RIGHT(p);
      PUT_PLUS(d, p, 0.);
    }
  else
    {
      if (*tmp == '-')
	PUT_CHAR(*tmp++, p);
      PUT_PLUS(d, p, 0.);
      PAD_RIGHT(p);
    }
  PUT_SPACE(d, p, 0.);

  while (*tmp)
    {
      PUT_CHAR(*tmp, p);
      tmp++;
    }

  if (p->precision != 0 || (p->flags & PF_ALTFORM))
      PUT_CHAR(decpoint, p);  /* the '.' */

  if ((*p->pf == 'g' || *p->pf == 'G') && (p->flags & PF_ALTFORM) == 0)
    /* smash the trailing zeros unless altform */
    for (i = strlen(tmp2) - 1; i >= 0 && tmp2[i] == '0'; i--)
      tmp2[i] = '\0'; 

  for (; *tmp2; tmp2++)
    PUT_CHAR(*tmp2, p); /* the fraction */

  /* the exponent put the 'e|E' */
  if (*p->pf == 'g' || *p->pf == 'e')
    PUT_CHAR('e', p);
  else
    PUT_CHAR('E', p);

  /* the sign of the exp */
  if (j >= 0)
    PUT_CHAR('+', p);
  else
    {
      PUT_CHAR('-', p);
      j = -j;
    }

   tmp = itoa(j);
   /* pad out to at least two spaces.  pad with `0' if the exponent is a
      single digit. */
   if (j <= 9)
     PUT_CHAR('0', p);

   /* the exponent */
   while (*tmp)
     {
       PUT_CHAR(*tmp, p);
       tmp++;
     }

   PAD_LEFT(p);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\snprintf.c:1,064
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\snprintf.c:1,163
parsing error 
{
  char *se, *ret, *re, *g;
  int len, slen;

  if (grouping == 0 || *grouping <= 0 || *grouping == CHAR_MAX)
    return ((char *)NULL);

  /* find min grouping to size returned string */
  for (len = *grouping, g = grouping; *g; g++)
      if (*g > 0 && *g < len)
	len = *g;

  slen = strlen (s);
  len = slen / len + 1;
  ret = (char *)xmalloc (slen + len + 1);
  re = ret + slen + len;
  *re = '\0';

  g = grouping;
  se = s + slen;
  len = *g;

  while (se > s)
    {
      *--re = *--se;

      /* handle `-' inserted by numtoa() and the fmtu* family here. */
      if (se > s && se[-1] == '-')
	continue;

      /* begin new group. */
      if (--len == 0 && se > s)
	{
	  *--re = thoussep;
	  len = *++g;		/* was g++, but that uses first char twice (glibc bug, too) */
	  if (*g == '\0')
	    len = *--g;		/* use previous grouping */
	  else if (*g == CHAR_MAX)
	    {
	      do
		*--re = *--se;
	      while (se > s);
	      break;
	    }
	}
    }

  if (re > ret)
#ifdef HAVE_MEMMOVE
    memmove (ret, re, strlen (re) + 1);
#else
    strcpy (ret, re);
#endif
   
  return ret;
}
warning: parse error {
  char *se, *ret, *re, *g;
  int len, slen;

  if (grouping == 0 || *grouping <= 0 || *grouping == CHAR_MAX)
    return ((char *)NULL);

  /* find min grouping to size returned string */
  for (len = *grouping, g = grouping; *g; g++)
      if (*g > 0 && *g < len)
	len = *g;

  slen = strlen (s);
  len = slen / len + 1;
  ret = (char *)xmalloc (slen + len + 1);
  re = ret + slen + len;
  *re = '\0';

  g = grouping;
  se = s + slen;
  len = *g;

  while (se > s)
    {
      *--re = *--se;

      /* handle `-' inserted by numtoa() and the fmtu* family here. */
      if (se > s && se[-1] == '-')
	continue;

      /* begin new group. */
      if (--len == 0 && se > s)
	{
	  *--re = thoussep;
	  len = *++g;		/* was g++, but that uses first char twice (glibc bug, too) */
	  if (*g == '\0')
	    len = *--g;		/* use previous grouping */
	  else if (*g == CHAR_MAX)
	    {
	      do
		*--re = *--se;
	      while (se > s);
	      break;
	    }
	}
    }

  if (re > ret)
#ifdef HAVE_MEMMOVE
    memmove (ret, re, strlen (re) + 1);
#else
    strcpy (ret, re);
#endif
   
  return ret;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\snprintf.c:1,165
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\snprintf.c:1,224
parsing error 
{
  p->flags &= PF_ALLOCBUF;		/* preserve PF_ALLOCBUF flag */
  p->precision = p->width = NOT_FOUND;
  p->justify = NOT_FOUND;
  p->pad = ' ';
}
warning: parse error {
  p->flags &= PF_ALLOCBUF;		/* preserve PF_ALLOCBUF flag */
  p->precision = p->width = NOT_FOUND;
  p->justify = NOT_FOUND;
  p->pad = ' ';
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\snprintf.c:1,226
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\snprintf.c:1,234
parsing error 
{
  p->length = length - 1; /* leave room for '\0' */
  p->holder = p->base = string;
  p->pf = format;
  p->counter = 0;
  p->flags = (mode == PFM_AS) ? PF_ALLOCBUF : 0;
}
warning: parse error {
  p->length = length - 1; /* leave room for '\0' */
  p->holder = p->base = string;
  p->pf = format;
  p->counter = 0;
  p->flags = (mode == PFM_AS) ? PF_ALLOCBUF : 0;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\snprintf.c:1,240
warning: parse error STAR_ARGS(data)Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\snprintf.c:1,434
warning: parse error STAR_ARGS(data)Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\snprintf.c:1,434
warning: parse error d = GETDOUBLE(data);Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\snprintf.c:1,435
warning: parse error STAR_ARGS(data)Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\snprintf.c:1,442
warning: parse error STAR_ARGS(data)Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\snprintf.c:1,442
warning: parse error d = GETDOUBLE(data);Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\snprintf.c:1,444
warning: parse error STAR_ARGS(data)Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\snprintf.c:1,469
warning: parse error STAR_ARGS(data)Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\snprintf.c:1,469
warning: parse error d = GETDOUBLE(data);Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\snprintf.c:1,470
warning: parse error STAR_ARGS(data)Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\snprintf.c:1,488
warning: parse error STAR_ARGS(data)Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\snprintf.c:1,488
warning: parse error ul = GETUNSIGNED(data);Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\snprintf.c:1,498
warning: parse error STAR_ARGS(data)Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\snprintf.c:1,508
warning: parse error STAR_ARGS(data)Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\snprintf.c:1,508
warning: parse error ul = GETSIGNED(data);Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\snprintf.c:1,518
warning: parse error STAR_ARGS(data)Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\snprintf.c:1,524
warning: parse error STAR_ARGS(data)Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\snprintf.c:1,524
warning: parse error ul = GETUNSIGNED(data);Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\snprintf.c:1,534
warning: parse error STAR_ARGS(data)Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\snprintf.c:1,541
warning: parse error STAR_ARGS(data)Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\snprintf.c:1,541
warning: parse error ul = GETUNSIGNED(data);Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\snprintf.c:1,551
warning: parse error STAR_ARGS(data)Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\snprintf.c:1,557
warning: parse error STAR_ARGS(data)Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\snprintf.c:1,557
warning: parse error ul = (unsigned long)GETARG (void *);Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\snprintf.c:1,558
warning: parse error STAR_ARGS(data)Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\snprintf.c:1,568
warning: parse error STAR_ARGS(data)Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\snprintf.c:1,568
warning: parse error ul = GETARG (int);Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\snprintf.c:1,578
warning: parse error STAR_ARGS(data)Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\snprintf.c:1,589
warning: parse error STAR_ARGS(data)Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\snprintf.c:1,589
warning: parse error s = GETARG (char *);Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\snprintf.c:1,599
warning: parse error if (data->flags & PF_LONGINT)
		  *(GETARG (long *)) = data->counter;Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\snprintf.c:1,610
warning: parse error else if (data->flags & PF_SHORTINT)
		  *(GETARG (short *)) = data->counter;Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\snprintf.c:1,612
warning: parse error else
		  *(GETARG (int *)) = data->counter;Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\snprintf.c:1,614
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\snprintf.c:1,675
parsing error 
{
  register char *x;
  char fmtbuf[FALLBACK_FMTSIZE], obuf[FALLBACK_BASE];
  int fl;

  fl = fe - fs + 1;
  strncpy (fmtbuf, fs, fl);
  fmtbuf[fl] = '\0';

  if ((data->flags & PF_STAR_W) && (data->flags & PF_STAR_P))
    sprintf (obuf, fmtbuf, data->width, data->precision, d);
  else if (data->flags & PF_STAR_W)
    sprintf (obuf, fmtbuf, data->width, d);
  else if (data->flags & PF_STAR_P)
    sprintf (obuf, fmtbuf, data->precision, d);
  else
    sprintf (obuf, fmtbuf, d);

  for (x = obuf; *x; x++)
    PUT_CHAR (*x, data);    
}
warning: parse error {
  register char *x;
  char fmtbuf[FALLBACK_FMTSIZE], obuf[FALLBACK_BASE];
  int fl;

  fl = fe - fs + 1;
  strncpy (fmtbuf, fs, fl);
  fmtbuf[fl] = '\0';

  if ((data->flags & PF_STAR_W) && (data->flags & PF_STAR_P))
    sprintf (obuf, fmtbuf, data->width, data->precision, d);
  else if (data->flags & PF_STAR_W)
    sprintf (obuf, fmtbuf, data->width, d);
  else if (data->flags & PF_STAR_P)
    sprintf (obuf, fmtbuf, data->precision, d);
  else
    sprintf (obuf, fmtbuf, d);

  for (x = obuf; *x; x++)
    PUT_CHAR (*x, data);    
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\snprintf.c:1,679
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\snprintf.c:1,727
parsing error 
va_dcl
#endif
{
  struct DATA data;
  int rval;
  va_list args;

  SH_VA_START(args, format);

  if (string == 0 && length != 0)
    return 0;
  init_data (&data, string, length, format, PFM_SN);
  rval = vsnprintf_internal (&data, string, length, format, args);

  va_end(args);

  return rval;
}
warning: parse error va_dcl
#endif
{
  struct DATA data;
  int rval;
  va_list args;

  SH_VA_START(args, format);

  if (string == 0 && length != 0)
    return 0;
  init_data (&data, string, length, format, PFM_SN);
  rval = vsnprintf_internal (&data, string, length, format, args);

  va_end(args);

  return rval;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\snprintf.c:1,731
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\snprintf.c:1,779
parsing error 
va_dcl
#endif
{
  int rval;
  va_list args;

  SH_VA_START(args, format);

  rval = vasprintf (stringp, format, args);

  va_end(args);

  return rval;
}
warning: parse error va_dcl
#endif
{
  int rval;
  va_list args;

  SH_VA_START(args, format);

  rval = vasprintf (stringp, format, args);

  va_end(args);

  return rval;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\snprintf.c:1,782
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\spell.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashtypes.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\posixdir.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\posixstat.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashansi.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\maxpath.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\stdc.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\spell.c:62
parsing error 
{
  char *op, *np, *p;
  char guess[PATH_MAX + 1], best[PATH_MAX + 1];

  op = oldname;
  np = newname;
  for (;;)
    {
      while (*op == '/')    /* Skip slashes */
	*np++ = *op++;
      *np = '\0';

      if (*op == '\0')    /* Exact or corrected */
	{
	  /* `.' is rarely the right thing. */
	  if (oldname[1] == '\0' && newname[1] == '\0' &&
		oldname[0] != '.' && newname[0] == '.')
	    return -1;
	  return strcmp(oldname, newname) != 0;
	}

      /* Copy next component into guess */
      for (p = guess; *op != '/' && *op != '\0'; op++)
	if (p < guess + PATH_MAX)
	  *p++ = *op;
      *p = '\0';

      if (mindist(newname, guess, best) >= 3)
	return -1;  /* Hopeless */

      /*
       *  Add to end of newname
       */
      for (p = best; *np = *p++; np++)
	;
    }
}
warning: parse error {
  char *op, *np, *p;
  char guess[PATH_MAX + 1], best[PATH_MAX + 1];

  op = oldname;
  np = newname;
  for (;;)
    {
      while (*op == '/')    /* Skip slashes */
	*np++ = *op++;
      *np = '\0';

      if (*op == '\0')    /* Exact or corrected */
	{
	  /* `.' is rarely the right thing. */
	  if (oldname[1] == '\0' && newname[1] == '\0' &&
		oldname[0] != '.' && newname[0] == '.')
	    return -1;
	  return strcmp(oldname, newname) != 0;
	}

      /* Copy next component into guess */
      for (p = guess; *op != '/' && *op != '\0'; op++)
	if (p < guess + PATH_MAX)
	  *p++ = *op;
      *p = '\0';

      if (mindist(newname, guess, best) >= 3)
	return -1;  /* Hopeless */

      /*
       *  Add to end of newname
       */
      for (p = best; *np = *p++; np++)
	;
    }
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\spell.c:65
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\spell.c:107
parsing error 
{
  DIR *fd;
  struct dirent *dp;
  int dist, x;

  dist = 3;    /* Worst distance */
  if (*dir == '\0')
    dir = ".";

  if ((fd = opendir(dir)) == NULL)
    return dist;

  while ((dp = readdir(fd)) != NULL)
    {
      /*
       *  Look for a better guess.  If the new guess is as
       *  good as the current one, we take it.  This way,
       *  any single character match will be a better match
       *  than ".".
       */
      x = spdist(dp->d_name, guess);
      if (x <= dist && x != 3)
	{
	  strcpy(best, dp->d_name);
	  dist = x;
	  if (dist == 0)    /* Exact match */
	    break;
	}
    }
  (void)closedir(fd);

  /* Don't return `.' */
  if (best[0] == '.' && best[1] == '\0')
    dist = 3;
  return dist;
}
warning: parse error {
  DIR *fd;
  struct dirent *dp;
  int dist, x;

  dist = 3;    /* Worst distance */
  if (*dir == '\0')
    dir = ".";

  if ((fd = opendir(dir)) == NULL)
    return dist;

  while ((dp = readdir(fd)) != NULL)
    {
      /*
       *  Look for a better guess.  If the new guess is as
       *  good as the current one, we take it.  This way,
       *  any single character match will be a better match
       *  than ".".
       */
      x = spdist(dp->d_name, guess);
      if (x <= dist && x != 3)
	{
	  strcpy(best, dp->d_name);
	  dist = x;
	  if (dist == 0)    /* Exact match */
	    break;
	}
    }
  (void)closedir(fd);

  /* Don't return `.' */
  if (best[0] == '.' && best[1] == '\0')
    dist = 3;
  return dist;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\spell.c:111
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\spell.c:158
parsing error 
{
  while (*cur == *new)
    {
      if (*cur == '\0')
	return 0;    /* Exact match */
      cur++;
      new++;
    }

  if (*cur)
    {
      if (*new)
	{
	  if (cur[1] && new[1] && cur[0] == new[1] && cur[1] == new[0] && strcmp (cur + 2, new + 2) == 0)
	    return 1;  /* Transposition */

	  if (strcmp (cur + 1, new + 1) == 0)
	    return 2;  /* One character mismatch */
	}

      if (strcmp(&cur[1], &new[0]) == 0)
	return 2;    /* Extra character */
    }

  if (*new && strcmp(cur, new + 1) == 0)
    return 2;      /* Missing character */

  return 3;
}
warning: parse error {
  while (*cur == *new)
    {
      if (*cur == '\0')
	return 0;    /* Exact match */
      cur++;
      new++;
    }

  if (*cur)
    {
      if (*new)
	{
	  if (cur[1] && new[1] && cur[0] == new[1] && cur[1] == new[0] && strcmp (cur + 2, new + 2) == 0)
	    return 1;  /* Transposition */

	  if (strcmp (cur + 1, new + 1) == 0)
	    return 2;  /* One character mismatch */
	}

      if (strcmp(&cur[1], &new[0]) == 0)
	return 2;    /* Extra character */
    }

  if (*new && strcmp(cur, new + 1) == 0)
    return 2;      /* Missing character */

  return 3;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\spell.c:160
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\spell.c:191
parsing error 
{
  int n;
  char *guess;

  n = (strlen (dirname) * 3 + 1) / 2 + 1;
  guess = (char *)malloc (n);
  if (guess == 0)
    return 0;

  switch (spname (dirname, guess))
    {
    case -1:
    default:
      free (guess);
      return (char *)NULL;
    case 0:
    case 1:
      return guess;
    }
}
warning: parse error {
  int n;
  char *guess;

  n = (strlen (dirname) * 3 + 1) / 2 + 1;
  guess = (char *)malloc (n);
  if (guess == 0)
    return 0;

  switch (spname (dirname, guess))
    {
    case -1:
    default:
      free (guess);
      return (char *)NULL;
    case 0:
    case 1:
      return guess;
    }
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\spell.c:193
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\strcasecmp.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\stdc.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashansi.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\chartypes.h...skip
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\strcasecmp.c:33
parsing error 
{
  register const char *s1;
  register const char *s2;
  register int r;

  if (count <= 0 || (string1 == string2))
    return 0;

  s1 = string1;
  s2 = string2;
  do
    {
      if ((r = TOLOWER ((unsigned char) *s1) - TOLOWER ((unsigned char) *s2)) != 0)
	return r;
      if (*s1++ == '\0')
	break;
      s2++;
    }
  while (--count != 0);

  return (0);
}
warning: parse error {
  register const char *s1;
  register const char *s2;
  register int r;

  if (count <= 0 || (string1 == string2))
    return 0;

  s1 = string1;
  s2 = string2;
  do
    {
      if ((r = TOLOWER ((unsigned char) *s1) - TOLOWER ((unsigned char) *s2)) != 0)
	return r;
      if (*s1++ == '\0')
	break;
      s2++;
    }
  while (--count != 0);

  return (0);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\strcasecmp.c:36
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\strcasecmp.c:62
parsing error 
{
  register const char *s1;
  register const char *s2;
  register int r;

  s1 = string1;
  s2 = string2;

  if (s1 == s2)
    return (0);

  while ((r = TOLOWER ((unsigned char)*s1) - TOLOWER ((unsigned char)*s2)) == 0)
    {
      if (*s1++ == '\0')
	return 0;
      s2++;
    }

  return (r);
}
warning: parse error {
  register const char *s1;
  register const char *s2;
  register int r;

  s1 = string1;
  s2 = string2;

  if (s1 == s2)
    return (0);

  while ((r = TOLOWER ((unsigned char)*s1) - TOLOWER ((unsigned char)*s2)) == 0)
    {
      if (*s1++ == '\0')
	return 0;
      s2++;
    }

  return (r);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\strcasecmp.c:64
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\strcasestr.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashansi.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\chartypes.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\stdc.h...skip
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\strcasestr.c:34
parsing error 
{
  register int i, l, len, c;

  c = TOLOWER ((unsigned char)s2[0]);
  len = strlen (s1);
  l = strlen (s2);
  for (i = 0; (len - i) >= l; i++)
    if ((TOLOWER ((unsigned char)s1[i]) == c) && (strncasecmp (s1 + i, s2, l) == 0))
      return ((char *)s1 + i);
  return ((char *)0);
}
warning: parse error {
  register int i, l, len, c;

  c = TOLOWER ((unsigned char)s2[0]);
  len = strlen (s1);
  l = strlen (s2);
  for (i = 0; (len - i) >= l; i++)
    if ((TOLOWER ((unsigned char)s1[i]) == c) && (strncasecmp (s1 + i, s2, l) == 0))
      return ((char *)s1 + i);
  return ((char *)0);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\strcasestr.c:36
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\strchrnul.c...
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\strchrnul.c:26
parsing error 
{
  char c;
  register char *s1;

  for (c = c_in, s1 = (char *)s; s1 && *s1 && *s1 != c; s1++)
    ;
  return (s1);
}
warning: parse error {
  char c;
  register char *s1;

  for (c = c_in, s1 = (char *)s; s1 && *s1 && *s1 != c; s1++)
    ;
  return (s1);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\strchrnul.c:28
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\strdup.c...
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\strdup.c:31
parsing error 
{
  size_t len;
  void *new;

  len = strlen (s) + 1;
  if ((new = malloc (len)) == NULL)
    return NULL;

  memcpy (new, s, len);
  return ((char *)new);
}
warning: parse error {
  size_t len;
  void *new;

  len = strlen (s) + 1;
  if ((new = malloc (len)) == NULL)
    return NULL;

  memcpy (new, s, len);
  return ((char *)new);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\strdup.c:32
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\strerror.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashtypes.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\shell.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\strerror.c:52
parsing error 
{
  static char emsg[40];
#if defined (HAVE_SYS_ERRLIST)
  extern int sys_nerr;
  extern char *sys_errlist[];

  if (e > 0 && e < sys_nerr)
    return (sys_errlist[e]);
  else
#endif /* HAVE_SYS_ERRLIST */
    {
      char *z;

      z = itos (e);
      strcpy (emsg, errbase);
      strcat (emsg, z);
      free (z);
      return (&emsg[0]);
    }
}
warning: parse error {
  static char emsg[40];
#if defined (HAVE_SYS_ERRLIST)
  extern int sys_nerr;
  extern char *sys_errlist[];

  if (e > 0 && e < sys_nerr)
    return (sys_errlist[e]);
  else
#endif /* HAVE_SYS_ERRLIST */
    {
      char *z;

      z = itos (e);
      strcpy (emsg, errbase);
      strcat (emsg, z);
      free (z);
      return (&emsg[0]);
    }
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\strerror.c:54
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\strftime.c...
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\stringlist.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashansi.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\shell.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\stringlist.c:40
parsing error 
{
  STRINGLIST *ret;
  register int i;

  ret = (STRINGLIST *)xmalloc (sizeof (STRINGLIST));
  if (n)
    {
      ret->list = strvec_create (n+1);
      ret->list_size = n;
      for (i = 0; i < n; i++)
	ret->list[i] = (char *)NULL;
    }
  else
    {
      ret->list = (char **)NULL;
      ret->list_size = 0;
    }
  ret->list_len = 0;
  return ret;
}
warning: parse error {
  STRINGLIST *ret;
  register int i;

  ret = (STRINGLIST *)xmalloc (sizeof (STRINGLIST));
  if (n)
    {
      ret->list = strvec_create (n+1);
      ret->list_size = n;
      for (i = 0; i < n; i++)
	ret->list[i] = (char *)NULL;
    }
  else
    {
      ret->list = (char **)NULL;
      ret->list_size = 0;
    }
  ret->list_len = 0;
  return ret;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\stringlist.c:42
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\stringlist.c:64
parsing error 
{
  register int i;

  if (sl == 0)
    return (sl = strlist_create (n));

  if (n > sl->list_size)
    {
      sl->list = strvec_resize (sl->list, n + 1);
      for (i = sl->list_size; i <= n; i++)
	sl->list[i] = (char *)NULL;
      sl->list_size = n;
    }
  return sl;
}
warning: parse error {
  register int i;

  if (sl == 0)
    return (sl = strlist_create (n));

  if (n > sl->list_size)
    {
      sl->list = strvec_resize (sl->list, n + 1);
      for (i = sl->list_size; i <= n; i++)
	sl->list[i] = (char *)NULL;
      sl->list_size = n;
    }
  return sl;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\stringlist.c:67
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\stringlist.c:84
parsing error 
{
  if (sl == 0 || sl->list == 0)
    return;
  strvec_flush (sl->list);
  sl->list_len = 0;
}
warning: parse error {
  if (sl == 0 || sl->list == 0)
    return;
  strvec_flush (sl->list);
  sl->list_len = 0;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\stringlist.c:86
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\stringlist.c:94
parsing error 
{
  if (sl == 0)
    return;
  if (sl->list)
    strvec_dispose (sl->list);
  free (sl);
}
warning: parse error {
  if (sl == 0)
    return;
  if (sl->list)
    strvec_dispose (sl->list);
  free (sl);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\stringlist.c:96
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\stringlist.c:105
parsing error 
{
  int r;

  if (sl == 0 || sl->list == 0 || sl->list_len == 0)
    return 0;

  r = strvec_remove (sl->list, s);
  if (r)
    sl->list_len--;
  return r;
}
warning: parse error {
  int r;

  if (sl == 0 || sl->list == 0 || sl->list_len == 0)
    return 0;

  r = strvec_remove (sl->list, s);
  if (r)
    sl->list_len--;
  return r;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\stringlist.c:108
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\stringlist.c:121
parsing error 
{
  STRINGLIST *new;
  register int i;

  if (sl == 0)
    return ((STRINGLIST *)0);
  new = strlist_create (sl->list_size);
  /* I'd like to use strvec_copy, but that doesn't copy everything. */
  if (sl->list)
    {
      for (i = 0; i < sl->list_size; i++)
	new->list[i] = STRDUP (sl->list[i]);
    }
  new->list_size = sl->list_size;
  new->list_len = sl->list_len;
  /* just being careful */
  if (new->list)
    new->list[new->list_len] = (char *)NULL;
  return new;
}
warning: parse error {
  STRINGLIST *new;
  register int i;

  if (sl == 0)
    return ((STRINGLIST *)0);
  new = strlist_create (sl->list_size);
  /* I'd like to use strvec_copy, but that doesn't copy everything. */
  if (sl->list)
    {
      for (i = 0; i < sl->list_size; i++)
	new->list[i] = STRDUP (sl->list[i]);
    }
  new->list_size = sl->list_size;
  new->list_len = sl->list_len;
  /* just being careful */
  if (new->list)
    new->list[new->list_len] = (char *)NULL;
  return new;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\stringlist.c:123
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\stringlist.c:147
parsing error 
{
  STRINGLIST *sl;
  int i, n, l1, l2;

  l1 = m1 ? m1->list_len : 0;
  l2 = m2 ? m2->list_len : 0;

  sl = strlist_create (l1 + l2 + 1);
  for (i = n = 0; i < l1; i++, n++)
    sl->list[n] = STRDUP (m1->list[i]);
  for (i = 0; i < l2; i++, n++)
    sl->list[n] = STRDUP (m2->list[i]);
  sl->list_len = n;
  sl->list[n] = (char *)NULL;
  return (sl);
}
warning: parse error {
  STRINGLIST *sl;
  int i, n, l1, l2;

  l1 = m1 ? m1->list_len : 0;
  l2 = m2 ? m2->list_len : 0;

  sl = strlist_create (l1 + l2 + 1);
  for (i = n = 0; i < l1; i++, n++)
    sl->list[n] = STRDUP (m1->list[i]);
  for (i = 0; i < l2; i++, n++)
    sl->list[n] = STRDUP (m2->list[i]);
  sl->list_len = n;
  sl->list[n] = (char *)NULL;
  return (sl);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\stringlist.c:149
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\stringlist.c:168
parsing error 
{
  register int i, n, len1, len2;

  if (m1 == 0)
    return (m2 ? strlist_copy (m2) : (STRINGLIST *)0);

  len1 = m1->list_len;
  len2 = m2 ? m2->list_len : 0;

  if (len2)
    {
      m1 = strlist_resize (m1, len1 + len2 + 1);
      for (i = 0, n = len1; i < len2; i++, n++)
	m1->list[n] = STRDUP (m2->list[i]);
      m1->list[n] = (char *)NULL;
      m1->list_len = n;
    }

  return m1;
}
warning: parse error {
  register int i, n, len1, len2;

  if (m1 == 0)
    return (m2 ? strlist_copy (m2) : (STRINGLIST *)0);

  len1 = m1->list_len;
  len2 = m2 ? m2->list_len : 0;

  if (len2)
    {
      m1 = strlist_resize (m1, len1 + len2 + 1);
      for (i = 0, n = len1; i < len2; i++, n++)
	m1->list[n] = STRDUP (m2->list[i]);
      m1->list[n] = (char *)NULL;
      m1->list_len = n;
    }

  return m1;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\stringlist.c:170
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\stringlist.c:192
parsing error 
{
  int plen, slen, tlen, llen, i;
  char *t;

  if (sl == 0 || sl->list == 0 || sl->list_len == 0)
    return sl;

  plen = STRLEN (prefix);
  slen = STRLEN (suffix);

  if (plen == 0 && slen == 0)
    return (sl);

  for (i = 0; i < sl->list_len; i++)
    {
      llen = STRLEN (sl->list[i]);
      tlen = plen + llen + slen + 1;
      t = (char *)xmalloc (tlen + 1);
      if (plen)
	strcpy (t, prefix);
      strcpy (t + plen, sl->list[i]);
      if (slen)
	strcpy (t + plen + llen, suffix);
      free (sl->list[i]);
      sl->list[i] = t;
    }

  return (sl);	 
}
warning: parse error {
  int plen, slen, tlen, llen, i;
  char *t;

  if (sl == 0 || sl->list == 0 || sl->list_len == 0)
    return sl;

  plen = STRLEN (prefix);
  slen = STRLEN (suffix);

  if (plen == 0 && slen == 0)
    return (sl);

  for (i = 0; i < sl->list_len; i++)
    {
      llen = STRLEN (sl->list[i]);
      tlen = plen + llen + slen + 1;
      t = (char *)xmalloc (tlen + 1);
      if (plen)
	strcpy (t, prefix);
      strcpy (t + plen, sl->list[i]);
      if (slen)
	strcpy (t + plen + llen, suffix);
      free (sl->list[i]);
      sl->list[i] = t;
    }

  return (sl);	 
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\stringlist.c:195
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\stringlist.c:226
parsing error 
{
  register int i;

  if (sl == 0)
    return;
  for (i = 0; i < sl->list_len; i++)
    printf ("%s%s\n", prefix ? prefix : "", sl->list[i]);
}
warning: parse error {
  register int i;

  if (sl == 0)
    return;
  for (i = 0; i < sl->list_len; i++)
    printf ("%s%s\n", prefix ? prefix : "", sl->list[i]);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\stringlist.c:229
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\stringlist.c:239
parsing error 
{
  register int i;

  if (sl == 0)
    return;
  for (i = 0; i < sl->list_len; i++)
    if ((*func)(sl->list[i]) < 0)
      break;
}
warning: parse error {
  register int i;

  if (sl == 0)
    return;
  for (i = 0; i < sl->list_len; i++)
    if ((*func)(sl->list[i]) < 0)
      break;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\stringlist.c:242
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\stringlist.c:253
parsing error 
{
  if (sl == 0 || sl->list_len == 0 || sl->list == 0)
    return;
  strvec_sort (sl->list, 0);
}
warning: parse error {
  if (sl == 0 || sl->list_len == 0 || sl->list == 0)
    return;
  strvec_sort (sl->list, 0);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\stringlist.c:255
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\stringlist.c:262
parsing error 
{
  STRINGLIST *ret;
  int slen, len;

  if (list == 0)
    {
      if (ip)
        *ip = 0;
      return ((STRINGLIST *)0);
    }
  slen = list_length (list);
  ret = (STRINGLIST *)xmalloc (sizeof (STRINGLIST));
  ret->list = strvec_from_word_list (list, alloc, starting_index, &len);
  ret->list_size = slen + starting_index;
  ret->list_len = len;
  if (ip)
    *ip = len;
  return ret;
}
warning: parse error {
  STRINGLIST *ret;
  int slen, len;

  if (list == 0)
    {
      if (ip)
        *ip = 0;
      return ((STRINGLIST *)0);
    }
  slen = list_length (list);
  ret = (STRINGLIST *)xmalloc (sizeof (STRINGLIST));
  ret->list = strvec_from_word_list (list, alloc, starting_index, &len);
  ret->list_size = slen + starting_index;
  ret->list_len = len;
  if (ip)
    *ip = len;
  return ret;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\stringlist.c:265
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\stringlist.c:286
parsing error 
{
  WORD_LIST *list;

  if (sl == 0 || sl->list == 0)
    return ((WORD_LIST *)NULL);

  list = strvec_to_word_list (sl->list, alloc, starting_index);
  return list;
}
warning: parse error {
  WORD_LIST *list;

  if (sl == 0 || sl->list == 0)
    return ((WORD_LIST *)NULL);

  list = strvec_to_word_list (sl->list, alloc, starting_index);
  return list;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\stringlist.c:289
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\stringvec.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashtypes.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashansi.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\chartypes.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\shell.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\stringvec.c:37
parsing error 
{
  return ((char **)xmalloc ((n) * sizeof (char *)));
}
warning: parse error {
  return ((char **)xmalloc ((n) * sizeof (char *)));
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\stringvec.c:39
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\stringvec.c:45
parsing error 
{
  return ((char **)malloc ((n) * sizeof (char *)));
}
warning: parse error {
  return ((char **)malloc ((n) * sizeof (char *)));
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\stringvec.c:47
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\stringvec.c:52
parsing error 
{
  return ((char **)xrealloc (array, nsize * sizeof (char *)));
}
warning: parse error {
  return ((char **)xrealloc (array, nsize * sizeof (char *)));
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\stringvec.c:55
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\stringvec.c:60
parsing error 
{
  return ((char **)realloc (array, nsize * sizeof (char *)));
}
warning: parse error {
  return ((char **)realloc (array, nsize * sizeof (char *)));
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\stringvec.c:63
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\stringvec.c:69
parsing error 
{
  register int i;

  for (i = 0; array[i]; i++);
  return (i);
}
warning: parse error {
  register int i;

  for (i = 0; array[i]; i++);
  return (i);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\stringvec.c:71
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\stringvec.c:80
parsing error 
{
  register int i;

  if (array == 0)
    return;

  for (i = 0; array[i]; i++)
    free (array[i]);
}
warning: parse error {
  register int i;

  if (array == 0)
    return;

  for (i = 0; array[i]; i++)
    free (array[i]);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\stringvec.c:82
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\stringvec.c:93
parsing error 
{
  if (array == 0)
    return;

  strvec_flush (array);
  free (array);
}
warning: parse error {
  if (array == 0)
    return;

  strvec_flush (array);
  free (array);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\stringvec.c:95
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\stringvec.c:104
parsing error 
{
  register int i, j;
  char *x;

  if (array == 0)
    return 0;

  for (i = 0; array[i]; i++)
    if (STREQ (name, array[i]))
      {
	x = array[i];
	for (j = i; array[j]; j++)
	  array[j] = array[j + 1];
	free (x);
	return 1;
      }
  return 0;
}
warning: parse error {
  register int i, j;
  char *x;

  if (array == 0)
    return 0;

  for (i = 0; array[i]; i++)
    if (STREQ (name, array[i]))
      {
	x = array[i];
	for (j = i; array[j]; j++)
	  array[j] = array[j + 1];
	free (x);
	return 1;
      }
  return 0;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\stringvec.c:106
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\stringvec.c:128
parsing error 
{
  int i;

  for (i = 0; array[i]; i++)
    if (STREQ (name, array[i]))
      return (i);

  return (-1);
}
warning: parse error {
  int i;

  for (i = 0; array[i]; i++)
    if (STREQ (name, array[i]))
      return (i);

  return (-1);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\stringvec.c:130
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\stringvec.c:142
parsing error 
{
  register int i;
  int len;
  char **ret;

  len = strvec_len (array);

  ret = (char **)xmalloc ((len + 1) * sizeof (char *));
  for (i = 0; array[i]; i++)
    ret[i] = savestring (array[i]);
  ret[i] = (char *)NULL;

  return (ret);
}
warning: parse error {
  register int i;
  int len;
  char **ret;

  len = strvec_len (array);

  ret = (char **)xmalloc ((len + 1) * sizeof (char *));
  for (i = 0; array[i]; i++)
    ret[i] = savestring (array[i]);
  ret[i] = (char *)NULL;

  return (ret);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\stringvec.c:144
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\stringvec.c:164
parsing error 
{
  int result;

#if defined (HAVE_STRCOLL)
   result = strcoll (*s1, *s2);
   if (result != 0)
     return result;
#endif

  if ((result = **s1 - **s2) == 0)
    result = strcmp (*s1, *s2);

  return (result);
}
warning: parse error {
  int result;

#if defined (HAVE_STRCOLL)
   result = strcoll (*s1, *s2);
   if (result != 0)
     return result;
#endif

  if ((result = **s1 - **s2) == 0)
    result = strcmp (*s1, *s2);

  return (result);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\stringvec.c:166
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\stringvec.c:184
parsing error 
{
#if defined (HAVE_STRCOLL)
   return (strcoll (*s1, *s2));
#else /* !HAVE_STRCOLL */
  int result;

  if ((result = **s1 - **s2) == 0)
    result = strcmp (*s1, *s2);

  return (result);
#endif /* !HAVE_STRCOLL */
}
warning: parse error {
#if defined (HAVE_STRCOLL)
   return (strcoll (*s1, *s2));
#else /* !HAVE_STRCOLL */
  int result;

  if ((result = **s1 - **s2) == 0)
    result = strcmp (*s1, *s2);

  return (result);
#endif /* !HAVE_STRCOLL */
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\stringvec.c:186
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\stringvec.c:201
parsing error 
{
  if (posix)
    qsort (array, strvec_len (array), sizeof (char *), (QSFUNC *)strvec_posixcmp);
  else
    qsort (array, strvec_len (array), sizeof (char *), (QSFUNC *)strvec_strcmp);
}
warning: parse error {
  if (posix)
    qsort (array, strvec_len (array), sizeof (char *), (QSFUNC *)strvec_posixcmp);
  else
    qsort (array, strvec_len (array), sizeof (char *), (QSFUNC *)strvec_strcmp);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\stringvec.c:204
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\stringvec.c:220
parsing error 
{
  int count;
  char **array;

  count = list_length (list);
  array = (char **)xmalloc ((1 + count + starting_index) * sizeof (char *));

  for (count = 0; count < starting_index; count++)
    array[count] = (char *)NULL;
  for (count = starting_index; list; count++, list = list->next)
    array[count] = alloc ? savestring (list->word->word) : list->word->word;
  array[count] = (char *)NULL;

  if (ip)
    *ip = count;
  return (array);
}
warning: parse error {
  int count;
  char **array;

  count = list_length (list);
  array = (char **)xmalloc ((1 + count + starting_index) * sizeof (char *));

  for (count = 0; count < starting_index; count++)
    array[count] = (char *)NULL;
  for (count = starting_index; list; count++, list = list->next)
    array[count] = alloc ? savestring (list->word->word) : list->word->word;
  array[count] = (char *)NULL;

  if (ip)
    *ip = count;
  return (array);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\stringvec.c:223
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\stringvec.c:247
parsing error 
{
  WORD_LIST *list;
  WORD_DESC *w;
  int i, count;

  if (array == 0 || array[0] == 0)
    return (WORD_LIST *)NULL;

  for (count = 0; array[count]; count++)
    ;

  for (i = starting_index, list = (WORD_LIST *)NULL; i < count; i++)
    {
      w = make_bare_word (alloc ? array[i] : "");
      if (alloc == 0)
	{
	  free (w->word);
	  w->word = array[i];
	}
      list = make_word_list (w, list);
    }
  return (REVERSE_LIST (list, WORD_LIST *));
}
warning: parse error {
  WORD_LIST *list;
  WORD_DESC *w;
  int i, count;

  if (array == 0 || array[0] == 0)
    return (WORD_LIST *)NULL;

  for (count = 0; array[count]; count++)
    ;

  for (i = starting_index, list = (WORD_LIST *)NULL; i < count; i++)
    {
      w = make_bare_word (alloc ? array[i] : "");
      if (alloc == 0)
	{
	  free (w->word);
	  w->word = array[i];
	}
      list = make_word_list (w, list);
    }
  return (REVERSE_LIST (list, WORD_LIST *));
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\stringvec.c:250
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\strnlen.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\stdc.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\strnlen.c:38
parsing error 
{
  register const char *e;
  size_t n;

  for (e = s, n = 0; *e && n < maxlen; e++, n++)
    ;
  return n;
}
warning: parse error {
  register const char *e;
  size_t n;

  for (e = s, n = 0; *e && n < maxlen; e++, n++)
    ;
  return n;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\strnlen.c:41
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\strpbrk.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\stdc.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\strpbrk.c:34
parsing error 
{
  while (*s != '\0')
    {
      const char *a = accept;
      while (*a != '\0')
	if (*a++ == *s)
	  return (char *) s;
      ++s;
    }

  return 0;
}
warning: parse error {
  while (*s != '\0')
    {
      const char *a = accept;
      while (*a != '\0')
	if (*a++ == *s)
	  return (char *) s;
      ++s;
    }

  return 0;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\strpbrk.c:37
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\strstr.c...
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\strtod.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\chartypes.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashansi.h...skip
parsing error 
extern int locale_decpoint PARAMS((void));
warning: parse error extern int locale_decpoint PARAMS((void));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\strtod.c:53
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\strtod.c:60
parsing error 
{
  register const char *s;
  short sign;

  /* The number so far.  */
  double num;

  int radixchar;
  int got_dot;			/* Found a decimal point.  */
  int got_digit;		/* Seen any digits.  */

  /* The exponent of the number.  */
  long int exponent;

  if (nptr == NULL)
    {
      errno = EINVAL;
      goto noconv;
    }

  s = nptr;

  /* Eat whitespace.  */
  while (ISSPACE ((unsigned char)*s))
    ++s;

  /* Get the sign.  */
  sign = *s == '-' ? -1 : 1;
  if (*s == '-' || *s == '+')
    ++s;

  radixchar = locale_decpoint ();
  num = 0.0;
  got_dot = 0;
  got_digit = 0;
  exponent = 0;
  for (;; ++s)
    {
      if (DIGIT (*s))
	{
	  got_digit = 1;

	  /* Make sure that multiplication by 10 will not overflow.  */
	  if (num > DBL_MAX * 0.1)
	    /* The value of the digit doesn't matter, since we have already
	       gotten as many digits as can be represented in a `double'.
	       This doesn't necessarily mean the result will overflow.
	       The exponent may reduce it to within range.

	       We just need to record that there was another
	       digit so that we can multiply by 10 later.  */
	    ++exponent;
	  else
	    num = (num * 10.0) + (*s - '0');

	  /* Keep track of the number of digits after the decimal point.
	     If we just divided by 10 here, we would lose precision.  */
	  if (got_dot)
	    --exponent;
	}
      else if (!got_dot && *s == radixchar)
	/* Record that we have found the decimal point.  */
	got_dot = 1;
      else
	/* Any other character terminates the number.  */
	break;
    }

  if (!got_digit)
    goto noconv;

  if (TOLOWER ((unsigned char)*s) == 'e')
    {
      /* Get the exponent specified after the `e' or `E'.  */
      int save = errno;
      char *end;
      long int exp;

      errno = 0;
      ++s;
      exp = strtol (s, &end, 10);
      if (errno == ERANGE)
	{
	  /* The exponent overflowed a `long int'.  It is probably a safe
	     assumption that an exponent that cannot be represented by
	     a `long int' exceeds the limits of a `double'.  */
	  if (endptr != NULL)
	    *endptr = end;
	  if (exp < 0)
	    goto underflow;
	  else
	    goto overflow;
	}
      else if (end == s)
	/* There was no exponent.  Reset END to point to
	   the 'e' or 'E', so *ENDPTR will be set there.  */
	end = (char *) s - 1;
      errno = save;
      s = end;
      exponent += exp;
    }

  if (endptr != NULL)
    *endptr = (char *) s;

  if (num == 0.0)
    return 0.0;

  /* Multiply NUM by 10 to the EXPONENT power,
     checking for overflow and underflow.  */

  if (exponent < 0)
    {
      if (num < DBL_MIN * pow (10.0, (double) -exponent))
	goto underflow;
    }
  else if (exponent > 0)
    {
      if (num > DBL_MAX * pow (10.0, (double) -exponent))
	goto overflow;
    }

  num *= pow (10.0, (double) exponent);

  return num * sign;

overflow:
  /* Return an overflow error.  */
  errno = ERANGE;
  return HUGE_VAL * sign;

underflow:
  /* Return an underflow error.  */
  if (endptr != NULL)
    *endptr = (char *) nptr;
  errno = ERANGE;
  return 0.0;

noconv:
  /* There was no number.  */
  if (endptr != NULL)
    *endptr = (char *) nptr;
  return 0.0;
}
warning: parse error {
  register const char *s;
  short sign;

  /* The number so far.  */
  double num;

  int radixchar;
  int got_dot;			/* Found a decimal point.  */
  int got_digit;		/* Seen any digits.  */

  /* The exponent of the number.  */
  long int exponent;

  if (nptr == NULL)
    {
      errno = EINVAL;
      goto noconv;
    }

  s = nptr;

  /* Eat whitespace.  */
  while (ISSPACE ((unsigned char)*s))
    ++s;

  /* Get the sign.  */
  sign = *s == '-' ? -1 : 1;
  if (*s == '-' || *s == '+')
    ++s;

  radixchar = locale_decpoint ();
  num = 0.0;
  got_dot = 0;
  got_digit = 0;
  exponent = 0;
  for (;; ++s)
    {
      if (DIGIT (*s))
	{
	  got_digit = 1;

	  /* Make sure that multiplication by 10 will not overflow.  */
	  if (num > DBL_MAX * 0.1)
	    /* The value of the digit doesn't matter, since we have already
	       gotten as many digits as can be represented in a `double'.
	       This doesn't necessarily mean the result will overflow.
	       The exponent may reduce it to within range.

	       We just need to record that there was another
	       digit so that we can multiply by 10 later.  */
	    ++exponent;
	  else
	    num = (num * 10.0) + (*s - '0');

	  /* Keep track of the number of digits after the decimal point.
	     If we just divided by 10 here, we would lose precision.  */
	  if (got_dot)
	    --exponent;
	}
      else if (!got_dot && *s == radixchar)
	/* Record that we have found the decimal point.  */
	got_dot = 1;
      else
	/* Any other character terminates the number.  */
	break;
    }

  if (!got_digit)
    goto noconv;

  if (TOLOWER ((unsigned char)*s) == 'e')
    {
      /* Get the exponent specified after the `e' or `E'.  */
      int save = errno;
      char *end;
      long int exp;

      errno = 0;
      ++s;
      exp = strtol (s, &end, 10);
      if (errno == ERANGE)
	{
	  /* The exponent overflowed a `long int'.  It is probably a safe
	     assumption that an exponent that cannot be represented by
	     a `long int' exceeds the limits of a `double'.  */
	  if (endptr != NULL)
	    *endptr = end;
	  if (exp < 0)
	    goto underflow;
	  else
	    goto overflow;
	}
      else if (end == s)
	/* There was no exponent.  Reset END to point to
	   the 'e' or 'E', so *ENDPTR will be set there.  */
	end = (char *) s - 1;
      errno = save;
      s = end;
      exponent += exp;
    }

  if (endptr != NULL)
    *endptr = (char *) s;

  if (num == 0.0)
    return 0.0;

  /* Multiply NUM by 10 to the EXPONENT power,
     checking for overflow and underflow.  */

  if (exponent < 0)
    {
      if (num < DBL_MIN * pow (10.0, (double) -exponent))
	goto underflow;
    }
  else if (exponent > 0)
    {
      if (num > DBL_MAX * pow (10.0, (double) -exponent))
	goto overflow;
    }

  num *= pow (10.0, (double) exponent);

  return num * sign;

overflow:
  /* Return an overflow error.  */
  errno = ERANGE;
  return HUGE_VAL * sign;

underflow:
  /* Return an underflow error.  */
  if (endptr != NULL)
    *endptr = (char *) nptr;
  errno = ERANGE;
  return 0.0;

noconv:
  /* There was no number.  */
  if (endptr != NULL)
    *endptr = (char *) nptr;
  return 0.0;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\strtod.c:62
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\strtoimax.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\stdc.h...skip
parsing error 
"this configure-time declaration test was not run"
#endif
#if !HAVE_DECL_STRTOL
extern long strtol PARAMS((const char *, char **, int));
warning: parse error "this configure-time declaration test was not run"
#endif
#if !HAVE_DECL_STRTOL
extern long strtol PARAMS((const char *, char **, int));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\strtoimax.c:45
parsing error 
"this configure-time declaration test was not run"
#endif
#if !HAVE_DECL_STRTOLL && HAVE_LONG_LONG
extern long long strtoll PARAMS((const char *, char **, int));
#endif

#ifdef strtoimax
#undef strtoimax
#endif

intmax_t
strtoimax (ptr, endptr, base)
     const char *ptr;
warning: parse error "this configure-time declaration test was not run"
#endif
#if !HAVE_DECL_STRTOLL && HAVE_LONG_LONG
extern long long strtoll PARAMS((const char *, char **, int));
#endif

#ifdef strtoimax
#undef strtoimax
#endif

intmax_t
strtoimax (ptr, endptr, base)
     const char *ptr;Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\strtoimax.c:52
parsing error 
{
#if HAVE_LONG_LONG
  verify(size_is_that_of_long_or_long_long,
	 (sizeof (intmax_t) == sizeof (long) ||
	  sizeof (intmax_t) == sizeof (long long)));

  if (sizeof (intmax_t) != sizeof (long))
    return (strtoll (ptr, endptr, base));
#else
  verify (size_is_that_of_long, sizeof (intmax_t) == sizeof (long));
#endif

  return (strtol (ptr, endptr, base));
}
warning: parse error {
#if HAVE_LONG_LONG
  verify(size_is_that_of_long_or_long_long,
	 (sizeof (intmax_t) == sizeof (long) ||
	  sizeof (intmax_t) == sizeof (long long)));

  if (sizeof (intmax_t) != sizeof (long))
    return (strtoll (ptr, endptr, base));
#else
  verify (size_is_that_of_long, sizeof (intmax_t) == sizeof (long));
#endif

  return (strtol (ptr, endptr, base));
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\strtoimax.c:67
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\strtol.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\chartypes.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\typemax.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\stdc.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashansi.h...skip
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\strtol.c:94
parsing error 
{
  int negative;
  register unsigned LONG int cutoff;
  register unsigned int cutlim;
  register unsigned LONG int i;
  register const char *s;
  register unsigned char c;
  const char *save, *end;
  int overflow;

  if (base < 0 || base == 1 || base > 36)
    {
      __set_errno (EINVAL);
      return 0;
    }

  save = s = nptr;

  /* Skip white space.  */
  while (ISSPACE ((unsigned char)*s))
    ++s;
  if (*s == '\0')
    goto noconv;

  /* Check for a sign.  */
  if (*s == '-' || *s == '+')
    {
      negative = (*s == '-');
      ++s;
    }
  else
    negative = 0;

  /* Recognize number prefix and if BASE is zero, figure it out ourselves.  */
  if (*s == '0')
    {
      if ((base == 0 || base == 16) && TOUPPER ((unsigned char) s[1]) == 'X')
	{
	  s += 2;
	  base = 16;
	}
      else if (base == 0)
	base = 8;
    }
  else if (base == 0)
    base = 10;

  /* Save the pointer so we can check later if anything happened.  */
  save = s;

  end = NULL;

  cutoff = STRTOL_ULONG_MAX / (unsigned LONG int) base;
  cutlim = STRTOL_ULONG_MAX % (unsigned LONG int) base;

  overflow = 0;
  i = 0;
  c = *s;
  if (sizeof (long int) != sizeof (LONG int))
    {
      unsigned long int j = 0;
      unsigned long int jmax = ULONG_MAX / base;

      for (;c != '\0'; c = *++s)
	{
	  if (s == end)
	    break;
	  if (DIGIT (c))
	    c -= '0';
	  else if (ISALPHA (c))
	    c = TOUPPER (c) - 'A' + 10;
	  else
	    break;

	  if ((int) c >= base)
	    break;
	  /* Note that we never can have an overflow.  */
	  else if (j >= jmax)
	    {
	      /* We have an overflow.  Now use the long representation.  */
	      i = (unsigned LONG int) j;
	      goto use_long;
	    }
	  else
	    j = j * (unsigned long int) base + c;
	}

      i = (unsigned LONG int) j;
    }
  else
    for (;c != '\0'; c = *++s)
      {
	if (s == end)
	  break;
	if (DIGIT (c))
	  c -= '0';
	else if (ISALPHA (c))
	  c = TOUPPER (c) - 'A' + 10;
	else
	  break;
	if ((int) c >= base)
	  break;
	/* Check for overflow.  */
	if (i > cutoff || (i == cutoff && c > cutlim))
	  overflow = 1;
	else
	  {
	  use_long:
	    i *= (unsigned LONG int) base;
	    i += c;
	  }
      }

  /* Check if anything actually happened.  */
  if (s == save)
    goto noconv;

  /* Store in ENDPTR the address of one character
     past the last character we converted.  */
  if (endptr != NULL)
    *endptr = (char *) s;

#if !UNSIGNED
  /* Check for a value that is within the range of
     `unsigned LONG int', but outside the range of `LONG int'.  */
  if (overflow == 0
      && i > (negative
	      ? -((unsigned LONG int) (STRTOL_LONG_MIN + 1)) + 1
	      : (unsigned LONG int) STRTOL_LONG_MAX))
    overflow = 1;
#endif

  if (overflow)
    {
      __set_errno (ERANGE);
#if UNSIGNED
      return STRTOL_ULONG_MAX;
#else
      return negative ? STRTOL_LONG_MIN : STRTOL_LONG_MAX;
#endif
    }

  /* Return the result of the appropriate sign.  */
  return negative ? -i : i;

noconv:
  /* We must handle a special case here: the base is 0 or 16 and the
     first two characters are '0' and 'x', but the rest are no
     hexadecimal digits.  This is no error case.  We return 0 and
     ENDPTR points to the `x`.  */
  if (endptr != NULL)
    {
      if (save - nptr >= 2 && TOUPPER ((unsigned char) save[-1]) == 'X' && save[-2] == '0')
	*endptr = (char *) &save[-1];
      else
	/*  There was no number to convert.  */
	*endptr = (char *) nptr;
    }

  return 0L;
}
warning: parse error {
  int negative;
  register unsigned LONG int cutoff;
  register unsigned int cutlim;
  register unsigned LONG int i;
  register const char *s;
  register unsigned char c;
  const char *save, *end;
  int overflow;

  if (base < 0 || base == 1 || base > 36)
    {
      __set_errno (EINVAL);
      return 0;
    }

  save = s = nptr;

  /* Skip white space.  */
  while (ISSPACE ((unsigned char)*s))
    ++s;
  if (*s == '\0')
    goto noconv;

  /* Check for a sign.  */
  if (*s == '-' || *s == '+')
    {
      negative = (*s == '-');
      ++s;
    }
  else
    negative = 0;

  /* Recognize number prefix and if BASE is zero, figure it out ourselves.  */
  if (*s == '0')
    {
      if ((base == 0 || base == 16) && TOUPPER ((unsigned char) s[1]) == 'X')
	{
	  s += 2;
	  base = 16;
	}
      else if (base == 0)
	base = 8;
    }
  else if (base == 0)
    base = 10;

  /* Save the pointer so we can check later if anything happened.  */
  save = s;

  end = NULL;

  cutoff = STRTOL_ULONG_MAX / (unsigned LONG int) base;
  cutlim = STRTOL_ULONG_MAX % (unsigned LONG int) base;

  overflow = 0;
  i = 0;
  c = *s;
  if (sizeof (long int) != sizeof (LONG int))
    {
      unsigned long int j = 0;
      unsigned long int jmax = ULONG_MAX / base;

      for (;c != '\0'; c = *++s)
	{
	  if (s == end)
	    break;
	  if (DIGIT (c))
	    c -= '0';
	  else if (ISALPHA (c))
	    c = TOUPPER (c) - 'A' + 10;
	  else
	    break;

	  if ((int) c >= base)
	    break;
	  /* Note that we never can have an overflow.  */
	  else if (j >= jmax)
	    {
	      /* We have an overflow.  Now use the long representation.  */
	      i = (unsigned LONG int) j;
	      goto use_long;
	    }
	  else
	    j = j * (unsigned long int) base + c;
	}

      i = (unsigned LONG int) j;
    }
  else
    for (;c != '\0'; c = *++s)
      {
	if (s == end)
	  break;
	if (DIGIT (c))
	  c -= '0';
	else if (ISALPHA (c))
	  c = TOUPPER (c) - 'A' + 10;
	else
	  break;
	if ((int) c >= base)
	  break;
	/* Check for overflow.  */
	if (i > cutoff || (i == cutoff && c > cutlim))
	  overflow = 1;
	else
	  {
	  use_long:
	    i *= (unsigned LONG int) base;
	    i += c;
	  }
      }

  /* Check if anything actually happened.  */
  if (s == save)
    goto noconv;

  /* Store in ENDPTR the address of one character
     past the last character we converted.  */
  if (endptr != NULL)
    *endptr = (char *) s;

#if !UNSIGNED
  /* Check for a value that is within the range of
     `unsigned LONG int', but outside the range of `LONG int'.  */
  if (overflow == 0
      && i > (negative
	      ? -((unsigned LONG int) (STRTOL_LONG_MIN + 1)) + 1
	      : (unsigned LONG int) STRTOL_LONG_MAX))
    overflow = 1;
#endif

  if (overflow)
    {
      __set_errno (ERANGE);
#if UNSIGNED
      return STRTOL_ULONG_MAX;
#else
      return negative ? STRTOL_LONG_MIN : STRTOL_LONG_MAX;
#endif
    }

  /* Return the result of the appropriate sign.  */
  return negative ? -i : i;

noconv:
  /* We must handle a special case here: the base is 0 or 16 and the
     first two characters are '0' and 'x', but the rest are no
     hexadecimal digits.  This is no error case.  We return 0 and
     ENDPTR points to the `x`.  */
  if (endptr != NULL)
    {
      if (save - nptr >= 2 && TOUPPER ((unsigned char) save[-1]) == 'X' && save[-2] == '0')
	*endptr = (char *) &save[-1];
      else
	/*  There was no number to convert.  */
	*endptr = (char *) nptr;
    }

  return 0L;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\strtol.c:97
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\strtoll.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\strtol.c...skip
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\strtoul.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\strtol.c...skip
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\strtoull.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\strtol.c...skip
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\strtoumax.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\stdc.h...skip
parsing error 
"this configure-time declaration test was not run"
#endif
#if !HAVE_DECL_STRTOUL
extern unsigned long strtoul PARAMS((const char *, char **, int));
warning: parse error "this configure-time declaration test was not run"
#endif
#if !HAVE_DECL_STRTOUL
extern unsigned long strtoul PARAMS((const char *, char **, int));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\strtoumax.c:45
parsing error 
"this configure-time declaration test was not run"
#endif
#if !HAVE_DECL_STRTOULL && HAVE_UNSIGNED_LONG_LONG
extern unsigned long long strtoull PARAMS((const char *, char **, int));
#endif

#ifdef strtoumax
#undef strtoumax
#endif

uintmax_t
strtoumax (ptr, endptr, base)
     const char *ptr;
warning: parse error "this configure-time declaration test was not run"
#endif
#if !HAVE_DECL_STRTOULL && HAVE_UNSIGNED_LONG_LONG
extern unsigned long long strtoull PARAMS((const char *, char **, int));
#endif

#ifdef strtoumax
#undef strtoumax
#endif

uintmax_t
strtoumax (ptr, endptr, base)
     const char *ptr;Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\strtoumax.c:52
parsing error 
{
#if HAVE_UNSIGNED_LONG_LONG
  verify (size_is_that_of_unsigned_long_or_unsigned_long_long,
	  (sizeof (uintmax_t) == sizeof (unsigned long) ||
	   sizeof (uintmax_t) == sizeof (unsigned long long)));

  if (sizeof (uintmax_t) != sizeof (unsigned long))
    return (strtoull (ptr, endptr, base));
#else
  verify (size_is_that_of_unsigned_long, sizeof (uintmax_t) == sizeof (unsigned long));
#endif

  return (strtoul (ptr, endptr, base));
}
warning: parse error {
#if HAVE_UNSIGNED_LONG_LONG
  verify (size_is_that_of_unsigned_long_or_unsigned_long_long,
	  (sizeof (uintmax_t) == sizeof (unsigned long) ||
	   sizeof (uintmax_t) == sizeof (unsigned long long)));

  if (sizeof (uintmax_t) != sizeof (unsigned long))
    return (strtoull (ptr, endptr, base));
#else
  verify (size_is_that_of_unsigned_long, sizeof (uintmax_t) == sizeof (unsigned long));
#endif

  return (strtoul (ptr, endptr, base));
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\strtoumax.c:67
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\strtrans.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashansi.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\chartypes.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\shell.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\shmbchar.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\shmbutil.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\strtrans.c:51
parsing error 
{
  int c, temp;
  char *ret, *r, *s;
  unsigned long v;
  size_t clen;
  int b, mb_cur_max;
#if defined (HANDLE_MULTIBYTE)
  wchar_t wc;
#endif

  if (string == 0 || *string == '\0')
    return ((char *)NULL);

  mb_cur_max = MB_CUR_MAX;
#if defined (HANDLE_MULTIBYTE)
  temp = 4*len + 4;
  if (temp < 12)
    temp = 12;				/* ensure enough for eventual u32cesc */
  ret = (char *)xmalloc (temp);
#else
  ret = (char *)xmalloc (2*len + 1);	/* 2*len for possible CTLESC */
#endif
  for (r = ret, s = string; s && *s; )
    {
      c = *s++;
      if (c != '\\' || *s == '\0')
	{
	  clen = 1;
#if defined (HANDLE_MULTIBYTE)
	  if ((locale_utf8locale && (c & 0x80)) ||
	      (locale_utf8locale == 0 && mb_cur_max > 0 && is_basic (c) == 0))
	    {
	      clen = mbrtowc (&wc, s - 1, mb_cur_max, 0);
	      if (MB_INVALIDCH (clen))
		clen = 1;
	    }
#endif
	  *r++ = c;
	  for (--clen; clen > 0; clen--)
	    *r++ = *s++;
	}
      else
	{
	  switch (c = *s++)
	    {
#if defined (__STDC__)
	    case 'a': c = '\a'; break;
	    case 'v': c = '\v'; break;
#else
	    case 'a': c = (int) 0x07; break;
	    case 'v': c = (int) 0x0B; break;
#endif
	    case 'b': c = '\b'; break;
	    case 'e': case 'E':		/* ESC -- non-ANSI */
	      c = ESC; break;
	    case 'f': c = '\f'; break;
	    case 'n': c = '\n'; break;
	    case 'r': c = '\r'; break;
	    case 't': c = '\t'; break;
	    case '1': case '2': case '3':
	    case '4': case '5': case '6':
	    case '7':
#if 1
	      if (flags & 1)
		{
		  *r++ = '\\';
		  break;
		}
	    /*FALLTHROUGH*/
#endif
	    case '0':
	      /* If (FLAGS & 1), we're translating a string for echo -e (or
		 the equivalent xpg_echo option), so we obey the SUSv3/
		 POSIX-2001 requirement and accept 0-3 octal digits after
		 a leading `0'. */
	      temp = 2 + ((flags & 1) && (c == '0'));
	      for (c -= '0'; ISOCTAL (*s) && temp--; s++)
		c = (c * 8) + OCTVALUE (*s);
	      c &= 0xFF;
	      break;
	    case 'x':			/* Hex digit -- non-ANSI */
	      if ((flags & 2) && *s == '{')
		{
		  flags |= 16;		/* internal flag value */
		  s++;
		}
	      /* Consume at least two hex characters */
	      for (temp = 2, c = 0; ISXDIGIT ((unsigned char)*s) && temp--; s++)
		c = (c * 16) + HEXVALUE (*s);
	      /* DGK says that after a `\x{' ksh93 consumes ISXDIGIT chars
		 until a non-xdigit or `}', so potentially more than two
		 chars are consumed. */
	      if (flags & 16)
		{
		  for ( ; ISXDIGIT ((unsigned char)*s); s++)
		    c = (c * 16) + HEXVALUE (*s);
		  flags &= ~16;
		  if (*s == '}')
		    s++;
	        }
	      /* \x followed by non-hex digits is passed through unchanged */
	      else if (temp == 2)
		{
		  *r++ = '\\';
		  c = 'x';
		}
	      c &= 0xFF;
	      break;
#if defined (HANDLE_MULTIBYTE)
	    case 'u':
	    case 'U':
	      temp = (c == 'u') ? 4 : 8;	/* \uNNNN \UNNNNNNNN */
	      for (v = 0; ISXDIGIT ((unsigned char)*s) && temp--; s++)
		v = (v * 16) + HEXVALUE (*s);
	      if (temp == ((c == 'u') ? 4 : 8))
		{
		  *r++ = '\\';	/* c remains unchanged */
		  break;
		}
	      else if (v <= 0x7f)	/* <= 0x7f translates directly */
		{
		  c = v;
		  break;
		}
	      else
		{
		  temp = u32cconv (v, r);
		  r += temp;
		  continue;
		}
#endif
	    case '\\':
	      break;
	    case '\'': case '"': case '?':
	      if (flags & 1)
		*r++ = '\\';
	      break;
	    case 'c':
	      if (sawc)
		{
		  *sawc = 1;
		  *r = '\0';
		  if (rlen)
		    *rlen = r - ret;
		  return ret;
		}
	      else if ((flags & 1) == 0 && *s == 0)
		;		/* pass \c through */
	      else if ((flags & 1) == 0 && (c = *s))
		{
		  s++;
		  if ((flags & 2) && c == '\\' && c == *s)
		    s++;	/* Posix requires $'\c\\' do backslash escaping */
		  c = TOCTRL(c);
		  break;
		}
		/*FALLTHROUGH*/
	    default:
		if ((flags & 4) == 0)
		  *r++ = '\\';
		break;
	    }
	  if ((flags & 2) && (c == CTLESC || c == CTLNUL))
	    *r++ = CTLESC;
	  *r++ = c;
	}
    }
  *r = '\0';
  if (rlen)
    *rlen = r - ret;
  return ret;
}
warning: parse error {
  int c, temp;
  char *ret, *r, *s;
  unsigned long v;
  size_t clen;
  int b, mb_cur_max;
#if defined (HANDLE_MULTIBYTE)
  wchar_t wc;
#endif

  if (string == 0 || *string == '\0')
    return ((char *)NULL);

  mb_cur_max = MB_CUR_MAX;
#if defined (HANDLE_MULTIBYTE)
  temp = 4*len + 4;
  if (temp < 12)
    temp = 12;				/* ensure enough for eventual u32cesc */
  ret = (char *)xmalloc (temp);
#else
  ret = (char *)xmalloc (2*len + 1);	/* 2*len for possible CTLESC */
#endif
  for (r = ret, s = string; s && *s; )
    {
      c = *s++;
      if (c != '\\' || *s == '\0')
	{
	  clen = 1;
#if defined (HANDLE_MULTIBYTE)
	  if ((locale_utf8locale && (c & 0x80)) ||
	      (locale_utf8locale == 0 && mb_cur_max > 0 && is_basic (c) == 0))
	    {
	      clen = mbrtowc (&wc, s - 1, mb_cur_max, 0);
	      if (MB_INVALIDCH (clen))
		clen = 1;
	    }
#endif
	  *r++ = c;
	  for (--clen; clen > 0; clen--)
	    *r++ = *s++;
	}
      else
	{
	  switch (c = *s++)
	    {
#if defined (__STDC__)
	    case 'a': c = '\a'; break;
	    case 'v': c = '\v'; break;
#else
	    case 'a': c = (int) 0x07; break;
	    case 'v': c = (int) 0x0B; break;
#endif
	    case 'b': c = '\b'; break;
	    case 'e': case 'E':		/* ESC -- non-ANSI */
	      c = ESC; break;
	    case 'f': c = '\f'; break;
	    case 'n': c = '\n'; break;
	    case 'r': c = '\r'; break;
	    case 't': c = '\t'; break;
	    case '1': case '2': case '3':
	    case '4': case '5': case '6':
	    case '7':
#if 1
	      if (flags & 1)
		{
		  *r++ = '\\';
		  break;
		}
	    /*FALLTHROUGH*/
#endif
	    case '0':
	      /* If (FLAGS & 1), we're translating a string for echo -e (or
		 the equivalent xpg_echo option), so we obey the SUSv3/
		 POSIX-2001 requirement and accept 0-3 octal digits after
		 a leading `0'. */
	      temp = 2 + ((flags & 1) && (c == '0'));
	      for (c -= '0'; ISOCTAL (*s) && temp--; s++)
		c = (c * 8) + OCTVALUE (*s);
	      c &= 0xFF;
	      break;
	    case 'x':			/* Hex digit -- non-ANSI */
	      if ((flags & 2) && *s == '{')
		{
		  flags |= 16;		/* internal flag value */
		  s++;
		}
	      /* Consume at least two hex characters */
	      for (temp = 2, c = 0; ISXDIGIT ((unsigned char)*s) && temp--; s++)
		c = (c * 16) + HEXVALUE (*s);
	      /* DGK says that after a `\x{' ksh93 consumes ISXDIGIT chars
		 until a non-xdigit or `}', so potentially more than two
		 chars are consumed. */
	      if (flags & 16)
		{
		  for ( ; ISXDIGIT ((unsigned char)*s); s++)
		    c = (c * 16) + HEXVALUE (*s);
		  flags &= ~16;
		  if (*s == '}')
		    s++;
	        }
	      /* \x followed by non-hex digits is passed through unchanged */
	      else if (temp == 2)
		{
		  *r++ = '\\';
		  c = 'x';
		}
	      c &= 0xFF;
	      break;
#if defined (HANDLE_MULTIBYTE)
	    case 'u':
	    case 'U':
	      temp = (c == 'u') ? 4 : 8;	/* \uNNNN \UNNNNNNNN */
	      for (v = 0; ISXDIGIT ((unsigned char)*s) && temp--; s++)
		v = (v * 16) + HEXVALUE (*s);
	      if (temp == ((c == 'u') ? 4 : 8))
		{
		  *r++ = '\\';	/* c remains unchanged */
		  break;
		}
	      else if (v <= 0x7f)	/* <= 0x7f translates directly */
		{
		  c = v;
		  break;
		}
	      else
		{
		  temp = u32cconv (v, r);
		  r += temp;
		  continue;
		}
#endif
	    case '\\':
	      break;
	    case '\'': case '"': case '?':
	      if (flags & 1)
		*r++ = '\\';
	      break;
	    case 'c':
	      if (sawc)
		{
		  *sawc = 1;
		  *r = '\0';
		  if (rlen)
		    *rlen = r - ret;
		  return ret;
		}
	      else if ((flags & 1) == 0 && *s == 0)
		;		/* pass \c through */
	      else if ((flags & 1) == 0 && (c = *s))
		{
		  s++;
		  if ((flags & 2) && c == '\\' && c == *s)
		    s++;	/* Posix requires $'\c\\' do backslash escaping */
		  c = TOCTRL(c);
		  break;
		}
		/*FALLTHROUGH*/
	    default:
		if ((flags & 4) == 0)
		  *r++ = '\\';
		break;
	    }
	  if ((flags & 2) && (c == CTLESC || c == CTLNUL))
	    *r++ = CTLESC;
	  *r++ = c;
	}
    }
  *r = '\0';
  if (rlen)
    *rlen = r - ret;
  return ret;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\strtrans.c:54
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\strtrans.c:230
parsing error 
{
  char *r, *ret, *s;
  int l, rsize;
  unsigned char c;
  size_t clen;
  int b;
#if defined (HANDLE_MULTIBYTE)
  wchar_t wc;
#endif

  if (str == 0 || *str == 0)
    return ((char *)0);

  l = strlen (str);
  rsize = 4 * l + 4;
  r = ret = (char *)xmalloc (rsize);

  *r++ = '$';
  *r++ = '\'';

  for (s = str; c = *s; s++)
    {
      b = l = 1;		/* 1 == add backslash; 0 == no backslash */
      clen = 1;

      switch (c)
	{
	case ESC: c = 'E'; break;
#ifdef __STDC__
	case '\a': c = 'a'; break;
	case '\v': c = 'v'; break;
#else
	case 0x07: c = 'a'; break;
	case 0x0b: c = 'v'; break;
#endif

	case '\b': c = 'b'; break;
	case '\f': c = 'f'; break;
	case '\n': c = 'n'; break;
	case '\r': c = 'r'; break;
	case '\t': c = 't'; break;
	case '\\':
	case '\'':
	  break;
	default:
#if defined (HANDLE_MULTIBYTE)
	  b = is_basic (c);
	  /* XXX - clen comparison to 0 is dicey */
	  if ((b == 0 && ((clen = mbrtowc (&wc, s, MB_CUR_MAX, 0)) < 0 || MB_INVALIDCH (clen) || iswprint (wc) == 0)) ||
	      (b == 1 && ISPRINT (c) == 0))
#else
	  if (ISPRINT (c) == 0)
#endif
	    {
	      *r++ = '\\';
	      *r++ = TOCHAR ((c >> 6) & 07);
	      *r++ = TOCHAR ((c >> 3) & 07);
	      *r++ = TOCHAR (c & 07);
	      continue;
	    }
	  l = 0;
	  break;
	}
      if (b == 0 && clen == 0)
	break;

      if (l)
	*r++ = '\\';

      if (clen == 1)
	*r++ = c;
      else
	{
	  for (b = 0; b < (int)clen; b++)
	    *r++ = (unsigned char)s[b];
	  s += clen - 1;	/* -1 because of the increment above */
	}
    }

  *r++ = '\'';
  *r = '\0';
  if (rlen)
    *rlen = r - ret;
  return ret;
}
warning: parse error {
  char *r, *ret, *s;
  int l, rsize;
  unsigned char c;
  size_t clen;
  int b;
#if defined (HANDLE_MULTIBYTE)
  wchar_t wc;
#endif

  if (str == 0 || *str == 0)
    return ((char *)0);

  l = strlen (str);
  rsize = 4 * l + 4;
  r = ret = (char *)xmalloc (rsize);

  *r++ = '$';
  *r++ = '\'';

  for (s = str; c = *s; s++)
    {
      b = l = 1;		/* 1 == add backslash; 0 == no backslash */
      clen = 1;

      switch (c)
	{
	case ESC: c = 'E'; break;
#ifdef __STDC__
	case '\a': c = 'a'; break;
	case '\v': c = 'v'; break;
#else
	case 0x07: c = 'a'; break;
	case 0x0b: c = 'v'; break;
#endif

	case '\b': c = 'b'; break;
	case '\f': c = 'f'; break;
	case '\n': c = 'n'; break;
	case '\r': c = 'r'; break;
	case '\t': c = 't'; break;
	case '\\':
	case '\'':
	  break;
	default:
#if defined (HANDLE_MULTIBYTE)
	  b = is_basic (c);
	  /* XXX - clen comparison to 0 is dicey */
	  if ((b == 0 && ((clen = mbrtowc (&wc, s, MB_CUR_MAX, 0)) < 0 || MB_INVALIDCH (clen) || iswprint (wc) == 0)) ||
	      (b == 1 && ISPRINT (c) == 0))
#else
	  if (ISPRINT (c) == 0)
#endif
	    {
	      *r++ = '\\';
	      *r++ = TOCHAR ((c >> 6) & 07);
	      *r++ = TOCHAR ((c >> 3) & 07);
	      *r++ = TOCHAR (c & 07);
	      continue;
	    }
	  l = 0;
	  break;
	}
      if (b == 0 && clen == 0)
	break;

      if (l)
	*r++ = '\\';

      if (clen == 1)
	*r++ = c;
      else
	{
	  for (b = 0; b < (int)clen; b++)
	    *r++ = (unsigned char)s[b];
	  s += clen - 1;	/* -1 because of the increment above */
	}
    }

  *r++ = '\'';
  *r = '\0';
  if (rlen)
    *rlen = r - ret;
  return ret;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\strtrans.c:233
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\strtrans.c:352
parsing error 
{
  const char *s;
  unsigned char c;

  if (string == 0)
    return 0;

  for (s = string; c = *s; s++)
    {
#if defined (HANDLE_MULTIBYTE)
      if (is_basic (c) == 0)
	return (ansic_wshouldquote (s));
#endif
      if (ISPRINT (c) == 0)
	return 1;
    }

  return 0;
}
warning: parse error {
  const char *s;
  unsigned char c;

  if (string == 0)
    return 0;

  for (s = string; c = *s; s++)
    {
#if defined (HANDLE_MULTIBYTE)
      if (is_basic (c) == 0)
	return (ansic_wshouldquote (s));
#endif
      if (ISPRINT (c) == 0)
	return 1;
    }

  return 0;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\strtrans.c:353
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\strtrans.c:376
parsing error 
{
  char *temp, *t;
  int len, tlen;

  temp = (char *)xmalloc (end - start + 1);
  for (tlen = 0, len = start; len < end; )
    temp[tlen++] = string[len++];
  temp[tlen] = '\0';

  if (*temp)
    {
      t = ansicstr (temp, tlen, 2, (int *)NULL, lenp);
      free (temp);
      return (t);
    }
  else
    {
      if (lenp)
	*lenp = 0;
      return (temp);
    }
}
warning: parse error {
  char *temp, *t;
  int len, tlen;

  temp = (char *)xmalloc (end - start + 1);
  for (tlen = 0, len = start; len < end; )
    temp[tlen++] = string[len++];
  temp[tlen] = '\0';

  if (*temp)
    {
      t = ansicstr (temp, tlen, 2, (int *)NULL, lenp);
      free (temp);
      return (t);
    }
  else
    {
      if (lenp)
	*lenp = 0;
      return (temp);
    }
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\strtrans.c:379
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\times.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\posixtime.h...skip
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\systimes.h...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\stdc.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\times.c:38
parsing error 
{
	clock_t rv;
	static long clk_tck = -1;

#if defined (HAVE_GETRUSAGE)
	struct timeval tv;
	struct rusage ru;

	if (clk_tck == -1)
		clk_tck = get_clk_tck();

	if (getrusage(RUSAGE_SELF, &ru) < 0)
		return ((clock_t)-1);
	tms->tms_utime = CONVTCK(ru.ru_utime);
	tms->tms_stime = CONVTCK(ru.ru_stime);

	if (getrusage(RUSAGE_CHILDREN, &ru) < 0)
		return ((clock_t)-1);
	tms->tms_cutime = CONVTCK(ru.ru_utime);
	tms->tms_cstime = CONVTCK(ru.ru_stime);

	if (gettimeofday(&tv, NULL) < 0)
		return ((clock_t)-1);
	rv = (clock_t)(CONVTCK(tv));
#else /* !HAVE_GETRUSAGE */
	if (clk_tck == -1)
		clk_tck = get_clk_tck();

	/* We can't do anything. */
	tms->tms_utime = tms->tms_stime = (clock_t)0;
	tms->tms_cutime = tms->tms_cstime = (clock_t)0;

	rv = (clock_t)time((time_t *)0) * clk_tck;
# endif /* HAVE_GETRUSAGE */

	return rv;
}
warning: parse error {
	clock_t rv;
	static long clk_tck = -1;

#if defined (HAVE_GETRUSAGE)
	struct timeval tv;
	struct rusage ru;

	if (clk_tck == -1)
		clk_tck = get_clk_tck();

	if (getrusage(RUSAGE_SELF, &ru) < 0)
		return ((clock_t)-1);
	tms->tms_utime = CONVTCK(ru.ru_utime);
	tms->tms_stime = CONVTCK(ru.ru_stime);

	if (getrusage(RUSAGE_CHILDREN, &ru) < 0)
		return ((clock_t)-1);
	tms->tms_cutime = CONVTCK(ru.ru_utime);
	tms->tms_cstime = CONVTCK(ru.ru_stime);

	if (gettimeofday(&tv, NULL) < 0)
		return ((clock_t)-1);
	rv = (clock_t)(CONVTCK(tv));
#else /* !HAVE_GETRUSAGE */
	if (clk_tck == -1)
		clk_tck = get_clk_tck();

	/* We can't do anything. */
	tms->tms_utime = tms->tms_stime = (clock_t)0;
	tms->tms_cutime = tms->tms_cstime = (clock_t)0;

	rv = (clock_t)time((time_t *)0) * clk_tck;
# endif /* HAVE_GETRUSAGE */

	return rv;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\times.c:40
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\timeval.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\posixtime.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashintl.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\stdc.h...skip
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\tmpfile.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashtypes.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\posixstat.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\posixtime.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\filecntl.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashansi.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\shell.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\tmpfile.c:95
parsing error 
{
  char *tdir;

  tdir = (flags & MT_USETMPDIR) ? get_string_value ("TMPDIR") : (char *)NULL;
  if (tdir && (file_iswdir (tdir) == 0 || strlen (tdir) > PATH_MAX))
    tdir = 0;

  if (tdir == 0)
    tdir = get_sys_tmpdir ();

#if defined (HAVE_PATHCONF) && defined (_PC_NAME_MAX)
  if (tmpnamelen == -1)
    tmpnamelen = pathconf (tdir, _PC_NAME_MAX);
#else
  tmpnamelen = 0;
#endif

  return tdir;
}
warning: parse error {
  char *tdir;

  tdir = (flags & MT_USETMPDIR) ? get_string_value ("TMPDIR") : (char *)NULL;
  if (tdir && (file_iswdir (tdir) == 0 || strlen (tdir) > PATH_MAX))
    tdir = 0;

  if (tdir == 0)
    tdir = get_sys_tmpdir ();

#if defined (HAVE_PATHCONF) && defined (_PC_NAME_MAX)
  if (tmpnamelen == -1)
    tmpnamelen = pathconf (tdir, _PC_NAME_MAX);
#else
  tmpnamelen = 0;
#endif

  return tdir;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\tmpfile.c:97
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\tmpfile.c:135
parsing error 
{
  char *filename, *tdir, *lroot;
  struct stat sb;
  int r, tdlen;
  static int seeded = 0;

  filename = (char *)xmalloc (PATH_MAX + 1);
  tdir = get_tmpdir (flags);
  tdlen = strlen (tdir);

  lroot = nameroot ? nameroot : DEFAULT_NAMEROOT;
  if (nameroot == 0)
    flags &= ~MT_TEMPLATE;

  if ((flags & MT_TEMPLATE) && strlen (nameroot) > PATH_MAX)
    flags &= ~MT_TEMPLATE;

#ifdef USE_MKTEMP
  if (flags & MT_TEMPLATE)
    strcpy (filename, nameroot);
  else
    sprintf (filename, "%s/%s.XXXXXX", tdir, lroot);
  if (mktemp (filename) == 0)
    {
      free (filename);
      filename = NULL;
    }
#else  /* !USE_MKTEMP */
  sh_seedrand ();
  while (1)
    {
      filenum = (filenum << 1) ^
		(unsigned long) time ((time_t *)0) ^
		(unsigned long) dollar_dollar_pid ^
		(unsigned long) ((flags & MT_USERANDOM) ? random () : ntmpfiles++);
      sprintf (filename, "%s/%s-%lu", tdir, lroot, filenum);
      if (tmpnamelen > 0 && tmpnamelen < 32)
	filename[tdlen + 1 + tmpnamelen] = '\0';
#  ifdef HAVE_LSTAT
      r = lstat (filename, &sb);
#  else
      r = stat (filename, &sb);
#  endif
      if (r < 0 && errno == ENOENT)
	break;
    }
#endif /* !USE_MKTEMP */

  return filename;
}
warning: parse error {
  char *filename, *tdir, *lroot;
  struct stat sb;
  int r, tdlen;
  static int seeded = 0;

  filename = (char *)xmalloc (PATH_MAX + 1);
  tdir = get_tmpdir (flags);
  tdlen = strlen (tdir);

  lroot = nameroot ? nameroot : DEFAULT_NAMEROOT;
  if (nameroot == 0)
    flags &= ~MT_TEMPLATE;

  if ((flags & MT_TEMPLATE) && strlen (nameroot) > PATH_MAX)
    flags &= ~MT_TEMPLATE;

#ifdef USE_MKTEMP
  if (flags & MT_TEMPLATE)
    strcpy (filename, nameroot);
  else
    sprintf (filename, "%s/%s.XXXXXX", tdir, lroot);
  if (mktemp (filename) == 0)
    {
      free (filename);
      filename = NULL;
    }
#else  /* !USE_MKTEMP */
  sh_seedrand ();
  while (1)
    {
      filenum = (filenum << 1) ^
		(unsigned long) time ((time_t *)0) ^
		(unsigned long) dollar_dollar_pid ^
		(unsigned long) ((flags & MT_USERANDOM) ? random () : ntmpfiles++);
      sprintf (filename, "%s/%s-%lu", tdir, lroot, filenum);
      if (tmpnamelen > 0 && tmpnamelen < 32)
	filename[tdlen + 1 + tmpnamelen] = '\0';
#  ifdef HAVE_LSTAT
      r = lstat (filename, &sb);
#  else
      r = stat (filename, &sb);
#  endif
      if (r < 0 && errno == ENOENT)
	break;
    }
#endif /* !USE_MKTEMP */

  return filename;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\tmpfile.c:138
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\tmpfile.c:190
parsing error 
{
  char *filename, *tdir, *lroot;
  int fd, tdlen;
  
  filename = (char *)xmalloc (PATH_MAX + 1);
  tdir = get_tmpdir (flags);
  tdlen = strlen (tdir);

  lroot = nameroot ? nameroot : DEFAULT_NAMEROOT;
  if (nameroot == 0)
    flags &= ~MT_TEMPLATE;

  if ((flags & MT_TEMPLATE) && strlen (nameroot) > PATH_MAX)
    flags &= ~MT_TEMPLATE;

#ifdef USE_MKSTEMP
  if (flags & MT_TEMPLATE)
    strcpy (filename, nameroot);
  else
    sprintf (filename, "%s/%s.XXXXXX", tdir, lroot);
  fd = mkstemp (filename);
  if (fd < 0 || namep == 0)
    {
      free (filename);
      filename = NULL;
    }
  if (namep)
    *namep = filename;
  return fd;
#else /* !USE_MKSTEMP */
  sh_seedrand ();
  do
    {
      filenum = (filenum << 1) ^
		(unsigned long) time ((time_t *)0) ^
		(unsigned long) dollar_dollar_pid ^
		(unsigned long) ((flags & MT_USERANDOM) ? random () : ntmpfiles++);
      sprintf (filename, "%s/%s-%lu", tdir, lroot, filenum);
      if (tmpnamelen > 0 && tmpnamelen < 32)
	filename[tdlen + 1 + tmpnamelen] = '\0';
      fd = open (filename, BASEOPENFLAGS | ((flags & MT_READWRITE) ? O_RDWR : O_WRONLY), 0600);
    }
  while (fd < 0 && errno == EEXIST);

  if (namep)
    *namep = filename;
  else
    free (filename);

  return fd;
#endif /* !USE_MKSTEMP */
}
warning: parse error {
  char *filename, *tdir, *lroot;
  int fd, tdlen;
  
  filename = (char *)xmalloc (PATH_MAX + 1);
  tdir = get_tmpdir (flags);
  tdlen = strlen (tdir);

  lroot = nameroot ? nameroot : DEFAULT_NAMEROOT;
  if (nameroot == 0)
    flags &= ~MT_TEMPLATE;

  if ((flags & MT_TEMPLATE) && strlen (nameroot) > PATH_MAX)
    flags &= ~MT_TEMPLATE;

#ifdef USE_MKSTEMP
  if (flags & MT_TEMPLATE)
    strcpy (filename, nameroot);
  else
    sprintf (filename, "%s/%s.XXXXXX", tdir, lroot);
  fd = mkstemp (filename);
  if (fd < 0 || namep == 0)
    {
      free (filename);
      filename = NULL;
    }
  if (namep)
    *namep = filename;
  return fd;
#else /* !USE_MKSTEMP */
  sh_seedrand ();
  do
    {
      filenum = (filenum << 1) ^
		(unsigned long) time ((time_t *)0) ^
		(unsigned long) dollar_dollar_pid ^
		(unsigned long) ((flags & MT_USERANDOM) ? random () : ntmpfiles++);
      sprintf (filename, "%s/%s-%lu", tdir, lroot, filenum);
      if (tmpnamelen > 0 && tmpnamelen < 32)
	filename[tdlen + 1 + tmpnamelen] = '\0';
      fd = open (filename, BASEOPENFLAGS | ((flags & MT_READWRITE) ? O_RDWR : O_WRONLY), 0600);
    }
  while (fd < 0 && errno == EEXIST);

  if (namep)
    *namep = filename;
  else
    free (filename);

  return fd;
#endif /* !USE_MKSTEMP */
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\tmpfile.c:194
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\tmpfile.c:248
parsing error 
{
  int fd;
  FILE *fp;

  fd = sh_mktmpfd (nameroot, flags, namep);
  if (fd < 0)
    return ((FILE *)NULL);
  fp = fdopen (fd, (flags & MT_READWRITE) ? "w+" : "w");
  if (fp == 0)
    close (fd);
  return fp;
}
warning: parse error {
  int fd;
  FILE *fp;

  fd = sh_mktmpfd (nameroot, flags, namep);
  if (fd < 0)
    return ((FILE *)NULL);
  fp = fdopen (fd, (flags & MT_READWRITE) ? "w+" : "w");
  if (fp == 0)
    close (fd);
  return fp;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\tmpfile.c:252
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\tmpfile.c:266
parsing error 
{
  char *filename, *tdir, *lroot, *dirname;
  int fd, tdlen;
  
#ifdef USE_MKDTEMP
  filename = (char *)xmalloc (PATH_MAX + 1);
  tdir = get_tmpdir (flags);
  tdlen = strlen (tdir);

  lroot = nameroot ? nameroot : DEFAULT_NAMEROOT;
  if (nameroot == 0)
    flags &= ~MT_TEMPLATE;

  if ((flags & MT_TEMPLATE) && strlen (nameroot) > PATH_MAX)
    flags &= ~MT_TEMPLATE;

  if (flags & MT_TEMPLATE)
    strcpy (filename, nameroot);
  else
    sprintf (filename, "%s/%s.XXXXXX", tdir, lroot);
  dirname = mkdtemp (filename);
  if (dirname == 0)
    {
      free (filename);
      filename = NULL;
    }
  return dirname;
#else /* !USE_MKDTEMP */
  filename = (char *)NULL;
  do
    {
      filename = sh_mktmpname (nameroot, flags);
      fd = mkdir (filename, 0700);
      if (fd == 0)
	break;
      free (filename);
      filename = (char *)NULL;
    }
  while (fd < 0 && errno == EEXIST);

  return (filename);
#endif /* !USE_MKDTEMP */
}
warning: parse error {
  char *filename, *tdir, *lroot, *dirname;
  int fd, tdlen;
  
#ifdef USE_MKDTEMP
  filename = (char *)xmalloc (PATH_MAX + 1);
  tdir = get_tmpdir (flags);
  tdlen = strlen (tdir);

  lroot = nameroot ? nameroot : DEFAULT_NAMEROOT;
  if (nameroot == 0)
    flags &= ~MT_TEMPLATE;

  if ((flags & MT_TEMPLATE) && strlen (nameroot) > PATH_MAX)
    flags &= ~MT_TEMPLATE;

  if (flags & MT_TEMPLATE)
    strcpy (filename, nameroot);
  else
    sprintf (filename, "%s/%s.XXXXXX", tdir, lroot);
  dirname = mkdtemp (filename);
  if (dirname == 0)
    {
      free (filename);
      filename = NULL;
    }
  return dirname;
#else /* !USE_MKDTEMP */
  filename = (char *)NULL;
  do
    {
      filename = sh_mktmpname (nameroot, flags);
      fd = mkdir (filename, 0700);
      if (fd == 0)
	break;
      free (filename);
      filename = (char *)NULL;
    }
  while (fd < 0 && errno == EEXIST);

  return (filename);
#endif /* !USE_MKDTEMP */
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\tmpfile.c:269
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\uconvert.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashtypes.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\posixtime.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\chartypes.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\shell.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\uconvert.c:60
parsing error 
{
  int n, mult;
  long ipart, upart;
  char *p;

  ipart = upart = 0;
  mult = 1;

  if (s && (*s == '-' || *s == '+'))
    {
      mult = (*s == '-') ? -1 : 1;
      p = s + 1;
    }
  else
    p = s;

  for ( ; p && *p; p++)
    {
      if (*p == DECIMAL)		/* decimal point */
	break;
      if (DIGIT(*p) == 0)
	RETURN(0);
      ipart = (ipart * 10) + (*p - '0');
    }

  if (p == 0 || *p == 0)	/* callers ensure p can never be 0; this is to shut up clang */
    RETURN(1);

  if (*p == DECIMAL)
    p++;

  /* Look for up to six digits past a decimal point. */
  for (n = 0; n < 6 && p[n]; n++)
    {
      if (DIGIT(p[n]) == 0)
	{
	  if (ep)
	    {
	      upart *= multiplier[n];
	      p += n;		/* To set EP */
	    }
	  RETURN(0);
	}
      upart = (upart * 10) + (p[n] - '0');
    }

  /* Now convert to millionths */
  upart *= multiplier[n];

  if (n == 6 && p[6] >= '5' && p[6] <= '9')
    upart++;			/* round up 1 */

  if (ep)
    {
      p += n;
      while (DIGIT(*p))
	p++;
    }

  RETURN(1);
}
warning: parse error {
  int n, mult;
  long ipart, upart;
  char *p;

  ipart = upart = 0;
  mult = 1;

  if (s && (*s == '-' || *s == '+'))
    {
      mult = (*s == '-') ? -1 : 1;
      p = s + 1;
    }
  else
    p = s;

  for ( ; p && *p; p++)
    {
      if (*p == DECIMAL)		/* decimal point */
	break;
      if (DIGIT(*p) == 0)
	RETURN(0);
      ipart = (ipart * 10) + (*p - '0');
    }

  if (p == 0 || *p == 0)	/* callers ensure p can never be 0; this is to shut up clang */
    RETURN(1);

  if (*p == DECIMAL)
    p++;

  /* Look for up to six digits past a decimal point. */
  for (n = 0; n < 6 && p[n]; n++)
    {
      if (DIGIT(p[n]) == 0)
	{
	  if (ep)
	    {
	      upart *= multiplier[n];
	      p += n;		/* To set EP */
	    }
	  RETURN(0);
	}
      upart = (upart * 10) + (p[n] - '0');
    }

  /* Now convert to millionths */
  upart *= multiplier[n];

  if (n == 6 && p[6] >= '5' && p[6] <= '9')
    upart++;			/* round up 1 */

  if (ep)
    {
      p += n;
      while (DIGIT(*p))
	p++;
    }

  RETURN(1);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\uconvert.c:64
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\ufuncs.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashtypes.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\posixtime.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\ufuncs.c:68
parsing error 
{
  if (secs == 0 && usecs == 0)
    return (alarm (0));

  if (secs == 0 || usecs >= 500000)
    {
      secs++;
      usecs = 0;
    }
  return (alarm (secs));
}
warning: parse error {
  if (secs == 0 && usecs == 0)
    return (alarm (0));

  if (secs == 0 || usecs >= 500000)
    {
      secs++;
      usecs = 0;
    }
  return (alarm (secs));
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\ufuncs.c:70
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\ufuncs.c:133
parsing error 
{
  if (usec >= 500000)	/* round */
   sec++;
  return (sleep(sec));
}
warning: parse error {
  if (usec >= 500000)	/* round */
   sec++;
  return (sleep(sec));
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\ufuncs.c:135
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\unicode.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\stdc.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashansi.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\xmalloc.h...skip
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\utf8.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashansi.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\shmbutil.h...skip
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\vprint.c...
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\wcsdup.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\stdc.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashansi.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\xmalloc.h...skip
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\wcsnwidth.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\stdc.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashansi.h...skip
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\wcswidth.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\stdc.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashansi.h...skip
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\winsize.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\stdc.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashtypes.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\winsize.c:76
parsing error 
{
#if defined (TIOCGWINSZ)
  struct winsize win;
  int tty;

  tty = input_tty ();
  if (tty >= 0 && (ioctl (tty, TIOCGWINSZ, &win) == 0) &&
      win.ws_row > 0 && win.ws_col > 0)
    {
      sh_set_lines_and_columns (win.ws_row, win.ws_col);
#if defined (READLINE)
      rl_set_screen_size (win.ws_row, win.ws_col);
      if (rp)
	*rp = win.ws_row;
      if (cp)
	*cp = win.ws_col;
#endif
    }
#endif
}
warning: parse error {
#if defined (TIOCGWINSZ)
  struct winsize win;
  int tty;

  tty = input_tty ();
  if (tty >= 0 && (ioctl (tty, TIOCGWINSZ, &win) == 0) &&
      win.ws_row > 0 && win.ws_col > 0)
    {
      sh_set_lines_and_columns (win.ws_row, win.ws_col);
#if defined (READLINE)
      rl_set_screen_size (win.ws_row, win.ws_col);
      if (rp)
	*rp = win.ws_row;
      if (cp)
	*cp = win.ws_col;
#endif
    }
#endif
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\winsize.c:79
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\zcatfd.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\stdc.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\zcatfd.c:47
parsing error 
{
  ssize_t nr;
  int rval;
  char lbuf[ZBUFSIZ];

  rval = 0;
  while (1)
    {
      nr = zread (fd, lbuf, sizeof (lbuf));
      if (nr == 0)
	break;
      else if (nr < 0)
	{
	  rval = -1;
	  break;
	}
      else if (zwrite (ofd, lbuf, nr) < 0)
	{
	  rval = -1;
	  break;
	}
    }

  return rval;
}
warning: parse error {
  ssize_t nr;
  int rval;
  char lbuf[ZBUFSIZ];

  rval = 0;
  while (1)
    {
      nr = zread (fd, lbuf, sizeof (lbuf));
      if (nr == 0)
	break;
      else if (nr < 0)
	{
	  rval = -1;
	  break;
	}
      else if (zwrite (ofd, lbuf, nr) < 0)
	{
	  rval = -1;
	  break;
	}
    }

  return rval;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\zcatfd.c:50
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\zgetline.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\xmalloc.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\zgetline.c:64
parsing error 
{
  int nr, retval;
  char *line, c;

  if (lineptr == 0 || n == 0 || (*lineptr == 0 && *n != 0))
    return -1;

  nr = 0;
  line = *lineptr;
  
  while (1)
    {
      retval = unbuffered_read ? zread (fd, &c, 1) : zreadc(fd, &c);

      if (retval <= 0)
	{
	  if (line && nr > 0)
	    line[nr] = '\0';
	  break;
	}

      if (nr + 2 >= *n)
	{
	  size_t new_size;

	  new_size = (*n == 0) ? GET_LINE_INITIAL_ALLOCATION : *n * 2;
	  line = (*n >= new_size) ? NULL : xrealloc (*lineptr, new_size);

	  if (line)
	    {
	      *lineptr = line;
	      *n = new_size;
	    }
	  else
	    {
	      if (*n > 0)
		{
		  (*lineptr)[*n - 1] = '\0';
		  nr = *n - 2;
		}
	      break;
	    }
	}

      line[nr] = c;
      nr++;

      if (c == delim)
	{
	  line[nr] = '\0';
	  break;
	}
    }

  return nr - 1;
}
warning: parse error {
  int nr, retval;
  char *line, c;

  if (lineptr == 0 || n == 0 || (*lineptr == 0 && *n != 0))
    return -1;

  nr = 0;
  line = *lineptr;
  
  while (1)
    {
      retval = unbuffered_read ? zread (fd, &c, 1) : zreadc(fd, &c);

      if (retval <= 0)
	{
	  if (line && nr > 0)
	    line[nr] = '\0';
	  break;
	}

      if (nr + 2 >= *n)
	{
	  size_t new_size;

	  new_size = (*n == 0) ? GET_LINE_INITIAL_ALLOCATION : *n * 2;
	  line = (*n >= new_size) ? NULL : xrealloc (*lineptr, new_size);

	  if (line)
	    {
	      *lineptr = line;
	      *n = new_size;
	    }
	  else
	    {
	      if (*n > 0)
		{
		  (*lineptr)[*n - 1] = '\0';
		  nr = *n - 2;
		}
	      break;
	    }
	}

      line[nr] = c;
      nr++;

      if (c == delim)
	{
	  line[nr] = '\0';
	  break;
	}
    }

  return nr - 1;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\zgetline.c:70
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\zmapfd.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashansi.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\command.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\general.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\zmapfd.c:48
parsing error 
{
  ssize_t nr;
  int rval;
  char lbuf[ZBUFSIZ];
  char *result;
  int rsize, rind;

  rval = 0;
  result = (char *)xmalloc (rsize = ZBUFSIZ);
  rind = 0;

  while (1)
    {
      nr = zread (fd, lbuf, sizeof (lbuf));
      if (nr == 0)
	{
	  rval = rind;
	  break;
	}
      else if (nr < 0)
	{
	  free (result);
	  if (ostr)
	    *ostr = (char *)NULL;
	  return -1;
	}

      RESIZE_MALLOCED_BUFFER (result, rind, nr, rsize, ZBUFSIZ);
      memcpy (result+rind, lbuf, nr);
      rind += nr;
    }

  RESIZE_MALLOCED_BUFFER (result, rind, 1, rsize, 128);
  result[rind] = '\0';

  if (ostr)
    *ostr = result;
  else
    free (result);

  return rval;
}
warning: parse error {
  ssize_t nr;
  int rval;
  char lbuf[ZBUFSIZ];
  char *result;
  int rsize, rind;

  rval = 0;
  result = (char *)xmalloc (rsize = ZBUFSIZ);
  rind = 0;

  while (1)
    {
      nr = zread (fd, lbuf, sizeof (lbuf));
      if (nr == 0)
	{
	  rval = rind;
	  break;
	}
      else if (nr < 0)
	{
	  free (result);
	  if (ostr)
	    *ostr = (char *)NULL;
	  return -1;
	}

      RESIZE_MALLOCED_BUFFER (result, rind, nr, rsize, ZBUFSIZ);
      memcpy (result+rind, lbuf, nr);
      rind += nr;
    }

  RESIZE_MALLOCED_BUFFER (result, rind, 1, rsize, 128);
  result[rind] = '\0';

  if (ostr)
    *ostr = result;
  else
    free (result);

  return rval;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\zmapfd.c:52
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\zread.c...
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\zread.c:53
parsing error 
{
  ssize_t r;

  check_signals ();	/* check for signals before a blocking read */
  while ((r = read (fd, buf, len)) < 0 && errno == EINTR)
    {
      int t;
      t = errno;
      /* XXX - bash-5.0 */
      /* We check executing_builtin and run traps here for backwards compatibility */
      if (executing_builtin)
	check_signals_and_traps ();	/* XXX - should it be check_signals()? */
      else
	check_signals ();
      errno = t;
    }

  return r;
}
warning: parse error {
  ssize_t r;

  check_signals ();	/* check for signals before a blocking read */
  while ((r = read (fd, buf, len)) < 0 && errno == EINTR)
    {
      int t;
      t = errno;
      /* XXX - bash-5.0 */
      /* We check executing_builtin and run traps here for backwards compatibility */
      if (executing_builtin)
	check_signals_and_traps ();	/* XXX - should it be check_signals()? */
      else
	check_signals ();
      errno = t;
    }

  return r;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\zread.c:57
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\zread.c:86
parsing error 
{
  ssize_t r;
  int nintr;

  for (nintr = 0; ; )
    {
      r = read (fd, buf, len);
      if (r >= 0)
	return r;
      if (r == -1 && errno == EINTR)
	{
	  if (++nintr >= NUM_INTR)
	    return -1;
	  continue;
	}
      return r;
    }
}
warning: parse error {
  ssize_t r;
  int nintr;

  for (nintr = 0; ; )
    {
      r = read (fd, buf, len);
      if (r >= 0)
	return r;
      if (r == -1 && errno == EINTR)
	{
	  if (++nintr >= NUM_INTR)
	    return -1;
	  continue;
	}
      return r;
    }
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\zread.c:90
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\zread.c:111
parsing error 
{
  check_signals ();
  return (read (fd, buf, len));
}
warning: parse error {
  check_signals ();
  return (read (fd, buf, len));
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\zread.c:115
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\zread.c:128
parsing error 
{
  ssize_t nr;

  if (lind == lused || lused == 0)
    {
      nr = zread (fd, lbuf, sizeof (lbuf));
      lind = 0;
      if (nr <= 0)
	{
	  lused = 0;
	  return nr;
	}
      lused = nr;
    }
  if (cp)
    *cp = lbuf[lind++];
  return 1;
}
warning: parse error {
  ssize_t nr;

  if (lind == lused || lused == 0)
    {
      nr = zread (fd, lbuf, sizeof (lbuf));
      lind = 0;
      if (nr <= 0)
	{
	  lused = 0;
	  return nr;
	}
      lused = nr;
    }
  if (cp)
    *cp = lbuf[lind++];
  return 1;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\zread.c:131
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\zread.c:153
parsing error 
{
  ssize_t nr;

  if (lind == lused || lused == 0)
    {
      nr = zreadintr (fd, lbuf, sizeof (lbuf));
      lind = 0;
      if (nr <= 0)
	{
	  lused = 0;
	  return nr;
	}
      lused = nr;
    }
  if (cp)
    *cp = lbuf[lind++];
  return 1;
}
warning: parse error {
  ssize_t nr;

  if (lind == lused || lused == 0)
    {
      nr = zreadintr (fd, lbuf, sizeof (lbuf));
      lind = 0;
      if (nr <= 0)
	{
	  lused = 0;
	  return nr;
	}
      lused = nr;
    }
  if (cp)
    *cp = lbuf[lind++];
  return 1;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\zread.c:156
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\zread.c:178
parsing error 
{
  ssize_t nr;

  if (lind == lused || lused == 0)
    {
      if (len > sizeof (lbuf))
	len = sizeof (lbuf);
      nr = zread (fd, lbuf, len);
      lind = 0;
      if (nr <= 0)
	{
	  lused = 0;
	  return nr;
	}
      lused = nr;
    }
  if (cp)
    *cp = lbuf[lind++];
  return 1;
}
warning: parse error {
  ssize_t nr;

  if (lind == lused || lused == 0)
    {
      if (len > sizeof (lbuf))
	len = sizeof (lbuf);
      nr = zread (fd, lbuf, len);
      lind = 0;
      if (nr <= 0)
	{
	  lused = 0;
	  return nr;
	}
      lused = nr;
    }
  if (cp)
    *cp = lbuf[lind++];
  return 1;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\zread.c:182
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\zread.c:212
parsing error 
{
  off_t off, r;

  off = lused - lind;
  r = 0;
  if (off > 0)
    r = lseek (fd, -off, SEEK_CUR);

  if (r != -1)
    lused = lind = 0;
}
warning: parse error {
  off_t off, r;

  off = lused - lind;
  r = 0;
  if (off > 0)
    r = lseek (fd, -off, SEEK_CUR);

  if (r != -1)
    lused = lind = 0;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\zread.c:214
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\zwrite.c...
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\zwrite.c:39
parsing error 
{
  int n, i, nt;

  for (n = nb, nt = 0;;)
    {
      i = write (fd, buf, n);
      if (i > 0)
	{
	  n -= i;
	  if (n <= 0)
	    return nb;
	  buf += i;
	}
      else if (i == 0)
	{
	  if (++nt > 3)
	    return (nb - n);
	}
      else if (errno != EINTR)
	return -1;
    }
}
warning: parse error {
  int n, i, nt;

  for (n = nb, nt = 0;;)
    {
      i = write (fd, buf, n);
      if (i > 0)
	{
	  n -= i;
	  if (n <= 0)
	    return nb;
	  buf += i;
	}
      else if (i == 0)
	{
	  if (++nt > 3)
	    return (nb - n);
	}
      else if (errno != EINTR)
	return -1;
    }
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\sh\zwrite.c:43
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\termcap\termcap.c...
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\termcap\ltcap.h...
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\termcap\termcap.c:118
parsing error 
{
  register char *tem = malloc (size);

  if (!tem)
    memory_out ();
  return tem;
}
warning: parse error {
  register char *tem = malloc (size);

  if (!tem)
    memory_out ();
  return tem;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\termcap\termcap.c:120
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\termcap\termcap.c:129
parsing error 
{
  register char *tem = realloc (ptr, size);

  if (!tem)
    memory_out ();
  return tem;
}
warning: parse error {
  register char *tem = realloc (ptr, size);

  if (!tem)
    memory_out ();
  return tem;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\termcap\termcap.c:132
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\termcap\termcap.c:154
parsing error 
{
  for (; *bp; bp++)
    if (bp[0] == ':'
	&& bp[1] == cap[0]
	&& bp[2] == cap[1])
      return &bp[4];
  return NULL;
}
warning: parse error {
  for (; *bp; bp++)
    if (bp[0] == ':'
	&& bp[1] == cap[0]
	&& bp[2] == cap[1])
      return &bp[4];
  return NULL;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\termcap\termcap.c:156
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\termcap\termcap.c:167
parsing error 
{
  register char *ptr = find_capability (term_entry, cap);
  if (!ptr || ptr[-1] != '#')
    return -1;
  return atoi (ptr);
}
warning: parse error {
  register char *ptr = find_capability (term_entry, cap);
  if (!ptr || ptr[-1] != '#')
    return -1;
  return atoi (ptr);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\termcap\termcap.c:169
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\termcap\termcap.c:178
parsing error 
{
  register char *ptr = find_capability (term_entry, cap);
  return ptr && ptr[-1] == ':';
}
warning: parse error {
  register char *ptr = find_capability (term_entry, cap);
  return ptr && ptr[-1] == ':';
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\termcap\termcap.c:180
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\termcap\termcap.c:192
parsing error 
{
  register char *ptr = find_capability (term_entry, cap);
  if (!ptr || (ptr[-1] != '=' && ptr[-1] != '~'))
    return NULL;
  return tgetst1 (ptr, area);
}
warning: parse error {
  register char *ptr = find_capability (term_entry, cap);
  if (!ptr || (ptr[-1] != '=' && ptr[-1] != '~'))
    return NULL;
  return tgetst1 (ptr, area);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\termcap\termcap.c:195
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\termcap\termcap.c:220
parsing error 
{
  register char *p, *r;
  register int c;
  register int size;
  char *ret;
  register int c1;

  if (!ptr)
    return NULL;

  /* `ret' gets address of where to store the string.  */
  if (!area)
    {
      /* Compute size of block needed (may overestimate).  */
      p = ptr;
      while ((c = *p++) && c != ':' && c != '\n')
	;
      ret = (char *) xmalloc (p - ptr + 1);
    }
  else
    ret = *area;

  /* Copy the string value, stopping at null or colon.
     Also process ^ and \ abbreviations.  */
  p = ptr;
  r = ret;
  while ((c = *p++) && c != ':' && c != '\n')
    {
      if (c == '^')
	{
	  c = *p++;
	  if (c == '?')
	    c = 0177;
	  else
	    c &= 037;
	}
      else if (c == '\\')
	{
	  c = *p++;
	  if (c >= '0' && c <= '7')
	    {
	      c -= '0';
	      size = 0;

	      while (++size < 3 && (c1 = *p) >= '0' && c1 <= '7')
		{
		  c *= 8;
		  c += c1 - '0';
		  p++;
		}
	    }
	  else if (c >= 0100 && c < 0200)
	    {
	      c1 = esctab[(c & ~040) - 0100];
	      if (c1 != ' ')
		c = c1;
	    }
	}
      *r++ = c;
    }
  *r = '\0';
  /* Update *AREA.  */
  if (area)
    *area = r + 1;
  return ret;
}
warning: parse error {
  register char *p, *r;
  register int c;
  register int size;
  char *ret;
  register int c1;

  if (!ptr)
    return NULL;

  /* `ret' gets address of where to store the string.  */
  if (!area)
    {
      /* Compute size of block needed (may overestimate).  */
      p = ptr;
      while ((c = *p++) && c != ':' && c != '\n')
	;
      ret = (char *) xmalloc (p - ptr + 1);
    }
  else
    ret = *area;

  /* Copy the string value, stopping at null or colon.
     Also process ^ and \ abbreviations.  */
  p = ptr;
  r = ret;
  while ((c = *p++) && c != ':' && c != '\n')
    {
      if (c == '^')
	{
	  c = *p++;
	  if (c == '?')
	    c = 0177;
	  else
	    c &= 037;
	}
      else if (c == '\\')
	{
	  c = *p++;
	  if (c >= '0' && c <= '7')
	    {
	      c -= '0';
	      size = 0;

	      while (++size < 3 && (c1 = *p) >= '0' && c1 <= '7')
		{
		  c *= 8;
		  c += c1 - '0';
		  p++;
		}
	    }
	  else if (c >= 0100 && c < 0200)
	    {
	      c1 = esctab[(c & ~040) - 0100];
	      if (c1 != ' ')
		c = c1;
	    }
	}
      *r++ = c;
    }
  *r = '\0';
  /* Update *AREA.  */
  if (area)
    *area = r + 1;
  return ret;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\termcap\termcap.c:223
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\termcap\termcap.c:313
parsing error 
{
  register int padcount = 0;
  register int speed;

#ifdef emacs
  extern baud_rate;
  speed = baud_rate;
  /* For quite high speeds, convert to the smaller
     units to avoid overflow.  */
  if (speed > 10000)
    speed = - speed / 100;
#else
  if (ospeed == 0)
    speed = tputs_baud_rate;
  else if (ospeed > 0 && ospeed < (sizeof speeds / sizeof speeds[0]))
    speed = speeds[ospeed];
  else
    speed = 0;
#endif

  if (!str)
    return -1;

  while (*str >= '0' && *str <= '9')
    {
      padcount += *str++ - '0';
      padcount *= 10;
    }
  if (*str == '.')
    {
      str++;
      padcount += *str++ - '0';
    }
  if (*str == '*')
    {
      str++;
      padcount *= nlines;
    }
  while (*str)
    (*outfun) (*str++);

  /* PADCOUNT is now in units of tenths of msec.
     SPEED is measured in characters per 10 seconds
     or in characters per .1 seconds (if negative).
     We use the smaller units for larger speeds to avoid overflow.  */
  padcount *= speed;
  padcount += 500;
  padcount /= 1000;
  if (speed < 0)
    padcount = -padcount;
  else
    {
      padcount += 50;
      padcount /= 100;
    }

  while (padcount-- > 0)
    (*outfun) (PC);

  return 0;
}
warning: parse error {
  register int padcount = 0;
  register int speed;

#ifdef emacs
  extern baud_rate;
  speed = baud_rate;
  /* For quite high speeds, convert to the smaller
     units to avoid overflow.  */
  if (speed > 10000)
    speed = - speed / 100;
#else
  if (ospeed == 0)
    speed = tputs_baud_rate;
  else if (ospeed > 0 && ospeed < (sizeof speeds / sizeof speeds[0]))
    speed = speeds[ospeed];
  else
    speed = 0;
#endif

  if (!str)
    return -1;

  while (*str >= '0' && *str <= '9')
    {
      padcount += *str++ - '0';
      padcount *= 10;
    }
  if (*str == '.')
    {
      str++;
      padcount += *str++ - '0';
    }
  if (*str == '*')
    {
      str++;
      padcount *= nlines;
    }
  while (*str)
    (*outfun) (*str++);

  /* PADCOUNT is now in units of tenths of msec.
     SPEED is measured in characters per 10 seconds
     or in characters per .1 seconds (if negative).
     We use the smaller units for larger speeds to avoid overflow.  */
  padcount *= speed;
  padcount += 500;
  padcount /= 1000;
  if (speed < 0)
    padcount = -padcount;
  else
    {
      padcount += 50;
      padcount /= 100;
    }

  while (padcount-- > 0)
    (*outfun) (PC);

  return 0;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\termcap\termcap.c:317
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\termcap\termcap.c:451
parsing error 
{
  register char *termcap_name;
  register int fd;
  struct buffer buf;
  register char *bp1;
  char *bp2;
  char *term;
  int malloc_size = 0;
  register int c;
  char *tcenv;			/* TERMCAP value, if it contains :tc=.  */
  char *indirect = NULL;	/* Terminal type in :tc= in TERMCAP value.  */
  int filep;

#ifdef INTERNAL_TERMINAL
  /* For the internal terminal we don't want to read any termcap file,
     so fake it.  */
  if (!strcmp (name, "internal"))
    {
      term = INTERNAL_TERMINAL;
      if (!bp)
	{
	  malloc_size = 1 + strlen (term);
	  bp = (char *) xmalloc (malloc_size);
	}
      strcpy (bp, term);
      goto ret;
    }
#endif /* INTERNAL_TERMINAL */

  /* For compatibility with programs like `less' that want to
     put data in the termcap buffer themselves as a fallback.  */
  if (bp)
    term_entry = bp;

  termcap_name = getenv ("TERMCAP");
  if (termcap_name && *termcap_name == '\0')
    termcap_name = NULL;
#if 0
#if defined (MSDOS) && !defined (TEST)
  if (termcap_name && (*termcap_name == '\\'
		       || *termcap_name == '/'
		       || termcap_name[1] == ':'))
    dostounix_filename(termcap_name);
#endif
#endif

  filep = termcap_name && valid_filename_p (termcap_name);

  /* If termcap_name is non-null and starts with / (in the un*x case, that is),
     it is a file name to use instead of /etc/termcap.
     If it is non-null and does not start with /,
     it is the entry itself, but only if
     the name the caller requested matches the TERM variable.  */

  if (termcap_name && !filep && !strcmp (name, getenv ("TERM")))
    {
      indirect = tgetst1 (find_capability (termcap_name, "tc"), (char **) 0);
      if (!indirect)
	{
	  if (!bp)
	    bp = termcap_name;
	  else
	    strcpy (bp, termcap_name);
	  goto ret;
	}
      else
	{			/* It has tc=.  Need to read /etc/termcap.  */
	  tcenv = termcap_name;
 	  termcap_name = NULL;
	}
    }

  if (!termcap_name || !filep)
    termcap_name = TERMCAP_FILE;

  /* Here we know we must search a file and termcap_name has its name.  */

#ifdef MSDOS
  fd = open (termcap_name, O_RDONLY|O_TEXT, 0);
#else
  fd = open (termcap_name, O_RDONLY, 0);
#endif
  if (fd < 0)
    return -1;

  buf.size = BUFSIZE;
  /* Add 1 to size to ensure room for terminating null.  */
  buf.beg = (char *) xmalloc (buf.size + 1);
  term = indirect ? indirect : name;

  if (!bp)
    {
      malloc_size = indirect ? strlen (tcenv) + 1 : buf.size;
      bp = (char *) xmalloc (malloc_size);
    }
  bp1 = bp;

  if (indirect)
    /* Copy the data from the environment variable.  */
    {
      strcpy (bp, tcenv);
      bp1 += strlen (tcenv);
    }

  while (term)
    {
      /* Scan the file, reading it via buf, till find start of main entry.  */
      if (scan_file (term, fd, &buf) == 0)
	{
	  close (fd);
	  free (buf.beg);
	  if (malloc_size)
	    free (bp);
	  return 0;
	}

      /* Free old `term' if appropriate.  */
      if (term != name)
	free (term);

      /* If BP is malloc'd by us, make sure it is big enough.  */
      if (malloc_size)
	{
	  malloc_size = bp1 - bp + buf.size;
	  termcap_name = (char *) xrealloc (bp, malloc_size);
	  bp1 += termcap_name - bp;
	  bp = termcap_name;
	}

      bp2 = bp1;

      /* Copy the line of the entry from buf into bp.  */
      termcap_name = buf.ptr;
      while ((*bp1++ = c = *termcap_name++) && c != '\n')
	/* Drop out any \ newline sequence.  */
	if (c == '\\' && *termcap_name == '\n')
	  {
	    bp1--;
	    termcap_name++;
	  }
      *bp1 = '\0';

      /* Does this entry refer to another terminal type's entry?
	 If something is found, copy it into heap and null-terminate it.  */
      term = tgetst1 (find_capability (bp2, "tc"), (char **) 0);
    }

  close (fd);
  free (buf.beg);

  if (malloc_size)
    bp = (char *) xrealloc (bp, bp1 - bp + 1);

 ret:
  term_entry = bp;
  return 1;
}
warning: parse error {
  register char *termcap_name;
  register int fd;
  struct buffer buf;
  register char *bp1;
  char *bp2;
  char *term;
  int malloc_size = 0;
  register int c;
  char *tcenv;			/* TERMCAP value, if it contains :tc=.  */
  char *indirect = NULL;	/* Terminal type in :tc= in TERMCAP value.  */
  int filep;

#ifdef INTERNAL_TERMINAL
  /* For the internal terminal we don't want to read any termcap file,
     so fake it.  */
  if (!strcmp (name, "internal"))
    {
      term = INTERNAL_TERMINAL;
      if (!bp)
	{
	  malloc_size = 1 + strlen (term);
	  bp = (char *) xmalloc (malloc_size);
	}
      strcpy (bp, term);
      goto ret;
    }
#endif /* INTERNAL_TERMINAL */

  /* For compatibility with programs like `less' that want to
     put data in the termcap buffer themselves as a fallback.  */
  if (bp)
    term_entry = bp;

  termcap_name = getenv ("TERMCAP");
  if (termcap_name && *termcap_name == '\0')
    termcap_name = NULL;
#if 0
#if defined (MSDOS) && !defined (TEST)
  if (termcap_name && (*termcap_name == '\\'
		       || *termcap_name == '/'
		       || termcap_name[1] == ':'))
    dostounix_filename(termcap_name);
#endif
#endif

  filep = termcap_name && valid_filename_p (termcap_name);

  /* If termcap_name is non-null and starts with / (in the un*x case, that is),
     it is a file name to use instead of /etc/termcap.
     If it is non-null and does not start with /,
     it is the entry itself, but only if
     the name the caller requested matches the TERM variable.  */

  if (termcap_name && !filep && !strcmp (name, getenv ("TERM")))
    {
      indirect = tgetst1 (find_capability (termcap_name, "tc"), (char **) 0);
      if (!indirect)
	{
	  if (!bp)
	    bp = termcap_name;
	  else
	    strcpy (bp, termcap_name);
	  goto ret;
	}
      else
	{			/* It has tc=.  Need to read /etc/termcap.  */
	  tcenv = termcap_name;
 	  termcap_name = NULL;
	}
    }

  if (!termcap_name || !filep)
    termcap_name = TERMCAP_FILE;

  /* Here we know we must search a file and termcap_name has its name.  */

#ifdef MSDOS
  fd = open (termcap_name, O_RDONLY|O_TEXT, 0);
#else
  fd = open (termcap_name, O_RDONLY, 0);
#endif
  if (fd < 0)
    return -1;

  buf.size = BUFSIZE;
  /* Add 1 to size to ensure room for terminating null.  */
  buf.beg = (char *) xmalloc (buf.size + 1);
  term = indirect ? indirect : name;

  if (!bp)
    {
      malloc_size = indirect ? strlen (tcenv) + 1 : buf.size;
      bp = (char *) xmalloc (malloc_size);
    }
  bp1 = bp;

  if (indirect)
    /* Copy the data from the environment variable.  */
    {
      strcpy (bp, tcenv);
      bp1 += strlen (tcenv);
    }

  while (term)
    {
      /* Scan the file, reading it via buf, till find start of main entry.  */
      if (scan_file (term, fd, &buf) == 0)
	{
	  close (fd);
	  free (buf.beg);
	  if (malloc_size)
	    free (bp);
	  return 0;
	}

      /* Free old `term' if appropriate.  */
      if (term != name)
	free (term);

      /* If BP is malloc'd by us, make sure it is big enough.  */
      if (malloc_size)
	{
	  malloc_size = bp1 - bp + buf.size;
	  termcap_name = (char *) xrealloc (bp, malloc_size);
	  bp1 += termcap_name - bp;
	  bp = termcap_name;
	}

      bp2 = bp1;

      /* Copy the line of the entry from buf into bp.  */
      termcap_name = buf.ptr;
      while ((*bp1++ = c = *termcap_name++) && c != '\n')
	/* Drop out any \ newline sequence.  */
	if (c == '\\' && *termcap_name == '\n')
	  {
	    bp1--;
	    termcap_name++;
	  }
      *bp1 = '\0';

      /* Does this entry refer to another terminal type's entry?
	 If something is found, copy it into heap and null-terminate it.  */
      term = tgetst1 (find_capability (bp2, "tc"), (char **) 0);
    }

  close (fd);
  free (buf.beg);

  if (malloc_size)
    bp = (char *) xrealloc (bp, bp1 - bp + 1);

 ret:
  term_entry = bp;
  return 1;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\termcap\termcap.c:453
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\termcap\termcap.c:618
parsing error 
{
  register char *end;

  bufp->ptr = bufp->beg;
  bufp->full = 0;
  bufp->ateof = 0;
  *bufp->ptr = '\0';

  lseek (fd, 0L, 0);

  while (!bufp->ateof)
    {
      /* Read a line into the buffer.  */
      end = NULL;
      do
	{
	  /* if it is continued, append another line to it,
	     until a non-continued line ends.  */
	  end = gobble_line (fd, bufp, end);
	}
      while (!bufp->ateof && end[-2] == '\\');

      if (*bufp->ptr != '#'
	  && name_match (bufp->ptr, str))
	return 1;

      /* Discard the line just processed.  */
      bufp->ptr = end;
    }
  return 0;
}
warning: parse error {
  register char *end;

  bufp->ptr = bufp->beg;
  bufp->full = 0;
  bufp->ateof = 0;
  *bufp->ptr = '\0';

  lseek (fd, 0L, 0);

  while (!bufp->ateof)
    {
      /* Read a line into the buffer.  */
      end = NULL;
      do
	{
	  /* if it is continued, append another line to it,
	     until a non-continued line ends.  */
	  end = gobble_line (fd, bufp, end);
	}
      while (!bufp->ateof && end[-2] == '\\');

      if (*bufp->ptr != '#'
	  && name_match (bufp->ptr, str))
	return 1;

      /* Discard the line just processed.  */
      bufp->ptr = end;
    }
  return 0;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\termcap\termcap.c:622
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\termcap\termcap.c:658
parsing error 
{
  register char *tem;

  if (!compare_contin (line, name))
    return 1;
  /* This line starts an entry.  Is it the right one?  */
  for (tem = line; *tem && *tem != '\n' && *tem != ':'; tem++)
    if (*tem == '|' && !compare_contin (tem + 1, name))
      return 1;

  return 0;
}
warning: parse error {
  register char *tem;

  if (!compare_contin (line, name))
    return 1;
  /* This line starts an entry.  Is it the right one?  */
  for (tem = line; *tem && *tem != '\n' && *tem != ':'; tem++)
    if (*tem == '|' && !compare_contin (tem + 1, name))
      return 1;

  return 0;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\termcap\termcap.c:660
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\termcap\termcap.c:674
parsing error 
{
  register int c1, c2;
  while (1)
    {
      c1 = *str1++;
      c2 = *str2++;
      while (c1 == '\\' && *str1 == '\n')
	{
	  str1++;
	  while ((c1 = *str1++) == ' ' || c1 == '\t');
	}
      if (c2 == '\0')
	{
	  /* End of type being looked up.  */
	  if (c1 == '|' || c1 == ':')
	    /* If end of name in data base, we win.  */
	    return 0;
	  else
	    return 1;
        }
      else if (c1 != c2)
	return 1;
    }
}
warning: parse error {
  register int c1, c2;
  while (1)
    {
      c1 = *str1++;
      c2 = *str2++;
      while (c1 == '\\' && *str1 == '\n')
	{
	  str1++;
	  while ((c1 = *str1++) == ' ' || c1 == '\t');
	}
      if (c2 == '\0')
	{
	  /* End of type being looked up.  */
	  if (c1 == '|' || c1 == ':')
	    /* If end of name in data base, we win.  */
	    return 0;
	  else
	    return 1;
        }
      else if (c1 != c2)
	return 1;
    }
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\termcap\termcap.c:676
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\termcap\termcap.c:715
parsing error 
{
  register char *end;
  register int nread;
  register char *buf = bufp->beg;
  register char *tem;

  if (!append_end)
    append_end = bufp->ptr;

  while (1)
    {
      end = append_end;
      while (*end && *end != '\n') end++;
      if (*end)
        break;
      if (bufp->ateof)
	return buf + bufp->full;
      if (bufp->ptr == buf)
	{
	  if (bufp->full == bufp->size)
	    {
	      bufp->size *= 2;
	      /* Add 1 to size to ensure room for terminating null.  */
	      tem = (char *) xrealloc (buf, bufp->size + 1);
	      bufp->ptr = (bufp->ptr - buf) + tem;
	      append_end = (append_end - buf) + tem;
	      bufp->beg = buf = tem;
	    }
	}
      else
	{
	  append_end -= bufp->ptr - buf;
	  bcopy (bufp->ptr, buf, bufp->full -= bufp->ptr - buf);
	  bufp->ptr = buf;
	}
      if (!(nread = read (fd, buf + bufp->full, bufp->size - bufp->full)))
	bufp->ateof = 1;
      bufp->full += nread;
      buf[bufp->full] = '\0';
    }
  return end + 1;
}
warning: parse error {
  register char *end;
  register int nread;
  register char *buf = bufp->beg;
  register char *tem;

  if (!append_end)
    append_end = bufp->ptr;

  while (1)
    {
      end = append_end;
      while (*end && *end != '\n') end++;
      if (*end)
        break;
      if (bufp->ateof)
	return buf + bufp->full;
      if (bufp->ptr == buf)
	{
	  if (bufp->full == bufp->size)
	    {
	      bufp->size *= 2;
	      /* Add 1 to size to ensure room for terminating null.  */
	      tem = (char *) xrealloc (buf, bufp->size + 1);
	      bufp->ptr = (bufp->ptr - buf) + tem;
	      append_end = (append_end - buf) + tem;
	      bufp->beg = buf = tem;
	    }
	}
      else
	{
	  append_end -= bufp->ptr - buf;
	  bcopy (bufp->ptr, buf, bufp->full -= bufp->ptr - buf);
	  bufp->ptr = buf;
	}
      if (!(nread = read (fd, buf + bufp->full, bufp->size - bufp->full)))
	bufp->ateof = 1;
      bufp->full += nread;
      buf[bufp->full] = '\0';
    }
  return end + 1;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\termcap\termcap.c:719
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\termcap\tparam.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\termcap\ltcap.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\termcap\tparam.c:72
parsing error 
{
  register char *tem = malloc (size);

  if (!tem)
    memory_out ();
  return tem;
}
warning: parse error {
  register char *tem = malloc (size);

  if (!tem)
    memory_out ();
  return tem;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\termcap\tparam.c:74
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\termcap\tparam.c:83
parsing error 
{
  register char *tem = realloc (ptr, size);

  if (!tem)
    memory_out ();
  return tem;
}
warning: parse error {
  register char *tem = realloc (ptr, size);

  if (!tem)
    memory_out ();
  return tem;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\termcap\tparam.c:86
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\termcap\tparam.c:111
parsing error 
{
  int arg[4];

  arg[0] = arg0;
  arg[1] = arg1;
  arg[2] = arg2;
  arg[3] = arg3;
  return tparam1 (string, outstring, len, NULL, NULL, arg);
}
warning: parse error {
  int arg[4];

  arg[0] = arg0;
  arg[1] = arg1;
  arg[2] = arg2;
  arg[3] = arg3;
  return tparam1 (string, outstring, len, NULL, NULL, arg);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\termcap\tparam.c:116
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\termcap\tparam.c:133
parsing error 
{
  int args[2];
  if (!cm)
    return NULL;
  args[0] = vpos;
  args[1] = hpos;
  return tparam1 (cm, tgoto_buf, 50, UP, BC, args);
}
warning: parse error {
  int args[2];
  if (!cm)
    return NULL;
  args[0] = vpos;
  args[1] = hpos;
  return tparam1 (cm, tgoto_buf, 50, UP, BC, args);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\termcap\tparam.c:136
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\termcap\tparam.c:146
parsing error 
{
  register int c;
  register char *p = string;
  register char *op = outstring;
  char *outend;
  int outlen = 0;

  register int tem;
  int *old_argp = argp;
  int doleft = 0;
  int doup = 0;

  outend = outstring + len;

  while (1)
    {
      /* If the buffer might be too short, make it bigger.  */
      if (op + 5 >= outend)
	{
	  register char *new;
	  if (outlen == 0)
	    {
	      outlen = len + 40;
	      new = (char *) xmalloc (outlen);
	      outend += 40;
	      bcopy (outstring, new, op - outstring);
	    }
	  else
	    {
	      outend += outlen;
	      outlen *= 2;
	      new = (char *) xrealloc (outstring, outlen);
	    }
	  op += new - outstring;
	  outend += new - outstring;
	  outstring = new;
	}
      c = *p++;
      if (!c)
	break;
      if (c == '%')
	{
	  c = *p++;
	  tem = *argp;
	  switch (c)
	    {
	    case 'd':		/* %d means output in decimal.  */
	      if (tem < 10)
		goto onedigit;
	      if (tem < 100)
		goto twodigit;
	    case '3':		/* %3 means output in decimal, 3 digits.  */
	      if (tem > 999)
		{
		  *op++ = tem / 1000 + '0';
		  tem %= 1000;
		}
	      *op++ = tem / 100 + '0';
	    case '2':		/* %2 means output in decimal, 2 digits.  */
	    twodigit:
	      tem %= 100;
	      *op++ = tem / 10 + '0';
	    onedigit:
	      *op++ = tem % 10 + '0';
	      argp++;
	      break;

	    case 'C':
	      /* For c-100: print quotient of value by 96, if nonzero,
		 then do like %+.  */
	      if (tem >= 96)
		{
		  *op++ = tem / 96;
		  tem %= 96;
		}
	    case '+':		/* %+x means add character code of char x.  */
	      tem += *p++;
	    case '.':		/* %. means output as character.  */
	      if (left)
		{
		  /* If want to forbid output of 0 and \n and \t,
		     and this is one of them, increment it.  */
		  while (tem == 0 || tem == '\n' || tem == '\t')
		    {
		      tem++;
		      if (argp == old_argp)
			doup++, outend -= strlen (up);
		      else
			doleft++, outend -= strlen (left);
		    }
		}
	      *op++ = tem ? tem : 0200;
	    case 'f':		/* %f means discard next arg.  */
	      argp++;
	      break;

	    case 'b':		/* %b means back up one arg (and re-use it).  */
	      argp--;
	      break;

	    case 'r':		/* %r means interchange following two args.  */
	      argp[0] = argp[1];
	      argp[1] = tem;
	      old_argp++;
	      break;

	    case '>':		/* %>xy means if arg is > char code of x, */
	      if (argp[0] > *p++) /* then add char code of y to the arg, */
		argp[0] += *p;	/* and in any case don't output.  */
	      p++;		/* Leave the arg to be output later.  */
	      break;

	    case 'a':		/* %a means arithmetic.  */
	      /* Next character says what operation.
		 Add or subtract either a constant or some other arg.  */
	      /* First following character is + to add or - to subtract
		 or = to assign.  */
	      /* Next following char is 'p' and an arg spec
		 (0100 plus position of that arg relative to this one)
		 or 'c' and a constant stored in a character.  */
	      tem = p[2] & 0177;
	      if (p[1] == 'p')
		tem = argp[tem - 0100];
	      if (p[0] == '-')
		argp[0] -= tem;
	      else if (p[0] == '+')
		argp[0] += tem;
	      else if (p[0] == '*')
		argp[0] *= tem;
	      else if (p[0] == '/')
		argp[0] /= tem;
	      else
		argp[0] = tem;

	      p += 3;
	      break;

	    case 'i':		/* %i means add one to arg, */
	      argp[0] ++;	/* and leave it to be output later.  */
	      argp[1] ++;	/* Increment the following arg, too!  */
	      break;

	    case '%':		/* %% means output %; no arg.  */
	      goto ordinary;

	    case 'n':		/* %n means xor each of next two args with 140.  */
	      argp[0] ^= 0140;
	      argp[1] ^= 0140;
	      break;

	    case 'm':		/* %m means xor each of next two args with 177.  */
	      argp[0] ^= 0177;
	      argp[1] ^= 0177;
	      break;

	    case 'B':		/* %B means express arg as BCD char code.  */
	      argp[0] += 6 * (tem / 10);
	      break;

	    case 'D':		/* %D means weird Delta Data transformation.  */
	      argp[0] -= 2 * (tem % 16);
	      break;
	    }
	}
      else
	/* Ordinary character in the argument string.  */
      ordinary:
	*op++ = c;
    }
  *op = 0;
  while (doup-- > 0)
    strcat (op, up);
  while (doleft-- > 0)
    strcat (op, left);
  return outstring;
}
warning: parse error {
  register int c;
  register char *p = string;
  register char *op = outstring;
  char *outend;
  int outlen = 0;

  register int tem;
  int *old_argp = argp;
  int doleft = 0;
  int doup = 0;

  outend = outstring + len;

  while (1)
    {
      /* If the buffer might be too short, make it bigger.  */
      if (op + 5 >= outend)
	{
	  register char *new;
	  if (outlen == 0)
	    {
	      outlen = len + 40;
	      new = (char *) xmalloc (outlen);
	      outend += 40;
	      bcopy (outstring, new, op - outstring);
	    }
	  else
	    {
	      outend += outlen;
	      outlen *= 2;
	      new = (char *) xrealloc (outstring, outlen);
	    }
	  op += new - outstring;
	  outend += new - outstring;
	  outstring = new;
	}
      c = *p++;
      if (!c)
	break;
      if (c == '%')
	{
	  c = *p++;
	  tem = *argp;
	  switch (c)
	    {
	    case 'd':		/* %d means output in decimal.  */
	      if (tem < 10)
		goto onedigit;
	      if (tem < 100)
		goto twodigit;
	    case '3':		/* %3 means output in decimal, 3 digits.  */
	      if (tem > 999)
		{
		  *op++ = tem / 1000 + '0';
		  tem %= 1000;
		}
	      *op++ = tem / 100 + '0';
	    case '2':		/* %2 means output in decimal, 2 digits.  */
	    twodigit:
	      tem %= 100;
	      *op++ = tem / 10 + '0';
	    onedigit:
	      *op++ = tem % 10 + '0';
	      argp++;
	      break;

	    case 'C':
	      /* For c-100: print quotient of value by 96, if nonzero,
		 then do like %+.  */
	      if (tem >= 96)
		{
		  *op++ = tem / 96;
		  tem %= 96;
		}
	    case '+':		/* %+x means add character code of char x.  */
	      tem += *p++;
	    case '.':		/* %. means output as character.  */
	      if (left)
		{
		  /* If want to forbid output of 0 and \n and \t,
		     and this is one of them, increment it.  */
		  while (tem == 0 || tem == '\n' || tem == '\t')
		    {
		      tem++;
		      if (argp == old_argp)
			doup++, outend -= strlen (up);
		      else
			doleft++, outend -= strlen (left);
		    }
		}
	      *op++ = tem ? tem : 0200;
	    case 'f':		/* %f means discard next arg.  */
	      argp++;
	      break;

	    case 'b':		/* %b means back up one arg (and re-use it).  */
	      argp--;
	      break;

	    case 'r':		/* %r means interchange following two args.  */
	      argp[0] = argp[1];
	      argp[1] = tem;
	      old_argp++;
	      break;

	    case '>':		/* %>xy means if arg is > char code of x, */
	      if (argp[0] > *p++) /* then add char code of y to the arg, */
		argp[0] += *p;	/* and in any case don't output.  */
	      p++;		/* Leave the arg to be output later.  */
	      break;

	    case 'a':		/* %a means arithmetic.  */
	      /* Next character says what operation.
		 Add or subtract either a constant or some other arg.  */
	      /* First following character is + to add or - to subtract
		 or = to assign.  */
	      /* Next following char is 'p' and an arg spec
		 (0100 plus position of that arg relative to this one)
		 or 'c' and a constant stored in a character.  */
	      tem = p[2] & 0177;
	      if (p[1] == 'p')
		tem = argp[tem - 0100];
	      if (p[0] == '-')
		argp[0] -= tem;
	      else if (p[0] == '+')
		argp[0] += tem;
	      else if (p[0] == '*')
		argp[0] *= tem;
	      else if (p[0] == '/')
		argp[0] /= tem;
	      else
		argp[0] = tem;

	      p += 3;
	      break;

	    case 'i':		/* %i means add one to arg, */
	      argp[0] ++;	/* and leave it to be output later.  */
	      argp[1] ++;	/* Increment the following arg, too!  */
	      break;

	    case '%':		/* %% means output %; no arg.  */
	      goto ordinary;

	    case 'n':		/* %n means xor each of next two args with 140.  */
	      argp[0] ^= 0140;
	      argp[1] ^= 0140;
	      break;

	    case 'm':		/* %m means xor each of next two args with 177.  */
	      argp[0] ^= 0177;
	      argp[1] ^= 0177;
	      break;

	    case 'B':		/* %B means express arg as BCD char code.  */
	      argp[0] += 6 * (tem / 10);
	      break;

	    case 'D':		/* %D means weird Delta Data transformation.  */
	      argp[0] -= 2 * (tem % 16);
	      break;
	    }
	}
      else
	/* Ordinary character in the argument string.  */
      ordinary:
	*op++ = c;
    }
  *op = 0;
  while (doup-- > 0)
    strcat (op, up);
  while (doleft-- > 0)
    strcat (op, left);
  return outstring;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\termcap\tparam.c:152
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\termcap\version.c...
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\tilde\shell.c...
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\tilde\tilde.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\tilde\tilde.h...skip
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\list.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\shell.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\list.c:63
parsing error 
{
  register GENERIC_LIST *next, *prev;

  for (prev = (GENERIC_LIST *)NULL; list; )
    {
      next = list->next;
      list->next = prev;
      prev = list;
      list = next;
    }
  return (prev);
}
warning: parse error {
  register GENERIC_LIST *next, *prev;

  for (prev = (GENERIC_LIST *)NULL; list; )
    {
      next = list->next;
      list->next = prev;
      prev = list;
      list = next;
    }
  return (prev);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\list.c:65
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\list.c:80
parsing error 
{
  register int i;

  for (i = 0; list; list = list->next, i++);
  return (i);
}
warning: parse error {
  register int i;

  for (i = 0; list; list = list->next, i++);
  return (i);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\list.c:82
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\list.c:91
parsing error 
{
  register GENERIC_LIST *t_head;

  if (head == 0)
    return (tail);

  for (t_head = head; t_head->next; t_head = t_head->next)
    ;
  t_head->next = tail;
  return (head);
}
warning: parse error {
  register GENERIC_LIST *t_head;

  if (head == 0)
    return (tail);

  for (t_head = head; t_head->next; t_head = t_head->next)
    ;
  t_head->next = tail;
  return (head);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\list.c:93
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\locale.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashtypes.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashintl.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashansi.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\chartypes.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\shell.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\input.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\locale.c:175
parsing error 
{
  int r;
  char *x;

  x = "";
  errno = 0;
  if (var[0] == 'T' && var[10] == 0)		/* TEXTDOMAIN */
    {
      FREE (default_domain);
      default_domain = value ? savestring (value) : (char *)NULL;
      if (default_dir && *default_dir)
	bindtextdomain (default_domain, default_dir);
      return (1);
    }
  else if (var[0] == 'T')			/* TEXTDOMAINDIR */
    {
      FREE (default_dir);
      default_dir = value ? savestring (value) : (char *)NULL;
      if (default_domain && *default_domain)
	bindtextdomain (default_domain, default_dir);
      return (1);
    }

  /* var[0] == 'L' && var[1] == 'C' && var[2] == '_' */

  else if (var[3] == 'A')			/* LC_ALL */
    {
      FREE (lc_all);
      if (value)
	lc_all = savestring (value);
      else
	{
	  lc_all = (char *)xmalloc (1);
	  lc_all[0] = '\0';
	}
#if defined (HAVE_SETLOCALE)
      r = *lc_all ? ((x = setlocale (LC_ALL, lc_all)) != 0) : reset_locale_vars ();
      if (x == 0)
	{
	  if (errno == 0)
	    internal_warning(_("setlocale: LC_ALL: cannot change locale (%s)"), lc_all);
	  else
	    internal_warning(_("setlocale: LC_ALL: cannot change locale (%s): %s"), lc_all, strerror (errno));
	}
      locale_setblanks ();
      locale_mb_cur_max = MB_CUR_MAX;
      /* if LC_ALL == "", reset_locale_vars has already called this */
      if (*lc_all && x)
	locale_utf8locale = locale_isutf8 (lc_all);
#  if defined (HANDLE_MULTIBYTE)
      locale_shiftstates = mblen ((char *)NULL, 0);
#  else
      local_shiftstates = 0;
#  endif
      u32reset ();
      return r;
#else
      return (1);
#endif
    }

#if defined (HAVE_SETLOCALE)
  else if (var[3] == 'C' && var[4] == 'T')	/* LC_CTYPE */
    {
#  if defined (LC_CTYPE)
      if (lc_all == 0 || *lc_all == '\0')
	{
	  x = setlocale (LC_CTYPE, get_locale_var ("LC_CTYPE"));
	  locale_setblanks ();
	  locale_mb_cur_max = MB_CUR_MAX;
	  /* if setlocale() returns NULL, the locale is not changed */
	  if (x)
	    locale_utf8locale = locale_isutf8 (x);
#if defined (HANDLE_MULTIBYTE)
	  locale_shiftstates = mblen ((char *)NULL, 0);
#else
	  local_shiftstates = 0;
#endif
	  u32reset ();
	}
#  endif
    }
  else if (var[3] == 'C' && var[4] == 'O')	/* LC_COLLATE */
    {
#  if defined (LC_COLLATE)
      if (lc_all == 0 || *lc_all == '\0')
	x = setlocale (LC_COLLATE, get_locale_var ("LC_COLLATE"));
#  endif /* LC_COLLATE */
    }
  else if (var[3] == 'M' && var[4] == 'E')	/* LC_MESSAGES */
    {
#  if defined (LC_MESSAGES)
      if (lc_all == 0 || *lc_all == '\0')
	x = setlocale (LC_MESSAGES, get_locale_var ("LC_MESSAGES"));
#  endif /* LC_MESSAGES */
    }
  else if (var[3] == 'N' && var[4] == 'U')	/* LC_NUMERIC */
    {
#  if defined (LC_NUMERIC)
      if (lc_all == 0 || *lc_all == '\0')
	x = setlocale (LC_NUMERIC, get_locale_var ("LC_NUMERIC"));
#  endif /* LC_NUMERIC */
    }
  else if (var[3] == 'T' && var[4] == 'I')	/* LC_TIME */
    {
#  if defined (LC_TIME)
      if (lc_all == 0 || *lc_all == '\0')
	x = setlocale (LC_TIME, get_locale_var ("LC_TIME"));
#  endif /* LC_TIME */
    }
#endif /* HAVE_SETLOCALE */
  
  if (x == 0)
    {
      if (errno == 0)
	internal_warning(_("setlocale: %s: cannot change locale (%s)"), var, get_locale_var (var));
      else
	internal_warning(_("setlocale: %s: cannot change locale (%s): %s"), var, get_locale_var (var), strerror (errno));
    }

  return (x != 0);
}
warning: parse error {
  int r;
  char *x;

  x = "";
  errno = 0;
  if (var[0] == 'T' && var[10] == 0)		/* TEXTDOMAIN */
    {
      FREE (default_domain);
      default_domain = value ? savestring (value) : (char *)NULL;
      if (default_dir && *default_dir)
	bindtextdomain (default_domain, default_dir);
      return (1);
    }
  else if (var[0] == 'T')			/* TEXTDOMAINDIR */
    {
      FREE (default_dir);
      default_dir = value ? savestring (value) : (char *)NULL;
      if (default_domain && *default_domain)
	bindtextdomain (default_domain, default_dir);
      return (1);
    }

  /* var[0] == 'L' && var[1] == 'C' && var[2] == '_' */

  else if (var[3] == 'A')			/* LC_ALL */
    {
      FREE (lc_all);
      if (value)
	lc_all = savestring (value);
      else
	{
	  lc_all = (char *)xmalloc (1);
	  lc_all[0] = '\0';
	}
#if defined (HAVE_SETLOCALE)
      r = *lc_all ? ((x = setlocale (LC_ALL, lc_all)) != 0) : reset_locale_vars ();
      if (x == 0)
	{
	  if (errno == 0)
	    internal_warning(_("setlocale: LC_ALL: cannot change locale (%s)"), lc_all);
	  else
	    internal_warning(_("setlocale: LC_ALL: cannot change locale (%s): %s"), lc_all, strerror (errno));
	}
      locale_setblanks ();
      locale_mb_cur_max = MB_CUR_MAX;
      /* if LC_ALL == "", reset_locale_vars has already called this */
      if (*lc_all && x)
	locale_utf8locale = locale_isutf8 (lc_all);
#  if defined (HANDLE_MULTIBYTE)
      locale_shiftstates = mblen ((char *)NULL, 0);
#  else
      local_shiftstates = 0;
#  endif
      u32reset ();
      return r;
#else
      return (1);
#endif
    }

#if defined (HAVE_SETLOCALE)
  else if (var[3] == 'C' && var[4] == 'T')	/* LC_CTYPE */
    {
#  if defined (LC_CTYPE)
      if (lc_all == 0 || *lc_all == '\0')
	{
	  x = setlocale (LC_CTYPE, get_locale_var ("LC_CTYPE"));
	  locale_setblanks ();
	  locale_mb_cur_max = MB_CUR_MAX;
	  /* if setlocale() returns NULL, the locale is not changed */
	  if (x)
	    locale_utf8locale = locale_isutf8 (x);
#if defined (HANDLE_MULTIBYTE)
	  locale_shiftstates = mblen ((char *)NULL, 0);
#else
	  local_shiftstates = 0;
#endif
	  u32reset ();
	}
#  endif
    }
  else if (var[3] == 'C' && var[4] == 'O')	/* LC_COLLATE */
    {
#  if defined (LC_COLLATE)
      if (lc_all == 0 || *lc_all == '\0')
	x = setlocale (LC_COLLATE, get_locale_var ("LC_COLLATE"));
#  endif /* LC_COLLATE */
    }
  else if (var[3] == 'M' && var[4] == 'E')	/* LC_MESSAGES */
    {
#  if defined (LC_MESSAGES)
      if (lc_all == 0 || *lc_all == '\0')
	x = setlocale (LC_MESSAGES, get_locale_var ("LC_MESSAGES"));
#  endif /* LC_MESSAGES */
    }
  else if (var[3] == 'N' && var[4] == 'U')	/* LC_NUMERIC */
    {
#  if defined (LC_NUMERIC)
      if (lc_all == 0 || *lc_all == '\0')
	x = setlocale (LC_NUMERIC, get_locale_var ("LC_NUMERIC"));
#  endif /* LC_NUMERIC */
    }
  else if (var[3] == 'T' && var[4] == 'I')	/* LC_TIME */
    {
#  if defined (LC_TIME)
      if (lc_all == 0 || *lc_all == '\0')
	x = setlocale (LC_TIME, get_locale_var ("LC_TIME"));
#  endif /* LC_TIME */
    }
#endif /* HAVE_SETLOCALE */
  
  if (x == 0)
    {
      if (errno == 0)
	internal_warning(_("setlocale: %s: cannot change locale (%s)"), var, get_locale_var (var));
      else
	internal_warning(_("setlocale: %s: cannot change locale (%s): %s"), var, get_locale_var (var), strerror (errno));
    }

  return (x != 0);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\locale.c:177
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\locale.c:304
parsing error 
{
  FREE (lang);
  if (value)
    lang = savestring (value);
  else
    {
      lang = (char *)xmalloc (1);
      lang[0] = '\0';
    }

  return ((lc_all == 0 || *lc_all == 0) ? reset_locale_vars () : 0);
}
warning: parse error {
  FREE (lang);
  if (value)
    lang = savestring (value);
  else
    {
      lang = (char *)xmalloc (1);
      lang[0] = '\0';
    }

  return ((lc_all == 0 || *lc_all == 0) ? reset_locale_vars () : 0);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\locale.c:306
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\locale.c:337
parsing error 
{
  char *locale;

  locale = lc_all;

  if (locale == 0 || *locale == 0)
    locale = get_string_value (var);	/* XXX - no mem leak */
  if (locale == 0 || *locale == 0)
    locale = lang;
  if (locale == 0 || *locale == 0)
#if 0
    locale = default_locale;	/* system-dependent; not really portable.  should it be "C"? */
#else
    locale = "";
#endif
  return (locale);
}
warning: parse error {
  char *locale;

  locale = lc_all;

  if (locale == 0 || *locale == 0)
    locale = get_string_value (var);	/* XXX - no mem leak */
  if (locale == 0 || *locale == 0)
    locale = lang;
  if (locale == 0 || *locale == 0)
#if 0
    locale = default_locale;	/* system-dependent; not really portable.  should it be "C"? */
#else
    locale = "";
#endif
  return (locale);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\locale.c:339
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\locale.c:406
parsing error 
{
  char *locale, *t;
  char *translated;
  int tlen;

  /* Don't try to translate null strings. */
  if (string == 0 || *string == 0)
    {
      if (lenp)
	*lenp = 0;
      return ((char *)NULL);
    }

  locale = get_locale_var ("LC_MESSAGES");

  /* If we don't have setlocale() or the current locale is `C' or `POSIX',
     just return the string.  If we don't have gettext(), there's no use
     doing anything else. */
  if (locale == 0 || locale[0] == '\0' ||
      (locale[0] == 'C' && locale[1] == '\0') || STREQ (locale, "POSIX"))
    {
      t = (char *)xmalloc (len + 1);
      strcpy (t, string);
      if (lenp)
	*lenp = len;
      return (t);
    }

  /* Now try to translate it. */
  if (default_domain && *default_domain)
    translated = dgettext (default_domain, string);
  else
    translated = string;

  if (translated == string)	/* gettext returns its argument if untranslatable */
    {
      t = (char *)xmalloc (len + 1);
      strcpy (t, string);
      if (lenp)
	*lenp = len;
    }
  else
    {
      tlen = strlen (translated);
      t = (char *)xmalloc (tlen + 1);
      strcpy (t, translated);
      if (lenp)
	*lenp = tlen;
    }
  return (t);
}
warning: parse error {
  char *locale, *t;
  char *translated;
  int tlen;

  /* Don't try to translate null strings. */
  if (string == 0 || *string == 0)
    {
      if (lenp)
	*lenp = 0;
      return ((char *)NULL);
    }

  locale = get_locale_var ("LC_MESSAGES");

  /* If we don't have setlocale() or the current locale is `C' or `POSIX',
     just return the string.  If we don't have gettext(), there's no use
     doing anything else. */
  if (locale == 0 || locale[0] == '\0' ||
      (locale[0] == 'C' && locale[1] == '\0') || STREQ (locale, "POSIX"))
    {
      t = (char *)xmalloc (len + 1);
      strcpy (t, string);
      if (lenp)
	*lenp = len;
      return (t);
    }

  /* Now try to translate it. */
  if (default_domain && *default_domain)
    translated = dgettext (default_domain, string);
  else
    translated = string;

  if (translated == string)	/* gettext returns its argument if untranslatable */
    {
      t = (char *)xmalloc (len + 1);
      strcpy (t, string);
      if (lenp)
	*lenp = len;
    }
  else
    {
      tlen = strlen (translated);
      t = (char *)xmalloc (tlen + 1);
      strcpy (t, translated);
      if (lenp)
	*lenp = tlen;
    }
  return (t);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\locale.c:409
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\locale.c:464
parsing error 
{
  register int c, len;
  char *result, *r, *s;

  for (len = 0, s = string; s && *s; s++)
    {
      len++;
      if (*s == '"' || *s == '\\')
	len++;
      else if (*s == '\n')
	len += 5;
    }
  
  r = result = (char *)xmalloc (len + 3);
  *r++ = '"';

  for (s = string; s && (c = *s); s++)
    {
      if (c == '\n')	/* <NL> -> \n"<NL>" */
	{
	  *r++ = '\\';
	  *r++ = 'n';
	  *r++ = '"';
	  *r++ = '\n';
	  *r++ = '"';
	  if (foundnlp)
	    *foundnlp = 1;
	  continue;
	}
      if (c == '"' || c == '\\')
	*r++ = '\\';
      *r++ = c;
    }

  *r++ = '"';
  *r++ = '\0';

  return result;
}
warning: parse error {
  register int c, len;
  char *result, *r, *s;

  for (len = 0, s = string; s && *s; s++)
    {
      len++;
      if (*s == '"' || *s == '\\')
	len++;
      else if (*s == '\n')
	len += 5;
    }
  
  r = result = (char *)xmalloc (len + 3);
  *r++ = '"';

  for (s = string; s && (c = *s); s++)
    {
      if (c == '\n')	/* <NL> -> \n"<NL>" */
	{
	  *r++ = '\\';
	  *r++ = 'n';
	  *r++ = '"';
	  *r++ = '\n';
	  *r++ = '"';
	  if (foundnlp)
	    *foundnlp = 1;
	  continue;
	}
      if (c == '"' || c == '\\')
	*r++ = '\\';
      *r++ = c;
    }

  *r++ = '"';
  *r++ = '\0';

  return result;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\locale.c:467
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\locale.c:515
parsing error 
{
  int len, tlen, foundnl;
  char *temp, *t, *t2;

  temp = (char *)xmalloc (end - start + 1);
  for (tlen = 0, len = start; len < end; )
    temp[tlen++] = string[len++];
  temp[tlen] = '\0';

  /* If we're just dumping translatable strings, don't do anything with the
     string itself, but if we're dumping in `po' file format, convert it into
     a form more palatable to gettext(3) and friends by quoting `"' and `\'
     with backslashes and converting <NL> into `\n"<NL>"'.  If we find a
     newline in TEMP, we first output a `msgid ""' line and then the
     translated string; otherwise we output the `msgid' and translated
     string all on one line. */
  if (dump_translatable_strings)
    {
      if (dump_po_strings)
	{
	  foundnl = 0;
	  t = mk_msgstr (temp, &foundnl);
	  t2 = foundnl ? "\"\"\n" : "";

	  printf ("#: %s:%d\nmsgid %s%s\nmsgstr \"\"\n",
			yy_input_name (), lineno, t2, t);
	  free (t);
	}
      else
	printf ("\"%s\"\n", temp);

      if (lenp)
	*lenp = tlen;
      return (temp);
    }
  else if (*temp)
    {
      t = localetrans (temp, tlen, &len);
      free (temp);
      if (lenp)
	*lenp = len;
      return (t);
    }
  else
    {
      if (lenp)
	*lenp = 0;
      return (temp);
    }
}
warning: parse error {
  int len, tlen, foundnl;
  char *temp, *t, *t2;

  temp = (char *)xmalloc (end - start + 1);
  for (tlen = 0, len = start; len < end; )
    temp[tlen++] = string[len++];
  temp[tlen] = '\0';

  /* If we're just dumping translatable strings, don't do anything with the
     string itself, but if we're dumping in `po' file format, convert it into
     a form more palatable to gettext(3) and friends by quoting `"' and `\'
     with backslashes and converting <NL> into `\n"<NL>"'.  If we find a
     newline in TEMP, we first output a `msgid ""' line and then the
     translated string; otherwise we output the `msgid' and translated
     string all on one line. */
  if (dump_translatable_strings)
    {
      if (dump_po_strings)
	{
	  foundnl = 0;
	  t = mk_msgstr (temp, &foundnl);
	  t2 = foundnl ? "\"\"\n" : "";

	  printf ("#: %s:%d\nmsgid %s%s\nmsgstr \"\"\n",
			yy_input_name (), lineno, t2, t);
	  free (t);
	}
      else
	printf ("\"%s\"\n", temp);

      if (lenp)
	*lenp = tlen;
      return (temp);
    }
  else if (*temp)
    {
      t = localetrans (temp, tlen, &len);
      free (temp);
      if (lenp)
	*lenp = len;
      return (t);
    }
  else
    {
      if (lenp)
	*lenp = 0;
      return (temp);
    }
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\locale.c:518
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\locale.c:594
parsing error 
{
  char *cp, *encoding;

#if HAVE_LANGINFO_CODESET
  cp = nl_langinfo (CODESET);
  return (STREQ (cp, "UTF-8") || STREQ (cp, "utf8"));
#elif HAVE_LOCALE_CHARSET
  cp = locale_charset ();
  return (STREQ (cp, "UTF-8") || STREQ (cp, "utf8"));
#else
  /* Take a shot */
  for (cp = lspec; *cp && *cp != '@' && *cp != '+' && *cp != ','; cp++)
    {
      if (*cp == '.')
	{
	  for (encoding = ++cp; *cp && *cp != '@' && *cp != '+' && *cp != ','; cp++)
	    ;
	  /* The encoding (codeset) is the substring between encoding and cp */
	  if ((cp - encoding == 5 && STREQN (encoding, "UTF-8", 5)) ||
	      (cp - encoding == 4 && STREQN (encoding, "utf8", 4)))
	    return 1;
	  else
	    return 0;
	}
    }
  return 0;
#endif
}
warning: parse error {
  char *cp, *encoding;

#if HAVE_LANGINFO_CODESET
  cp = nl_langinfo (CODESET);
  return (STREQ (cp, "UTF-8") || STREQ (cp, "utf8"));
#elif HAVE_LOCALE_CHARSET
  cp = locale_charset ();
  return (STREQ (cp, "UTF-8") || STREQ (cp, "utf8"));
#else
  /* Take a shot */
  for (cp = lspec; *cp && *cp != '@' && *cp != '+' && *cp != ','; cp++)
    {
      if (*cp == '.')
	{
	  for (encoding = ++cp; *cp && *cp != '@' && *cp != '+' && *cp != ','; cp++)
	    ;
	  /* The encoding (codeset) is the substring between encoding and cp */
	  if ((cp - encoding == 5 && STREQN (encoding, "UTF-8", 5)) ||
	      (cp - encoding == 4 && STREQN (encoding, "utf8", 4)))
	    return 1;
	  else
	    return 0;
	}
    }
  return 0;
#endif
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\locale.c:596
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\mailcheck.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashtypes.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\posixstat.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\posixtime.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashansi.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashintl.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\shell.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\execute_cmd.h...skip
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\mailcheck.h...
parsing error 
extern int time_to_check_mail PARAMS((void));
warning: parse error extern int time_to_check_mail PARAMS((void));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\mailcheck.h:34
parsing error 
extern void reset_mail_timer PARAMS((void));
warning: parse error extern void reset_mail_timer PARAMS((void));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\mailcheck.h:35
parsing error 
extern void reset_mail_files PARAMS((void));
warning: parse error extern void reset_mail_files PARAMS((void));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\mailcheck.h:36
parsing error 
extern void free_mail_files PARAMS((void));
warning: parse error extern void free_mail_files PARAMS((void));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\mailcheck.h:37
parsing error 
extern char *make_default_mailpath PARAMS((void));
warning: parse error extern char *make_default_mailpath PARAMS((void));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\mailcheck.h:38
parsing error 
extern void remember_mail_dates PARAMS((void));
warning: parse error extern void remember_mail_dates PARAMS((void));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\mailcheck.h:39
parsing error 
extern void init_mail_dates PARAMS((void));
warning: parse error extern void init_mail_dates PARAMS((void));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\mailcheck.h:40
parsing error 
extern void check_mail PARAMS((void));
warning: parse error extern void check_mail PARAMS((void));Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\mailcheck.h:41
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\tilde\tilde.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\mailcheck.c:115
parsing error 
{
  register int i;

  for (i = 0; i < mailfiles_count; i++)
    if (STREQ (mailfiles[i]->name, file))
      return i;

  return -1;
}
warning: parse error {
  register int i;

  for (i = 0; i < mailfiles_count; i++)
    if (STREQ (mailfiles[i]->name, file))
      return i;

  return -1;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\mailcheck.c:117
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\mailcheck.c:147
parsing error 
{
  mailfiles[i]->access_time = mailfiles[i]->mod_time = last_time_mail_checked ? last_time_mail_checked : shell_start_time;
  mailfiles[i]->file_size = 0;
  mailfiles[i]->flags = 0;
}
warning: parse error {
  mailfiles[i]->access_time = mailfiles[i]->mod_time = last_time_mail_checked ? last_time_mail_checked : shell_start_time;
  mailfiles[i]->file_size = 0;
  mailfiles[i]->flags = 0;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\mailcheck.c:149
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\mailcheck.c:156
parsing error 
{
  char *file;
  struct stat finfo;

  file = mailfiles[i]->name;
  if (mailstat (file, &finfo) == 0)
    UPDATE_MAIL_FILE (i, finfo);
  else
    RESET_MAIL_FILE (i);
}
warning: parse error {
  char *file;
  struct stat finfo;

  file = mailfiles[i]->name;
  if (mailstat (file, &finfo) == 0)
    UPDATE_MAIL_FILE (i, finfo);
  else
    RESET_MAIL_FILE (i);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\mailcheck.c:158
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\mailcheck.c:172
parsing error 
{
  struct stat finfo;
  char *filename;
  int i;

  filename = full_pathname (file);
  i = find_mail_file (filename);
  if (i >= 0)
    {
      if (mailstat (filename, &finfo) == 0)
	UPDATE_MAIL_FILE (i, finfo);

      free (filename);
      return i;
    }

  i = mailfiles_count++;
  mailfiles = (FILEINFO **)xrealloc
		(mailfiles, mailfiles_count * sizeof (FILEINFO *));

  mailfiles[i] = alloc_mail_file (filename, msg);
  init_mail_file (i);

  return i;
}
warning: parse error {
  struct stat finfo;
  char *filename;
  int i;

  filename = full_pathname (file);
  i = find_mail_file (filename);
  if (i >= 0)
    {
      if (mailstat (filename, &finfo) == 0)
	UPDATE_MAIL_FILE (i, finfo);

      free (filename);
      return i;
    }

  i = mailfiles_count++;
  mailfiles = (FILEINFO **)xrealloc
		(mailfiles, mailfiles_count * sizeof (FILEINFO *));

  mailfiles[i] = alloc_mail_file (filename, msg);
  init_mail_file (i);

  return i;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\mailcheck.c:174
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\mailcheck.c:211
parsing error 
{
  FILEINFO *mf;

  mf = (FILEINFO *)xmalloc (sizeof (FILEINFO));
  mf->name = filename;
  mf->msg = msg ? savestring (msg) : (char *)NULL;
  mf->flags = 0;

  return mf;
}
warning: parse error {
  FILEINFO *mf;

  mf = (FILEINFO *)xmalloc (sizeof (FILEINFO));
  mf->name = filename;
  mf->msg = msg ? savestring (msg) : (char *)NULL;
  mf->flags = 0;

  return mf;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\mailcheck.c:213
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\mailcheck.c:225
parsing error 
{
  free (mf->name);
  FREE (mf->msg);
  free (mf);
}
warning: parse error {
  free (mf->name);
  FREE (mf->msg);
  free (mf);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\mailcheck.c:227
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\mailcheck.c:260
parsing error 
{
  time_t mtime;
  struct stat finfo;
  char *file;

  file = mailfiles[i]->name;
  mtime = mailfiles[i]->mod_time;

  if (mailstat (file, &finfo) != 0)
    return (0);

  if (finfo.st_size > 0)
    return (mtime < finfo.st_mtime);

  if (finfo.st_size == 0 && mailfiles[i]->file_size > 0)
    UPDATE_MAIL_FILE (i, finfo);

  return (0);
}
warning: parse error {
  time_t mtime;
  struct stat finfo;
  char *file;

  file = mailfiles[i]->name;
  mtime = mailfiles[i]->mod_time;

  if (mailstat (file, &finfo) != 0)
    return (0);

  if (finfo.st_size > 0)
    return (mtime < finfo.st_mtime);

  if (finfo.st_size == 0 && mailfiles[i]->file_size > 0)
    UPDATE_MAIL_FILE (i, finfo);

  return (0);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\mailcheck.c:262
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\mailcheck.c:284
parsing error 
{
  time_t atime;
  struct stat finfo;
  char *file;

  file = mailfiles[i]->name;
  atime = mailfiles[i]->access_time;

  if (mailstat (file, &finfo) != 0)
    return (0);

  if (finfo.st_size > 0)
    return (atime < finfo.st_atime);

  return (0);
}
warning: parse error {
  time_t atime;
  struct stat finfo;
  char *file;

  file = mailfiles[i]->name;
  atime = mailfiles[i]->access_time;

  if (mailstat (file, &finfo) != 0)
    return (0);

  if (finfo.st_size > 0)
    return (atime < finfo.st_atime);

  return (0);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\mailcheck.c:286
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\mailcheck.c:305
parsing error 
{
  off_t size;
  struct stat finfo;
  char *file;

  file = mailfiles[i]->name;
  size = mailfiles[i]->file_size;

  return ((mailstat (file, &finfo) == 0) && (finfo.st_size > size));
}
warning: parse error {
  off_t size;
  struct stat finfo;
  char *file;

  file = mailfiles[i]->name;
  size = mailfiles[i]->file_size;

  return ((mailstat (file, &finfo) == 0) && (finfo.st_size > size));
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\mailcheck.c:307
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\mailcheck.c:322
parsing error 
{
  char *s;
  int pass_next;

  for (s = str, pass_next = 0; s && *s; s++)
    {
      if (pass_next)
	{
	  pass_next = 0;
	  continue;
	}
      if (*s == '\\')
	{
	  pass_next++;
	  continue;
	}
      if (*s == '?' || *s == '%')
	return s;
    }
  return ((char *)NULL);
}
warning: parse error {
  char *s;
  int pass_next;

  for (s = str, pass_next = 0; s && *s; s++)
    {
      if (pass_next)
	{
	  pass_next = 0;
	  continue;
	}
      if (*s == '\\')
	{
	  pass_next++;
	  continue;
	}
      if (*s == '?' || *s == '%')
	return s;
    }
  return ((char *)NULL);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\mailcheck.c:324
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\make_cmd.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashtypes.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\filecntl.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashansi.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashintl.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\shell.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\execute_cmd.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\parser.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\flags.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\input.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\jobs.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\shmbutil.h...skip
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\make_cmd.c:84
parsing error 
{
  WORD_DESC *temp;

  temp = alloc_word_desc ();

  if (*string)
    temp->word = savestring (string);
  else
    {
      temp->word = (char *)xmalloc (1);
      temp->word[0] = '\0';
    }

  return (temp);
}
warning: parse error {
  WORD_DESC *temp;

  temp = alloc_word_desc ();

  if (*string)
    temp->word = savestring (string);
  else
    {
      temp->word = (char *)xmalloc (1);
      temp->word[0] = '\0';
    }

  return (temp);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\make_cmd.c:85
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\make_cmd.c:102
parsing error 
{
  register int i;
  size_t slen;
  DECLARE_MBSTATE;

  i = 0;
  slen = strlen (string);
  while (i < slen)
    {
      switch (string[i])
	{
	case '$':
	  w->flags |= W_HASDOLLAR;
	  break;
	case '\\':
	  break;	/* continue the loop */
	case '\'':
	case '`':
	case '"':
	  w->flags |= W_QUOTED;
	  break;
	}

      ADVANCE_CHAR (string, slen, i);
    }

  return (w);
}
warning: parse error {
  register int i;
  size_t slen;
  DECLARE_MBSTATE;

  i = 0;
  slen = strlen (string);
  while (i < slen)
    {
      switch (string[i])
	{
	case '$':
	  w->flags |= W_HASDOLLAR;
	  break;
	case '\\':
	  break;	/* continue the loop */
	case '\'':
	case '`':
	case '"':
	  w->flags |= W_QUOTED;
	  break;
	}

      ADVANCE_CHAR (string, slen, i);
    }

  return (w);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\make_cmd.c:105
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\make_cmd.c:136
parsing error 
{
  WORD_DESC *temp;

  temp = make_bare_word (string);
  return (make_word_flags (temp, string));
}
warning: parse error {
  WORD_DESC *temp;

  temp = make_bare_word (string);
  return (make_word_flags (temp, string));
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\make_cmd.c:137
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\make_cmd.c:145
parsing error 
{
  char tokenizer[2];

  tokenizer[0] = token;
  tokenizer[1] = '\0';

  return (make_word (tokenizer));
}
warning: parse error {
  char tokenizer[2];

  tokenizer[0] = token;
  tokenizer[1] = '\0';

  return (make_word (tokenizer));
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\make_cmd.c:147
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\make_cmd.c:157
parsing error 
{
  WORD_LIST *temp;

  ocache_alloc (wlcache, WORD_LIST, temp);

  temp->word = word;
  temp->next = wlink;
  return (temp);
}
warning: parse error {
  WORD_LIST *temp;

  ocache_alloc (wlcache, WORD_LIST, temp);

  temp->word = word;
  temp->next = wlink;
  return (temp);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\make_cmd.c:160
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\make_cmd.c:171
parsing error 
{
  COMMAND *temp;

  temp = (COMMAND *)xmalloc (sizeof (COMMAND));
  temp->type = type;
  temp->value.Simple = pointer;
  temp->value.Simple->flags = temp->flags = 0;
  temp->redirects = (REDIRECT *)NULL;
  return (temp);
}
warning: parse error {
  COMMAND *temp;

  temp = (COMMAND *)xmalloc (sizeof (COMMAND));
  temp->type = type;
  temp->value.Simple = pointer;
  temp->value.Simple->flags = temp->flags = 0;
  temp->redirects = (REDIRECT *)NULL;
  return (temp);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\make_cmd.c:174
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\make_cmd.c:186
parsing error 
{
  CONNECTION *temp;

  temp = (CONNECTION *)xmalloc (sizeof (CONNECTION));
  temp->connector = connector;
  temp->first = com1;
  temp->second = com2;
  return (make_command (cm_connection, (SIMPLE_COM *)temp));
}
warning: parse error {
  CONNECTION *temp;

  temp = (CONNECTION *)xmalloc (sizeof (CONNECTION));
  temp->connector = connector;
  temp->first = com1;
  temp->second = com2;
  return (make_command (cm_connection, (SIMPLE_COM *)temp));
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\make_cmd.c:189
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\make_cmd.c:200
parsing error 
{
  FOR_COM *temp;

  temp = (FOR_COM *)xmalloc (sizeof (FOR_COM));
  temp->flags = 0;
  temp->name = name;
  temp->line = lineno;
  temp->map_list = map_list;
  temp->action = action;
  return (make_command (type, (SIMPLE_COM *)temp));
}
warning: parse error {
  FOR_COM *temp;

  temp = (FOR_COM *)xmalloc (sizeof (FOR_COM));
  temp->flags = 0;
  temp->name = name;
  temp->line = lineno;
  temp->map_list = map_list;
  temp->action = action;
  return (make_command (type, (SIMPLE_COM *)temp));
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\make_cmd.c:206
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\make_cmd.c:219
parsing error 
{
  return (make_for_or_select (cm_for, name, map_list, action, lineno));
}
warning: parse error {
  return (make_for_or_select (cm_for, name, map_list, action, lineno));
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\make_cmd.c:224
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\make_cmd.c:229
parsing error 
{
#if defined (SELECT_COMMAND)
  return (make_for_or_select (cm_select, name, map_list, action, lineno));
#else
  set_exit_status (2);
  return ((COMMAND *)NULL);
#endif
}
warning: parse error {
#if defined (SELECT_COMMAND)
  return (make_for_or_select (cm_select, name, map_list, action, lineno));
#else
  set_exit_status (2);
  return ((COMMAND *)NULL);
#endif
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\make_cmd.c:234
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\make_cmd.c:268
parsing error 
{
#if defined (ARITH_FOR_COMMAND)
  ARITH_FOR_COM *temp;
  WORD_LIST *init, *test, *step;
  char *s, *t, *start;
  int nsemi, i;

  init = test = step = (WORD_LIST *)NULL;
  /* Parse the string into the three component sub-expressions. */
  start = t = s = exprs->word->word;
  for (nsemi = 0; ;)
    {
      /* skip whitespace at the start of each sub-expression. */
      while (whitespace (*s))
	s++;
      start = s;
      /* skip to the semicolon or EOS */
      i = skip_to_delim (start, 0, ";", SD_NOJMP|SD_NOPROCSUB);
      s = start + i;

      t = (i > 0) ? substring (start, 0, i) : (char *)NULL;

      nsemi++;
      switch (nsemi)
	{
	case 1:
	  init = make_arith_for_expr (t);
	  break;
	case 2:
	  test = make_arith_for_expr (t);
	  break;
	case 3:
	  step = make_arith_for_expr (t);
	  break;
	}

      FREE (t);
      if (*s == '\0')
	break;
      s++;	/* skip over semicolon */
    }

  if (nsemi != 3)
    {
      if (nsemi < 3)
	parser_error (lineno, _("syntax error: arithmetic expression required"));
      else
	parser_error (lineno, _("syntax error: `;' unexpected"));
      parser_error (lineno, _("syntax error: `((%s))'"), exprs->word->word);
      free (init);
      free (test);
      free (step);
      set_exit_status (2);
      return ((COMMAND *)NULL);
    }

  temp = (ARITH_FOR_COM *)xmalloc (sizeof (ARITH_FOR_COM));
  temp->flags = 0;
  temp->line = lineno;
  temp->init = init ? init : make_arith_for_expr ("1");
  temp->test = test ? test : make_arith_for_expr ("1");
  temp->step = step ? step : make_arith_for_expr ("1");
  temp->action = action;

  dispose_words (exprs);
  return (make_command (cm_arith_for, (SIMPLE_COM *)temp));
#else
  dispose_words (exprs);
  set_exit_status (2);
  return ((COMMAND *)NULL);
#endif /* ARITH_FOR_COMMAND */
}
warning: parse error {
#if defined (ARITH_FOR_COMMAND)
  ARITH_FOR_COM *temp;
  WORD_LIST *init, *test, *step;
  char *s, *t, *start;
  int nsemi, i;

  init = test = step = (WORD_LIST *)NULL;
  /* Parse the string into the three component sub-expressions. */
  start = t = s = exprs->word->word;
  for (nsemi = 0; ;)
    {
      /* skip whitespace at the start of each sub-expression. */
      while (whitespace (*s))
	s++;
      start = s;
      /* skip to the semicolon or EOS */
      i = skip_to_delim (start, 0, ";", SD_NOJMP|SD_NOPROCSUB);
      s = start + i;

      t = (i > 0) ? substring (start, 0, i) : (char *)NULL;

      nsemi++;
      switch (nsemi)
	{
	case 1:
	  init = make_arith_for_expr (t);
	  break;
	case 2:
	  test = make_arith_for_expr (t);
	  break;
	case 3:
	  step = make_arith_for_expr (t);
	  break;
	}

      FREE (t);
      if (*s == '\0')
	break;
      s++;	/* skip over semicolon */
    }

  if (nsemi != 3)
    {
      if (nsemi < 3)
	parser_error (lineno, _("syntax error: arithmetic expression required"));
      else
	parser_error (lineno, _("syntax error: `;' unexpected"));
      parser_error (lineno, _("syntax error: `((%s))'"), exprs->word->word);
      free (init);
      free (test);
      free (step);
      set_exit_status (2);
      return ((COMMAND *)NULL);
    }

  temp = (ARITH_FOR_COM *)xmalloc (sizeof (ARITH_FOR_COM));
  temp->flags = 0;
  temp->line = lineno;
  temp->init = init ? init : make_arith_for_expr ("1");
  temp->test = test ? test : make_arith_for_expr ("1");
  temp->step = step ? step : make_arith_for_expr ("1");
  temp->action = action;

  dispose_words (exprs);
  return (make_command (cm_arith_for, (SIMPLE_COM *)temp));
#else
  dispose_words (exprs);
  set_exit_status (2);
  return ((COMMAND *)NULL);
#endif /* ARITH_FOR_COMMAND */
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\make_cmd.c:272
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\make_cmd.c:346
parsing error 
{
  GROUP_COM *temp;

  temp = (GROUP_COM *)xmalloc (sizeof (GROUP_COM));
  temp->command = command;
  return (make_command (cm_group, (SIMPLE_COM *)temp));
}
warning: parse error {
  GROUP_COM *temp;

  temp = (GROUP_COM *)xmalloc (sizeof (GROUP_COM));
  temp->command = command;
  return (make_command (cm_group, (SIMPLE_COM *)temp));
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\make_cmd.c:348
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\make_cmd.c:357
parsing error 
{
  CASE_COM *temp;

  temp = (CASE_COM *)xmalloc (sizeof (CASE_COM));
  temp->flags = 0;
  temp->line = lineno;
  temp->word = word;
  temp->clauses = REVERSE_LIST (clauses, PATTERN_LIST *);
  return (make_command (cm_case, (SIMPLE_COM *)temp));
}
warning: parse error {
  CASE_COM *temp;

  temp = (CASE_COM *)xmalloc (sizeof (CASE_COM));
  temp->flags = 0;
  temp->line = lineno;
  temp->word = word;
  temp->clauses = REVERSE_LIST (clauses, PATTERN_LIST *);
  return (make_command (cm_case, (SIMPLE_COM *)temp));
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\make_cmd.c:361
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\make_cmd.c:373
parsing error 
{
  PATTERN_LIST *temp;

  temp = (PATTERN_LIST *)xmalloc (sizeof (PATTERN_LIST));
  temp->patterns = REVERSE_LIST (patterns, WORD_LIST *);
  temp->action = action;
  temp->next = NULL;
  temp->flags = 0;
  return (temp);
}
warning: parse error {
  PATTERN_LIST *temp;

  temp = (PATTERN_LIST *)xmalloc (sizeof (PATTERN_LIST));
  temp->patterns = REVERSE_LIST (patterns, WORD_LIST *);
  temp->action = action;
  temp->next = NULL;
  temp->flags = 0;
  return (temp);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\make_cmd.c:376
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\make_cmd.c:388
parsing error 
{
  IF_COM *temp;

  temp = (IF_COM *)xmalloc (sizeof (IF_COM));
  temp->flags = 0;
  temp->test = test;
  temp->true_case = true_case;
  temp->false_case = false_case;
  return (make_command (cm_if, (SIMPLE_COM *)temp));
}
warning: parse error {
  IF_COM *temp;

  temp = (IF_COM *)xmalloc (sizeof (IF_COM));
  temp->flags = 0;
  temp->test = test;
  temp->true_case = true_case;
  temp->false_case = false_case;
  return (make_command (cm_if, (SIMPLE_COM *)temp));
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\make_cmd.c:390
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\make_cmd.c:402
parsing error 
{
  WHILE_COM *temp;

  temp = (WHILE_COM *)xmalloc (sizeof (WHILE_COM));
  temp->flags = 0;
  temp->test = test;
  temp->action = action;
  return (make_command (which, (SIMPLE_COM *)temp));
}
warning: parse error {
  WHILE_COM *temp;

  temp = (WHILE_COM *)xmalloc (sizeof (WHILE_COM));
  temp->flags = 0;
  temp->test = test;
  temp->action = action;
  return (make_command (which, (SIMPLE_COM *)temp));
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\make_cmd.c:405
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\make_cmd.c:416
parsing error 
{
  return (make_until_or_while (cm_while, test, action));
}
warning: parse error {
  return (make_until_or_while (cm_while, test, action));
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\make_cmd.c:418
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\make_cmd.c:423
parsing error 
{
  return (make_until_or_while (cm_until, test, action));
}
warning: parse error {
  return (make_until_or_while (cm_until, test, action));
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\make_cmd.c:425
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\make_cmd.c:430
parsing error 
{
#if defined (DPAREN_ARITHMETIC)
  COMMAND *command;
  ARITH_COM *temp;

  command = (COMMAND *)xmalloc (sizeof (COMMAND));
  command->value.Arith = temp = (ARITH_COM *)xmalloc (sizeof (ARITH_COM));

  temp->flags = 0;
  temp->line = line_number;
  temp->exp = exp;

  command->type = cm_arith;
  command->redirects = (REDIRECT *)NULL;
  command->flags = 0;

  return (command);
#else
  set_exit_status (2);
  return ((COMMAND *)NULL);
#endif
}
warning: parse error {
#if defined (DPAREN_ARITHMETIC)
  COMMAND *command;
  ARITH_COM *temp;

  command = (COMMAND *)xmalloc (sizeof (COMMAND));
  command->value.Arith = temp = (ARITH_COM *)xmalloc (sizeof (ARITH_COM));

  temp->flags = 0;
  temp->line = line_number;
  temp->exp = exp;

  command->type = cm_arith;
  command->redirects = (REDIRECT *)NULL;
  command->flags = 0;

  return (command);
#else
  set_exit_status (2);
  return ((COMMAND *)NULL);
#endif
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\make_cmd.c:432
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\make_cmd.c:477
parsing error 
{
#if defined (COND_COMMAND)
  COMMAND *command;

  command = (COMMAND *)xmalloc (sizeof (COMMAND));
  command->value.Cond = cond_node;

  command->type = cm_cond;
  command->redirects = (REDIRECT *)NULL;
  command->flags = 0;
  command->line = cond_node ? cond_node->line : 0;

  return (command);
#else
  set_exit_status (2);
  return ((COMMAND *)NULL);
#endif
}
warning: parse error {
#if defined (COND_COMMAND)
  COMMAND *command;

  command = (COMMAND *)xmalloc (sizeof (COMMAND));
  command->value.Cond = cond_node;

  command->type = cm_cond;
  command->redirects = (REDIRECT *)NULL;
  command->flags = 0;
  command->line = cond_node ? cond_node->line : 0;

  return (command);
#else
  set_exit_status (2);
  return ((COMMAND *)NULL);
#endif
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\make_cmd.c:479
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\make_cmd.c:522
parsing error 
{
  /* If we are starting from scratch, then make the initial command
     structure.  Also note that we have to fill in all the slots, since
     malloc doesn't return zeroed space. */
  if (command == 0)
    {
      command = make_bare_simple_command ();
      parser_state |= PST_REDIRLIST;
    }

  if (element.word)
    {
      command->value.Simple->words = make_word_list (element.word, command->value.Simple->words);
      parser_state &= ~PST_REDIRLIST;
    }
  else if (element.redirect)
    {
      REDIRECT *r = element.redirect;
      /* Due to the way <> is implemented, there may be more than a single
	 redirection in element.redirect.  We just follow the chain as far
	 as it goes, and hook onto the end. */
      while (r->next)
	r = r->next;
      r->next = command->value.Simple->redirects;
      command->value.Simple->redirects = element.redirect;
    }

  return (command);
}
warning: parse error {
  /* If we are starting from scratch, then make the initial command
     structure.  Also note that we have to fill in all the slots, since
     malloc doesn't return zeroed space. */
  if (command == 0)
    {
      command = make_bare_simple_command ();
      parser_state |= PST_REDIRLIST;
    }

  if (element.word)
    {
      command->value.Simple->words = make_word_list (element.word, command->value.Simple->words);
      parser_state &= ~PST_REDIRLIST;
    }
  else if (element.redirect)
    {
      REDIRECT *r = element.redirect;
      /* Due to the way <> is implemented, there may be more than a single
	 redirection in element.redirect.  We just follow the chain as far
	 as it goes, and hook onto the end. */
      while (r->next)
	r = r->next;
      r->next = command->value.Simple->redirects;
      command->value.Simple->redirects = element.redirect;
    }

  return (command);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\make_cmd.c:525
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\make_cmd.c:561
parsing error 
{
  int kill_leading, redir_len;
  char *redir_word, *document, *full_line;
  int document_index, document_size, delim_unquoted;

  if (temp->instruction != r_deblank_reading_until &&
      temp->instruction != r_reading_until)
    {
      internal_error (_("make_here_document: bad instruction type %d"), temp->instruction);
      return;
    }

  kill_leading = temp->instruction == r_deblank_reading_until;

  document = (char *)NULL;
  document_index = document_size = 0;

  /* Quote removal is the only expansion performed on the delimiter
     for here documents, making it an extremely special case. */
  redir_word = string_quote_removal (temp->redirectee.filename->word, 0);

  /* redirection_expand will return NULL if the expansion results in
     multiple words or no words.  Check for that here, and just abort
     this here document if it does. */
  if (redir_word)
    redir_len = strlen (redir_word);
  else
    {
      temp->here_doc_eof = (char *)xmalloc (1);
      temp->here_doc_eof[0] = '\0';
      goto document_done;
    }

  free (temp->redirectee.filename->word);
  temp->here_doc_eof = redir_word;

  /* Read lines from wherever lines are coming from.
     For each line read, if kill_leading, then kill the
     leading tab characters.
     If the line matches redir_word exactly, then we have
     manufactured the document.  Otherwise, add the line to the
     list of lines in the document. */

  /* If the here-document delimiter was quoted, the lines should
     be read verbatim from the input.  If it was not quoted, we
     need to perform backslash-quoted newline removal. */
  delim_unquoted = (temp->redirectee.filename->flags & W_QUOTED) == 0;
  while (full_line = read_secondary_line (delim_unquoted))
    {
      register char *line;
      int len;

      here_doc_first_line = 0;
      line = full_line;
      line_number++;

      /* If set -v is in effect, echo the line read.  read_secondary_line/
	 read_a_line leaves the newline at the end, so don't print another. */
      if (echo_input_at_read)
	fprintf (stderr, "%s", line);

      if (kill_leading && *line)
	{
	  /* Hack:  To be compatible with some Bourne shells, we
	     check the word before stripping the whitespace.  This
	     is a hack, though. */
	  if (STREQN (line, redir_word, redir_len) && line[redir_len] == '\n')
	    goto document_done;

	  while (*line == '\t')
	    line++;
	}

      if (*line == 0)
	continue;

      if (STREQN (line, redir_word, redir_len) && line[redir_len] == '\n')
	goto document_done;

      len = strlen (line);
      if (len + document_index >= document_size)
	{
	  document_size = document_size ? 2 * (document_size + len) : len + 2;
	  document = (char *)xrealloc (document, document_size);
	}

      /* len is guaranteed to be > 0 because of the check for line
	 being an empty string before the call to strlen. */
      FASTCOPY (line, document + document_index, len);
      document_index += len;
    }

  if (full_line == 0)
    internal_warning (_("here-document at line %d delimited by end-of-file (wanted `%s')"), lineno, redir_word);

document_done:
  if (document)
    document[document_index] = '\0';
  else
    {
      document = (char *)xmalloc (1);
      document[0] = '\0';
    }
  temp->redirectee.filename->word = document;
  here_doc_first_line = 0;
}
warning: parse error {
  int kill_leading, redir_len;
  char *redir_word, *document, *full_line;
  int document_index, document_size, delim_unquoted;

  if (temp->instruction != r_deblank_reading_until &&
      temp->instruction != r_reading_until)
    {
      internal_error (_("make_here_document: bad instruction type %d"), temp->instruction);
      return;
    }

  kill_leading = temp->instruction == r_deblank_reading_until;

  document = (char *)NULL;
  document_index = document_size = 0;

  /* Quote removal is the only expansion performed on the delimiter
     for here documents, making it an extremely special case. */
  redir_word = string_quote_removal (temp->redirectee.filename->word, 0);

  /* redirection_expand will return NULL if the expansion results in
     multiple words or no words.  Check for that here, and just abort
     this here document if it does. */
  if (redir_word)
    redir_len = strlen (redir_word);
  else
    {
      temp->here_doc_eof = (char *)xmalloc (1);
      temp->here_doc_eof[0] = '\0';
      goto document_done;
    }

  free (temp->redirectee.filename->word);
  temp->here_doc_eof = redir_word;

  /* Read lines from wherever lines are coming from.
     For each line read, if kill_leading, then kill the
     leading tab characters.
     If the line matches redir_word exactly, then we have
     manufactured the document.  Otherwise, add the line to the
     list of lines in the document. */

  /* If the here-document delimiter was quoted, the lines should
     be read verbatim from the input.  If it was not quoted, we
     need to perform backslash-quoted newline removal. */
  delim_unquoted = (temp->redirectee.filename->flags & W_QUOTED) == 0;
  while (full_line = read_secondary_line (delim_unquoted))
    {
      register char *line;
      int len;

      here_doc_first_line = 0;
      line = full_line;
      line_number++;

      /* If set -v is in effect, echo the line read.  read_secondary_line/
	 read_a_line leaves the newline at the end, so don't print another. */
      if (echo_input_at_read)
	fprintf (stderr, "%s", line);

      if (kill_leading && *line)
	{
	  /* Hack:  To be compatible with some Bourne shells, we
	     check the word before stripping the whitespace.  This
	     is a hack, though. */
	  if (STREQN (line, redir_word, redir_len) && line[redir_len] == '\n')
	    goto document_done;

	  while (*line == '\t')
	    line++;
	}

      if (*line == 0)
	continue;

      if (STREQN (line, redir_word, redir_len) && line[redir_len] == '\n')
	goto document_done;

      len = strlen (line);
      if (len + document_index >= document_size)
	{
	  document_size = document_size ? 2 * (document_size + len) : len + 2;
	  document = (char *)xrealloc (document, document_size);
	}

      /* len is guaranteed to be > 0 because of the check for line
	 being an empty string before the call to strlen. */
      FASTCOPY (line, document + document_index, len);
      document_index += len;
    }

  if (full_line == 0)
    internal_warning (_("here-document at line %d delimited by end-of-file (wanted `%s')"), lineno, redir_word);

document_done:
  if (document)
    document[document_index] = '\0';
  else
    {
      document = (char *)xmalloc (1);
      document[0] = '\0';
    }
  temp->redirectee.filename->word = document;
  here_doc_first_line = 0;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\make_cmd.c:564
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\make_cmd.c:675
parsing error 
{
  REDIRECT *temp;
  WORD_DESC *w;
  int wlen;
  intmax_t lfd;

  temp = (REDIRECT *)xmalloc (sizeof (REDIRECT));

  /* First do the common cases. */
  temp->redirector = source;
  temp->redirectee = dest_and_filename;
  temp->here_doc_eof = 0;
  temp->instruction = instruction;
  temp->flags = 0;
  temp->rflags = flags;
  temp->next = (REDIRECT *)NULL;

  switch (instruction)
    {

    case r_output_direction:		/* >foo */
    case r_output_force:		/* >| foo */
    case r_err_and_out:			/* &>filename */
      temp->flags = O_TRUNC | O_WRONLY | O_CREAT;
      break;

    case r_appending_to:		/* >>foo */
    case r_append_err_and_out:		/* &>> filename */
      temp->flags = O_APPEND | O_WRONLY | O_CREAT;
      break;

    case r_input_direction:		/* <foo */
    case r_inputa_direction:		/* foo & makes this. */
      temp->flags = O_RDONLY;
      break;

    case r_input_output:		/* <>foo */
      temp->flags = O_RDWR | O_CREAT;
      break;

    case r_deblank_reading_until: 	/* <<-foo */
    case r_reading_until:		/* << foo */
    case r_reading_string:		/* <<< foo */
    case r_close_this:			/* <&- */
    case r_duplicating_input:		/* 1<&2 */
    case r_duplicating_output:		/* 1>&2 */
      break;

    /* the parser doesn't pass these. */
    case r_move_input:			/* 1<&2- */
    case r_move_output:			/* 1>&2- */
    case r_move_input_word:		/* 1<&$foo- */
    case r_move_output_word:		/* 1>&$foo- */
      break;

    /* The way the lexer works we have to do this here. */
    case r_duplicating_input_word:	/* 1<&$foo */
    case r_duplicating_output_word:	/* 1>&$foo */
      w = dest_and_filename.filename;
      wlen = strlen (w->word) - 1;
      if (w->word[wlen] == '-')		/* Yuck */
        {
          w->word[wlen] = '\0';
	  if (all_digits (w->word) && legal_number (w->word, &lfd) && lfd == (int)lfd)
	    {
	      dispose_word (w);
	      temp->instruction = (instruction == r_duplicating_input_word) ? r_move_input : r_move_output;
	      temp->redirectee.dest = lfd;
	    }
	  else
	    temp->instruction = (instruction == r_duplicating_input_word) ? r_move_input_word : r_move_output_word;
        }
          
      break;

    default:
      programming_error (_("make_redirection: redirection instruction `%d' out of range"), instruction);
      abort ();
      break;
    }
  return (temp);
}
warning: parse error {
  REDIRECT *temp;
  WORD_DESC *w;
  int wlen;
  intmax_t lfd;

  temp = (REDIRECT *)xmalloc (sizeof (REDIRECT));

  /* First do the common cases. */
  temp->redirector = source;
  temp->redirectee = dest_and_filename;
  temp->here_doc_eof = 0;
  temp->instruction = instruction;
  temp->flags = 0;
  temp->rflags = flags;
  temp->next = (REDIRECT *)NULL;

  switch (instruction)
    {

    case r_output_direction:		/* >foo */
    case r_output_force:		/* >| foo */
    case r_err_and_out:			/* &>filename */
      temp->flags = O_TRUNC | O_WRONLY | O_CREAT;
      break;

    case r_appending_to:		/* >>foo */
    case r_append_err_and_out:		/* &>> filename */
      temp->flags = O_APPEND | O_WRONLY | O_CREAT;
      break;

    case r_input_direction:		/* <foo */
    case r_inputa_direction:		/* foo & makes this. */
      temp->flags = O_RDONLY;
      break;

    case r_input_output:		/* <>foo */
      temp->flags = O_RDWR | O_CREAT;
      break;

    case r_deblank_reading_until: 	/* <<-foo */
    case r_reading_until:		/* << foo */
    case r_reading_string:		/* <<< foo */
    case r_close_this:			/* <&- */
    case r_duplicating_input:		/* 1<&2 */
    case r_duplicating_output:		/* 1>&2 */
      break;

    /* the parser doesn't pass these. */
    case r_move_input:			/* 1<&2- */
    case r_move_output:			/* 1>&2- */
    case r_move_input_word:		/* 1<&$foo- */
    case r_move_output_word:		/* 1>&$foo- */
      break;

    /* The way the lexer works we have to do this here. */
    case r_duplicating_input_word:	/* 1<&$foo */
    case r_duplicating_output_word:	/* 1>&$foo */
      w = dest_and_filename.filename;
      wlen = strlen (w->word) - 1;
      if (w->word[wlen] == '-')		/* Yuck */
        {
          w->word[wlen] = '\0';
	  if (all_digits (w->word) && legal_number (w->word, &lfd) && lfd == (int)lfd)
	    {
	      dispose_word (w);
	      temp->instruction = (instruction == r_duplicating_input_word) ? r_move_input : r_move_output;
	      temp->redirectee.dest = lfd;
	    }
	  else
	    temp->instruction = (instruction == r_duplicating_input_word) ? r_move_input_word : r_move_output_word;
        }
          
      break;

    default:
      programming_error (_("make_redirection: redirection instruction `%d' out of range"), instruction);
      abort ();
      break;
    }
  return (temp);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\make_cmd.c:680
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\make_cmd.c:764
parsing error 
{
  FUNCTION_DEF *temp;
#if defined (ARRAY_VARS)
  SHELL_VAR *bash_source_v;
  ARRAY *bash_source_a;
#endif

  temp = (FUNCTION_DEF *)xmalloc (sizeof (FUNCTION_DEF));
  temp->command = command;
  temp->name = name;
  temp->line = lineno;
  temp->flags = 0;
  command->line = lstart;

  /* Information used primarily for debugging. */
  temp->source_file = 0;
#if defined (ARRAY_VARS)
  GET_ARRAY_FROM_VAR ("BASH_SOURCE", bash_source_v, bash_source_a);
  if (bash_source_a && array_num_elements (bash_source_a) > 0)
    temp->source_file = array_reference (bash_source_a, 0);
#endif
  /* Assume that shell functions without a source file before the shell is
     initialized come from the environment.  Otherwise default to "main"
     (usually functions being defined interactively) */
  if (temp->source_file == 0)
    temp->source_file = shell_initialized ? "main" : "environment";

#if defined (DEBUGGER)
  bind_function_def (name->word, temp, 0);
#endif

  temp->source_file = temp->source_file ? savestring (temp->source_file) : 0;

  return (make_command (cm_function_def, (SIMPLE_COM *)temp));
}
warning: parse error {
  FUNCTION_DEF *temp;
#if defined (ARRAY_VARS)
  SHELL_VAR *bash_source_v;
  ARRAY *bash_source_a;
#endif

  temp = (FUNCTION_DEF *)xmalloc (sizeof (FUNCTION_DEF));
  temp->command = command;
  temp->name = name;
  temp->line = lineno;
  temp->flags = 0;
  command->line = lstart;

  /* Information used primarily for debugging. */
  temp->source_file = 0;
#if defined (ARRAY_VARS)
  GET_ARRAY_FROM_VAR ("BASH_SOURCE", bash_source_v, bash_source_a);
  if (bash_source_a && array_num_elements (bash_source_a) > 0)
    temp->source_file = array_reference (bash_source_a, 0);
#endif
  /* Assume that shell functions without a source file before the shell is
     initialized come from the environment.  Otherwise default to "main"
     (usually functions being defined interactively) */
  if (temp->source_file == 0)
    temp->source_file = shell_initialized ? "main" : "environment";

#if defined (DEBUGGER)
  bind_function_def (name->word, temp, 0);
#endif

  temp->source_file = temp->source_file ? savestring (temp->source_file) : 0;

  return (make_command (cm_function_def, (SIMPLE_COM *)temp));
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\make_cmd.c:768
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\make_cmd.c:805
parsing error 
{
  SUBSHELL_COM *temp;

  temp = (SUBSHELL_COM *)xmalloc (sizeof (SUBSHELL_COM));
  temp->command = command;
  temp->flags = CMD_WANT_SUBSHELL;
  temp->line = line_number;
  return (make_command (cm_subshell, (SIMPLE_COM *)temp));
}
warning: parse error {
  SUBSHELL_COM *temp;

  temp = (SUBSHELL_COM *)xmalloc (sizeof (SUBSHELL_COM));
  temp->command = command;
  temp->flags = CMD_WANT_SUBSHELL;
  temp->line = line_number;
  return (make_command (cm_subshell, (SIMPLE_COM *)temp));
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\make_cmd.c:807
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\make_cmd.c:818
parsing error 
{
  COPROC_COM *temp;

  temp = (COPROC_COM *)xmalloc (sizeof (COPROC_COM));
  temp->name = savestring (name);
  temp->command = command;
  temp->flags = CMD_WANT_SUBSHELL|CMD_COPROC_SUBSHELL;
  return (make_command (cm_coproc, (SIMPLE_COM *)temp));
}
warning: parse error {
  COPROC_COM *temp;

  temp = (COPROC_COM *)xmalloc (sizeof (COPROC_COM));
  temp->name = savestring (name);
  temp->command = command;
  temp->flags = CMD_WANT_SUBSHELL|CMD_COPROC_SUBSHELL;
  return (make_command (cm_coproc, (SIMPLE_COM *)temp));
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\make_cmd.c:821
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\make_cmd.c:835
parsing error 
{
  if (command->type != cm_simple)
    command_error ("clean_simple_command", CMDERR_BADTYPE, command->type, 0);
  else
    {
      command->value.Simple->words =
	REVERSE_LIST (command->value.Simple->words, WORD_LIST *);
      command->value.Simple->redirects =
	REVERSE_LIST (command->value.Simple->redirects, REDIRECT *);
    }

  parser_state &= ~PST_REDIRLIST;
  return (command);
}
warning: parse error {
  if (command->type != cm_simple)
    command_error ("clean_simple_command", CMDERR_BADTYPE, command->type, 0);
  else
    {
      command->value.Simple->words =
	REVERSE_LIST (command->value.Simple->words, WORD_LIST *);
      command->value.Simple->redirects =
	REVERSE_LIST (command->value.Simple->redirects, REDIRECT *);
    }

  parser_state &= ~PST_REDIRLIST;
  return (command);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\make_cmd.c:837
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\make_cmd.c:862
parsing error 
{
  COMMAND *t, *t1, *t2;

  t1 = command;
  t = command->value.Connection->second;

  if (!t || (command->flags & CMD_WANT_SUBSHELL) ||
      command->value.Connection->connector != ';')
    {
      t = command_connect (command, command2, connector);
      return t;
    }

  /* This is just defensive programming.  The Yacc precedence rules
     will generally hand this function a command where t points directly
     to the command we want (e.g. given a ; b ; c ; d &, t1 will point
     to the `a ; b ; c' list and t will be the `d').  We only want to do
     this if the list is not being executed as a unit in the background
     with `( ... )', so we have to check for CMD_WANT_SUBSHELL.  That's
     the only way to tell. */
  while (((t->flags & CMD_WANT_SUBSHELL) == 0) && t->type == cm_connection &&
	 t->value.Connection->connector == ';')
    {
      t1 = t;
      t = t->value.Connection->second;
    }
  /* Now we have t pointing to the last command in the list, and
     t1->value.Connection->second == t. */
  t2 = command_connect (t, command2, connector);
  t1->value.Connection->second = t2;
  return command;
}
warning: parse error {
  COMMAND *t, *t1, *t2;

  t1 = command;
  t = command->value.Connection->second;

  if (!t || (command->flags & CMD_WANT_SUBSHELL) ||
      command->value.Connection->connector != ';')
    {
      t = command_connect (command, command2, connector);
      return t;
    }

  /* This is just defensive programming.  The Yacc precedence rules
     will generally hand this function a command where t points directly
     to the command we want (e.g. given a ; b ; c ; d &, t1 will point
     to the `a ; b ; c' list and t will be the `d').  We only want to do
     this if the list is not being executed as a unit in the background
     with `( ... )', so we have to check for CMD_WANT_SUBSHELL.  That's
     the only way to tell. */
  while (((t->flags & CMD_WANT_SUBSHELL) == 0) && t->type == cm_connection &&
	 t->value.Connection->connector == ';')
    {
      t1 = t;
      t = t->value.Connection->second;
    }
  /* Now we have t pointing to the last command in the list, and
     t1->value.Connection->second == t. */
  t2 = command_connect (t, command2, connector);
  t1->value.Connection->second = t2;
  return command;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\make_cmd.c:865
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\mksyntax.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashansi.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\chartypes.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\syntax.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashtypes.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\mksyntax.c:108
parsing error 
{
  static char xbuf[16];

  if (i == ' ')
    return "SPC";
  else if (ISPRINT (i))
    {
      xbuf[0] = i;
      xbuf[1] = '\0';
      return (xbuf);
    }
  else if (i == CTLESC)
    return "CTLESC";
  else if (i == CTLNUL)
    return "CTLNUL";
  else if (i == '\033')		/* ASCII */
    return "ESC";

  xbuf[0] = '\\';
  xbuf[2] = '\0';
    
  switch (i)
    {
#ifdef __STDC__
    case '\a': xbuf[1] = 'a'; break;
    case '\v': xbuf[1] = 'v'; break;
#else
    case '\007': xbuf[1] = 'a'; break;
    case 0x0B: xbuf[1] = 'v'; break;
#endif
    case '\b': xbuf[1] = 'b'; break;
    case '\f': xbuf[1] = 'f'; break;
    case '\n': xbuf[1] = 'n'; break;
    case '\r': xbuf[1] = 'r'; break;
    case '\t': xbuf[1] = 't'; break;
    default: sprintf (xbuf, "%d", i); break;
    }

  return xbuf;	
}
warning: parse error {
  static char xbuf[16];

  if (i == ' ')
    return "SPC";
  else if (ISPRINT (i))
    {
      xbuf[0] = i;
      xbuf[1] = '\0';
      return (xbuf);
    }
  else if (i == CTLESC)
    return "CTLESC";
  else if (i == CTLNUL)
    return "CTLNUL";
  else if (i == '\033')		/* ASCII */
    return "ESC";

  xbuf[0] = '\\';
  xbuf[2] = '\0';
    
  switch (i)
    {
#ifdef __STDC__
    case '\a': xbuf[1] = 'a'; break;
    case '\v': xbuf[1] = 'v'; break;
#else
    case '\007': xbuf[1] = 'a'; break;
    case 0x0B: xbuf[1] = 'v'; break;
#endif
    case '\b': xbuf[1] = 'b'; break;
    case '\f': xbuf[1] = 'f'; break;
    case '\n': xbuf[1] = 'n'; break;
    case '\r': xbuf[1] = 'r'; break;
    case '\t': xbuf[1] = 't'; break;
    default: sprintf (xbuf, "%d", i); break;
    }

  return xbuf;	
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\mksyntax.c:110
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\mksyntax.c:152
parsing error 
{
  int i;

  for (i = 0; i < N_WFLAGS; i++)
    if (f == wordflags[i].flag)
      return (wordflags[i].fstr);
  return ((char *)NULL);
}
warning: parse error {
  int i;

  for (i = 0; i < N_WFLAGS; i++)
    if (f == wordflags[i].flag)
      return (wordflags[i].fstr);
  return ((char *)NULL);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\mksyntax.c:154
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\mksyntax.c:164
parsing error 
{
  char *s, *fstr;
  unsigned char uc;

  for (s = str; s && *s; s++)
    {
      uc = *s;

      if (debug)
	{
	  fstr = getcstr (flag);
	  fprintf(stderr, "added %s for character %s\n", fstr, cdesc(uc));
	}
	
      lsyntax[uc] |= flag;
    }
}
warning: parse error {
  char *s, *fstr;
  unsigned char uc;

  for (s = str; s && *s; s++)
    {
      uc = *s;

      if (debug)
	{
	  fstr = getcstr (flag);
	  fprintf(stderr, "added %s for character %s\n", fstr, cdesc(uc));
	}
	
      lsyntax[uc] |= flag;
    }
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\mksyntax.c:167
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\mksyntax.c:186
parsing error 
{
  char *fstr;

  if (debug)
    {
      fstr = getcstr (flag);
      fprintf (stderr, "added %s for character %s\n", fstr, cdesc(c));
    }
  lsyntax[c] |= flag;
}
warning: parse error {
  char *fstr;

  if (debug)
    {
      fstr = getcstr (flag);
      fprintf (stderr, "added %s for character %s\n", fstr, cdesc(c));
    }
  lsyntax[c] |= flag;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\mksyntax.c:189
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\mksyntax.c:255
parsing error 
{
  int xflags, first, i;

  xflags = lsyntax[ind];
  first = 1;

  if (xflags == 0)
    fputs (wordflags[0].fstr, fp);
  else
    {
      for (i = 1; i < N_WFLAGS; i++)
	if (xflags & wordflags[i].flag)
	  {
	    if (first)
	      first = 0;
	    else
	      putc ('|', fp);
	    fputs (wordflags[i].fstr, fp);
  	  }
    }
}
warning: parse error {
  int xflags, first, i;

  xflags = lsyntax[ind];
  first = 1;

  if (xflags == 0)
    fputs (wordflags[0].fstr, fp);
  else
    {
      for (i = 1; i < N_WFLAGS; i++)
	if (xflags & wordflags[i].flag)
	  {
	    if (first)
	      first = 0;
	    else
	      putc ('|', fp);
	    fputs (wordflags[i].fstr, fp);
  	  }
    }
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\mksyntax.c:258
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\mksyntax.c:281
parsing error 
{
  fputs ("\t\t/* ", fp);

  fprintf (fp, "%s", cdesc(i));
      
  fputs (" */", fp);
}
warning: parse error {
  fputs ("\t\t/* ", fp);

  fprintf (fp, "%s", cdesc(i));
      
  fputs (" */", fp);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\mksyntax.c:284
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\mksyntax.c:293
parsing error 
{
  int i;

  fprintf (fp, "int sh_syntabsiz = %d;\n", SYNSIZE);
  fprintf (fp, "int sh_syntaxtab[%d] = {\n", SYNSIZE);

  for (i = 0; i < SYNSIZE; i++)
    {
      putc ('\t', fp);
      dump_lflags (fp, i);
      putc (',', fp);
      wcomment (fp, i);
      putc ('\n', fp);
    }

  fprintf (fp, "};\n");
}
warning: parse error {
  int i;

  fprintf (fp, "int sh_syntabsiz = %d;\n", SYNSIZE);
  fprintf (fp, "int sh_syntaxtab[%d] = {\n", SYNSIZE);

  for (i = 0; i < SYNSIZE; i++)
    {
      putc ('\t', fp);
      dump_lflags (fp, i);
      putc (',', fp);
      wcomment (fp, i);
      putc ('\n', fp);
    }

  fprintf (fp, "};\n");
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\mksyntax.c:295
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\mksyntax.c:314
parsing error 
{
  int opt, i;
  char *filename;
  FILE *fp;

  if ((progname = strrchr (argv[0], '/')) == 0)
    progname = argv[0];
  else
    progname++;

  filename = (char *)NULL;
  debug = 0;

  while ((opt = getopt (argc, argv, "do:")) != EOF)
    {
      switch (opt)
	{
	case 'd':
	  debug = 1;
	  break;
	case 'o':
	  filename = optarg;
	  break;
	default:
	  usage();
	}
    }

  argc -= optind;
  argv += optind;

  if (filename)
    {
      fp = fopen (filename, "w");
      if (fp == 0)
	{
	  fprintf (stderr, "%s: %s: cannot open: %s\n", progname, filename, strerror(errno));
	  exit (1);
	}
    }
  else
    {
      filename = "stdout";
      fp = stdout;
    }


  for (i = 0; i < SYNSIZE; i++)
    lsyntax[i] = CWORD;

  load_lsyntax ();

  fprintf (fp, "%s\n", preamble);
  fprintf (fp, "%s\n", includes);

  dump_lsyntax (fp);

  if (fp != stdout)
    fclose (fp);
  exit (0);
}
warning: parse error {
  int opt, i;
  char *filename;
  FILE *fp;

  if ((progname = strrchr (argv[0], '/')) == 0)
    progname = argv[0];
  else
    progname++;

  filename = (char *)NULL;
  debug = 0;

  while ((opt = getopt (argc, argv, "do:")) != EOF)
    {
      switch (opt)
	{
	case 'd':
	  debug = 1;
	  break;
	case 'o':
	  filename = optarg;
	  break;
	default:
	  usage();
	}
    }

  argc -= optind;
  argv += optind;

  if (filename)
    {
      fp = fopen (filename, "w");
      if (fp == 0)
	{
	  fprintf (stderr, "%s: %s: cannot open: %s\n", progname, filename, strerror(errno));
	  exit (1);
	}
    }
  else
    {
      filename = "stdout";
      fp = stdout;
    }


  for (i = 0; i < SYNSIZE; i++)
    lsyntax[i] = CWORD;

  load_lsyntax ();

  fprintf (fp, "%s\n", preamble);
  fprintf (fp, "%s\n", includes);

  dump_lsyntax (fp);

  if (fp != stdout)
    fclose (fp);
  exit (0);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\mksyntax.c:317
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\mksyntax.c:398
parsing error 
{
  static char emsg[40];
#if defined (HAVE_SYS_ERRLIST)
  extern int sys_nerr;
  extern char *sys_errlist[];

  if (e > 0 && e < sys_nerr)
    return (sys_errlist[e]);
  else
#endif /* HAVE_SYS_ERRLIST */
    {
      sprintf (emsg, "Unknown system error %d", e);
      return (&emsg[0]);
    }
}
warning: parse error {
  static char emsg[40];
#if defined (HAVE_SYS_ERRLIST)
  extern int sys_nerr;
  extern char *sys_errlist[];

  if (e > 0 && e < sys_nerr)
    return (sys_errlist[e]);
  else
#endif /* HAVE_SYS_ERRLIST */
    {
      sprintf (emsg, "Unknown system error %d", e);
      return (&emsg[0]);
    }
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\mksyntax.c:400
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\nojobs.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashtypes.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\filecntl.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\shtty.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashintl.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\shell.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\jobs.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\execute_cmd.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\trap.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\common.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\nojobs.c:172
parsing error 
{
  register int i;

  for (i = 0; i < pid_list_size; i++)
    if (pid_list[i].pid == NO_PID || pid_list[i].pid == pid)
      return (i);

  if (i == pid_list_size)
    alloc_pid_list ();

  return (i);
}
warning: parse error {
  register int i;

  for (i = 0; i < pid_list_size; i++)
    if (pid_list[i].pid == NO_PID || pid_list[i].pid == pid)
      return (i);

  if (i == pid_list_size)
    alloc_pid_list ();

  return (i);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\nojobs.c:174
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\nojobs.c:190
parsing error 
{
  register int i;

  for (i = 0; i < pid_list_size; i++)
    if (pid_list[i].pid == pid)
      return (i);

  return (NO_PID);
}
warning: parse error {
  register int i;

  for (i = 0; i < pid_list_size; i++)
    if (pid_list[i].pid == pid)
      return (i);

  return (NO_PID);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\nojobs.c:192
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\nojobs.c:205
parsing error 
{
  int i;

  i = find_index_by_pid (pid);
  if (i == NO_PID)
    return (PROC_BAD);
  if (pid_list[i].flags & PROC_RUNNING)
    return (PROC_STILL_ALIVE);
  return (pid_list[i].status);
}
warning: parse error {
  int i;

  i = find_index_by_pid (pid);
  if (i == NO_PID)
    return (PROC_BAD);
  if (pid_list[i].flags & PROC_RUNNING)
    return (PROC_STILL_ALIVE);
  return (pid_list[i].status);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\nojobs.c:207
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\nojobs.c:219
parsing error 
{
  if (WIFSIGNALED (status))
    return (128 + WTERMSIG (status));
  else
    return (WEXITSTATUS (status));
}
warning: parse error {
  if (WIFSIGNALED (status))
    return (128 + WTERMSIG (status));
  else
    return (WEXITSTATUS (status));
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\nojobs.c:221
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\nojobs.c:231
parsing error 
{
  int i;

  i = find_index_by_pid (pid);
  if (i == NO_PID)
    return (0);
  if (pid_list[i].flags & PROC_RUNNING)
    return (0);
  return (get_termsig ((WAIT)pid_list[i].status));
}
warning: parse error {
  int i;

  i = find_index_by_pid (pid);
  if (i == NO_PID)
    return (0);
  if (pid_list[i].flags & PROC_RUNNING)
    return (0);
  return (get_termsig ((WAIT)pid_list[i].status));
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\nojobs.c:233
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\nojobs.c:248
parsing error 
{
  if (WIFSTOPPED (status) == 0 && WIFSIGNALED (status))
    return (WTERMSIG (status));
  else
    return (0);
}
warning: parse error {
  if (WIFSTOPPED (status) == 0 && WIFSIGNALED (status))
    return (WTERMSIG (status));
  else
    return (0);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\nojobs.c:250
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\nojobs.c:259
parsing error 
{
  int slot;

#if defined (COPROCESS_SUPPORT)
  coproc_pidchk (pid, status);
#endif

#if defined (PROCESS_SUBSTITUTION)
  if ((slot = find_procsub_child (pid)) >= 0)
    set_procsub_status (slot, pid, WSTATUS (status));
    /* XXX - also saving in list below */
#endif

  slot = find_index_by_pid (pid);
  if (slot == NO_PID)
    return;

  pid_list[slot].status = process_exit_status (status);
  pid_list[slot].flags &= ~PROC_RUNNING;
  if (WIFSIGNALED (status))
    pid_list[slot].flags |= PROC_SIGNALED;
  /* If it's not a background process, mark it as notified so it gets
     cleaned up. */
  if ((pid_list[slot].flags & PROC_ASYNC) == 0)
    pid_list[slot].flags |= PROC_NOTIFIED;
}
warning: parse error {
  int slot;

#if defined (COPROCESS_SUPPORT)
  coproc_pidchk (pid, status);
#endif

#if defined (PROCESS_SUBSTITUTION)
  if ((slot = find_procsub_child (pid)) >= 0)
    set_procsub_status (slot, pid, WSTATUS (status));
    /* XXX - also saving in list below */
#endif

  slot = find_index_by_pid (pid);
  if (slot == NO_PID)
    return;

  pid_list[slot].status = process_exit_status (status);
  pid_list[slot].flags &= ~PROC_RUNNING;
  if (WIFSIGNALED (status))
    pid_list[slot].flags |= PROC_SIGNALED;
  /* If it's not a background process, mark it as notified so it gets
     cleaned up. */
  if ((pid_list[slot].flags & PROC_ASYNC) == 0)
    pid_list[slot].flags |= PROC_NOTIFIED;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\nojobs.c:262
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\nojobs.c:291
parsing error 
{
  int slot;

  slot = find_index_by_pid (pid);
  if (slot == NO_PID)
    return;

  pid_list[slot].flags |= flags;
}
warning: parse error {
  int slot;

  slot = find_index_by_pid (pid);
  if (slot == NO_PID)
    return;

  pid_list[slot].flags |= flags;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\nojobs.c:294
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\nojobs.c:306
parsing error 
{
  int slot;

  slot = find_index_by_pid (pid);
  if (slot == NO_PID)
    return;

  pid_list[slot].flags &= ~flags;
}
warning: parse error {
  int slot;

  slot = find_index_by_pid (pid);
  if (slot == NO_PID)
    return;

  pid_list[slot].flags &= ~flags;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\nojobs.c:309
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\nojobs.c:321
parsing error 
{
  int slot;

  slot = find_index_by_pid (pid);
  if (slot == NO_PID)
    return 0;

  return (pid_list[slot].flags);
}
warning: parse error {
  int slot;

  slot = find_index_by_pid (pid);
  if (slot == NO_PID)
    return 0;

  return (pid_list[slot].flags);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\nojobs.c:323
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\nojobs.c:334
parsing error 
{
  int slot;

  slot = find_proc_slot (pid);

  pid_list[slot].pid = pid;
  pid_list[slot].status = -1;
  pid_list[slot].flags = PROC_RUNNING;
  if (async)
    pid_list[slot].flags |= PROC_ASYNC;
}
warning: parse error {
  int slot;

  slot = find_proc_slot (pid);

  pid_list[slot].pid = pid;
  pid_list[slot].status = -1;
  pid_list[slot].flags = PROC_RUNNING;
  if (async)
    pid_list[slot].flags |= PROC_ASYNC;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\nojobs.c:337
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\nojobs.c:350
parsing error 
{
  register int i, ndead;

  /* first, count the number of non-running async jobs if FORCE == 0 */
  for (i = ndead = 0; force == 0 && i < pid_list_size; i++)
    {
      if (pid_list[i].pid == NO_PID)
	continue;
      if (((pid_list[i].flags & PROC_RUNNING) == 0) &&
	   (pid_list[i].flags & PROC_ASYNC))
	ndead++;
    }

  if (child_max < 0)
    child_max = getmaxchild ();
  if (child_max < 0)
    child_max = DEFAULT_CHILD_MAX;

  if (force == 0 && ndead <= child_max)
    return;

  /* If FORCE == 0, we just mark as many non-running async jobs as notified
     to bring us under the CHILD_MAX limit. */
  for (i = 0; i < pid_list_size; i++)
    {
      if (pid_list[i].pid == NO_PID)
	continue;
      if (((pid_list[i].flags & PROC_RUNNING) == 0) &&
	   pid_list[i].pid != last_asynchronous_pid)
	{
	  pid_list[i].flags |= PROC_NOTIFIED;
	  if (force == 0 && (pid_list[i].flags & PROC_ASYNC) && --ndead <= child_max)
	    break;
	}
    }
}
warning: parse error {
  register int i, ndead;

  /* first, count the number of non-running async jobs if FORCE == 0 */
  for (i = ndead = 0; force == 0 && i < pid_list_size; i++)
    {
      if (pid_list[i].pid == NO_PID)
	continue;
      if (((pid_list[i].flags & PROC_RUNNING) == 0) &&
	   (pid_list[i].flags & PROC_ASYNC))
	ndead++;
    }

  if (child_max < 0)
    child_max = getmaxchild ();
  if (child_max < 0)
    child_max = DEFAULT_CHILD_MAX;

  if (force == 0 && ndead <= child_max)
    return;

  /* If FORCE == 0, we just mark as many non-running async jobs as notified
     to bring us under the CHILD_MAX limit. */
  for (i = 0; i < pid_list_size; i++)
    {
      if (pid_list[i].pid == NO_PID)
	continue;
      if (((pid_list[i].flags & PROC_RUNNING) == 0) &&
	   pid_list[i].pid != last_asynchronous_pid)
	{
	  pid_list[i].flags |= PROC_NOTIFIED;
	  if (force == 0 && (pid_list[i].flags & PROC_ASYNC) && --ndead <= child_max)
	    break;
	}
    }
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\nojobs.c:352
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\nojobs.c:423
parsing error 
{
  shell_tty = fileno (stderr);

  if (interactive)
    get_tty_state ();
  return 0;
}
warning: parse error {
  shell_tty = fileno (stderr);

  if (interactive)
    get_tty_state ();
  return 0;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\nojobs.c:425
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\nojobs.c:493
parsing error 
{
  pid_t pid;
  int async_p, forksleep;
  sigset_t set, oset;

  /* Discard saved memory. */
  if (command)
    free (command);

  async_p = (flags & FORK_ASYNC);
  start_pipeline ();

#if defined (BUFFERED_INPUT)
  /* If default_buffered_input is active, we are reading a script.  If
     the command is asynchronous, we have already duplicated /dev/null
     as fd 0, but have not changed the buffered stream corresponding to
     the old fd 0.  We don't want to sync the stream in this case. */
  if (default_buffered_input != -1 && (!async_p || default_buffered_input > 0))
    sync_buffered_stream (default_buffered_input);
#endif /* BUFFERED_INPUT */

  /* Block SIGTERM here and unblock in child after fork resets the
     set of pending signals */
  if (interactive_shell)
    {
      sigemptyset (&set);
      sigaddset (&set, SIGTERM);
      sigemptyset (&oset);
      sigprocmask (SIG_BLOCK, &set, &oset);
      set_signal_handler (SIGTERM, SIG_DFL);
    }

  /* Create the child, handle severe errors.  Retry on EAGAIN. */
  forksleep = 1;
  while ((pid = fork ()) < 0 && errno == EAGAIN && forksleep < FORKSLEEP_MAX)
    {
      sys_error ("fork: retry");

#if defined (HAVE_WAITPID)
      /* Posix systems with a non-blocking waitpid () system call available
	 get another chance after zombies are reaped. */
      reap_zombie_children ();
      if (forksleep > 1 && sleep (forksleep) != 0)
        break;
#else
      if (sleep (forksleep) != 0)
	break;
#endif /* HAVE_WAITPID */
      forksleep <<= 1;
    }

  if (pid != 0)
    if (interactive_shell)
      {
	set_signal_handler (SIGTERM, SIG_IGN);
	sigprocmask (SIG_SETMASK, &oset, (sigset_t *)NULL);
      }

  if (pid < 0)
    {
      sys_error ("fork");
      last_command_exit_value = EX_NOEXEC;
      throw_to_top_level ();
    }

  if (pid == 0)
    {
#if defined (BUFFERED_INPUT)
      unset_bash_input (0);
#endif /* BUFFERED_INPUT */

      CLRINTERRUPT;	/* XXX - children have their own interrupt state */

      /* Restore top-level signal mask. */
      restore_sigmask ();

#if 0
      /* Ignore INT and QUIT in asynchronous children. */
      if (async_p)
	last_asynchronous_pid = getpid ();
#endif

      default_tty_job_signals ();
    }
  else
    {
      /* In the parent. */

      last_made_pid = pid;

      if (async_p)
	last_asynchronous_pid = pid;

      add_pid (pid, async_p);
    }
  return (pid);
}
warning: parse error {
  pid_t pid;
  int async_p, forksleep;
  sigset_t set, oset;

  /* Discard saved memory. */
  if (command)
    free (command);

  async_p = (flags & FORK_ASYNC);
  start_pipeline ();

#if defined (BUFFERED_INPUT)
  /* If default_buffered_input is active, we are reading a script.  If
     the command is asynchronous, we have already duplicated /dev/null
     as fd 0, but have not changed the buffered stream corresponding to
     the old fd 0.  We don't want to sync the stream in this case. */
  if (default_buffered_input != -1 && (!async_p || default_buffered_input > 0))
    sync_buffered_stream (default_buffered_input);
#endif /* BUFFERED_INPUT */

  /* Block SIGTERM here and unblock in child after fork resets the
     set of pending signals */
  if (interactive_shell)
    {
      sigemptyset (&set);
      sigaddset (&set, SIGTERM);
      sigemptyset (&oset);
      sigprocmask (SIG_BLOCK, &set, &oset);
      set_signal_handler (SIGTERM, SIG_DFL);
    }

  /* Create the child, handle severe errors.  Retry on EAGAIN. */
  forksleep = 1;
  while ((pid = fork ()) < 0 && errno == EAGAIN && forksleep < FORKSLEEP_MAX)
    {
      sys_error ("fork: retry");

#if defined (HAVE_WAITPID)
      /* Posix systems with a non-blocking waitpid () system call available
	 get another chance after zombies are reaped. */
      reap_zombie_children ();
      if (forksleep > 1 && sleep (forksleep) != 0)
        break;
#else
      if (sleep (forksleep) != 0)
	break;
#endif /* HAVE_WAITPID */
      forksleep <<= 1;
    }

  if (pid != 0)
    if (interactive_shell)
      {
	set_signal_handler (SIGTERM, SIG_IGN);
	sigprocmask (SIG_SETMASK, &oset, (sigset_t *)NULL);
      }

  if (pid < 0)
    {
      sys_error ("fork");
      last_command_exit_value = EX_NOEXEC;
      throw_to_top_level ();
    }

  if (pid == 0)
    {
#if defined (BUFFERED_INPUT)
      unset_bash_input (0);
#endif /* BUFFERED_INPUT */

      CLRINTERRUPT;	/* XXX - children have their own interrupt state */

      /* Restore top-level signal mask. */
      restore_sigmask ();

#if 0
      /* Ignore INT and QUIT in asynchronous children. */
      if (async_p)
	last_asynchronous_pid = getpid ();
#endif

      default_tty_job_signals ();
    }
  else
    {
      /* In the parent. */

      last_made_pid = pid;

      if (async_p)
	last_asynchronous_pid = pid;

      add_pid (pid, async_p);
    }
  return (pid);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\nojobs.c:496
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\nojobs.c:652
parsing error 
{
  pid_t got_pid;
  WAIT status;
  int pstatus;

  pstatus = find_status_by_pid (pid);

  if (pstatus == PROC_BAD)
    {
      internal_error (_("wait: pid %ld is not a child of this shell"), (long)pid);
      return (127);
    }

  if (pstatus != PROC_STILL_ALIVE)
    {
      if (pstatus > 128)
	last_command_exit_signal = find_termsig_by_pid (pid);
      return (pstatus);
    }

  siginterrupt (SIGINT, 1);
  while ((got_pid = WAITPID (pid, &status, 0)) != pid)
    {
      CHECK_TERMSIG;
      CHECK_WAIT_INTR;
      if (got_pid < 0)
	{
	  if (errno != EINTR && errno != ECHILD)
	    {
	      siginterrupt (SIGINT, 0);
	      sys_error ("wait");
	    }
	  break;
	}
      else if (got_pid > 0)
	set_pid_status (got_pid, status);
    }

  if (got_pid > 0)
    {
      set_pid_status (got_pid, status);
      set_pid_flags (got_pid, PROC_NOTIFIED);
    }

  siginterrupt (SIGINT, 0);
  QUIT;
  CHECK_WAIT_INTR;

  return (got_pid > 0 ? process_exit_status (status) : -1);
}
warning: parse error {
  pid_t got_pid;
  WAIT status;
  int pstatus;

  pstatus = find_status_by_pid (pid);

  if (pstatus == PROC_BAD)
    {
      internal_error (_("wait: pid %ld is not a child of this shell"), (long)pid);
      return (127);
    }

  if (pstatus != PROC_STILL_ALIVE)
    {
      if (pstatus > 128)
	last_command_exit_signal = find_termsig_by_pid (pid);
      return (pstatus);
    }

  siginterrupt (SIGINT, 1);
  while ((got_pid = WAITPID (pid, &status, 0)) != pid)
    {
      CHECK_TERMSIG;
      CHECK_WAIT_INTR;
      if (got_pid < 0)
	{
	  if (errno != EINTR && errno != ECHILD)
	    {
	      siginterrupt (SIGINT, 0);
	      sys_error ("wait");
	    }
	  break;
	}
      else if (got_pid > 0)
	set_pid_status (got_pid, status);
    }

  if (got_pid > 0)
    {
      set_pid_status (got_pid, status);
      set_pid_flags (got_pid, PROC_NOTIFIED);
    }

  siginterrupt (SIGINT, 0);
  QUIT;
  CHECK_WAIT_INTR;

  return (got_pid > 0 ? process_exit_status (status) : -1);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\nojobs.c:655
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\nojobs.c:709
parsing error 
{
  pid_t got_pid;
  WAIT status;

  /* If we aren't using job control, we let the kernel take care of the
     bookkeeping for us.  wait () will return -1 and set errno to ECHILD
     when there are no more unwaited-for child processes on both
     4.2 BSD-based and System V-based systems. */

  siginterrupt (SIGINT, 1);

  /* Wait for ECHILD */
  waiting_for_child = 1;
  while ((got_pid = WAITPID (-1, &status, 0)) != -1)
    {
      waiting_for_child = 0;
      set_pid_status (got_pid, status);
      if (ps)
	{
	  ps->pid = got_pid;
	  ps->status = process_exit_status (status);
	}
      waiting_for_child = 1;
      CHECK_WAIT_INTR;
    }
  waiting_for_child = 0;

  if (errno != EINTR && errno != ECHILD)
    {
      siginterrupt (SIGINT, 0);
      sys_error("wait");
    }

  siginterrupt (SIGINT, 0);
  QUIT;
  CHECK_WAIT_INTR;

  mark_dead_jobs_as_notified (1);
  cleanup_dead_jobs ();
}
warning: parse error {
  pid_t got_pid;
  WAIT status;

  /* If we aren't using job control, we let the kernel take care of the
     bookkeeping for us.  wait () will return -1 and set errno to ECHILD
     when there are no more unwaited-for child processes on both
     4.2 BSD-based and System V-based systems. */

  siginterrupt (SIGINT, 1);

  /* Wait for ECHILD */
  waiting_for_child = 1;
  while ((got_pid = WAITPID (-1, &status, 0)) != -1)
    {
      waiting_for_child = 0;
      set_pid_status (got_pid, status);
      if (ps)
	{
	  ps->pid = got_pid;
	  ps->status = process_exit_status (status);
	}
      waiting_for_child = 1;
      CHECK_WAIT_INTR;
    }
  waiting_for_child = 0;

  if (errno != EINTR && errno != ECHILD)
    {
      siginterrupt (SIGINT, 0);
      sys_error("wait");
    }

  siginterrupt (SIGINT, 0);
  QUIT;
  CHECK_WAIT_INTR;

  mark_dead_jobs_as_notified (1);
  cleanup_dead_jobs ();
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\nojobs.c:711
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\nojobs.c:775
parsing error 
{
  SigHandler *sigint_handler;

  /* If we got a SIGINT while in `wait', and SIGINT is trapped, do
     what POSIX.2 says (see builtins/wait.def for more info). */
  if (this_shell_builtin && this_shell_builtin == wait_builtin &&
      signal_is_trapped (SIGINT) &&
      ((sigint_handler = trap_to_sighandler (SIGINT)) == trap_handler))
    {
      last_command_exit_value = 128+SIGINT;
      restore_sigint_handler ();
      trap_handler (SIGINT);	/* set pending_traps[SIGINT] */
      wait_signal_received = SIGINT;
      SIGRETURN (0);
    }

  wait_sigint_received = 1;

  SIGRETURN (0);
}
warning: parse error {
  SigHandler *sigint_handler;

  /* If we got a SIGINT while in `wait', and SIGINT is trapped, do
     what POSIX.2 says (see builtins/wait.def for more info). */
  if (this_shell_builtin && this_shell_builtin == wait_builtin &&
      signal_is_trapped (SIGINT) &&
      ((sigint_handler = trap_to_sighandler (SIGINT)) == trap_handler))
    {
      last_command_exit_value = 128+SIGINT;
      restore_sigint_handler ();
      trap_handler (SIGINT);	/* set pending_traps[SIGINT] */
      wait_signal_received = SIGINT;
      SIGRETURN (0);
    }

  wait_sigint_received = 1;

  SIGRETURN (0);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\nojobs.c:777
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\nojobs.c:799
parsing error 
{
  static char retcode_name_buffer[64] = { '\0' };
  char *x;

  x = strsignal (s);
  if (x == 0)
    {
      x = retcode_name_buffer;
      sprintf (x, "Signal %d", s);
    }
  return x;
}
warning: parse error {
  static char retcode_name_buffer[64] = { '\0' };
  char *x;

  x = strsignal (s);
  if (x == 0)
    {
      x = retcode_name_buffer;
      sprintf (x, "Signal %d", s);
    }
  return x;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\nojobs.c:801
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\nojobs.c:817
parsing error 
{
  int return_val, pstatus;
  pid_t got_pid;
  WAIT status;

  pstatus = find_status_by_pid (pid);

  if (pstatus == PROC_BAD)
    return (0);

  if (pstatus != PROC_STILL_ALIVE)
    {
      if (pstatus > 128)
	last_command_exit_signal = find_termsig_by_pid (pid);
      return (pstatus);
    }

  /* If we are running a script, ignore SIGINT while we're waiting for
     a child to exit.  The loop below does some of this, but not all. */
  wait_sigint_received = 0;
  if (interactive_shell == 0)
    old_sigint_handler = set_signal_handler (SIGINT, wait_sigint_handler);

  waiting_for_child = 1;  
  CHECK_WAIT_INTR;
  while ((got_pid = WAITPID (-1, &status, 0)) != pid) /* XXX was pid now -1 */
    {
      waiting_for_child = 0;
      CHECK_TERMSIG;
      CHECK_WAIT_INTR;
      if (got_pid < 0 && errno == ECHILD)
	{
#if !defined (_POSIX_VERSION)
	  status.w_termsig = status.w_retcode = 0;
#else
	  status = 0;
#endif /* _POSIX_VERSION */
	  break;
	}
      else if (got_pid < 0 && errno != EINTR)
	programming_error ("wait_for(%ld): %s", (long)pid, strerror(errno));
      else if (got_pid > 0)
	set_pid_status (got_pid, status);
      waiting_for_child = 1;
    }
  waiting_for_child = 0;

  if (got_pid > 0)
    set_pid_status (got_pid, status);

#if defined (HAVE_WAITPID)
  if (got_pid >= 0)
    reap_zombie_children ();
#endif /* HAVE_WAITPID */

  CHECK_TERMSIG;
  CHECK_WAIT_INTR;

  if (interactive_shell == 0)
    {
      SigHandler *temp_handler;

      temp_handler = old_sigint_handler;
      restore_sigint_handler ();

      /* If the job exited because of SIGINT, make sure the shell acts as if
	 it had received one also. */
      if (WIFSIGNALED (status) && (WTERMSIG (status) == SIGINT))
	{

	  if (maybe_call_trap_handler (SIGINT) == 0)
	    {
	      if (temp_handler == SIG_DFL)
		termsig_handler (SIGINT);
	      else if (temp_handler != INVALID_SIGNAL_HANDLER && temp_handler != SIG_IGN)
		(*temp_handler) (SIGINT);
	    }
	}
    }

  /* Default return value. */
  /* ``a full 8 bits of status is returned'' */
  return_val = process_exit_status (status);
  last_command_exit_signal = get_termsig (status);

#if defined (DONT_REPORT_SIGPIPE) && defined (DONT_REPORT_SIGTERM)
#  define REPORTSIG(x) ((x) != SIGINT && (x) != SIGPIPE && (x) != SIGTERM)
#elif !defined (DONT_REPORT_SIGPIPE) && !defined (DONT_REPORT_SIGTERM)
#  define REPORTSIG(x) ((x) != SIGINT)
#elif defined (DONT_REPORT_SIGPIPE)
#  define REPORTSIG(x) ((x) != SIGINT && (x) != SIGPIPE)
#else
#  define REPORTSIG(x) ((x) != SIGINT && (x) != SIGTERM)
#endif

  if ((WIFSTOPPED (status) == 0) && WIFSIGNALED (status) && REPORTSIG(WTERMSIG (status)))
    {
      fprintf (stderr, "%s", j_strsignal (WTERMSIG (status)));
      if (WIFCORED (status))
	fprintf (stderr, _(" (core dumped)"));
      fprintf (stderr, "\n");
    }

  if (interactive_shell && subshell_environment == 0)
    {
      if (WIFSIGNALED (status) || WIFSTOPPED (status))
	set_tty_state ();
      else
	get_tty_state ();
    }
  else if (interactive_shell == 0 && subshell_environment == 0 && check_window_size)
    get_new_window_size (0, (int *)0, (int *)0);

  return (return_val);
}
warning: parse error {
  int return_val, pstatus;
  pid_t got_pid;
  WAIT status;

  pstatus = find_status_by_pid (pid);

  if (pstatus == PROC_BAD)
    return (0);

  if (pstatus != PROC_STILL_ALIVE)
    {
      if (pstatus > 128)
	last_command_exit_signal = find_termsig_by_pid (pid);
      return (pstatus);
    }

  /* If we are running a script, ignore SIGINT while we're waiting for
     a child to exit.  The loop below does some of this, but not all. */
  wait_sigint_received = 0;
  if (interactive_shell == 0)
    old_sigint_handler = set_signal_handler (SIGINT, wait_sigint_handler);

  waiting_for_child = 1;  
  CHECK_WAIT_INTR;
  while ((got_pid = WAITPID (-1, &status, 0)) != pid) /* XXX was pid now -1 */
    {
      waiting_for_child = 0;
      CHECK_TERMSIG;
      CHECK_WAIT_INTR;
      if (got_pid < 0 && errno == ECHILD)
	{
#if !defined (_POSIX_VERSION)
	  status.w_termsig = status.w_retcode = 0;
#else
	  status = 0;
#endif /* _POSIX_VERSION */
	  break;
	}
      else if (got_pid < 0 && errno != EINTR)
	programming_error ("wait_for(%ld): %s", (long)pid, strerror(errno));
      else if (got_pid > 0)
	set_pid_status (got_pid, status);
      waiting_for_child = 1;
    }
  waiting_for_child = 0;

  if (got_pid > 0)
    set_pid_status (got_pid, status);

#if defined (HAVE_WAITPID)
  if (got_pid >= 0)
    reap_zombie_children ();
#endif /* HAVE_WAITPID */

  CHECK_TERMSIG;
  CHECK_WAIT_INTR;

  if (interactive_shell == 0)
    {
      SigHandler *temp_handler;

      temp_handler = old_sigint_handler;
      restore_sigint_handler ();

      /* If the job exited because of SIGINT, make sure the shell acts as if
	 it had received one also. */
      if (WIFSIGNALED (status) && (WTERMSIG (status) == SIGINT))
	{

	  if (maybe_call_trap_handler (SIGINT) == 0)
	    {
	      if (temp_handler == SIG_DFL)
		termsig_handler (SIGINT);
	      else if (temp_handler != INVALID_SIGNAL_HANDLER && temp_handler != SIG_IGN)
		(*temp_handler) (SIGINT);
	    }
	}
    }

  /* Default return value. */
  /* ``a full 8 bits of status is returned'' */
  return_val = process_exit_status (status);
  last_command_exit_signal = get_termsig (status);

#if defined (DONT_REPORT_SIGPIPE) && defined (DONT_REPORT_SIGTERM)
#  define REPORTSIG(x) ((x) != SIGINT && (x) != SIGPIPE && (x) != SIGTERM)
#elif !defined (DONT_REPORT_SIGPIPE) && !defined (DONT_REPORT_SIGTERM)
#  define REPORTSIG(x) ((x) != SIGINT)
#elif defined (DONT_REPORT_SIGPIPE)
#  define REPORTSIG(x) ((x) != SIGINT && (x) != SIGPIPE)
#else
#  define REPORTSIG(x) ((x) != SIGINT && (x) != SIGTERM)
#endif

  if ((WIFSTOPPED (status) == 0) && WIFSIGNALED (status) && REPORTSIG(WTERMSIG (status)))
    {
      fprintf (stderr, "%s", j_strsignal (WTERMSIG (status)));
      if (WIFCORED (status))
	fprintf (stderr, _(" (core dumped)"));
      fprintf (stderr, "\n");
    }

  if (interactive_shell && subshell_environment == 0)
    {
      if (WIFSIGNALED (status) || WIFSTOPPED (status))
	set_tty_state ();
      else
	get_tty_state ();
    }
  else if (interactive_shell == 0 && subshell_environment == 0 && check_window_size)
    get_new_window_size (0, (int *)0, (int *)0);

  return (return_val);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\nojobs.c:820
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\nojobs.c:939
parsing error 
{
  int result;

  if (pid < -1)
    {
      pid = -pid;
      group = 1;
    }
  result = group ? killpg (pid, signal) : kill (pid, signal);
  return (result);
}
warning: parse error {
  int result;

  if (pid < -1)
    {
      pid = -pid;
      group = 1;
    }
  result = group ? killpg (pid, signal) : kill (pid, signal);
  return (result);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\nojobs.c:942
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\nojobs.c:992
parsing error 
{
  return 0;
}
warning: parse error {
  return 0;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\nojobs.c:995
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\nojobs.c:1,001
parsing error 
{
  already_making_children = 0;
  return 0;
}
warning: parse error {
  already_making_children = 0;
  return 0;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\nojobs.c:1,004
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\nojobs.c:1,030
parsing error 
{
  int i;

  i = find_index_by_pid (pid);
  return ((i == NO_PID) ? PROC_BAD : i);
}
warning: parse error {
  int i;

  i = find_index_by_pid (pid);
  return ((i == NO_PID) ? PROC_BAD : i);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\nojobs.c:1,034
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\nojobs.c:1,043
parsing error 
{
  fprintf (stderr, "%ld\n", (long) pid);
}
warning: parse error {
  fprintf (stderr, "%ld\n", (long) pid);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\nojobs.c:1,045
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\nojobs.c:1,061
parsing error 
{
}
warning: parse error {
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\nojobs.c:1,063
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\pathexp.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashtypes.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashansi.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\shell.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\pathexp.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\flags.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\shmbutil.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashintl.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\glob\strmatch.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\pathexp.c:66
parsing error 
{
  register int c;
  char *send;
  int open, bsquote;

  DECLARE_MBSTATE;

  open = bsquote = 0;
  send = string + strlen (string);

  while (c = *string++)
    {
      switch (c)
	{
	case '?':
	case '*':
	  return (1);

	case '[':
	  open++;
	  continue;

	case ']':
	  if (open)		/* XXX - if --open == 0? */
	    return (1);
	  continue;

	case '/':
	  if (open)
	    open = 0;

	case '+':
	case '@':
	case '!':
	  if (*string == '(')	/*)*/
	    return (1);
	  continue;

	/* A pattern can't end with a backslash, but a backslash in the pattern
	   can be special to the matching engine, so we note it in case we
	   need it later. */
	case '\\':
	  if (*string != '\0' && *string != '/')
	    {
	      bsquote = 1;
	      string++;
	      continue;
	    }
	  else if (open && *string == '/')
	    {
	      string++;		/* quoted slashes in bracket expressions are ok */
	      continue;
	    }
	  else if (*string == 0)
	    return (0);
	 	  
	case CTLESC:
	  if (*string++ == '\0')
	    return (0);
	}

      /* Advance one fewer byte than an entire multibyte character to
	 account for the auto-increment in the loop above. */
#ifdef HANDLE_MULTIBYTE
      string--;
      ADVANCE_CHAR_P (string, send - string);
      string++;
#else
      ADVANCE_CHAR_P (string, send - string);
#endif
    }

#if 0
  return (bsquote ? 2 : 0);
#else
  return (0);
#endif
}
warning: parse error {
  register int c;
  char *send;
  int open, bsquote;

  DECLARE_MBSTATE;

  open = bsquote = 0;
  send = string + strlen (string);

  while (c = *string++)
    {
      switch (c)
	{
	case '?':
	case '*':
	  return (1);

	case '[':
	  open++;
	  continue;

	case ']':
	  if (open)		/* XXX - if --open == 0? */
	    return (1);
	  continue;

	case '/':
	  if (open)
	    open = 0;

	case '+':
	case '@':
	case '!':
	  if (*string == '(')	/*)*/
	    return (1);
	  continue;

	/* A pattern can't end with a backslash, but a backslash in the pattern
	   can be special to the matching engine, so we note it in case we
	   need it later. */
	case '\\':
	  if (*string != '\0' && *string != '/')
	    {
	      bsquote = 1;
	      string++;
	      continue;
	    }
	  else if (open && *string == '/')
	    {
	      string++;		/* quoted slashes in bracket expressions are ok */
	      continue;
	    }
	  else if (*string == 0)
	    return (0);
	 	  
	case CTLESC:
	  if (*string++ == '\0')
	    return (0);
	}

      /* Advance one fewer byte than an entire multibyte character to
	 account for the auto-increment in the loop above. */
#ifdef HANDLE_MULTIBYTE
      string--;
      ADVANCE_CHAR_P (string, send - string);
      string++;
#else
      ADVANCE_CHAR_P (string, send - string);
#endif
    }

#if 0
  return (bsquote ? 2 : 0);
#else
  return (0);
#endif
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\pathexp.c:68
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\pathexp.c:150
parsing error 
{
  switch (c)
    {
    case '.':
    case '[':
    case '\\':
    case '(':
    case ')':
    case '*':
    case '+':
    case '?':
    case '{':
    case '|':
    case '^':
    case '$':
      return 1;
    default: 
      return 0;
    }
  return (0);
}
warning: parse error {
  switch (c)
    {
    case '.':
    case '[':
    case '\\':
    case '(':
    case ')':
    case '*':
    case '+':
    case '?':
    case '{':
    case '|':
    case '^':
    case '$':
      return 1;
    default: 
      return 0;
    }
  return (0);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\pathexp.c:152
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\pathexp.c:176
parsing error 
{
  switch (*s)
    {
    case '*':
    case '[':
    case ']':
    case '?':
    case '\\':
      return 1;
    case '+':
    case '@':
    case '!':
      if (s[1] == '(')	/*(*/
	return 1;
      break;
    }
  return 0;
}
warning: parse error {
  switch (*s)
    {
    case '*':
    case '[':
    case ']':
    case '?':
    case '\\':
      return 1;
    case '+':
    case '@':
    case '!':
      if (s[1] == '(')	/*(*/
	return 1;
      break;
    }
  return 0;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\pathexp.c:177
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\pathexp.c:211
parsing error 
{
  char *temp;
  register int i, j;
  int cclass, collsym, equiv, c, last_was_backslash;
  int savei, savej;

  temp = (char *)xmalloc (2 * strlen (pathname) + 1);

  if ((qflags & QGLOB_CVTNULL) && QUOTED_NULL (pathname))
    {
      temp[0] = '\0';
      return temp;
    }

  cclass = collsym = equiv = last_was_backslash = 0;
  for (i = j = 0; pathname[i]; i++)
    {
      /* Fix for CTLESC at the end of the string? */
      if (pathname[i] == CTLESC && pathname[i+1] == '\0')
	{
	  temp[j++] = pathname[i++];
	  break;
	}
      /* If we are parsing regexp, turn CTLESC CTLESC into CTLESC. It's not an
	 ERE special character, so we should just be able to pass it through. */
      else if ((qflags & (QGLOB_REGEXP|QGLOB_CTLESC)) && pathname[i] == CTLESC && (pathname[i+1] == CTLESC || pathname[i+1] == CTLNUL))
	{
	  i++;
	  temp[j++] = pathname[i];
	  continue;
	}
      else if (pathname[i] == CTLESC)
	{
convert_to_backslash:
	  if ((qflags & QGLOB_FILENAME) && pathname[i+1] == '/')
	    continue;
	  /* What to do if preceding char is backslash? */
	  if (pathname[i+1] != CTLESC && (qflags & QGLOB_REGEXP) && ere_char (pathname[i+1]) == 0)
	    continue;
	  temp[j++] = '\\';
	  i++;
	  if (pathname[i] == '\0')
	    break;
	}
      else if ((qflags & QGLOB_REGEXP) && (i == 0 || pathname[i-1] != CTLESC) && pathname[i] == '[')	/*]*/
	{
	  temp[j++] = pathname[i++];	/* open bracket */
	  savej = j;
	  savei = i;
	  c = pathname[i++];	/* c == char after open bracket */
	  if (c == '^')		/* ignore pattern negation */
	    {
	      temp[j++] = c;
	      c = pathname[i++];
	    }
	  if (c == ']')		/* ignore right bracket if first char */
	    {
	      temp[j++] = c;
	      c = pathname[i++];
	    }
	  do
	    {
	      if (c == 0)
		goto endpat;
	      else if (c == CTLESC)
		{
		  /* skip c, check for EOS, let assignment at end of loop */
		  /* pathname[i] == backslash-escaped character */
		  if (pathname[i] == 0)
		    goto endpat;
		  temp[j++] = pathname[i++];
		}
	      else if (c == '[' && pathname[i] == ':')
		{
		  temp[j++] = c;
		  temp[j++] = pathname[i++];
		  cclass = 1;
		}
	      else if (cclass && c == ':' && pathname[i] == ']')
		{
		  temp[j++] = c;
		  temp[j++] = pathname[i++];
		  cclass = 0;
		}
	      else if (c == '[' && pathname[i] == '=')
		{
		  temp[j++] = c;
		  temp[j++] = pathname[i++];
		  if (pathname[i] == ']')
		    temp[j++] = pathname[i++];		/* right brack can be in equiv */
		  equiv = 1;
		}
	      else if (equiv && c == '=' && pathname[i] == ']')
		{
		  temp[j++] = c;
		  temp[j++] = pathname[i++];
		  equiv = 0;
		}
	      else if (c == '[' && pathname[i] == '.')
		{
		  temp[j++] = c;
		  temp[j++] = pathname[i++];
		  if (pathname[i] == ']')
		    temp[j++] = pathname[i++];		/* right brack can be in collsym */
		  collsym = 1;
		}
	      else if (collsym && c == '.' && pathname[i] == ']')
		{
		  temp[j++] = c;
		  temp[j++] = pathname[i++];
		  collsym = 0;
		}
	      else
		temp[j++] = c;
	    }
	  while (((c = pathname[i++]) != ']') && c != 0);

	  /* If we don't find the closing bracket before we hit the end of
	     the string, rescan string without treating it as a bracket
	     expression (has implications for backslash and special ERE
	     chars) */
	  if (c == 0)
	    {
	      i = savei - 1;	/* -1 for autoincrement above */
	      j = savej;
	      continue;
	    }

	  temp[j++] = c;	/* closing right bracket */
	  i--;			/* increment will happen above in loop */
	  continue;		/* skip double assignment below */
	}
      else if (pathname[i] == '\\' && (qflags & QGLOB_REGEXP) == 0)
	{
	  /* XXX - if not quoting regexp, use backslash as quote char. Should
	     We just pass it through without treating it as special? That is
	     what ksh93 seems to do. */

	  /* If we want to pass through backslash unaltered, comment out these
	     lines. */
	  temp[j++] = '\\';

	  i++;
	  if (pathname[i] == '\0')
	    break;
	  /* If we are turning CTLESC CTLESC into CTLESC, we need to do that
	     even when the first CTLESC is preceded by a backslash. */
	  if ((qflags & QGLOB_CTLESC) && pathname[i] == CTLESC && (pathname[i+1] == CTLESC || pathname[i+1] == CTLNUL))
	    i++;	/* skip over the CTLESC */
	  else if ((qflags & QGLOB_CTLESC) && pathname[i] == CTLESC)
	    /* A little more general: if there is an unquoted backslash in the
	       pattern and we are handling quoted characters in the pattern,
	       convert the CTLESC to backslash and add the next character on
	       the theory that the backslash will quote the next character
	       but it would be inconsistent not to replace the CTLESC with
	       another backslash here. We can't tell at this point whether the
	       CTLESC comes from a backslash or other form of quoting in the
	       original pattern. */
	    goto convert_to_backslash;
	}
      else if (pathname[i] == '\\' && (qflags & QGLOB_REGEXP))
        last_was_backslash = 1;
      temp[j++] = pathname[i];
    }
endpat:
  temp[j] = '\0';

  return (temp);
}
warning: parse error {
  char *temp;
  register int i, j;
  int cclass, collsym, equiv, c, last_was_backslash;
  int savei, savej;

  temp = (char *)xmalloc (2 * strlen (pathname) + 1);

  if ((qflags & QGLOB_CVTNULL) && QUOTED_NULL (pathname))
    {
      temp[0] = '\0';
      return temp;
    }

  cclass = collsym = equiv = last_was_backslash = 0;
  for (i = j = 0; pathname[i]; i++)
    {
      /* Fix for CTLESC at the end of the string? */
      if (pathname[i] == CTLESC && pathname[i+1] == '\0')
	{
	  temp[j++] = pathname[i++];
	  break;
	}
      /* If we are parsing regexp, turn CTLESC CTLESC into CTLESC. It's not an
	 ERE special character, so we should just be able to pass it through. */
      else if ((qflags & (QGLOB_REGEXP|QGLOB_CTLESC)) && pathname[i] == CTLESC && (pathname[i+1] == CTLESC || pathname[i+1] == CTLNUL))
	{
	  i++;
	  temp[j++] = pathname[i];
	  continue;
	}
      else if (pathname[i] == CTLESC)
	{
convert_to_backslash:
	  if ((qflags & QGLOB_FILENAME) && pathname[i+1] == '/')
	    continue;
	  /* What to do if preceding char is backslash? */
	  if (pathname[i+1] != CTLESC && (qflags & QGLOB_REGEXP) && ere_char (pathname[i+1]) == 0)
	    continue;
	  temp[j++] = '\\';
	  i++;
	  if (pathname[i] == '\0')
	    break;
	}
      else if ((qflags & QGLOB_REGEXP) && (i == 0 || pathname[i-1] != CTLESC) && pathname[i] == '[')	/*]*/
	{
	  temp[j++] = pathname[i++];	/* open bracket */
	  savej = j;
	  savei = i;
	  c = pathname[i++];	/* c == char after open bracket */
	  if (c == '^')		/* ignore pattern negation */
	    {
	      temp[j++] = c;
	      c = pathname[i++];
	    }
	  if (c == ']')		/* ignore right bracket if first char */
	    {
	      temp[j++] = c;
	      c = pathname[i++];
	    }
	  do
	    {
	      if (c == 0)
		goto endpat;
	      else if (c == CTLESC)
		{
		  /* skip c, check for EOS, let assignment at end of loop */
		  /* pathname[i] == backslash-escaped character */
		  if (pathname[i] == 0)
		    goto endpat;
		  temp[j++] = pathname[i++];
		}
	      else if (c == '[' && pathname[i] == ':')
		{
		  temp[j++] = c;
		  temp[j++] = pathname[i++];
		  cclass = 1;
		}
	      else if (cclass && c == ':' && pathname[i] == ']')
		{
		  temp[j++] = c;
		  temp[j++] = pathname[i++];
		  cclass = 0;
		}
	      else if (c == '[' && pathname[i] == '=')
		{
		  temp[j++] = c;
		  temp[j++] = pathname[i++];
		  if (pathname[i] == ']')
		    temp[j++] = pathname[i++];		/* right brack can be in equiv */
		  equiv = 1;
		}
	      else if (equiv && c == '=' && pathname[i] == ']')
		{
		  temp[j++] = c;
		  temp[j++] = pathname[i++];
		  equiv = 0;
		}
	      else if (c == '[' && pathname[i] == '.')
		{
		  temp[j++] = c;
		  temp[j++] = pathname[i++];
		  if (pathname[i] == ']')
		    temp[j++] = pathname[i++];		/* right brack can be in collsym */
		  collsym = 1;
		}
	      else if (collsym && c == '.' && pathname[i] == ']')
		{
		  temp[j++] = c;
		  temp[j++] = pathname[i++];
		  collsym = 0;
		}
	      else
		temp[j++] = c;
	    }
	  while (((c = pathname[i++]) != ']') && c != 0);

	  /* If we don't find the closing bracket before we hit the end of
	     the string, rescan string without treating it as a bracket
	     expression (has implications for backslash and special ERE
	     chars) */
	  if (c == 0)
	    {
	      i = savei - 1;	/* -1 for autoincrement above */
	      j = savej;
	      continue;
	    }

	  temp[j++] = c;	/* closing right bracket */
	  i--;			/* increment will happen above in loop */
	  continue;		/* skip double assignment below */
	}
      else if (pathname[i] == '\\' && (qflags & QGLOB_REGEXP) == 0)
	{
	  /* XXX - if not quoting regexp, use backslash as quote char. Should
	     We just pass it through without treating it as special? That is
	     what ksh93 seems to do. */

	  /* If we want to pass through backslash unaltered, comment out these
	     lines. */
	  temp[j++] = '\\';

	  i++;
	  if (pathname[i] == '\0')
	    break;
	  /* If we are turning CTLESC CTLESC into CTLESC, we need to do that
	     even when the first CTLESC is preceded by a backslash. */
	  if ((qflags & QGLOB_CTLESC) && pathname[i] == CTLESC && (pathname[i+1] == CTLESC || pathname[i+1] == CTLNUL))
	    i++;	/* skip over the CTLESC */
	  else if ((qflags & QGLOB_CTLESC) && pathname[i] == CTLESC)
	    /* A little more general: if there is an unquoted backslash in the
	       pattern and we are handling quoted characters in the pattern,
	       convert the CTLESC to backslash and add the next character on
	       the theory that the backslash will quote the next character
	       but it would be inconsistent not to replace the CTLESC with
	       another backslash here. We can't tell at this point whether the
	       CTLESC comes from a backslash or other form of quoting in the
	       original pattern. */
	    goto convert_to_backslash;
	}
      else if (pathname[i] == '\\' && (qflags & QGLOB_REGEXP))
        last_was_backslash = 1;
      temp[j++] = pathname[i];
    }
endpat:
  temp[j] = '\0';

  return (temp);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\pathexp.c:213
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\pathexp.c:385
parsing error 
{
  size_t slen;
  char *temp, *t;
  const char *s, *send;
  DECLARE_MBSTATE;

  slen = strlen (string);
  send = string + slen;

  temp = (char *)xmalloc (slen * 2 + 1);
  for (t = temp, s = string; *s; )
    {
      if (glob_char_p (s))
	*t++ = '\\';

      /* Copy a single (possibly multibyte) character from s to t,
	 incrementing both. */
      COPY_CHAR_P (t, s, send);
    }
  *t = '\0';
  return temp;
}
warning: parse error {
  size_t slen;
  char *temp, *t;
  const char *s, *send;
  DECLARE_MBSTATE;

  slen = strlen (string);
  send = string + slen;

  temp = (char *)xmalloc (slen * 2 + 1);
  for (t = temp, s = string; *s; )
    {
      if (glob_char_p (s))
	*t++ = '\\';

      /* Copy a single (possibly multibyte) character from s to t,
	 incrementing both. */
      COPY_CHAR_P (t, s, send);
    }
  *t = '\0';
  return temp;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\pathexp.c:386
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\pathexp.c:412
parsing error 
{
#if defined (USE_POSIX_GLOB_LIBRARY)
  register int i;
  char *temp, **results;
  glob_t filenames;
  int glob_flags;

  temp = quote_string_for_globbing (pathname, QGLOB_FILENAME|qflags);

  filenames.gl_offs = 0;

#  if defined (GLOB_PERIOD)
  glob_flags = glob_dot_filenames ? GLOB_PERIOD : 0;
#  else
  glob_flags = 0;
#  endif /* !GLOB_PERIOD */

  glob_flags |= (GLOB_ERR | GLOB_DOOFFS);

  i = glob (temp, glob_flags, (posix_glob_errfunc_t *)NULL, &filenames);

  free (temp);

  if (i == GLOB_NOSPACE || i == GLOB_ABORTED)
    return ((char **)NULL);
  else if (i == GLOB_NOMATCH)
    filenames.gl_pathv = (char **)NULL;
  else if (i != 0)		/* other error codes not in POSIX.2 */
    filenames.gl_pathv = (char **)NULL;

  results = filenames.gl_pathv;

  if (results && ((GLOB_FAILED (results)) == 0))
    {
      if (should_ignore_glob_matches ())
	ignore_glob_matches (results);
      if (results && results[0])
	strvec_sort (results, 1);		/* posix sort */
      else
	{
	  FREE (results);
	  results = (char **)NULL;
	}
    }

  return (results);

#else /* !USE_POSIX_GLOB_LIBRARY */

  char *temp, **results;
  int gflags, quoted_pattern;

  noglob_dot_filenames = glob_dot_filenames == 0;

  temp = quote_string_for_globbing (pathname, QGLOB_FILENAME|qflags);
  gflags = glob_star ? GX_GLOBSTAR : 0;
  results = glob_filename (temp, gflags);
  free (temp);

  if (results && ((GLOB_FAILED (results)) == 0))
    {
      if (should_ignore_glob_matches ())
	ignore_glob_matches (results);
      if (results && results[0])
	strvec_sort (results, 1);		/* posix sort */
      else
	{
	  FREE (results);
	  results = (char **)&glob_error_return;
	}
    }

  return (results);
#endif /* !USE_POSIX_GLOB_LIBRARY */
}
warning: parse error {
#if defined (USE_POSIX_GLOB_LIBRARY)
  register int i;
  char *temp, **results;
  glob_t filenames;
  int glob_flags;

  temp = quote_string_for_globbing (pathname, QGLOB_FILENAME|qflags);

  filenames.gl_offs = 0;

#  if defined (GLOB_PERIOD)
  glob_flags = glob_dot_filenames ? GLOB_PERIOD : 0;
#  else
  glob_flags = 0;
#  endif /* !GLOB_PERIOD */

  glob_flags |= (GLOB_ERR | GLOB_DOOFFS);

  i = glob (temp, glob_flags, (posix_glob_errfunc_t *)NULL, &filenames);

  free (temp);

  if (i == GLOB_NOSPACE || i == GLOB_ABORTED)
    return ((char **)NULL);
  else if (i == GLOB_NOMATCH)
    filenames.gl_pathv = (char **)NULL;
  else if (i != 0)		/* other error codes not in POSIX.2 */
    filenames.gl_pathv = (char **)NULL;

  results = filenames.gl_pathv;

  if (results && ((GLOB_FAILED (results)) == 0))
    {
      if (should_ignore_glob_matches ())
	ignore_glob_matches (results);
      if (results && results[0])
	strvec_sort (results, 1);		/* posix sort */
      else
	{
	  FREE (results);
	  results = (char **)NULL;
	}
    }

  return (results);

#else /* !USE_POSIX_GLOB_LIBRARY */

  char *temp, **results;
  int gflags, quoted_pattern;

  noglob_dot_filenames = glob_dot_filenames == 0;

  temp = quote_string_for_globbing (pathname, QGLOB_FILENAME|qflags);
  gflags = glob_star ? GX_GLOBSTAR : 0;
  results = glob_filename (temp, gflags);
  free (temp);

  if (results && ((GLOB_FAILED (results)) == 0))
    {
      if (should_ignore_glob_matches ())
	ignore_glob_matches (results);
      if (results && results[0])
	strvec_sort (results, 1);		/* posix sort */
      else
	{
	  FREE (results);
	  results = (char **)&glob_error_return;
	}
    }

  return (results);
#endif /* !USE_POSIX_GLOB_LIBRARY */
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\pathexp.c:414
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\pathexp.c:505
parsing error 
{
  char *v;

  v = get_string_value (name);
  setup_ignore_patterns (&globignore);

  if (globignore.num_ignores)
    glob_dot_filenames = 1;
  else if (v == 0)
    glob_dot_filenames = 0;
}
warning: parse error {
  char *v;

  v = get_string_value (name);
  setup_ignore_patterns (&globignore);

  if (globignore.num_ignores)
    glob_dot_filenames = 1;
  else if (v == 0)
    glob_dot_filenames = 0;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\pathexp.c:507
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\pathexp.c:528
parsing error 
{
  struct ign *p;
  char *n;
  int flags;

  /* . and .. are never matched. We extend this to the terminal component of a
     pathname. */
  n = strrchr (name, '/');
  if (n == 0 || n[1] == 0)
    n = (char *)name;
  else
    n++;

  if (n[0] == '.' && (n[1] == '\0' || (n[1] == '.' && n[2] == '\0')))
    return (0);

  flags = FNM_PATHNAME | FNMATCH_EXTFLAG | FNMATCH_NOCASEGLOB;
  for (p = globignore.ignores; p->val; p++)
    {
      if (strmatch (p->val, (char *)name, flags) != FNM_NOMATCH)
	return (0);
    }
  return (1);
}
warning: parse error {
  struct ign *p;
  char *n;
  int flags;

  /* . and .. are never matched. We extend this to the terminal component of a
     pathname. */
  n = strrchr (name, '/');
  if (n == 0 || n[1] == 0)
    n = (char *)name;
  else
    n++;

  if (n[0] == '.' && (n[1] == '\0' || (n[1] == '.' && n[2] == '\0')))
    return (0);

  flags = FNM_PATHNAME | FNMATCH_EXTFLAG | FNMATCH_NOCASEGLOB;
  for (p = globignore.ignores; p->val; p++)
    {
      if (strmatch (p->val, (char *)name, flags) != FNM_NOMATCH)
	return (0);
    }
  return (1);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\pathexp.c:529
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\pathexp.c:561
parsing error 
{
  char **newnames;
  int n, i;

  for (i = 0; names[i]; i++)
    ;
  newnames = strvec_create (i + 1);

  for (n = i = 0; names[i]; i++)
    {
      if ((*name_func) (names[i]))
	newnames[n++] = names[i];
      else
	free (names[i]);
    }

  newnames[n] = (char *)NULL;

  if (n == 0)
    {
      names[0] = (char *)NULL;
      free (newnames);
      return;
    }

  /* Copy the acceptable names from NEWNAMES back to NAMES and set the
     new array end. */
  for (n = 0; newnames[n]; n++)
    names[n] = newnames[n];
  names[n] = (char *)NULL;
  free (newnames);
}
warning: parse error {
  char **newnames;
  int n, i;

  for (i = 0; names[i]; i++)
    ;
  newnames = strvec_create (i + 1);

  for (n = i = 0; names[i]; i++)
    {
      if ((*name_func) (names[i]))
	newnames[n++] = names[i];
      else
	free (names[i]);
    }

  newnames[n] = (char *)NULL;

  if (n == 0)
    {
      names[0] = (char *)NULL;
      free (newnames);
      return;
    }

  /* Copy the acceptable names from NEWNAMES back to NAMES and set the
     new array end. */
  for (n = 0; newnames[n]; n++)
    names[n] = newnames[n];
  names[n] = (char *)NULL;
  free (newnames);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\pathexp.c:564
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\pathexp.c:598
parsing error 
{
  if (globignore.num_ignores == 0)
    return;

  ignore_globbed_names (names, glob_name_is_acceptable);
}
warning: parse error {
  if (globignore.num_ignores == 0)
    return;

  ignore_globbed_names (names, glob_name_is_acceptable);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\pathexp.c:600
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\pathexp.c:608
parsing error 
{
  char *t;
  int n, i;

  if (s == 0)
    return 0;

  i = *ip;
  if (s[i] == 0)
    return 0;

  n = skip_to_delim (s, i, ":", SD_NOJMP|SD_EXTGLOB|SD_GLOB);
  t = substring (s, i, n);

  if (s[n] == ':')
    n++;  
  *ip = n;  
  return t;
}
warning: parse error {
  char *t;
  int n, i;

  if (s == 0)
    return 0;

  i = *ip;
  if (s[i] == 0)
    return 0;

  n = skip_to_delim (s, i, ":", SD_NOJMP|SD_EXTGLOB|SD_GLOB);
  t = substring (s, i, n);

  if (s[n] == ':')
    n++;  
  *ip = n;  
  return t;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\pathexp.c:611
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\pathexp.c:632
parsing error 
{
  int numitems, maxitems, ptr;
  char *colon_bit, *this_ignoreval;
  struct ign *p;

  this_ignoreval = get_string_value (ivp->varname);

  /* If nothing has changed then just exit now. */
  if ((this_ignoreval && ivp->last_ignoreval && STREQ (this_ignoreval, ivp->last_ignoreval)) ||
      (!this_ignoreval && !ivp->last_ignoreval))
    return;

  /* Oops.  The ignore variable has changed.  Re-parse it. */
  ivp->num_ignores = 0;

  if (ivp->ignores)
    {
      for (p = ivp->ignores; p->val; p++)
	free(p->val);
      free (ivp->ignores);
      ivp->ignores = (struct ign *)NULL;
    }

  if (ivp->last_ignoreval)
    {
      free (ivp->last_ignoreval);
      ivp->last_ignoreval = (char *)NULL;
    }

  if (this_ignoreval == 0 || *this_ignoreval == '\0')
    return;

  ivp->last_ignoreval = savestring (this_ignoreval);

  numitems = maxitems = ptr = 0;

#if 0
  while (colon_bit = extract_colon_unit (this_ignoreval, &ptr))
#else
  while (colon_bit = split_ignorespec (this_ignoreval, &ptr))
#endif
    {
      if (numitems + 1 >= maxitems)
	{
	  maxitems += 10;
	  ivp->ignores = (struct ign *)xrealloc (ivp->ignores, maxitems * sizeof (struct ign));
	}
      ivp->ignores[numitems].val = colon_bit;
      ivp->ignores[numitems].len = strlen (colon_bit);
      ivp->ignores[numitems].flags = 0;
      if (ivp->item_func)
	(*ivp->item_func) (&ivp->ignores[numitems]);
      numitems++;
    }
  ivp->ignores[numitems].val = (char *)NULL;
  ivp->num_ignores = numitems;
}
warning: parse error {
  int numitems, maxitems, ptr;
  char *colon_bit, *this_ignoreval;
  struct ign *p;

  this_ignoreval = get_string_value (ivp->varname);

  /* If nothing has changed then just exit now. */
  if ((this_ignoreval && ivp->last_ignoreval && STREQ (this_ignoreval, ivp->last_ignoreval)) ||
      (!this_ignoreval && !ivp->last_ignoreval))
    return;

  /* Oops.  The ignore variable has changed.  Re-parse it. */
  ivp->num_ignores = 0;

  if (ivp->ignores)
    {
      for (p = ivp->ignores; p->val; p++)
	free(p->val);
      free (ivp->ignores);
      ivp->ignores = (struct ign *)NULL;
    }

  if (ivp->last_ignoreval)
    {
      free (ivp->last_ignoreval);
      ivp->last_ignoreval = (char *)NULL;
    }

  if (this_ignoreval == 0 || *this_ignoreval == '\0')
    return;

  ivp->last_ignoreval = savestring (this_ignoreval);

  numitems = maxitems = ptr = 0;

#if 0
  while (colon_bit = extract_colon_unit (this_ignoreval, &ptr))
#else
  while (colon_bit = split_ignorespec (this_ignoreval, &ptr))
#endif
    {
      if (numitems + 1 >= maxitems)
	{
	  maxitems += 10;
	  ivp->ignores = (struct ign *)xrealloc (ivp->ignores, maxitems * sizeof (struct ign));
	}
      ivp->ignores[numitems].val = colon_bit;
      ivp->ignores[numitems].len = strlen (colon_bit);
      ivp->ignores[numitems].flags = 0;
      if (ivp->item_func)
	(*ivp->item_func) (&ivp->ignores[numitems]);
      numitems++;
    }
  ivp->ignores[numitems].val = (char *)NULL;
  ivp->num_ignores = numitems;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\pathexp.c:634
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\pcomplete.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashtypes.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\posixstat.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\posixtime.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashansi.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashintl.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\shell.h...skip
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\pcomplete.h...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\stdc.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\hashlib.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\alias.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashline.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\execute_cmd.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\pathexp.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\shmbutil.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\common.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\glob\glob.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\glob\strmatch.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\rlconf.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\readline.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\readline\history.h...skip
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\pcomplib.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashansi.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashintl.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\shell.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\pcomplete.h...skip
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\print_cmd.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashansi.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashintl.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\shell.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\flags.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\y.tab.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\input.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\shmbutil.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\common.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\print_cmd.c:144
parsing error 
{
  command_string_index = 0;
  printf ("%s", make_command_string (command));
}
warning: parse error {
  command_string_index = 0;
  printf ("%s", make_command_string (command));
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\print_cmd.c:146
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\print_cmd.c:156
parsing error 
{
  command_string_index = was_heredoc = 0;
  deferred_heredocs = 0;
  make_command_string_internal (command);
  return (the_printed_command);
}
warning: parse error {
  command_string_index = was_heredoc = 0;
  deferred_heredocs = 0;
  make_command_string_internal (command);
  return (the_printed_command);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\print_cmd.c:158
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\print_cmd.c:167
parsing error 
{
  char s[3];

  if (command == 0)
    cprintf ("");
  else
    {
      if (skip_this_indent)
	skip_this_indent--;
      else
	indent (indentation);

      if (command->flags & CMD_TIME_PIPELINE)
	{
	  cprintf ("time ");
	  if (command->flags & CMD_TIME_POSIX)
	    cprintf ("-p ");
	}

      if (command->flags & CMD_INVERT_RETURN)
	cprintf ("! ");

      switch (command->type)
	{
	case cm_for:
	  print_for_command (command->value.For);
	  break;

#if defined (ARITH_FOR_COMMAND)
	case cm_arith_for:
	  print_arith_for_command (command->value.ArithFor);
	  break;
#endif

#if defined (SELECT_COMMAND)
	case cm_select:
	  print_select_command (command->value.Select);
	  break;
#endif

	case cm_case:
	  print_case_command (command->value.Case);
	  break;

	case cm_while:
	  print_while_command (command->value.While);
	  break;

	case cm_until:
	  print_until_command (command->value.While);
	  break;

	case cm_if:
	  print_if_command (command->value.If);
	  break;

#if defined (DPAREN_ARITHMETIC)
	case cm_arith:
	  print_arith_command (command->value.Arith->exp);
	  break;
#endif

#if defined (COND_COMMAND)
	case cm_cond:
	  print_cond_command (command->value.Cond);
	  break;
#endif

	case cm_simple:
	  print_simple_command (command->value.Simple);
	  break;

	case cm_connection:

	  skip_this_indent++;
	  printing_connection++;
	  make_command_string_internal (command->value.Connection->first);

	  switch (command->value.Connection->connector)
	    {
	    case '&':
	    case '|':
	      {
		char c = command->value.Connection->connector;

		s[0] = ' ';
		s[1] = c;
		s[2] = '\0';
		
		print_deferred_heredocs (s);

		if (c != '&' || command->value.Connection->second)
		  {
		    cprintf (" ");
		    skip_this_indent++;
		  }
	      }
	      break;

	    case AND_AND:
	      print_deferred_heredocs (" && ");
	      if (command->value.Connection->second)
		skip_this_indent++;
	      break;

	    case OR_OR:
	      print_deferred_heredocs (" || ");
	      if (command->value.Connection->second)
		skip_this_indent++;
	      break;

	    case ';':
	      if (deferred_heredocs == 0)
		{
		  if (was_heredoc == 0)
		    cprintf (";");
		  else
		    was_heredoc = 0;
		}
	      else
		print_deferred_heredocs (inside_function_def ? "" : ";");

	      if (inside_function_def)
		cprintf ("\n");
	      else
		{
		  cprintf (" ");
		  if (command->value.Connection->second)
		    skip_this_indent++;
		}
	      break;

	    default:
	      cprintf (_("print_command: bad connector `%d'"),
		       command->value.Connection->connector);
	      break;
	    }

	  make_command_string_internal (command->value.Connection->second);
	  PRINT_DEFERRED_HEREDOCS ("");
	  printing_connection--;	  	  
	  break;

	case cm_function_def:
	  print_function_def (command->value.Function_def);
	  break;

	case cm_group:
	  print_group_command (command->value.Group);
	  break;

	case cm_subshell:
	  cprintf ("( ");
	  skip_this_indent++;
	  make_command_string_internal (command->value.Subshell->command);
	  PRINT_DEFERRED_HEREDOCS ("");
	  cprintf (" )");
	  break;

	case cm_coproc:
	  cprintf ("coproc %s ", command->value.Coproc->name);
	  skip_this_indent++;
	  make_command_string_internal (command->value.Coproc->command);
	  break;

	default:
	  command_error ("print_command", CMDERR_BADTYPE, command->type, 0);
	  break;
	}


      if (command->redirects)
	{
	  cprintf (" ");
	  print_redirection_list (command->redirects);
	}
    }
}
warning: parse error {
  char s[3];

  if (command == 0)
    cprintf ("");
  else
    {
      if (skip_this_indent)
	skip_this_indent--;
      else
	indent (indentation);

      if (command->flags & CMD_TIME_PIPELINE)
	{
	  cprintf ("time ");
	  if (command->flags & CMD_TIME_POSIX)
	    cprintf ("-p ");
	}

      if (command->flags & CMD_INVERT_RETURN)
	cprintf ("! ");

      switch (command->type)
	{
	case cm_for:
	  print_for_command (command->value.For);
	  break;

#if defined (ARITH_FOR_COMMAND)
	case cm_arith_for:
	  print_arith_for_command (command->value.ArithFor);
	  break;
#endif

#if defined (SELECT_COMMAND)
	case cm_select:
	  print_select_command (command->value.Select);
	  break;
#endif

	case cm_case:
	  print_case_command (command->value.Case);
	  break;

	case cm_while:
	  print_while_command (command->value.While);
	  break;

	case cm_until:
	  print_until_command (command->value.While);
	  break;

	case cm_if:
	  print_if_command (command->value.If);
	  break;

#if defined (DPAREN_ARITHMETIC)
	case cm_arith:
	  print_arith_command (command->value.Arith->exp);
	  break;
#endif

#if defined (COND_COMMAND)
	case cm_cond:
	  print_cond_command (command->value.Cond);
	  break;
#endif

	case cm_simple:
	  print_simple_command (command->value.Simple);
	  break;

	case cm_connection:

	  skip_this_indent++;
	  printing_connection++;
	  make_command_string_internal (command->value.Connection->first);

	  switch (command->value.Connection->connector)
	    {
	    case '&':
	    case '|':
	      {
		char c = command->value.Connection->connector;

		s[0] = ' ';
		s[1] = c;
		s[2] = '\0';
		
		print_deferred_heredocs (s);

		if (c != '&' || command->value.Connection->second)
		  {
		    cprintf (" ");
		    skip_this_indent++;
		  }
	      }
	      break;

	    case AND_AND:
	      print_deferred_heredocs (" && ");
	      if (command->value.Connection->second)
		skip_this_indent++;
	      break;

	    case OR_OR:
	      print_deferred_heredocs (" || ");
	      if (command->value.Connection->second)
		skip_this_indent++;
	      break;

	    case ';':
	      if (deferred_heredocs == 0)
		{
		  if (was_heredoc == 0)
		    cprintf (";");
		  else
		    was_heredoc = 0;
		}
	      else
		print_deferred_heredocs (inside_function_def ? "" : ";");

	      if (inside_function_def)
		cprintf ("\n");
	      else
		{
		  cprintf (" ");
		  if (command->value.Connection->second)
		    skip_this_indent++;
		}
	      break;

	    default:
	      cprintf (_("print_command: bad connector `%d'"),
		       command->value.Connection->connector);
	      break;
	    }

	  make_command_string_internal (command->value.Connection->second);
	  PRINT_DEFERRED_HEREDOCS ("");
	  printing_connection--;	  	  
	  break;

	case cm_function_def:
	  print_function_def (command->value.Function_def);
	  break;

	case cm_group:
	  print_group_command (command->value.Group);
	  break;

	case cm_subshell:
	  cprintf ("( ");
	  skip_this_indent++;
	  make_command_string_internal (command->value.Subshell->command);
	  PRINT_DEFERRED_HEREDOCS ("");
	  cprintf (" )");
	  break;

	case cm_coproc:
	  cprintf ("coproc %s ", command->value.Coproc->name);
	  skip_this_indent++;
	  make_command_string_internal (command->value.Coproc->command);
	  break;

	default:
	  command_error ("print_command", CMDERR_BADTYPE, command->type, 0);
	  break;
	}


      if (command->redirects)
	{
	  cprintf (" ");
	  print_redirection_list (command->redirects);
	}
    }
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\print_cmd.c:169
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\print_cmd.c:349
parsing error 
{
  WORD_LIST *w;

  for (w = list; w; w = w->next)
    (*pfunc) ("%s%s", w->word->word, w->next ? separator : "");
}
warning: parse error {
  WORD_LIST *w;

  for (w = list; w; w = w->next)
    (*pfunc) ("%s%s", w->word->word, w->next ? separator : "");
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\print_cmd.c:353
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\print_cmd.c:361
parsing error 
{
  _print_word_list (list, separator, xprintf);
}
warning: parse error {
  _print_word_list (list, separator, xprintf);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\print_cmd.c:364
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\print_cmd.c:369
parsing error 
{
  if (fd >= 0 && sh_validfd (fd) == 0)
    {
      internal_error (_("xtrace_set: %d: invalid file descriptor"), fd);
      return;
    }
  if (fp == 0)
    {
      internal_error (_("xtrace_set: NULL file pointer"));
      return;
    }
  if (fd >= 0 && fileno (fp) != fd)
    internal_warning (_("xtrace fd (%d) != fileno xtrace fp (%d)"), fd, fileno (fp));
  
  xtrace_fd = fd;
  xtrace_fp = fp;
}
warning: parse error {
  if (fd >= 0 && sh_validfd (fd) == 0)
    {
      internal_error (_("xtrace_set: %d: invalid file descriptor"), fd);
      return;
    }
  if (fp == 0)
    {
      internal_error (_("xtrace_set: NULL file pointer"));
      return;
    }
  if (fd >= 0 && fileno (fp) != fd)
    internal_warning (_("xtrace fd (%d) != fileno xtrace fp (%d)"), fd, fileno (fp));
  
  xtrace_fd = fd;
  xtrace_fp = fp;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\print_cmd.c:372
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\print_cmd.c:412
parsing error 
{
  if (fd == xtrace_fd)
    xtrace_reset ();
}
warning: parse error {
  if (fd == xtrace_fd)
    xtrace_reset ();
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\print_cmd.c:414
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\print_cmd.c:486
parsing error 
{
  char *nval;

  CHECK_XTRACE_FP;

  if (xflags)
    fprintf (xtrace_fp, "%s", indirection_level_string ());

  /* VALUE should not be NULL when this is called. */
  if (*value == '\0' || assign_list)
    nval = value;
  else if (sh_contains_shell_metas (value))
    nval = sh_single_quote (value);
  else if (ansic_shouldquote (value))
    nval = ansic_quote (value, 0, (int *)0);
  else
    nval = value;

  if (assign_list)
    fprintf (xtrace_fp, "%s=(%s)\n", name, nval);
  else
    fprintf (xtrace_fp, "%s=%s\n", name, nval);

  if (nval != value)
    FREE (nval);

  fflush (xtrace_fp);
}
warning: parse error {
  char *nval;

  CHECK_XTRACE_FP;

  if (xflags)
    fprintf (xtrace_fp, "%s", indirection_level_string ());

  /* VALUE should not be NULL when this is called. */
  if (*value == '\0' || assign_list)
    nval = value;
  else if (sh_contains_shell_metas (value))
    nval = sh_single_quote (value);
  else if (ansic_shouldquote (value))
    nval = ansic_quote (value, 0, (int *)0);
  else
    nval = value;

  if (assign_list)
    fprintf (xtrace_fp, "%s=(%s)\n", name, nval);
  else
    fprintf (xtrace_fp, "%s=%s\n", name, nval);

  if (nval != value)
    FREE (nval);

  fflush (xtrace_fp);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\print_cmd.c:489
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\print_cmd.c:523
parsing error 
{
  WORD_LIST *w;
  char *t, *x;

  CHECK_XTRACE_FP;

  if (xtflags&1)
    fprintf (xtrace_fp, "%s", indirection_level_string ());

  for (w = list; w; w = w->next)
    {
      t = w->word->word;
      if (t == 0 || *t == '\0')
	fprintf (xtrace_fp, "''%s", w->next ? " " : "");
      else if (xtflags & 2)
	fprintf (xtrace_fp, "%s%s", t, w->next ? " " : "");
      else if (sh_contains_shell_metas (t))
	{
	  x = sh_single_quote (t);
	  fprintf (xtrace_fp, "%s%s", x, w->next ? " " : "");
	  free (x);
	}
      else if (ansic_shouldquote (t))
	{
	  x = ansic_quote (t, 0, (int *)0);
	  fprintf (xtrace_fp, "%s%s", x, w->next ? " " : "");
	  free (x);
	}
      else
	fprintf (xtrace_fp, "%s%s", t, w->next ? " " : "");
    }
  fprintf (xtrace_fp, "\n");
  fflush (xtrace_fp);
}
warning: parse error {
  WORD_LIST *w;
  char *t, *x;

  CHECK_XTRACE_FP;

  if (xtflags&1)
    fprintf (xtrace_fp, "%s", indirection_level_string ());

  for (w = list; w; w = w->next)
    {
      t = w->word->word;
      if (t == 0 || *t == '\0')
	fprintf (xtrace_fp, "''%s", w->next ? " " : "");
      else if (xtflags & 2)
	fprintf (xtrace_fp, "%s%s", t, w->next ? " " : "");
      else if (sh_contains_shell_metas (t))
	{
	  x = sh_single_quote (t);
	  fprintf (xtrace_fp, "%s%s", x, w->next ? " " : "");
	  free (x);
	}
      else if (ansic_shouldquote (t))
	{
	  x = ansic_quote (t, 0, (int *)0);
	  fprintf (xtrace_fp, "%s%s", x, w->next ? " " : "");
	  free (x);
	}
      else
	fprintf (xtrace_fp, "%s%s", t, w->next ? " " : "");
    }
  fprintf (xtrace_fp, "\n");
  fflush (xtrace_fp);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\print_cmd.c:526
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\print_cmd.c:562
parsing error 
{
  _print_word_list (list, separator, cprintf);
}
warning: parse error {
  _print_word_list (list, separator, cprintf);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\print_cmd.c:565
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\print_cmd.c:570
parsing error 
{
  cprintf ("for %s in ", for_command->name->word);
  command_print_word_list (for_command->map_list, " ");
}
warning: parse error {
  cprintf ("for %s in ", for_command->name->word);
  command_print_word_list (for_command->map_list, " ");
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\print_cmd.c:572
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\print_cmd.c:578
parsing error 
{
  CHECK_XTRACE_FP;
  fprintf (xtrace_fp, "%s", indirection_level_string ());
  fprintf (xtrace_fp, "for %s in ", for_command->name->word);
  xtrace_print_word_list (for_command->map_list, 2);
}
warning: parse error {
  CHECK_XTRACE_FP;
  fprintf (xtrace_fp, "%s", indirection_level_string ());
  fprintf (xtrace_fp, "for %s in ", for_command->name->word);
  xtrace_print_word_list (for_command->map_list, 2);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\print_cmd.c:580
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\print_cmd.c:588
parsing error 
{
  print_for_command_head (for_command);
  cprintf (";");
  newline ("do\n");

  indentation += indentation_amount;
  make_command_string_internal (for_command->action);
  PRINT_DEFERRED_HEREDOCS ("");
  semicolon ();
  indentation -= indentation_amount;

  newline ("done");
}
warning: parse error {
  print_for_command_head (for_command);
  cprintf (";");
  newline ("do\n");

  indentation += indentation_amount;
  make_command_string_internal (for_command->action);
  PRINT_DEFERRED_HEREDOCS ("");
  semicolon ();
  indentation -= indentation_amount;

  newline ("done");
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\print_cmd.c:590
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\print_cmd.c:663
parsing error 
{
  group_command_nesting++;
  cprintf ("{ ");

  if (inside_function_def == 0)
    skip_this_indent++;
  else
    {
      /* This is a group command { ... } inside of a function
	 definition, and should be printed as a multiline group
	 command, using the current indentation. */
      cprintf ("\n");
      indentation += indentation_amount;
    }

  make_command_string_internal (group_command->command);
  PRINT_DEFERRED_HEREDOCS ("");

  if (inside_function_def)
    {
      cprintf ("\n");
      indentation -= indentation_amount;
      indent (indentation);
    }
  else
    {
      semicolon ();
      cprintf (" ");
    }

  cprintf ("}");

  group_command_nesting--;
}
warning: parse error {
  group_command_nesting++;
  cprintf ("{ ");

  if (inside_function_def == 0)
    skip_this_indent++;
  else
    {
      /* This is a group command { ... } inside of a function
	 definition, and should be printed as a multiline group
	 command, using the current indentation. */
      cprintf ("\n");
      indentation += indentation_amount;
    }

  make_command_string_internal (group_command->command);
  PRINT_DEFERRED_HEREDOCS ("");

  if (inside_function_def)
    {
      cprintf ("\n");
      indentation -= indentation_amount;
      indent (indentation);
    }
  else
    {
      semicolon ();
      cprintf (" ");
    }

  cprintf ("}");

  group_command_nesting--;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\print_cmd.c:665
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\print_cmd.c:701
parsing error 
{
  cprintf ("case %s in ", case_command->word->word);
}
warning: parse error {
  cprintf ("case %s in ", case_command->word->word);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\print_cmd.c:703
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\print_cmd.c:708
parsing error 
{
  CHECK_XTRACE_FP;
  fprintf (xtrace_fp, "%s", indirection_level_string ());
  fprintf (xtrace_fp, "case %s in\n", case_command->word->word);
}
warning: parse error {
  CHECK_XTRACE_FP;
  fprintf (xtrace_fp, "%s", indirection_level_string ());
  fprintf (xtrace_fp, "case %s in\n", case_command->word->word);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\print_cmd.c:710
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\print_cmd.c:717
parsing error 
{
  print_case_command_head (case_command);

  if (case_command->clauses)
    print_case_clauses (case_command->clauses);
  newline ("esac");
}
warning: parse error {
  print_case_command_head (case_command);

  if (case_command->clauses)
    print_case_clauses (case_command->clauses);
  newline ("esac");
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\print_cmd.c:719
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\print_cmd.c:728
parsing error 
{
  indentation += indentation_amount;
  while (clauses)
    {
      newline ("");
      command_print_word_list (clauses->patterns, " | ");
      cprintf (")\n");
      indentation += indentation_amount;
      make_command_string_internal (clauses->action);
      indentation -= indentation_amount;
      PRINT_DEFERRED_HEREDOCS ("");
      if (clauses->flags & CASEPAT_FALLTHROUGH)
	newline (";&");
      else if (clauses->flags & CASEPAT_TESTNEXT)
	newline (";;&");
      else
	newline (";;");
      clauses = clauses->next;
    }
  indentation -= indentation_amount;
}
warning: parse error {
  indentation += indentation_amount;
  while (clauses)
    {
      newline ("");
      command_print_word_list (clauses->patterns, " | ");
      cprintf (")\n");
      indentation += indentation_amount;
      make_command_string_internal (clauses->action);
      indentation -= indentation_amount;
      PRINT_DEFERRED_HEREDOCS ("");
      if (clauses->flags & CASEPAT_FALLTHROUGH)
	newline (";&");
      else if (clauses->flags & CASEPAT_TESTNEXT)
	newline (";;&");
      else
	newline (";;");
      clauses = clauses->next;
    }
  indentation -= indentation_amount;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\print_cmd.c:730
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\print_cmd.c:753
parsing error 
{
  print_until_or_while (while_command, "while");
}
warning: parse error {
  print_until_or_while (while_command, "while");
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\print_cmd.c:755
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\print_cmd.c:760
parsing error 
{
  print_until_or_while (while_command, "until");
}
warning: parse error {
  print_until_or_while (while_command, "until");
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\print_cmd.c:762
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\print_cmd.c:767
parsing error 
{
  cprintf ("%s ", which);
  skip_this_indent++;
  make_command_string_internal (while_command->test);
  PRINT_DEFERRED_HEREDOCS ("");
  semicolon ();
  cprintf (" do\n");	/* was newline ("do\n"); */
  indentation += indentation_amount;
  make_command_string_internal (while_command->action);
  PRINT_DEFERRED_HEREDOCS ("");
  indentation -= indentation_amount;
  semicolon ();
  newline ("done");
}
warning: parse error {
  cprintf ("%s ", which);
  skip_this_indent++;
  make_command_string_internal (while_command->test);
  PRINT_DEFERRED_HEREDOCS ("");
  semicolon ();
  cprintf (" do\n");	/* was newline ("do\n"); */
  indentation += indentation_amount;
  make_command_string_internal (while_command->action);
  PRINT_DEFERRED_HEREDOCS ("");
  indentation -= indentation_amount;
  semicolon ();
  newline ("done");
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\print_cmd.c:770
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\print_cmd.c:786
parsing error 
{
  cprintf ("if ");
  skip_this_indent++;
  make_command_string_internal (if_command->test);
  semicolon ();
  cprintf (" then\n");
  indentation += indentation_amount;
  make_command_string_internal (if_command->true_case);
  PRINT_DEFERRED_HEREDOCS ("");
  indentation -= indentation_amount;

  if (if_command->false_case)
    {
      semicolon ();
      newline ("else\n");
      indentation += indentation_amount;
      make_command_string_internal (if_command->false_case);
      PRINT_DEFERRED_HEREDOCS ("");
      indentation -= indentation_amount;
    }
  semicolon ();
  newline ("fi");
}
warning: parse error {
  cprintf ("if ");
  skip_this_indent++;
  make_command_string_internal (if_command->test);
  semicolon ();
  cprintf (" then\n");
  indentation += indentation_amount;
  make_command_string_internal (if_command->true_case);
  PRINT_DEFERRED_HEREDOCS ("");
  indentation -= indentation_amount;

  if (if_command->false_case)
    {
      semicolon ();
      newline ("else\n");
      indentation += indentation_amount;
      make_command_string_internal (if_command->false_case);
      PRINT_DEFERRED_HEREDOCS ("");
      indentation -= indentation_amount;
    }
  semicolon ();
  newline ("fi");
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\print_cmd.c:788
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\print_cmd.c:956
parsing error 
{
  command_print_word_list (simple_command->words, " ");

  if (simple_command->redirects)
    {
      cprintf (" ");
      print_redirection_list (simple_command->redirects);
    }
}
warning: parse error {
  command_print_word_list (simple_command->words, " ");

  if (simple_command->redirects)
    {
      cprintf (" ");
      print_redirection_list (simple_command->redirects);
    }
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\print_cmd.c:958
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\print_cmd.c:969
parsing error 
{
  REDIRECT *hdtail;

  cprintf (" "); 
  for (hdtail = heredocs; hdtail; hdtail = hdtail->next)
    {
      print_redirection (hdtail);
      cprintf ("\n");
    }
  was_heredoc = 1;
}
warning: parse error {
  REDIRECT *hdtail;

  cprintf (" "); 
  for (hdtail = heredocs; hdtail; hdtail = hdtail->next)
    {
      print_redirection (hdtail);
      cprintf ("\n");
    }
  was_heredoc = 1;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\print_cmd.c:971
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\print_cmd.c:984
parsing error 
{
  REDIRECT *hdtail;

  cprintf ("\n"); 
  for (hdtail = heredocs; hdtail; hdtail = hdtail->next)
    {
      print_heredoc_body (hdtail);
      cprintf ("\n");
    }
  was_heredoc = 1;
}
warning: parse error {
  REDIRECT *hdtail;

  cprintf ("\n"); 
  for (hdtail = heredocs; hdtail; hdtail = hdtail->next)
    {
      print_heredoc_body (hdtail);
      cprintf ("\n");
    }
  was_heredoc = 1;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\print_cmd.c:986
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\print_cmd.c:1,007
parsing error 
{
  /* We now print the heredoc headers in print_redirection_list */
  if (cstring && cstring[0] && (cstring[0] != ';' || cstring[1]))
    cprintf ("%s", cstring); 
  if (deferred_heredocs)
    {
      print_heredoc_bodies (deferred_heredocs);
      if (cstring && cstring[0] && (cstring[0] != ';' || cstring[1]))
	cprintf (" ");	/* make sure there's at least one space */
      dispose_redirects (deferred_heredocs);
      was_heredoc = 1;
    }
  deferred_heredocs = (REDIRECT *)NULL;
}
warning: parse error {
  /* We now print the heredoc headers in print_redirection_list */
  if (cstring && cstring[0] && (cstring[0] != ';' || cstring[1]))
    cprintf ("%s", cstring); 
  if (deferred_heredocs)
    {
      print_heredoc_bodies (deferred_heredocs);
      if (cstring && cstring[0] && (cstring[0] != ';' || cstring[1]))
	cprintf (" ");	/* make sure there's at least one space */
      dispose_redirects (deferred_heredocs);
      was_heredoc = 1;
    }
  deferred_heredocs = (REDIRECT *)NULL;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\print_cmd.c:1,008
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\print_cmd.c:1,024
parsing error 
{
  REDIRECT *heredocs, *hdtail, *newredir;
  char *rw;

  heredocs = (REDIRECT *)NULL;
  hdtail = heredocs;

  was_heredoc = 0;
  while (redirects)
    {
      /* Defer printing the here document bodiess until we've printed the rest of the
         redirections, but print the headers in the order they're given.  */
      if (redirects->instruction == r_reading_until || redirects->instruction == r_deblank_reading_until)
	{
	  newredir = copy_redirect (redirects);
	  newredir->next = (REDIRECT *)NULL;

	  print_heredoc_header (newredir);

	  if (heredocs)
	    {
	      hdtail->next = newredir;
	      hdtail = newredir;
	    }
	  else
	    hdtail = heredocs = newredir;
	}
      else if (redirects->instruction == r_duplicating_output_word && (redirects->flags & REDIR_VARASSIGN) == 0 && redirects->redirector.dest == 1)
	{
	  /* Temporarily translate it as the execution code does. */
	  rw = redirects->redirectee.filename->word;
	  if (rw && *rw != '-' && DIGIT (*rw) == 0 && EXPCHAR (*rw) == 0)
	    redirects->instruction = r_err_and_out;
	  print_redirection (redirects);
	  redirects->instruction = r_duplicating_output_word;
	}
      else
	print_redirection (redirects);

      redirects = redirects->next;
      if (redirects)
	cprintf (" ");
    }

  /* Now that we've printed all the other redirections (on one line),
     print the here documents.  If we're printing a connection, we wait until
     we print the connector symbol, then we print the here document bodies */
  if (heredocs && printing_connection)
    deferred_heredocs = heredocs;
  else if (heredocs)
    {
      print_heredoc_bodies (heredocs);
      dispose_redirects (heredocs);
    }
}
warning: parse error {
  REDIRECT *heredocs, *hdtail, *newredir;
  char *rw;

  heredocs = (REDIRECT *)NULL;
  hdtail = heredocs;

  was_heredoc = 0;
  while (redirects)
    {
      /* Defer printing the here document bodiess until we've printed the rest of the
         redirections, but print the headers in the order they're given.  */
      if (redirects->instruction == r_reading_until || redirects->instruction == r_deblank_reading_until)
	{
	  newredir = copy_redirect (redirects);
	  newredir->next = (REDIRECT *)NULL;

	  print_heredoc_header (newredir);

	  if (heredocs)
	    {
	      hdtail->next = newredir;
	      hdtail = newredir;
	    }
	  else
	    hdtail = heredocs = newredir;
	}
      else if (redirects->instruction == r_duplicating_output_word && (redirects->flags & REDIR_VARASSIGN) == 0 && redirects->redirector.dest == 1)
	{
	  /* Temporarily translate it as the execution code does. */
	  rw = redirects->redirectee.filename->word;
	  if (rw && *rw != '-' && DIGIT (*rw) == 0 && EXPCHAR (*rw) == 0)
	    redirects->instruction = r_err_and_out;
	  print_redirection (redirects);
	  redirects->instruction = r_duplicating_output_word;
	}
      else
	print_redirection (redirects);

      redirects = redirects->next;
      if (redirects)
	cprintf (" ");
    }

  /* Now that we've printed all the other redirections (on one line),
     print the here documents.  If we're printing a connection, we wait until
     we print the connector symbol, then we print the here document bodies */
  if (heredocs && printing_connection)
    deferred_heredocs = heredocs;
  else if (heredocs)
    {
      print_heredoc_bodies (heredocs);
      dispose_redirects (heredocs);
    }
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\print_cmd.c:1,026
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\print_cmd.c:1,083
parsing error 
{
  int kill_leading;
  char *x;

  kill_leading = redirect->instruction == r_deblank_reading_until;

  /* Here doc header */
  if (redirect->rflags & REDIR_VARASSIGN)
    cprintf ("{%s}", redirect->redirector.filename->word);
  else if (redirect->redirector.dest != 0)
    cprintf ("%d", redirect->redirector.dest);

  /* If the here document delimiter is quoted, single-quote it. */
  if (redirect->redirectee.filename->flags & W_QUOTED)
    {
      x = sh_single_quote (redirect->here_doc_eof);
      cprintf ("<<%s%s", kill_leading ? "-" : "", x);
      free (x);
    }
  else
    cprintf ("<<%s%s", kill_leading ? "-" : "", redirect->here_doc_eof);
}
warning: parse error {
  int kill_leading;
  char *x;

  kill_leading = redirect->instruction == r_deblank_reading_until;

  /* Here doc header */
  if (redirect->rflags & REDIR_VARASSIGN)
    cprintf ("{%s}", redirect->redirector.filename->word);
  else if (redirect->redirector.dest != 0)
    cprintf ("%d", redirect->redirector.dest);

  /* If the here document delimiter is quoted, single-quote it. */
  if (redirect->redirectee.filename->flags & W_QUOTED)
    {
      x = sh_single_quote (redirect->here_doc_eof);
      cprintf ("<<%s%s", kill_leading ? "-" : "", x);
      free (x);
    }
  else
    cprintf ("<<%s%s", kill_leading ? "-" : "", redirect->here_doc_eof);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\print_cmd.c:1,085
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\print_cmd.c:1,109
parsing error 
{
  /* Here doc body */
  cprintf ("%s%s", redirect->redirectee.filename->word, redirect->here_doc_eof);
}
warning: parse error {
  /* Here doc body */
  cprintf ("%s%s", redirect->redirectee.filename->word, redirect->here_doc_eof);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\print_cmd.c:1,111
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\print_cmd.c:1,117
parsing error 
{
  int redirector, redir_fd;
  WORD_DESC *redirectee, *redir_word;

  redirectee = redirect->redirectee.filename;
  redir_fd = redirect->redirectee.dest;

  redir_word = redirect->redirector.filename;
  redirector = redirect->redirector.dest;

  switch (redirect->instruction)
    {
    case r_input_direction:
      if (redirect->rflags & REDIR_VARASSIGN)
	cprintf ("{%s}", redir_word->word);
      else if (redirector != 0)
	cprintf ("%d", redirector);
      cprintf ("< %s", redirectee->word);
      break;

    case r_output_direction:
      if (redirect->rflags & REDIR_VARASSIGN)
	cprintf ("{%s}", redir_word->word);
      else if (redirector != 1)
	cprintf ("%d", redirector);
      cprintf ("> %s", redirectee->word);
      break;

    case r_inputa_direction:	/* Redirection created by the shell. */
      cprintf ("&");
      break;

    case r_output_force:
      if (redirect->rflags & REDIR_VARASSIGN)
	cprintf ("{%s}", redir_word->word);
      else if (redirector != 1)
	cprintf ("%d", redirector);
      cprintf (">| %s", redirectee->word);
      break;

    case r_appending_to:
      if (redirect->rflags & REDIR_VARASSIGN)
	cprintf ("{%s}", redir_word->word);
      else if (redirector != 1)
	cprintf ("%d", redirector);
      cprintf (">> %s", redirectee->word);
      break;

    case r_input_output:
      if (redirect->rflags & REDIR_VARASSIGN)
	cprintf ("{%s}", redir_word->word);
      else if (redirector != 1)
	cprintf ("%d", redirector);
      cprintf ("<> %s", redirectee->word);
      break;

    case r_deblank_reading_until:
    case r_reading_until:
      print_heredoc_header (redirect);
      cprintf ("\n");
      print_heredoc_body (redirect);
      break;

    case r_reading_string:
      if (redirect->rflags & REDIR_VARASSIGN)
	cprintf ("{%s}", redir_word->word);
      else if (redirector != 0)
	cprintf ("%d", redirector);
#if 0
      /* Don't need to check whether or not to requote, since original quotes
         are still intact.  The only thing that has happened is that $'...'
         has been replaced with 'expanded ...'. */
      if (ansic_shouldquote (redirect->redirectee.filename->word))
	{
	  char *x;
	  x = ansic_quote (redirect->redirectee.filename->word, 0, (int *)0);
	  cprintf ("<<< %s", x);
	  free (x);
	}
      else
#endif
	cprintf ("<<< %s", redirect->redirectee.filename->word);
      break;

    case r_duplicating_input:
      if (redirect->rflags & REDIR_VARASSIGN)
	cprintf ("{%s}<&%d", redir_word->word, redir_fd);
      else
	cprintf ("%d<&%d", redirector, redir_fd);
      break;

    case r_duplicating_output:
      if (redirect->rflags & REDIR_VARASSIGN)
	cprintf ("{%s}>&%d", redir_word->word, redir_fd);
      else
	cprintf ("%d>&%d", redirector, redir_fd);
      break;

    case r_duplicating_input_word:
      if (redirect->rflags & REDIR_VARASSIGN)
	cprintf ("{%s}<&%s", redir_word->word, redirectee->word);
      else
	cprintf ("%d<&%s", redirector, redirectee->word);
      break;

    case r_duplicating_output_word:
      if (redirect->rflags & REDIR_VARASSIGN)
	cprintf ("{%s}>&%s", redir_word->word, redirectee->word);
      else
	cprintf ("%d>&%s", redirector, redirectee->word);
      break;

    case r_move_input:
      if (redirect->rflags & REDIR_VARASSIGN)
	cprintf ("{%s}<&%d-", redir_word->word, redir_fd);
      else
	cprintf ("%d<&%d-", redirector, redir_fd);
      break;

    case r_move_output:
      if (redirect->rflags & REDIR_VARASSIGN)
	cprintf ("{%s}>&%d-", redir_word->word, redir_fd);
      else
	cprintf ("%d>&%d-", redirector, redir_fd);
      break;

    case r_move_input_word:
      if (redirect->rflags & REDIR_VARASSIGN)
	cprintf ("{%s}<&%s-", redir_word->word, redirectee->word);
      else
	cprintf ("%d<&%s-", redirector, redirectee->word);
      break;

    case r_move_output_word:
      if (redirect->rflags & REDIR_VARASSIGN)
	cprintf ("{%s}>&%s-", redir_word->word, redirectee->word);
      else
	cprintf ("%d>&%s-", redirector, redirectee->word);
      break;

    case r_close_this:
      if (redirect->rflags & REDIR_VARASSIGN)
	cprintf ("{%s}>&-", redir_word->word);
      else
	cprintf ("%d>&-", redirector);
      break;

    case r_err_and_out:
      cprintf ("&> %s", redirectee->word);
      break;

    case r_append_err_and_out:
      cprintf ("&>> %s", redirectee->word);
      break;
    }
}
warning: parse error {
  int redirector, redir_fd;
  WORD_DESC *redirectee, *redir_word;

  redirectee = redirect->redirectee.filename;
  redir_fd = redirect->redirectee.dest;

  redir_word = redirect->redirector.filename;
  redirector = redirect->redirector.dest;

  switch (redirect->instruction)
    {
    case r_input_direction:
      if (redirect->rflags & REDIR_VARASSIGN)
	cprintf ("{%s}", redir_word->word);
      else if (redirector != 0)
	cprintf ("%d", redirector);
      cprintf ("< %s", redirectee->word);
      break;

    case r_output_direction:
      if (redirect->rflags & REDIR_VARASSIGN)
	cprintf ("{%s}", redir_word->word);
      else if (redirector != 1)
	cprintf ("%d", redirector);
      cprintf ("> %s", redirectee->word);
      break;

    case r_inputa_direction:	/* Redirection created by the shell. */
      cprintf ("&");
      break;

    case r_output_force:
      if (redirect->rflags & REDIR_VARASSIGN)
	cprintf ("{%s}", redir_word->word);
      else if (redirector != 1)
	cprintf ("%d", redirector);
      cprintf (">| %s", redirectee->word);
      break;

    case r_appending_to:
      if (redirect->rflags & REDIR_VARASSIGN)
	cprintf ("{%s}", redir_word->word);
      else if (redirector != 1)
	cprintf ("%d", redirector);
      cprintf (">> %s", redirectee->word);
      break;

    case r_input_output:
      if (redirect->rflags & REDIR_VARASSIGN)
	cprintf ("{%s}", redir_word->word);
      else if (redirector != 1)
	cprintf ("%d", redirector);
      cprintf ("<> %s", redirectee->word);
      break;

    case r_deblank_reading_until:
    case r_reading_until:
      print_heredoc_header (redirect);
      cprintf ("\n");
      print_heredoc_body (redirect);
      break;

    case r_reading_string:
      if (redirect->rflags & REDIR_VARASSIGN)
	cprintf ("{%s}", redir_word->word);
      else if (redirector != 0)
	cprintf ("%d", redirector);
#if 0
      /* Don't need to check whether or not to requote, since original quotes
         are still intact.  The only thing that has happened is that $'...'
         has been replaced with 'expanded ...'. */
      if (ansic_shouldquote (redirect->redirectee.filename->word))
	{
	  char *x;
	  x = ansic_quote (redirect->redirectee.filename->word, 0, (int *)0);
	  cprintf ("<<< %s", x);
	  free (x);
	}
      else
#endif
	cprintf ("<<< %s", redirect->redirectee.filename->word);
      break;

    case r_duplicating_input:
      if (redirect->rflags & REDIR_VARASSIGN)
	cprintf ("{%s}<&%d", redir_word->word, redir_fd);
      else
	cprintf ("%d<&%d", redirector, redir_fd);
      break;

    case r_duplicating_output:
      if (redirect->rflags & REDIR_VARASSIGN)
	cprintf ("{%s}>&%d", redir_word->word, redir_fd);
      else
	cprintf ("%d>&%d", redirector, redir_fd);
      break;

    case r_duplicating_input_word:
      if (redirect->rflags & REDIR_VARASSIGN)
	cprintf ("{%s}<&%s", redir_word->word, redirectee->word);
      else
	cprintf ("%d<&%s", redirector, redirectee->word);
      break;

    case r_duplicating_output_word:
      if (redirect->rflags & REDIR_VARASSIGN)
	cprintf ("{%s}>&%s", redir_word->word, redirectee->word);
      else
	cprintf ("%d>&%s", redirector, redirectee->word);
      break;

    case r_move_input:
      if (redirect->rflags & REDIR_VARASSIGN)
	cprintf ("{%s}<&%d-", redir_word->word, redir_fd);
      else
	cprintf ("%d<&%d-", redirector, redir_fd);
      break;

    case r_move_output:
      if (redirect->rflags & REDIR_VARASSIGN)
	cprintf ("{%s}>&%d-", redir_word->word, redir_fd);
      else
	cprintf ("%d>&%d-", redirector, redir_fd);
      break;

    case r_move_input_word:
      if (redirect->rflags & REDIR_VARASSIGN)
	cprintf ("{%s}<&%s-", redir_word->word, redirectee->word);
      else
	cprintf ("%d<&%s-", redirector, redirectee->word);
      break;

    case r_move_output_word:
      if (redirect->rflags & REDIR_VARASSIGN)
	cprintf ("{%s}>&%s-", redir_word->word, redirectee->word);
      else
	cprintf ("%d>&%s-", redirector, redirectee->word);
      break;

    case r_close_this:
      if (redirect->rflags & REDIR_VARASSIGN)
	cprintf ("{%s}>&-", redir_word->word);
      else
	cprintf ("%d>&-", redirector);
      break;

    case r_err_and_out:
      cprintf ("&> %s", redirectee->word);
      break;

    case r_append_err_and_out:
      cprintf ("&>> %s", redirectee->word);
      break;
    }
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\print_cmd.c:1,119
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\print_cmd.c:1,286
parsing error 
{
  COMMAND *cmdcopy;
  REDIRECT *func_redirects;

  func_redirects = NULL;
  /* When in posix mode, print functions as posix specifies them. */
  if (posixly_correct == 0)
    cprintf ("function %s () \n", func->name->word);
  else
    cprintf ("%s () \n", func->name->word);
  add_unwind_protect (reset_locals, 0);

  indent (indentation);
  cprintf ("{ \n");

  inside_function_def++;
  indentation += indentation_amount;

  cmdcopy = copy_command (func->command);
  if (cmdcopy->type == cm_group)
    {
      func_redirects = cmdcopy->redirects;
      cmdcopy->redirects = (REDIRECT *)NULL;
    }
  make_command_string_internal (cmdcopy->type == cm_group
					? cmdcopy->value.Group->command
					: cmdcopy);
  PRINT_DEFERRED_HEREDOCS ("");

  remove_unwind_protect ();
  indentation -= indentation_amount;
  inside_function_def--;

  if (func_redirects)
    { /* { */
      newline ("} ");
      print_redirection_list (func_redirects);
      cmdcopy->redirects = func_redirects;
    }
  else
    newline ("}");

  dispose_command (cmdcopy);
}
warning: parse error {
  COMMAND *cmdcopy;
  REDIRECT *func_redirects;

  func_redirects = NULL;
  /* When in posix mode, print functions as posix specifies them. */
  if (posixly_correct == 0)
    cprintf ("function %s () \n", func->name->word);
  else
    cprintf ("%s () \n", func->name->word);
  add_unwind_protect (reset_locals, 0);

  indent (indentation);
  cprintf ("{ \n");

  inside_function_def++;
  indentation += indentation_amount;

  cmdcopy = copy_command (func->command);
  if (cmdcopy->type == cm_group)
    {
      func_redirects = cmdcopy->redirects;
      cmdcopy->redirects = (REDIRECT *)NULL;
    }
  make_command_string_internal (cmdcopy->type == cm_group
					? cmdcopy->value.Group->command
					: cmdcopy);
  PRINT_DEFERRED_HEREDOCS ("");

  remove_unwind_protect ();
  indentation -= indentation_amount;
  inside_function_def--;

  if (func_redirects)
    { /* { */
      newline ("} ");
      print_redirection_list (func_redirects);
      cmdcopy->redirects = func_redirects;
    }
  else
    newline ("}");

  dispose_command (cmdcopy);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\print_cmd.c:1,288
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\print_cmd.c:1,340
parsing error 
{
  char *result;
  int old_indent, old_amount;
  COMMAND *cmdcopy;
  REDIRECT *func_redirects;

  old_indent = indentation;
  old_amount = indentation_amount;
  command_string_index = was_heredoc = 0;
  deferred_heredocs = 0;

  if (name && *name)
    {
      if (find_reserved_word (name) >= 0)
	cprintf ("function ");
      cprintf ("%s ", name);
    }

  cprintf ("() ");

  if ((flags & FUNC_MULTILINE) == 0)
    {
      indentation = 1;
      indentation_amount = 0;
    }
  else
    {
      cprintf ("\n");
      indentation += indentation_amount;
    }

  inside_function_def++;

  cprintf ((flags & FUNC_MULTILINE) ? "{ \n" : "{ ");

  cmdcopy = copy_command (command);
  /* Take any redirections specified in the function definition (which should
     apply to the function as a whole) and save them for printing later. */
  func_redirects = (REDIRECT *)NULL;
  if (cmdcopy->type == cm_group)
    {
      func_redirects = cmdcopy->redirects;
      cmdcopy->redirects = (REDIRECT *)NULL;
    }
  make_command_string_internal (cmdcopy->type == cm_group
					? cmdcopy->value.Group->command
					: cmdcopy);
  PRINT_DEFERRED_HEREDOCS ("");

  indentation = old_indent;
  indentation_amount = old_amount;
  inside_function_def--;

  if (func_redirects)
    { /* { */
      newline ("} ");
      print_redirection_list (func_redirects);
      cmdcopy->redirects = func_redirects;
    }
  else
    newline ("}");

  result = the_printed_command;

  if ((flags & FUNC_MULTILINE) == 0)
    {
#if 0
      register int i;
      for (i = 0; result[i]; i++)
	if (result[i] == '\n')
	  {
	    strcpy (result + i, result + i + 1);
	    --i;
	  }
#else
      if (result[2] == '\n')	/* XXX -- experimental */
	memmove (result + 2, result + 3, strlen (result) - 2);	
#endif
    }

  dispose_command (cmdcopy);

  if (flags & FUNC_EXTERNAL)
    result = remove_quoted_escapes (result);

  return (result);
}
warning: parse error {
  char *result;
  int old_indent, old_amount;
  COMMAND *cmdcopy;
  REDIRECT *func_redirects;

  old_indent = indentation;
  old_amount = indentation_amount;
  command_string_index = was_heredoc = 0;
  deferred_heredocs = 0;

  if (name && *name)
    {
      if (find_reserved_word (name) >= 0)
	cprintf ("function ");
      cprintf ("%s ", name);
    }

  cprintf ("() ");

  if ((flags & FUNC_MULTILINE) == 0)
    {
      indentation = 1;
      indentation_amount = 0;
    }
  else
    {
      cprintf ("\n");
      indentation += indentation_amount;
    }

  inside_function_def++;

  cprintf ((flags & FUNC_MULTILINE) ? "{ \n" : "{ ");

  cmdcopy = copy_command (command);
  /* Take any redirections specified in the function definition (which should
     apply to the function as a whole) and save them for printing later. */
  func_redirects = (REDIRECT *)NULL;
  if (cmdcopy->type == cm_group)
    {
      func_redirects = cmdcopy->redirects;
      cmdcopy->redirects = (REDIRECT *)NULL;
    }
  make_command_string_internal (cmdcopy->type == cm_group
					? cmdcopy->value.Group->command
					: cmdcopy);
  PRINT_DEFERRED_HEREDOCS ("");

  indentation = old_indent;
  indentation_amount = old_amount;
  inside_function_def--;

  if (func_redirects)
    { /* { */
      newline ("} ");
      print_redirection_list (func_redirects);
      cmdcopy->redirects = func_redirects;
    }
  else
    newline ("}");

  result = the_printed_command;

  if ((flags & FUNC_MULTILINE) == 0)
    {
#if 0
      register int i;
      for (i = 0; result[i]; i++)
	if (result[i] == '\n')
	  {
	    strcpy (result + i, result + i + 1);
	    --i;
	  }
#else
      if (result[2] == '\n')	/* XXX -- experimental */
	memmove (result + 2, result + 3, strlen (result) - 2);	
#endif
    }

  dispose_command (cmdcopy);

  if (flags & FUNC_EXTERNAL)
    result = remove_quoted_escapes (result);

  return (result);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\print_cmd.c:1,344
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\print_cmd.c:1,433
parsing error 
{
  cprintf ("\n");
  indent (indentation);
  if (string && *string)
    cprintf ("%s", string);
}
warning: parse error {
  cprintf ("\n");
  indent (indentation);
  if (string && *string)
    cprintf ("%s", string);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\print_cmd.c:1,435
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\print_cmd.c:1,446
parsing error 
{
  register int i;

  RESIZE_MALLOCED_BUFFER (indentation_string, 0, amount, indentation_size, 16);

  for (i = 0; amount > 0; amount--)
    indentation_string[i++] = ' ';
  indentation_string[i] = '\0';
  cprintf ("%s", indentation_string);
}
warning: parse error {
  register int i;

  RESIZE_MALLOCED_BUFFER (indentation_string, 0, amount, indentation_size, 16);

  for (i = 0; amount > 0; amount--)
    indentation_string[i++] = ' ';
  indentation_string[i] = '\0';
  cprintf ("%s", indentation_string);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\print_cmd.c:1,448
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\print_cmd.c:1,475
parsing error 
va_dcl
#endif
{
  register const char *s;
  char char_arg[2], *argp, intbuf[INT_STRLEN_BOUND (unsigned int) + 1];
  int digit_arg, arg_len, c;
  va_list args;

  SH_VA_START (args, control);

  arg_len = strlen (control);
  the_printed_command_resize (arg_len + 1);

  char_arg[1] = '\0';
  s = control;
  while (s && *s)
    {
      c = *s++;
      argp = (char *)NULL;
      if (c != '%' || !*s)
	{
	  char_arg[0] = c;
	  argp = char_arg;
	  arg_len = 1;
	}
      else
	{
	  c = *s++;
	  switch (c)
	    {
	    case '%':
	      char_arg[0] = c;
	      argp = char_arg;
	      arg_len = 1;
	      break;

	    case 's':
	      argp = va_arg (args, char *);
	      arg_len = strlen (argp);
	      break;

	    case 'd':
	      /* Represent an out-of-range file descriptor with an out-of-range
		 integer value.  We can do this because the only use of `%d' in
		 the calls to cprintf is to output a file descriptor number for
		 a redirection. */
	      digit_arg = va_arg (args, int);
	      if (digit_arg < 0)
		{
		  sprintf (intbuf, "%u", (unsigned int)-1);
		  argp = intbuf;
		}
	      else
		argp = inttostr (digit_arg, intbuf, sizeof (intbuf));
	      arg_len = strlen (argp);
	      break;

	    case 'c':
	      char_arg[0] = va_arg (args, int);
	      argp = char_arg;
	      arg_len = 1;
	      break;

	    default:
	      programming_error (_("cprintf: `%c': invalid format character"), c);
	      /*NOTREACHED*/
	    }
	}

      if (argp && arg_len)
	{
	  the_printed_command_resize (arg_len + 1);
	  FASTCOPY (argp, the_printed_command + command_string_index, arg_len);
	  command_string_index += arg_len;
	}
    }

  va_end (args);

  the_printed_command[command_string_index] = '\0';
}
warning: parse error va_dcl
#endif
{
  register const char *s;
  char char_arg[2], *argp, intbuf[INT_STRLEN_BOUND (unsigned int) + 1];
  int digit_arg, arg_len, c;
  va_list args;

  SH_VA_START (args, control);

  arg_len = strlen (control);
  the_printed_command_resize (arg_len + 1);

  char_arg[1] = '\0';
  s = control;
  while (s && *s)
    {
      c = *s++;
      argp = (char *)NULL;
      if (c != '%' || !*s)
	{
	  char_arg[0] = c;
	  argp = char_arg;
	  arg_len = 1;
	}
      else
	{
	  c = *s++;
	  switch (c)
	    {
	    case '%':
	      char_arg[0] = c;
	      argp = char_arg;
	      arg_len = 1;
	      break;

	    case 's':
	      argp = va_arg (args, char *);
	      arg_len = strlen (argp);
	      break;

	    case 'd':
	      /* Represent an out-of-range file descriptor with an out-of-range
		 integer value.  We can do this because the only use of `%d' in
		 the calls to cprintf is to output a file descriptor number for
		 a redirection. */
	      digit_arg = va_arg (args, int);
	      if (digit_arg < 0)
		{
		  sprintf (intbuf, "%u", (unsigned int)-1);
		  argp = intbuf;
		}
	      else
		argp = inttostr (digit_arg, intbuf, sizeof (intbuf));
	      arg_len = strlen (argp);
	      break;

	    case 'c':
	      char_arg[0] = va_arg (args, int);
	      argp = char_arg;
	      arg_len = 1;
	      break;

	    default:
	      programming_error (_("cprintf: `%c': invalid format character"), c);
	      /*NOTREACHED*/
	    }
	}

      if (argp && arg_len)
	{
	  the_printed_command_resize (arg_len + 1);
	  FASTCOPY (argp, the_printed_command + command_string_index, arg_len);
	  command_string_index += arg_len;
	}
    }

  va_end (args);

  the_printed_command[command_string_index] = '\0';
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\print_cmd.c:1,476
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\print_cmd.c:1,561
parsing error 
{
  if (the_printed_command == 0)
    {
      the_printed_command_size = (length + PRINTED_COMMAND_INITIAL_SIZE - 1) & ~(PRINTED_COMMAND_INITIAL_SIZE - 1);
      the_printed_command = (char *)xmalloc (the_printed_command_size);
      command_string_index = 0;
    }
  else if ((command_string_index + length) >= the_printed_command_size)
    {
      int new;
      new = command_string_index + length + 1;

      /* Round up to the next multiple of PRINTED_COMMAND_GROW_SIZE. */
      new = (new + PRINTED_COMMAND_GROW_SIZE - 1) & ~(PRINTED_COMMAND_GROW_SIZE - 1);
      the_printed_command_size = new;

      the_printed_command = (char *)xrealloc (the_printed_command, the_printed_command_size);
    }
}
warning: parse error {
  if (the_printed_command == 0)
    {
      the_printed_command_size = (length + PRINTED_COMMAND_INITIAL_SIZE - 1) & ~(PRINTED_COMMAND_INITIAL_SIZE - 1);
      the_printed_command = (char *)xmalloc (the_printed_command_size);
      command_string_index = 0;
    }
  else if ((command_string_index + length) >= the_printed_command_size)
    {
      int new;
      new = command_string_index + length + 1;

      /* Round up to the next multiple of PRINTED_COMMAND_GROW_SIZE. */
      new = (new + PRINTED_COMMAND_GROW_SIZE - 1) & ~(PRINTED_COMMAND_GROW_SIZE - 1);
      the_printed_command_size = new;

      the_printed_command = (char *)xrealloc (the_printed_command, the_printed_command_size);
    }
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\print_cmd.c:1,563
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\print_cmd.c:1,608
parsing error 
{
  printf (format, arg1, arg2, arg3, arg4, arg5);
}
warning: parse error {
  printf (format, arg1, arg2, arg3, arg4, arg5);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\print_cmd.c:1,609
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\redir.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashtypes.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\filecntl.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\posixstat.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashansi.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashintl.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\memalloc.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\shell.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\flags.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\execute_cmd.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\redir.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\trap.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\redir.c:135
parsing error 
{
  char *filename, *allocname;
  int oflags;

  allocname = 0;
  if ((temp->rflags & REDIR_VARASSIGN) && error < 0)
    filename = allocname = savestring (temp->redirector.filename->word);
  else if ((temp->rflags & REDIR_VARASSIGN) == 0 && temp->redirector.dest < 0)
    /* This can happen when read_token_word encounters overflow, like in
       exec 4294967297>x */
    filename = _("file descriptor out of range");
#ifdef EBADF
  /* This error can never involve NOCLOBBER */
  else if (error != NOCLOBBER_REDIRECT && temp->redirector.dest >= 0 && error == EBADF)
    {
      /* If we're dealing with two file descriptors, we have to guess about
         which one is invalid; in the cases of r_{duplicating,move}_input and
         r_{duplicating,move}_output we're here because dup2() failed. */
      switch (temp->instruction)
        {
        case r_duplicating_input:
        case r_duplicating_output:
        case r_move_input:
        case r_move_output:
	  filename = allocname = itos (temp->redirectee.dest);
	  break;
	case r_duplicating_input_word:
	  if (temp->redirector.dest == 0)	/* Guess */
	    filename = temp->redirectee.filename->word;	/* XXX */
	  else
	    filename = allocname = itos (temp->redirector.dest);
	  break;
	case r_duplicating_output_word:
	  if (temp->redirector.dest == 1)	/* Guess */
	    filename = temp->redirectee.filename->word;	/* XXX */
	  else
	    filename = allocname = itos (temp->redirector.dest);
	  break;
	default:
	  filename = allocname = itos (temp->redirector.dest);
	  break;
        }
    }
#endif
  else if (fn)
    filename = fn;
  else if (expandable_redirection_filename (temp))
    {
      oflags = temp->redirectee.filename->flags;
      if (posixly_correct && interactive_shell == 0)
	temp->redirectee.filename->flags |= W_NOGLOB;
      temp->redirectee.filename->flags |= W_NOCOMSUB;
      filename = allocname = redirection_expand (temp->redirectee.filename);
      temp->redirectee.filename->flags = oflags;
      if (filename == 0)
	filename = temp->redirectee.filename->word;
    }
  else if (temp->redirectee.dest < 0)
    filename = _("file descriptor out of range");
  else
    filename = allocname = itos (temp->redirectee.dest);

  switch (error)
    {
    case AMBIGUOUS_REDIRECT:
      internal_error (_("%s: ambiguous redirect"), filename);
      break;

    case NOCLOBBER_REDIRECT:
      internal_error (_("%s: cannot overwrite existing file"), filename);
      break;

#if defined (RESTRICTED_SHELL)
    case RESTRICTED_REDIRECT:
      internal_error (_("%s: restricted: cannot redirect output"), filename);
      break;
#endif /* RESTRICTED_SHELL */

    case HEREDOC_REDIRECT:
      internal_error (_("cannot create temp file for here-document: %s"), strerror (heredoc_errno));
      break;

    case BADVAR_REDIRECT:
      internal_error (_("%s: cannot assign fd to variable"), filename);
      break;

    default:
      internal_error ("%s: %s", filename, strerror (error));
      break;
    }

  FREE (allocname);
}
warning: parse error {
  char *filename, *allocname;
  int oflags;

  allocname = 0;
  if ((temp->rflags & REDIR_VARASSIGN) && error < 0)
    filename = allocname = savestring (temp->redirector.filename->word);
  else if ((temp->rflags & REDIR_VARASSIGN) == 0 && temp->redirector.dest < 0)
    /* This can happen when read_token_word encounters overflow, like in
       exec 4294967297>x */
    filename = _("file descriptor out of range");
#ifdef EBADF
  /* This error can never involve NOCLOBBER */
  else if (error != NOCLOBBER_REDIRECT && temp->redirector.dest >= 0 && error == EBADF)
    {
      /* If we're dealing with two file descriptors, we have to guess about
         which one is invalid; in the cases of r_{duplicating,move}_input and
         r_{duplicating,move}_output we're here because dup2() failed. */
      switch (temp->instruction)
        {
        case r_duplicating_input:
        case r_duplicating_output:
        case r_move_input:
        case r_move_output:
	  filename = allocname = itos (temp->redirectee.dest);
	  break;
	case r_duplicating_input_word:
	  if (temp->redirector.dest == 0)	/* Guess */
	    filename = temp->redirectee.filename->word;	/* XXX */
	  else
	    filename = allocname = itos (temp->redirector.dest);
	  break;
	case r_duplicating_output_word:
	  if (temp->redirector.dest == 1)	/* Guess */
	    filename = temp->redirectee.filename->word;	/* XXX */
	  else
	    filename = allocname = itos (temp->redirector.dest);
	  break;
	default:
	  filename = allocname = itos (temp->redirector.dest);
	  break;
        }
    }
#endif
  else if (fn)
    filename = fn;
  else if (expandable_redirection_filename (temp))
    {
      oflags = temp->redirectee.filename->flags;
      if (posixly_correct && interactive_shell == 0)
	temp->redirectee.filename->flags |= W_NOGLOB;
      temp->redirectee.filename->flags |= W_NOCOMSUB;
      filename = allocname = redirection_expand (temp->redirectee.filename);
      temp->redirectee.filename->flags = oflags;
      if (filename == 0)
	filename = temp->redirectee.filename->word;
    }
  else if (temp->redirectee.dest < 0)
    filename = _("file descriptor out of range");
  else
    filename = allocname = itos (temp->redirectee.dest);

  switch (error)
    {
    case AMBIGUOUS_REDIRECT:
      internal_error (_("%s: ambiguous redirect"), filename);
      break;

    case NOCLOBBER_REDIRECT:
      internal_error (_("%s: cannot overwrite existing file"), filename);
      break;

#if defined (RESTRICTED_SHELL)
    case RESTRICTED_REDIRECT:
      internal_error (_("%s: restricted: cannot redirect output"), filename);
      break;
#endif /* RESTRICTED_SHELL */

    case HEREDOC_REDIRECT:
      internal_error (_("cannot create temp file for here-document: %s"), strerror (heredoc_errno));
      break;

    case BADVAR_REDIRECT:
      internal_error (_("%s: cannot assign fd to variable"), filename);
      break;

    default:
      internal_error ("%s: %s", filename, strerror (error));
      break;
    }

  FREE (allocname);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\redir.c:139
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\redir.c:240
parsing error 
{
  int error;
  REDIRECT *temp;
  char *fn;

  if (flags & RX_UNDOABLE)
    {
      if (redirection_undo_list)
	{
	  dispose_redirects (redirection_undo_list);
	  redirection_undo_list = (REDIRECT *)NULL;
	}
      if (exec_redirection_undo_list)
	dispose_exec_redirects ();
    }

  for (temp = list; temp; temp = temp->next)
    {
      fn = 0;
      error = do_redirection_internal (temp, flags, &fn);
      if (error)
	{
	  redirection_error (temp, error, fn);
	  FREE (fn);
	  return (error);
	}
      FREE (fn);
    }
  return (0);
}
warning: parse error {
  int error;
  REDIRECT *temp;
  char *fn;

  if (flags & RX_UNDOABLE)
    {
      if (redirection_undo_list)
	{
	  dispose_redirects (redirection_undo_list);
	  redirection_undo_list = (REDIRECT *)NULL;
	}
      if (exec_redirection_undo_list)
	dispose_exec_redirects ();
    }

  for (temp = list; temp; temp = temp->next)
    {
      fn = 0;
      error = do_redirection_internal (temp, flags, &fn);
      if (error)
	{
	  redirection_error (temp, error, fn);
	  FREE (fn);
	  return (error);
	}
      FREE (fn);
    }
  return (0);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\redir.c:243
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\redir.c:277
parsing error 
{
  switch (redirect->instruction)
    {
    case r_output_direction:
    case r_appending_to:
    case r_input_direction:
    case r_inputa_direction:
    case r_err_and_out:
    case r_append_err_and_out:
    case r_input_output:
    case r_output_force:
    case r_duplicating_input_word:
    case r_duplicating_output_word:
    case r_move_input_word:
    case r_move_output_word:
      return 1;

    default:
      return 0;
    }
}
warning: parse error {
  switch (redirect->instruction)
    {
    case r_output_direction:
    case r_appending_to:
    case r_input_direction:
    case r_inputa_direction:
    case r_err_and_out:
    case r_append_err_and_out:
    case r_input_output:
    case r_output_force:
    case r_duplicating_input_word:
    case r_duplicating_output_word:
    case r_move_input_word:
    case r_move_output_word:
      return 1;

    default:
      return 0;
    }
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\redir.c:279
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\redir.c:304
parsing error 
{
  char *result;
  WORD_LIST *tlist1, *tlist2;
  WORD_DESC *w;
  int old;

  w = copy_word (word);
  if (posixly_correct)
    w->flags |= W_NOSPLIT;

  tlist1 = make_word_list (w, (WORD_LIST *)NULL);
  expanding_redir = 1;
  /* Now that we've changed the variable search order to ignore the temp
     environment, see if we need to change the cached IFS values. */
  sv_ifs ("IFS");
  tlist2 = expand_words_no_vars (tlist1);
  expanding_redir = 0;
  /* Now we need to change the variable search order back to include the temp
     environment.  We force the temp environment search by forcing
     executing_builtin to 1.  This is what makes `read' get the right values
     for the IFS-related cached variables, for example. */
  old = executing_builtin;
  executing_builtin = 1;
  sv_ifs ("IFS");
  executing_builtin = old;
  dispose_words (tlist1);

  if (tlist2 == 0 || tlist2->next)
    {
      /* We expanded to no words, or to more than a single word.
	 Dispose of the word list and return NULL. */
      if (tlist2)
	dispose_words (tlist2);
      return ((char *)NULL);
    }
  result = string_list (tlist2);  /* XXX savestring (tlist2->word->word)? */
  dispose_words (tlist2);
  return (result);
}
warning: parse error {
  char *result;
  WORD_LIST *tlist1, *tlist2;
  WORD_DESC *w;
  int old;

  w = copy_word (word);
  if (posixly_correct)
    w->flags |= W_NOSPLIT;

  tlist1 = make_word_list (w, (WORD_LIST *)NULL);
  expanding_redir = 1;
  /* Now that we've changed the variable search order to ignore the temp
     environment, see if we need to change the cached IFS values. */
  sv_ifs ("IFS");
  tlist2 = expand_words_no_vars (tlist1);
  expanding_redir = 0;
  /* Now we need to change the variable search order back to include the temp
     environment.  We force the temp environment search by forcing
     executing_builtin to 1.  This is what makes `read' get the right values
     for the IFS-related cached variables, for example. */
  old = executing_builtin;
  executing_builtin = 1;
  sv_ifs ("IFS");
  executing_builtin = old;
  dispose_words (tlist1);

  if (tlist2 == 0 || tlist2->next)
    {
      /* We expanded to no words, or to more than a single word.
	 Dispose of the word list and return NULL. */
      if (tlist2)
	dispose_words (tlist2);
      return ((char *)NULL);
    }
  result = string_list (tlist2);  /* XXX savestring (tlist2->word->word)? */
  dispose_words (tlist2);
  return (result);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\redir.c:306
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\redir.c:355
parsing error 
{
  char *document;
  size_t dlen;
  int old;

  if (redirectee->word == 0 || redirectee->word[0] == '\0')
    {
      if (lenp)
        *lenp = 0;
      return (redirectee->word);
    }

  /* Quoted here documents are not expanded */
  if (ri != r_reading_string && (redirectee->flags & W_QUOTED))
    {
      if (lenp)
        *lenp = STRLEN (redirectee->word);
      return (redirectee->word);
    }
  
  expanding_redir = 1;
  /* Now that we've changed the variable search order to ignore the temp
     environment, see if we need to change the cached IFS values. */
  sv_ifs ("IFS");
  document = (ri == r_reading_string) ? expand_assignment_string_to_string (redirectee->word, 0)
  				      : expand_string_to_string (redirectee->word, Q_HERE_DOCUMENT);
  expanding_redir = 0;
  /* Now we need to change the variable search order back to include the temp
     environment.  We force the temp environment search by forcing
     executing_builtin to 1.  This is what makes `read' get the right values
     for the IFS-related cached variables, for example. */
  old = executing_builtin;
  executing_builtin = 1;
  sv_ifs ("IFS");
  executing_builtin = old;

  dlen = STRLEN (document);
  /* XXX - Add trailing newline to here-string */
  if (ri == r_reading_string)
    {
      document = xrealloc (document, dlen + 2);
      document[dlen++] = '\n';
      document[dlen] = '\0';
    }
  if (lenp)
    *lenp = dlen;    

  return document;
}
warning: parse error {
  char *document;
  size_t dlen;
  int old;

  if (redirectee->word == 0 || redirectee->word[0] == '\0')
    {
      if (lenp)
        *lenp = 0;
      return (redirectee->word);
    }

  /* Quoted here documents are not expanded */
  if (ri != r_reading_string && (redirectee->flags & W_QUOTED))
    {
      if (lenp)
        *lenp = STRLEN (redirectee->word);
      return (redirectee->word);
    }
  
  expanding_redir = 1;
  /* Now that we've changed the variable search order to ignore the temp
     environment, see if we need to change the cached IFS values. */
  sv_ifs ("IFS");
  document = (ri == r_reading_string) ? expand_assignment_string_to_string (redirectee->word, 0)
  				      : expand_string_to_string (redirectee->word, Q_HERE_DOCUMENT);
  expanding_redir = 0;
  /* Now we need to change the variable search order back to include the temp
     environment.  We force the temp environment search by forcing
     executing_builtin to 1.  This is what makes `read' get the right values
     for the IFS-related cached variables, for example. */
  old = executing_builtin;
  executing_builtin = 1;
  sv_ifs ("IFS");
  executing_builtin = old;

  dlen = STRLEN (document);
  /* XXX - Add trailing newline to here-string */
  if (ri == r_reading_string)
    {
      document = xrealloc (document, dlen + 2);
      document[dlen++] = '\n';
      document[dlen] = '\0';
    }
  if (lenp)
    *lenp = dlen;    

  return document;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\redir.c:359
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\redir.c:412
parsing error 
{
  ssize_t nw;
  int e;

  errno = 0;
  nw = write (fd, heredoc, herelen);
  e = errno;
  if (nw != herelen)
    {
      if (e == 0)
	e = ENOSPC;
      return e;
    }
  return 0;
}
warning: parse error {
  ssize_t nw;
  int e;

  errno = 0;
  nw = write (fd, heredoc, herelen);
  e = errno;
  if (nw != herelen)
    {
      if (e == 0)
	e = ENOSPC;
      return e;
    }
  return 0;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\redir.c:416
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\redir.c:436
parsing error 
{
  char *filename;
  int r, fd, fd2, herepipe[2];
  char *document;
  size_t document_len;
#if HEREDOC_PARANOID
  struct stat st1, st2;
#endif

  /* Expand the here-document/here-string first and then decide what to do. */
  document = heredoc_expand (redirectee, ri, &document_len);

  /* If we have a zero-length document, don't mess with a temp file */
  if (document_len == 0)
    {
      fd = open ("/dev/null", O_RDONLY);
      r = errno;
      if (document != redirectee->word)
	FREE (document);
      errno = r;
      return fd;
    }

#if defined (HEREDOC_PIPESIZE)
  /* Try to use a pipe internal to this process if the document is shorter
     than the system's pipe capacity (computed at build time). We want to
     write the entire document without write blocking. */
  if (document_len <= HEREDOC_PIPESIZE)
    {
      if (pipe (herepipe) < 0)
	{
	  r = errno;
	  if (document != redirectee->word)
	    free (document);
	  errno = r;
	  return (-1);
	}

#if defined (F_GETPIPE_SZ)
      if (fcntl (herepipe[1], F_GETPIPE_SZ, 0) < document_len)
	goto use_tempfile;
#endif

      r = heredoc_write (herepipe[1], document, document_len);
      if (document != redirectee->word)
	free (document);
      close (herepipe[1]);
      if (r)			/* write error */
	{
	  close (herepipe[0]);
	  errno = r;
	  return (-1);
	}
      return (herepipe[0]);
    }
#endif

use_tempfile:

  fd = sh_mktmpfd ("sh-thd", MT_USERANDOM|MT_USETMPDIR, &filename);

  /* If we failed for some reason other than the file existing, abort */
  if (fd < 0)
    {
      r = errno;
      FREE (filename);
      if (document != redirectee->word)
	FREE (document);
      errno = r;
      return (fd);
    }

  fchmod (fd, S_IRUSR | S_IWUSR);
  SET_CLOSE_ON_EXEC (fd);

  errno = r = 0;		/* XXX */
  r = heredoc_write (fd, document, document_len);
  if (document != redirectee->word)
    FREE (document);

  if (r)
    {
      close (fd);
      unlink (filename);
      free (filename);
      errno = r;
      return (-1);
    }

  /* In an attempt to avoid races, we close the first fd only after opening
     the second. */
  /* Make the document really temporary.  Also make it the input. */
  fd2 = open (filename, O_RDONLY|O_BINARY, 0600);

  if (fd2 < 0)
    {
      r = errno;
      unlink (filename);
      free (filename);
      close (fd);
      errno = r;
      return -1;
    }

#if HEREDOC_PARANOID
  /* We can use same_file here to check whether or not fd and fd2 refer to
     the same file, but we don't do that unless HEREDOC_PARANOID is defined. */
  if (fstat (fd, &st1) < 0 || S_ISREG (st1.st_mode) == 0 ||
      fstat (fd2, &st2) < 0 || S_ISREG (st2.st_mode) == 0 ||
      same_file (filename, filename, &st1, &st2) == 0)
    {
      unlink (filename);
      free (filename);
      close (fd);
      close (fd2);
      errno = EEXIST;
      return -1;
    }
#endif

  close (fd);
  if (unlink (filename) < 0)
    {
      r = errno;
      close (fd2);
      free (filename);
      errno = r;
      return (-1);
    }

  free (filename);

  fchmod (fd2, S_IRUSR);
  return (fd2);
}
warning: parse error {
  char *filename;
  int r, fd, fd2, herepipe[2];
  char *document;
  size_t document_len;
#if HEREDOC_PARANOID
  struct stat st1, st2;
#endif

  /* Expand the here-document/here-string first and then decide what to do. */
  document = heredoc_expand (redirectee, ri, &document_len);

  /* If we have a zero-length document, don't mess with a temp file */
  if (document_len == 0)
    {
      fd = open ("/dev/null", O_RDONLY);
      r = errno;
      if (document != redirectee->word)
	FREE (document);
      errno = r;
      return fd;
    }

#if defined (HEREDOC_PIPESIZE)
  /* Try to use a pipe internal to this process if the document is shorter
     than the system's pipe capacity (computed at build time). We want to
     write the entire document without write blocking. */
  if (document_len <= HEREDOC_PIPESIZE)
    {
      if (pipe (herepipe) < 0)
	{
	  r = errno;
	  if (document != redirectee->word)
	    free (document);
	  errno = r;
	  return (-1);
	}

#if defined (F_GETPIPE_SZ)
      if (fcntl (herepipe[1], F_GETPIPE_SZ, 0) < document_len)
	goto use_tempfile;
#endif

      r = heredoc_write (herepipe[1], document, document_len);
      if (document != redirectee->word)
	free (document);
      close (herepipe[1]);
      if (r)			/* write error */
	{
	  close (herepipe[0]);
	  errno = r;
	  return (-1);
	}
      return (herepipe[0]);
    }
#endif

use_tempfile:

  fd = sh_mktmpfd ("sh-thd", MT_USERANDOM|MT_USETMPDIR, &filename);

  /* If we failed for some reason other than the file existing, abort */
  if (fd < 0)
    {
      r = errno;
      FREE (filename);
      if (document != redirectee->word)
	FREE (document);
      errno = r;
      return (fd);
    }

  fchmod (fd, S_IRUSR | S_IWUSR);
  SET_CLOSE_ON_EXEC (fd);

  errno = r = 0;		/* XXX */
  r = heredoc_write (fd, document, document_len);
  if (document != redirectee->word)
    FREE (document);

  if (r)
    {
      close (fd);
      unlink (filename);
      free (filename);
      errno = r;
      return (-1);
    }

  /* In an attempt to avoid races, we close the first fd only after opening
     the second. */
  /* Make the document really temporary.  Also make it the input. */
  fd2 = open (filename, O_RDONLY|O_BINARY, 0600);

  if (fd2 < 0)
    {
      r = errno;
      unlink (filename);
      free (filename);
      close (fd);
      errno = r;
      return -1;
    }

#if HEREDOC_PARANOID
  /* We can use same_file here to check whether or not fd and fd2 refer to
     the same file, but we don't do that unless HEREDOC_PARANOID is defined. */
  if (fstat (fd, &st1) < 0 || S_ISREG (st1.st_mode) == 0 ||
      fstat (fd2, &st2) < 0 || S_ISREG (st2.st_mode) == 0 ||
      same_file (filename, filename, &st1, &st2) == 0)
    {
      unlink (filename);
      free (filename);
      close (fd);
      close (fd2);
      errno = EEXIST;
      return -1;
    }
#endif

  close (fd);
  if (unlink (filename) < 0)
    {
      r = errno;
      close (fd2);
      free (filename);
      errno = r;
      return (-1);
    }

  free (filename);

  fchmod (fd2, S_IRUSR);
  return (fd2);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\redir.c:439
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\redir.c:601
parsing error 
{
  int fd;
#if !defined (HAVE_DEV_FD)
  intmax_t lfd;
#endif

  fd = -1;
  switch (spec)
    {
#if !defined (HAVE_DEV_FD)
    case RF_DEVFD:
      if (all_digits (filename+8) && legal_number (filename+8, &lfd) && lfd == (int)lfd)
	{
	  fd = lfd;
	  fd = fcntl (fd, F_DUPFD, SHELL_FD_BASE);
	}
      else
	fd = AMBIGUOUS_REDIRECT;
      break;
#endif

#if !defined (HAVE_DEV_STDIN)
    case RF_DEVSTDIN:
      fd = fcntl (0, F_DUPFD, SHELL_FD_BASE);
      break;
    case RF_DEVSTDOUT:
      fd = fcntl (1, F_DUPFD, SHELL_FD_BASE);
      break;
    case RF_DEVSTDERR:
      fd = fcntl (2, F_DUPFD, SHELL_FD_BASE);
      break;
#endif

#if defined (NETWORK_REDIRECTIONS)
    case RF_DEVTCP:
    case RF_DEVUDP:
#if defined (RESTRICTED_SHELL)
      if (restricted)
	return (RESTRICTED_REDIRECT);
#endif
#if defined (HAVE_NETWORK)
      fd = netopen (filename);
#else
      internal_warning (_("/dev/(tcp|udp)/host/port not supported without networking"));
      fd = open (filename, flags, mode);
#endif
      break;
#endif /* NETWORK_REDIRECTIONS */
    }

  return fd;
}
warning: parse error {
  int fd;
#if !defined (HAVE_DEV_FD)
  intmax_t lfd;
#endif

  fd = -1;
  switch (spec)
    {
#if !defined (HAVE_DEV_FD)
    case RF_DEVFD:
      if (all_digits (filename+8) && legal_number (filename+8, &lfd) && lfd == (int)lfd)
	{
	  fd = lfd;
	  fd = fcntl (fd, F_DUPFD, SHELL_FD_BASE);
	}
      else
	fd = AMBIGUOUS_REDIRECT;
      break;
#endif

#if !defined (HAVE_DEV_STDIN)
    case RF_DEVSTDIN:
      fd = fcntl (0, F_DUPFD, SHELL_FD_BASE);
      break;
    case RF_DEVSTDOUT:
      fd = fcntl (1, F_DUPFD, SHELL_FD_BASE);
      break;
    case RF_DEVSTDERR:
      fd = fcntl (2, F_DUPFD, SHELL_FD_BASE);
      break;
#endif

#if defined (NETWORK_REDIRECTIONS)
    case RF_DEVTCP:
    case RF_DEVUDP:
#if defined (RESTRICTED_SHELL)
      if (restricted)
	return (RESTRICTED_REDIRECT);
#endif
#if defined (HAVE_NETWORK)
      fd = netopen (filename);
#else
      internal_warning (_("/dev/(tcp|udp)/host/port not supported without networking"));
      fd = open (filename, flags, mode);
#endif
      break;
#endif /* NETWORK_REDIRECTIONS */
    }

  return fd;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\redir.c:606
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\redir.c:663
parsing error 
{
  int r, fd;
  struct stat finfo, finfo2;

  /* If the file exists and is a regular file, return an error
     immediately. */
  r = stat (filename, &finfo);
  if (r == 0 && (S_ISREG (finfo.st_mode)))
    return (NOCLOBBER_REDIRECT);

  /* If the file was not present (r != 0), make sure we open it
     exclusively so that if it is created before we open it, our open
     will fail.  Make sure that we do not truncate an existing file.
     Note that we don't turn on O_EXCL unless the stat failed -- if
     the file was not a regular file, we leave O_EXCL off. */
  flags &= ~O_TRUNC;
  if (r != 0)
    {
      fd = open (filename, flags|O_EXCL, mode);
      return ((fd < 0 && errno == EEXIST) ? NOCLOBBER_REDIRECT : fd);
    }
  fd = open (filename, flags, mode);

  /* If the open failed, return the file descriptor right away. */
  if (fd < 0)
    return (errno == EEXIST ? NOCLOBBER_REDIRECT : fd);

  /* OK, the open succeeded, but the file may have been changed from a
     non-regular file to a regular file between the stat and the open.
     We are assuming that the O_EXCL open handles the case where FILENAME
     did not exist and is symlinked to an existing file between the stat
     and open. */

  /* If we can open it and fstat the file descriptor, and neither check
     revealed that it was a regular file, and the file has not been replaced,
     return the file descriptor. */
  if ((fstat (fd, &finfo2) == 0) && (S_ISREG (finfo2.st_mode) == 0) &&
      r == 0 && (S_ISREG (finfo.st_mode) == 0) &&
      same_file (filename, filename, &finfo, &finfo2))
    return fd;

  /* The file has been replaced.  badness. */
  close (fd);  
  errno = EEXIST;
  return (NOCLOBBER_REDIRECT);
}
warning: parse error {
  int r, fd;
  struct stat finfo, finfo2;

  /* If the file exists and is a regular file, return an error
     immediately. */
  r = stat (filename, &finfo);
  if (r == 0 && (S_ISREG (finfo.st_mode)))
    return (NOCLOBBER_REDIRECT);

  /* If the file was not present (r != 0), make sure we open it
     exclusively so that if it is created before we open it, our open
     will fail.  Make sure that we do not truncate an existing file.
     Note that we don't turn on O_EXCL unless the stat failed -- if
     the file was not a regular file, we leave O_EXCL off. */
  flags &= ~O_TRUNC;
  if (r != 0)
    {
      fd = open (filename, flags|O_EXCL, mode);
      return ((fd < 0 && errno == EEXIST) ? NOCLOBBER_REDIRECT : fd);
    }
  fd = open (filename, flags, mode);

  /* If the open failed, return the file descriptor right away. */
  if (fd < 0)
    return (errno == EEXIST ? NOCLOBBER_REDIRECT : fd);

  /* OK, the open succeeded, but the file may have been changed from a
     non-regular file to a regular file between the stat and the open.
     We are assuming that the O_EXCL open handles the case where FILENAME
     did not exist and is symlinked to an existing file between the stat
     and open. */

  /* If we can open it and fstat the file descriptor, and neither check
     revealed that it was a regular file, and the file has not been replaced,
     return the file descriptor. */
  if ((fstat (fd, &finfo2) == 0) && (S_ISREG (finfo2.st_mode) == 0) &&
      r == 0 && (S_ISREG (finfo.st_mode) == 0) &&
      same_file (filename, filename, &finfo, &finfo2))
    return fd;

  /* The file has been replaced.  badness. */
  close (fd);  
  errno = EEXIST;
  return (NOCLOBBER_REDIRECT);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\redir.c:667
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\redir.c:715
parsing error 
{
  int fd, r, e;

  r = find_string_in_alist (filename, _redir_special_filenames, 1);
  if (r >= 0)
    return (redir_special_open (r, filename, flags, mode, ri));

  /* If we are in noclobber mode, you are not allowed to overwrite
     existing files.  Check before opening. */
  if (noclobber && CLOBBERING_REDIRECT (ri))
    {
      fd = noclobber_open (filename, flags, mode, ri);
      if (fd == NOCLOBBER_REDIRECT)
	return (NOCLOBBER_REDIRECT);
    }
  else
    {
      do
	{
	  fd = open (filename, flags, mode);
	  e = errno;
	  if (fd < 0 && e == EINTR)
	    {
	      QUIT;
	      run_pending_traps ();
	    }
	  errno = e;
	}
      while (fd < 0 && errno == EINTR);

#if defined (AFS)
      if ((fd < 0) && (errno == EACCES))
	{
	  fd = open (filename, flags & ~O_CREAT, mode);
	  errno = EACCES;	/* restore errno */
	}
#endif /* AFS */
    }

  return fd;
}
warning: parse error {
  int fd, r, e;

  r = find_string_in_alist (filename, _redir_special_filenames, 1);
  if (r >= 0)
    return (redir_special_open (r, filename, flags, mode, ri));

  /* If we are in noclobber mode, you are not allowed to overwrite
     existing files.  Check before opening. */
  if (noclobber && CLOBBERING_REDIRECT (ri))
    {
      fd = noclobber_open (filename, flags, mode, ri);
      if (fd == NOCLOBBER_REDIRECT)
	return (NOCLOBBER_REDIRECT);
    }
  else
    {
      do
	{
	  fd = open (filename, flags, mode);
	  e = errno;
	  if (fd < 0 && e == EINTR)
	    {
	      QUIT;
	      run_pending_traps ();
	    }
	  errno = e;
	}
      while (fd < 0 && errno == EINTR);

#if defined (AFS)
      if ((fd < 0) && (errno == EACCES))
	{
	  fd = open (filename, flags & ~O_CREAT, mode);
	  errno = EACCES;	/* restore errno */
	}
#endif /* AFS */
    }

  return fd;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\redir.c:719
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\redir.c:762
parsing error 
{
  int clexec;

  clexec = fcntl (fd, F_GETFD, 0);
  if (clexec == -1 || (fd >= SHELL_FD_BASE && clexec == 1))
    return 0;
  return 1;
}
warning: parse error {
  int clexec;

  clexec = fcntl (fd, F_GETFD, 0);
  if (clexec == -1 || (fd >= SHELL_FD_BASE && clexec == 1))
    return 0;
  return 1;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\redir.c:764
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\redir.c:782
parsing error 
{
  WORD_DESC *redirectee;
  int redir_fd, fd, redirector, r, oflags;
  intmax_t lfd;
  char *redirectee_word;
  enum r_instruction ri;
  REDIRECT *new_redirect;
  REDIRECTEE sd;

  redirectee = redirect->redirectee.filename;
  redir_fd = redirect->redirectee.dest;
  redirector = redirect->redirector.dest;
  ri = redirect->instruction;

  if (redirect->flags & RX_INTERNAL)
    flags |= RX_INTERNAL;

  if (TRANSLATE_REDIRECT (ri))
    {
      /* We have [N]>&WORD[-] or [N]<&WORD[-] (or {V}>&WORD[-] or {V}<&WORD-).
         and WORD, then translate the redirection into a new one and 
	 continue. */
      redirectee_word = redirection_expand (redirectee);

      /* XXX - what to do with [N]<&$w- where w is unset or null?  ksh93
	       closes N. */
      if (redirectee_word == 0)
	return (AMBIGUOUS_REDIRECT);
      else if (redirectee_word[0] == '-' && redirectee_word[1] == '\0')
	{
	  sd = redirect->redirector;
	  rd.dest = 0;
	  new_redirect = make_redirection (sd, r_close_this, rd, 0);
	}
      else if (all_digits (redirectee_word))
	{
	  sd = redirect->redirector;
	  if (legal_number (redirectee_word, &lfd) && (int)lfd == lfd)
	    rd.dest = lfd;
	  else
	    rd.dest = -1;	/* XXX */
	  switch (ri)
	    {
	    case r_duplicating_input_word:
	      new_redirect = make_redirection (sd, r_duplicating_input, rd, 0);
	      break;
	    case r_duplicating_output_word:
	      new_redirect = make_redirection (sd, r_duplicating_output, rd, 0);
	      break;
	    case r_move_input_word:
	      new_redirect = make_redirection (sd, r_move_input, rd, 0);
	      break;
	    case r_move_output_word:
	      new_redirect = make_redirection (sd, r_move_output, rd, 0);
	      break;
	    default:
	      break;	/* shut up gcc */
	    }
	}
      else if (ri == r_duplicating_output_word && (redirect->rflags & REDIR_VARASSIGN) == 0 && redirector == 1)
	{
	  sd = redirect->redirector;
	  rd.filename = make_bare_word (redirectee_word);
	  new_redirect = make_redirection (sd, r_err_and_out, rd, 0);
	}
      else
	{
	  free (redirectee_word);
	  return (AMBIGUOUS_REDIRECT);
	}

      free (redirectee_word);

      /* Set up the variables needed by the rest of the function from the
	 new redirection. */
      if (new_redirect->instruction == r_err_and_out)
	{
	  char *alloca_hack;

	  /* Copy the word without allocating any memory that must be
	     explicitly freed. */
	  redirectee = (WORD_DESC *)alloca (sizeof (WORD_DESC));
	  xbcopy ((char *)new_redirect->redirectee.filename,
		 (char *)redirectee, sizeof (WORD_DESC));

	  alloca_hack = (char *)
	    alloca (1 + strlen (new_redirect->redirectee.filename->word));
	  redirectee->word = alloca_hack;
	  strcpy (redirectee->word, new_redirect->redirectee.filename->word);
	}
      else
	/* It's guaranteed to be an integer, and shouldn't be freed. */
	redirectee = new_redirect->redirectee.filename;

      redir_fd = new_redirect->redirectee.dest;
      redirector = new_redirect->redirector.dest;
      ri = new_redirect->instruction;

      /* Overwrite the flags element of the old redirect with the new value. */
      redirect->flags = new_redirect->flags;
      dispose_redirects (new_redirect);
    }

  switch (ri)
    {
    case r_output_direction:
    case r_appending_to:
    case r_input_direction:
    case r_inputa_direction:
    case r_err_and_out:		/* command &>filename */
    case r_append_err_and_out:	/* command &>> filename */
    case r_input_output:
    case r_output_force:
      if (posixly_correct && interactive_shell == 0)
	{
	  oflags = redirectee->flags;
	  redirectee->flags |= W_NOGLOB;
	}
      redirectee_word = redirection_expand (redirectee);
      if (posixly_correct && interactive_shell == 0)
	redirectee->flags = oflags;

      if (redirectee_word == 0)
	return (AMBIGUOUS_REDIRECT);

#if defined (RESTRICTED_SHELL)
      if (restricted && (WRITE_REDIRECT (ri)))
	{
	  free (redirectee_word);
	  return (RESTRICTED_REDIRECT);
	}
#endif /* RESTRICTED_SHELL */

      fd = redir_open (redirectee_word, redirect->flags, 0666, ri);
      if (fnp)
	*fnp = redirectee_word;
      else
	free (redirectee_word);

      if (fd == NOCLOBBER_REDIRECT || fd == RESTRICTED_REDIRECT)
	return (fd);

      if (fd < 0)
	return (errno);

      if (flags & RX_ACTIVE)
	{
	  if (redirect->rflags & REDIR_VARASSIGN)
	    {
	      redirector = fcntl (fd, F_DUPFD, SHELL_FD_BASE);		/* XXX try this for now */
	      r = errno;
	      if (redirector < 0)
		sys_error (_("redirection error: cannot duplicate fd"));
	      REDIRECTION_ERROR (redirector, r, fd);
	    }

	  if ((flags & RX_UNDOABLE) && (redirect->rflags & REDIR_VARASSIGN) == 0)
	    {
	      /* Only setup to undo it if the thing to undo is active. */
	      if ((fd != redirector) && (fcntl (redirector, F_GETFD, 0) != -1))
		r = add_undo_redirect (redirector, ri, -1);
	      else
		r = add_undo_close_redirect (redirector);
	      REDIRECTION_ERROR (r, errno, fd);
	    }

#if defined (BUFFERED_INPUT)
	  /* inhibit call to sync_buffered_stream() for async processes */
	  if (redirector != 0 || (subshell_environment & SUBSHELL_ASYNC) == 0)
	    check_bash_input (redirector);
#endif

	  /* Make sure there is no pending output before we change the state
	     of the underlying file descriptor, since the builtins use stdio
	     for output. */
	  if (redirector == 1 && fileno (stdout) == redirector)
	    {
	      fflush (stdout);
	      fpurge (stdout);
	    }
	  else if (redirector == 2 && fileno (stderr) == redirector)
	    {
	      fflush (stderr);
	      fpurge (stderr);
	    }

	  if (redirect->rflags & REDIR_VARASSIGN)
	    {
	      if ((r = redir_varassign (redirect, redirector)) < 0)
		{
		  close (redirector);
		  close (fd);
		  return (r);	/* XXX */
		}
	    }
	  else if ((fd != redirector) && (dup2 (fd, redirector) < 0))
	    {
	      close (fd);	/* dup2 failed? must be fd limit issue */
	      return (errno);
	    }

#if defined (BUFFERED_INPUT)
	  /* Do not change the buffered stream for an implicit redirection
	     of /dev/null to fd 0 for asynchronous commands without job
	     control (r_inputa_direction). */
	  if (ri == r_input_direction || ri == r_input_output)
	    duplicate_buffered_stream (fd, redirector);
#endif /* BUFFERED_INPUT */

	  /*
	   * If we're remembering, then this is the result of a while, for
	   * or until loop with a loop redirection, or a function/builtin
	   * executing in the parent shell with a redirection.  In the
	   * function/builtin case, we want to set all file descriptors > 2
	   * to be close-on-exec to duplicate the effect of the old
	   * for i = 3 to NOFILE close(i) loop.  In the case of the loops,
	   * both sh and ksh leave the file descriptors open across execs.
	   * The Posix standard mentions only the exec builtin.
	   */
	  if ((flags & RX_CLEXEC) && (redirector > 2))
	    SET_CLOSE_ON_EXEC (redirector);
	}

      if (fd != redirector)
	{
#if defined (BUFFERED_INPUT)
	  if (INPUT_REDIRECT (ri))
	    close_buffered_fd (fd);
	  else
#endif /* !BUFFERED_INPUT */
	    close (fd);		/* Don't close what we just opened! */
	}

      /* If we are hacking both stdout and stderr, do the stderr
	 redirection here.  XXX - handle {var} here? */
      if (ri == r_err_and_out || ri == r_append_err_and_out)
	{
	  if (flags & RX_ACTIVE)
	    {
	      if (flags & RX_UNDOABLE)
		add_undo_redirect (2, ri, -1);
	      if (dup2 (1, 2) < 0)
		return (errno);
	    }
	}
      break;

    case r_reading_until:
    case r_deblank_reading_until:
    case r_reading_string:
      /* REDIRECTEE is a pointer to a WORD_DESC containing the text of
	 the new input.  Place it in a temporary file. */
      if (redirectee)
	{
	  fd = here_document_to_fd (redirectee, ri);

	  if (fd < 0)
	    {
	      heredoc_errno = errno;
	      return (HEREDOC_REDIRECT);
	    }

	  if (redirect->rflags & REDIR_VARASSIGN)
	    {
	      redirector = fcntl (fd, F_DUPFD, SHELL_FD_BASE);		/* XXX try this for now */
	      r = errno;
	      if (redirector < 0)
		sys_error (_("redirection error: cannot duplicate fd"));
	      REDIRECTION_ERROR (redirector, r, fd);
	    }

	  if (flags & RX_ACTIVE)
	    {
	      if ((flags & RX_UNDOABLE) && (redirect->rflags & REDIR_VARASSIGN) == 0)
	        {
		  /* Only setup to undo it if the thing to undo is active. */
		  if ((fd != redirector) && (fcntl (redirector, F_GETFD, 0) != -1))
		    r = add_undo_redirect (redirector, ri, -1);
		  else
		    r = add_undo_close_redirect (redirector);
		  REDIRECTION_ERROR (r, errno, fd);
	        }

#if defined (BUFFERED_INPUT)
	      check_bash_input (redirector);
#endif
	      if (redirect->rflags & REDIR_VARASSIGN)
		{
		  if ((r = redir_varassign (redirect, redirector)) < 0)
		    {
		      close (redirector);
		      close (fd);
		      return (r);	/* XXX */
		    }
		}
	      else if (fd != redirector && dup2 (fd, redirector) < 0)
		{
		  r = errno;
		  close (fd);
		  return (r);
		}

#if defined (BUFFERED_INPUT)
	      duplicate_buffered_stream (fd, redirector);
#endif

	      if ((flags & RX_CLEXEC) && (redirector > 2))
		SET_CLOSE_ON_EXEC (redirector);
	    }

	  if (fd != redirector)
#if defined (BUFFERED_INPUT)
	    close_buffered_fd (fd);
#else
	    close (fd);
#endif
	}
      break;

    case r_duplicating_input:
    case r_duplicating_output:
    case r_move_input:
    case r_move_output:
      if ((flags & RX_ACTIVE) && (redirect->rflags & REDIR_VARASSIGN))
        {
	  redirector = fcntl (redir_fd, F_DUPFD, SHELL_FD_BASE);		/* XXX try this for now */
	  r = errno;
	  if (redirector < 0)
	    sys_error (_("redirection error: cannot duplicate fd"));
	  REDIRECTION_ERROR (redirector, r, -1);
        }

      if ((flags & RX_ACTIVE) && (redir_fd != redirector))
	{
	  if ((flags & RX_UNDOABLE) && (redirect->rflags & REDIR_VARASSIGN) == 0)
	    {
	      /* Only setup to undo it if the thing to undo is active. */
	      if (fcntl (redirector, F_GETFD, 0) != -1)
		r = add_undo_redirect (redirector, ri, redir_fd);
	      else
		r = add_undo_close_redirect (redirector);
	      REDIRECTION_ERROR (r, errno, -1);
	    }
	  if ((flags & RX_UNDOABLE) && (ri == r_move_input || ri == r_move_output))
	    {
	      /* r_move_input and r_move_output add an additional close()
		 that needs to be undone */
	      if (fcntl (redirector, F_GETFD, 0) != -1)
		{
		  r = add_undo_redirect (redir_fd, r_close_this, -1);
		  REDIRECTION_ERROR (r, errno, -1);
		}
	    }
#if defined (BUFFERED_INPUT)
	  /* inhibit call to sync_buffered_stream() for async processes */
	  if (redirector != 0 || (subshell_environment & SUBSHELL_ASYNC) == 0)
	    check_bash_input (redirector);
#endif
	  if (redirect->rflags & REDIR_VARASSIGN)
	    {
	      if ((r = redir_varassign (redirect, redirector)) < 0)
		{
		  close (redirector);
		  return (r);	/* XXX */
		}
	    }
	  /* This is correct.  2>&1 means dup2 (1, 2); */
	  else if (dup2 (redir_fd, redirector) < 0)
	    return (errno);

#if defined (BUFFERED_INPUT)
	  if (ri == r_duplicating_input || ri == r_move_input)
	    duplicate_buffered_stream (redir_fd, redirector);
#endif /* BUFFERED_INPUT */

	  /* First duplicate the close-on-exec state of redirectee.  dup2
	     leaves the flag unset on the new descriptor, which means it
	     stays open.  Only set the close-on-exec bit for file descriptors
	     greater than 2 in any case, since 0-2 should always be open
	     unless closed by something like `exec 2<&-'.  It should always
	     be safe to set fds > 2 to close-on-exec if they're being used to
	     save file descriptors < 2, since we don't need to preserve the
	     state of the close-on-exec flag for those fds -- they should
	     always be open. */
	  /* if ((already_set || set_unconditionally) && (ok_to_set))
		set_it () */
#if 0
	  if (((fcntl (redir_fd, F_GETFD, 0) == 1) || redir_fd < 2 || (flags & RX_CLEXEC)) &&
	       (redirector > 2))
#else
	  if (((fcntl (redir_fd, F_GETFD, 0) == 1) || (redir_fd < 2 && (flags & RX_INTERNAL)) || (flags & RX_CLEXEC)) &&
	       (redirector > 2))
#endif
	    SET_CLOSE_ON_EXEC (redirector);

	  /* When undoing saving of non-standard file descriptors (>=3) using
	     file descriptors >= SHELL_FD_BASE, we set the saving fd to be
	     close-on-exec and use a flag to decide how to set close-on-exec
	     when the fd is restored. */
	  if ((redirect->flags & RX_INTERNAL) && (redirect->flags & RX_SAVCLEXEC) && redirector >= 3 && (redir_fd >= SHELL_FD_BASE || (redirect->flags & RX_SAVEFD)))
	    SET_OPEN_ON_EXEC (redirector);
	    
	  /* dup-and-close redirection */
	  if (ri == r_move_input || ri == r_move_output)
	    {
	      xtrace_fdchk (redir_fd);

	      close (redir_fd);
#if defined (COPROCESS_SUPPORT)
	      coproc_fdchk (redir_fd);	/* XXX - loses coproc fds */
#endif
	    }
	}
      break;

    case r_close_this:
      if (flags & RX_ACTIVE)
	{
	  if (redirect->rflags & REDIR_VARASSIGN)
	    {
	      redirector = redir_varvalue (redirect);
	      if (redirector < 0)
		return AMBIGUOUS_REDIRECT;
	    }

	  r = 0;
	  /* XXX - only if REDIR_VARASSIGN not set? */
	  if (flags & RX_UNDOABLE)
	    {
	      if (fcntl (redirector, F_GETFD, 0) != -1)
		r = add_undo_redirect (redirector, ri, -1);
	      else
		r = add_undo_close_redirect (redirector);
	      REDIRECTION_ERROR (r, errno, redirector);
	    }

#if defined (COPROCESS_SUPPORT)
	  coproc_fdchk (redirector);
#endif
	  xtrace_fdchk (redirector);

#if defined (BUFFERED_INPUT)
	  /* inhibit call to sync_buffered_stream() for async processes */
	  if (redirector != 0 || (subshell_environment & SUBSHELL_ASYNC) == 0)
	    check_bash_input (redirector);
	  r = close_buffered_fd (redirector);
#else /* !BUFFERED_INPUT */
	  r = close (redirector);
#endif /* !BUFFERED_INPUT */

	  if (r < 0 && (flags & RX_INTERNAL) && (errno == EIO || errno == ENOSPC))
	    REDIRECTION_ERROR (r, errno, -1);
	}
      break;

    case r_duplicating_input_word:
    case r_duplicating_output_word:
    case r_move_input_word:
    case r_move_output_word:
      break;
    }
  return (0);
}
warning: parse error {
  WORD_DESC *redirectee;
  int redir_fd, fd, redirector, r, oflags;
  intmax_t lfd;
  char *redirectee_word;
  enum r_instruction ri;
  REDIRECT *new_redirect;
  REDIRECTEE sd;

  redirectee = redirect->redirectee.filename;
  redir_fd = redirect->redirectee.dest;
  redirector = redirect->redirector.dest;
  ri = redirect->instruction;

  if (redirect->flags & RX_INTERNAL)
    flags |= RX_INTERNAL;

  if (TRANSLATE_REDIRECT (ri))
    {
      /* We have [N]>&WORD[-] or [N]<&WORD[-] (or {V}>&WORD[-] or {V}<&WORD-).
         and WORD, then translate the redirection into a new one and 
	 continue. */
      redirectee_word = redirection_expand (redirectee);

      /* XXX - what to do with [N]<&$w- where w is unset or null?  ksh93
	       closes N. */
      if (redirectee_word == 0)
	return (AMBIGUOUS_REDIRECT);
      else if (redirectee_word[0] == '-' && redirectee_word[1] == '\0')
	{
	  sd = redirect->redirector;
	  rd.dest = 0;
	  new_redirect = make_redirection (sd, r_close_this, rd, 0);
	}
      else if (all_digits (redirectee_word))
	{
	  sd = redirect->redirector;
	  if (legal_number (redirectee_word, &lfd) && (int)lfd == lfd)
	    rd.dest = lfd;
	  else
	    rd.dest = -1;	/* XXX */
	  switch (ri)
	    {
	    case r_duplicating_input_word:
	      new_redirect = make_redirection (sd, r_duplicating_input, rd, 0);
	      break;
	    case r_duplicating_output_word:
	      new_redirect = make_redirection (sd, r_duplicating_output, rd, 0);
	      break;
	    case r_move_input_word:
	      new_redirect = make_redirection (sd, r_move_input, rd, 0);
	      break;
	    case r_move_output_word:
	      new_redirect = make_redirection (sd, r_move_output, rd, 0);
	      break;
	    default:
	      break;	/* shut up gcc */
	    }
	}
      else if (ri == r_duplicating_output_word && (redirect->rflags & REDIR_VARASSIGN) == 0 && redirector == 1)
	{
	  sd = redirect->redirector;
	  rd.filename = make_bare_word (redirectee_word);
	  new_redirect = make_redirection (sd, r_err_and_out, rd, 0);
	}
      else
	{
	  free (redirectee_word);
	  return (AMBIGUOUS_REDIRECT);
	}

      free (redirectee_word);

      /* Set up the variables needed by the rest of the function from the
	 new redirection. */
      if (new_redirect->instruction == r_err_and_out)
	{
	  char *alloca_hack;

	  /* Copy the word without allocating any memory that must be
	     explicitly freed. */
	  redirectee = (WORD_DESC *)alloca (sizeof (WORD_DESC));
	  xbcopy ((char *)new_redirect->redirectee.filename,
		 (char *)redirectee, sizeof (WORD_DESC));

	  alloca_hack = (char *)
	    alloca (1 + strlen (new_redirect->redirectee.filename->word));
	  redirectee->word = alloca_hack;
	  strcpy (redirectee->word, new_redirect->redirectee.filename->word);
	}
      else
	/* It's guaranteed to be an integer, and shouldn't be freed. */
	redirectee = new_redirect->redirectee.filename;

      redir_fd = new_redirect->redirectee.dest;
      redirector = new_redirect->redirector.dest;
      ri = new_redirect->instruction;

      /* Overwrite the flags element of the old redirect with the new value. */
      redirect->flags = new_redirect->flags;
      dispose_redirects (new_redirect);
    }

  switch (ri)
    {
    case r_output_direction:
    case r_appending_to:
    case r_input_direction:
    case r_inputa_direction:
    case r_err_and_out:		/* command &>filename */
    case r_append_err_and_out:	/* command &>> filename */
    case r_input_output:
    case r_output_force:
      if (posixly_correct && interactive_shell == 0)
	{
	  oflags = redirectee->flags;
	  redirectee->flags |= W_NOGLOB;
	}
      redirectee_word = redirection_expand (redirectee);
      if (posixly_correct && interactive_shell == 0)
	redirectee->flags = oflags;

      if (redirectee_word == 0)
	return (AMBIGUOUS_REDIRECT);

#if defined (RESTRICTED_SHELL)
      if (restricted && (WRITE_REDIRECT (ri)))
	{
	  free (redirectee_word);
	  return (RESTRICTED_REDIRECT);
	}
#endif /* RESTRICTED_SHELL */

      fd = redir_open (redirectee_word, redirect->flags, 0666, ri);
      if (fnp)
	*fnp = redirectee_word;
      else
	free (redirectee_word);

      if (fd == NOCLOBBER_REDIRECT || fd == RESTRICTED_REDIRECT)
	return (fd);

      if (fd < 0)
	return (errno);

      if (flags & RX_ACTIVE)
	{
	  if (redirect->rflags & REDIR_VARASSIGN)
	    {
	      redirector = fcntl (fd, F_DUPFD, SHELL_FD_BASE);		/* XXX try this for now */
	      r = errno;
	      if (redirector < 0)
		sys_error (_("redirection error: cannot duplicate fd"));
	      REDIRECTION_ERROR (redirector, r, fd);
	    }

	  if ((flags & RX_UNDOABLE) && (redirect->rflags & REDIR_VARASSIGN) == 0)
	    {
	      /* Only setup to undo it if the thing to undo is active. */
	      if ((fd != redirector) && (fcntl (redirector, F_GETFD, 0) != -1))
		r = add_undo_redirect (redirector, ri, -1);
	      else
		r = add_undo_close_redirect (redirector);
	      REDIRECTION_ERROR (r, errno, fd);
	    }

#if defined (BUFFERED_INPUT)
	  /* inhibit call to sync_buffered_stream() for async processes */
	  if (redirector != 0 || (subshell_environment & SUBSHELL_ASYNC) == 0)
	    check_bash_input (redirector);
#endif

	  /* Make sure there is no pending output before we change the state
	     of the underlying file descriptor, since the builtins use stdio
	     for output. */
	  if (redirector == 1 && fileno (stdout) == redirector)
	    {
	      fflush (stdout);
	      fpurge (stdout);
	    }
	  else if (redirector == 2 && fileno (stderr) == redirector)
	    {
	      fflush (stderr);
	      fpurge (stderr);
	    }

	  if (redirect->rflags & REDIR_VARASSIGN)
	    {
	      if ((r = redir_varassign (redirect, redirector)) < 0)
		{
		  close (redirector);
		  close (fd);
		  return (r);	/* XXX */
		}
	    }
	  else if ((fd != redirector) && (dup2 (fd, redirector) < 0))
	    {
	      close (fd);	/* dup2 failed? must be fd limit issue */
	      return (errno);
	    }

#if defined (BUFFERED_INPUT)
	  /* Do not change the buffered stream for an implicit redirection
	     of /dev/null to fd 0 for asynchronous commands without job
	     control (r_inputa_direction). */
	  if (ri == r_input_direction || ri == r_input_output)
	    duplicate_buffered_stream (fd, redirector);
#endif /* BUFFERED_INPUT */

	  /*
	   * If we're remembering, then this is the result of a while, for
	   * or until loop with a loop redirection, or a function/builtin
	   * executing in the parent shell with a redirection.  In the
	   * function/builtin case, we want to set all file descriptors > 2
	   * to be close-on-exec to duplicate the effect of the old
	   * for i = 3 to NOFILE close(i) loop.  In the case of the loops,
	   * both sh and ksh leave the file descriptors open across execs.
	   * The Posix standard mentions only the exec builtin.
	   */
	  if ((flags & RX_CLEXEC) && (redirector > 2))
	    SET_CLOSE_ON_EXEC (redirector);
	}

      if (fd != redirector)
	{
#if defined (BUFFERED_INPUT)
	  if (INPUT_REDIRECT (ri))
	    close_buffered_fd (fd);
	  else
#endif /* !BUFFERED_INPUT */
	    close (fd);		/* Don't close what we just opened! */
	}

      /* If we are hacking both stdout and stderr, do the stderr
	 redirection here.  XXX - handle {var} here? */
      if (ri == r_err_and_out || ri == r_append_err_and_out)
	{
	  if (flags & RX_ACTIVE)
	    {
	      if (flags & RX_UNDOABLE)
		add_undo_redirect (2, ri, -1);
	      if (dup2 (1, 2) < 0)
		return (errno);
	    }
	}
      break;

    case r_reading_until:
    case r_deblank_reading_until:
    case r_reading_string:
      /* REDIRECTEE is a pointer to a WORD_DESC containing the text of
	 the new input.  Place it in a temporary file. */
      if (redirectee)
	{
	  fd = here_document_to_fd (redirectee, ri);

	  if (fd < 0)
	    {
	      heredoc_errno = errno;
	      return (HEREDOC_REDIRECT);
	    }

	  if (redirect->rflags & REDIR_VARASSIGN)
	    {
	      redirector = fcntl (fd, F_DUPFD, SHELL_FD_BASE);		/* XXX try this for now */
	      r = errno;
	      if (redirector < 0)
		sys_error (_("redirection error: cannot duplicate fd"));
	      REDIRECTION_ERROR (redirector, r, fd);
	    }

	  if (flags & RX_ACTIVE)
	    {
	      if ((flags & RX_UNDOABLE) && (redirect->rflags & REDIR_VARASSIGN) == 0)
	        {
		  /* Only setup to undo it if the thing to undo is active. */
		  if ((fd != redirector) && (fcntl (redirector, F_GETFD, 0) != -1))
		    r = add_undo_redirect (redirector, ri, -1);
		  else
		    r = add_undo_close_redirect (redirector);
		  REDIRECTION_ERROR (r, errno, fd);
	        }

#if defined (BUFFERED_INPUT)
	      check_bash_input (redirector);
#endif
	      if (redirect->rflags & REDIR_VARASSIGN)
		{
		  if ((r = redir_varassign (redirect, redirector)) < 0)
		    {
		      close (redirector);
		      close (fd);
		      return (r);	/* XXX */
		    }
		}
	      else if (fd != redirector && dup2 (fd, redirector) < 0)
		{
		  r = errno;
		  close (fd);
		  return (r);
		}

#if defined (BUFFERED_INPUT)
	      duplicate_buffered_stream (fd, redirector);
#endif

	      if ((flags & RX_CLEXEC) && (redirector > 2))
		SET_CLOSE_ON_EXEC (redirector);
	    }

	  if (fd != redirector)
#if defined (BUFFERED_INPUT)
	    close_buffered_fd (fd);
#else
	    close (fd);
#endif
	}
      break;

    case r_duplicating_input:
    case r_duplicating_output:
    case r_move_input:
    case r_move_output:
      if ((flags & RX_ACTIVE) && (redirect->rflags & REDIR_VARASSIGN))
        {
	  redirector = fcntl (redir_fd, F_DUPFD, SHELL_FD_BASE);		/* XXX try this for now */
	  r = errno;
	  if (redirector < 0)
	    sys_error (_("redirection error: cannot duplicate fd"));
	  REDIRECTION_ERROR (redirector, r, -1);
        }

      if ((flags & RX_ACTIVE) && (redir_fd != redirector))
	{
	  if ((flags & RX_UNDOABLE) && (redirect->rflags & REDIR_VARASSIGN) == 0)
	    {
	      /* Only setup to undo it if the thing to undo is active. */
	      if (fcntl (redirector, F_GETFD, 0) != -1)
		r = add_undo_redirect (redirector, ri, redir_fd);
	      else
		r = add_undo_close_redirect (redirector);
	      REDIRECTION_ERROR (r, errno, -1);
	    }
	  if ((flags & RX_UNDOABLE) && (ri == r_move_input || ri == r_move_output))
	    {
	      /* r_move_input and r_move_output add an additional close()
		 that needs to be undone */
	      if (fcntl (redirector, F_GETFD, 0) != -1)
		{
		  r = add_undo_redirect (redir_fd, r_close_this, -1);
		  REDIRECTION_ERROR (r, errno, -1);
		}
	    }
#if defined (BUFFERED_INPUT)
	  /* inhibit call to sync_buffered_stream() for async processes */
	  if (redirector != 0 || (subshell_environment & SUBSHELL_ASYNC) == 0)
	    check_bash_input (redirector);
#endif
	  if (redirect->rflags & REDIR_VARASSIGN)
	    {
	      if ((r = redir_varassign (redirect, redirector)) < 0)
		{
		  close (redirector);
		  return (r);	/* XXX */
		}
	    }
	  /* This is correct.  2>&1 means dup2 (1, 2); */
	  else if (dup2 (redir_fd, redirector) < 0)
	    return (errno);

#if defined (BUFFERED_INPUT)
	  if (ri == r_duplicating_input || ri == r_move_input)
	    duplicate_buffered_stream (redir_fd, redirector);
#endif /* BUFFERED_INPUT */

	  /* First duplicate the close-on-exec state of redirectee.  dup2
	     leaves the flag unset on the new descriptor, which means it
	     stays open.  Only set the close-on-exec bit for file descriptors
	     greater than 2 in any case, since 0-2 should always be open
	     unless closed by something like `exec 2<&-'.  It should always
	     be safe to set fds > 2 to close-on-exec if they're being used to
	     save file descriptors < 2, since we don't need to preserve the
	     state of the close-on-exec flag for those fds -- they should
	     always be open. */
	  /* if ((already_set || set_unconditionally) && (ok_to_set))
		set_it () */
#if 0
	  if (((fcntl (redir_fd, F_GETFD, 0) == 1) || redir_fd < 2 || (flags & RX_CLEXEC)) &&
	       (redirector > 2))
#else
	  if (((fcntl (redir_fd, F_GETFD, 0) == 1) || (redir_fd < 2 && (flags & RX_INTERNAL)) || (flags & RX_CLEXEC)) &&
	       (redirector > 2))
#endif
	    SET_CLOSE_ON_EXEC (redirector);

	  /* When undoing saving of non-standard file descriptors (>=3) using
	     file descriptors >= SHELL_FD_BASE, we set the saving fd to be
	     close-on-exec and use a flag to decide how to set close-on-exec
	     when the fd is restored. */
	  if ((redirect->flags & RX_INTERNAL) && (redirect->flags & RX_SAVCLEXEC) && redirector >= 3 && (redir_fd >= SHELL_FD_BASE || (redirect->flags & RX_SAVEFD)))
	    SET_OPEN_ON_EXEC (redirector);
	    
	  /* dup-and-close redirection */
	  if (ri == r_move_input || ri == r_move_output)
	    {
	      xtrace_fdchk (redir_fd);

	      close (redir_fd);
#if defined (COPROCESS_SUPPORT)
	      coproc_fdchk (redir_fd);	/* XXX - loses coproc fds */
#endif
	    }
	}
      break;

    case r_close_this:
      if (flags & RX_ACTIVE)
	{
	  if (redirect->rflags & REDIR_VARASSIGN)
	    {
	      redirector = redir_varvalue (redirect);
	      if (redirector < 0)
		return AMBIGUOUS_REDIRECT;
	    }

	  r = 0;
	  /* XXX - only if REDIR_VARASSIGN not set? */
	  if (flags & RX_UNDOABLE)
	    {
	      if (fcntl (redirector, F_GETFD, 0) != -1)
		r = add_undo_redirect (redirector, ri, -1);
	      else
		r = add_undo_close_redirect (redirector);
	      REDIRECTION_ERROR (r, errno, redirector);
	    }

#if defined (COPROCESS_SUPPORT)
	  coproc_fdchk (redirector);
#endif
	  xtrace_fdchk (redirector);

#if defined (BUFFERED_INPUT)
	  /* inhibit call to sync_buffered_stream() for async processes */
	  if (redirector != 0 || (subshell_environment & SUBSHELL_ASYNC) == 0)
	    check_bash_input (redirector);
	  r = close_buffered_fd (redirector);
#else /* !BUFFERED_INPUT */
	  r = close (redirector);
#endif /* !BUFFERED_INPUT */

	  if (r < 0 && (flags & RX_INTERNAL) && (errno == EIO || errno == ENOSPC))
	    REDIRECTION_ERROR (r, errno, -1);
	}
      break;

    case r_duplicating_input_word:
    case r_duplicating_output_word:
    case r_move_input_word:
    case r_move_output_word:
      break;
    }
  return (0);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\redir.c:786
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\redir.c:1,263
parsing error 
{
  int new_fd, clexec_flag, savefd_flag;
  REDIRECT *new_redirect, *closer, *dummy_redirect;
  REDIRECTEE sd;

  savefd_flag = 0;
  new_fd = fcntl (fd, F_DUPFD, (fdbase < SHELL_FD_BASE) ? SHELL_FD_BASE : fdbase+1);
  if (new_fd < 0)
    new_fd = fcntl (fd, F_DUPFD, SHELL_FD_BASE);
  if (new_fd < 0)
    {
      new_fd = fcntl (fd, F_DUPFD, 0);
      savefd_flag = 1;
    }

  if (new_fd < 0)
    {
      sys_error (_("redirection error: cannot duplicate fd"));
      return (-1);
    }

  clexec_flag = fcntl (fd, F_GETFD, 0);

  sd.dest = new_fd;
  rd.dest = 0;
  closer = make_redirection (sd, r_close_this, rd, 0);
  closer->flags |= RX_INTERNAL;
  dummy_redirect = copy_redirects (closer);

  sd.dest = fd;
  rd.dest = new_fd;
  if (fd == 0)
    new_redirect = make_redirection (sd, r_duplicating_input, rd, 0);
  else
    new_redirect = make_redirection (sd, r_duplicating_output, rd, 0);
  new_redirect->flags |= RX_INTERNAL;
  if (savefd_flag)
    new_redirect->flags |= RX_SAVEFD;
  if (clexec_flag == 0 && fd >= 3 && (new_fd >= SHELL_FD_BASE || savefd_flag))
    new_redirect->flags |= RX_SAVCLEXEC;
  new_redirect->next = closer;

  closer->next = redirection_undo_list;
  redirection_undo_list = new_redirect;

  /* Save redirections that need to be undone even if the undo list
     is thrown away by the `exec' builtin. */
  add_exec_redirect (dummy_redirect);

  /* experimental:  if we're saving a redirection to undo for a file descriptor
     above SHELL_FD_BASE, add a redirection to be undone if the exec builtin
     causes redirections to be discarded.  There needs to be a difference
     between fds that are used to save other fds and then are the target of
     user redirections and fds that are just the target of user redirections.
     We use the close-on-exec flag to tell the difference; fds > SHELL_FD_BASE
     that have the close-on-exec flag set are assumed to be fds used internally
     to save others. */
  if (fd >= SHELL_FD_BASE && ri != r_close_this && clexec_flag)
    {
      sd.dest = fd;
      rd.dest = new_fd;
      new_redirect = make_redirection (sd, r_duplicating_output, rd, 0);
      new_redirect->flags |= RX_INTERNAL;

      add_exec_redirect (new_redirect);
    }

  /* File descriptors used only for saving others should always be
     marked close-on-exec.  Unfortunately, we have to preserve the
     close-on-exec state of the file descriptor we are saving, since
     fcntl (F_DUPFD) sets the new file descriptor to remain open
     across execs.  If, however, the file descriptor whose state we
     are saving is <= 2, we can just set the close-on-exec flag,
     because file descriptors 0-2 should always be open-on-exec,
     and the restore above in do_redirection() will take care of it. */
  if (clexec_flag || fd < 3)
    SET_CLOSE_ON_EXEC (new_fd);
  else if (redirection_undo_list->flags & RX_SAVCLEXEC)
    SET_CLOSE_ON_EXEC (new_fd);

  return (0);
}
warning: parse error {
  int new_fd, clexec_flag, savefd_flag;
  REDIRECT *new_redirect, *closer, *dummy_redirect;
  REDIRECTEE sd;

  savefd_flag = 0;
  new_fd = fcntl (fd, F_DUPFD, (fdbase < SHELL_FD_BASE) ? SHELL_FD_BASE : fdbase+1);
  if (new_fd < 0)
    new_fd = fcntl (fd, F_DUPFD, SHELL_FD_BASE);
  if (new_fd < 0)
    {
      new_fd = fcntl (fd, F_DUPFD, 0);
      savefd_flag = 1;
    }

  if (new_fd < 0)
    {
      sys_error (_("redirection error: cannot duplicate fd"));
      return (-1);
    }

  clexec_flag = fcntl (fd, F_GETFD, 0);

  sd.dest = new_fd;
  rd.dest = 0;
  closer = make_redirection (sd, r_close_this, rd, 0);
  closer->flags |= RX_INTERNAL;
  dummy_redirect = copy_redirects (closer);

  sd.dest = fd;
  rd.dest = new_fd;
  if (fd == 0)
    new_redirect = make_redirection (sd, r_duplicating_input, rd, 0);
  else
    new_redirect = make_redirection (sd, r_duplicating_output, rd, 0);
  new_redirect->flags |= RX_INTERNAL;
  if (savefd_flag)
    new_redirect->flags |= RX_SAVEFD;
  if (clexec_flag == 0 && fd >= 3 && (new_fd >= SHELL_FD_BASE || savefd_flag))
    new_redirect->flags |= RX_SAVCLEXEC;
  new_redirect->next = closer;

  closer->next = redirection_undo_list;
  redirection_undo_list = new_redirect;

  /* Save redirections that need to be undone even if the undo list
     is thrown away by the `exec' builtin. */
  add_exec_redirect (dummy_redirect);

  /* experimental:  if we're saving a redirection to undo for a file descriptor
     above SHELL_FD_BASE, add a redirection to be undone if the exec builtin
     causes redirections to be discarded.  There needs to be a difference
     between fds that are used to save other fds and then are the target of
     user redirections and fds that are just the target of user redirections.
     We use the close-on-exec flag to tell the difference; fds > SHELL_FD_BASE
     that have the close-on-exec flag set are assumed to be fds used internally
     to save others. */
  if (fd >= SHELL_FD_BASE && ri != r_close_this && clexec_flag)
    {
      sd.dest = fd;
      rd.dest = new_fd;
      new_redirect = make_redirection (sd, r_duplicating_output, rd, 0);
      new_redirect->flags |= RX_INTERNAL;

      add_exec_redirect (new_redirect);
    }

  /* File descriptors used only for saving others should always be
     marked close-on-exec.  Unfortunately, we have to preserve the
     close-on-exec state of the file descriptor we are saving, since
     fcntl (F_DUPFD) sets the new file descriptor to remain open
     across execs.  If, however, the file descriptor whose state we
     are saving is <= 2, we can just set the close-on-exec flag,
     because file descriptors 0-2 should always be open-on-exec,
     and the restore above in do_redirection() will take care of it. */
  if (clexec_flag || fd < 3)
    SET_CLOSE_ON_EXEC (new_fd);
  else if (redirection_undo_list->flags & RX_SAVCLEXEC)
    SET_CLOSE_ON_EXEC (new_fd);

  return (0);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\redir.c:1,267
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\redir.c:1,353
parsing error 
{
  REDIRECT *closer;
  REDIRECTEE sd;

  sd.dest = fd;
  rd.dest = 0;
  closer = make_redirection (sd, r_close_this, rd, 0);
  closer->flags |= RX_INTERNAL;
  closer->next = redirection_undo_list;
  redirection_undo_list = closer;

  return 0;
}
warning: parse error {
  REDIRECT *closer;
  REDIRECTEE sd;

  sd.dest = fd;
  rd.dest = 0;
  closer = make_redirection (sd, r_close_this, rd, 0);
  closer->flags |= RX_INTERNAL;
  closer->next = redirection_undo_list;
  redirection_undo_list = closer;

  return 0;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\redir.c:1,355
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\redir.c:1,370
parsing error 
{
  dummy_redirect->next = exec_redirection_undo_list;
  exec_redirection_undo_list = dummy_redirect;
}
warning: parse error {
  dummy_redirect->next = exec_redirection_undo_list;
  exec_redirection_undo_list = dummy_redirect;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\redir.c:1,372
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\redir.c:1,380
parsing error 
{
  switch (ri)
    {
    case r_input_direction:
    case r_inputa_direction:
    case r_input_output:
    case r_reading_until:
    case r_deblank_reading_until:
    case r_reading_string:
      return (1);
    case r_duplicating_input:
    case r_duplicating_input_word:
    case r_close_this:
      return (redirector == 0);
    case r_output_direction:
    case r_appending_to:
    case r_duplicating_output:
    case r_err_and_out:
    case r_append_err_and_out:
    case r_output_force:
    case r_duplicating_output_word:
    case r_move_input:
    case r_move_output:
    case r_move_input_word:
    case r_move_output_word:
      return (0);
    }
  return (0);
}
warning: parse error {
  switch (ri)
    {
    case r_input_direction:
    case r_inputa_direction:
    case r_input_output:
    case r_reading_until:
    case r_deblank_reading_until:
    case r_reading_string:
      return (1);
    case r_duplicating_input:
    case r_duplicating_input_word:
    case r_close_this:
      return (redirector == 0);
    case r_output_direction:
    case r_appending_to:
    case r_duplicating_output:
    case r_err_and_out:
    case r_append_err_and_out:
    case r_output_force:
    case r_duplicating_output_word:
    case r_move_input:
    case r_move_output:
    case r_move_input_word:
    case r_move_output_word:
      return (0);
    }
  return (0);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\redir.c:1,383
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\redir.c:1,416
parsing error 
{
  REDIRECT *rp;
  int n;

  for (n = 0, rp = redirs; rp; rp = rp->next)
    if ((rp->rflags & REDIR_VARASSIGN) == 0)
      n += stdin_redirection (rp->instruction, rp->redirector.dest);
  return n;
}
warning: parse error {
  REDIRECT *rp;
  int n;

  for (n = 0, rp = redirs; rp; rp = rp->next)
    if ((rp->rflags & REDIR_VARASSIGN) == 0)
      n += stdin_redirection (rp->instruction, rp->redirector.dest);
  return n;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\redir.c:1,418
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\redir.c:1,429
parsing error 
{
  WORD_DESC *w;
  SHELL_VAR *v;

  w = redir->redirector.filename;
  v = bind_var_to_int (w->word, fd);
  if (v == 0 || readonly_p (v) || noassign_p (v))
    return BADVAR_REDIRECT;

  stupidly_hack_special_variables (w->word);
  return 0;
}
warning: parse error {
  WORD_DESC *w;
  SHELL_VAR *v;

  w = redir->redirector.filename;
  v = bind_var_to_int (w->word, fd);
  if (v == 0 || readonly_p (v) || noassign_p (v))
    return BADVAR_REDIRECT;

  stupidly_hack_special_variables (w->word);
  return 0;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\redir.c:1,432
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\redir.c:1,447
parsing error 
{
  SHELL_VAR *v;
  char *val, *w;
  intmax_t vmax;
  int i;
#if defined (ARRAY_VARS)
  char *sub;
  int len, vr;
#endif

  w = redir->redirector.filename->word;		/* shorthand */
  /* XXX - handle set -u here? */
#if defined (ARRAY_VARS)
  if (vr = valid_array_reference (w, 0))
    {
      v = array_variable_part (w, 0, &sub, &len);
    }
  else
#endif
    {
      v = find_variable (w);
#if defined (ARRAY_VARS)
      if (v == 0)
	{
	  v = find_variable_last_nameref (w, 0);
	  if (v && nameref_p (v))
	    {
	      w = nameref_cell (v);
	      if (vr = valid_array_reference (w, 0))
		v = array_variable_part (w, 0, &sub, &len);
	      else
	        v = find_variable (w);
	    }
	}
#endif
    }
	
  if (v == 0 || invisible_p (v))
    return -1;

#if defined (ARRAY_VARS)
  /* get_variable_value handles references to array variables without
     subscripts */
  if (vr && (array_p (v) || assoc_p (v)))
    val = get_array_value (w, 0, (int *)NULL, (arrayind_t *)0);
  else
#endif
  val = get_variable_value (v);
  if (val == 0 || *val == 0)
    return -1;

  if (legal_number (val, &vmax) < 0)
    return -1;

  i = vmax;	/* integer truncation */
  return i;
}
warning: parse error {
  SHELL_VAR *v;
  char *val, *w;
  intmax_t vmax;
  int i;
#if defined (ARRAY_VARS)
  char *sub;
  int len, vr;
#endif

  w = redir->redirector.filename->word;		/* shorthand */
  /* XXX - handle set -u here? */
#if defined (ARRAY_VARS)
  if (vr = valid_array_reference (w, 0))
    {
      v = array_variable_part (w, 0, &sub, &len);
    }
  else
#endif
    {
      v = find_variable (w);
#if defined (ARRAY_VARS)
      if (v == 0)
	{
	  v = find_variable_last_nameref (w, 0);
	  if (v && nameref_p (v))
	    {
	      w = nameref_cell (v);
	      if (vr = valid_array_reference (w, 0))
		v = array_variable_part (w, 0, &sub, &len);
	      else
	        v = find_variable (w);
	    }
	}
#endif
    }
	
  if (v == 0 || invisible_p (v))
    return -1;

#if defined (ARRAY_VARS)
  /* get_variable_value handles references to array variables without
     subscripts */
  if (vr && (array_p (v) || assoc_p (v)))
    val = get_array_value (w, 0, (int *)NULL, (arrayind_t *)0);
  else
#endif
  val = get_variable_value (v);
  if (val == 0 || *val == 0)
    return -1;

  if (legal_number (val, &vmax) < 0)
    return -1;

  i = vmax;	/* integer truncation */
  return i;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\redir.c:1,449
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\shell.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashtypes.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\posixstat.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\posixtime.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashansi.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\filecntl.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashintl.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\shell.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\parser.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\flags.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\trap.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\mailcheck.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\common.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\jobs.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\input.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\execute_cmd.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\findcmd.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\tilde\tilde.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\glob\strmatch.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\shell.c:364
parsing error 
{
  register int i;
  int code, old_errexit_flag;
#if defined (RESTRICTED_SHELL)
  int saverst;
#endif
  volatile int locally_skip_execution;
  volatile int arg_index, top_level_arg_index;
#ifdef __OPENNT
  char **env;

  env = environ;
#endif /* __OPENNT */

  USE_VAR(argc);
  USE_VAR(argv);
  USE_VAR(env);
  USE_VAR(code);
  USE_VAR(old_errexit_flag);
#if defined (RESTRICTED_SHELL)
  USE_VAR(saverst);
#endif

  /* Catch early SIGINTs. */
  code = setjmp_nosigs (top_level);
  if (code)
    exit (2);

  xtrace_init ();

#if defined (USING_BASH_MALLOC) && defined (DEBUG) && !defined (DISABLE_MALLOC_WRAPPERS)
  malloc_set_register (1);	/* XXX - change to 1 for malloc debugging */
#endif

  check_dev_tty ();

#ifdef __CYGWIN__
  _cygwin32_check_tmp ();
#endif /* __CYGWIN__ */

  /* Wait forever if we are debugging a login shell. */
  while (debugging_login_shell) sleep (3);

  set_default_locale ();

  running_setuid = uidget ();

  if (getenv ("POSIXLY_CORRECT") || getenv ("POSIX_PEDANTIC"))
    posixly_correct = 1;

#if defined (USE_GNU_MALLOC_LIBRARY)
  mcheck (programming_error, (void (*) ())0);
#endif /* USE_GNU_MALLOC_LIBRARY */

  if (setjmp_sigs (subshell_top_level))
    {
      argc = subshell_argc;
      argv = subshell_argv;
      env = subshell_envp;
      sourced_env = 0;
    }

  shell_reinitialized = 0;

  /* Initialize `local' variables for all `invocations' of main (). */
  arg_index = 1;
  if (arg_index > argc)
    arg_index = argc;
  command_execution_string = shell_script_filename = (char *)NULL;
  want_pending_command = locally_skip_execution = read_from_stdin = 0;
  default_input = stdin;
#if defined (BUFFERED_INPUT)
  default_buffered_input = -1;
#endif

  /* Fix for the `infinite process creation' bug when running shell scripts
     from startup files on System V. */
  login_shell = make_login_shell = 0;

  /* If this shell has already been run, then reinitialize it to a
     vanilla state. */
  if (shell_initialized || shell_name)
    {
      /* Make sure that we do not infinitely recurse as a login shell. */
      if (*shell_name == '-')
	shell_name++;

      shell_reinitialize ();
      if (setjmp_nosigs (top_level))
	exit (2);
    }

  shell_environment = env;
  set_shell_name (argv[0]);

  gettimeofday (&shellstart, 0);
  shell_start_time = shellstart.tv_sec;

  /* Parse argument flags from the input line. */

  /* Find full word arguments first. */
  arg_index = parse_long_options (argv, arg_index, argc);
  
  if (want_initial_help)
    {
      show_shell_usage (stdout, 1);
      exit (EXECUTION_SUCCESS);
    }

  if (do_version)
    {
      show_shell_version (1);
      exit (EXECUTION_SUCCESS);
    }

  echo_input_at_read = verbose_flag;	/* --verbose given */

  /* All done with full word options; do standard shell option parsing.*/
  this_command_name = shell_name;	/* for error reporting */
  arg_index = parse_shell_options (argv, arg_index, argc);

  /* If user supplied the "--login" (or -l) flag, then set and invert
     LOGIN_SHELL. */
  if (make_login_shell)
    {
      login_shell++;
      login_shell = -login_shell;
    }

  set_login_shell ("login_shell", login_shell != 0);

  if (dump_po_strings)
    dump_translatable_strings = 1;

  if (dump_translatable_strings)
    read_but_dont_execute = 1;

  if (running_setuid && privileged_mode == 0)
    disable_priv_mode ();

  /* Need to get the argument to a -c option processed in the
     above loop.  The next arg is a command to execute, and the
     following args are $0...$n respectively. */
  if (want_pending_command)
    {
      command_execution_string = argv[arg_index];
      if (command_execution_string == 0)
	{
	  report_error (_("%s: option requires an argument"), "-c");
	  exit (EX_BADUSAGE);
	}
      arg_index++;
    }
  this_command_name = (char *)NULL;

  /* First, let the outside world know about our interactive status.
     A shell is interactive if the `-i' flag was given, or if all of
     the following conditions are met:
	no -c command
	no arguments remaining or the -s flag given
	standard input is a terminal
	standard error is a terminal
     Refer to Posix.2, the description of the `sh' utility. */

  if (forced_interactive ||		/* -i flag */
      (!command_execution_string &&	/* No -c command and ... */
       wordexp_only == 0 &&		/* No --wordexp and ... */
       ((arg_index == argc) ||		/*   no remaining args or... */
	read_from_stdin) &&		/*   -s flag with args, and */
       isatty (fileno (stdin)) &&	/* Input is a terminal and */
       isatty (fileno (stderr))))	/* error output is a terminal. */
    init_interactive ();
  else
    init_noninteractive ();

  /*
   * Some systems have the bad habit of starting login shells with lots of open
   * file descriptors.  For instance, most systems that have picked up the
   * pre-4.0 Sun YP code leave a file descriptor open each time you call one
   * of the getpw* functions, and it's set to be open across execs.  That
   * means one for login, one for xterm, one for shelltool, etc.  There are
   * also systems that open persistent FDs to other agents or files as part
   * of process startup; these need to be set to be close-on-exec.
   */
  if (login_shell && interactive_shell)
    {
      for (i = 3; i < 20; i++)
	SET_CLOSE_ON_EXEC (i);
    }

  /* If we're in a strict Posix.2 mode, turn on interactive comments,
     alias expansion in non-interactive shells, and other Posix.2 things. */
  if (posixly_correct)
    {
      bind_variable ("POSIXLY_CORRECT", "y", 0);
      sv_strict_posix ("POSIXLY_CORRECT");
    }

  /* Now we run the shopt_alist and process the options. */
  if (shopt_alist)
    run_shopt_alist ();

  /* From here on in, the shell must be a normal functioning shell.
     Variables from the environment are expected to be set, etc. */
  shell_initialize ();

  set_default_lang ();
  set_default_locale_vars ();

  /*
   * M-x term -> TERM=eterm-color INSIDE_EMACS='251,term:0.96' (eterm)
   * M-x shell -> TERM='dumb' INSIDE_EMACS='25.1,comint' (no line editing)
   *
   * Older versions of Emacs may set EMACS to 't' or to something like
   * '22.1 (term:0.96)' instead of (or in addition to) setting INSIDE_EMACS.
   * They may set TERM to 'eterm' instead of 'eterm-color'.  They may have
   * a now-obsolete command that sets neither EMACS nor INSIDE_EMACS:
   * M-x terminal -> TERM='emacs-em7955' (line editing)
   */
  if (interactive_shell)
    {
      char *term, *emacs, *inside_emacs;
      int emacs_term, in_emacs;

      term = get_string_value ("TERM");
      emacs = get_string_value ("EMACS");
      inside_emacs = get_string_value ("INSIDE_EMACS");

      if (inside_emacs)
	{
	  emacs_term = strstr (inside_emacs, ",term:") != 0;
	  in_emacs = 1;
	}
      else if (emacs)
	{
	  /* Infer whether we are in an older Emacs. */
	  emacs_term = strstr (emacs, " (term:") != 0;
	  in_emacs = emacs_term || STREQ (emacs, "t");
	}
      else
	in_emacs = emacs_term = 0;

      /* Not sure any emacs terminal emulator sets TERM=emacs any more */
      no_line_editing |= STREQ (term, "emacs");
      no_line_editing |= in_emacs && STREQ (term, "dumb");

      /* running_under_emacs == 2 for `eterm' */
      running_under_emacs = in_emacs || STREQN (term, "emacs", 5);
      running_under_emacs += emacs_term && STREQN (term, "eterm", 5);

      if (running_under_emacs)
	gnu_error_format = 1;
    }

  top_level_arg_index = arg_index;
  old_errexit_flag = exit_immediately_on_error;

  /* Give this shell a place to longjmp to before executing the
     startup files.  This allows users to press C-c to abort the
     lengthy startup. */
  code = setjmp_sigs (top_level);
  if (code)
    {
      if (code == EXITPROG || code == ERREXIT)
	exit_shell (last_command_exit_value);
      else
	{
#if defined (JOB_CONTROL)
	  /* Reset job control, since run_startup_files turned it off. */
	  set_job_control (interactive_shell);
#endif
	  /* Reset value of `set -e', since it's turned off before running
	     the startup files. */
	  exit_immediately_on_error += old_errexit_flag;
	  locally_skip_execution++;
	}
    }

  arg_index = top_level_arg_index;

  /* Execute the start-up scripts. */

  if (interactive_shell == 0)
    {
      unbind_variable ("PS1");
      unbind_variable ("PS2");
      interactive = 0;
#if 0
      /* This has already been done by init_noninteractive */
      expand_aliases = posixly_correct;
#endif
    }
  else
    {
      change_flag ('i', FLAG_ON);
      interactive = 1;
    }

#if defined (RESTRICTED_SHELL)
  /* Set restricted_shell based on whether the basename of $0 indicates that
     the shell should be restricted or if the `-r' option was supplied at
     startup. */
  restricted_shell = shell_is_restricted (shell_name);

  /* If the `-r' option is supplied at invocation, make sure that the shell
     is not in restricted mode when running the startup files. */
  saverst = restricted;
  restricted = 0;
#endif

  /* Set positional parameters before running startup files. top_level_arg_index
     holds the index of the current argument before setting the positional
     parameters, so any changes performed in the startup files won't affect
     later option processing. */
  if (wordexp_only)
    ;			/* nothing yet */
  else if (command_execution_string)
    arg_index = bind_args (argv, arg_index, argc, 0);	/* $0 ... $n */
  else if (arg_index != argc && read_from_stdin == 0)
    {
      shell_script_filename = argv[arg_index++];
      arg_index = bind_args (argv, arg_index, argc, 1);	/* $1 ... $n */
    }
  else
    arg_index = bind_args (argv, arg_index, argc, 1);	/* $1 ... $n */

  /* The startup files are run with `set -e' temporarily disabled. */
  if (locally_skip_execution == 0 && running_setuid == 0)
    {
      old_errexit_flag = exit_immediately_on_error;
      exit_immediately_on_error = 0;

      run_startup_files ();
      exit_immediately_on_error += old_errexit_flag;
    }

  /* If we are invoked as `sh', turn on Posix mode. */
  if (act_like_sh)
    {
      bind_variable ("POSIXLY_CORRECT", "y", 0);
      sv_strict_posix ("POSIXLY_CORRECT");
    }

#if defined (RESTRICTED_SHELL)
  /* Turn on the restrictions after executing the startup files.  This
     means that `bash -r' or `set -r' invoked from a startup file will
     turn on the restrictions after the startup files are executed. */
  restricted = saverst || restricted;
  if (shell_reinitialized == 0)
    maybe_make_restricted (shell_name);
#endif /* RESTRICTED_SHELL */

#if defined (WORDEXP_OPTION)
  if (wordexp_only)
    {
      startup_state = 3;
      last_command_exit_value = run_wordexp (argv[top_level_arg_index]);
      exit_shell (last_command_exit_value);
    }
#endif

  cmd_init ();		/* initialize the command object caches */
  uwp_init ();

  if (command_execution_string)
    {
      startup_state = 2;

      if (debugging_mode)
	start_debugger ();

#if defined (ONESHOT)
      executing = 1;
      run_one_command (command_execution_string);
      exit_shell (last_command_exit_value);
#else /* ONESHOT */
      with_input_from_string (command_execution_string, "-c");
      goto read_and_execute;
#endif /* !ONESHOT */
    }

  /* Get possible input filename and set up default_buffered_input or
     default_input as appropriate. */
  if (shell_script_filename)
    open_shell_script (shell_script_filename);
  else if (interactive == 0)
    {
      /* In this mode, bash is reading a script from stdin, which is a
	 pipe or redirected file. */
#if defined (BUFFERED_INPUT)
      default_buffered_input = fileno (stdin);	/* == 0 */
#else
      setbuf (default_input, (char *)NULL);
#endif /* !BUFFERED_INPUT */
      read_from_stdin = 1;
    }
  else if (top_level_arg_index == argc)		/* arg index before startup files */
    /* "If there are no operands and the -c option is not specified, the -s
       option shall be assumed." */
    read_from_stdin = 1;

  set_bash_input ();

  if (debugging_mode && locally_skip_execution == 0 && running_setuid == 0 && (reading_shell_script || interactive_shell == 0))
    start_debugger ();

  /* Do the things that should be done only for interactive shells. */
  if (interactive_shell)
    {
      /* Set up for checking for presence of mail. */
      reset_mail_timer ();
      init_mail_dates ();

#if defined (HISTORY)
      /* Initialize the interactive history stuff. */
      bash_initialize_history ();
      /* Don't load the history from the history file if we've already
	 saved some lines in this session (e.g., by putting `history -s xx'
	 into one of the startup files). */
      if (shell_initialized == 0 && history_lines_this_session == 0)
	load_history ();
#endif /* HISTORY */

      /* Initialize terminal state for interactive shells after the
	 .bash_profile and .bashrc are interpreted. */
      get_tty_state ();
    }

#if !defined (ONESHOT)
 read_and_execute:
#endif /* !ONESHOT */

  shell_initialized = 1;

  if (pretty_print_mode && interactive_shell)
    {
      internal_warning (_("pretty-printing mode ignored in interactive shells"));
      pretty_print_mode = 0;
    }
  if (pretty_print_mode)
    exit_shell (pretty_print_loop ());

  /* Read commands until exit condition. */
  reader_loop ();
  exit_shell (last_command_exit_value);
}
warning: parse error {
  register int i;
  int code, old_errexit_flag;
#if defined (RESTRICTED_SHELL)
  int saverst;
#endif
  volatile int locally_skip_execution;
  volatile int arg_index, top_level_arg_index;
#ifdef __OPENNT
  char **env;

  env = environ;
#endif /* __OPENNT */

  USE_VAR(argc);
  USE_VAR(argv);
  USE_VAR(env);
  USE_VAR(code);
  USE_VAR(old_errexit_flag);
#if defined (RESTRICTED_SHELL)
  USE_VAR(saverst);
#endif

  /* Catch early SIGINTs. */
  code = setjmp_nosigs (top_level);
  if (code)
    exit (2);

  xtrace_init ();

#if defined (USING_BASH_MALLOC) && defined (DEBUG) && !defined (DISABLE_MALLOC_WRAPPERS)
  malloc_set_register (1);	/* XXX - change to 1 for malloc debugging */
#endif

  check_dev_tty ();

#ifdef __CYGWIN__
  _cygwin32_check_tmp ();
#endif /* __CYGWIN__ */

  /* Wait forever if we are debugging a login shell. */
  while (debugging_login_shell) sleep (3);

  set_default_locale ();

  running_setuid = uidget ();

  if (getenv ("POSIXLY_CORRECT") || getenv ("POSIX_PEDANTIC"))
    posixly_correct = 1;

#if defined (USE_GNU_MALLOC_LIBRARY)
  mcheck (programming_error, (void (*) ())0);
#endif /* USE_GNU_MALLOC_LIBRARY */

  if (setjmp_sigs (subshell_top_level))
    {
      argc = subshell_argc;
      argv = subshell_argv;
      env = subshell_envp;
      sourced_env = 0;
    }

  shell_reinitialized = 0;

  /* Initialize `local' variables for all `invocations' of main (). */
  arg_index = 1;
  if (arg_index > argc)
    arg_index = argc;
  command_execution_string = shell_script_filename = (char *)NULL;
  want_pending_command = locally_skip_execution = read_from_stdin = 0;
  default_input = stdin;
#if defined (BUFFERED_INPUT)
  default_buffered_input = -1;
#endif

  /* Fix for the `infinite process creation' bug when running shell scripts
     from startup files on System V. */
  login_shell = make_login_shell = 0;

  /* If this shell has already been run, then reinitialize it to a
     vanilla state. */
  if (shell_initialized || shell_name)
    {
      /* Make sure that we do not infinitely recurse as a login shell. */
      if (*shell_name == '-')
	shell_name++;

      shell_reinitialize ();
      if (setjmp_nosigs (top_level))
	exit (2);
    }

  shell_environment = env;
  set_shell_name (argv[0]);

  gettimeofday (&shellstart, 0);
  shell_start_time = shellstart.tv_sec;

  /* Parse argument flags from the input line. */

  /* Find full word arguments first. */
  arg_index = parse_long_options (argv, arg_index, argc);
  
  if (want_initial_help)
    {
      show_shell_usage (stdout, 1);
      exit (EXECUTION_SUCCESS);
    }

  if (do_version)
    {
      show_shell_version (1);
      exit (EXECUTION_SUCCESS);
    }

  echo_input_at_read = verbose_flag;	/* --verbose given */

  /* All done with full word options; do standard shell option parsing.*/
  this_command_name = shell_name;	/* for error reporting */
  arg_index = parse_shell_options (argv, arg_index, argc);

  /* If user supplied the "--login" (or -l) flag, then set and invert
     LOGIN_SHELL. */
  if (make_login_shell)
    {
      login_shell++;
      login_shell = -login_shell;
    }

  set_login_shell ("login_shell", login_shell != 0);

  if (dump_po_strings)
    dump_translatable_strings = 1;

  if (dump_translatable_strings)
    read_but_dont_execute = 1;

  if (running_setuid && privileged_mode == 0)
    disable_priv_mode ();

  /* Need to get the argument to a -c option processed in the
     above loop.  The next arg is a command to execute, and the
     following args are $0...$n respectively. */
  if (want_pending_command)
    {
      command_execution_string = argv[arg_index];
      if (command_execution_string == 0)
	{
	  report_error (_("%s: option requires an argument"), "-c");
	  exit (EX_BADUSAGE);
	}
      arg_index++;
    }
  this_command_name = (char *)NULL;

  /* First, let the outside world know about our interactive status.
     A shell is interactive if the `-i' flag was given, or if all of
     the following conditions are met:
	no -c command
	no arguments remaining or the -s flag given
	standard input is a terminal
	standard error is a terminal
     Refer to Posix.2, the description of the `sh' utility. */

  if (forced_interactive ||		/* -i flag */
      (!command_execution_string &&	/* No -c command and ... */
       wordexp_only == 0 &&		/* No --wordexp and ... */
       ((arg_index == argc) ||		/*   no remaining args or... */
	read_from_stdin) &&		/*   -s flag with args, and */
       isatty (fileno (stdin)) &&	/* Input is a terminal and */
       isatty (fileno (stderr))))	/* error output is a terminal. */
    init_interactive ();
  else
    init_noninteractive ();

  /*
   * Some systems have the bad habit of starting login shells with lots of open
   * file descriptors.  For instance, most systems that have picked up the
   * pre-4.0 Sun YP code leave a file descriptor open each time you call one
   * of the getpw* functions, and it's set to be open across execs.  That
   * means one for login, one for xterm, one for shelltool, etc.  There are
   * also systems that open persistent FDs to other agents or files as part
   * of process startup; these need to be set to be close-on-exec.
   */
  if (login_shell && interactive_shell)
    {
      for (i = 3; i < 20; i++)
	SET_CLOSE_ON_EXEC (i);
    }

  /* If we're in a strict Posix.2 mode, turn on interactive comments,
     alias expansion in non-interactive shells, and other Posix.2 things. */
  if (posixly_correct)
    {
      bind_variable ("POSIXLY_CORRECT", "y", 0);
      sv_strict_posix ("POSIXLY_CORRECT");
    }

  /* Now we run the shopt_alist and process the options. */
  if (shopt_alist)
    run_shopt_alist ();

  /* From here on in, the shell must be a normal functioning shell.
     Variables from the environment are expected to be set, etc. */
  shell_initialize ();

  set_default_lang ();
  set_default_locale_vars ();

  /*
   * M-x term -> TERM=eterm-color INSIDE_EMACS='251,term:0.96' (eterm)
   * M-x shell -> TERM='dumb' INSIDE_EMACS='25.1,comint' (no line editing)
   *
   * Older versions of Emacs may set EMACS to 't' or to something like
   * '22.1 (term:0.96)' instead of (or in addition to) setting INSIDE_EMACS.
   * They may set TERM to 'eterm' instead of 'eterm-color'.  They may have
   * a now-obsolete command that sets neither EMACS nor INSIDE_EMACS:
   * M-x terminal -> TERM='emacs-em7955' (line editing)
   */
  if (interactive_shell)
    {
      char *term, *emacs, *inside_emacs;
      int emacs_term, in_emacs;

      term = get_string_value ("TERM");
      emacs = get_string_value ("EMACS");
      inside_emacs = get_string_value ("INSIDE_EMACS");

      if (inside_emacs)
	{
	  emacs_term = strstr (inside_emacs, ",term:") != 0;
	  in_emacs = 1;
	}
      else if (emacs)
	{
	  /* Infer whether we are in an older Emacs. */
	  emacs_term = strstr (emacs, " (term:") != 0;
	  in_emacs = emacs_term || STREQ (emacs, "t");
	}
      else
	in_emacs = emacs_term = 0;

      /* Not sure any emacs terminal emulator sets TERM=emacs any more */
      no_line_editing |= STREQ (term, "emacs");
      no_line_editing |= in_emacs && STREQ (term, "dumb");

      /* running_under_emacs == 2 for `eterm' */
      running_under_emacs = in_emacs || STREQN (term, "emacs", 5);
      running_under_emacs += emacs_term && STREQN (term, "eterm", 5);

      if (running_under_emacs)
	gnu_error_format = 1;
    }

  top_level_arg_index = arg_index;
  old_errexit_flag = exit_immediately_on_error;

  /* Give this shell a place to longjmp to before executing the
     startup files.  This allows users to press C-c to abort the
     lengthy startup. */
  code = setjmp_sigs (top_level);
  if (code)
    {
      if (code == EXITPROG || code == ERREXIT)
	exit_shell (last_command_exit_value);
      else
	{
#if defined (JOB_CONTROL)
	  /* Reset job control, since run_startup_files turned it off. */
	  set_job_control (interactive_shell);
#endif
	  /* Reset value of `set -e', since it's turned off before running
	     the startup files. */
	  exit_immediately_on_error += old_errexit_flag;
	  locally_skip_execution++;
	}
    }

  arg_index = top_level_arg_index;

  /* Execute the start-up scripts. */

  if (interactive_shell == 0)
    {
      unbind_variable ("PS1");
      unbind_variable ("PS2");
      interactive = 0;
#if 0
      /* This has already been done by init_noninteractive */
      expand_aliases = posixly_correct;
#endif
    }
  else
    {
      change_flag ('i', FLAG_ON);
      interactive = 1;
    }

#if defined (RESTRICTED_SHELL)
  /* Set restricted_shell based on whether the basename of $0 indicates that
     the shell should be restricted or if the `-r' option was supplied at
     startup. */
  restricted_shell = shell_is_restricted (shell_name);

  /* If the `-r' option is supplied at invocation, make sure that the shell
     is not in restricted mode when running the startup files. */
  saverst = restricted;
  restricted = 0;
#endif

  /* Set positional parameters before running startup files. top_level_arg_index
     holds the index of the current argument before setting the positional
     parameters, so any changes performed in the startup files won't affect
     later option processing. */
  if (wordexp_only)
    ;			/* nothing yet */
  else if (command_execution_string)
    arg_index = bind_args (argv, arg_index, argc, 0);	/* $0 ... $n */
  else if (arg_index != argc && read_from_stdin == 0)
    {
      shell_script_filename = argv[arg_index++];
      arg_index = bind_args (argv, arg_index, argc, 1);	/* $1 ... $n */
    }
  else
    arg_index = bind_args (argv, arg_index, argc, 1);	/* $1 ... $n */

  /* The startup files are run with `set -e' temporarily disabled. */
  if (locally_skip_execution == 0 && running_setuid == 0)
    {
      old_errexit_flag = exit_immediately_on_error;
      exit_immediately_on_error = 0;

      run_startup_files ();
      exit_immediately_on_error += old_errexit_flag;
    }

  /* If we are invoked as `sh', turn on Posix mode. */
  if (act_like_sh)
    {
      bind_variable ("POSIXLY_CORRECT", "y", 0);
      sv_strict_posix ("POSIXLY_CORRECT");
    }

#if defined (RESTRICTED_SHELL)
  /* Turn on the restrictions after executing the startup files.  This
     means that `bash -r' or `set -r' invoked from a startup file will
     turn on the restrictions after the startup files are executed. */
  restricted = saverst || restricted;
  if (shell_reinitialized == 0)
    maybe_make_restricted (shell_name);
#endif /* RESTRICTED_SHELL */

#if defined (WORDEXP_OPTION)
  if (wordexp_only)
    {
      startup_state = 3;
      last_command_exit_value = run_wordexp (argv[top_level_arg_index]);
      exit_shell (last_command_exit_value);
    }
#endif

  cmd_init ();		/* initialize the command object caches */
  uwp_init ();

  if (command_execution_string)
    {
      startup_state = 2;

      if (debugging_mode)
	start_debugger ();

#if defined (ONESHOT)
      executing = 1;
      run_one_command (command_execution_string);
      exit_shell (last_command_exit_value);
#else /* ONESHOT */
      with_input_from_string (command_execution_string, "-c");
      goto read_and_execute;
#endif /* !ONESHOT */
    }

  /* Get possible input filename and set up default_buffered_input or
     default_input as appropriate. */
  if (shell_script_filename)
    open_shell_script (shell_script_filename);
  else if (interactive == 0)
    {
      /* In this mode, bash is reading a script from stdin, which is a
	 pipe or redirected file. */
#if defined (BUFFERED_INPUT)
      default_buffered_input = fileno (stdin);	/* == 0 */
#else
      setbuf (default_input, (char *)NULL);
#endif /* !BUFFERED_INPUT */
      read_from_stdin = 1;
    }
  else if (top_level_arg_index == argc)		/* arg index before startup files */
    /* "If there are no operands and the -c option is not specified, the -s
       option shall be assumed." */
    read_from_stdin = 1;

  set_bash_input ();

  if (debugging_mode && locally_skip_execution == 0 && running_setuid == 0 && (reading_shell_script || interactive_shell == 0))
    start_debugger ();

  /* Do the things that should be done only for interactive shells. */
  if (interactive_shell)
    {
      /* Set up for checking for presence of mail. */
      reset_mail_timer ();
      init_mail_dates ();

#if defined (HISTORY)
      /* Initialize the interactive history stuff. */
      bash_initialize_history ();
      /* Don't load the history from the history file if we've already
	 saved some lines in this session (e.g., by putting `history -s xx'
	 into one of the startup files). */
      if (shell_initialized == 0 && history_lines_this_session == 0)
	load_history ();
#endif /* HISTORY */

      /* Initialize terminal state for interactive shells after the
	 .bash_profile and .bashrc are interpreted. */
      get_tty_state ();
    }

#if !defined (ONESHOT)
 read_and_execute:
#endif /* !ONESHOT */

  shell_initialized = 1;

  if (pretty_print_mode && interactive_shell)
    {
      internal_warning (_("pretty-printing mode ignored in interactive shells"));
      pretty_print_mode = 0;
    }
  if (pretty_print_mode)
    exit_shell (pretty_print_loop ());

  /* Read commands until exit condition. */
  reader_loop ();
  exit_shell (last_command_exit_value);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\shell.c:368
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\shell.c:816
parsing error 
{
  int arg_index, longarg, i;
  char *arg_string;

  arg_index = arg_start;
  while ((arg_index != arg_end) && (arg_string = argv[arg_index]) &&
	 (*arg_string == '-'))
    {
      longarg = 0;

      /* Make --login equivalent to -login. */
      if (arg_string[1] == '-' && arg_string[2])
	{
	  longarg = 1;
	  arg_string++;
	}

      for (i = 0; long_args[i].name; i++)
	{
	  if (STREQ (arg_string + 1, long_args[i].name))
	    {
	      if (long_args[i].type == Int)
		*long_args[i].int_value = 1;
	      else if (argv[++arg_index] == 0)
		{
		  report_error (_("%s: option requires an argument"), long_args[i].name);
		  exit (EX_BADUSAGE);
		}
	      else
		*long_args[i].char_value = argv[arg_index];

	      break;
	    }
	}
      if (long_args[i].name == 0)
	{
	  if (longarg)
	    {
	      report_error (_("%s: invalid option"), argv[arg_index]);
	      show_shell_usage (stderr, 0);
	      exit (EX_BADUSAGE);
	    }
	  break;		/* No such argument.  Maybe flag arg. */
	}

      arg_index++;
    }

  return (arg_index);
}
warning: parse error {
  int arg_index, longarg, i;
  char *arg_string;

  arg_index = arg_start;
  while ((arg_index != arg_end) && (arg_string = argv[arg_index]) &&
	 (*arg_string == '-'))
    {
      longarg = 0;

      /* Make --login equivalent to -login. */
      if (arg_string[1] == '-' && arg_string[2])
	{
	  longarg = 1;
	  arg_string++;
	}

      for (i = 0; long_args[i].name; i++)
	{
	  if (STREQ (arg_string + 1, long_args[i].name))
	    {
	      if (long_args[i].type == Int)
		*long_args[i].int_value = 1;
	      else if (argv[++arg_index] == 0)
		{
		  report_error (_("%s: option requires an argument"), long_args[i].name);
		  exit (EX_BADUSAGE);
		}
	      else
		*long_args[i].char_value = argv[arg_index];

	      break;
	    }
	}
      if (long_args[i].name == 0)
	{
	  if (longarg)
	    {
	      report_error (_("%s: invalid option"), argv[arg_index]);
	      show_shell_usage (stderr, 0);
	      exit (EX_BADUSAGE);
	    }
	  break;		/* No such argument.  Maybe flag arg. */
	}

      arg_index++;
    }

  return (arg_index);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\shell.c:819
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\shell.c:871
parsing error 
{
  int arg_index;
  int arg_character, on_or_off, next_arg, i;
  char *o_option, *arg_string;

  arg_index = arg_start;
  while (arg_index != arg_end && (arg_string = argv[arg_index]) &&
	 (*arg_string == '-' || *arg_string == '+'))
    {
      /* There are flag arguments, so parse them. */
      next_arg = arg_index + 1;

      /* A single `-' signals the end of options.  From the 4.3 BSD sh.
	 An option `--' means the same thing; this is the standard
	 getopt(3) meaning. */
      if (arg_string[0] == '-' &&
	   (arg_string[1] == '\0' ||
	     (arg_string[1] == '-' && arg_string[2] == '\0')))
	return (next_arg);

      i = 1;
      on_or_off = arg_string[0];
      while (arg_character = arg_string[i++])
	{
	  switch (arg_character)
	    {
	    case 'c':
	      want_pending_command = 1;
	      break;

	    case 'l':
	      make_login_shell = 1;
	      break;

	    case 's':
	      read_from_stdin = 1;
	      break;

	    case 'o':
	      o_option = argv[next_arg];
	      if (o_option == 0)
		{
		  set_option_defaults ();
		  list_minus_o_opts (-1, (on_or_off == '-') ? 0 : 1);
		  reset_option_defaults ();
		  break;
		}
	      if (set_minus_o_option (on_or_off, o_option) != EXECUTION_SUCCESS)
		exit (EX_BADUSAGE);
	      next_arg++;
	      break;

	    case 'O':
	      /* Since some of these can be overridden by the normal
		 interactive/non-interactive shell initialization or
		 initializing posix mode, we save the options and process
		 them after initialization. */
	      o_option = argv[next_arg];
	      if (o_option == 0)
		{
		  shopt_listopt (o_option, (on_or_off == '-') ? 0 : 1);
		  break;
		}
	      add_shopt_to_alist (o_option, on_or_off);
	      next_arg++;
	      break;

	    case 'D':
	      dump_translatable_strings = 1;
	      break;

	    default:
	      if (change_flag (arg_character, on_or_off) == FLAG_ERROR)
		{
		  report_error (_("%c%c: invalid option"), on_or_off, arg_character);
		  show_shell_usage (stderr, 0);
		  exit (EX_BADUSAGE);
		}
	    }
	}
      /* Can't do just a simple increment anymore -- what about
	 "bash -abouo emacs ignoreeof -hP"? */
      arg_index = next_arg;
    }

  return (arg_index);
}
warning: parse error {
  int arg_index;
  int arg_character, on_or_off, next_arg, i;
  char *o_option, *arg_string;

  arg_index = arg_start;
  while (arg_index != arg_end && (arg_string = argv[arg_index]) &&
	 (*arg_string == '-' || *arg_string == '+'))
    {
      /* There are flag arguments, so parse them. */
      next_arg = arg_index + 1;

      /* A single `-' signals the end of options.  From the 4.3 BSD sh.
	 An option `--' means the same thing; this is the standard
	 getopt(3) meaning. */
      if (arg_string[0] == '-' &&
	   (arg_string[1] == '\0' ||
	     (arg_string[1] == '-' && arg_string[2] == '\0')))
	return (next_arg);

      i = 1;
      on_or_off = arg_string[0];
      while (arg_character = arg_string[i++])
	{
	  switch (arg_character)
	    {
	    case 'c':
	      want_pending_command = 1;
	      break;

	    case 'l':
	      make_login_shell = 1;
	      break;

	    case 's':
	      read_from_stdin = 1;
	      break;

	    case 'o':
	      o_option = argv[next_arg];
	      if (o_option == 0)
		{
		  set_option_defaults ();
		  list_minus_o_opts (-1, (on_or_off == '-') ? 0 : 1);
		  reset_option_defaults ();
		  break;
		}
	      if (set_minus_o_option (on_or_off, o_option) != EXECUTION_SUCCESS)
		exit (EX_BADUSAGE);
	      next_arg++;
	      break;

	    case 'O':
	      /* Since some of these can be overridden by the normal
		 interactive/non-interactive shell initialization or
		 initializing posix mode, we save the options and process
		 them after initialization. */
	      o_option = argv[next_arg];
	      if (o_option == 0)
		{
		  shopt_listopt (o_option, (on_or_off == '-') ? 0 : 1);
		  break;
		}
	      add_shopt_to_alist (o_option, on_or_off);
	      next_arg++;
	      break;

	    case 'D':
	      dump_translatable_strings = 1;
	      break;

	    default:
	      if (change_flag (arg_character, on_or_off) == FLAG_ERROR)
		{
		  report_error (_("%c%c: invalid option"), on_or_off, arg_character);
		  show_shell_usage (stderr, 0);
		  exit (EX_BADUSAGE);
		}
	    }
	}
      /* Can't do just a simple increment anymore -- what about
	 "bash -abouo emacs ignoreeof -hP"? */
      arg_index = next_arg;
    }

  return (arg_index);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\shell.c:874
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\shell.c:964
parsing error 
{
  fflush (stdout);		/* XXX */
  fflush (stderr);

  /* Clean up the terminal if we are in a state where it's been modified. */
#if defined (READLINE)
  if (RL_ISSTATE (RL_STATE_TERMPREPPED) && rl_deprep_term_function)
    (*rl_deprep_term_function) ();
#endif
  if (read_tty_modified ())
    read_tty_cleanup ();

  /* Do trap[0] if defined.  Allow it to override the exit status
     passed to us. */
  if (signal_is_trapped (0))
    s = run_exit_trap ();

#if defined (PROCESS_SUBSTITUTION)
  unlink_all_fifos ();
#endif /* PROCESS_SUBSTITUTION */

#if defined (HISTORY)
  if (remember_on_history)
    maybe_save_shell_history ();
#endif /* HISTORY */

#if defined (COPROCESS_SUPPORT)
  coproc_flush ();
#endif

#if defined (JOB_CONTROL)
  /* If the user has run `shopt -s huponexit', hangup all jobs when we exit
     an interactive login shell.  ksh does this unconditionally. */
  if (interactive_shell && login_shell && hup_on_exit)
    hangup_all_jobs ();

  /* If this shell is interactive, or job control is active, terminate all
     stopped jobs and restore the original terminal process group.  Don't do
     this if we're in a subshell and calling exit_shell after, for example,
     a failed word expansion.  We want to do this even if the shell is not
     interactive because we set the terminal's process group when job control
     is enabled regardless of the interactive status. */
  if (subshell_environment == 0)
    end_job_control ();
#endif /* JOB_CONTROL */

  /* Always return the exit status of the last command to our parent. */
  sh_exit (s);
}
warning: parse error {
  fflush (stdout);		/* XXX */
  fflush (stderr);

  /* Clean up the terminal if we are in a state where it's been modified. */
#if defined (READLINE)
  if (RL_ISSTATE (RL_STATE_TERMPREPPED) && rl_deprep_term_function)
    (*rl_deprep_term_function) ();
#endif
  if (read_tty_modified ())
    read_tty_cleanup ();

  /* Do trap[0] if defined.  Allow it to override the exit status
     passed to us. */
  if (signal_is_trapped (0))
    s = run_exit_trap ();

#if defined (PROCESS_SUBSTITUTION)
  unlink_all_fifos ();
#endif /* PROCESS_SUBSTITUTION */

#if defined (HISTORY)
  if (remember_on_history)
    maybe_save_shell_history ();
#endif /* HISTORY */

#if defined (COPROCESS_SUPPORT)
  coproc_flush ();
#endif

#if defined (JOB_CONTROL)
  /* If the user has run `shopt -s huponexit', hangup all jobs when we exit
     an interactive login shell.  ksh does this unconditionally. */
  if (interactive_shell && login_shell && hup_on_exit)
    hangup_all_jobs ();

  /* If this shell is interactive, or job control is active, terminate all
     stopped jobs and restore the original terminal process group.  Don't do
     this if we're in a subshell and calling exit_shell after, for example,
     a failed word expansion.  We want to do this even if the shell is not
     interactive because we set the terminal's process group when job control
     is enabled regardless of the interactive status. */
  if (subshell_environment == 0)
    end_job_control ();
#endif /* JOB_CONTROL */

  /* Always return the exit status of the last command to our parent. */
  sh_exit (s);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\shell.c:966
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\shell.c:1,019
parsing error 
{
#if defined (MALLOC_DEBUG) && defined (USING_BASH_MALLOC)
  if (malloc_trace_at_exit && (subshell_environment & (SUBSHELL_COMSUB|SUBSHELL_PROCSUB)) == 0)
    trace_malloc_stats (get_name_for_error (), (char *)NULL);
  /* mlocation_write_table (); */
#endif

  exit (s);
}
warning: parse error {
#if defined (MALLOC_DEBUG) && defined (USING_BASH_MALLOC)
  if (malloc_trace_at_exit && (subshell_environment & (SUBSHELL_COMSUB|SUBSHELL_PROCSUB)) == 0)
    trace_malloc_stats (get_name_for_error (), (char *)NULL);
  /* mlocation_write_table (); */
#endif

  exit (s);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\shell.c:1,021
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\shell.c:1,035
parsing error 
{
  fflush (stdout);
  fflush (stderr);

  /* Do trap[0] if defined.  Allow it to override the exit status
     passed to us. */
  if (signal_is_trapped (0))
    s = run_exit_trap ();

  sh_exit (s);
}
warning: parse error {
  fflush (stdout);
  fflush (stderr);

  /* Do trap[0] if defined.  Allow it to override the exit status
     passed to us. */
  if (signal_is_trapped (0))
    s = run_exit_trap ();

  sh_exit (s);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\shell.c:1,037
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\shell.c:1,050
parsing error 
{
  set_pipestatus_from_exit (last_command_exit_value = s);
}
warning: parse error {
  set_pipestatus_from_exit (last_command_exit_value = s);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\shell.c:1,052
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\shell.c:1,084
parsing error 
{
  char *fn;

  if (env_file && *env_file)
    {
      fn = expand_string_unsplit_to_string (env_file, Q_DOUBLE_QUOTES);
      if (fn && *fn)
	maybe_execute_file (fn, 1);
      FREE (fn);
    }
}
warning: parse error {
  char *fn;

  if (env_file && *env_file)
    {
      fn = expand_string_unsplit_to_string (env_file, Q_DOUBLE_QUOTES);
      if (fn && *fn)
	maybe_execute_file (fn, 1);
      FREE (fn);
    }
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\shell.c:1,086
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\shell.c:1,445
parsing error 
{
  register int i;
  WORD_LIST *args, *tl;

  for (i = arg_start, args = tl = (WORD_LIST *)NULL; i < arg_end; i++)
    {
      if (args == 0)
	args = tl = make_word_list (make_word (argv[i]), args);
      else
	{
	  tl->next = make_word_list (make_word (argv[i]), (WORD_LIST *)NULL);
	  tl = tl->next;
	}
    }

  if (args)
    {
      if (start_index == 0)	/* bind to $0...$n for sh -c command */
	{
	  /* Posix.2 4.56.3 says that the first argument after sh -c command
	     becomes $0, and the rest of the arguments become $1...$n */
	  shell_name = savestring (args->word->word);
	  FREE (dollar_vars[0]);
	  dollar_vars[0] = savestring (args->word->word);
	  remember_args (args->next, 1);
	  if (debugging_mode)
	    {
	      push_args (args->next);	/* BASH_ARGV and BASH_ARGC */
	      bash_argv_initialized = 1;
	    }
	}
      else			/* bind to $1...$n for shell script */
        {
	  remember_args (args, 1);
	  /* We do this unconditionally so something like -O extdebug doesn't
	     do it first.  We're setting the definitive positional params
	     here. */
	  if (debugging_mode)
	    {
	      push_args (args);		/* BASH_ARGV and BASH_ARGC */
	      bash_argv_initialized = 1;
	    }
        }

      dispose_words (args);
    }

  return (i);
}
warning: parse error {
  register int i;
  WORD_LIST *args, *tl;

  for (i = arg_start, args = tl = (WORD_LIST *)NULL; i < arg_end; i++)
    {
      if (args == 0)
	args = tl = make_word_list (make_word (argv[i]), args);
      else
	{
	  tl->next = make_word_list (make_word (argv[i]), (WORD_LIST *)NULL);
	  tl = tl->next;
	}
    }

  if (args)
    {
      if (start_index == 0)	/* bind to $0...$n for sh -c command */
	{
	  /* Posix.2 4.56.3 says that the first argument after sh -c command
	     becomes $0, and the rest of the arguments become $1...$n */
	  shell_name = savestring (args->word->word);
	  FREE (dollar_vars[0]);
	  dollar_vars[0] = savestring (args->word->word);
	  remember_args (args->next, 1);
	  if (debugging_mode)
	    {
	      push_args (args->next);	/* BASH_ARGV and BASH_ARGC */
	      bash_argv_initialized = 1;
	    }
	}
      else			/* bind to $1...$n for shell script */
        {
	  remember_args (args, 1);
	  /* We do this unconditionally so something like -O extdebug doesn't
	     do it first.  We're setting the definitive positional params
	     here. */
	  if (debugging_mode)
	    {
	      push_args (args);		/* BASH_ARGV and BASH_ARGC */
	      bash_argv_initialized = 1;
	    }
        }

      dispose_words (args);
    }

  return (i);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\shell.c:1,448
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\shell.c:1,531
parsing error 
{
  int fd, e, fd_is_tty;
  char *filename, *path_filename, *t;
  char sample[80];
  int sample_len;
  struct stat sb;
#if defined (ARRAY_VARS)
  SHELL_VAR *funcname_v, *bash_source_v, *bash_lineno_v;
  ARRAY *funcname_a, *bash_source_a, *bash_lineno_a;
#endif

  filename = savestring (script_name);

  fd = open (filename, O_RDONLY);
  if ((fd < 0) && (errno == ENOENT) && (absolute_program (filename) == 0))
    {
      e = errno;
      /* If it's not in the current directory, try looking through PATH
	 for it. */
      path_filename = find_path_file (script_name);
      if (path_filename)
	{
	  free (filename);
	  filename = path_filename;
	  fd = open (filename, O_RDONLY);
	}
      else
	errno = e;
    }

  if (fd < 0)
    {
      e = errno;
      file_error (filename);
#if defined (JOB_CONTROL)
      end_job_control ();	/* just in case we were run as bash -i script */
#endif
      sh_exit ((e == ENOENT) ? EX_NOTFOUND : EX_NOINPUT);
    }

  free (dollar_vars[0]);
  dollar_vars[0] = exec_argv0 ? savestring (exec_argv0) : savestring (script_name);
  if (exec_argv0)
    {
      free (exec_argv0);
      exec_argv0 = (char *)NULL;
    }

  if (file_isdir (filename))
    {
#if defined (EISDIR)
      errno = EISDIR;
#else
      errno = EINVAL;
#endif
      file_error (filename);
#if defined (JOB_CONTROL)
      end_job_control ();	/* just in case we were run as bash -i script */
#endif
      sh_exit (EX_NOINPUT);
    }

#if defined (ARRAY_VARS)
  GET_ARRAY_FROM_VAR ("FUNCNAME", funcname_v, funcname_a);
  GET_ARRAY_FROM_VAR ("BASH_SOURCE", bash_source_v, bash_source_a);
  GET_ARRAY_FROM_VAR ("BASH_LINENO", bash_lineno_v, bash_lineno_a);

  array_push (bash_source_a, filename);
  if (bash_lineno_a)
    {
      t = itos (executing_line_number ());
      array_push (bash_lineno_a, t);
      free (t);
    }
  array_push (funcname_a, "main");
#endif

#ifdef HAVE_DEV_FD
  fd_is_tty = isatty (fd);
#else
  fd_is_tty = 0;
#endif

  /* Only do this with non-tty file descriptors we can seek on. */
  if (fd_is_tty == 0 && (lseek (fd, 0L, 1) != -1))
    {
      /* Check to see if the `file' in `bash file' is a binary file
	 according to the same tests done by execute_simple_command (),
	 and report an error and exit if it is. */
      sample_len = read (fd, sample, sizeof (sample));
      if (sample_len < 0)
	{
	  e = errno;
	  if ((fstat (fd, &sb) == 0) && S_ISDIR (sb.st_mode))
	    {
#if defined (EISDIR)
	      errno = EISDIR;
	      file_error (filename);
#else	      
	      internal_error (_("%s: Is a directory"), filename);
#endif
	    }
	  else
	    {
	      errno = e;
	      file_error (filename);
	    }
#if defined (JOB_CONTROL)
	  end_job_control ();	/* just in case we were run as bash -i script */
#endif
	  exit (EX_NOEXEC);
	}
      else if (sample_len > 0 && (check_binary_file (sample, sample_len)))
	{
	  internal_error (_("%s: cannot execute binary file"), filename);
#if defined (JOB_CONTROL)
	  end_job_control ();	/* just in case we were run as bash -i script */
#endif
	  exit (EX_BINARY_FILE);
	}
      /* Now rewind the file back to the beginning. */
      lseek (fd, 0L, 0);
    }

  /* Open the script.  But try to move the file descriptor to a randomly
     large one, in the hopes that any descriptors used by the script will
     not match with ours. */
  fd = move_to_high_fd (fd, 1, -1);

#if defined (BUFFERED_INPUT)
  default_buffered_input = fd;
  SET_CLOSE_ON_EXEC (default_buffered_input);
#else /* !BUFFERED_INPUT */
  default_input = fdopen (fd, "r");

  if (default_input == 0)
    {
      file_error (filename);
      exit (EX_NOTFOUND);
    }

  SET_CLOSE_ON_EXEC (fd);
  if (fileno (default_input) != fd)
    SET_CLOSE_ON_EXEC (fileno (default_input));
#endif /* !BUFFERED_INPUT */

  /* Just about the only way for this code to be executed is if something
     like `bash -i /dev/stdin' is executed. */
  if (interactive_shell && fd_is_tty)
    {
      dup2 (fd, 0);
      close (fd);
      fd = 0;
#if defined (BUFFERED_INPUT)
      default_buffered_input = 0;
#else
      fclose (default_input);
      default_input = stdin;
#endif
    }
  else if (forced_interactive && fd_is_tty == 0)
    /* But if a script is called with something like `bash -i scriptname',
       we need to do a non-interactive setup here, since we didn't do it
       before. */
    init_interactive_script ();

  free (filename);

  reading_shell_script = 1;
  return (fd);
}
warning: parse error {
  int fd, e, fd_is_tty;
  char *filename, *path_filename, *t;
  char sample[80];
  int sample_len;
  struct stat sb;
#if defined (ARRAY_VARS)
  SHELL_VAR *funcname_v, *bash_source_v, *bash_lineno_v;
  ARRAY *funcname_a, *bash_source_a, *bash_lineno_a;
#endif

  filename = savestring (script_name);

  fd = open (filename, O_RDONLY);
  if ((fd < 0) && (errno == ENOENT) && (absolute_program (filename) == 0))
    {
      e = errno;
      /* If it's not in the current directory, try looking through PATH
	 for it. */
      path_filename = find_path_file (script_name);
      if (path_filename)
	{
	  free (filename);
	  filename = path_filename;
	  fd = open (filename, O_RDONLY);
	}
      else
	errno = e;
    }

  if (fd < 0)
    {
      e = errno;
      file_error (filename);
#if defined (JOB_CONTROL)
      end_job_control ();	/* just in case we were run as bash -i script */
#endif
      sh_exit ((e == ENOENT) ? EX_NOTFOUND : EX_NOINPUT);
    }

  free (dollar_vars[0]);
  dollar_vars[0] = exec_argv0 ? savestring (exec_argv0) : savestring (script_name);
  if (exec_argv0)
    {
      free (exec_argv0);
      exec_argv0 = (char *)NULL;
    }

  if (file_isdir (filename))
    {
#if defined (EISDIR)
      errno = EISDIR;
#else
      errno = EINVAL;
#endif
      file_error (filename);
#if defined (JOB_CONTROL)
      end_job_control ();	/* just in case we were run as bash -i script */
#endif
      sh_exit (EX_NOINPUT);
    }

#if defined (ARRAY_VARS)
  GET_ARRAY_FROM_VAR ("FUNCNAME", funcname_v, funcname_a);
  GET_ARRAY_FROM_VAR ("BASH_SOURCE", bash_source_v, bash_source_a);
  GET_ARRAY_FROM_VAR ("BASH_LINENO", bash_lineno_v, bash_lineno_a);

  array_push (bash_source_a, filename);
  if (bash_lineno_a)
    {
      t = itos (executing_line_number ());
      array_push (bash_lineno_a, t);
      free (t);
    }
  array_push (funcname_a, "main");
#endif

#ifdef HAVE_DEV_FD
  fd_is_tty = isatty (fd);
#else
  fd_is_tty = 0;
#endif

  /* Only do this with non-tty file descriptors we can seek on. */
  if (fd_is_tty == 0 && (lseek (fd, 0L, 1) != -1))
    {
      /* Check to see if the `file' in `bash file' is a binary file
	 according to the same tests done by execute_simple_command (),
	 and report an error and exit if it is. */
      sample_len = read (fd, sample, sizeof (sample));
      if (sample_len < 0)
	{
	  e = errno;
	  if ((fstat (fd, &sb) == 0) && S_ISDIR (sb.st_mode))
	    {
#if defined (EISDIR)
	      errno = EISDIR;
	      file_error (filename);
#else	      
	      internal_error (_("%s: Is a directory"), filename);
#endif
	    }
	  else
	    {
	      errno = e;
	      file_error (filename);
	    }
#if defined (JOB_CONTROL)
	  end_job_control ();	/* just in case we were run as bash -i script */
#endif
	  exit (EX_NOEXEC);
	}
      else if (sample_len > 0 && (check_binary_file (sample, sample_len)))
	{
	  internal_error (_("%s: cannot execute binary file"), filename);
#if defined (JOB_CONTROL)
	  end_job_control ();	/* just in case we were run as bash -i script */
#endif
	  exit (EX_BINARY_FILE);
	}
      /* Now rewind the file back to the beginning. */
      lseek (fd, 0L, 0);
    }

  /* Open the script.  But try to move the file descriptor to a randomly
     large one, in the hopes that any descriptors used by the script will
     not match with ours. */
  fd = move_to_high_fd (fd, 1, -1);

#if defined (BUFFERED_INPUT)
  default_buffered_input = fd;
  SET_CLOSE_ON_EXEC (default_buffered_input);
#else /* !BUFFERED_INPUT */
  default_input = fdopen (fd, "r");

  if (default_input == 0)
    {
      file_error (filename);
      exit (EX_NOTFOUND);
    }

  SET_CLOSE_ON_EXEC (fd);
  if (fileno (default_input) != fd)
    SET_CLOSE_ON_EXEC (fileno (default_input));
#endif /* !BUFFERED_INPUT */

  /* Just about the only way for this code to be executed is if something
     like `bash -i /dev/stdin' is executed. */
  if (interactive_shell && fd_is_tty)
    {
      dup2 (fd, 0);
      close (fd);
      fd = 0;
#if defined (BUFFERED_INPUT)
      default_buffered_input = 0;
#else
      fclose (default_input);
      default_input = stdin;
#endif
    }
  else if (forced_interactive && fd_is_tty == 0)
    /* But if a script is called with something like `bash -i scriptname',
       we need to do a non-interactive setup here, since we didn't do it
       before. */
    init_interactive_script ();

  free (filename);

  reading_shell_script = 1;
  return (fd);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\shell.c:1,533
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\shell.c:1,734
parsing error 
{
#if defined (BUFFERED_INPUT)
  if ((check_zero && default_buffered_input >= 0) ||
      (check_zero == 0 && default_buffered_input > 0))
    {
      close_buffered_fd (default_buffered_input);
      default_buffered_input = bash_input.location.buffered_fd = -1;
      bash_input.type = st_none;		/* XXX */
    }
#else /* !BUFFERED_INPUT */
  if (default_input)
    {
      fclose (default_input);
      default_input = (FILE *)NULL;
    }
#endif /* !BUFFERED_INPUT */
}
warning: parse error {
#if defined (BUFFERED_INPUT)
  if ((check_zero && default_buffered_input >= 0) ||
      (check_zero == 0 && default_buffered_input > 0))
    {
      close_buffered_fd (default_buffered_input);
      default_buffered_input = bash_input.location.buffered_fd = -1;
      bash_input.type = st_none;		/* XXX */
    }
#else /* !BUFFERED_INPUT */
  if (default_input)
    {
      fclose (default_input);
      default_input = (FILE *)NULL;
    }
#endif /* !BUFFERED_INPUT */
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\shell.c:1,736
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\shell.c:1,760
parsing error 
{
  /* Here's a hack.  If the name of this shell is "sh", then don't do
     any startup files; just try to be more like /bin/sh. */
  shell_name = argv0 ? base_pathname (argv0) : PROGRAM;

  if (argv0 && *argv0 == '-')
    {
      if (*shell_name == '-')
	shell_name++;
      login_shell = 1;
    }

  if (shell_name[0] == 's' && shell_name[1] == 'h' && shell_name[2] == '\0')
    act_like_sh++;
  if (shell_name[0] == 's' && shell_name[1] == 'u' && shell_name[2] == '\0')
    su_shell++;

  shell_name = argv0 ? argv0 : PROGRAM;
  FREE (dollar_vars[0]);
  dollar_vars[0] = savestring (shell_name);

  /* A program may start an interactive shell with
	  "execl ("/bin/bash", "-", NULL)".
     If so, default the name of this shell to our name. */
  if (!shell_name || !*shell_name || (shell_name[0] == '-' && !shell_name[1]))
    shell_name = PROGRAM;
}
warning: parse error {
  /* Here's a hack.  If the name of this shell is "sh", then don't do
     any startup files; just try to be more like /bin/sh. */
  shell_name = argv0 ? base_pathname (argv0) : PROGRAM;

  if (argv0 && *argv0 == '-')
    {
      if (*shell_name == '-')
	shell_name++;
      login_shell = 1;
    }

  if (shell_name[0] == 's' && shell_name[1] == 'h' && shell_name[2] == '\0')
    act_like_sh++;
  if (shell_name[0] == 's' && shell_name[1] == 'u' && shell_name[2] == '\0')
    su_shell++;

  shell_name = argv0 ? argv0 : PROGRAM;
  FREE (dollar_vars[0]);
  dollar_vars[0] = savestring (shell_name);

  /* A program may start an interactive shell with
	  "execl ("/bin/bash", "-", NULL)".
     If so, default the name of this shell to our name. */
  if (!shell_name || !*shell_name || (shell_name[0] == '-' && !shell_name[1]))
    shell_name = PROGRAM;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\shell.c:1,762
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\shell.c:2,027
parsing error 
{
  int i;
  char *set_opts, *s, *t;

  if (extra)
    fprintf (fp, _("GNU bash, version %s-(%s)\n"), shell_version_string (), MACHTYPE);
  fprintf (fp, _("Usage:\t%s [GNU long option] [option] ...\n\t%s [GNU long option] [option] script-file ...\n"),
	     shell_name, shell_name);
  fputs (_("GNU long options:\n"), fp);
  for (i = 0; long_args[i].name; i++)
    fprintf (fp, "\t--%s\n", long_args[i].name);

  fputs (_("Shell options:\n"), fp);
  fputs (_("\t-ilrsD or -c command or -O shopt_option\t\t(invocation only)\n"), fp);

  for (i = 0, set_opts = 0; shell_builtins[i].name; i++)
    if (STREQ (shell_builtins[i].name, "set"))
      {
	set_opts = savestring (shell_builtins[i].short_doc);
	break;
      }

  if (set_opts)
    {
      s = strchr (set_opts, '[');
      if (s == 0)
	s = set_opts;
      while (*++s == '-')
	;
      t = strchr (s, ']');
      if (t)
	*t = '\0';
      fprintf (fp, _("\t-%s or -o option\n"), s);
      free (set_opts);
    }

  if (extra)
    {
      fprintf (fp, _("Type `%s -c \"help set\"' for more information about shell options.\n"), shell_name);
      fprintf (fp, _("Type `%s -c help' for more information about shell builtin commands.\n"), shell_name);
      fprintf (fp, _("Use the `bashbug' command to report bugs.\n"));
      fprintf (fp, "\n");
      fprintf (fp, _("bash home page: <http://www.gnu.org/software/bash>\n"));
      fprintf (fp, _("General help using GNU software: <http://www.gnu.org/gethelp/>\n"));
    }
}
warning: parse error {
  int i;
  char *set_opts, *s, *t;

  if (extra)
    fprintf (fp, _("GNU bash, version %s-(%s)\n"), shell_version_string (), MACHTYPE);
  fprintf (fp, _("Usage:\t%s [GNU long option] [option] ...\n\t%s [GNU long option] [option] script-file ...\n"),
	     shell_name, shell_name);
  fputs (_("GNU long options:\n"), fp);
  for (i = 0; long_args[i].name; i++)
    fprintf (fp, "\t--%s\n", long_args[i].name);

  fputs (_("Shell options:\n"), fp);
  fputs (_("\t-ilrsD or -c command or -O shopt_option\t\t(invocation only)\n"), fp);

  for (i = 0, set_opts = 0; shell_builtins[i].name; i++)
    if (STREQ (shell_builtins[i].name, "set"))
      {
	set_opts = savestring (shell_builtins[i].short_doc);
	break;
      }

  if (set_opts)
    {
      s = strchr (set_opts, '[');
      if (s == 0)
	s = set_opts;
      while (*++s == '-')
	;
      t = strchr (s, ']');
      if (t)
	*t = '\0';
      fprintf (fp, _("\t-%s or -o option\n"), s);
      free (set_opts);
    }

  if (extra)
    {
      fprintf (fp, _("Type `%s -c \"help set\"' for more information about shell options.\n"), shell_name);
      fprintf (fp, _("Type `%s -c help' for more information about shell builtin commands.\n"), shell_name);
      fprintf (fp, _("Use the `bashbug' command to report bugs.\n"));
      fprintf (fp, "\n");
      fprintf (fp, _("bash home page: <http://www.gnu.org/software/bash>\n"));
      fprintf (fp, _("General help using GNU software: <http://www.gnu.org/gethelp/>\n"));
    }
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\shell.c:2,030
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\shell.c:2,078
parsing error 
{
  if (shopt_ind >= shopt_len)
    {
      shopt_len += 8;
      shopt_alist = (STRING_INT_ALIST *)xrealloc (shopt_alist, shopt_len * sizeof (shopt_alist[0]));
    }
  shopt_alist[shopt_ind].word = opt;
  shopt_alist[shopt_ind].token = on_or_off;
  shopt_ind++;
}
warning: parse error {
  if (shopt_ind >= shopt_len)
    {
      shopt_len += 8;
      shopt_alist = (STRING_INT_ALIST *)xrealloc (shopt_alist, shopt_len * sizeof (shopt_alist[0]));
    }
  shopt_alist[shopt_ind].word = opt;
  shopt_alist[shopt_ind].token = on_or_off;
  shopt_ind++;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\shell.c:2,081
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\sig.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashtypes.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashintl.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\shell.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\execute_cmd.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\jobs.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\siglist.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\sig.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\trap.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\common.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\sig.c:98
parsing error 
{
  initialize_shell_signals ();
  initialize_job_signals ();
#if !defined (HAVE_SYS_SIGLIST) && !defined (HAVE_UNDER_SYS_SIGLIST) && !defined (HAVE_STRSIGNAL)
  if (reinit == 0)
    initialize_siglist ();
#endif /* !HAVE_SYS_SIGLIST && !HAVE_UNDER_SYS_SIGLIST && !HAVE_STRSIGNAL */
}
warning: parse error {
  initialize_shell_signals ();
  initialize_job_signals ();
#if !defined (HAVE_SYS_SIGLIST) && !defined (HAVE_UNDER_SYS_SIGLIST) && !defined (HAVE_STRSIGNAL)
  if (reinit == 0)
    initialize_siglist ();
#endif /* !HAVE_SYS_SIGLIST && !HAVE_UNDER_SYS_SIGLIST && !HAVE_STRSIGNAL */
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\sig.c:100
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\sig.c:467
parsing error 
{
  sh_longjmp (top_level, value);
}
warning: parse error {
  sh_longjmp (top_level, value);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\sig.c:469
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\sig.c:482
parsing error 
{
  /* If we get called twice with the same signal before handling it,
     terminate right away. */
  if (
#ifdef SIGHUP
    sig != SIGHUP &&
#endif
#ifdef SIGINT
    sig != SIGINT &&
#endif
#ifdef SIGDANGER
    sig != SIGDANGER &&
#endif
#ifdef SIGPIPE
    sig != SIGPIPE &&
#endif
#ifdef SIGALRM
    sig != SIGALRM &&
#endif
#ifdef SIGTERM
    sig != SIGTERM &&
#endif
#ifdef SIGXCPU
    sig != SIGXCPU &&
#endif
#ifdef SIGXFSZ
    sig != SIGXFSZ &&
#endif
#ifdef SIGVTALRM
    sig != SIGVTALRM &&
#endif
#ifdef SIGLOST
    sig != SIGLOST &&
#endif
#ifdef SIGUSR1
    sig != SIGUSR1 &&
#endif
#ifdef SIGUSR2
   sig != SIGUSR2 &&
#endif
   sig == terminating_signal)
    terminate_immediately = 1;

  terminating_signal = sig;

  if (terminate_immediately)
    {
#if defined (HISTORY)
      /* XXX - will inhibit history file being written */
#  if defined (READLINE)
      if (interactive_shell == 0 || interactive == 0 || (sig != SIGHUP && sig != SIGTERM) || no_line_editing || (RL_ISSTATE (RL_STATE_READCMD) == 0))
#  endif
        history_lines_this_session = 0;
#endif
      terminate_immediately = 0;
      termsig_handler (sig);
    }

#if defined (READLINE)
  /* Set the event hook so readline will call it after the signal handlers
     finish executing, so if this interrupted character input we can get
     quick response.  If readline is active or has modified the terminal we
     need to set this no matter what the signal is, though the check for
     RL_STATE_TERMPREPPED is possibly redundant. */
  if (RL_ISSTATE (RL_STATE_SIGHANDLER) || RL_ISSTATE (RL_STATE_TERMPREPPED))
    bashline_set_event_hook ();
#endif

  SIGRETURN (0);
}
warning: parse error {
  /* If we get called twice with the same signal before handling it,
     terminate right away. */
  if (
#ifdef SIGHUP
    sig != SIGHUP &&
#endif
#ifdef SIGINT
    sig != SIGINT &&
#endif
#ifdef SIGDANGER
    sig != SIGDANGER &&
#endif
#ifdef SIGPIPE
    sig != SIGPIPE &&
#endif
#ifdef SIGALRM
    sig != SIGALRM &&
#endif
#ifdef SIGTERM
    sig != SIGTERM &&
#endif
#ifdef SIGXCPU
    sig != SIGXCPU &&
#endif
#ifdef SIGXFSZ
    sig != SIGXFSZ &&
#endif
#ifdef SIGVTALRM
    sig != SIGVTALRM &&
#endif
#ifdef SIGLOST
    sig != SIGLOST &&
#endif
#ifdef SIGUSR1
    sig != SIGUSR1 &&
#endif
#ifdef SIGUSR2
   sig != SIGUSR2 &&
#endif
   sig == terminating_signal)
    terminate_immediately = 1;

  terminating_signal = sig;

  if (terminate_immediately)
    {
#if defined (HISTORY)
      /* XXX - will inhibit history file being written */
#  if defined (READLINE)
      if (interactive_shell == 0 || interactive == 0 || (sig != SIGHUP && sig != SIGTERM) || no_line_editing || (RL_ISSTATE (RL_STATE_READCMD) == 0))
#  endif
        history_lines_this_session = 0;
#endif
      terminate_immediately = 0;
      termsig_handler (sig);
    }

#if defined (READLINE)
  /* Set the event hook so readline will call it after the signal handlers
     finish executing, so if this interrupted character input we can get
     quick response.  If readline is active or has modified the terminal we
     need to set this no matter what the signal is, though the check for
     RL_STATE_TERMPREPPED is possibly redundant. */
  if (RL_ISSTATE (RL_STATE_SIGHANDLER) || RL_ISSTATE (RL_STATE_TERMPREPPED))
    bashline_set_event_hook ();
#endif

  SIGRETURN (0);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\sig.c:484
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\sig.c:556
parsing error 
{
  static int handling_termsig = 0;
  int i, core;
  sigset_t mask;

  /* Simple semaphore to keep this function from being executed multiple
     times.  Since we no longer are running as a signal handler, we don't
     block multiple occurrences of the terminating signals while running. */
  if (handling_termsig)
    return;
  handling_termsig = 1;
  terminating_signal = 0;	/* keep macro from re-testing true. */

  /* I don't believe this condition ever tests true. */
  if (sig == SIGINT && signal_is_trapped (SIGINT))
    run_interrupt_trap (0);

#if defined (HISTORY)
  /* If we don't do something like this, the history will not be saved when
     an interactive shell is running in a terminal window that gets closed
     with the `close' button.  We can't test for RL_STATE_READCMD because
     readline no longer handles SIGTERM synchronously.  */
  if (interactive_shell && interactive && (sig == SIGHUP || sig == SIGTERM) && remember_on_history)
    maybe_save_shell_history ();
#endif /* HISTORY */

  if (this_shell_builtin == read_builtin)
    read_tty_cleanup ();

#if defined (JOB_CONTROL)
  if (sig == SIGHUP && (interactive || (subshell_environment & (SUBSHELL_COMSUB|SUBSHELL_PROCSUB))))
    hangup_all_jobs ();

  if ((subshell_environment & (SUBSHELL_COMSUB|SUBSHELL_PROCSUB)) == 0)
    end_job_control ();
#endif /* JOB_CONTROL */

#if defined (PROCESS_SUBSTITUTION)
  unlink_all_fifos ();
#  if defined (JOB_CONTROL)
  procsub_clear ();
#  endif
#endif /* PROCESS_SUBSTITUTION */

  /* Reset execution context */
  loop_level = continuing = breaking = funcnest = 0;
  executing_list = comsub_ignore_return = return_catch_flag = wait_intr_flag = 0;

  run_exit_trap ();	/* XXX - run exit trap possibly in signal context? */

  /* We don't change the set of blocked signals. If a user starts the shell
     with a terminating signal blocked, we won't get here (and if by some
     magic chance we do, we'll exit below). What we do is to restore the
     top-level signal mask, in case this is called from a terminating signal
     handler context, in which case the signal is blocked. */
  restore_sigmask ();

  set_signal_handler (sig, SIG_DFL);

  kill (getpid (), sig);

  if (dollar_dollar_pid != 1)
    exit (128+sig);		/* just in case the kill fails? */

  /* We get here only under extraordinary circumstances. */

  /* We are PID 1, and the kill above failed to kill the process. We assume
     this means that we are running as an init process in a pid namespace
     on Linux. In this case, we can't send ourselves a fatal signal, so we
     determine whether or not we should have generated a core dump with the
     kill call and attempt to trick the kernel into generating one if
     necessary. */
  sigprocmask (SIG_SETMASK, (sigset_t *)NULL, &mask);
  for (i = core = 0; i < TERMSIGS_LENGTH; i++)
    {
      set_signal_handler (XSIG (i), SIG_DFL);
      sigdelset (&mask, XSIG (i));
      if (sig == XSIG (i))
	core = XCOREDUMP (i);
    }
  sigprocmask (SIG_SETMASK, &mask, (sigset_t *)NULL);

  if (core)
    *((volatile unsigned long *) NULL) = 0xdead0000 + sig;	/* SIGSEGV */

  exit (128+sig);
}
warning: parse error {
  static int handling_termsig = 0;
  int i, core;
  sigset_t mask;

  /* Simple semaphore to keep this function from being executed multiple
     times.  Since we no longer are running as a signal handler, we don't
     block multiple occurrences of the terminating signals while running. */
  if (handling_termsig)
    return;
  handling_termsig = 1;
  terminating_signal = 0;	/* keep macro from re-testing true. */

  /* I don't believe this condition ever tests true. */
  if (sig == SIGINT && signal_is_trapped (SIGINT))
    run_interrupt_trap (0);

#if defined (HISTORY)
  /* If we don't do something like this, the history will not be saved when
     an interactive shell is running in a terminal window that gets closed
     with the `close' button.  We can't test for RL_STATE_READCMD because
     readline no longer handles SIGTERM synchronously.  */
  if (interactive_shell && interactive && (sig == SIGHUP || sig == SIGTERM) && remember_on_history)
    maybe_save_shell_history ();
#endif /* HISTORY */

  if (this_shell_builtin == read_builtin)
    read_tty_cleanup ();

#if defined (JOB_CONTROL)
  if (sig == SIGHUP && (interactive || (subshell_environment & (SUBSHELL_COMSUB|SUBSHELL_PROCSUB))))
    hangup_all_jobs ();

  if ((subshell_environment & (SUBSHELL_COMSUB|SUBSHELL_PROCSUB)) == 0)
    end_job_control ();
#endif /* JOB_CONTROL */

#if defined (PROCESS_SUBSTITUTION)
  unlink_all_fifos ();
#  if defined (JOB_CONTROL)
  procsub_clear ();
#  endif
#endif /* PROCESS_SUBSTITUTION */

  /* Reset execution context */
  loop_level = continuing = breaking = funcnest = 0;
  executing_list = comsub_ignore_return = return_catch_flag = wait_intr_flag = 0;

  run_exit_trap ();	/* XXX - run exit trap possibly in signal context? */

  /* We don't change the set of blocked signals. If a user starts the shell
     with a terminating signal blocked, we won't get here (and if by some
     magic chance we do, we'll exit below). What we do is to restore the
     top-level signal mask, in case this is called from a terminating signal
     handler context, in which case the signal is blocked. */
  restore_sigmask ();

  set_signal_handler (sig, SIG_DFL);

  kill (getpid (), sig);

  if (dollar_dollar_pid != 1)
    exit (128+sig);		/* just in case the kill fails? */

  /* We get here only under extraordinary circumstances. */

  /* We are PID 1, and the kill above failed to kill the process. We assume
     this means that we are running as an init process in a pid namespace
     on Linux. In this case, we can't send ourselves a fatal signal, so we
     determine whether or not we should have generated a core dump with the
     kill call and attempt to trick the kernel into generating one if
     necessary. */
  sigprocmask (SIG_SETMASK, (sigset_t *)NULL, &mask);
  for (i = core = 0; i < TERMSIGS_LENGTH; i++)
    {
      set_signal_handler (XSIG (i), SIG_DFL);
      sigdelset (&mask, XSIG (i));
      if (sig == XSIG (i))
	core = XCOREDUMP (i);
    }
  sigprocmask (SIG_SETMASK, &mask, (sigset_t *)NULL);

  if (core)
    *((volatile unsigned long *) NULL) = 0xdead0000 + sig;	/* SIGSEGV */

  exit (128+sig);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\sig.c:558
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\sig.c:649
parsing error 
{
#if defined (MUST_REINSTALL_SIGHANDLERS)
  signal (sig, sigint_sighandler);
#endif

  /* interrupt_state needs to be set for the stack of interrupts to work
     right.  Should it be set unconditionally? */
  if (interrupt_state == 0)
    ADDINTERRUPT;

  /* We will get here in interactive shells with job control active; allow
     an interactive wait to be interrupted.  wait_intr_flag is only set during
     the execution of the wait builtin and when wait_intr_buf is valid. */
  if (wait_intr_flag)
    {
      last_command_exit_value = 128 + sig;
      set_pipestatus_from_exit (last_command_exit_value);
      wait_signal_received = sig;
      SIGRETURN (0);
    }

  /* In interactive shells, we will get here instead of trap_handler() so
     note that we have a trap pending. */
  if (signal_is_trapped (sig))
    set_trap_state (sig);

  /* This is no longer used, but this code block remains as a reminder. */
  if (interrupt_immediately)
    {
      interrupt_immediately = 0;
      set_exit_status (128 + sig);
      throw_to_top_level ();
    }
#if defined (READLINE)
  /* Set the event hook so readline will call it after the signal handlers
     finish executing, so if this interrupted character input we can get
     quick response. */
  else if (RL_ISSTATE (RL_STATE_SIGHANDLER))
    bashline_set_event_hook ();
#endif

  SIGRETURN (0);
}
warning: parse error {
#if defined (MUST_REINSTALL_SIGHANDLERS)
  signal (sig, sigint_sighandler);
#endif

  /* interrupt_state needs to be set for the stack of interrupts to work
     right.  Should it be set unconditionally? */
  if (interrupt_state == 0)
    ADDINTERRUPT;

  /* We will get here in interactive shells with job control active; allow
     an interactive wait to be interrupted.  wait_intr_flag is only set during
     the execution of the wait builtin and when wait_intr_buf is valid. */
  if (wait_intr_flag)
    {
      last_command_exit_value = 128 + sig;
      set_pipestatus_from_exit (last_command_exit_value);
      wait_signal_received = sig;
      SIGRETURN (0);
    }

  /* In interactive shells, we will get here instead of trap_handler() so
     note that we have a trap pending. */
  if (signal_is_trapped (sig))
    set_trap_state (sig);

  /* This is no longer used, but this code block remains as a reminder. */
  if (interrupt_immediately)
    {
      interrupt_immediately = 0;
      set_exit_status (128 + sig);
      throw_to_top_level ();
    }
#if defined (READLINE)
  /* Set the event hook so readline will call it after the signal handlers
     finish executing, so if this interrupted character input we can get
     quick response. */
  else if (RL_ISSTATE (RL_STATE_SIGHANDLER))
    bashline_set_event_hook ();
#endif

  SIGRETURN (0);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\sig.c:651
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\sig.c:725
parsing error 
{
  sigterm_received = 1;		/* XXX - counter? */
  SIGRETURN (0);
}
warning: parse error {
  sigterm_received = 1;		/* XXX - counter? */
  SIGRETURN (0);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\sig.c:727
parsing error 
sigprocmask (operation, newset, oldset)
     int operation, *newset, *oldset;
warning: parse error sigprocmask (operation, newset, oldset)
     int operation, *newset, *oldset;Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\sig.c:736
parsing error 
{
  int old, new;

  if (newset)
    new = *newset;
  else
    new = 0;

  switch (operation)
    {
    case SIG_BLOCK:
      old = sigblock (new);
      break;

    case SIG_SETMASK:
      old = sigsetmask (new);
      break;

    default:
      internal_error (_("sigprocmask: %d: invalid operation"), operation);
    }

  if (oldset)
    *oldset = old;
}
warning: parse error {
  int old, new;

  if (newset)
    new = *newset;
  else
    new = 0;

  switch (operation)
    {
    case SIG_BLOCK:
      old = sigblock (new);
      break;

    case SIG_SETMASK:
      old = sigsetmask (new);
      break;

    default:
      internal_error (_("sigprocmask: %d: invalid operation"), operation);
    }

  if (oldset)
    *oldset = old;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\sig.c:738
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\siglist.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\general.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\siglist.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashintl.h...skip
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\stringlib.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashtypes.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashansi.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\chartypes.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\shell.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\pathexp.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\glob\glob.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\stringlib.c:51
parsing error 
{
  register int i;
  int r;

  for (i = r = 0; alist[i].word; i++)
    {
#if defined (EXTENDED_GLOB)
      if (flags)
	r = strmatch (alist[i].word, string, FNM_EXTMATCH) != FNM_NOMATCH;
      else
#endif
	r = STREQ (string, alist[i].word);

      if (r)
	return (alist[i].token);
    }
  return -1;
}
warning: parse error {
  register int i;
  int r;

  for (i = r = 0; alist[i].word; i++)
    {
#if defined (EXTENDED_GLOB)
      if (flags)
	r = strmatch (alist[i].word, string, FNM_EXTMATCH) != FNM_NOMATCH;
      else
#endif
	r = STREQ (string, alist[i].word);

      if (r)
	return (alist[i].token);
    }
  return -1;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\stringlib.c:55
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\stringlib.c:78
parsing error 
{
  register int i;

  for (i = 0; alist[i].word; i++)
    {
      if (alist[i].token == token)
        return (savestring (alist[i].word));
    }
  return ((char *)NULL);
}
warning: parse error {
  register int i;

  for (i = 0; alist[i].word; i++)
    {
      if (alist[i].token == token)
        return (savestring (alist[i].word));
    }
  return ((char *)NULL);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\stringlib.c:82
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\stringlib.c:94
parsing error 
{
  register int i;
  int r;

  for (i = r = 0; alist[i].word; i++)
    {
#if defined (EXTENDED_GLOB)
      if (flags)
	r = strmatch (alist[i].word, string, FNM_EXTMATCH) != FNM_NOMATCH;
      else
#endif
	r = STREQ (string, alist[i].word);

      if (r)
	return (i);
    }

  return -1;
}
warning: parse error {
  register int i;
  int r;

  for (i = r = 0; alist[i].word; i++)
    {
#if defined (EXTENDED_GLOB)
      if (flags)
	r = strmatch (alist[i].word, string, FNM_EXTMATCH) != FNM_NOMATCH;
      else
#endif
	r = STREQ (string, alist[i].word);

      if (r)
	return (i);
    }

  return -1;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\stringlib.c:98
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\stringlib.c:128
parsing error 
{
  register int len;
  register char *result;

  len = end - start;
  result = (char *)xmalloc (len + 1);
  memcpy (result, string + start, len);
  result[len] = '\0';
  return (result);
}
warning: parse error {
  register int len;
  register char *result;

  len = end - start;
  result = (char *)xmalloc (len + 1);
  memcpy (result, string + start, len);
  result[len] = '\0';
  return (result);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\stringlib.c:130
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\stringlib.c:145
parsing error 
{
  int patlen, replen, templen, tempsize, repl, i;
  char *temp, *r;

  patlen = strlen (pat);
  replen = strlen (rep);
  for (temp = (char *)NULL, i = templen = tempsize = 0, repl = 1; string[i]; )
    {
      if (repl && STREQN (string + i, pat, patlen))
	{
	  if (replen)
	    RESIZE_MALLOCED_BUFFER (temp, templen, replen, tempsize, (replen * 2));

	  for (r = rep; *r; )	/* can rep == "" */
	    temp[templen++] = *r++;

	  i += patlen ? patlen : 1;	/* avoid infinite recursion */
	  repl = global != 0;
	}
      else
	{
	  RESIZE_MALLOCED_BUFFER (temp, templen, 1, tempsize, 16);
	  temp[templen++] = string[i++];
	}
    }
  if (temp)
    temp[templen] = 0;
  else
    temp = savestring (string);
  return (temp);
}
warning: parse error {
  int patlen, replen, templen, tempsize, repl, i;
  char *temp, *r;

  patlen = strlen (pat);
  replen = strlen (rep);
  for (temp = (char *)NULL, i = templen = tempsize = 0, repl = 1; string[i]; )
    {
      if (repl && STREQN (string + i, pat, patlen))
	{
	  if (replen)
	    RESIZE_MALLOCED_BUFFER (temp, templen, replen, tempsize, (replen * 2));

	  for (r = rep; *r; )	/* can rep == "" */
	    temp[templen++] = *r++;

	  i += patlen ? patlen : 1;	/* avoid infinite recursion */
	  repl = global != 0;
	}
      else
	{
	  RESIZE_MALLOCED_BUFFER (temp, templen, 1, tempsize, 16);
	  temp[templen++] = string[i++];
	}
    }
  if (temp)
    temp[templen] = 0;
  else
    temp = savestring (string);
  return (temp);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\stringlib.c:148
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\stringlib.c:184
parsing error 
{
  char *ret, *p, *r, *t;
  int len, rlen, ind, tlen;

  len = STRLEN (text);
  rlen = len + strlen (string) + 2;
  ret = (char *)xmalloc (rlen);

  for (p = string, r = ret; p && *p; )
    {
      if (*p == c)
	{
	  if (len)
	    {
	      ind = r - ret;
	      if (do_glob && (glob_pattern_p (text) || strchr (text, '\\')))
		{
		  t = quote_globbing_chars (text);
		  tlen = strlen (t);
		  RESIZE_MALLOCED_BUFFER (ret, ind, tlen, rlen, rlen);
		  r = ret + ind;	/* in case reallocated */
		  strcpy (r, t);
		  r += tlen;
		  free (t);
		}
	      else
		{
		  RESIZE_MALLOCED_BUFFER (ret, ind, len, rlen, rlen);
		  r = ret + ind;	/* in case reallocated */
		  strcpy (r, text);
		  r += len;
		}
	    }
	  p++;
	  continue;
	}

      if (*p == '\\' && p[1] == c)
	p++;

      ind = r - ret;
      RESIZE_MALLOCED_BUFFER (ret, ind, 2, rlen, rlen);
      r = ret + ind;			/* in case reallocated */
      *r++ = *p++;
    }
  *r = '\0';

  return ret;
}
warning: parse error {
  char *ret, *p, *r, *t;
  int len, rlen, ind, tlen;

  len = STRLEN (text);
  rlen = len + strlen (string) + 2;
  ret = (char *)xmalloc (rlen);

  for (p = string, r = ret; p && *p; )
    {
      if (*p == c)
	{
	  if (len)
	    {
	      ind = r - ret;
	      if (do_glob && (glob_pattern_p (text) || strchr (text, '\\')))
		{
		  t = quote_globbing_chars (text);
		  tlen = strlen (t);
		  RESIZE_MALLOCED_BUFFER (ret, ind, tlen, rlen, rlen);
		  r = ret + ind;	/* in case reallocated */
		  strcpy (r, t);
		  r += tlen;
		  free (t);
		}
	      else
		{
		  RESIZE_MALLOCED_BUFFER (ret, ind, len, rlen, rlen);
		  r = ret + ind;	/* in case reallocated */
		  strcpy (r, text);
		  r += len;
		}
	    }
	  p++;
	  continue;
	}

      if (*p == '\\' && p[1] == c)
	p++;

      ind = r - ret;
      RESIZE_MALLOCED_BUFFER (ret, ind, 2, rlen, rlen);
      r = ret + ind;			/* in case reallocated */
      *r++ = *p++;
    }
  *r = '\0';

  return ret;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\stringlib.c:189
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\stringlib.c:264
parsing error 
{
  while (len >= 0)
    {
      if ((newlines_only && string[len] == '\n') ||
	  (!newlines_only && whitespace (string[len])))
	len--;
      else
	break;
    }
  string[len + 1] = '\0';
}
warning: parse error {
  while (len >= 0)
    {
      if ((newlines_only && string[len] == '\n') ||
	  (!newlines_only && whitespace (string[len])))
	len--;
      else
	break;
    }
  string[len + 1] = '\0';
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\stringlib.c:268
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\stringlib.c:282
parsing error 
{
  FASTCOPY (s, d, n);
}
warning: parse error {
  FASTCOPY (s, d, n);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\stringlib.c:285
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashtypes.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\chartypes.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashansi.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\posixstat.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashintl.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\shell.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\parser.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\flags.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\jobs.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\execute_cmd.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\filecntl.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\trap.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\pathexp.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\mailcheck.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\shmbutil.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\typemax.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\getopt.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\common.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\tilde\tilde.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\glob\strmatch.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:734
parsing error 
{
  if (source)
    {
      int n;
      size_t srclen;

      srclen = STRLEN (source);
      if (srclen >= (int)(*size - *indx))
	{
	  n = srclen + *indx;
	  n = (n + DEFAULT_ARRAY_SIZE) - (n % DEFAULT_ARRAY_SIZE);
	  target = (char *)xrealloc (target, (*size = n));
	}

      FASTCOPY (source, target + *indx, srclen);
      *indx += srclen;
      target[*indx] = '\0';

      free (source);
    }
  return (target);
}
warning: parse error {
  if (source)
    {
      int n;
      size_t srclen;

      srclen = STRLEN (source);
      if (srclen >= (int)(*size - *indx))
	{
	  n = srclen + *indx;
	  n = (n + DEFAULT_ARRAY_SIZE) - (n % DEFAULT_ARRAY_SIZE);
	  target = (char *)xrealloc (target, (*size = n));
	}

      FASTCOPY (source, target + *indx, srclen);
      *indx += srclen;
      target[*indx] = '\0';

      free (source);
    }
  return (target);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:738
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:789
parsing error 
{
  register int c, i;
  int found;
  size_t slen;
  char *temp;
  DECLARE_MBSTATE;

  slen = (MB_CUR_MAX > 1) ? strlen (string + *sindex) + *sindex : 0;
  i = *sindex;
  found = 0;
  while (c = string[i])
    {
      if (c == '\\')
	{
	  if (string[i + 1])
	    i++;
	  else
	    break;
	}
#if defined (ARRAY_VARS)
      else if ((flags & SX_VARNAME) && c == LBRACK)
	{
	  int ni;
	  /* If this is an array subscript, skip over it and continue. */
	  ni = skipsubscript (string, i, 0);
	  if (string[ni] == RBRACK)
	    i = ni;
	}
#endif
      else if (MEMBER (c, charlist))
	{
	  found = 1;
	  break;
	}

      ADVANCE_CHAR (string, slen, i);
    }

  /* If we had to have a matching delimiter and didn't find one, return an
     error and let the caller deal with it. */
  if ((flags & SX_REQMATCH) && found == 0)
    {
      *sindex = i;
      return (&extract_string_error);
    }
  
  temp = (flags & SX_NOALLOC) ? (char *)NULL : substring (string, *sindex, i);
  *sindex = i;
  
  return (temp);
}
warning: parse error {
  register int c, i;
  int found;
  size_t slen;
  char *temp;
  DECLARE_MBSTATE;

  slen = (MB_CUR_MAX > 1) ? strlen (string + *sindex) + *sindex : 0;
  i = *sindex;
  found = 0;
  while (c = string[i])
    {
      if (c == '\\')
	{
	  if (string[i + 1])
	    i++;
	  else
	    break;
	}
#if defined (ARRAY_VARS)
      else if ((flags & SX_VARNAME) && c == LBRACK)
	{
	  int ni;
	  /* If this is an array subscript, skip over it and continue. */
	  ni = skipsubscript (string, i, 0);
	  if (string[ni] == RBRACK)
	    i = ni;
	}
#endif
      else if (MEMBER (c, charlist))
	{
	  found = 1;
	  break;
	}

      ADVANCE_CHAR (string, slen, i);
    }

  /* If we had to have a matching delimiter and didn't find one, return an
     error and let the caller deal with it. */
  if ((flags & SX_REQMATCH) && found == 0)
    {
      *sindex = i;
      return (&extract_string_error);
    }
  
  temp = (flags & SX_NOALLOC) ? (char *)NULL : substring (string, *sindex, i);
  *sindex = i;
  
  return (temp);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:794
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:854
parsing error 
{
  size_t slen;
  char *send;
  int j, i, t;
  unsigned char c;
  char *temp, *ret;		/* The new string we return. */
  int pass_next, backquote, si;	/* State variables for the machine. */
  int dquote;
  int stripdq;
  DECLARE_MBSTATE;

  slen = strlen (string + *sindex) + *sindex;
  send = string + slen;

  stripdq = (flags & SX_STRIPDQ);

  pass_next = backquote = dquote = 0;
  temp = (char *)xmalloc (1 + slen - *sindex);

  j = 0;
  i = *sindex;
  while (c = string[i])
    {
      /* Process a character that was quoted by a backslash. */
      if (pass_next)
	{
	  /* XXX - take another look at this in light of Interp 221 */
	  /* Posix.2 sez:

	     ``The backslash shall retain its special meaning as an escape
	     character only when followed by one of the characters:
		$	`	"	\	<newline>''.

	     If STRIPDQ is zero, we handle the double quotes here and let
	     expand_word_internal handle the rest.  If STRIPDQ is non-zero,
	     we have already been through one round of backslash stripping,
	     and want to strip these backslashes only if DQUOTE is non-zero,
	     indicating that we are inside an embedded double-quoted string. */

	  /* If we are in an embedded quoted string, then don't strip
	     backslashes before characters for which the backslash
	     retains its special meaning, but remove backslashes in
	     front of other characters.  If we are not in an
	     embedded quoted string, don't strip backslashes at all.
	     This mess is necessary because the string was already
	     surrounded by double quotes (and sh has some really weird
	     quoting rules).
	     The returned string will be run through expansion as if
	     it were double-quoted. */
	  if ((stripdq == 0 && c != '"') ||
	      (stripdq && ((dquote && (sh_syntaxtab[c] & CBSDQUOTE)) || dquote == 0)))
	    temp[j++] = '\\';
	  pass_next = 0;

add_one_character:
	  COPY_CHAR_I (temp, j, string, send, i);
	  continue;
	}

      /* A backslash protects the next character.  The code just above
	 handles preserving the backslash in front of any character but
	 a double quote. */
      if (c == '\\')
	{
	  pass_next++;
	  i++;
	  continue;
	}

      /* Inside backquotes, ``the portion of the quoted string from the
	 initial backquote and the characters up to the next backquote
	 that is not preceded by a backslash, having escape characters
	 removed, defines that command''. */
      if (backquote)
	{
	  if (c == '`')
	    backquote = 0;
	  temp[j++] = c;	/* COPY_CHAR_I? */
	  i++;
	  continue;
	}

      if (c == '`')
	{
	  temp[j++] = c;
	  backquote++;
	  i++;
	  continue;
	}

      /* Pass everything between `$(' and the matching `)' or a quoted
	 ${ ... } pair through according to the Posix.2 specification. */
      if (c == '$' && ((string[i + 1] == LPAREN) || (string[i + 1] == LBRACE)))
	{
	  int free_ret = 1;

	  si = i + 2;
	  if (string[i + 1] == LPAREN)
	    ret = extract_command_subst (string, &si, (flags & SX_COMPLETE));
	  else
	    ret = extract_dollar_brace_string (string, &si, Q_DOUBLE_QUOTES, 0);

	  temp[j++] = '$';
	  temp[j++] = string[i + 1];

	  /* Just paranoia; ret will not be 0 unless no_longjmp_on_fatal_error
	     is set. */
	  if (ret == 0 && no_longjmp_on_fatal_error)
	    {
	      free_ret = 0;
	      ret = string + i + 2;
	    }

	  /* XXX - CHECK_STRING_OVERRUN here? */
	  for (t = 0; ret[t]; t++, j++)
	    temp[j] = ret[t];
	  temp[j] = string[si];

	  if (si < i + 2)	/* we went back? */
	    i += 2;
	  else if (string[si])
	    {
	      j++;
	      i = si + 1;
	    }
	  else
	    i = si;

	  if (free_ret)
	    free (ret);
	  continue;
	}

      /* Add any character but a double quote to the quoted string we're
	 accumulating. */
      if (c != '"')
	goto add_one_character;

      /* c == '"' */
      if (stripdq)
	{
	  dquote ^= 1;
	  i++;
	  continue;
	}

      break;
    }
  temp[j] = '\0';

  /* Point to after the closing quote. */
  if (c)
    i++;
  *sindex = i;

  return (temp);
}
warning: parse error {
  size_t slen;
  char *send;
  int j, i, t;
  unsigned char c;
  char *temp, *ret;		/* The new string we return. */
  int pass_next, backquote, si;	/* State variables for the machine. */
  int dquote;
  int stripdq;
  DECLARE_MBSTATE;

  slen = strlen (string + *sindex) + *sindex;
  send = string + slen;

  stripdq = (flags & SX_STRIPDQ);

  pass_next = backquote = dquote = 0;
  temp = (char *)xmalloc (1 + slen - *sindex);

  j = 0;
  i = *sindex;
  while (c = string[i])
    {
      /* Process a character that was quoted by a backslash. */
      if (pass_next)
	{
	  /* XXX - take another look at this in light of Interp 221 */
	  /* Posix.2 sez:

	     ``The backslash shall retain its special meaning as an escape
	     character only when followed by one of the characters:
		$	`	"	\	<newline>''.

	     If STRIPDQ is zero, we handle the double quotes here and let
	     expand_word_internal handle the rest.  If STRIPDQ is non-zero,
	     we have already been through one round of backslash stripping,
	     and want to strip these backslashes only if DQUOTE is non-zero,
	     indicating that we are inside an embedded double-quoted string. */

	  /* If we are in an embedded quoted string, then don't strip
	     backslashes before characters for which the backslash
	     retains its special meaning, but remove backslashes in
	     front of other characters.  If we are not in an
	     embedded quoted string, don't strip backslashes at all.
	     This mess is necessary because the string was already
	     surrounded by double quotes (and sh has some really weird
	     quoting rules).
	     The returned string will be run through expansion as if
	     it were double-quoted. */
	  if ((stripdq == 0 && c != '"') ||
	      (stripdq && ((dquote && (sh_syntaxtab[c] & CBSDQUOTE)) || dquote == 0)))
	    temp[j++] = '\\';
	  pass_next = 0;

add_one_character:
	  COPY_CHAR_I (temp, j, string, send, i);
	  continue;
	}

      /* A backslash protects the next character.  The code just above
	 handles preserving the backslash in front of any character but
	 a double quote. */
      if (c == '\\')
	{
	  pass_next++;
	  i++;
	  continue;
	}

      /* Inside backquotes, ``the portion of the quoted string from the
	 initial backquote and the characters up to the next backquote
	 that is not preceded by a backslash, having escape characters
	 removed, defines that command''. */
      if (backquote)
	{
	  if (c == '`')
	    backquote = 0;
	  temp[j++] = c;	/* COPY_CHAR_I? */
	  i++;
	  continue;
	}

      if (c == '`')
	{
	  temp[j++] = c;
	  backquote++;
	  i++;
	  continue;
	}

      /* Pass everything between `$(' and the matching `)' or a quoted
	 ${ ... } pair through according to the Posix.2 specification. */
      if (c == '$' && ((string[i + 1] == LPAREN) || (string[i + 1] == LBRACE)))
	{
	  int free_ret = 1;

	  si = i + 2;
	  if (string[i + 1] == LPAREN)
	    ret = extract_command_subst (string, &si, (flags & SX_COMPLETE));
	  else
	    ret = extract_dollar_brace_string (string, &si, Q_DOUBLE_QUOTES, 0);

	  temp[j++] = '$';
	  temp[j++] = string[i + 1];

	  /* Just paranoia; ret will not be 0 unless no_longjmp_on_fatal_error
	     is set. */
	  if (ret == 0 && no_longjmp_on_fatal_error)
	    {
	      free_ret = 0;
	      ret = string + i + 2;
	    }

	  /* XXX - CHECK_STRING_OVERRUN here? */
	  for (t = 0; ret[t]; t++, j++)
	    temp[j] = ret[t];
	  temp[j] = string[si];

	  if (si < i + 2)	/* we went back? */
	    i += 2;
	  else if (string[si])
	    {
	      j++;
	      i = si + 1;
	    }
	  else
	    i = si;

	  if (free_ret)
	    free (ret);
	  continue;
	}

      /* Add any character but a double quote to the quoted string we're
	 accumulating. */
      if (c != '"')
	goto add_one_character;

      /* c == '"' */
      if (stripdq)
	{
	  dquote ^= 1;
	  i++;
	  continue;
	}

      break;
    }
  temp[j] = '\0';

  /* Point to after the closing quote. */
  if (c)
    i++;
  *sindex = i;

  return (temp);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:857
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:1,017
parsing error 
{
  int c, i;
  char *ret;
  int pass_next, backquote, si;
  DECLARE_MBSTATE;

  pass_next = backquote = 0;
  i = sind;
  while (c = string[i])
    {
      if (pass_next)
	{
	  pass_next = 0;
	  ADVANCE_CHAR (string, slen, i);
	  continue;
	}
      else if (c == '\\')
	{
	  pass_next++;
	  i++;
	  continue;
	}
      else if (backquote)
	{
	  if (c == '`')
	    backquote = 0;
	  ADVANCE_CHAR (string, slen, i);
	  continue;
	}
      else if (c == '`')
	{
	  backquote++;
	  i++;
	  continue;
	}
      else if (c == '$' && ((string[i + 1] == LPAREN) || (string[i + 1] == LBRACE)))
	{
	  si = i + 2;
	  if (string[i + 1] == LPAREN)
	    ret = extract_command_subst (string, &si, SX_NOALLOC|(flags&SX_COMPLETE));
	  else
	    ret = extract_dollar_brace_string (string, &si, Q_DOUBLE_QUOTES, SX_NOALLOC);

	  /* These can consume the entire string if they are unterminated */
	  CHECK_STRING_OVERRUN (i, si, slen, c);

	  i = si + 1;
	  continue;
	}
      else if (c != '"')
	{
	  ADVANCE_CHAR (string, slen, i);
	  continue;
	}
      else
	break;
    }

  if (c)
    i++;

  return (i);
}
warning: parse error {
  int c, i;
  char *ret;
  int pass_next, backquote, si;
  DECLARE_MBSTATE;

  pass_next = backquote = 0;
  i = sind;
  while (c = string[i])
    {
      if (pass_next)
	{
	  pass_next = 0;
	  ADVANCE_CHAR (string, slen, i);
	  continue;
	}
      else if (c == '\\')
	{
	  pass_next++;
	  i++;
	  continue;
	}
      else if (backquote)
	{
	  if (c == '`')
	    backquote = 0;
	  ADVANCE_CHAR (string, slen, i);
	  continue;
	}
      else if (c == '`')
	{
	  backquote++;
	  i++;
	  continue;
	}
      else if (c == '$' && ((string[i + 1] == LPAREN) || (string[i + 1] == LBRACE)))
	{
	  si = i + 2;
	  if (string[i + 1] == LPAREN)
	    ret = extract_command_subst (string, &si, SX_NOALLOC|(flags&SX_COMPLETE));
	  else
	    ret = extract_dollar_brace_string (string, &si, Q_DOUBLE_QUOTES, SX_NOALLOC);

	  /* These can consume the entire string if they are unterminated */
	  CHECK_STRING_OVERRUN (i, si, slen, c);

	  i = si + 1;
	  continue;
	}
      else if (c != '"')
	{
	  ADVANCE_CHAR (string, slen, i);
	  continue;
	}
      else
	break;
    }

  if (c)
    i++;

  return (i);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:1,022
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:1,091
parsing error 
{
  register int i;
  size_t slen;
  char *t;
  DECLARE_MBSTATE;

  /* Don't need slen for ADVANCE_CHAR unless multibyte chars possible. */
  slen = (MB_CUR_MAX > 1) ? strlen (string + *sindex) + *sindex : 0;
  i = *sindex;
  while (string[i] && string[i] != '\'')
    ADVANCE_CHAR (string, slen, i);

  t = substring (string, *sindex, i);

  if (string[i])
    i++;
  *sindex = i;

  return (t);
}
warning: parse error {
  register int i;
  size_t slen;
  char *t;
  DECLARE_MBSTATE;

  /* Don't need slen for ADVANCE_CHAR unless multibyte chars possible. */
  slen = (MB_CUR_MAX > 1) ? strlen (string + *sindex) + *sindex : 0;
  i = *sindex;
  while (string[i] && string[i] != '\'')
    ADVANCE_CHAR (string, slen, i);

  t = substring (string, *sindex, i);

  if (string[i])
    i++;
  *sindex = i;

  return (t);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:1,094
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:1,120
parsing error 
{
  register int c;
  DECLARE_MBSTATE;

  c = sind;
  while (string[c] && string[c] != '\'')
    {
      if ((flags & SX_COMPLETE) && string[c] == '\\' && string[c+1] == '\'' && string[c+2])
	ADVANCE_CHAR (string, slen, c);
      ADVANCE_CHAR (string, slen, c);
    }

  if (string[c])
    c++;
  return c;
}
warning: parse error {
  register int c;
  DECLARE_MBSTATE;

  c = sind;
  while (string[c] && string[c] != '\'')
    {
      if ((flags & SX_COMPLETE) && string[c] == '\\' && string[c+1] == '\'' && string[c+2])
	ADVANCE_CHAR (string, slen, c);
      ADVANCE_CHAR (string, slen, c);
    }

  if (string[c])
    c++;
  return c;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:1,124
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:1,144
parsing error 
{
  register int i;
#if defined (HANDLE_MULTIBYTE)
  wchar_t *wcharlist;
#endif
  int c;
  char *temp;
  DECLARE_MBSTATE;

  if ((flags & SX_NOCTLESC) && charlist[0] == '\'' && charlist[1] == '\0')
    {
      temp = string_extract_single_quoted (string, sindex);
      --*sindex;	/* leave *sindex at separator character */
      return temp;
    }

  /* This can never be called with charlist == NULL. If *charlist == NULL,
     we can skip the loop and just return a copy of the string, updating
     *sindex */
  if (*charlist == 0)
    {
      temp = string + *sindex;
      c = (*sindex == 0) ? slen : STRLEN (temp);
      temp = savestring (temp);
      *sindex += c;
      return temp;
    }

  i = *sindex;
#if defined (HANDLE_MULTIBYTE)
  wcharlist = 0;
#endif
  while (c = string[i])
    {
#if defined (HANDLE_MULTIBYTE)
      size_t mblength;
#endif
      if ((flags & SX_NOCTLESC) == 0 && c == CTLESC)
	{
	  i += 2;
	  CHECK_STRING_OVERRUN (i, i, slen, c);
	  continue;
	}
      /* Even if flags contains SX_NOCTLESC, we let CTLESC quoting CTLNUL
	 through, to protect the CTLNULs from later calls to
	 remove_quoted_nulls. */
      else if ((flags & SX_NOESCCTLNUL) == 0 && c == CTLESC && string[i+1] == CTLNUL)
	{
	  i += 2;
	  CHECK_STRING_OVERRUN (i, i, slen, c);
	  continue;
	}

#if defined (HANDLE_MULTIBYTE)
      if (locale_utf8locale && slen > i && UTF8_SINGLEBYTE (string[i]))
	mblength = (string[i] != 0) ? 1 : 0;
      else
	mblength = MBLEN (string + i, slen - i);
      if (mblength > 1)
	{
	  wchar_t wc;
	  mblength = mbtowc (&wc, string + i, slen - i);
	  if (MB_INVALIDCH (mblength))
	    {
	      if (MEMBER (c, charlist))
		break;
	    }
	  else
	    {
	      if (wcharlist == 0)
		{
		  size_t len;
		  len = mbstowcs (wcharlist, charlist, 0);
		  if (len == -1)
		    len = 0;
		  wcharlist = (wchar_t *)xmalloc (sizeof (wchar_t) * (len + 1));
		  mbstowcs (wcharlist, charlist, len + 1);
		}

	      if (wcschr (wcharlist, wc))
		break;
	    }
	}
      else		
#endif
      if (MEMBER (c, charlist))
	break;

      ADVANCE_CHAR (string, slen, i);
    }

#if defined (HANDLE_MULTIBYTE)
  FREE (wcharlist);
#endif

  temp = substring (string, *sindex, i);
  *sindex = i;

  return (temp);
}
warning: parse error {
  register int i;
#if defined (HANDLE_MULTIBYTE)
  wchar_t *wcharlist;
#endif
  int c;
  char *temp;
  DECLARE_MBSTATE;

  if ((flags & SX_NOCTLESC) && charlist[0] == '\'' && charlist[1] == '\0')
    {
      temp = string_extract_single_quoted (string, sindex);
      --*sindex;	/* leave *sindex at separator character */
      return temp;
    }

  /* This can never be called with charlist == NULL. If *charlist == NULL,
     we can skip the loop and just return a copy of the string, updating
     *sindex */
  if (*charlist == 0)
    {
      temp = string + *sindex;
      c = (*sindex == 0) ? slen : STRLEN (temp);
      temp = savestring (temp);
      *sindex += c;
      return temp;
    }

  i = *sindex;
#if defined (HANDLE_MULTIBYTE)
  wcharlist = 0;
#endif
  while (c = string[i])
    {
#if defined (HANDLE_MULTIBYTE)
      size_t mblength;
#endif
      if ((flags & SX_NOCTLESC) == 0 && c == CTLESC)
	{
	  i += 2;
	  CHECK_STRING_OVERRUN (i, i, slen, c);
	  continue;
	}
      /* Even if flags contains SX_NOCTLESC, we let CTLESC quoting CTLNUL
	 through, to protect the CTLNULs from later calls to
	 remove_quoted_nulls. */
      else if ((flags & SX_NOESCCTLNUL) == 0 && c == CTLESC && string[i+1] == CTLNUL)
	{
	  i += 2;
	  CHECK_STRING_OVERRUN (i, i, slen, c);
	  continue;
	}

#if defined (HANDLE_MULTIBYTE)
      if (locale_utf8locale && slen > i && UTF8_SINGLEBYTE (string[i]))
	mblength = (string[i] != 0) ? 1 : 0;
      else
	mblength = MBLEN (string + i, slen - i);
      if (mblength > 1)
	{
	  wchar_t wc;
	  mblength = mbtowc (&wc, string + i, slen - i);
	  if (MB_INVALIDCH (mblength))
	    {
	      if (MEMBER (c, charlist))
		break;
	    }
	  else
	    {
	      if (wcharlist == 0)
		{
		  size_t len;
		  len = mbstowcs (wcharlist, charlist, 0);
		  if (len == -1)
		    len = 0;
		  wcharlist = (wchar_t *)xmalloc (sizeof (wchar_t) * (len + 1));
		  mbstowcs (wcharlist, charlist, len + 1);
		}

	      if (wcschr (wcharlist, wc))
		break;
	    }
	}
      else		
#endif
      if (MEMBER (c, charlist))
	break;

      ADVANCE_CHAR (string, slen, i);
    }

#if defined (HANDLE_MULTIBYTE)
  FREE (wcharlist);
#endif

  temp = substring (string, *sindex, i);
  *sindex = i;

  return (temp);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:1,150
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:1,256
parsing error 
{
  char *ret;

  if (string[*sindex] == LPAREN || (xflags & SX_COMPLETE))
    return (extract_delimited_string (string, sindex, "$(", "(", ")", xflags|SX_COMMAND)); /*)*/
  else
    {
      xflags |= (no_longjmp_on_fatal_error ? SX_NOLONGJMP : 0);
      ret = xparse_dolparen (string, string+*sindex, sindex, xflags);
      return ret;
    }
}
warning: parse error {
  char *ret;

  if (string[*sindex] == LPAREN || (xflags & SX_COMPLETE))
    return (extract_delimited_string (string, sindex, "$(", "(", ")", xflags|SX_COMMAND)); /*)*/
  else
    {
      xflags |= (no_longjmp_on_fatal_error ? SX_NOLONGJMP : 0);
      ret = xparse_dolparen (string, string+*sindex, sindex, xflags);
      return ret;
    }
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:1,260
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:1,277
parsing error 
{
  return (extract_delimited_string (string, sindex, "$[", "[", "]", 0)); /*]*/
}
warning: parse error {
  return (extract_delimited_string (string, sindex, "$[", "[", "]", 0)); /*]*/
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:1,280
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:1,337
parsing error 
{
  int i, c, si;
  size_t slen;
  char *t, *result;
  int pass_character, nesting_level, in_comment;
  int len_closer, len_opener, len_alt_opener;
  DECLARE_MBSTATE;

  slen = strlen (string + *sindex) + *sindex;
  len_opener = STRLEN (opener);
  len_alt_opener = STRLEN (alt_opener);
  len_closer = STRLEN (closer);

  pass_character = in_comment = 0;

  nesting_level = 1;
  i = *sindex;

  while (nesting_level)
    {
      c = string[i];

      /* If a recursive call or a call to ADVANCE_CHAR leaves the index beyond
	 the end of the string, catch it and cut the loop. */
      if (i > slen)
	{
	  i = slen;
	  c = string[i = slen];
	  break;
	}

      if (c == 0)
	break;

      if (in_comment)
	{
	  if (c == '\n')
	    in_comment = 0;
	  ADVANCE_CHAR (string, slen, i);
	  continue;
	}

      if (pass_character)	/* previous char was backslash */
	{
	  pass_character = 0;
	  ADVANCE_CHAR (string, slen, i);
	  continue;
	}

      /* Not exactly right yet; should handle shell metacharacters and
	 multibyte characters, too.  See COMMENT_BEGIN define in parse.y */
      if ((flags & SX_COMMAND) && c == '#' && (i == 0 || string[i - 1] == '\n' || shellblank (string[i - 1])))
	{
          in_comment = 1;
          ADVANCE_CHAR (string, slen, i);
          continue;
	}
        
      if (c == CTLESC || c == '\\')
	{
	  pass_character++;
	  i++;
	  continue;
	}

      /* Process a nested command substitution, but only if we're parsing an
	 arithmetic substitution. */
      if ((flags & SX_COMMAND) && string[i] == '$' && string[i+1] == LPAREN)
        {
          si = i + 2;
          t = extract_command_subst (string, &si, flags|SX_NOALLOC);
          CHECK_STRING_OVERRUN (i, si, slen, c);
          i = si + 1;
          continue;
        }

      /* Process a nested OPENER. */
      if (STREQN (string + i, opener, len_opener))
	{
	  si = i + len_opener;
	  t = extract_delimited_string (string, &si, opener, alt_opener, closer, flags|SX_NOALLOC);
	  CHECK_STRING_OVERRUN (i, si, slen, c);
	  i = si + 1;
	  continue;
	}

      /* Process a nested ALT_OPENER */
      if (len_alt_opener && STREQN (string + i, alt_opener, len_alt_opener))
	{
	  si = i + len_alt_opener;
	  t = extract_delimited_string (string, &si, alt_opener, alt_opener, closer, flags|SX_NOALLOC);
	  CHECK_STRING_OVERRUN (i, si, slen, c);
	  i = si + 1;
	  continue;
	}

      /* If the current substring terminates the delimited string, decrement
	 the nesting level. */
      if (STREQN (string + i, closer, len_closer))
	{
	  i += len_closer - 1;	/* move to last byte of the closer */
	  nesting_level--;
	  if (nesting_level == 0)
	    break;
	}

      /* Pass old-style command substitution through verbatim. */
      if (c == '`')
	{
	  si = i + 1;
	  t = string_extract (string, &si, "`", flags|SX_NOALLOC);
	  CHECK_STRING_OVERRUN (i, si, slen, c);
	  i = si + 1;
	  continue;
	}

      /* Pass single-quoted and double-quoted strings through verbatim. */
      if (c == '\'' || c == '"')
	{
	  si = i + 1;
	  i = (c == '\'') ? skip_single_quoted (string, slen, si, 0)
			  : skip_double_quoted (string, slen, si, 0);
	  continue;
	}

      /* move past this character, which was not special. */
      ADVANCE_CHAR (string, slen, i);
    }

  if (c == 0 && nesting_level)
    {
      if (no_longjmp_on_fatal_error == 0)
	{
	  last_command_exit_value = EXECUTION_FAILURE;
	  report_error (_("bad substitution: no closing `%s' in %s"), closer, string);
	  exp_jump_to_top_level (DISCARD);
	}
      else
	{
	  *sindex = i;
	  return (char *)NULL;
	}
    }

  si = i - *sindex - len_closer + 1;
  if (flags & SX_NOALLOC)
    result = (char *)NULL;
  else    
    {
      result = (char *)xmalloc (1 + si);
      strncpy (result, string + *sindex, si);
      result[si] = '\0';
    }
  *sindex = i;

  return (result);
}
warning: parse error {
  int i, c, si;
  size_t slen;
  char *t, *result;
  int pass_character, nesting_level, in_comment;
  int len_closer, len_opener, len_alt_opener;
  DECLARE_MBSTATE;

  slen = strlen (string + *sindex) + *sindex;
  len_opener = STRLEN (opener);
  len_alt_opener = STRLEN (alt_opener);
  len_closer = STRLEN (closer);

  pass_character = in_comment = 0;

  nesting_level = 1;
  i = *sindex;

  while (nesting_level)
    {
      c = string[i];

      /* If a recursive call or a call to ADVANCE_CHAR leaves the index beyond
	 the end of the string, catch it and cut the loop. */
      if (i > slen)
	{
	  i = slen;
	  c = string[i = slen];
	  break;
	}

      if (c == 0)
	break;

      if (in_comment)
	{
	  if (c == '\n')
	    in_comment = 0;
	  ADVANCE_CHAR (string, slen, i);
	  continue;
	}

      if (pass_character)	/* previous char was backslash */
	{
	  pass_character = 0;
	  ADVANCE_CHAR (string, slen, i);
	  continue;
	}

      /* Not exactly right yet; should handle shell metacharacters and
	 multibyte characters, too.  See COMMENT_BEGIN define in parse.y */
      if ((flags & SX_COMMAND) && c == '#' && (i == 0 || string[i - 1] == '\n' || shellblank (string[i - 1])))
	{
          in_comment = 1;
          ADVANCE_CHAR (string, slen, i);
          continue;
	}
        
      if (c == CTLESC || c == '\\')
	{
	  pass_character++;
	  i++;
	  continue;
	}

      /* Process a nested command substitution, but only if we're parsing an
	 arithmetic substitution. */
      if ((flags & SX_COMMAND) && string[i] == '$' && string[i+1] == LPAREN)
        {
          si = i + 2;
          t = extract_command_subst (string, &si, flags|SX_NOALLOC);
          CHECK_STRING_OVERRUN (i, si, slen, c);
          i = si + 1;
          continue;
        }

      /* Process a nested OPENER. */
      if (STREQN (string + i, opener, len_opener))
	{
	  si = i + len_opener;
	  t = extract_delimited_string (string, &si, opener, alt_opener, closer, flags|SX_NOALLOC);
	  CHECK_STRING_OVERRUN (i, si, slen, c);
	  i = si + 1;
	  continue;
	}

      /* Process a nested ALT_OPENER */
      if (len_alt_opener && STREQN (string + i, alt_opener, len_alt_opener))
	{
	  si = i + len_alt_opener;
	  t = extract_delimited_string (string, &si, alt_opener, alt_opener, closer, flags|SX_NOALLOC);
	  CHECK_STRING_OVERRUN (i, si, slen, c);
	  i = si + 1;
	  continue;
	}

      /* If the current substring terminates the delimited string, decrement
	 the nesting level. */
      if (STREQN (string + i, closer, len_closer))
	{
	  i += len_closer - 1;	/* move to last byte of the closer */
	  nesting_level--;
	  if (nesting_level == 0)
	    break;
	}

      /* Pass old-style command substitution through verbatim. */
      if (c == '`')
	{
	  si = i + 1;
	  t = string_extract (string, &si, "`", flags|SX_NOALLOC);
	  CHECK_STRING_OVERRUN (i, si, slen, c);
	  i = si + 1;
	  continue;
	}

      /* Pass single-quoted and double-quoted strings through verbatim. */
      if (c == '\'' || c == '"')
	{
	  si = i + 1;
	  i = (c == '\'') ? skip_single_quoted (string, slen, si, 0)
			  : skip_double_quoted (string, slen, si, 0);
	  continue;
	}

      /* move past this character, which was not special. */
      ADVANCE_CHAR (string, slen, i);
    }

  if (c == 0 && nesting_level)
    {
      if (no_longjmp_on_fatal_error == 0)
	{
	  last_command_exit_value = EXECUTION_FAILURE;
	  report_error (_("bad substitution: no closing `%s' in %s"), closer, string);
	  exp_jump_to_top_level (DISCARD);
	}
      else
	{
	  *sindex = i;
	  return (char *)NULL;
	}
    }

  si = i - *sindex - len_closer + 1;
  if (flags & SX_NOALLOC)
    result = (char *)NULL;
  else    
    {
      result = (char *)xmalloc (1 + si);
      strncpy (result, string + *sindex, si);
      result[si] = '\0';
    }
  *sindex = i;

  return (result);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:1,342
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:1,509
parsing error 
{
  register int i, c;
  size_t slen;
  int pass_character, nesting_level, si, dolbrace_state;
  char *result, *t;
  DECLARE_MBSTATE;

  pass_character = 0;
  nesting_level = 1;
  slen = strlen (string + *sindex) + *sindex;

  /* The handling of dolbrace_state needs to agree with the code in parse.y:
     parse_matched_pair().  The different initial value is to handle the
     case where this function is called to parse the word in
     ${param op word} (SX_WORD). */
  dolbrace_state = (flags & SX_WORD) ? DOLBRACE_WORD : DOLBRACE_PARAM;
  if ((quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)) && (flags & SX_POSIXEXP))
    dolbrace_state = DOLBRACE_QUOTE;

  i = *sindex;
  while (c = string[i])
    {
      if (pass_character)
	{
	  pass_character = 0;
	  ADVANCE_CHAR (string, slen, i);
	  continue;
	}

      /* CTLESCs and backslashes quote the next character. */
      if (c == CTLESC || c == '\\')
	{
	  pass_character++;
	  i++;
	  continue;
	}

      if (string[i] == '$' && string[i+1] == LBRACE)
	{
	  nesting_level++;
	  i += 2;
	  continue;
	}

      if (c == RBRACE)
	{
	  nesting_level--;
	  if (nesting_level == 0)
	    break;
	  i++;
	  continue;
	}

      /* Pass the contents of old-style command substitutions through
	 verbatim. */
      if (c == '`')
	{
	  si = i + 1;
	  t = string_extract (string, &si, "`", flags|SX_NOALLOC);

	  CHECK_STRING_OVERRUN (i, si, slen, c);

	  i = si + 1;
	  continue;
	}

      /* Pass the contents of new-style command substitutions and
	 arithmetic substitutions through verbatim. */
      if (string[i] == '$' && string[i+1] == LPAREN)
	{
	  si = i + 2;
	  t = extract_command_subst (string, &si, flags|SX_NOALLOC);

	  CHECK_STRING_OVERRUN (i, si, slen, c);

	  i = si + 1;
	  continue;
	}

#if defined (PROCESS_SUBSTITUTION)
      /* Technically this should only work at the start of a word */
      if ((string[i] == '<' || string[i] == '>') && string[i+1] == LPAREN)
	{
	  si = i + 2;
	  t = extract_process_subst (string, (string[i] == '<' ? "<(" : ">)"), &si, flags|SX_NOALLOC);

	  CHECK_STRING_OVERRUN (i, si, slen, c);

	  i = si + 1;
	  continue;
	}
#endif

      /* Pass the contents of double-quoted strings through verbatim. */
      if (c == '"')
	{
	  si = i + 1;
	  i = skip_double_quoted (string, slen, si, 0);
	  /* skip_XXX_quoted leaves index one past close quote */
	  continue;
	}

      if (c == '\'')
	{
/*itrace("extract_dollar_brace_string: c == single quote flags = %d quoted = %d dolbrace_state = %d", flags, quoted, dolbrace_state);*/
	  if (posixly_correct && shell_compatibility_level > 42 && dolbrace_state != DOLBRACE_QUOTE && (quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)))
	    ADVANCE_CHAR (string, slen, i);
	  else
	    {
	      si = i + 1;
	      i = skip_single_quoted (string, slen, si, 0);
	    }

          continue;
	}

#if defined (ARRAY_VARS)
      if (c == LBRACK && dolbrace_state == DOLBRACE_PARAM)
	{
	  si = skipsubscript (string, i, 0);
	  CHECK_STRING_OVERRUN (i, si, slen, c);
	  if (string[si] == RBRACK)
	    c = string[i = si];
	}
#endif

      /* move past this character, which was not special. */
      ADVANCE_CHAR (string, slen, i);

      /* This logic must agree with parse.y:parse_matched_pair, since they
	 share the same defines. */
      if (dolbrace_state == DOLBRACE_PARAM && c == '%' && (i - *sindex) > 1)
	dolbrace_state = DOLBRACE_QUOTE;
      else if (dolbrace_state == DOLBRACE_PARAM && c == '#' && (i - *sindex) > 1)
        dolbrace_state = DOLBRACE_QUOTE;
      else if (dolbrace_state == DOLBRACE_PARAM && c == '/' && (i - *sindex) > 1)
        dolbrace_state = DOLBRACE_QUOTE2;	/* XXX */
      else if (dolbrace_state == DOLBRACE_PARAM && c == '^' && (i - *sindex) > 1)
        dolbrace_state = DOLBRACE_QUOTE;
      else if (dolbrace_state == DOLBRACE_PARAM && c == ',' && (i - *sindex) > 1)
        dolbrace_state = DOLBRACE_QUOTE;
      /* This is intended to handle all of the [:]op expansions and the substring/
	 length/pattern removal/pattern substitution expansions. */
      else if (dolbrace_state == DOLBRACE_PARAM && strchr ("#%^,~:-=?+/", c) != 0)
	dolbrace_state = DOLBRACE_OP;
      else if (dolbrace_state == DOLBRACE_OP && strchr ("#%^,~:-=?+/", c) == 0)
	dolbrace_state = DOLBRACE_WORD;
    }

  if (c == 0 && nesting_level)
    {
      if (no_longjmp_on_fatal_error == 0)
	{			/* { */
	  last_command_exit_value = EXECUTION_FAILURE;
	  report_error (_("bad substitution: no closing `%s' in %s"), "}", string);
	  exp_jump_to_top_level (DISCARD);
	}
      else
	{
	  *sindex = i;
	  return ((char *)NULL);
	}
    }

  result = (flags & SX_NOALLOC) ? (char *)NULL : substring (string, *sindex, i);
  *sindex = i;

  return (result);
}
warning: parse error {
  register int i, c;
  size_t slen;
  int pass_character, nesting_level, si, dolbrace_state;
  char *result, *t;
  DECLARE_MBSTATE;

  pass_character = 0;
  nesting_level = 1;
  slen = strlen (string + *sindex) + *sindex;

  /* The handling of dolbrace_state needs to agree with the code in parse.y:
     parse_matched_pair().  The different initial value is to handle the
     case where this function is called to parse the word in
     ${param op word} (SX_WORD). */
  dolbrace_state = (flags & SX_WORD) ? DOLBRACE_WORD : DOLBRACE_PARAM;
  if ((quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)) && (flags & SX_POSIXEXP))
    dolbrace_state = DOLBRACE_QUOTE;

  i = *sindex;
  while (c = string[i])
    {
      if (pass_character)
	{
	  pass_character = 0;
	  ADVANCE_CHAR (string, slen, i);
	  continue;
	}

      /* CTLESCs and backslashes quote the next character. */
      if (c == CTLESC || c == '\\')
	{
	  pass_character++;
	  i++;
	  continue;
	}

      if (string[i] == '$' && string[i+1] == LBRACE)
	{
	  nesting_level++;
	  i += 2;
	  continue;
	}

      if (c == RBRACE)
	{
	  nesting_level--;
	  if (nesting_level == 0)
	    break;
	  i++;
	  continue;
	}

      /* Pass the contents of old-style command substitutions through
	 verbatim. */
      if (c == '`')
	{
	  si = i + 1;
	  t = string_extract (string, &si, "`", flags|SX_NOALLOC);

	  CHECK_STRING_OVERRUN (i, si, slen, c);

	  i = si + 1;
	  continue;
	}

      /* Pass the contents of new-style command substitutions and
	 arithmetic substitutions through verbatim. */
      if (string[i] == '$' && string[i+1] == LPAREN)
	{
	  si = i + 2;
	  t = extract_command_subst (string, &si, flags|SX_NOALLOC);

	  CHECK_STRING_OVERRUN (i, si, slen, c);

	  i = si + 1;
	  continue;
	}

#if defined (PROCESS_SUBSTITUTION)
      /* Technically this should only work at the start of a word */
      if ((string[i] == '<' || string[i] == '>') && string[i+1] == LPAREN)
	{
	  si = i + 2;
	  t = extract_process_subst (string, (string[i] == '<' ? "<(" : ">)"), &si, flags|SX_NOALLOC);

	  CHECK_STRING_OVERRUN (i, si, slen, c);

	  i = si + 1;
	  continue;
	}
#endif

      /* Pass the contents of double-quoted strings through verbatim. */
      if (c == '"')
	{
	  si = i + 1;
	  i = skip_double_quoted (string, slen, si, 0);
	  /* skip_XXX_quoted leaves index one past close quote */
	  continue;
	}

      if (c == '\'')
	{
/*itrace("extract_dollar_brace_string: c == single quote flags = %d quoted = %d dolbrace_state = %d", flags, quoted, dolbrace_state);*/
	  if (posixly_correct && shell_compatibility_level > 42 && dolbrace_state != DOLBRACE_QUOTE && (quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)))
	    ADVANCE_CHAR (string, slen, i);
	  else
	    {
	      si = i + 1;
	      i = skip_single_quoted (string, slen, si, 0);
	    }

          continue;
	}

#if defined (ARRAY_VARS)
      if (c == LBRACK && dolbrace_state == DOLBRACE_PARAM)
	{
	  si = skipsubscript (string, i, 0);
	  CHECK_STRING_OVERRUN (i, si, slen, c);
	  if (string[si] == RBRACK)
	    c = string[i = si];
	}
#endif

      /* move past this character, which was not special. */
      ADVANCE_CHAR (string, slen, i);

      /* This logic must agree with parse.y:parse_matched_pair, since they
	 share the same defines. */
      if (dolbrace_state == DOLBRACE_PARAM && c == '%' && (i - *sindex) > 1)
	dolbrace_state = DOLBRACE_QUOTE;
      else if (dolbrace_state == DOLBRACE_PARAM && c == '#' && (i - *sindex) > 1)
        dolbrace_state = DOLBRACE_QUOTE;
      else if (dolbrace_state == DOLBRACE_PARAM && c == '/' && (i - *sindex) > 1)
        dolbrace_state = DOLBRACE_QUOTE2;	/* XXX */
      else if (dolbrace_state == DOLBRACE_PARAM && c == '^' && (i - *sindex) > 1)
        dolbrace_state = DOLBRACE_QUOTE;
      else if (dolbrace_state == DOLBRACE_PARAM && c == ',' && (i - *sindex) > 1)
        dolbrace_state = DOLBRACE_QUOTE;
      /* This is intended to handle all of the [:]op expansions and the substring/
	 length/pattern removal/pattern substitution expansions. */
      else if (dolbrace_state == DOLBRACE_PARAM && strchr ("#%^,~:-=?+/", c) != 0)
	dolbrace_state = DOLBRACE_OP;
      else if (dolbrace_state == DOLBRACE_OP && strchr ("#%^,~:-=?+/", c) == 0)
	dolbrace_state = DOLBRACE_WORD;
    }

  if (c == 0 && nesting_level)
    {
      if (no_longjmp_on_fatal_error == 0)
	{			/* { */
	  last_command_exit_value = EXECUTION_FAILURE;
	  report_error (_("bad substitution: no closing `%s' in %s"), "}", string);
	  exp_jump_to_top_level (DISCARD);
	}
      else
	{
	  *sindex = i;
	  return ((char *)NULL);
	}
    }

  result = (flags & SX_NOALLOC) ? (char *)NULL : substring (string, *sindex, i);
  *sindex = i;

  return (result);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:1,512
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:1,685
parsing error 
{
  register size_t slen;
  register int i, j, prev_i;
  DECLARE_MBSTATE;

  slen = strlen (string);
  i = j = 0;

  /* Loop copying string[i] to string[j], i >= j. */
  while (i < slen)
    {
      if (string[i] == '\\' && (string[i + 1] == '`' || string[i + 1] == '\\' ||
			      string[i + 1] == '$'))
	i++;
      prev_i = i;
      ADVANCE_CHAR (string, slen, i);
      if (j < prev_i)
	do string[j++] = string[prev_i++]; while (prev_i < i);
      else
	j = i;
    }
  string[j] = '\0';

  return (string);
}
warning: parse error {
  register size_t slen;
  register int i, j, prev_i;
  DECLARE_MBSTATE;

  slen = strlen (string);
  i = j = 0;

  /* Loop copying string[i] to string[j], i >= j. */
  while (i < slen)
    {
      if (string[i] == '\\' && (string[i + 1] == '`' || string[i + 1] == '\\' ||
			      string[i + 1] == '$'))
	i++;
      prev_i = i;
      ADVANCE_CHAR (string, slen, i);
      if (j < prev_i)
	do string[j++] = string[prev_i++]; while (prev_i < i);
      else
	j = i;
    }
  string[j] = '\0';

  return (string);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:1,687
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:1,748
parsing error 
{
  int i, pass_next, backq, si, c, count, oldjmp;
  size_t slen;
  char *temp, *ss;
  DECLARE_MBSTATE;

  slen = strlen (string + start) + start;
  oldjmp = no_longjmp_on_fatal_error;
  no_longjmp_on_fatal_error = 1;

  i = start + 1;		/* skip over leading bracket */
  count = 1;
  pass_next = backq = 0;
  ss = (char *)string;
  while (c = string[i])
    {
      if (pass_next)
	{
	  pass_next = 0;
	  if (c == 0)
	    CQ_RETURN(i);
	  ADVANCE_CHAR (string, slen, i);
	  continue;
	}
      else if ((flags & 1) == 0 && c == '\\')
	{
	  pass_next = 1;
	  i++;
	  continue;
	}
      else if (backq)
	{
	  if (c == '`')
	    backq = 0;
	  ADVANCE_CHAR (string, slen, i);
	  continue;
	}
      else if ((flags & 1) == 0 && c == '`')
	{
	  backq = 1;
	  i++;
	  continue;
	}
      else if ((flags & 1) == 0 && c == open)
	{
	  count++;
	  i++;
	  continue;
	}
      else if (c == close)
	{
	  count--;
	  if (count == 0)
	    break;
	  i++;
	  continue;
	}
      else if ((flags & 1) == 0 && (c == '\'' || c == '"'))
	{
	  i = (c == '\'') ? skip_single_quoted (ss, slen, ++i, 0)
			  : skip_double_quoted (ss, slen, ++i, 0);
	  /* no increment, the skip functions increment past the closing quote. */
	}
      else if ((flags&1) == 0 && c == '$' && (string[i+1] == LPAREN || string[i+1] == LBRACE))
	{
	  si = i + 2;
	  if (string[si] == '\0')
	    CQ_RETURN(si);

	  /* XXX - extract_command_subst here? */
	  if (string[i+1] == LPAREN)
	    temp = extract_delimited_string (ss, &si, "$(", "(", ")", SX_NOALLOC|SX_COMMAND); /* ) */
	  else
	    temp = extract_dollar_brace_string (ss, &si, 0, SX_NOALLOC);

	  CHECK_STRING_OVERRUN (i, si, slen, c);

	  i = si;
	  if (string[i] == '\0')	/* don't increment i past EOS in loop */
	    break;
	  i++;
	  continue;
	}
      else
	ADVANCE_CHAR (string, slen, i);
    }

  CQ_RETURN(i);
}
warning: parse error {
  int i, pass_next, backq, si, c, count, oldjmp;
  size_t slen;
  char *temp, *ss;
  DECLARE_MBSTATE;

  slen = strlen (string + start) + start;
  oldjmp = no_longjmp_on_fatal_error;
  no_longjmp_on_fatal_error = 1;

  i = start + 1;		/* skip over leading bracket */
  count = 1;
  pass_next = backq = 0;
  ss = (char *)string;
  while (c = string[i])
    {
      if (pass_next)
	{
	  pass_next = 0;
	  if (c == 0)
	    CQ_RETURN(i);
	  ADVANCE_CHAR (string, slen, i);
	  continue;
	}
      else if ((flags & 1) == 0 && c == '\\')
	{
	  pass_next = 1;
	  i++;
	  continue;
	}
      else if (backq)
	{
	  if (c == '`')
	    backq = 0;
	  ADVANCE_CHAR (string, slen, i);
	  continue;
	}
      else if ((flags & 1) == 0 && c == '`')
	{
	  backq = 1;
	  i++;
	  continue;
	}
      else if ((flags & 1) == 0 && c == open)
	{
	  count++;
	  i++;
	  continue;
	}
      else if (c == close)
	{
	  count--;
	  if (count == 0)
	    break;
	  i++;
	  continue;
	}
      else if ((flags & 1) == 0 && (c == '\'' || c == '"'))
	{
	  i = (c == '\'') ? skip_single_quoted (ss, slen, ++i, 0)
			  : skip_double_quoted (ss, slen, ++i, 0);
	  /* no increment, the skip functions increment past the closing quote. */
	}
      else if ((flags&1) == 0 && c == '$' && (string[i+1] == LPAREN || string[i+1] == LBRACE))
	{
	  si = i + 2;
	  if (string[si] == '\0')
	    CQ_RETURN(si);

	  /* XXX - extract_command_subst here? */
	  if (string[i+1] == LPAREN)
	    temp = extract_delimited_string (ss, &si, "$(", "(", ")", SX_NOALLOC|SX_COMMAND); /* ) */
	  else
	    temp = extract_dollar_brace_string (ss, &si, 0, SX_NOALLOC);

	  CHECK_STRING_OVERRUN (i, si, slen, c);

	  i = si;
	  if (string[i] == '\0')	/* don't increment i past EOS in loop */
	    break;
	  i++;
	  continue;
	}
      else
	ADVANCE_CHAR (string, slen, i);
    }

  CQ_RETURN(i);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:1,750
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:1,860
parsing error 
{
  int i, pass_next, backq, dquote, si, c, oldjmp;
  int invert, skipquote, skipcmd, noprocsub, completeflag;
  int arithexp, skipcol;
  size_t slen;
  char *temp, open[3];
  DECLARE_MBSTATE;

  slen = strlen (string + start) + start;
  oldjmp = no_longjmp_on_fatal_error;
  if (flags & SD_NOJMP)
    no_longjmp_on_fatal_error = 1;
  invert = (flags & SD_INVERT);
  skipcmd = (flags & SD_NOSKIPCMD) == 0;
  noprocsub = (flags & SD_NOPROCSUB);
  completeflag = (flags & SD_COMPLETE) ? SX_COMPLETE : 0;

  arithexp = (flags & SD_ARITHEXP);
  skipcol = 0;

  i = start;
  pass_next = backq = dquote = 0;
  while (c = string[i])
    {
      /* If this is non-zero, we should not let quote characters be delimiters
	 and the current character is a single or double quote.  We should not
	 test whether or not it's a delimiter until after we skip single- or
	 double-quoted strings. */
      skipquote = ((flags & SD_NOQUOTEDELIM) && (c == '\'' || c =='"'));
      if (pass_next)
	{
	  pass_next = 0;
	  if (c == 0)
	    CQ_RETURN(i);
	  ADVANCE_CHAR (string, slen, i);
	  continue;
	}
      else if (c == '\\')
	{
	  pass_next = 1;
	  i++;
	  continue;
	}
      else if (backq)
	{
	  if (c == '`')
	    backq = 0;
	  ADVANCE_CHAR (string, slen, i);
	  continue;
	}
      else if (c == '`')
	{
	  backq = 1;
	  i++;
	  continue;
	}
      else if (arithexp && skipcol && c == ':')
	{
	  skipcol--;
	  i++;
	  continue;
	}
      else if (arithexp && c == '?')
	{
	  skipcol++;
	  i++;
	  continue;
	}
      else if (skipquote == 0 && invert == 0 && member (c, delims))
	break;
      /* the usual case is to use skip_xxx_quoted, but we don't skip over double
	 quoted strings when looking for the history expansion character as a
	 delimiter. */
      /* special case for programmable completion which takes place before
         parser converts backslash-escaped single quotes between $'...' to
         `regular' single-quoted strings. */
      else if (completeflag && i > 0 && string[i-1] == '$' && c == '\'')
	i = skip_single_quoted (string, slen, ++i, SX_COMPLETE);
      else if (c == '\'')
	i = skip_single_quoted (string, slen, ++i, 0);
      else if (c == '"')
	i = skip_double_quoted (string, slen, ++i, completeflag);
      else if (c == LPAREN && arithexp)
        {
          si = i + 1;
          if (string[si] == '\0')
	    CQ_RETURN(si);

	  temp = extract_delimited_string (string, &si, "(", "(", ")", SX_NOALLOC); /* ) */
	  i = si;
	  if (string[i] == '\0')	/* don't increment i past EOS in loop */
	    break;
	  i++;
	  continue;         
        }
      else if (c == '$' && ((skipcmd && string[i+1] == LPAREN) || string[i+1] == LBRACE))
	{
	  si = i + 2;
	  if (string[si] == '\0')
	    CQ_RETURN(si);

	  if (string[i+1] == LPAREN)
	    temp = extract_delimited_string (string, &si, "$(", "(", ")", SX_NOALLOC|SX_COMMAND); /* ) */
	  else
	    temp = extract_dollar_brace_string (string, &si, 0, SX_NOALLOC);
	  CHECK_STRING_OVERRUN (i, si, slen, c);
	  i = si;
	  if (string[i] == '\0')	/* don't increment i past EOS in loop */
	    break;
	  i++;
	  continue;
	}
#if defined (PROCESS_SUBSTITUTION)
      else if (skipcmd && noprocsub == 0 && (c == '<' || c == '>') && string[i+1] == LPAREN)
	{
	  si = i + 2;
	  if (string[si] == '\0')
	    CQ_RETURN(si);

	  temp = extract_delimited_string (string, &si, (c == '<') ? "<(" : ">(", "(", ")", SX_COMMAND|SX_NOALLOC); /* )) */
	  CHECK_STRING_OVERRUN (i, si, slen, c);
	  i = si;
	  if (string[i] == '\0')
	    break;
	  i++;
	  continue;
	}
#endif /* PROCESS_SUBSTITUTION */
#if defined (EXTENDED_GLOB)
      else if ((flags & SD_EXTGLOB) && extended_glob && string[i+1] == LPAREN && member (c, "?*+!@"))
	{
	  si = i + 2;
	  if (string[si] == '\0')
	    CQ_RETURN(si);

	  open[0] = c;
	  open[1] = LPAREN;
	  open[2] = '\0';
	  temp = extract_delimited_string (string, &si, open, "(", ")", SX_NOALLOC); /* ) */

	  CHECK_STRING_OVERRUN (i, si, slen, c);
	  i = si;
	  if (string[i] == '\0')	/* don't increment i past EOS in loop */
	    break;
	  i++;
	  continue;
	}
#endif
      else if ((flags & SD_GLOB) && c == LBRACK)
	{
	  si = i + 1;
	  if (string[si] == '\0')
	    CQ_RETURN(si);

	  temp = extract_delimited_string (string, &si, "[", "[", "]", SX_NOALLOC); /* ] */

	  i = si;
	  if (string[i] == '\0')	/* don't increment i past EOS in loop */
	    break;
	  i++;
	  continue;
	}
      else if ((skipquote || invert) && (member (c, delims) == 0))
	break;
      else
	ADVANCE_CHAR (string, slen, i);
    }

  CQ_RETURN(i);
}
warning: parse error {
  int i, pass_next, backq, dquote, si, c, oldjmp;
  int invert, skipquote, skipcmd, noprocsub, completeflag;
  int arithexp, skipcol;
  size_t slen;
  char *temp, open[3];
  DECLARE_MBSTATE;

  slen = strlen (string + start) + start;
  oldjmp = no_longjmp_on_fatal_error;
  if (flags & SD_NOJMP)
    no_longjmp_on_fatal_error = 1;
  invert = (flags & SD_INVERT);
  skipcmd = (flags & SD_NOSKIPCMD) == 0;
  noprocsub = (flags & SD_NOPROCSUB);
  completeflag = (flags & SD_COMPLETE) ? SX_COMPLETE : 0;

  arithexp = (flags & SD_ARITHEXP);
  skipcol = 0;

  i = start;
  pass_next = backq = dquote = 0;
  while (c = string[i])
    {
      /* If this is non-zero, we should not let quote characters be delimiters
	 and the current character is a single or double quote.  We should not
	 test whether or not it's a delimiter until after we skip single- or
	 double-quoted strings. */
      skipquote = ((flags & SD_NOQUOTEDELIM) && (c == '\'' || c =='"'));
      if (pass_next)
	{
	  pass_next = 0;
	  if (c == 0)
	    CQ_RETURN(i);
	  ADVANCE_CHAR (string, slen, i);
	  continue;
	}
      else if (c == '\\')
	{
	  pass_next = 1;
	  i++;
	  continue;
	}
      else if (backq)
	{
	  if (c == '`')
	    backq = 0;
	  ADVANCE_CHAR (string, slen, i);
	  continue;
	}
      else if (c == '`')
	{
	  backq = 1;
	  i++;
	  continue;
	}
      else if (arithexp && skipcol && c == ':')
	{
	  skipcol--;
	  i++;
	  continue;
	}
      else if (arithexp && c == '?')
	{
	  skipcol++;
	  i++;
	  continue;
	}
      else if (skipquote == 0 && invert == 0 && member (c, delims))
	break;
      /* the usual case is to use skip_xxx_quoted, but we don't skip over double
	 quoted strings when looking for the history expansion character as a
	 delimiter. */
      /* special case for programmable completion which takes place before
         parser converts backslash-escaped single quotes between $'...' to
         `regular' single-quoted strings. */
      else if (completeflag && i > 0 && string[i-1] == '$' && c == '\'')
	i = skip_single_quoted (string, slen, ++i, SX_COMPLETE);
      else if (c == '\'')
	i = skip_single_quoted (string, slen, ++i, 0);
      else if (c == '"')
	i = skip_double_quoted (string, slen, ++i, completeflag);
      else if (c == LPAREN && arithexp)
        {
          si = i + 1;
          if (string[si] == '\0')
	    CQ_RETURN(si);

	  temp = extract_delimited_string (string, &si, "(", "(", ")", SX_NOALLOC); /* ) */
	  i = si;
	  if (string[i] == '\0')	/* don't increment i past EOS in loop */
	    break;
	  i++;
	  continue;         
        }
      else if (c == '$' && ((skipcmd && string[i+1] == LPAREN) || string[i+1] == LBRACE))
	{
	  si = i + 2;
	  if (string[si] == '\0')
	    CQ_RETURN(si);

	  if (string[i+1] == LPAREN)
	    temp = extract_delimited_string (string, &si, "$(", "(", ")", SX_NOALLOC|SX_COMMAND); /* ) */
	  else
	    temp = extract_dollar_brace_string (string, &si, 0, SX_NOALLOC);
	  CHECK_STRING_OVERRUN (i, si, slen, c);
	  i = si;
	  if (string[i] == '\0')	/* don't increment i past EOS in loop */
	    break;
	  i++;
	  continue;
	}
#if defined (PROCESS_SUBSTITUTION)
      else if (skipcmd && noprocsub == 0 && (c == '<' || c == '>') && string[i+1] == LPAREN)
	{
	  si = i + 2;
	  if (string[si] == '\0')
	    CQ_RETURN(si);

	  temp = extract_delimited_string (string, &si, (c == '<') ? "<(" : ">(", "(", ")", SX_COMMAND|SX_NOALLOC); /* )) */
	  CHECK_STRING_OVERRUN (i, si, slen, c);
	  i = si;
	  if (string[i] == '\0')
	    break;
	  i++;
	  continue;
	}
#endif /* PROCESS_SUBSTITUTION */
#if defined (EXTENDED_GLOB)
      else if ((flags & SD_EXTGLOB) && extended_glob && string[i+1] == LPAREN && member (c, "?*+!@"))
	{
	  si = i + 2;
	  if (string[si] == '\0')
	    CQ_RETURN(si);

	  open[0] = c;
	  open[1] = LPAREN;
	  open[2] = '\0';
	  temp = extract_delimited_string (string, &si, open, "(", ")", SX_NOALLOC); /* ) */

	  CHECK_STRING_OVERRUN (i, si, slen, c);
	  i = si;
	  if (string[i] == '\0')	/* don't increment i past EOS in loop */
	    break;
	  i++;
	  continue;
	}
#endif
      else if ((flags & SD_GLOB) && c == LBRACK)
	{
	  si = i + 1;
	  if (string[si] == '\0')
	    CQ_RETURN(si);

	  temp = extract_delimited_string (string, &si, "[", "[", "]", SX_NOALLOC); /* ] */

	  i = si;
	  if (string[i] == '\0')	/* don't increment i past EOS in loop */
	    break;
	  i++;
	  continue;
	}
      else if ((skipquote || invert) && (member (c, delims) == 0))
	break;
      else
	ADVANCE_CHAR (string, slen, i);
    }

  CQ_RETURN(i);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:1,865
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:2,466
parsing error 
{
  register WORD_LIST *t;
  char *result, *r;
  size_t word_len, sep_len, result_size;

  if (list == 0)
    return ((char *)NULL);

  /* Short-circuit quickly if we don't need to separate anything. */
  if (list->next == 0)
    return (savestring (list->word->word));

  /* This is nearly always called with either sep[0] == 0 or sep[1] == 0. */
  sep_len = STRLEN (sep);
  result_size = 0;

  for (t = list; t; t = t->next)
    {
      if (t != list)
	result_size += sep_len;
      result_size += strlen (t->word->word);
    }

  r = result = (char *)xmalloc (result_size + 1);

  for (t = list; t; t = t->next)
    {
      if (t != list && sep_len)
	{
	  if (sep_len > 1)
	    {
	      FASTCOPY (sep, r, sep_len);
	      r += sep_len;
	    }
	  else
	    *r++ = sep[0];
	}

      word_len = strlen (t->word->word);
      FASTCOPY (t->word->word, r, word_len);
      r += word_len;
    }

  *r = '\0';
  return (result);
}
warning: parse error {
  register WORD_LIST *t;
  char *result, *r;
  size_t word_len, sep_len, result_size;

  if (list == 0)
    return ((char *)NULL);

  /* Short-circuit quickly if we don't need to separate anything. */
  if (list->next == 0)
    return (savestring (list->word->word));

  /* This is nearly always called with either sep[0] == 0 or sep[1] == 0. */
  sep_len = STRLEN (sep);
  result_size = 0;

  for (t = list; t; t = t->next)
    {
      if (t != list)
	result_size += sep_len;
      result_size += strlen (t->word->word);
    }

  r = result = (char *)xmalloc (result_size + 1);

  for (t = list; t; t = t->next)
    {
      if (t != list && sep_len)
	{
	  if (sep_len > 1)
	    {
	      FASTCOPY (sep, r, sep_len);
	      r += sep_len;
	    }
	  else
	    *r++ = sep[0];
	}

      word_len = strlen (t->word->word);
      FASTCOPY (t->word->word, r, word_len);
      r += word_len;
    }

  *r = '\0';
  return (result);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:2,469
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:2,519
parsing error 
{
  return (string_list_internal (list, " "));
}
warning: parse error {
  return (string_list_internal (list, " "));
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:2,521
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:2,530
parsing error 
{
  char *ret;
  int len;

  ret = xmalloc (MB_LEN_MAX + 1);
#if defined (HANDLE_MULTIBYTE)
  if (ifs_firstc_len == 1)
    {
      ret[0] = ifs_firstc[0];
      ret[1] = '\0';
      len = ret[0] ? 1 : 0;
    }
  else
    {
      memcpy (ret, ifs_firstc, ifs_firstc_len);
      ret[len = ifs_firstc_len] = '\0';
    }
#else
  ret[0] = ifs_firstc;
  ret[1] = '\0';
  len = ret[0] ? 0 : 1;
#endif

  if (lenp)
    *lenp = len;

  return ret;
}
warning: parse error {
  char *ret;
  int len;

  ret = xmalloc (MB_LEN_MAX + 1);
#if defined (HANDLE_MULTIBYTE)
  if (ifs_firstc_len == 1)
    {
      ret[0] = ifs_firstc[0];
      ret[1] = '\0';
      len = ret[0] ? 1 : 0;
    }
  else
    {
      memcpy (ret, ifs_firstc, ifs_firstc_len);
      ret[len = ifs_firstc_len] = '\0';
    }
#else
  ret[0] = ifs_firstc;
  ret[1] = '\0';
  len = ret[0] ? 0 : 1;
#endif

  if (lenp)
    *lenp = len;

  return ret;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:2,532
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:2,569
parsing error 
{
  char *ret;
#if defined (HANDLE_MULTIBYTE)
#  if defined (__GNUC__)
  char sep[MB_CUR_MAX + 1];
#  else
  char *sep = 0;
#  endif
#else
  char sep[2];
#endif

#if defined (HANDLE_MULTIBYTE)
#  if !defined (__GNUC__)
  sep = (char *)xmalloc (MB_CUR_MAX + 1);
#  endif /* !__GNUC__ */
  if (ifs_firstc_len == 1)
    {
      sep[0] = ifs_firstc[0];
      sep[1] = '\0';
    }
  else
    {
      memcpy (sep, ifs_firstc, ifs_firstc_len);
      sep[ifs_firstc_len] = '\0';
    }
#else
  sep[0] = ifs_firstc;
  sep[1] = '\0';
#endif

  ret = string_list_internal (list, sep);
#if defined (HANDLE_MULTIBYTE) && !defined (__GNUC__)
  free (sep);
#endif
  return ret;
}
warning: parse error {
  char *ret;
#if defined (HANDLE_MULTIBYTE)
#  if defined (__GNUC__)
  char sep[MB_CUR_MAX + 1];
#  else
  char *sep = 0;
#  endif
#else
  char sep[2];
#endif

#if defined (HANDLE_MULTIBYTE)
#  if !defined (__GNUC__)
  sep = (char *)xmalloc (MB_CUR_MAX + 1);
#  endif /* !__GNUC__ */
  if (ifs_firstc_len == 1)
    {
      sep[0] = ifs_firstc[0];
      sep[1] = '\0';
    }
  else
    {
      memcpy (sep, ifs_firstc, ifs_firstc_len);
      sep[ifs_firstc_len] = '\0';
    }
#else
  sep[0] = ifs_firstc;
  sep[1] = '\0';
#endif

  ret = string_list_internal (list, sep);
#if defined (HANDLE_MULTIBYTE) && !defined (__GNUC__)
  free (sep);
#endif
  return ret;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:2,572
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:2,626
parsing error 
{
  char *ifs, *ret;
#if defined (HANDLE_MULTIBYTE)
#  if defined (__GNUC__)
  char sep[MB_CUR_MAX + 1];
#  else
  char *sep = 0;
#  endif /* !__GNUC__ */
#else
  char sep[2];
#endif
  WORD_LIST *tlist;

  /* XXX this could just be ifs = ifs_value; */
  ifs = ifs_var ? value_cell (ifs_var) : (char *)0;

#if defined (HANDLE_MULTIBYTE)
#  if !defined (__GNUC__)
  sep = (char *)xmalloc (MB_CUR_MAX + 1);
#  endif /* !__GNUC__ */
  /* XXX - testing PF_ASSIGNRHS to make sure positional parameters are
     separated with a space even when word splitting will not occur. */
  if (flags & PF_ASSIGNRHS)
    {
      sep[0] = ' ';
      sep[1] = '\0';
    }
  else if (ifs && *ifs)
    {
      if (ifs_firstc_len == 1)
	{
	  sep[0] = ifs_firstc[0];
	  sep[1] = '\0';
	}
      else
	{
	  memcpy (sep, ifs_firstc, ifs_firstc_len);
	  sep[ifs_firstc_len] = '\0';
	}
    }
  else
    {
      sep[0] = ' ';
      sep[1] = '\0';
    }
#else	/* !HANDLE_MULTIBYTE */
  /* XXX - PF_ASSIGNRHS means no word splitting, so we want positional
     parameters separated by a space. */
  sep[0] = ((flags & PF_ASSIGNRHS) || ifs == 0 || *ifs == 0) ? ' ' : *ifs;
  sep[1] = '\0';
#endif	/* !HANDLE_MULTIBYTE */

  /* XXX -- why call quote_list if ifs == 0?  we can get away without doing
     it now that quote_escapes quotes spaces */
  tlist = (quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES|Q_PATQUOTE))
		? quote_list (list)
		: list_quote_escapes (list);

  ret = string_list_internal (tlist, sep);
#if defined (HANDLE_MULTIBYTE) && !defined (__GNUC__)
  free (sep);
#endif
  return ret;
}
warning: parse error {
  char *ifs, *ret;
#if defined (HANDLE_MULTIBYTE)
#  if defined (__GNUC__)
  char sep[MB_CUR_MAX + 1];
#  else
  char *sep = 0;
#  endif /* !__GNUC__ */
#else
  char sep[2];
#endif
  WORD_LIST *tlist;

  /* XXX this could just be ifs = ifs_value; */
  ifs = ifs_var ? value_cell (ifs_var) : (char *)0;

#if defined (HANDLE_MULTIBYTE)
#  if !defined (__GNUC__)
  sep = (char *)xmalloc (MB_CUR_MAX + 1);
#  endif /* !__GNUC__ */
  /* XXX - testing PF_ASSIGNRHS to make sure positional parameters are
     separated with a space even when word splitting will not occur. */
  if (flags & PF_ASSIGNRHS)
    {
      sep[0] = ' ';
      sep[1] = '\0';
    }
  else if (ifs && *ifs)
    {
      if (ifs_firstc_len == 1)
	{
	  sep[0] = ifs_firstc[0];
	  sep[1] = '\0';
	}
      else
	{
	  memcpy (sep, ifs_firstc, ifs_firstc_len);
	  sep[ifs_firstc_len] = '\0';
	}
    }
  else
    {
      sep[0] = ' ';
      sep[1] = '\0';
    }
#else	/* !HANDLE_MULTIBYTE */
  /* XXX - PF_ASSIGNRHS means no word splitting, so we want positional
     parameters separated by a space. */
  sep[0] = ((flags & PF_ASSIGNRHS) || ifs == 0 || *ifs == 0) ? ' ' : *ifs;
  sep[1] = '\0';
#endif	/* !HANDLE_MULTIBYTE */

  /* XXX -- why call quote_list if ifs == 0?  we can get away without doing
     it now that quote_escapes quotes spaces */
  tlist = (quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES|Q_PATQUOTE))
		? quote_list (list)
		: list_quote_escapes (list);

  ret = string_list_internal (tlist, sep);
#if defined (HANDLE_MULTIBYTE) && !defined (__GNUC__)
  free (sep);
#endif
  return ret;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:2,630
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:2,702
parsing error 
{
  char *ret;
  WORD_LIST *tlist;

  if (pchar == '*' && (quoted & Q_DOUBLE_QUOTES))
    {
      tlist = quote_list (list);
      word_list_remove_quoted_nulls (tlist);
      ret = string_list_dollar_star (tlist, 0, 0);
    }
  else if (pchar == '*' && (quoted & Q_HERE_DOCUMENT))
    {
      tlist = quote_list (list);
      word_list_remove_quoted_nulls (tlist);
      ret = string_list (tlist);
    }
  else if (pchar == '*' && quoted == 0 && ifs_is_null)	/* XXX */
    ret = expand_no_split_dollar_star ? string_list_dollar_star (list, quoted, 0) : string_list_dollar_at (list, quoted, 0);	/* Posix interp 888 */
  else if (pchar == '*' && quoted == 0 && (pflags & PF_ASSIGNRHS))	/* XXX */
    ret = expand_no_split_dollar_star ? string_list_dollar_star (list, quoted, 0) : string_list_dollar_at (list, quoted, 0);	/* Posix interp 888 */
  else if (pchar == '*')
    {
      /* Even when unquoted, string_list_dollar_star does the right thing
	 making sure that the first character of $IFS is used as the
	 separator. */
      ret = string_list_dollar_star (list, quoted, 0);
    }
  else if (pchar == '@' && (quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)))
    /* We use string_list_dollar_at, but only if the string is quoted, since
       that quotes the escapes if it's not, which we don't want.  We could
       use string_list (the old code did), but that doesn't do the right
       thing if the first character of $IFS is not a space.  We use
       string_list_dollar_star if the string is unquoted so we make sure that
       the elements of $@ are separated by the first character of $IFS for
       later splitting. */
    ret = string_list_dollar_at (list, quoted, 0);
  else if (pchar == '@' && quoted == 0 && ifs_is_null)	/* XXX */
    ret = string_list_dollar_at (list, quoted, 0);	/* Posix interp 888 */
  else if (pchar == '@' && quoted == 0 && (pflags & PF_ASSIGNRHS))
    ret = string_list_dollar_at (list, quoted, pflags);	/* Posix interp 888 */
  else if (pchar == '@')
    ret = string_list_dollar_star (list, quoted, 0);
  else
    ret = string_list ((quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)) ? quote_list (list) : list);

  return ret;
}
warning: parse error {
  char *ret;
  WORD_LIST *tlist;

  if (pchar == '*' && (quoted & Q_DOUBLE_QUOTES))
    {
      tlist = quote_list (list);
      word_list_remove_quoted_nulls (tlist);
      ret = string_list_dollar_star (tlist, 0, 0);
    }
  else if (pchar == '*' && (quoted & Q_HERE_DOCUMENT))
    {
      tlist = quote_list (list);
      word_list_remove_quoted_nulls (tlist);
      ret = string_list (tlist);
    }
  else if (pchar == '*' && quoted == 0 && ifs_is_null)	/* XXX */
    ret = expand_no_split_dollar_star ? string_list_dollar_star (list, quoted, 0) : string_list_dollar_at (list, quoted, 0);	/* Posix interp 888 */
  else if (pchar == '*' && quoted == 0 && (pflags & PF_ASSIGNRHS))	/* XXX */
    ret = expand_no_split_dollar_star ? string_list_dollar_star (list, quoted, 0) : string_list_dollar_at (list, quoted, 0);	/* Posix interp 888 */
  else if (pchar == '*')
    {
      /* Even when unquoted, string_list_dollar_star does the right thing
	 making sure that the first character of $IFS is used as the
	 separator. */
      ret = string_list_dollar_star (list, quoted, 0);
    }
  else if (pchar == '@' && (quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)))
    /* We use string_list_dollar_at, but only if the string is quoted, since
       that quotes the escapes if it's not, which we don't want.  We could
       use string_list (the old code did), but that doesn't do the right
       thing if the first character of $IFS is not a space.  We use
       string_list_dollar_star if the string is unquoted so we make sure that
       the elements of $@ are separated by the first character of $IFS for
       later splitting. */
    ret = string_list_dollar_at (list, quoted, 0);
  else if (pchar == '@' && quoted == 0 && ifs_is_null)	/* XXX */
    ret = string_list_dollar_at (list, quoted, 0);	/* Posix interp 888 */
  else if (pchar == '@' && quoted == 0 && (pflags & PF_ASSIGNRHS))
    ret = string_list_dollar_at (list, quoted, pflags);	/* Posix interp 888 */
  else if (pchar == '@')
    ret = string_list_dollar_star (list, quoted, 0);
  else
    ret = string_list ((quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)) ? quote_list (list) : list);

  return ret;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:2,706
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:2,794
parsing error 
{
  WORD_LIST *result;
  WORD_DESC *t;
  char *current_word, *s;
  int sindex, sh_style_split, whitesep, xflags, free_word;
  size_t slen;

  if (!string || !*string)
    return ((WORD_LIST *)NULL);

  sh_style_split = separators && separators[0] == ' ' &&
				 separators[1] == '\t' &&
				 separators[2] == '\n' &&
				 separators[3] == '\0';
  for (xflags = 0, s = ifs_value; s && *s; s++)
    {
      if (*s == CTLESC) xflags |= SX_NOCTLESC;
      else if (*s == CTLNUL) xflags |= SX_NOESCCTLNUL;
    }

  slen = 0;
  /* Remove sequences of whitespace at the beginning of STRING, as
     long as those characters appear in IFS.  Do not do this if
     STRING is quoted or if there are no separator characters. We use the
     Posix definition of whitespace as a member of the space character
     class in the current locale. */
#if 0
  if (!quoted || !separators || !*separators)
#else
  /* issep() requires that separators be non-null, and always returns 0 if
     separator is the empty string, so don't bother if we get an empty string
     for separators. We already returned NULL above if STRING is empty. */
  if (!quoted && separators && *separators)
#endif
    {
      for (s = string; *s && issep (*s) && ifs_whitespace (*s); s++);

      if (!*s)
	return ((WORD_LIST *)NULL);

      string = s;
    }

  /* OK, now STRING points to a word that does not begin with white space.
     The splitting algorithm is:
	extract a word, stopping at a separator
	skip sequences of whitespace characters as long as they are separators
     This obeys the field splitting rules in Posix.2. */
  slen = STRLEN (string);
  for (result = (WORD_LIST *)NULL, sindex = 0; string[sindex]; )
    {
      /* Don't need string length in ADVANCE_CHAR unless multibyte chars are
	 possible, but need it in string_extract_verbatim for bounds checking */
      current_word = string_extract_verbatim (string, slen, &sindex, separators, xflags);
      if (current_word == 0)
	break;

      free_word = 1;	/* If non-zero, we free current_word */

      /* If we have a quoted empty string, add a quoted null argument.  We
	 want to preserve the quoted null character iff this is a quoted
	 empty string; otherwise the quoted null characters are removed
	 below. */
      if (QUOTED_NULL (current_word))
	{
	  t = alloc_word_desc ();
	  t->word = make_quoted_char ('\0');
	  t->flags |= W_QUOTED|W_HASQUOTEDNULL;
	  result = make_word_list (t, result);
	}
      else if (current_word[0] != '\0')
	{
	  /* If we have something, then add it regardless.  However,
	     perform quoted null character removal on the current word. */
	  remove_quoted_nulls (current_word);

	  /* We don't want to set the word flags based on the string contents
	     here -- that's mostly for the parser -- so we just allocate a
	     WORD_DESC *, assign current_word (noting that we don't want to
	     free it), and skip all of make_word. */
	  t = alloc_word_desc ();
	  t->word = current_word;
	  result = make_word_list (t, result);
	  free_word = 0;
	  result->word->flags &= ~W_HASQUOTEDNULL;	/* just to be sure */
	  if (quoted & (Q_DOUBLE_QUOTES|Q_HERE_DOCUMENT))
	    result->word->flags |= W_QUOTED;
	  /* If removing quoted null characters leaves an empty word, note
	     that we saw this for the caller to act on. */
	  if (current_word == 0 || current_word[0] == '\0')
	    result->word->flags |= W_SAWQUOTEDNULL;
	}

      /* If we're not doing sequences of separators in the traditional
	 Bourne shell style, then add a quoted null argument. */
      else if (!sh_style_split && !ifs_whitespace (string[sindex]))
	{
	  t = alloc_word_desc ();
	  t->word = make_quoted_char ('\0');
	  t->flags |= W_QUOTED|W_HASQUOTEDNULL;
	  result = make_word_list (t, result);
	}

      if (free_word)
	free (current_word);

      /* Note whether or not the separator is IFS whitespace, used later. */
      whitesep = string[sindex] && ifs_whitesep (string[sindex]);

      /* Move past the current separator character. */
      if (string[sindex])
	{
	  DECLARE_MBSTATE;
	  ADVANCE_CHAR (string, slen, sindex);
	}

      /* Now skip sequences of whitespace characters if they are
	 in the list of separators. */
      while (string[sindex] && ifs_whitesep (string[sindex]) && issep (string[sindex]))
	sindex++;

      /* If the first separator was IFS whitespace and the current character
	 is a non-whitespace IFS character, it should be part of the current
	 field delimiter, not a separate delimiter that would result in an
	 empty field.  Look at POSIX.2, 3.6.5, (3)(b). */
      if (string[sindex] && whitesep && issep (string[sindex]) && !ifs_whitesep (string[sindex]))
	{
	  sindex++;
	  /* An IFS character that is not IFS white space, along with any
	     adjacent IFS white space, shall delimit a field. (SUSv3) */
	  while (string[sindex] && ifs_whitesep (string[sindex]) && isifs (string[sindex]))
	    sindex++;
	}
    }
  return (REVERSE_LIST (result, WORD_LIST *));
}
warning: parse error {
  WORD_LIST *result;
  WORD_DESC *t;
  char *current_word, *s;
  int sindex, sh_style_split, whitesep, xflags, free_word;
  size_t slen;

  if (!string || !*string)
    return ((WORD_LIST *)NULL);

  sh_style_split = separators && separators[0] == ' ' &&
				 separators[1] == '\t' &&
				 separators[2] == '\n' &&
				 separators[3] == '\0';
  for (xflags = 0, s = ifs_value; s && *s; s++)
    {
      if (*s == CTLESC) xflags |= SX_NOCTLESC;
      else if (*s == CTLNUL) xflags |= SX_NOESCCTLNUL;
    }

  slen = 0;
  /* Remove sequences of whitespace at the beginning of STRING, as
     long as those characters appear in IFS.  Do not do this if
     STRING is quoted or if there are no separator characters. We use the
     Posix definition of whitespace as a member of the space character
     class in the current locale. */
#if 0
  if (!quoted || !separators || !*separators)
#else
  /* issep() requires that separators be non-null, and always returns 0 if
     separator is the empty string, so don't bother if we get an empty string
     for separators. We already returned NULL above if STRING is empty. */
  if (!quoted && separators && *separators)
#endif
    {
      for (s = string; *s && issep (*s) && ifs_whitespace (*s); s++);

      if (!*s)
	return ((WORD_LIST *)NULL);

      string = s;
    }

  /* OK, now STRING points to a word that does not begin with white space.
     The splitting algorithm is:
	extract a word, stopping at a separator
	skip sequences of whitespace characters as long as they are separators
     This obeys the field splitting rules in Posix.2. */
  slen = STRLEN (string);
  for (result = (WORD_LIST *)NULL, sindex = 0; string[sindex]; )
    {
      /* Don't need string length in ADVANCE_CHAR unless multibyte chars are
	 possible, but need it in string_extract_verbatim for bounds checking */
      current_word = string_extract_verbatim (string, slen, &sindex, separators, xflags);
      if (current_word == 0)
	break;

      free_word = 1;	/* If non-zero, we free current_word */

      /* If we have a quoted empty string, add a quoted null argument.  We
	 want to preserve the quoted null character iff this is a quoted
	 empty string; otherwise the quoted null characters are removed
	 below. */
      if (QUOTED_NULL (current_word))
	{
	  t = alloc_word_desc ();
	  t->word = make_quoted_char ('\0');
	  t->flags |= W_QUOTED|W_HASQUOTEDNULL;
	  result = make_word_list (t, result);
	}
      else if (current_word[0] != '\0')
	{
	  /* If we have something, then add it regardless.  However,
	     perform quoted null character removal on the current word. */
	  remove_quoted_nulls (current_word);

	  /* We don't want to set the word flags based on the string contents
	     here -- that's mostly for the parser -- so we just allocate a
	     WORD_DESC *, assign current_word (noting that we don't want to
	     free it), and skip all of make_word. */
	  t = alloc_word_desc ();
	  t->word = current_word;
	  result = make_word_list (t, result);
	  free_word = 0;
	  result->word->flags &= ~W_HASQUOTEDNULL;	/* just to be sure */
	  if (quoted & (Q_DOUBLE_QUOTES|Q_HERE_DOCUMENT))
	    result->word->flags |= W_QUOTED;
	  /* If removing quoted null characters leaves an empty word, note
	     that we saw this for the caller to act on. */
	  if (current_word == 0 || current_word[0] == '\0')
	    result->word->flags |= W_SAWQUOTEDNULL;
	}

      /* If we're not doing sequences of separators in the traditional
	 Bourne shell style, then add a quoted null argument. */
      else if (!sh_style_split && !ifs_whitespace (string[sindex]))
	{
	  t = alloc_word_desc ();
	  t->word = make_quoted_char ('\0');
	  t->flags |= W_QUOTED|W_HASQUOTEDNULL;
	  result = make_word_list (t, result);
	}

      if (free_word)
	free (current_word);

      /* Note whether or not the separator is IFS whitespace, used later. */
      whitesep = string[sindex] && ifs_whitesep (string[sindex]);

      /* Move past the current separator character. */
      if (string[sindex])
	{
	  DECLARE_MBSTATE;
	  ADVANCE_CHAR (string, slen, sindex);
	}

      /* Now skip sequences of whitespace characters if they are
	 in the list of separators. */
      while (string[sindex] && ifs_whitesep (string[sindex]) && issep (string[sindex]))
	sindex++;

      /* If the first separator was IFS whitespace and the current character
	 is a non-whitespace IFS character, it should be part of the current
	 field delimiter, not a separate delimiter that would result in an
	 empty field.  Look at POSIX.2, 3.6.5, (3)(b). */
      if (string[sindex] && whitesep && issep (string[sindex]) && !ifs_whitesep (string[sindex]))
	{
	  sindex++;
	  /* An IFS character that is not IFS white space, along with any
	     adjacent IFS white space, shall delimit a field. (SUSv3) */
	  while (string[sindex] && ifs_whitesep (string[sindex]) && isifs (string[sindex]))
	    sindex++;
	}
    }
  return (REVERSE_LIST (result, WORD_LIST *));
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:2,797
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:2,947
parsing error 
{
  register char *s;
  char *current_word;
  int sindex, sh_style_split, whitesep, xflags;
  unsigned char local_cmap[UCHAR_MAX+1];	/* really only need single-byte chars here */
  size_t slen;

  if (!stringp || !*stringp || !**stringp)
    return ((char *)NULL);

  sh_style_split = separators && separators[0] == ' ' &&
				 separators[1] == '\t' &&
				 separators[2] == '\n' &&
				 separators[3] == '\0';
  memset (local_cmap, '\0', sizeof (local_cmap));
  for (xflags = 0, s = separators; s && *s; s++)
    {
      if (*s == CTLESC) xflags |= SX_NOCTLESC;
      if (*s == CTLNUL) xflags |= SX_NOESCCTLNUL;
      local_cmap[(unsigned char)*s] = 1;	/* local charmap of separators */
    }

  s = *stringp;
  slen = 0;

  /* Remove sequences of whitespace at the beginning of STRING, as
     long as those characters appear in SEPARATORS.  This happens if
     SEPARATORS == $' \t\n' or if IFS is unset. */
  if (sh_style_split || separators == 0)
    for (; *s && spctabnl (*s) && islocalsep (*s); s++);
  else
    for (; *s && ifs_whitespace (*s) && islocalsep (*s); s++);

  /* If the string is nothing but whitespace, update it and return. */
  if (!*s)
    {
      *stringp = s;
      if (endptr)
	*endptr = s;
      return ((char *)NULL);
    }

  /* OK, S points to a word that does not begin with white space.
     Now extract a word, stopping at a separator, save a pointer to
     the first character after the word, then skip sequences of spc,
     tab, or nl as long as they are separators.

     This obeys the field splitting rules in Posix.2. */
  sindex = 0;
  /* Don't need string length in ADVANCE_CHAR unless multibyte chars are
     possible, but need it in string_extract_verbatim for bounds checking */
  slen = STRLEN (s);
  current_word = string_extract_verbatim (s, slen, &sindex, separators, xflags);

  /* Set ENDPTR to the first character after the end of the word. */
  if (endptr)
    *endptr = s + sindex;

  /* Note whether or not the separator is IFS whitespace, used later. */
  whitesep = s[sindex] && ifs_whitesep (s[sindex]);

  /* Move past the current separator character. */
  if (s[sindex])
    {
      DECLARE_MBSTATE;
      ADVANCE_CHAR (s, slen, sindex);
    }

  /* Now skip sequences of space, tab, or newline characters if they are
     in the list of separators. */
  while (s[sindex] && spctabnl (s[sindex]) && islocalsep (s[sindex]))
    sindex++;

  /* If the first separator was IFS whitespace and the current character is
     a non-whitespace IFS character, it should be part of the current field
     delimiter, not a separate delimiter that would result in an empty field.
     Look at POSIX.2, 3.6.5, (3)(b). */
  if (s[sindex] && whitesep && islocalsep (s[sindex]) && !ifs_whitesep (s[sindex]))
    {
      sindex++;
      /* An IFS character that is not IFS white space, along with any adjacent
	 IFS white space, shall delimit a field. */
      while (s[sindex] && ifs_whitesep (s[sindex]) && islocalsep(s[sindex]))
	sindex++;
    }

  /* Update STRING to point to the next field. */
  *stringp = s + sindex;
  return (current_word);
}
warning: parse error {
  register char *s;
  char *current_word;
  int sindex, sh_style_split, whitesep, xflags;
  unsigned char local_cmap[UCHAR_MAX+1];	/* really only need single-byte chars here */
  size_t slen;

  if (!stringp || !*stringp || !**stringp)
    return ((char *)NULL);

  sh_style_split = separators && separators[0] == ' ' &&
				 separators[1] == '\t' &&
				 separators[2] == '\n' &&
				 separators[3] == '\0';
  memset (local_cmap, '\0', sizeof (local_cmap));
  for (xflags = 0, s = separators; s && *s; s++)
    {
      if (*s == CTLESC) xflags |= SX_NOCTLESC;
      if (*s == CTLNUL) xflags |= SX_NOESCCTLNUL;
      local_cmap[(unsigned char)*s] = 1;	/* local charmap of separators */
    }

  s = *stringp;
  slen = 0;

  /* Remove sequences of whitespace at the beginning of STRING, as
     long as those characters appear in SEPARATORS.  This happens if
     SEPARATORS == $' \t\n' or if IFS is unset. */
  if (sh_style_split || separators == 0)
    for (; *s && spctabnl (*s) && islocalsep (*s); s++);
  else
    for (; *s && ifs_whitespace (*s) && islocalsep (*s); s++);

  /* If the string is nothing but whitespace, update it and return. */
  if (!*s)
    {
      *stringp = s;
      if (endptr)
	*endptr = s;
      return ((char *)NULL);
    }

  /* OK, S points to a word that does not begin with white space.
     Now extract a word, stopping at a separator, save a pointer to
     the first character after the word, then skip sequences of spc,
     tab, or nl as long as they are separators.

     This obeys the field splitting rules in Posix.2. */
  sindex = 0;
  /* Don't need string length in ADVANCE_CHAR unless multibyte chars are
     possible, but need it in string_extract_verbatim for bounds checking */
  slen = STRLEN (s);
  current_word = string_extract_verbatim (s, slen, &sindex, separators, xflags);

  /* Set ENDPTR to the first character after the end of the word. */
  if (endptr)
    *endptr = s + sindex;

  /* Note whether or not the separator is IFS whitespace, used later. */
  whitesep = s[sindex] && ifs_whitesep (s[sindex]);

  /* Move past the current separator character. */
  if (s[sindex])
    {
      DECLARE_MBSTATE;
      ADVANCE_CHAR (s, slen, sindex);
    }

  /* Now skip sequences of space, tab, or newline characters if they are
     in the list of separators. */
  while (s[sindex] && spctabnl (s[sindex]) && islocalsep (s[sindex]))
    sindex++;

  /* If the first separator was IFS whitespace and the current character is
     a non-whitespace IFS character, it should be part of the current field
     delimiter, not a separate delimiter that would result in an empty field.
     Look at POSIX.2, 3.6.5, (3)(b). */
  if (s[sindex] && whitesep && islocalsep (s[sindex]) && !ifs_whitesep (s[sindex]))
    {
      sindex++;
      /* An IFS character that is not IFS white space, along with any adjacent
	 IFS white space, shall delimit a field. */
      while (s[sindex] && ifs_whitesep (s[sindex]) && islocalsep(s[sindex]))
	sindex++;
    }

  /* Update STRING to point to the next field. */
  *stringp = s + sindex;
  return (current_word);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:2,949
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:3,046
parsing error 
{
  char *s;

  s = string + STRLEN (string) - 1;
  while (s > string && ((spctabnl (*s) && isifs (*s)) ||
			(saw_escape && *s == CTLESC && spctabnl (s[1]))))
    s--;
  *++s = '\0';
  return string;
}
warning: parse error {
  char *s;

  s = string + STRLEN (string) - 1;
  while (s > string && ((spctabnl (*s) && isifs (*s)) ||
			(saw_escape && *s == CTLESC && spctabnl (s[1]))))
    s--;
  *++s = '\0';
  return string;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:3,049
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:3,210
parsing error 
{
  int offset, appendop, assign_list, aflags, retval;
  char *name, *value, *temp;
  SHELL_VAR *entry;
#if defined (ARRAY_VARS)
  char *t;
  int ni;
#endif
  const char *string;

  if (word == 0 || word->word == 0)
    return 0;

  appendop = assign_list = aflags = 0;
  string = word->word;
  offset = assignment (string, 0);
  name = savestring (string);
  value = (char *)NULL;

  if (name[offset] == '=')
    {
      if (name[offset - 1] == '+')
	{
	  appendop = 1;
	  name[offset - 1] = '\0';
	}

      name[offset] = 0;		/* might need this set later */
      temp = name + offset + 1;

#if defined (ARRAY_VARS)
      if (expand && (word->flags & W_COMPASSIGN))
	{
	  assign_list = ni = 1;
	  value = extract_array_assignment_list (temp, &ni);
	}
      else
#endif
      if (expand && temp[0])
	value = expand_string_if_necessary (temp, 0, expand_string_assignment);
      else
	value = savestring (temp);
    }

  if (value == 0)
    {
      value = (char *)xmalloc (1);
      value[0] = '\0';
    }

  if (echo_command_at_execute)
    {
      if (appendop)
	name[offset - 1] = '+';
      xtrace_print_assignment (name, value, assign_list, 1);
      if (appendop)
	name[offset - 1] = '\0';
    }

#define ASSIGN_RETURN(r)	do { FREE (value); free (name); return (r); } while (0)

  if (appendop)
    aflags |= ASS_APPEND;

#if defined (ARRAY_VARS)
  if (t = mbschr (name, LBRACK))
    {
      if (assign_list)
	{
	  report_error (_("%s: cannot assign list to array member"), name);
	  ASSIGN_RETURN (0);
	}
      entry = assign_array_element (name, value, aflags);
      if (entry == 0)
	ASSIGN_RETURN (0);
    }
  else if (assign_list)
    {
      if ((word->flags & W_ASSIGNARG) && (word->flags & W_CHKLOCAL))
	aflags |= ASS_CHKLOCAL;
      if ((word->flags & W_ASSIGNARG) && (word->flags & W_ASSNGLOBAL) == 0)
	aflags |= ASS_MKLOCAL;
      if ((word->flags & W_ASSIGNARG) && (word->flags & W_ASSNGLOBAL))
	aflags |= ASS_MKGLOBAL;
      if (word->flags & W_ASSIGNASSOC)
	aflags |= ASS_MKASSOC;
      entry = do_compound_assignment (name, value, aflags);
    }
  else
#endif /* ARRAY_VARS */
  entry = bind_variable (name, value, aflags);

  if (entry)
    stupidly_hack_special_variables (entry->name);	/* might be a nameref */
  else
    stupidly_hack_special_variables (name);

  /* Return 1 if the assignment seems to have been performed correctly. */
  if (entry == 0 || readonly_p (entry))
    retval = 0;		/* assignment failure */
  else if (noassign_p (entry))
    {
      set_exit_status (EXECUTION_FAILURE);
      retval = 1;	/* error status, but not assignment failure */
    }
  else
    retval = 1;

  if (entry && retval != 0 && noassign_p (entry) == 0)
    VUNSETATTR (entry, att_invisible);

  ASSIGN_RETURN (retval);
}
warning: parse error {
  int offset, appendop, assign_list, aflags, retval;
  char *name, *value, *temp;
  SHELL_VAR *entry;
#if defined (ARRAY_VARS)
  char *t;
  int ni;
#endif
  const char *string;

  if (word == 0 || word->word == 0)
    return 0;

  appendop = assign_list = aflags = 0;
  string = word->word;
  offset = assignment (string, 0);
  name = savestring (string);
  value = (char *)NULL;

  if (name[offset] == '=')
    {
      if (name[offset - 1] == '+')
	{
	  appendop = 1;
	  name[offset - 1] = '\0';
	}

      name[offset] = 0;		/* might need this set later */
      temp = name + offset + 1;

#if defined (ARRAY_VARS)
      if (expand && (word->flags & W_COMPASSIGN))
	{
	  assign_list = ni = 1;
	  value = extract_array_assignment_list (temp, &ni);
	}
      else
#endif
      if (expand && temp[0])
	value = expand_string_if_necessary (temp, 0, expand_string_assignment);
      else
	value = savestring (temp);
    }

  if (value == 0)
    {
      value = (char *)xmalloc (1);
      value[0] = '\0';
    }

  if (echo_command_at_execute)
    {
      if (appendop)
	name[offset - 1] = '+';
      xtrace_print_assignment (name, value, assign_list, 1);
      if (appendop)
	name[offset - 1] = '\0';
    }

#define ASSIGN_RETURN(r)	do { FREE (value); free (name); return (r); } while (0)

  if (appendop)
    aflags |= ASS_APPEND;

#if defined (ARRAY_VARS)
  if (t = mbschr (name, LBRACK))
    {
      if (assign_list)
	{
	  report_error (_("%s: cannot assign list to array member"), name);
	  ASSIGN_RETURN (0);
	}
      entry = assign_array_element (name, value, aflags);
      if (entry == 0)
	ASSIGN_RETURN (0);
    }
  else if (assign_list)
    {
      if ((word->flags & W_ASSIGNARG) && (word->flags & W_CHKLOCAL))
	aflags |= ASS_CHKLOCAL;
      if ((word->flags & W_ASSIGNARG) && (word->flags & W_ASSNGLOBAL) == 0)
	aflags |= ASS_MKLOCAL;
      if ((word->flags & W_ASSIGNARG) && (word->flags & W_ASSNGLOBAL))
	aflags |= ASS_MKGLOBAL;
      if (word->flags & W_ASSIGNASSOC)
	aflags |= ASS_MKASSOC;
      entry = do_compound_assignment (name, value, aflags);
    }
  else
#endif /* ARRAY_VARS */
  entry = bind_variable (name, value, aflags);

  if (entry)
    stupidly_hack_special_variables (entry->name);	/* might be a nameref */
  else
    stupidly_hack_special_variables (name);

  /* Return 1 if the assignment seems to have been performed correctly. */
  if (entry == 0 || readonly_p (entry))
    retval = 0;		/* assignment failure */
  else if (noassign_p (entry))
    {
      set_exit_status (EXECUTION_FAILURE);
      retval = 1;	/* error status, but not assignment failure */
    }
  else
    retval = 1;

  if (entry && retval != 0 && noassign_p (entry) == 0)
    VUNSETATTR (entry, att_invisible);

  ASSIGN_RETURN (retval);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:3,212
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:3,329
parsing error 
{
  WORD_DESC td;

  td.flags = W_ASSIGNMENT;
  td.word = string;

  return do_assignment_internal (&td, 1);
}
warning: parse error {
  WORD_DESC td;

  td.flags = W_ASSIGNMENT;
  td.word = string;

  return do_assignment_internal (&td, 1);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:3,331
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:3,341
parsing error 
{
  return do_assignment_internal (word, 1);
}
warning: parse error {
  return do_assignment_internal (word, 1);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:3,344
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:3,352
parsing error 
{
  WORD_DESC td;

  td.flags = W_ASSIGNMENT;
  td.word = string;

  return (do_assignment_internal (&td, 0));
}
warning: parse error {
  WORD_DESC td;

  td.flags = W_ASSIGNMENT;
  td.word = string;

  return (do_assignment_internal (&td, 0));
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:3,354
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:3,388
parsing error 
{
  char *temp;
  WORD_LIST *p;

  if (ind < 10)
    temp = dollar_vars[ind] ? savestring (dollar_vars[ind]) : (char *)NULL;
  else	/* We want something like ${11} */
    {
      ind -= 10;
      for (p = rest_of_args; p && ind--; p = p->next)
	;
      temp = p ? savestring (p->word->word) : (char *)NULL;
    }
  return (temp);
}
warning: parse error {
  char *temp;
  WORD_LIST *p;

  if (ind < 10)
    temp = dollar_vars[ind] ? savestring (dollar_vars[ind]) : (char *)NULL;
  else	/* We want something like ${11} */
    {
      ind -= 10;
      for (p = rest_of_args; p && ind--; p = p->next)
	;
      temp = p ? savestring (p->word->word) : (char *)NULL;
    }
  return (temp);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:3,390
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:3,410
parsing error 
{
  register WORD_LIST *list;
  char *string;

  list = list_rest_of_args ();
  string = dollar_star ? string_list_dollar_star (list, 0, 0) : string_list (list);
  dispose_words (list);
  return (string);
}
warning: parse error {
  register WORD_LIST *list;
  char *string;

  list = list_rest_of_args ();
  string = dollar_star ? string_list_dollar_star (list, 0, 0) : string_list (list);
  dispose_words (list);
  return (string);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:3,412
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:3,428
parsing error 
{
  WORD_LIST *save, *params, *h, *t;
  char *ret;
  int i;

  /* see if we can short-circuit.  if start == end, we want 0 parameters. */
  if (start == end)
    return ((char *)NULL);

  save = params = list_rest_of_args ();
  if (save == 0 && start > 0)
    return ((char *)NULL);

  if (start == 0)		/* handle ${@:0[:x]} specially */
    {
      t = make_word_list (make_word (dollar_vars[0]), params);
      save = params = t;
    }

  for (i = start ? 1 : 0; params && i < start; i++)
    params = params->next;
  if (params == 0)
    {
      dispose_words (save);
      return ((char *)NULL);
    }
  for (h = t = params; params && i < end; i++)
    {
      t = params;
      params = params->next;
    }
  t->next = (WORD_LIST *)NULL;

  ret = string_list_pos_params (string[0], h, quoted, pflags);

  if (t != params)
    t->next = params;

  dispose_words (save);
  return (ret);
}
warning: parse error {
  WORD_LIST *save, *params, *h, *t;
  char *ret;
  int i;

  /* see if we can short-circuit.  if start == end, we want 0 parameters. */
  if (start == end)
    return ((char *)NULL);

  save = params = list_rest_of_args ();
  if (save == 0 && start > 0)
    return ((char *)NULL);

  if (start == 0)		/* handle ${@:0[:x]} specially */
    {
      t = make_word_list (make_word (dollar_vars[0]), params);
      save = params = t;
    }

  for (i = start ? 1 : 0; params && i < start; i++)
    params = params->next;
  if (params == 0)
    {
      dispose_words (save);
      return ((char *)NULL);
    }
  for (h = t = params; params && i < end; i++)
    {
      t = params;
      params = params->next;
    }
  t->next = (WORD_LIST *)NULL;

  ret = string_list_pos_params (string[0], h, quoted, pflags);

  if (t != params)
    t->next = params;

  dispose_words (save);
  return (ret);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:3,431
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:3,489
parsing error 
{
  WORD_LIST *list;
  size_t slen;
  int i, saw_quote;
  char *ret;
  DECLARE_MBSTATE;

  /* Don't need string length for ADVANCE_CHAR unless multibyte chars possible. */
  slen = (MB_CUR_MAX > 1) ? strlen (string) : 0;
  i = saw_quote = 0;
  while (string[i])
    {
      if (EXP_CHAR (string[i]))
	break;
      else if (string[i] == '\'' || string[i] == '\\' || string[i] == '"')
	saw_quote = 1;
      ADVANCE_CHAR (string, slen, i);
    }

  if (string[i])
    {
      list = (*func) (string, quoted);
      if (list)
	{
	  ret = string_list (list);
	  dispose_words (list);
	}
      else
	ret = (char *)NULL;
    }
  else if (saw_quote && ((quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)) == 0))
    ret = string_quote_removal (string, quoted);
  else
    ret = savestring (string);

  return ret;
}
warning: parse error {
  WORD_LIST *list;
  size_t slen;
  int i, saw_quote;
  char *ret;
  DECLARE_MBSTATE;

  /* Don't need string length for ADVANCE_CHAR unless multibyte chars possible. */
  slen = (MB_CUR_MAX > 1) ? strlen (string) : 0;
  i = saw_quote = 0;
  while (string[i])
    {
      if (EXP_CHAR (string[i]))
	break;
      else if (string[i] == '\'' || string[i] == '\\' || string[i] == '"')
	saw_quote = 1;
      ADVANCE_CHAR (string, slen, i);
    }

  if (string[i])
    {
      list = (*func) (string, quoted);
      if (list)
	{
	  ret = string_list (list);
	  dispose_words (list);
	}
      else
	ret = (char *)NULL;
    }
  else if (saw_quote && ((quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)) == 0))
    ret = string_quote_removal (string, quoted);
  else
    ret = savestring (string);

  return ret;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:3,493
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:3,532
parsing error 
{
  WORD_LIST *list;
  char *ret;

  if (string == 0 || *string == '\0')
    return ((char *)NULL);

  list = (*func) (string, quoted);
  if (list)
    {
      ret = string_list (list);
      dispose_words (list);
    }
  else
    ret = (char *)NULL;

  return (ret);
}
warning: parse error {
  WORD_LIST *list;
  char *ret;

  if (string == 0 || *string == '\0')
    return ((char *)NULL);

  list = (*func) (string, quoted);
  if (list)
    {
      ret = string_list (list);
      dispose_words (list);
    }
  else
    ret = (char *)NULL;

  return (ret);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:3,536
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:3,556
parsing error 
{
  return (expand_string_to_string_internal (string, quoted, expand_string));
}
warning: parse error {
  return (expand_string_to_string_internal (string, quoted, expand_string));
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:3,559
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:3,564
parsing error 
{
  return (expand_string_to_string_internal (string, quoted, expand_string_unsplit));
}
warning: parse error {
  return (expand_string_to_string_internal (string, quoted, expand_string_unsplit));
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:3,567
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:3,572
parsing error 
{
  return (expand_string_to_string_internal (string, quoted, expand_string_assignment));
}
warning: parse error {
  return (expand_string_to_string_internal (string, quoted, expand_string_assignment));
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:3,575
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:3,580
parsing error 
{
  WORD_DESC td;
  WORD_LIST *list, *tlist;
  size_t slen;
  int i, saw_quote;
  char *ret;
  DECLARE_MBSTATE;

  /* Don't need string length for ADVANCE_CHAR unless multibyte chars possible. */
  slen = (MB_CUR_MAX > 1) ? strlen (string) : 0;
  i = saw_quote = 0;
  while (string[i])
    {
      if (EXP_CHAR (string[i]))
	break;
      else if (string[i] == '\'' || string[i] == '\\' || string[i] == '"')
	saw_quote = 1;
      ADVANCE_CHAR (string, slen, i);
    }

  if (string[i])
    {
      /* This is expanded version of expand_string_internal as it's called by
	 expand_string_leave_quoted  */
      td.flags = W_NOPROCSUB|W_NOTILDE;	/* don't want process substitution or tilde expansion */
#if 0	/* TAG: bash-5.2 */
      if (quoted & Q_ARRAYSUB)
	td.flags |= W_NOCOMSUB;
#endif
      td.word = savestring (string);
      list = call_expand_word_internal (&td, quoted, 0, (int *)NULL, (int *)NULL);
      /* This takes care of the calls from expand_string_leave_quoted and
	 expand_string */
      if (list)
	{
	  tlist = word_list_split (list);
	  dispose_words (list);
	  list = tlist;
	  if (list)
	    dequote_list (list);
	}
      /* This comes from expand_string_if_necessary */
      if (list)
	{
	  ret = string_list (list);
	  dispose_words (list);
	}
      else
	ret = (char *)NULL;
      FREE (td.word);
    }
  else if (saw_quote && (quoted & Q_ARITH))
    ret = string_quote_removal (string, quoted);
  else if (saw_quote && ((quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)) == 0))
    ret = string_quote_removal (string, quoted);
  else
    ret = savestring (string);

  return ret;
}
warning: parse error {
  WORD_DESC td;
  WORD_LIST *list, *tlist;
  size_t slen;
  int i, saw_quote;
  char *ret;
  DECLARE_MBSTATE;

  /* Don't need string length for ADVANCE_CHAR unless multibyte chars possible. */
  slen = (MB_CUR_MAX > 1) ? strlen (string) : 0;
  i = saw_quote = 0;
  while (string[i])
    {
      if (EXP_CHAR (string[i]))
	break;
      else if (string[i] == '\'' || string[i] == '\\' || string[i] == '"')
	saw_quote = 1;
      ADVANCE_CHAR (string, slen, i);
    }

  if (string[i])
    {
      /* This is expanded version of expand_string_internal as it's called by
	 expand_string_leave_quoted  */
      td.flags = W_NOPROCSUB|W_NOTILDE;	/* don't want process substitution or tilde expansion */
#if 0	/* TAG: bash-5.2 */
      if (quoted & Q_ARRAYSUB)
	td.flags |= W_NOCOMSUB;
#endif
      td.word = savestring (string);
      list = call_expand_word_internal (&td, quoted, 0, (int *)NULL, (int *)NULL);
      /* This takes care of the calls from expand_string_leave_quoted and
	 expand_string */
      if (list)
	{
	  tlist = word_list_split (list);
	  dispose_words (list);
	  list = tlist;
	  if (list)
	    dequote_list (list);
	}
      /* This comes from expand_string_if_necessary */
      if (list)
	{
	  ret = string_list (list);
	  dispose_words (list);
	}
      else
	ret = (char *)NULL;
      FREE (td.word);
    }
  else if (saw_quote && (quoted & Q_ARITH))
    ret = string_quote_removal (string, quoted);
  else if (saw_quote && ((quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)) == 0))
    ret = string_quote_removal (string, quoted);
  else
    ret = savestring (string);

  return ret;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:3,583
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:3,726
parsing error 
{
  WORD_LIST *result;

  result = expand_word_internal (w, q, i, c, e);
  if (result == &expand_word_error || result == &expand_word_fatal)
    {
      /* By convention, each time this error is returned, w->word has
	 already been freed (it sometimes may not be in the fatal case,
	 but that doesn't result in a memory leak because we're going
	 to exit in most cases). */
      w->word = (char *)NULL;
      last_command_exit_value = EXECUTION_FAILURE;
      exp_jump_to_top_level ((result == &expand_word_error) ? DISCARD : FORCE_EOF);
      /* NOTREACHED */
      return (NULL);
    }
  else
    return (result);
}
warning: parse error {
  WORD_LIST *result;

  result = expand_word_internal (w, q, i, c, e);
  if (result == &expand_word_error || result == &expand_word_fatal)
    {
      /* By convention, each time this error is returned, w->word has
	 already been freed (it sometimes may not be in the fatal case,
	 but that doesn't result in a memory leak because we're going
	 to exit in most cases). */
      w->word = (char *)NULL;
      last_command_exit_value = EXECUTION_FAILURE;
      exp_jump_to_top_level ((result == &expand_word_error) ? DISCARD : FORCE_EOF);
      /* NOTREACHED */
      return (NULL);
    }
  else
    return (result);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:3,729
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:3,754
parsing error 
{
  WORD_DESC td;
  WORD_LIST *tresult;

  if (string == 0 || *string == 0)
    return ((WORD_LIST *)NULL);

  td.flags = 0;
  td.word = savestring (string);

  tresult = call_expand_word_internal (&td, quoted, 0, (int *)NULL, (int *)NULL);

  FREE (td.word);
  return (tresult);
}
warning: parse error {
  WORD_DESC td;
  WORD_LIST *tresult;

  if (string == 0 || *string == 0)
    return ((WORD_LIST *)NULL);

  td.flags = 0;
  td.word = savestring (string);

  tresult = call_expand_word_internal (&td, quoted, 0, (int *)NULL, (int *)NULL);

  FREE (td.word);
  return (tresult);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:3,757
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:3,779
parsing error 
{
  WORD_LIST *value;

  if (string == 0 || *string == '\0')
    return ((WORD_LIST *)NULL);

  expand_no_split_dollar_star = 1;
  value = expand_string_internal (string, quoted);
  expand_no_split_dollar_star = 0;

  if (value)
    {
      if (value->word)
	{
	  remove_quoted_nulls (value->word->word);	/* XXX */
	  value->word->flags &= ~W_HASQUOTEDNULL;
	}
      dequote_list (value);
    }
  return (value);
}
warning: parse error {
  WORD_LIST *value;

  if (string == 0 || *string == '\0')
    return ((WORD_LIST *)NULL);

  expand_no_split_dollar_star = 1;
  value = expand_string_internal (string, quoted);
  expand_no_split_dollar_star = 0;

  if (value)
    {
      if (value->word)
	{
	  remove_quoted_nulls (value->word->word);	/* XXX */
	  value->word->flags &= ~W_HASQUOTEDNULL;
	}
      dequote_list (value);
    }
  return (value);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:3,782
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:3,806
parsing error 
{
  WORD_DESC td;
  WORD_LIST *value;

  if (string == 0 || *string == '\0')
    return ((WORD_LIST *)NULL);

  expand_no_split_dollar_star = 1;

#if 0
  /* Other shells (ksh93) do it this way, which affects how $@ is expanded
     in constructs like bar=${@#0} (preserves the spaces resulting from the
     expansion of $@ in a context where you don't do word splitting); Posix
     interp 888 makes the expansion of $@ in contexts where word splitting
     is not performed unspecified. */
  td.flags = W_ASSIGNRHS|W_NOSPLIT2;		/* Posix interp 888 */
#else
  td.flags = W_ASSIGNRHS;
#endif
  td.word = savestring (string);
  value = call_expand_word_internal (&td, quoted, 0, (int *)NULL, (int *)NULL);
  FREE (td.word);

  expand_no_split_dollar_star = 0;

  if (value)
    {
      if (value->word)
	{
	  remove_quoted_nulls (value->word->word);	/* XXX */
	  value->word->flags &= ~W_HASQUOTEDNULL;
	}
      dequote_list (value);
    }
  return (value);
}
warning: parse error {
  WORD_DESC td;
  WORD_LIST *value;

  if (string == 0 || *string == '\0')
    return ((WORD_LIST *)NULL);

  expand_no_split_dollar_star = 1;

#if 0
  /* Other shells (ksh93) do it this way, which affects how $@ is expanded
     in constructs like bar=${@#0} (preserves the spaces resulting from the
     expansion of $@ in a context where you don't do word splitting); Posix
     interp 888 makes the expansion of $@ in contexts where word splitting
     is not performed unspecified. */
  td.flags = W_ASSIGNRHS|W_NOSPLIT2;		/* Posix interp 888 */
#else
  td.flags = W_ASSIGNRHS;
#endif
  td.word = savestring (string);
  value = call_expand_word_internal (&td, quoted, 0, (int *)NULL, (int *)NULL);
  FREE (td.word);

  expand_no_split_dollar_star = 0;

  if (value)
    {
      if (value->word)
	{
	  remove_quoted_nulls (value->word->word);	/* XXX */
	  value->word->flags &= ~W_HASQUOTEDNULL;
	}
      dequote_list (value);
    }
  return (value);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:3,809
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:3,852
parsing error 
{
  WORD_LIST *value;
  WORD_DESC td;

  if (string == 0 || *string == 0)
    return ((WORD_LIST *)NULL);

  td.flags = wflags;
  td.word = savestring (string);

  no_longjmp_on_fatal_error = 1;
  value = expand_word_internal (&td, quoted, 0, (int *)NULL, (int *)NULL);
  no_longjmp_on_fatal_error = 0;

  if (value == &expand_word_error || value == &expand_word_fatal)
    {
      value = make_word_list (make_bare_word (string), (WORD_LIST *)NULL);
      return value;
    }
  FREE (td.word);
  if (value)
    {
      if (value->word)
	{
	  remove_quoted_nulls (value->word->word);	/* XXX */
	  value->word->flags &= ~W_HASQUOTEDNULL;
	}
      dequote_list (value);
    }
  return (value);
}
warning: parse error {
  WORD_LIST *value;
  WORD_DESC td;

  if (string == 0 || *string == 0)
    return ((WORD_LIST *)NULL);

  td.flags = wflags;
  td.word = savestring (string);

  no_longjmp_on_fatal_error = 1;
  value = expand_word_internal (&td, quoted, 0, (int *)NULL, (int *)NULL);
  no_longjmp_on_fatal_error = 0;

  if (value == &expand_word_error || value == &expand_word_fatal)
    {
      value = make_word_list (make_bare_word (string), (WORD_LIST *)NULL);
      return value;
    }
  FREE (td.word);
  if (value)
    {
      if (value->word)
	{
	  remove_quoted_nulls (value->word->word);	/* XXX */
	  value->word->flags &= ~W_HASQUOTEDNULL;
	}
      dequote_list (value);
    }
  return (value);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:3,856
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:3,894
parsing error 
{
  WORD_LIST *tlist;
  WORD_LIST *tresult;

  if (string == 0 || *string == '\0')
    return ((WORD_LIST *)NULL);

  tlist = expand_string_internal (string, quoted);

  if (tlist)
    {
      tresult = word_list_split (tlist);
      dispose_words (tlist);
      return (tresult);
    }
  return ((WORD_LIST *)NULL);
}
warning: parse error {
  WORD_LIST *tlist;
  WORD_LIST *tresult;

  if (string == 0 || *string == '\0')
    return ((WORD_LIST *)NULL);

  tlist = expand_string_internal (string, quoted);

  if (tlist)
    {
      tresult = word_list_split (tlist);
      dispose_words (tlist);
      return (tresult);
    }
  return ((WORD_LIST *)NULL);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:3,897
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:3,918
parsing error 
{
  WORD_DESC td;
  WORD_LIST *tresult;
  int old_nosplit;

  if (string == 0 || *string == '\0')
    return (WORD_LIST *)NULL;

  /* We want field splitting to be determined by what is going to be done with
     the entire ${parameterOPword} expansion, so we don't want to split the RHS
     we expand here.  However, the expansion of $* is determined by whether we
     are going to eventually perform word splitting, so we want to set this
     depending on whether or not are are going to be splitting: if the expansion
     is quoted, if the OP is `=', or if IFS is set to the empty string, we
     are not going to be splitting, so we set expand_no_split_dollar_star to
     note this to callees.
     We pass through PF_ASSIGNRHS as W_ASSIGNRHS if this is on the RHS of an
     assignment statement. */
  /* The updated treatment of $* is the result of Posix interp 888 */
  /* This was further clarified on the austin-group list in March, 2017 and
     in Posix bug 1129 */
  old_nosplit = expand_no_split_dollar_star;
  expand_no_split_dollar_star = (quoted & (Q_DOUBLE_QUOTES|Q_HERE_DOCUMENT)) || op == '=' || ifs_is_null == 0;	/* XXX - was 1 */
  td.flags = W_EXPANDRHS;		/* expanding RHS of ${paramOPword} */
  td.flags |= W_NOSPLIT2;		/* no splitting, remove "" and '' */
  if (pflags & PF_ASSIGNRHS)		/* pass through */
    td.flags |= W_ASSIGNRHS;
  if (op == '=')
#if 0
    td.flags |= W_ASSIGNRHS;		/* expand b in ${a=b} like assignment */
#else
    td.flags |= W_ASSIGNRHS|W_NOASSNTILDE;		/* expand b in ${a=b} like assignment */
#endif
  td.word = string;
  tresult = call_expand_word_internal (&td, quoted, 1, dollar_at_p, expanded_p);
  expand_no_split_dollar_star = old_nosplit;

  return (tresult);
}
warning: parse error {
  WORD_DESC td;
  WORD_LIST *tresult;
  int old_nosplit;

  if (string == 0 || *string == '\0')
    return (WORD_LIST *)NULL;

  /* We want field splitting to be determined by what is going to be done with
     the entire ${parameterOPword} expansion, so we don't want to split the RHS
     we expand here.  However, the expansion of $* is determined by whether we
     are going to eventually perform word splitting, so we want to set this
     depending on whether or not are are going to be splitting: if the expansion
     is quoted, if the OP is `=', or if IFS is set to the empty string, we
     are not going to be splitting, so we set expand_no_split_dollar_star to
     note this to callees.
     We pass through PF_ASSIGNRHS as W_ASSIGNRHS if this is on the RHS of an
     assignment statement. */
  /* The updated treatment of $* is the result of Posix interp 888 */
  /* This was further clarified on the austin-group list in March, 2017 and
     in Posix bug 1129 */
  old_nosplit = expand_no_split_dollar_star;
  expand_no_split_dollar_star = (quoted & (Q_DOUBLE_QUOTES|Q_HERE_DOCUMENT)) || op == '=' || ifs_is_null == 0;	/* XXX - was 1 */
  td.flags = W_EXPANDRHS;		/* expanding RHS of ${paramOPword} */
  td.flags |= W_NOSPLIT2;		/* no splitting, remove "" and '' */
  if (pflags & PF_ASSIGNRHS)		/* pass through */
    td.flags |= W_ASSIGNRHS;
  if (op == '=')
#if 0
    td.flags |= W_ASSIGNRHS;		/* expand b in ${a=b} like assignment */
#else
    td.flags |= W_ASSIGNRHS|W_NOASSNTILDE;		/* expand b in ${a=b} like assignment */
#endif
  td.word = string;
  tresult = call_expand_word_internal (&td, quoted, 1, dollar_at_p, expanded_p);
  expand_no_split_dollar_star = old_nosplit;

  return (tresult);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:3,922
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:3,965
parsing error 
{
  WORD_DESC td;
  WORD_LIST *tresult;
  int oexp;

  if (string == 0 || *string == '\0')
    return (WORD_LIST *)NULL;

  oexp = expand_no_split_dollar_star;
  expand_no_split_dollar_star = 1;
  td.flags = W_NOSPLIT2;		/* no splitting, remove "" and '' */
  td.word = string;
  tresult = call_expand_word_internal (&td, quoted, 1, dollar_at_p, expanded_p);
  expand_no_split_dollar_star = oexp;

  return (tresult);
}
warning: parse error {
  WORD_DESC td;
  WORD_LIST *tresult;
  int oexp;

  if (string == 0 || *string == '\0')
    return (WORD_LIST *)NULL;

  oexp = expand_no_split_dollar_star;
  expand_no_split_dollar_star = 1;
  td.flags = W_NOSPLIT2;		/* no splitting, remove "" and '' */
  td.word = string;
  tresult = call_expand_word_internal (&td, quoted, 1, dollar_at_p, expanded_p);
  expand_no_split_dollar_star = oexp;

  return (tresult);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:3,968
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:3,992
parsing error 
{
  WORD_LIST *result;

  if (string == 0 || *string == '\0')
    return ((WORD_LIST *)NULL);

  result = expand_string_leave_quoted (string, quoted);
  return (result ? dequote_list (result) : result);
}
warning: parse error {
  WORD_LIST *result;

  if (string == 0 || *string == '\0')
    return ((WORD_LIST *)NULL);

  result = expand_string_leave_quoted (string, quoted);
  return (result ? dequote_list (result) : result);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:3,995
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:4,016
parsing error 
{
  WORD_LIST *result, *tresult;

  tresult = call_expand_word_internal (word, quoted, 0, (int *)NULL, (int *)NULL);
  result = word_list_split (tresult);
  dispose_words (tresult);
  return (result ? dequote_list (result) : result);
}
warning: parse error {
  WORD_LIST *result, *tresult;

  tresult = call_expand_word_internal (word, quoted, 0, (int *)NULL, (int *)NULL);
  result = word_list_split (tresult);
  dispose_words (tresult);
  return (result ? dequote_list (result) : result);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:4,019
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:4,032
parsing error 
{
  WORD_LIST *result;

  result = expand_word_leave_quoted (word, quoted);
  return (result ? dequote_list (result) : result);
}
warning: parse error {
  WORD_LIST *result;

  result = expand_word_leave_quoted (word, quoted);
  return (result ? dequote_list (result) : result);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:4,035
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:4,046
parsing error 
{
  WORD_LIST *result;

  expand_no_split_dollar_star = 1;
  if (ifs_is_null)
    word->flags |= W_NOSPLIT;
  word->flags |= W_NOSPLIT2;
  result = call_expand_word_internal (word, quoted, 0, (int *)NULL, (int *)NULL);
  expand_no_split_dollar_star = 0;

  return result;
}
warning: parse error {
  WORD_LIST *result;

  expand_no_split_dollar_star = 1;
  if (ifs_is_null)
    word->flags |= W_NOSPLIT;
  word->flags |= W_NOSPLIT2;
  result = call_expand_word_internal (word, quoted, 0, (int *)NULL, (int *)NULL);
  expand_no_split_dollar_star = 0;

  return result;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:4,049
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:4,088
parsing error 
{
  const char *s, *send;
  char *t, *result;
  size_t slen;
  int quote_spaces, skip_ctlesc, skip_ctlnul, nosplit;
  DECLARE_MBSTATE; 

  slen = strlen (string);
  send = string + slen;

  quote_spaces = (ifs_value && *ifs_value == 0);
  nosplit = (flags & PF_NOSPLIT2);

  for (skip_ctlesc = skip_ctlnul = 0, s = ifs_value; s && *s; s++)
    {
      skip_ctlesc |= (nosplit == 0 && *s == CTLESC);
      skip_ctlnul |= (nosplit == 0 && *s == CTLNUL);
    }

  t = result = (char *)xmalloc ((slen * 2) + 1);
  s = string;

  while (*s)
    {
      if ((skip_ctlesc == 0 && *s == CTLESC) || (skip_ctlnul == 0 && *s == CTLNUL) || (quote_spaces && *s == ' '))
	*t++ = CTLESC;
      COPY_CHAR_P (t, s, send);
    }
  *t = '\0';

  return (result);
}
warning: parse error {
  const char *s, *send;
  char *t, *result;
  size_t slen;
  int quote_spaces, skip_ctlesc, skip_ctlnul, nosplit;
  DECLARE_MBSTATE; 

  slen = strlen (string);
  send = string + slen;

  quote_spaces = (ifs_value && *ifs_value == 0);
  nosplit = (flags & PF_NOSPLIT2);

  for (skip_ctlesc = skip_ctlnul = 0, s = ifs_value; s && *s; s++)
    {
      skip_ctlesc |= (nosplit == 0 && *s == CTLESC);
      skip_ctlnul |= (nosplit == 0 && *s == CTLNUL);
    }

  t = result = (char *)xmalloc ((slen * 2) + 1);
  s = string;

  while (*s)
    {
      if ((skip_ctlesc == 0 && *s == CTLESC) || (skip_ctlnul == 0 && *s == CTLNUL) || (quote_spaces && *s == ' '))
	*t++ = CTLESC;
      COPY_CHAR_P (t, s, send);
    }
  *t = '\0';

  return (result);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:4,090
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:4,125
parsing error 
{
  return (quote_escapes_internal (string, 0));
}
warning: parse error {
  return (quote_escapes_internal (string, 0));
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:4,126
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:4,132
parsing error 
{
  return (quote_escapes_internal (string, PF_NOSPLIT2));
}
warning: parse error {
  return (quote_escapes_internal (string, PF_NOSPLIT2));
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:4,133
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:4,138
parsing error 
{
  register WORD_LIST *w;
  char *t;

  for (w = list; w; w = w->next)
    {
      t = w->word->word;
      w->word->word = quote_escapes (t);
      free (t);
    }
  return list;
}
warning: parse error {
  register WORD_LIST *w;
  char *t;

  for (w = list; w; w = w->next)
    {
      t = w->word->word;
      w->word->word = quote_escapes (t);
      free (t);
    }
  return list;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:4,140
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:4,166
parsing error 
{
  const char *s, *send;
  char *t, *result;
  size_t slen;
  int quote_spaces;
  DECLARE_MBSTATE;

  if (string == 0)
    return (char *)0;

  slen = strlen (string);
  send = string + slen;

  t = result = (char *)xmalloc (slen + 1);

  if (strchr (string, CTLESC) == 0)
    return (strcpy (result, string));

  quote_spaces = (ifs_value && *ifs_value == 0);

  s = string;
  while (*s)
    {
      if (*s == CTLESC && (s[1] == CTLESC || s[1] == CTLNUL || (quote_spaces && s[1] == ' ')))
	{
	  s++;
	  if (*s == '\0')
	    break;
	}
      COPY_CHAR_P (t, s, send);
    }
  *t = '\0';

  return result;
}
warning: parse error {
  const char *s, *send;
  char *t, *result;
  size_t slen;
  int quote_spaces;
  DECLARE_MBSTATE;

  if (string == 0)
    return (char *)0;

  slen = strlen (string);
  send = string + slen;

  t = result = (char *)xmalloc (slen + 1);

  if (strchr (string, CTLESC) == 0)
    return (strcpy (result, string));

  quote_spaces = (ifs_value && *ifs_value == 0);

  s = string;
  while (*s)
    {
      if (*s == CTLESC && (s[1] == CTLESC || s[1] == CTLNUL || (quote_spaces && s[1] == ' ')))
	{
	  s++;
	  if (*s == '\0')
	    break;
	}
      COPY_CHAR_P (t, s, send);
    }
  *t = '\0';

  return result;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:4,167
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:4,225
parsing error 
{
  char *temp;

  temp = (char *)xmalloc (3);
  if (c == 0)
    {
      temp[0] = CTLNUL;
      temp[1] = '\0';
    }
  else
    {
      temp[0] = CTLESC;
      temp[1] = c;
      temp[2] = '\0';
    }
  return (temp);
}
warning: parse error {
  char *temp;

  temp = (char *)xmalloc (3);
  if (c == 0)
    {
      temp[0] = CTLNUL;
      temp[1] = '\0';
    }
  else
    {
      temp[0] = CTLESC;
      temp[1] = c;
      temp[2] = '\0';
    }
  return (temp);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:4,227
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:4,249
parsing error 
{
  register char *t;
  size_t slen;
  char *result, *send;

  if (*string == 0)
    {
      result = (char *)xmalloc (2);
      result[0] = CTLNUL;
      result[1] = '\0';
    }
  else
    {
      DECLARE_MBSTATE;

      slen = strlen (string);
      send = string + slen;

      result = (char *)xmalloc ((slen * 2) + 1);

      for (t = result; string < send; )
	{
	  *t++ = CTLESC;
	  COPY_CHAR_P (t, string, send);
	}
      *t = '\0';
    }
  return (result);
}
warning: parse error {
  register char *t;
  size_t slen;
  char *result, *send;

  if (*string == 0)
    {
      result = (char *)xmalloc (2);
      result[0] = CTLNUL;
      result[1] = '\0';
    }
  else
    {
      DECLARE_MBSTATE;

      slen = strlen (string);
      send = string + slen;

      result = (char *)xmalloc ((slen * 2) + 1);

      for (t = result; string < send; )
	{
	  *t++ = CTLESC;
	  COPY_CHAR_P (t, string, send);
	}
      *t = '\0';
    }
  return (result);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:4,251
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:4,283
parsing error 
{
  register char *s, *t;
  size_t slen;
  char *result, *send;
  DECLARE_MBSTATE;

#if defined (DEBUG)
  if (string[0] == CTLESC && string[1] == 0)
    internal_inform ("dequote_string: string with bare CTLESC");
#endif

  slen = STRLEN (string);

  t = result = (char *)xmalloc (slen + 1);

  if (QUOTED_NULL (string))
    {
      result[0] = '\0';
      return (result);
    }

  /* A string consisting of only a single CTLESC should pass through unchanged */
  if (string[0] == CTLESC && string[1] == 0)
    {
      result[0] = CTLESC;
      result[1] = '\0';
      return (result);
    }

  /* If no character in the string can be quoted, don't bother examining
     each character.  Just return a copy of the string passed to us. */
  if (strchr (string, CTLESC) == NULL)
    return (strcpy (result, string));

  send = string + slen;
  s = string;
  while (*s)
    {
      if (*s == CTLESC)
	{
	  s++;
	  if (*s == '\0')
	    break;
	}
      COPY_CHAR_P (t, s, send);
    }

  *t = '\0';
  return (result);
}
warning: parse error {
  register char *s, *t;
  size_t slen;
  char *result, *send;
  DECLARE_MBSTATE;

#if defined (DEBUG)
  if (string[0] == CTLESC && string[1] == 0)
    internal_inform ("dequote_string: string with bare CTLESC");
#endif

  slen = STRLEN (string);

  t = result = (char *)xmalloc (slen + 1);

  if (QUOTED_NULL (string))
    {
      result[0] = '\0';
      return (result);
    }

  /* A string consisting of only a single CTLESC should pass through unchanged */
  if (string[0] == CTLESC && string[1] == 0)
    {
      result[0] = CTLESC;
      result[1] = '\0';
      return (result);
    }

  /* If no character in the string can be quoted, don't bother examining
     each character.  Just return a copy of the string passed to us. */
  if (strchr (string, CTLESC) == NULL)
    return (strcpy (result, string));

  send = string + slen;
  s = string;
  while (*s)
    {
      if (*s == CTLESC)
	{
	  s++;
	  if (*s == '\0')
	    break;
	}
      COPY_CHAR_P (t, s, send);
    }

  *t = '\0';
  return (result);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:4,285
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:4,338
parsing error 
{
  register WORD_LIST *w;
  char *t;

  for (w = list; w; w = w->next)
    {
      t = w->word->word;
      w->word->word = quote_string (t);
      if (*t == 0)
	w->word->flags |= W_HASQUOTEDNULL;	/* XXX - turn on W_HASQUOTEDNULL here? */
      w->word->flags |= W_QUOTED;
      free (t);
    }
  return list;
}
warning: parse error {
  register WORD_LIST *w;
  char *t;

  for (w = list; w; w = w->next)
    {
      t = w->word->word;
      w->word->word = quote_string (t);
      if (*t == 0)
	w->word->flags |= W_HASQUOTEDNULL;	/* XXX - turn on W_HASQUOTEDNULL here? */
      w->word->flags |= W_QUOTED;
      free (t);
    }
  return list;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:4,340
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:4,357
parsing error 
{
  register char *s;

  s = dequote_string (word->word);
  if (QUOTED_NULL (word->word))
    word->flags &= ~W_HASQUOTEDNULL;
  free (word->word);
  word->word = s;

  return word;
}
warning: parse error {
  register char *s;

  s = dequote_string (word->word);
  if (QUOTED_NULL (word->word))
    word->flags &= ~W_HASQUOTEDNULL;
  free (word->word);
  word->word = s;

  return word;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:4,359
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:4,373
parsing error 
{
  register char *s;
  register WORD_LIST *tlist;

  for (tlist = list; tlist; tlist = tlist->next)
    {
      s = dequote_string (tlist->word->word);
      if (QUOTED_NULL (tlist->word->word))
	tlist->word->flags &= ~W_HASQUOTEDNULL;
      free (tlist->word->word);
      tlist->word->word = s;
    }
  return list;
}
warning: parse error {
  register char *s;
  register WORD_LIST *tlist;

  for (tlist = list; tlist; tlist = tlist->next)
    {
      s = dequote_string (tlist->word->word);
      if (QUOTED_NULL (tlist->word->word))
	tlist->word->flags &= ~W_HASQUOTEDNULL;
      free (tlist->word->word);
      tlist->word->word = s;
    }
  return list;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:4,375
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:4,393
parsing error 
{
  char *t;

  if (string)
    {
      t = dequote_escapes (string);
      strcpy (string, t);
      free (t);
    }

  return (string);
}
warning: parse error {
  char *t;

  if (string)
    {
      t = dequote_escapes (string);
      strcpy (string, t);
      free (t);
    }

  return (string);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:4,395
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:4,413
parsing error 
{
  register size_t slen;
  register int i, j;
  char *ret, *send;
  DECLARE_MBSTATE;

  slen = strlen (string);
  send = string + slen;

  i = j = 0;
  ret = (char *)xmalloc (slen + 1);

  while (i < slen)
    {
      if (string[i] == CTLESC)
	{
	  i++;
	  if (string[i] == 0 || isifs (string[i]) == 0)
	    ret[j++] = CTLESC;
	  if (i == slen)
	    break;
	}

      COPY_CHAR_I (ret, j, string, send, i);
    }
  ret[j] = '\0';

  return (ret);
}
warning: parse error {
  register size_t slen;
  register int i, j;
  char *ret, *send;
  DECLARE_MBSTATE;

  slen = strlen (string);
  send = string + slen;

  i = j = 0;
  ret = (char *)xmalloc (slen + 1);

  while (i < slen)
    {
      if (string[i] == CTLESC)
	{
	  i++;
	  if (string[i] == 0 || isifs (string[i]) == 0)
	    ret[j++] = CTLESC;
	  if (i == slen)
	    break;
	}

      COPY_CHAR_I (ret, j, string, send, i);
    }
  ret[j] = '\0';

  return (ret);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:4,415
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:4,446
parsing error 
{
  register size_t slen;
  register int i, j, prev_i;
  DECLARE_MBSTATE;

  if (strchr (string, CTLNUL) == 0)		/* XXX */
    return string;				/* XXX */

  slen = strlen (string);
  i = j = 0;

  while (i < slen)
    {
      if (string[i] == CTLESC)
	{
	  /* Old code had j++, but we cannot assume that i == j at this
	     point -- what if a CTLNUL has already been removed from the
	     string?  We don't want to drop the CTLESC or recopy characters
	     that we've already copied down. */
	  i++;
	  string[j++] = CTLESC;
	  if (i == slen)
	    break;
	}
      else if (string[i] == CTLNUL)
	{
	  i++;
	  continue;
	}

      prev_i = i;
      ADVANCE_CHAR (string, slen, i);		/* COPY_CHAR_I? */
      if (j < prev_i)
	{
	  do string[j++] = string[prev_i++]; while (prev_i < i);
	}
      else
	j = i;
    }
  string[j] = '\0';

  return (string);
}
warning: parse error {
  register size_t slen;
  register int i, j, prev_i;
  DECLARE_MBSTATE;

  if (strchr (string, CTLNUL) == 0)		/* XXX */
    return string;				/* XXX */

  slen = strlen (string);
  i = j = 0;

  while (i < slen)
    {
      if (string[i] == CTLESC)
	{
	  /* Old code had j++, but we cannot assume that i == j at this
	     point -- what if a CTLNUL has already been removed from the
	     string?  We don't want to drop the CTLESC or recopy characters
	     that we've already copied down. */
	  i++;
	  string[j++] = CTLESC;
	  if (i == slen)
	    break;
	}
      else if (string[i] == CTLNUL)
	{
	  i++;
	  continue;
	}

      prev_i = i;
      ADVANCE_CHAR (string, slen, i);		/* COPY_CHAR_I? */
      if (j < prev_i)
	{
	  do string[j++] = string[prev_i++]; while (prev_i < i);
	}
      else
	j = i;
    }
  string[j] = '\0';

  return (string);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:4,448
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:4,495
parsing error 
{
  register WORD_LIST *t;

  for (t = list; t; t = t->next)
    {
      remove_quoted_nulls (t->word->word);
      t->word->flags &= ~W_HASQUOTEDNULL;
    }
}
warning: parse error {
  register WORD_LIST *t;

  for (t = list; t; t = t->next)
    {
      remove_quoted_nulls (t->word->word);
      t->word->flags &= ~W_HASQUOTEDNULL;
    }
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:4,497
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:4,555
parsing error 
{
  register size_t len;
  register char *end;
  register char *p, *ret, c;

  len = STRLEN (param);
  end = param + len;

  switch (op)
    {
      case RP_LONG_LEFT:	/* remove longest match at start */
	for (p = end; p >= param; p--)
	  {
	    c = *p; *p = '\0';
	    if (strmatch (pattern, param, FNMATCH_EXTFLAG) != FNM_NOMATCH)
	      {
		*p = c;
		return (savestring (p));
	      }
	    *p = c;

	  }
	break;

      case RP_SHORT_LEFT:	/* remove shortest match at start */
	for (p = param; p <= end; p++)
	  {
	    c = *p; *p = '\0';
	    if (strmatch (pattern, param, FNMATCH_EXTFLAG) != FNM_NOMATCH)
	      {
		*p = c;
		return (savestring (p));
	      }
	    *p = c;
	  }
	break;

      case RP_LONG_RIGHT:	/* remove longest match at end */
	for (p = param; p <= end; p++)
	  {
	    if (strmatch (pattern, p, FNMATCH_EXTFLAG) != FNM_NOMATCH)
	      {
		c = *p; *p = '\0';
		ret = savestring (param);
		*p = c;
		return (ret);
	      }
	  }
	break;

      case RP_SHORT_RIGHT:	/* remove shortest match at end */
	for (p = end; p >= param; p--)
	  {
	    if (strmatch (pattern, p, FNMATCH_EXTFLAG) != FNM_NOMATCH)
	      {
		c = *p; *p = '\0';
		ret = savestring (param);
		*p = c;
		return (ret);
	      }
	  }
	break;
    }

  return (param);	/* no match, return original string */
}
warning: parse error {
  register size_t len;
  register char *end;
  register char *p, *ret, c;

  len = STRLEN (param);
  end = param + len;

  switch (op)
    {
      case RP_LONG_LEFT:	/* remove longest match at start */
	for (p = end; p >= param; p--)
	  {
	    c = *p; *p = '\0';
	    if (strmatch (pattern, param, FNMATCH_EXTFLAG) != FNM_NOMATCH)
	      {
		*p = c;
		return (savestring (p));
	      }
	    *p = c;

	  }
	break;

      case RP_SHORT_LEFT:	/* remove shortest match at start */
	for (p = param; p <= end; p++)
	  {
	    c = *p; *p = '\0';
	    if (strmatch (pattern, param, FNMATCH_EXTFLAG) != FNM_NOMATCH)
	      {
		*p = c;
		return (savestring (p));
	      }
	    *p = c;
	  }
	break;

      case RP_LONG_RIGHT:	/* remove longest match at end */
	for (p = param; p <= end; p++)
	  {
	    if (strmatch (pattern, p, FNMATCH_EXTFLAG) != FNM_NOMATCH)
	      {
		c = *p; *p = '\0';
		ret = savestring (param);
		*p = c;
		return (ret);
	      }
	  }
	break;

      case RP_SHORT_RIGHT:	/* remove shortest match at end */
	for (p = end; p >= param; p--)
	  {
	    if (strmatch (pattern, p, FNMATCH_EXTFLAG) != FNM_NOMATCH)
	      {
		c = *p; *p = '\0';
		ret = savestring (param);
		*p = c;
		return (ret);
	      }
	  }
	break;
    }

  return (param);	/* no match, return original string */
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:4,558
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:4,697
parsing error 
{
  char *xret;

  if (param == NULL)
    return (param);
  if (*param == '\0' || pattern == NULL || *pattern == '\0')	/* minor optimization */
    return (savestring (param));

#if defined (HANDLE_MULTIBYTE)
  if (MB_CUR_MAX > 1)
    {
      wchar_t *ret, *oret;
      size_t n;
      wchar_t *wparam, *wpattern;
      mbstate_t ps;

      /* XXX - could optimize here by checking param and pattern for multibyte
	 chars with mbsmbchar and calling remove_upattern. */

      n = xdupmbstowcs (&wpattern, NULL, pattern);
      if (n == (size_t)-1)
	{
	  xret = remove_upattern (param, pattern, op);
	  return ((xret == param) ? savestring (param) : xret);
	}
      n = xdupmbstowcs (&wparam, NULL, param);

      if (n == (size_t)-1)
	{
	  free (wpattern);
	  xret = remove_upattern (param, pattern, op);
	  return ((xret == param) ? savestring (param) : xret);
	}
      oret = ret = remove_wpattern (wparam, n, wpattern, op);
      /* Don't bother to convert wparam back to multibyte string if nothing
	 matched; just return copy of original string */
      if (ret == wparam)
        {
          free (wparam);
          free (wpattern);
          return (savestring (param));
        }

      free (wparam);
      free (wpattern);

      n = strlen (param);
      xret = (char *)xmalloc (n + 1);
      memset (&ps, '\0', sizeof (mbstate_t));
      n = wcsrtombs (xret, (const wchar_t **)&ret, n, &ps);
      xret[n] = '\0';		/* just to make sure */
      free (oret);
      return xret;      
    }
  else
#endif
    {
      xret = remove_upattern (param, pattern, op);
      return ((xret == param) ? savestring (param) : xret);
    }
}
warning: parse error {
  char *xret;

  if (param == NULL)
    return (param);
  if (*param == '\0' || pattern == NULL || *pattern == '\0')	/* minor optimization */
    return (savestring (param));

#if defined (HANDLE_MULTIBYTE)
  if (MB_CUR_MAX > 1)
    {
      wchar_t *ret, *oret;
      size_t n;
      wchar_t *wparam, *wpattern;
      mbstate_t ps;

      /* XXX - could optimize here by checking param and pattern for multibyte
	 chars with mbsmbchar and calling remove_upattern. */

      n = xdupmbstowcs (&wpattern, NULL, pattern);
      if (n == (size_t)-1)
	{
	  xret = remove_upattern (param, pattern, op);
	  return ((xret == param) ? savestring (param) : xret);
	}
      n = xdupmbstowcs (&wparam, NULL, param);

      if (n == (size_t)-1)
	{
	  free (wpattern);
	  xret = remove_upattern (param, pattern, op);
	  return ((xret == param) ? savestring (param) : xret);
	}
      oret = ret = remove_wpattern (wparam, n, wpattern, op);
      /* Don't bother to convert wparam back to multibyte string if nothing
	 matched; just return copy of original string */
      if (ret == wparam)
        {
          free (wparam);
          free (wpattern);
          return (savestring (param));
        }

      free (wparam);
      free (wpattern);

      n = strlen (param);
      xret = (char *)xmalloc (n + 1);
      memset (&ps, '\0', sizeof (mbstate_t));
      n = wcsrtombs (xret, (const wchar_t **)&ret, n, &ps);
      xret[n] = '\0';		/* just to make sure */
      free (oret);
      return xret;      
    }
  else
#endif
    {
      xret = remove_upattern (param, pattern, op);
      return ((xret == param) ? savestring (param) : xret);
    }
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:4,700
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:4,769
parsing error 
{
  int c, mlen;
  size_t len;
  register char *p, *p1, *npat;
  char *end;

  /* If the pattern doesn't match anywhere in the string, go ahead and
     short-circuit right away.  A minor optimization, saves a bunch of
     unnecessary calls to strmatch (up to N calls for a string of N
     characters) if the match is unsuccessful.  To preserve the semantics
     of the substring matches below, we make sure that the pattern has
     `*' as first and last character, making a new pattern if necessary. */
  /* XXX - check this later if I ever implement `**' with special meaning,
     since this will potentially result in `**' at the beginning or end */
  len = STRLEN (pat);
  if (pat[0] != '*' || (pat[0] == '*' && pat[1] == LPAREN && extended_glob) || pat[len - 1] != '*')
    {
      int unescaped_backslash;
      char *pp;

      p = npat = (char *)xmalloc (len + 3);
      p1 = pat;
      if ((mtype != MATCH_BEG) && (*p1 != '*' || (*p1 == '*' && p1[1] == LPAREN && extended_glob)))
	*p++ = '*';
      while (*p1)
	*p++ = *p1++;
#if 1
      /* Need to also handle a pattern that ends with an unescaped backslash.
	 For right now, we ignore it because the pattern matching code will
	 fail the match anyway */
      /* If the pattern ends with a `*' we leave it alone if it's preceded by
	 an even number of backslashes, but if it's escaped by a backslash
	 we need to add another `*'. */
      if ((mtype != MATCH_END) && (p1[-1] == '*' && (unescaped_backslash = p1[-2] == '\\')))
	{
	  pp = p1 - 3;
	  while (pp >= pat && *pp-- == '\\')
	    unescaped_backslash = 1 - unescaped_backslash;
	  if (unescaped_backslash)
	    *p++ = '*';
	}
      else if (mtype != MATCH_END && p1[-1] != '*')
	*p++ = '*';
#else 
      if (p1[-1] != '*' || p1[-2] == '\\')
	*p++ = '*';
#endif
      *p = '\0';
    }
  else
    npat = pat;
  c = strmatch (npat, string, FNMATCH_EXTFLAG | FNMATCH_IGNCASE);
  if (npat != pat)
    free (npat);
  if (c == FNM_NOMATCH)
    return (0);

  len = STRLEN (string);
  end = string + len;

  mlen = umatchlen (pat, len);
  if (mlen > (int)len)
    return (0);

  switch (mtype)
    {
    case MATCH_ANY:
      for (p = string; p <= end; p++)
	{
	  if (match_pattern_char (pat, p, FNMATCH_IGNCASE))
	    {
	      p1 = (mlen == -1) ? end : p + mlen;
	      /* p1 - p = length of portion of string to be considered
	         p = current position in string
	         mlen = number of characters consumed by match (-1 for entire string)
	         end = end of string
	         we want to break immediately if the potential match len
	         is greater than the number of characters remaining in the
	         string
	      */
	      if (p1 > end)
		break;
	      for ( ; p1 >= p; p1--)
		{
		  c = *p1; *p1 = '\0';
		  if (strmatch (pat, p, FNMATCH_EXTFLAG | FNMATCH_IGNCASE) == 0)
		    {
		      *p1 = c;
		      *sp = p;
		      *ep = p1;
		      return 1;
		    }
		  *p1 = c;
#if 1
		  /* If MLEN != -1, we have a fixed length pattern. */
		  if (mlen != -1)
		    break;
#endif
		}
	    }
	}

      return (0);

    case MATCH_BEG:
      if (match_pattern_char (pat, string, FNMATCH_IGNCASE) == 0)
	return (0);

      for (p = (mlen == -1) ? end : string + mlen; p >= string; p--)
	{
	  c = *p; *p = '\0';
	  if (strmatch (pat, string, FNMATCH_EXTFLAG | FNMATCH_IGNCASE) == 0)
	    {
	      *p = c;
	      *sp = string;
	      *ep = p;
	      return 1;
	    }
	  *p = c;
	  /* If MLEN != -1, we have a fixed length pattern. */
	  if (mlen != -1)
	    break;
	}

      return (0);

    case MATCH_END:
      for (p = end - ((mlen == -1) ? len : mlen); p <= end; p++)
	{
	  if (strmatch (pat, p, FNMATCH_EXTFLAG | FNMATCH_IGNCASE) == 0)
	    {
	      *sp = p;
	      *ep = end;
	      return 1;
	    }
	  /* If MLEN != -1, we have a fixed length pattern. */
	  if (mlen != -1)
	    break;
	}

      return (0);
    }

  return (0);
}
warning: parse error {
  int c, mlen;
  size_t len;
  register char *p, *p1, *npat;
  char *end;

  /* If the pattern doesn't match anywhere in the string, go ahead and
     short-circuit right away.  A minor optimization, saves a bunch of
     unnecessary calls to strmatch (up to N calls for a string of N
     characters) if the match is unsuccessful.  To preserve the semantics
     of the substring matches below, we make sure that the pattern has
     `*' as first and last character, making a new pattern if necessary. */
  /* XXX - check this later if I ever implement `**' with special meaning,
     since this will potentially result in `**' at the beginning or end */
  len = STRLEN (pat);
  if (pat[0] != '*' || (pat[0] == '*' && pat[1] == LPAREN && extended_glob) || pat[len - 1] != '*')
    {
      int unescaped_backslash;
      char *pp;

      p = npat = (char *)xmalloc (len + 3);
      p1 = pat;
      if ((mtype != MATCH_BEG) && (*p1 != '*' || (*p1 == '*' && p1[1] == LPAREN && extended_glob)))
	*p++ = '*';
      while (*p1)
	*p++ = *p1++;
#if 1
      /* Need to also handle a pattern that ends with an unescaped backslash.
	 For right now, we ignore it because the pattern matching code will
	 fail the match anyway */
      /* If the pattern ends with a `*' we leave it alone if it's preceded by
	 an even number of backslashes, but if it's escaped by a backslash
	 we need to add another `*'. */
      if ((mtype != MATCH_END) && (p1[-1] == '*' && (unescaped_backslash = p1[-2] == '\\')))
	{
	  pp = p1 - 3;
	  while (pp >= pat && *pp-- == '\\')
	    unescaped_backslash = 1 - unescaped_backslash;
	  if (unescaped_backslash)
	    *p++ = '*';
	}
      else if (mtype != MATCH_END && p1[-1] != '*')
	*p++ = '*';
#else 
      if (p1[-1] != '*' || p1[-2] == '\\')
	*p++ = '*';
#endif
      *p = '\0';
    }
  else
    npat = pat;
  c = strmatch (npat, string, FNMATCH_EXTFLAG | FNMATCH_IGNCASE);
  if (npat != pat)
    free (npat);
  if (c == FNM_NOMATCH)
    return (0);

  len = STRLEN (string);
  end = string + len;

  mlen = umatchlen (pat, len);
  if (mlen > (int)len)
    return (0);

  switch (mtype)
    {
    case MATCH_ANY:
      for (p = string; p <= end; p++)
	{
	  if (match_pattern_char (pat, p, FNMATCH_IGNCASE))
	    {
	      p1 = (mlen == -1) ? end : p + mlen;
	      /* p1 - p = length of portion of string to be considered
	         p = current position in string
	         mlen = number of characters consumed by match (-1 for entire string)
	         end = end of string
	         we want to break immediately if the potential match len
	         is greater than the number of characters remaining in the
	         string
	      */
	      if (p1 > end)
		break;
	      for ( ; p1 >= p; p1--)
		{
		  c = *p1; *p1 = '\0';
		  if (strmatch (pat, p, FNMATCH_EXTFLAG | FNMATCH_IGNCASE) == 0)
		    {
		      *p1 = c;
		      *sp = p;
		      *ep = p1;
		      return 1;
		    }
		  *p1 = c;
#if 1
		  /* If MLEN != -1, we have a fixed length pattern. */
		  if (mlen != -1)
		    break;
#endif
		}
	    }
	}

      return (0);

    case MATCH_BEG:
      if (match_pattern_char (pat, string, FNMATCH_IGNCASE) == 0)
	return (0);

      for (p = (mlen == -1) ? end : string + mlen; p >= string; p--)
	{
	  c = *p; *p = '\0';
	  if (strmatch (pat, string, FNMATCH_EXTFLAG | FNMATCH_IGNCASE) == 0)
	    {
	      *p = c;
	      *sp = string;
	      *ep = p;
	      return 1;
	    }
	  *p = c;
	  /* If MLEN != -1, we have a fixed length pattern. */
	  if (mlen != -1)
	    break;
	}

      return (0);

    case MATCH_END:
      for (p = end - ((mlen == -1) ? len : mlen); p <= end; p++)
	{
	  if (strmatch (pat, p, FNMATCH_EXTFLAG | FNMATCH_IGNCASE) == 0)
	    {
	      *sp = p;
	      *ep = end;
	      return 1;
	    }
	  /* If MLEN != -1, we have a fixed length pattern. */
	  if (mlen != -1)
	    break;
	}

      return (0);
    }

  return (0);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:4,773
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:5,072
parsing error 
{
#if defined (HANDLE_MULTIBYTE)
  int ret;
  size_t n;
  wchar_t *wstring, *wpat;
  char **indices;
#endif

  if (string == 0 || pat == 0 || *pat == 0)
    return (0);

#if defined (HANDLE_MULTIBYTE)
  if (MB_CUR_MAX > 1)
    {
      if (mbsmbchar (string) == 0 && mbsmbchar (pat) == 0)
        return (match_upattern (string, pat, mtype, sp, ep));

      n = xdupmbstowcs (&wpat, NULL, pat);
      if (n == (size_t)-1)
	return (match_upattern (string, pat, mtype, sp, ep));
      n = xdupmbstowcs (&wstring, &indices, string);
      if (n == (size_t)-1)
	{
	  free (wpat);
	  return (match_upattern (string, pat, mtype, sp, ep));
	}
      ret = match_wpattern (wstring, indices, n, wpat, mtype, sp, ep);

      free (wpat);
      free (wstring);
      free (indices);

      return (ret);
    }
  else
#endif
    return (match_upattern (string, pat, mtype, sp, ep));
}
warning: parse error {
#if defined (HANDLE_MULTIBYTE)
  int ret;
  size_t n;
  wchar_t *wstring, *wpat;
  char **indices;
#endif

  if (string == 0 || pat == 0 || *pat == 0)
    return (0);

#if defined (HANDLE_MULTIBYTE)
  if (MB_CUR_MAX > 1)
    {
      if (mbsmbchar (string) == 0 && mbsmbchar (pat) == 0)
        return (match_upattern (string, pat, mtype, sp, ep));

      n = xdupmbstowcs (&wpat, NULL, pat);
      if (n == (size_t)-1)
	return (match_upattern (string, pat, mtype, sp, ep));
      n = xdupmbstowcs (&wstring, &indices, string);
      if (n == (size_t)-1)
	{
	  free (wpat);
	  return (match_upattern (string, pat, mtype, sp, ep));
	}
      ret = match_wpattern (wstring, indices, n, wpat, mtype, sp, ep);

      free (wpat);
      free (wstring);
      free (indices);

      return (ret);
    }
  else
#endif
    return (match_upattern (string, pat, mtype, sp, ep));
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:5,076
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:5,116
parsing error 
{
  if (c == '#')
    return ((*value == '#') ? RP_LONG_LEFT : RP_SHORT_LEFT);
  else	/* c == '%' */
    return ((*value == '%') ? RP_LONG_RIGHT : RP_SHORT_RIGHT);
}
warning: parse error {
  if (c == '#')
    return ((*value == '#') ? RP_LONG_LEFT : RP_SHORT_LEFT);
  else	/* c == '%' */
    return ((*value == '%') ? RP_LONG_RIGHT : RP_SHORT_RIGHT);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:5,119
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:5,135
parsing error 
{
  char *pat, *tword;
  WORD_LIST *l;
#if 0
  int i;
#endif
  /* There is a problem here:  how to handle single or double quotes in the
     pattern string when the whole expression is between double quotes?
     POSIX.2 says that enclosing double quotes do not cause the pattern to
     be quoted, but does that leave us a problem with @ and array[@] and their
     expansions inside a pattern? */
#if 0
  if (expandpat && (quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)) && *tword)
    {
      i = 0;
      pat = string_extract_double_quoted (tword, &i, SX_STRIPDQ);
      free (tword);
      tword = pat;
    }
#endif

  /* expand_string_for_pat () leaves WORD quoted and does not perform
     word splitting. */
  l = *value ? expand_string_for_pat (value,
				      (quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)) ? Q_PATQUOTE : quoted,
				      (int *)NULL, (int *)NULL)
	     : (WORD_LIST *)0;
  if (l)
    word_list_remove_quoted_nulls (l);
  pat = string_list (l);
  dispose_words (l);
  if (pat)
    {
      tword = quote_string_for_globbing (pat, QGLOB_CVTNULL);
      free (pat);
      pat = tword;
    }
  return (pat);
}
warning: parse error {
  char *pat, *tword;
  WORD_LIST *l;
#if 0
  int i;
#endif
  /* There is a problem here:  how to handle single or double quotes in the
     pattern string when the whole expression is between double quotes?
     POSIX.2 says that enclosing double quotes do not cause the pattern to
     be quoted, but does that leave us a problem with @ and array[@] and their
     expansions inside a pattern? */
#if 0
  if (expandpat && (quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)) && *tword)
    {
      i = 0;
      pat = string_extract_double_quoted (tword, &i, SX_STRIPDQ);
      free (tword);
      tword = pat;
    }
#endif

  /* expand_string_for_pat () leaves WORD quoted and does not perform
     word splitting. */
  l = *value ? expand_string_for_pat (value,
				      (quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)) ? Q_PATQUOTE : quoted,
				      (int *)NULL, (int *)NULL)
	     : (WORD_LIST *)0;
  if (l)
    word_list_remove_quoted_nulls (l);
  pat = string_list (l);
  dispose_words (l);
  if (pat)
    {
      tword = quote_string_for_globbing (pat, QGLOB_CVTNULL);
      free (pat);
      pat = tword;
    }
  return (pat);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:5,138
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:5,195
parsing error 
{
  WORD_LIST *new, *l;
  WORD_DESC *w;
  char *tword;

  for (new = (WORD_LIST *)NULL, l = list; l; l = l->next)
    {
      tword = remove_pattern (l->word->word, pattern, patspec);
      w = alloc_word_desc ();
      w->word = tword ? tword : savestring ("");
      new = make_word_list (w, new);
    }

  l = REVERSE_LIST (new, WORD_LIST *);
  tword = string_list_pos_params (itype, l, quoted, 0);
  dispose_words (l);

  return (tword);
}
warning: parse error {
  WORD_LIST *new, *l;
  WORD_DESC *w;
  char *tword;

  for (new = (WORD_LIST *)NULL, l = list; l; l = l->next)
    {
      tword = remove_pattern (l->word->word, pattern, patspec);
      w = alloc_word_desc ();
      w->word = tword ? tword : savestring ("");
      new = make_word_list (w, new);
    }

  l = REVERSE_LIST (new, WORD_LIST *);
  tword = string_list_pos_params (itype, l, quoted, 0);
  dispose_words (l);

  return (tword);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:5,199
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:5,220
parsing error 
{
  char *ret;
  WORD_LIST *list;

  list = list_rest_of_args ();
  if (list == 0)
    return ((char *)NULL);
  ret = list_remove_pattern (list, pattern, patspec, itype, quoted);
  dispose_words (list);
  return (ret);
}
warning: parse error {
  char *ret;
  WORD_LIST *list;

  list = list_rest_of_args ();
  if (list == 0)
    return ((char *)NULL);
  ret = list_remove_pattern (list, pattern, patspec, itype, quoted);
  dispose_words (list);
  return (ret);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:5,224
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:5,270
parsing error 
{
  int vtype, patspec, starsub;
  char *temp1, *val, *pattern, *oname;
  SHELL_VAR *v;

  if (value == 0)
    return ((char *)NULL);

  oname = this_command_name;
  this_command_name = varname;

  vtype = get_var_and_type (varname, value, ind, quoted, flags, &v, &val);
  if (vtype == -1)
    {
      this_command_name = oname;
      return ((char *)NULL);
    }

  starsub = vtype & VT_STARSUB;
  vtype &= ~VT_STARSUB;

  patspec = getpatspec (rtype, patstr);
  if (patspec == RP_LONG_LEFT || patspec == RP_LONG_RIGHT)
    patstr++;

  /* Need to pass getpattern newly-allocated memory in case of expansion --
     the expansion code will free the passed string on an error. */
  temp1 = savestring (patstr);
  pattern = getpattern (temp1, quoted, 1);
  free (temp1);

  temp1 = (char *)NULL;		/* shut up gcc */
  switch (vtype)
    {
    case VT_VARIABLE:
    case VT_ARRAYMEMBER:
      temp1 = remove_pattern (val, pattern, patspec);
      if (vtype == VT_VARIABLE)
	FREE (val);
      if (temp1)
	{
	  val = (quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES))
			? quote_string (temp1)
			: quote_escapes (temp1);
	  free (temp1);
	  temp1 = val;
	}
      break;
#if defined (ARRAY_VARS)
    case VT_ARRAYVAR:
      temp1 = array_remove_pattern (v, pattern, patspec, starsub, quoted);
      if (temp1 && ((quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)) == 0))
	{
	  val = quote_escapes (temp1);
	  free (temp1);
	  temp1 = val;
	}
      break;
#endif
    case VT_POSPARMS:
      temp1 = parameter_list_remove_pattern (varname[0], pattern, patspec, quoted);
      if (temp1 && quoted == 0 && ifs_is_null)
	{
	  /* Posix interp 888 */
	}
      else if (temp1 && ((quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)) == 0))
	{
	  val = quote_escapes (temp1);
	  free (temp1);
	  temp1 = val;
	}
      break;
    }

  this_command_name = oname;

  FREE (pattern);
  return temp1;
}
warning: parse error {
  int vtype, patspec, starsub;
  char *temp1, *val, *pattern, *oname;
  SHELL_VAR *v;

  if (value == 0)
    return ((char *)NULL);

  oname = this_command_name;
  this_command_name = varname;

  vtype = get_var_and_type (varname, value, ind, quoted, flags, &v, &val);
  if (vtype == -1)
    {
      this_command_name = oname;
      return ((char *)NULL);
    }

  starsub = vtype & VT_STARSUB;
  vtype &= ~VT_STARSUB;

  patspec = getpatspec (rtype, patstr);
  if (patspec == RP_LONG_LEFT || patspec == RP_LONG_RIGHT)
    patstr++;

  /* Need to pass getpattern newly-allocated memory in case of expansion --
     the expansion code will free the passed string on an error. */
  temp1 = savestring (patstr);
  pattern = getpattern (temp1, quoted, 1);
  free (temp1);

  temp1 = (char *)NULL;		/* shut up gcc */
  switch (vtype)
    {
    case VT_VARIABLE:
    case VT_ARRAYMEMBER:
      temp1 = remove_pattern (val, pattern, patspec);
      if (vtype == VT_VARIABLE)
	FREE (val);
      if (temp1)
	{
	  val = (quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES))
			? quote_string (temp1)
			: quote_escapes (temp1);
	  free (temp1);
	  temp1 = val;
	}
      break;
#if defined (ARRAY_VARS)
    case VT_ARRAYVAR:
      temp1 = array_remove_pattern (v, pattern, patspec, starsub, quoted);
      if (temp1 && ((quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)) == 0))
	{
	  val = quote_escapes (temp1);
	  free (temp1);
	  temp1 = val;
	}
      break;
#endif
    case VT_POSPARMS:
      temp1 = parameter_list_remove_pattern (varname[0], pattern, patspec, quoted);
      if (temp1 && quoted == 0 && ifs_is_null)
	{
	  /* Posix interp 888 */
	}
      else if (temp1 && ((quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)) == 0))
	{
	  val = quote_escapes (temp1);
	  free (temp1);
	  temp1 = val;
	}
      break;
    }

  this_command_name = oname;

  FREE (pattern);
  return temp1;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:5,275
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:6,168
parsing error 
{
  char *istring, buf[512], *bufp;
  int istring_index, c, tflag, skip_ctlesc, skip_ctlnul;
  int mb_cur_max;
  size_t istring_size;
  ssize_t bufn;
  int nullbyte;
#if defined (HANDLE_MULTIBYTE)
  mbstate_t ps;
  wchar_t wc;
  size_t mblen;
  int i;
#endif

  istring = (char *)NULL;
  istring_index = istring_size = bufn = tflag = 0;

  skip_ctlesc = ifs_cmap[CTLESC];
  skip_ctlnul = ifs_cmap[CTLNUL];

  mb_cur_max = MB_CUR_MAX;
  nullbyte = 0;

  /* Read the output of the command through the pipe. */
  while (1)
    {
      if (fd < 0)
	break;
      if (--bufn <= 0)
	{
	  bufn = zread (fd, buf, sizeof (buf));
	  if (bufn <= 0) 
	    break;
	  bufp = buf;
	}
      c = *bufp++;

      if (c == 0)
	{
#if 1
	  if (nullbyte == 0)
	    {
	      internal_warning ("%s", _("command substitution: ignored null byte in input"));
	      nullbyte = 1;
	    }
#endif
	  continue;
	}

      /* Add the character to ISTRING, possibly after resizing it. */
      RESIZE_MALLOCED_BUFFER (istring, istring_index, mb_cur_max+1, istring_size, 512);

      /* This is essentially quote_string inline */
      if ((quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)) /* || c == CTLESC || c == CTLNUL */)
	istring[istring_index++] = CTLESC;
      else if ((flags & PF_ASSIGNRHS) && skip_ctlesc && c == CTLESC)
	istring[istring_index++] = CTLESC;
      /* Escape CTLESC and CTLNUL in the output to protect those characters
	 from the rest of the word expansions (word splitting and globbing.)
	 This is essentially quote_escapes inline. */
      else if (skip_ctlesc == 0 && c == CTLESC)
	istring[istring_index++] = CTLESC;
      else if ((skip_ctlnul == 0 && c == CTLNUL) || (c == ' ' && (ifs_value && *ifs_value == 0)))
	istring[istring_index++] = CTLESC;

#if defined (HANDLE_MULTIBYTE)
      if ((locale_utf8locale && (c & 0x80)) ||
	  (locale_utf8locale == 0 && mb_cur_max > 1 && (unsigned char)c > 127))
	{
	  /* read a multibyte character from buf */
	  /* punt on the hard case for now */
	  memset (&ps, '\0', sizeof (mbstate_t));
	  mblen = mbrtowc (&wc, bufp-1, bufn+1, &ps);
	  if (MB_INVALIDCH (mblen) || mblen == 0 || mblen == 1)
	    istring[istring_index++] = c;
	  else
	    {
	      istring[istring_index++] = c;
	      for (i = 0; i < mblen-1; i++)
		istring[istring_index++] = *bufp++;
	      bufn -= mblen - 1;
	    }
	  continue;
	}
#endif

      istring[istring_index++] = c;
    }

  if (istring)
    istring[istring_index] = '\0';

  /* If we read no output, just return now and save ourselves some
     trouble. */
  if (istring_index == 0)
    {
      FREE (istring);
      if (rflag)
	*rflag = tflag;
      return (char *)NULL;
    }

  /* Strip trailing newlines from the output of the command. */
  if (quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES))
    {
      while (istring_index > 0)
	{
	  if (istring[istring_index - 1] == '\n')
	    {
	      --istring_index;

	      /* If the newline was quoted, remove the quoting char. */
	      if (istring[istring_index - 1] == CTLESC)
		--istring_index;
	    }
	  else
	    break;
	}
      istring[istring_index] = '\0';
    }
  else
    strip_trailing (istring, istring_index - 1, 1);

  if (rflag)
    *rflag = tflag;
  return istring;
}
warning: parse error {
  char *istring, buf[512], *bufp;
  int istring_index, c, tflag, skip_ctlesc, skip_ctlnul;
  int mb_cur_max;
  size_t istring_size;
  ssize_t bufn;
  int nullbyte;
#if defined (HANDLE_MULTIBYTE)
  mbstate_t ps;
  wchar_t wc;
  size_t mblen;
  int i;
#endif

  istring = (char *)NULL;
  istring_index = istring_size = bufn = tflag = 0;

  skip_ctlesc = ifs_cmap[CTLESC];
  skip_ctlnul = ifs_cmap[CTLNUL];

  mb_cur_max = MB_CUR_MAX;
  nullbyte = 0;

  /* Read the output of the command through the pipe. */
  while (1)
    {
      if (fd < 0)
	break;
      if (--bufn <= 0)
	{
	  bufn = zread (fd, buf, sizeof (buf));
	  if (bufn <= 0) 
	    break;
	  bufp = buf;
	}
      c = *bufp++;

      if (c == 0)
	{
#if 1
	  if (nullbyte == 0)
	    {
	      internal_warning ("%s", _("command substitution: ignored null byte in input"));
	      nullbyte = 1;
	    }
#endif
	  continue;
	}

      /* Add the character to ISTRING, possibly after resizing it. */
      RESIZE_MALLOCED_BUFFER (istring, istring_index, mb_cur_max+1, istring_size, 512);

      /* This is essentially quote_string inline */
      if ((quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)) /* || c == CTLESC || c == CTLNUL */)
	istring[istring_index++] = CTLESC;
      else if ((flags & PF_ASSIGNRHS) && skip_ctlesc && c == CTLESC)
	istring[istring_index++] = CTLESC;
      /* Escape CTLESC and CTLNUL in the output to protect those characters
	 from the rest of the word expansions (word splitting and globbing.)
	 This is essentially quote_escapes inline. */
      else if (skip_ctlesc == 0 && c == CTLESC)
	istring[istring_index++] = CTLESC;
      else if ((skip_ctlnul == 0 && c == CTLNUL) || (c == ' ' && (ifs_value && *ifs_value == 0)))
	istring[istring_index++] = CTLESC;

#if defined (HANDLE_MULTIBYTE)
      if ((locale_utf8locale && (c & 0x80)) ||
	  (locale_utf8locale == 0 && mb_cur_max > 1 && (unsigned char)c > 127))
	{
	  /* read a multibyte character from buf */
	  /* punt on the hard case for now */
	  memset (&ps, '\0', sizeof (mbstate_t));
	  mblen = mbrtowc (&wc, bufp-1, bufn+1, &ps);
	  if (MB_INVALIDCH (mblen) || mblen == 0 || mblen == 1)
	    istring[istring_index++] = c;
	  else
	    {
	      istring[istring_index++] = c;
	      for (i = 0; i < mblen-1; i++)
		istring[istring_index++] = *bufp++;
	      bufn -= mblen - 1;
	    }
	  continue;
	}
#endif

      istring[istring_index++] = c;
    }

  if (istring)
    istring[istring_index] = '\0';

  /* If we read no output, just return now and save ourselves some
     trouble. */
  if (istring_index == 0)
    {
      FREE (istring);
      if (rflag)
	*rflag = tflag;
      return (char *)NULL;
    }

  /* Strip trailing newlines from the output of the command. */
  if (quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES))
    {
      while (istring_index > 0)
	{
	  if (istring[istring_index - 1] == '\n')
	    {
	      --istring_index;

	      /* If the newline was quoted, remove the quoting char. */
	      if (istring[istring_index - 1] == CTLESC)
		--istring_index;
	    }
	  else
	    break;
	}
      istring[istring_index] = '\0';
    }
  else
    strip_trailing (istring, istring_index - 1, 1);

  if (rflag)
    *rflag = tflag;
  return istring;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:6,171
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:6,302
parsing error 
{
  pid_t pid, old_pid, old_pipeline_pgrp, old_async_pid;
  char *istring, *s;
  int result, fildes[2], function_value, pflags, rc, tflag, fork_flags;
  WORD_DESC *ret;
  sigset_t set, oset;

  istring = (char *)NULL;

  /* Don't fork () if there is no need to.  In the case of no command to
     run, just return NULL. */
#if 1
  for (s = string; s && *s && (shellblank (*s) || *s == '\n'); s++)
    ;
  if (s == 0 || *s == 0)
    return ((WORD_DESC *)NULL);
#else
  if (!string || !*string || (string[0] == '\n' && !string[1]))
    return ((WORD_DESC *)NULL);
#endif

  if (wordexp_only && read_but_dont_execute)
    {
      last_command_exit_value = EX_WEXPCOMSUB;
      jump_to_top_level (EXITPROG);
    }

  /* We're making the assumption here that the command substitution will
     eventually run a command from the file system.  Since we'll run
     maybe_make_export_env in this subshell before executing that command,
     the parent shell and any other shells it starts will have to remake
     the environment.  If we make it before we fork, other shells won't
     have to.  Don't bother if we have any temporary variable assignments,
     though, because the export environment will be remade after this
     command completes anyway, but do it if all the words to be expanded
     are variable assignments. */
  if (subst_assign_varlist == 0 || garglist == 0)
    maybe_make_export_env ();	/* XXX */

  /* Flags to pass to parse_and_execute() */
  pflags = (interactive && sourcelevel == 0) ? SEVAL_RESETLINE : 0;

  old_pid = last_made_pid;

  /* Pipe the output of executing STRING into the current shell. */
  if (pipe (fildes) < 0)
    {
      sys_error ("%s", _("cannot make pipe for command substitution"));
      goto error_exit;
    }

#if defined (JOB_CONTROL)
  old_pipeline_pgrp = pipeline_pgrp;
  /* Don't reset the pipeline pgrp if we're already a subshell in a pipeline. */
  if ((subshell_environment & SUBSHELL_PIPE) == 0)
    pipeline_pgrp = shell_pgrp;
  cleanup_the_pipeline ();
#endif /* JOB_CONTROL */

  old_async_pid = last_asynchronous_pid;
  fork_flags = (subshell_environment&SUBSHELL_ASYNC) ? FORK_ASYNC : 0;
  pid = make_child ((char *)NULL, fork_flags|FORK_NOTERM);
  last_asynchronous_pid = old_async_pid;

  if (pid == 0)
    {
      /* Reset the signal handlers in the child, but don't free the
	 trap strings.  Set a flag noting that we have to free the
	 trap strings if we run trap to change a signal disposition. */
      reset_signal_handlers ();
      if (ISINTERRUPT)
	{
	  kill (getpid (), SIGINT);
	  CLRINTERRUPT;		/* if we're ignoring SIGINT somehow */
	}	
      QUIT;	/* catch any interrupts we got post-fork */
      subshell_environment |= SUBSHELL_RESETTRAP;
    }

#if defined (JOB_CONTROL)
  /* XXX DO THIS ONLY IN PARENT ? XXX */
  set_sigchld_handler ();
  stop_making_children ();
  if (pid != 0)
    pipeline_pgrp = old_pipeline_pgrp;
#else
  stop_making_children ();
#endif /* JOB_CONTROL */

  if (pid < 0)
    {
      sys_error (_("cannot make child for command substitution"));
    error_exit:

      last_made_pid = old_pid;

      FREE (istring);
      close (fildes[0]);
      close (fildes[1]);
      return ((WORD_DESC *)NULL);
    }

  if (pid == 0)
    {
      /* The currently executing shell is not interactive. */
      interactive = 0;

      set_sigint_handler ();	/* XXX */

      free_pushed_string_input ();

      /* Discard  buffered stdio output before replacing the underlying file
	 descriptor. */
      fpurge (stdout);

      if (dup2 (fildes[1], 1) < 0)
	{
	  sys_error ("%s", _("command_substitute: cannot duplicate pipe as fd 1"));
	  exit (EXECUTION_FAILURE);
	}

      /* If standard output is closed in the parent shell
	 (such as after `exec >&-'), file descriptor 1 will be
	 the lowest available file descriptor, and end up in
	 fildes[0].  This can happen for stdin and stderr as well,
	 but stdout is more important -- it will cause no output
	 to be generated from this command. */
      if ((fildes[1] != fileno (stdin)) &&
	  (fildes[1] != fileno (stdout)) &&
	  (fildes[1] != fileno (stderr)))
	close (fildes[1]);

      if ((fildes[0] != fileno (stdin)) &&
	  (fildes[0] != fileno (stdout)) &&
	  (fildes[0] != fileno (stderr)))
	close (fildes[0]);

#ifdef __CYGWIN__
      /* Let stdio know the fd may have changed from text to binary mode, and
	 make sure to preserve stdout line buffering. */
      freopen (NULL, "w", stdout);
      sh_setlinebuf (stdout);
#endif /* __CYGWIN__ */

      /* This is a subshell environment. */
      subshell_environment |= SUBSHELL_COMSUB;

      /* Many shells do not appear to inherit the -v option for command
	 substitutions. */
      change_flag ('v', FLAG_OFF);

      /* When inherit_errexit option is not enabled, command substitution does
	 not inherit the -e flag.  It is enabled when Posix mode is enabled */
      if (inherit_errexit == 0)
        {
          builtin_ignoring_errexit = 0;
	  change_flag ('e', FLAG_OFF);
        }
      set_shellopts ();

      /* If we are expanding a redirection, we can dispose of any temporary
	 environment we received, since redirections are not supposed to have
	 access to the temporary environment.  We will have to see whether this
	 affects temporary environments supplied to `eval', but the temporary
	 environment gets copied to builtin_env at some point. */
      if (expanding_redir)
	{
	  flush_temporary_env ();
	  expanding_redir = 0;
	}

      remove_quoted_escapes (string);

      startup_state = 2;	/* see if we can avoid a fork */
      parse_and_execute_level = 0;

      /* Give command substitution a place to jump back to on failure,
	 so we don't go back up to main (). */
      result = setjmp_nosigs (top_level);

      /* If we're running a command substitution inside a shell function,
	 trap `return' so we don't return from the function in the subshell
	 and go off to never-never land. */
      if (result == 0 && return_catch_flag)
	function_value = setjmp_nosigs (return_catch);
      else
	function_value = 0;

      if (result == ERREXIT)
	rc = last_command_exit_value;
      else if (result == EXITPROG)
	rc = last_command_exit_value;
      else if (result)
	rc = EXECUTION_FAILURE;
      else if (function_value)
	rc = return_catch_value;
      else
	{
	  subshell_level++;
	  rc = parse_and_execute (string, "command substitution", pflags|SEVAL_NOHIST);
	  /* leave subshell level intact for any exit trap */
	}

      last_command_exit_value = rc;
      rc = run_exit_trap ();
#if defined (PROCESS_SUBSTITUTION)
      unlink_fifo_list ();
#endif
      exit (rc);
    }
  else
    {
      int dummyfd;

#if defined (JOB_CONTROL) && defined (PGRP_PIPE)
      close_pgrp_pipe ();
#endif /* JOB_CONTROL && PGRP_PIPE */

      close (fildes[1]);

      begin_unwind_frame ("read-comsub");
      dummyfd = fildes[0];
      add_unwind_protect (close, dummyfd);

      /* Block SIGINT while we're reading from the pipe. If the child
	 process gets a SIGINT, it will either handle it or die, and the
	 read will return. */
      BLOCK_SIGNAL (SIGINT, set, oset);
      tflag = 0;
      istring = read_comsub (fildes[0], quoted, flags, &tflag);

      close (fildes[0]);
      discard_unwind_frame ("read-comsub");
      UNBLOCK_SIGNAL (oset);

      current_command_subst_pid = pid;
      last_command_exit_value = wait_for (pid, JWAIT_NOTERM);
      last_command_subst_pid = pid;
      last_made_pid = old_pid;

#if defined (JOB_CONTROL)
      /* If last_command_exit_value > 128, then the substituted command
	 was terminated by a signal.  If that signal was SIGINT, then send
	 SIGINT to ourselves.  This will break out of loops, for instance. */
      if (last_command_exit_value == (128 + SIGINT) && last_command_exit_signal == SIGINT)
	kill (getpid (), SIGINT);
#endif /* JOB_CONTROL */

      ret = alloc_word_desc ();
      ret->word = istring;
      ret->flags = tflag;

      return ret;
    }
}
warning: parse error {
  pid_t pid, old_pid, old_pipeline_pgrp, old_async_pid;
  char *istring, *s;
  int result, fildes[2], function_value, pflags, rc, tflag, fork_flags;
  WORD_DESC *ret;
  sigset_t set, oset;

  istring = (char *)NULL;

  /* Don't fork () if there is no need to.  In the case of no command to
     run, just return NULL. */
#if 1
  for (s = string; s && *s && (shellblank (*s) || *s == '\n'); s++)
    ;
  if (s == 0 || *s == 0)
    return ((WORD_DESC *)NULL);
#else
  if (!string || !*string || (string[0] == '\n' && !string[1]))
    return ((WORD_DESC *)NULL);
#endif

  if (wordexp_only && read_but_dont_execute)
    {
      last_command_exit_value = EX_WEXPCOMSUB;
      jump_to_top_level (EXITPROG);
    }

  /* We're making the assumption here that the command substitution will
     eventually run a command from the file system.  Since we'll run
     maybe_make_export_env in this subshell before executing that command,
     the parent shell and any other shells it starts will have to remake
     the environment.  If we make it before we fork, other shells won't
     have to.  Don't bother if we have any temporary variable assignments,
     though, because the export environment will be remade after this
     command completes anyway, but do it if all the words to be expanded
     are variable assignments. */
  if (subst_assign_varlist == 0 || garglist == 0)
    maybe_make_export_env ();	/* XXX */

  /* Flags to pass to parse_and_execute() */
  pflags = (interactive && sourcelevel == 0) ? SEVAL_RESETLINE : 0;

  old_pid = last_made_pid;

  /* Pipe the output of executing STRING into the current shell. */
  if (pipe (fildes) < 0)
    {
      sys_error ("%s", _("cannot make pipe for command substitution"));
      goto error_exit;
    }

#if defined (JOB_CONTROL)
  old_pipeline_pgrp = pipeline_pgrp;
  /* Don't reset the pipeline pgrp if we're already a subshell in a pipeline. */
  if ((subshell_environment & SUBSHELL_PIPE) == 0)
    pipeline_pgrp = shell_pgrp;
  cleanup_the_pipeline ();
#endif /* JOB_CONTROL */

  old_async_pid = last_asynchronous_pid;
  fork_flags = (subshell_environment&SUBSHELL_ASYNC) ? FORK_ASYNC : 0;
  pid = make_child ((char *)NULL, fork_flags|FORK_NOTERM);
  last_asynchronous_pid = old_async_pid;

  if (pid == 0)
    {
      /* Reset the signal handlers in the child, but don't free the
	 trap strings.  Set a flag noting that we have to free the
	 trap strings if we run trap to change a signal disposition. */
      reset_signal_handlers ();
      if (ISINTERRUPT)
	{
	  kill (getpid (), SIGINT);
	  CLRINTERRUPT;		/* if we're ignoring SIGINT somehow */
	}	
      QUIT;	/* catch any interrupts we got post-fork */
      subshell_environment |= SUBSHELL_RESETTRAP;
    }

#if defined (JOB_CONTROL)
  /* XXX DO THIS ONLY IN PARENT ? XXX */
  set_sigchld_handler ();
  stop_making_children ();
  if (pid != 0)
    pipeline_pgrp = old_pipeline_pgrp;
#else
  stop_making_children ();
#endif /* JOB_CONTROL */

  if (pid < 0)
    {
      sys_error (_("cannot make child for command substitution"));
    error_exit:

      last_made_pid = old_pid;

      FREE (istring);
      close (fildes[0]);
      close (fildes[1]);
      return ((WORD_DESC *)NULL);
    }

  if (pid == 0)
    {
      /* The currently executing shell is not interactive. */
      interactive = 0;

      set_sigint_handler ();	/* XXX */

      free_pushed_string_input ();

      /* Discard  buffered stdio output before replacing the underlying file
	 descriptor. */
      fpurge (stdout);

      if (dup2 (fildes[1], 1) < 0)
	{
	  sys_error ("%s", _("command_substitute: cannot duplicate pipe as fd 1"));
	  exit (EXECUTION_FAILURE);
	}

      /* If standard output is closed in the parent shell
	 (such as after `exec >&-'), file descriptor 1 will be
	 the lowest available file descriptor, and end up in
	 fildes[0].  This can happen for stdin and stderr as well,
	 but stdout is more important -- it will cause no output
	 to be generated from this command. */
      if ((fildes[1] != fileno (stdin)) &&
	  (fildes[1] != fileno (stdout)) &&
	  (fildes[1] != fileno (stderr)))
	close (fildes[1]);

      if ((fildes[0] != fileno (stdin)) &&
	  (fildes[0] != fileno (stdout)) &&
	  (fildes[0] != fileno (stderr)))
	close (fildes[0]);

#ifdef __CYGWIN__
      /* Let stdio know the fd may have changed from text to binary mode, and
	 make sure to preserve stdout line buffering. */
      freopen (NULL, "w", stdout);
      sh_setlinebuf (stdout);
#endif /* __CYGWIN__ */

      /* This is a subshell environment. */
      subshell_environment |= SUBSHELL_COMSUB;

      /* Many shells do not appear to inherit the -v option for command
	 substitutions. */
      change_flag ('v', FLAG_OFF);

      /* When inherit_errexit option is not enabled, command substitution does
	 not inherit the -e flag.  It is enabled when Posix mode is enabled */
      if (inherit_errexit == 0)
        {
          builtin_ignoring_errexit = 0;
	  change_flag ('e', FLAG_OFF);
        }
      set_shellopts ();

      /* If we are expanding a redirection, we can dispose of any temporary
	 environment we received, since redirections are not supposed to have
	 access to the temporary environment.  We will have to see whether this
	 affects temporary environments supplied to `eval', but the temporary
	 environment gets copied to builtin_env at some point. */
      if (expanding_redir)
	{
	  flush_temporary_env ();
	  expanding_redir = 0;
	}

      remove_quoted_escapes (string);

      startup_state = 2;	/* see if we can avoid a fork */
      parse_and_execute_level = 0;

      /* Give command substitution a place to jump back to on failure,
	 so we don't go back up to main (). */
      result = setjmp_nosigs (top_level);

      /* If we're running a command substitution inside a shell function,
	 trap `return' so we don't return from the function in the subshell
	 and go off to never-never land. */
      if (result == 0 && return_catch_flag)
	function_value = setjmp_nosigs (return_catch);
      else
	function_value = 0;

      if (result == ERREXIT)
	rc = last_command_exit_value;
      else if (result == EXITPROG)
	rc = last_command_exit_value;
      else if (result)
	rc = EXECUTION_FAILURE;
      else if (function_value)
	rc = return_catch_value;
      else
	{
	  subshell_level++;
	  rc = parse_and_execute (string, "command substitution", pflags|SEVAL_NOHIST);
	  /* leave subshell level intact for any exit trap */
	}

      last_command_exit_value = rc;
      rc = run_exit_trap ();
#if defined (PROCESS_SUBSTITUTION)
      unlink_fifo_list ();
#endif
      exit (rc);
    }
  else
    {
      int dummyfd;

#if defined (JOB_CONTROL) && defined (PGRP_PIPE)
      close_pgrp_pipe ();
#endif /* JOB_CONTROL && PGRP_PIPE */

      close (fildes[1]);

      begin_unwind_frame ("read-comsub");
      dummyfd = fildes[0];
      add_unwind_protect (close, dummyfd);

      /* Block SIGINT while we're reading from the pipe. If the child
	 process gets a SIGINT, it will either handle it or die, and the
	 read will return. */
      BLOCK_SIGNAL (SIGINT, set, oset);
      tflag = 0;
      istring = read_comsub (fildes[0], quoted, flags, &tflag);

      close (fildes[0]);
      discard_unwind_frame ("read-comsub");
      UNBLOCK_SIGNAL (oset);

      current_command_subst_pid = pid;
      last_command_exit_value = wait_for (pid, JWAIT_NOTERM);
      last_command_subst_pid = pid;
      last_made_pid = old_pid;

#if defined (JOB_CONTROL)
      /* If last_command_exit_value > 128, then the substituted command
	 was terminated by a signal.  If that signal was SIGINT, then send
	 SIGINT to ourselves.  This will break out of loops, for instance. */
      if (last_command_exit_value == (128 + SIGINT) && last_command_exit_signal == SIGINT)
	kill (getpid (), SIGINT);
#endif /* JOB_CONTROL */

      ret = alloc_word_desc ();
      ret->word = istring;
      ret->flags = tflag;

      return ret;
    }
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:6,306
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:6,652
parsing error 
{
  if (DIGIT (*name) && all_digits (name))
    return 1;
  else if (var_is_special)
    return 1;
#if defined (ARRAY_VARS)
  else if (valid_array_reference (name, 0))
    return 1;
#endif /* ARRAY_VARS */
  else if (legal_identifier (name))
    return 1;
  else
    return 0;
}
warning: parse error {
  if (DIGIT (*name) && all_digits (name))
    return 1;
  else if (var_is_special)
    return 1;
#if defined (ARRAY_VARS)
  else if (valid_array_reference (name, 0))
    return 1;
#endif /* ARRAY_VARS */
  else if (legal_identifier (name))
    return 1;
  else
    return 0;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:6,655
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:6,671
parsing error 
{
  char *temp1;

  if (name == 0)
    {
      if (quoted_dollar_atp)
	*quoted_dollar_atp = 0;
      if (contains_dollar_at)
	*contains_dollar_at = 0;
      return 0;
    }

  /* check for $@ and $* */
  if (name[0] == '@' && name[1] == 0)
    {
      if ((quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)) && quoted_dollar_atp)
	*quoted_dollar_atp = 1;
      if (contains_dollar_at)
	*contains_dollar_at = 1;
      return 1;
    }
  else if (name[0] == '*' && name[1] == '\0' && quoted == 0)
    {
      /* Need more checks here that parallel what string_list_pos_params and
	 param_expand do. Check expand_no_split_dollar_star and ??? */
      if (contains_dollar_at && expand_no_split_dollar_star == 0)
	*contains_dollar_at = 1;
      return 1;
    }

  /* Now check for ${array[@]} and ${array[*]} */
#if defined (ARRAY_VARS)
  else if (valid_array_reference (name, 0))
    {
      temp1 = mbschr (name, LBRACK);
      if (temp1 && temp1[1] == '@' && temp1[2] == RBRACK)
	{
	  if ((quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)) && quoted_dollar_atp)
	    *quoted_dollar_atp = 1;
	  if (contains_dollar_at)
	    *contains_dollar_at = 1;
	  return 1;
	}
      /* ${array[*]}, when unquoted, should be treated like ${array[@]},
	 which should result in separate words even when IFS is unset. */
      if (temp1 && temp1[1] == '*' && temp1[2] == RBRACK && quoted == 0)
	{
	  if (contains_dollar_at)
	    *contains_dollar_at = 1;
	  return 1;
	}
    }
#endif
  return 0;
}
warning: parse error {
  char *temp1;

  if (name == 0)
    {
      if (quoted_dollar_atp)
	*quoted_dollar_atp = 0;
      if (contains_dollar_at)
	*contains_dollar_at = 0;
      return 0;
    }

  /* check for $@ and $* */
  if (name[0] == '@' && name[1] == 0)
    {
      if ((quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)) && quoted_dollar_atp)
	*quoted_dollar_atp = 1;
      if (contains_dollar_at)
	*contains_dollar_at = 1;
      return 1;
    }
  else if (name[0] == '*' && name[1] == '\0' && quoted == 0)
    {
      /* Need more checks here that parallel what string_list_pos_params and
	 param_expand do. Check expand_no_split_dollar_star and ??? */
      if (contains_dollar_at && expand_no_split_dollar_star == 0)
	*contains_dollar_at = 1;
      return 1;
    }

  /* Now check for ${array[@]} and ${array[*]} */
#if defined (ARRAY_VARS)
  else if (valid_array_reference (name, 0))
    {
      temp1 = mbschr (name, LBRACK);
      if (temp1 && temp1[1] == '@' && temp1[2] == RBRACK)
	{
	  if ((quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)) && quoted_dollar_atp)
	    *quoted_dollar_atp = 1;
	  if (contains_dollar_at)
	    *contains_dollar_at = 1;
	  return 1;
	}
      /* ${array[*]}, when unquoted, should be treated like ${array[@]},
	 which should result in separate words even when IFS is unset. */
      if (temp1 && temp1[1] == '*' && temp1[2] == RBRACK && quoted == 0)
	{
	  if (contains_dollar_at)
	    *contains_dollar_at = 1;
	  return 1;
	}
    }
#endif
  return 0;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:6,675
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:6,737
parsing error 
{
  WORD_DESC *ret;
  char *temp, *tt;
  intmax_t arg_index;
  SHELL_VAR *var;
  int atype, rflags;
  arrayind_t ind;

  ret = 0;
  temp = 0;
  rflags = 0;

  if (indp)
    *indp = INTMAX_MIN;

  /* Handle multiple digit arguments, as in ${11}. */  
  if (legal_number (name, &arg_index))
    {
      tt = get_dollar_var_value (arg_index);
      if (tt)
 	temp = (*tt && (quoted & (Q_DOUBLE_QUOTES|Q_HERE_DOCUMENT)))
 		  ? quote_string (tt)
 		  : quote_escapes (tt);
      else
        temp = (char *)NULL;
      FREE (tt);
    }
  else if (var_is_special)      /* ${@} */
    {
      int sindex;
      tt = (char *)xmalloc (2 + strlen (name));
      tt[sindex = 0] = '$';
      strcpy (tt + 1, name);

      ret = param_expand (tt, &sindex, quoted, (int *)NULL, (int *)NULL,
			  (int *)NULL, (int *)NULL, pflags);
      free (tt);
    }
#if defined (ARRAY_VARS)
  else if (valid_array_reference (name, 0))
    {
expand_arrayref:
      var = array_variable_part (name, 0, &tt, (int *)0);
      /* These are the cases where word splitting will not be performed */
      if (pflags & PF_ASSIGNRHS)
	{
	  if (ALL_ELEMENT_SUB (tt[0]) && tt[1] == RBRACK)
	    {
	      /* Only treat as double quoted if array variable */
	      if (var && (array_p (var) || assoc_p (var)))
		temp = array_value (name, quoted|Q_DOUBLE_QUOTES, AV_ASSIGNRHS, &atype, &ind);
	      else		
		temp = array_value (name, quoted, 0, &atype, &ind);
	    }
	  else
	    temp = array_value (name, quoted, 0, &atype, &ind);
	}
      /* Posix interp 888 */
      else if (pflags & PF_NOSPLIT2)
	{
	  /* Special cases, then general case, for each of A[@], A[*], A[n] */
#if defined (HANDLE_MULTIBYTE)
          if (tt[0] == '@' && tt[1] == RBRACK && var && quoted == 0 && ifs_is_set && ifs_is_null == 0 && ifs_firstc[0] != ' ')
#else
	  if (tt[0] == '@' && tt[1] == RBRACK && var && quoted == 0 && ifs_is_set && ifs_is_null == 0 && ifs_firstc != ' ')
#endif
	    temp = array_value (name, Q_DOUBLE_QUOTES, AV_ASSIGNRHS, &atype, &ind);
	  else if (tt[0] == '@' && tt[1] == RBRACK)
	    temp = array_value (name, quoted, 0, &atype, &ind);
	  else if (tt[0] == '*' && tt[1] == RBRACK && expand_no_split_dollar_star && ifs_is_null)
	    temp = array_value (name, Q_DOUBLE_QUOTES|Q_HERE_DOCUMENT, 0, &atype, &ind);
	  else if (tt[0] == '*' && tt[1] == RBRACK)
	    temp = array_value (name, quoted, 0, &atype, &ind);
	  else
	    temp = array_value (name, quoted, 0, &atype, &ind);
	}	  	  
      else if (tt[0] == '*' && tt[1] == RBRACK && expand_no_split_dollar_star && ifs_is_null)
	temp = array_value (name, Q_DOUBLE_QUOTES|Q_HERE_DOCUMENT, 0, &atype, &ind);
      else
	temp = array_value (name, quoted, 0, &atype, &ind);
      if (atype == 0 && temp)
	{
	  temp = (*temp && (quoted & (Q_DOUBLE_QUOTES|Q_HERE_DOCUMENT)))
		    ? quote_string (temp)
		    : quote_escapes (temp);
	  rflags |= W_ARRAYIND;
	  if (indp)
	    *indp = ind;
	} 		  
      else if (atype == 1 && temp && QUOTED_NULL (temp) && (quoted & (Q_DOUBLE_QUOTES|Q_HERE_DOCUMENT)))
	rflags |= W_HASQUOTEDNULL;
    }
#endif
  else if (var = find_variable (name))
    {
      if (var_isset (var) && invisible_p (var) == 0)
	{
#if defined (ARRAY_VARS)
	  /* We avoid a memory leak by saving TT as the memory allocated by
	     assoc_to_string or array_to_string and leaving it 0 otherwise,
	     then freeing TT after quoting temp. */
	  tt = (char *)NULL;
	  if ((pflags & PF_ALLINDS) && assoc_p (var))
	    tt = temp = assoc_empty (assoc_cell (var)) ? (char *)NULL : assoc_to_string (assoc_cell (var), " ", quoted);
	  else if ((pflags & PF_ALLINDS) && array_p (var))
	    tt = temp = array_empty (array_cell (var)) ? (char *)NULL : array_to_string (array_cell (var), " ", quoted);
	  else if (assoc_p (var))
	    temp = assoc_reference (assoc_cell (var), "0");
	  else if (array_p (var))
	    temp = array_reference (array_cell (var), 0);
	  else
	    temp = value_cell (var);
#else
	  temp = value_cell (var);
#endif

	  if (temp)
	    temp = (*temp && (quoted & (Q_DOUBLE_QUOTES|Q_HERE_DOCUMENT)))
		      ? quote_string (temp)
		      : ((pflags & PF_ASSIGNRHS) ? quote_rhs (temp)
						 : quote_escapes (temp));
	  FREE (tt);
	}
      else
	temp = (char *)NULL;
    }
  else if (var = find_variable_last_nameref (name, 0))
    {
      temp = nameref_cell (var);
#if defined (ARRAY_VARS)
      /* Handle expanding nameref whose value is x[n] */
      if (temp && *temp && valid_array_reference (temp, 0))
	{
	  name = temp;
	  goto expand_arrayref;
	}
      else
#endif
      /* y=2 ; typeset -n x=y; echo ${x} is not the same as echo ${2} in ksh */
      if (temp && *temp && legal_identifier (temp) == 0)
        {
	  set_exit_status (EXECUTION_FAILURE);
	  report_error (_("%s: invalid variable name for name reference"), temp);
	  temp = &expand_param_error;
        }
      else
	temp = (char *)NULL;
    }
  else
    temp = (char *)NULL;

  if (ret == 0)
    {
      ret = alloc_word_desc ();
      ret->word = temp;
      ret->flags |= rflags;
    }
  return ret;
}
warning: parse error {
  WORD_DESC *ret;
  char *temp, *tt;
  intmax_t arg_index;
  SHELL_VAR *var;
  int atype, rflags;
  arrayind_t ind;

  ret = 0;
  temp = 0;
  rflags = 0;

  if (indp)
    *indp = INTMAX_MIN;

  /* Handle multiple digit arguments, as in ${11}. */  
  if (legal_number (name, &arg_index))
    {
      tt = get_dollar_var_value (arg_index);
      if (tt)
 	temp = (*tt && (quoted & (Q_DOUBLE_QUOTES|Q_HERE_DOCUMENT)))
 		  ? quote_string (tt)
 		  : quote_escapes (tt);
      else
        temp = (char *)NULL;
      FREE (tt);
    }
  else if (var_is_special)      /* ${@} */
    {
      int sindex;
      tt = (char *)xmalloc (2 + strlen (name));
      tt[sindex = 0] = '$';
      strcpy (tt + 1, name);

      ret = param_expand (tt, &sindex, quoted, (int *)NULL, (int *)NULL,
			  (int *)NULL, (int *)NULL, pflags);
      free (tt);
    }
#if defined (ARRAY_VARS)
  else if (valid_array_reference (name, 0))
    {
expand_arrayref:
      var = array_variable_part (name, 0, &tt, (int *)0);
      /* These are the cases where word splitting will not be performed */
      if (pflags & PF_ASSIGNRHS)
	{
	  if (ALL_ELEMENT_SUB (tt[0]) && tt[1] == RBRACK)
	    {
	      /* Only treat as double quoted if array variable */
	      if (var && (array_p (var) || assoc_p (var)))
		temp = array_value (name, quoted|Q_DOUBLE_QUOTES, AV_ASSIGNRHS, &atype, &ind);
	      else		
		temp = array_value (name, quoted, 0, &atype, &ind);
	    }
	  else
	    temp = array_value (name, quoted, 0, &atype, &ind);
	}
      /* Posix interp 888 */
      else if (pflags & PF_NOSPLIT2)
	{
	  /* Special cases, then general case, for each of A[@], A[*], A[n] */
#if defined (HANDLE_MULTIBYTE)
          if (tt[0] == '@' && tt[1] == RBRACK && var && quoted == 0 && ifs_is_set && ifs_is_null == 0 && ifs_firstc[0] != ' ')
#else
	  if (tt[0] == '@' && tt[1] == RBRACK && var && quoted == 0 && ifs_is_set && ifs_is_null == 0 && ifs_firstc != ' ')
#endif
	    temp = array_value (name, Q_DOUBLE_QUOTES, AV_ASSIGNRHS, &atype, &ind);
	  else if (tt[0] == '@' && tt[1] == RBRACK)
	    temp = array_value (name, quoted, 0, &atype, &ind);
	  else if (tt[0] == '*' && tt[1] == RBRACK && expand_no_split_dollar_star && ifs_is_null)
	    temp = array_value (name, Q_DOUBLE_QUOTES|Q_HERE_DOCUMENT, 0, &atype, &ind);
	  else if (tt[0] == '*' && tt[1] == RBRACK)
	    temp = array_value (name, quoted, 0, &atype, &ind);
	  else
	    temp = array_value (name, quoted, 0, &atype, &ind);
	}	  	  
      else if (tt[0] == '*' && tt[1] == RBRACK && expand_no_split_dollar_star && ifs_is_null)
	temp = array_value (name, Q_DOUBLE_QUOTES|Q_HERE_DOCUMENT, 0, &atype, &ind);
      else
	temp = array_value (name, quoted, 0, &atype, &ind);
      if (atype == 0 && temp)
	{
	  temp = (*temp && (quoted & (Q_DOUBLE_QUOTES|Q_HERE_DOCUMENT)))
		    ? quote_string (temp)
		    : quote_escapes (temp);
	  rflags |= W_ARRAYIND;
	  if (indp)
	    *indp = ind;
	} 		  
      else if (atype == 1 && temp && QUOTED_NULL (temp) && (quoted & (Q_DOUBLE_QUOTES|Q_HERE_DOCUMENT)))
	rflags |= W_HASQUOTEDNULL;
    }
#endif
  else if (var = find_variable (name))
    {
      if (var_isset (var) && invisible_p (var) == 0)
	{
#if defined (ARRAY_VARS)
	  /* We avoid a memory leak by saving TT as the memory allocated by
	     assoc_to_string or array_to_string and leaving it 0 otherwise,
	     then freeing TT after quoting temp. */
	  tt = (char *)NULL;
	  if ((pflags & PF_ALLINDS) && assoc_p (var))
	    tt = temp = assoc_empty (assoc_cell (var)) ? (char *)NULL : assoc_to_string (assoc_cell (var), " ", quoted);
	  else if ((pflags & PF_ALLINDS) && array_p (var))
	    tt = temp = array_empty (array_cell (var)) ? (char *)NULL : array_to_string (array_cell (var), " ", quoted);
	  else if (assoc_p (var))
	    temp = assoc_reference (assoc_cell (var), "0");
	  else if (array_p (var))
	    temp = array_reference (array_cell (var), 0);
	  else
	    temp = value_cell (var);
#else
	  temp = value_cell (var);
#endif

	  if (temp)
	    temp = (*temp && (quoted & (Q_DOUBLE_QUOTES|Q_HERE_DOCUMENT)))
		      ? quote_string (temp)
		      : ((pflags & PF_ASSIGNRHS) ? quote_rhs (temp)
						 : quote_escapes (temp));
	  FREE (tt);
	}
      else
	temp = (char *)NULL;
    }
  else if (var = find_variable_last_nameref (name, 0))
    {
      temp = nameref_cell (var);
#if defined (ARRAY_VARS)
      /* Handle expanding nameref whose value is x[n] */
      if (temp && *temp && valid_array_reference (temp, 0))
	{
	  name = temp;
	  goto expand_arrayref;
	}
      else
#endif
      /* y=2 ; typeset -n x=y; echo ${x} is not the same as echo ${2} in ksh */
      if (temp && *temp && legal_identifier (temp) == 0)
        {
	  set_exit_status (EXECUTION_FAILURE);
	  report_error (_("%s: invalid variable name for name reference"), temp);
	  temp = &expand_param_error;
        }
      else
	temp = (char *)NULL;
    }
  else
    temp = (char *)NULL;

  if (ret == 0)
    {
      ret = alloc_word_desc ();
      ret->word = temp;
      ret->flags |= rflags;
    }
  return ret;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:6,741
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:6,902
parsing error 
{
  char *temp, *t;
  WORD_DESC *w;
  SHELL_VAR *v;
  int pflags, oldex;

  if (find_nameref && var_is_special == 0 && (v = find_variable_last_nameref (name, 0)) &&
      nameref_p (v) && (t = nameref_cell (v)) && *t)
    return (savestring (t));

  /* If var_is_special == 0, and name is not an array reference, this does
     more expansion than necessary.  It should really look up the variable's
     value and not try to expand it. */
  pflags = PF_IGNUNBOUND;
  /* Note that we're not going to be doing word splitting here */
  if (var_is_special)
    {
      pflags |= PF_ASSIGNRHS;	/* suppresses word splitting */
      oldex = expand_no_split_dollar_star;
      expand_no_split_dollar_star = 1;
    }
  w = parameter_brace_expand_word (name, var_is_special, quoted, pflags, 0);
  if (var_is_special)
    expand_no_split_dollar_star = oldex;

  t = w->word;
  /* Have to dequote here if necessary */
  if (t)
    {
      temp = ((quoted & (Q_DOUBLE_QUOTES|Q_HERE_DOCUMENT)) || var_is_special)
		? dequote_string (t)
		: dequote_escapes (t);
      free (t);
      t = temp;
    }
  dispose_word_desc (w);

  return t;
}
warning: parse error {
  char *temp, *t;
  WORD_DESC *w;
  SHELL_VAR *v;
  int pflags, oldex;

  if (find_nameref && var_is_special == 0 && (v = find_variable_last_nameref (name, 0)) &&
      nameref_p (v) && (t = nameref_cell (v)) && *t)
    return (savestring (t));

  /* If var_is_special == 0, and name is not an array reference, this does
     more expansion than necessary.  It should really look up the variable's
     value and not try to expand it. */
  pflags = PF_IGNUNBOUND;
  /* Note that we're not going to be doing word splitting here */
  if (var_is_special)
    {
      pflags |= PF_ASSIGNRHS;	/* suppresses word splitting */
      oldex = expand_no_split_dollar_star;
      expand_no_split_dollar_star = 1;
    }
  w = parameter_brace_expand_word (name, var_is_special, quoted, pflags, 0);
  if (var_is_special)
    expand_no_split_dollar_star = oldex;

  t = w->word;
  /* Have to dequote here if necessary */
  if (t)
    {
      temp = ((quoted & (Q_DOUBLE_QUOTES|Q_HERE_DOCUMENT)) || var_is_special)
		? dequote_string (t)
		: dequote_escapes (t);
      free (t);
      t = temp;
    }
  dispose_word_desc (w);

  return t;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:6,905
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:6,948
parsing error 
{
  char *t;
  WORD_DESC *w;
  SHELL_VAR *v;

  /* See if it's a nameref first, behave in ksh93-compatible fashion.
     There is at least one incompatibility: given ${!foo[0]} where foo=bar,
     bash performs an indirect lookup on foo[0] and expands the result;
     ksh93 expands bar[0].  We could do that here -- there are enough usable
     primitives to do that -- but do not at this point. */
  if (var_is_special == 0 && (v = find_variable_last_nameref (name, 0)))
    {
      if (nameref_p (v) && (t = nameref_cell (v)) && *t)
	{
	  w = alloc_word_desc ();
	  w->word = savestring (t);
	  w->flags = 0;
	  return w;
	}
    }

  /* An indirect reference to a positional parameter or a special parameter
     is ok.  Indirect references to array references, as explained above, are
     ok (currently).  Only references to unset variables are errors at this
     point. */
  if (legal_identifier (name) && v == 0)
    {
      report_error (_("%s: invalid indirect expansion"), name);
      w = alloc_word_desc ();
      w->word = &expand_param_error;
      w->flags = 0;
      return (w);
    }
      
  t = parameter_brace_find_indir (name, var_is_special, quoted, 0);

  chk_atstar (t, quoted, pflags, quoted_dollar_atp, contains_dollar_at);

#if defined (ARRAY_VARS)
  /* Array references to unset variables are also an error */
  if (t == 0 && valid_array_reference (name, 0))
    {
      v = array_variable_part (name, 0, (char **)0, (int *)0);
      if (v == 0)
	{
	  report_error (_("%s: invalid indirect expansion"), name);
	  w = alloc_word_desc ();
	  w->word = &expand_param_error;
	  w->flags = 0;
	  return (w);
	}
      else
        return (WORD_DESC *)NULL;      
    }
#endif

  if (t == 0)
    return (WORD_DESC *)NULL;

  if (valid_brace_expansion_word (t, SPECIAL_VAR (t, 0)) == 0)
    {
      report_error (_("%s: invalid variable name"), t);
      free (t);
      w = alloc_word_desc ();
      w->word = &expand_param_error;
      w->flags = 0;
      return (w);
    }
	
  w = parameter_brace_expand_word (t, SPECIAL_VAR(t, 0), quoted, pflags, 0);
  free (t);

  return w;
}
warning: parse error {
  char *t;
  WORD_DESC *w;
  SHELL_VAR *v;

  /* See if it's a nameref first, behave in ksh93-compatible fashion.
     There is at least one incompatibility: given ${!foo[0]} where foo=bar,
     bash performs an indirect lookup on foo[0] and expands the result;
     ksh93 expands bar[0].  We could do that here -- there are enough usable
     primitives to do that -- but do not at this point. */
  if (var_is_special == 0 && (v = find_variable_last_nameref (name, 0)))
    {
      if (nameref_p (v) && (t = nameref_cell (v)) && *t)
	{
	  w = alloc_word_desc ();
	  w->word = savestring (t);
	  w->flags = 0;
	  return w;
	}
    }

  /* An indirect reference to a positional parameter or a special parameter
     is ok.  Indirect references to array references, as explained above, are
     ok (currently).  Only references to unset variables are errors at this
     point. */
  if (legal_identifier (name) && v == 0)
    {
      report_error (_("%s: invalid indirect expansion"), name);
      w = alloc_word_desc ();
      w->word = &expand_param_error;
      w->flags = 0;
      return (w);
    }
      
  t = parameter_brace_find_indir (name, var_is_special, quoted, 0);

  chk_atstar (t, quoted, pflags, quoted_dollar_atp, contains_dollar_at);

#if defined (ARRAY_VARS)
  /* Array references to unset variables are also an error */
  if (t == 0 && valid_array_reference (name, 0))
    {
      v = array_variable_part (name, 0, (char **)0, (int *)0);
      if (v == 0)
	{
	  report_error (_("%s: invalid indirect expansion"), name);
	  w = alloc_word_desc ();
	  w->word = &expand_param_error;
	  w->flags = 0;
	  return (w);
	}
      else
        return (WORD_DESC *)NULL;      
    }
#endif

  if (t == 0)
    return (WORD_DESC *)NULL;

  if (valid_brace_expansion_word (t, SPECIAL_VAR (t, 0)) == 0)
    {
      report_error (_("%s: invalid variable name"), t);
      free (t);
      w = alloc_word_desc ();
      w->word = &expand_param_error;
      w->flags = 0;
      return (w);
    }
	
  w = parameter_brace_expand_word (t, SPECIAL_VAR(t, 0), quoted, pflags, 0);
  free (t);

  return w;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:6,952
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:7,032
parsing error 
{
  WORD_DESC *w;
  WORD_LIST *l, *tl;
  char *t, *t1, *temp, *vname;
  int l_hasdollat, sindex;
  SHELL_VAR *v;

/*itrace("parameter_brace_expand_rhs: %s:%s pflags = %d", name, value, pflags);*/
  /* If the entire expression is between double quotes, we want to treat
     the value as a double-quoted string, with the exception that we strip
     embedded unescaped double quotes (for sh backwards compatibility). */
  if ((quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)) && *value)
    {
      sindex = 0;
      temp = string_extract_double_quoted (value, &sindex, SX_STRIPDQ);
    }
  else
    temp = value;

  w = alloc_word_desc ();
  l_hasdollat = 0;
  l = *temp ? expand_string_for_rhs (temp, quoted, op, pflags, &l_hasdollat, (int *)NULL)
	    : (WORD_LIST *)0;
  if (hasdollarat)
    *hasdollarat = l_hasdollat || (l && l->next);
  if (temp != value)
    free (temp);

  /* list_string takes multiple CTLNULs and turns them into an empty word
     with W_SAWQUOTEDNULL set. Turn it back into a single CTLNUL for the
     rest of this function and the caller. */
  for (tl = l; tl; tl = tl->next)
    {
      if (tl->word && (tl->word->word == 0 || tl->word->word[0] == 0) &&
	    (tl->word->flags | W_SAWQUOTEDNULL))
	{
	  t = make_quoted_char ('\0');
	  FREE (tl->word->word);
	  tl->word->word = t;
	  tl->word->flags |= W_QUOTED|W_HASQUOTEDNULL;
	  tl->word->flags &= ~W_SAWQUOTEDNULL;
	}
    }

  if (l)
    {
      /* If l->next is not null, we know that TEMP contained "$@", since that
	 is the only expansion that creates more than one word. */
      if (qdollaratp && ((l_hasdollat && quoted) || l->next))
	{
/*itrace("parameter_brace_expand_rhs: %s:%s: l != NULL, set *qdollaratp", name, value);*/
	  *qdollaratp = 1;
	}

      /* The expansion of TEMP returned something.  We need to treat things
	  slightly differently if L_HASDOLLAT is non-zero.  If we have "$@",
	  the individual words have already been quoted.  We need to turn them
	  into a string with the words separated by the first character of
	  $IFS without any additional quoting, so string_list_dollar_at won't
	  do the right thing.  If IFS is null, we want "$@" to split into
	  separate arguments, not be concatenated, so we use string_list_internal
	  and mark the word to be split on spaces later.  We use
	  string_list_dollar_star for "$@" otherwise. */
      if (l->next && ifs_is_null)
	{
	  temp = string_list_internal (l, " ");
	  w->flags |= W_SPLITSPACE;
	}
      else if (l_hasdollat || l->next)
	temp = string_list_dollar_star (l, quoted, 0);
      else
	{
	  temp = string_list (l);
	  if (temp && (QUOTED_NULL (temp) == 0) && (l->word->flags & W_SAWQUOTEDNULL))
	    w->flags |= W_SAWQUOTEDNULL;	/* XXX */
	}

      /* If we have a quoted null result (QUOTED_NULL(temp)) and the word is
	 a quoted null (l->next == 0 && QUOTED_NULL(l->word->word)), the
	 flags indicate it (l->word->flags & W_HASQUOTEDNULL), and the
	 expansion is quoted (quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES))
	 (which is more paranoia than anything else), we need to return the
	 quoted null string and set the flags to indicate it. */
      if (l->next == 0 && (quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)) && QUOTED_NULL (temp) && QUOTED_NULL (l->word->word) && (l->word->flags & W_HASQUOTEDNULL))
	{
	  w->flags |= W_HASQUOTEDNULL;
/*itrace("parameter_brace_expand_rhs (%s:%s): returning quoted null, turning off qdollaratp", name, value);*/
	  /* If we return a quoted null with L_HASDOLLARAT, we either have a
	     construct like "${@-$@}" or "${@-${@-$@}}" with no positional
	     parameters or a quoted expansion of "$@" with $1 == ''.  In either
	     case, we don't want to enable special handling of $@. */
	  if (qdollaratp && l_hasdollat)
	    *qdollaratp = 0;
	}
      dispose_words (l);
    }
  else if ((quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)) && l_hasdollat)
    {
      /* Posix interp 221 changed the rules on this.  The idea is that
	 something like "$xxx$@" should expand the same as "${foo-$xxx$@}"
	 when foo and xxx are unset.  The problem is that it's not in any
	 way backwards compatible and few other shells do it.  We're eventually
	 going to try and split the difference (heh) a little bit here. */
      /* l_hasdollat == 1 means we saw a quoted dollar at.  */

      /* The brace expansion occurred between double quotes and there was
	 a $@ in TEMP.  It does not matter if the $@ is quoted, as long as
	 it does not expand to anything.  In this case, we want to return
	 a quoted empty string.  Posix interp 888 */
      temp = make_quoted_char ('\0');
      w->flags |= W_HASQUOTEDNULL;
/*itrace("parameter_brace_expand_rhs (%s:%s): returning quoted null", name, value);*/
    }
  else
    temp = (char *)NULL;

  if (op == '-' || op == '+')
    {
      w->word = temp;
      return w;
    }

  /* op == '=' */
  t1 = temp ? dequote_string (temp) : savestring ("");
  free (temp);

  /* bash-4.4/5.0 */
  vname = name;
  if (*name == '!' &&
      (legal_variable_starter ((unsigned char)name[1]) || DIGIT (name[1]) || VALID_INDIR_PARAM (name[1])))
    {
      vname = parameter_brace_find_indir (name + 1, SPECIAL_VAR (name, 1), quoted, 1);
      if (vname == 0 || *vname == 0)
	{
	  report_error (_("%s: invalid indirect expansion"), name);
	  free (vname);
	  free (t1);
	  dispose_word (w);
	  return &expand_wdesc_error;
	}
      if (legal_identifier (vname) == 0)
	{
	  report_error (_("%s: invalid variable name"), vname);
	  free (vname);
	  free (t1);
	  dispose_word (w);
	  return &expand_wdesc_error;
	}
    }
    
#if defined (ARRAY_VARS)
  if (valid_array_reference (vname, 0))
    v = assign_array_element (vname, t1, 0);
  else
#endif /* ARRAY_VARS */
  v = bind_variable (vname, t1, 0);

  if (v == 0 || readonly_p (v) || noassign_p (v))	/* expansion error  */
    {
      if ((v == 0 || readonly_p (v)) && interactive_shell == 0 && posixly_correct)
	{
	  last_command_exit_value = EXECUTION_FAILURE;
	  exp_jump_to_top_level (FORCE_EOF);
	}
      else
	{
	  if (vname != name)
	    free (vname);
	  last_command_exit_value = EX_BADUSAGE;
	  exp_jump_to_top_level (DISCARD);
	}
    }

  stupidly_hack_special_variables (vname);

  if (vname != name)
    free (vname);

  /* From Posix group discussion Feb-March 2010.  Issue 7 0000221 */

  /* If we are double-quoted or if we are not going to be performing word
     splitting, we want to quote the value we return appropriately, like
     the other expansions this function handles. */
  w->word = (quoted & (Q_DOUBLE_QUOTES|Q_HERE_DOCUMENT)) ? quote_string (t1) : quote_escapes (t1);
  /* If we have something that's non-null, that's not a quoted null string,
     and we're not going to be performing word splitting (we know we're not
     because the operator is `='), we can forget we saw a quoted null. */
  if (w->word && w->word[0] && QUOTED_NULL (w->word) == 0)
    w->flags &= ~W_SAWQUOTEDNULL;
  free (t1);

  /* If we convert a null string into a quoted null, make sure the caller
     knows it. */
  if ((quoted & (Q_DOUBLE_QUOTES|Q_HERE_DOCUMENT)) && QUOTED_NULL (w->word))
    w->flags |= W_HASQUOTEDNULL;

  return w;
}
warning: parse error {
  WORD_DESC *w;
  WORD_LIST *l, *tl;
  char *t, *t1, *temp, *vname;
  int l_hasdollat, sindex;
  SHELL_VAR *v;

/*itrace("parameter_brace_expand_rhs: %s:%s pflags = %d", name, value, pflags);*/
  /* If the entire expression is between double quotes, we want to treat
     the value as a double-quoted string, with the exception that we strip
     embedded unescaped double quotes (for sh backwards compatibility). */
  if ((quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)) && *value)
    {
      sindex = 0;
      temp = string_extract_double_quoted (value, &sindex, SX_STRIPDQ);
    }
  else
    temp = value;

  w = alloc_word_desc ();
  l_hasdollat = 0;
  l = *temp ? expand_string_for_rhs (temp, quoted, op, pflags, &l_hasdollat, (int *)NULL)
	    : (WORD_LIST *)0;
  if (hasdollarat)
    *hasdollarat = l_hasdollat || (l && l->next);
  if (temp != value)
    free (temp);

  /* list_string takes multiple CTLNULs and turns them into an empty word
     with W_SAWQUOTEDNULL set. Turn it back into a single CTLNUL for the
     rest of this function and the caller. */
  for (tl = l; tl; tl = tl->next)
    {
      if (tl->word && (tl->word->word == 0 || tl->word->word[0] == 0) &&
	    (tl->word->flags | W_SAWQUOTEDNULL))
	{
	  t = make_quoted_char ('\0');
	  FREE (tl->word->word);
	  tl->word->word = t;
	  tl->word->flags |= W_QUOTED|W_HASQUOTEDNULL;
	  tl->word->flags &= ~W_SAWQUOTEDNULL;
	}
    }

  if (l)
    {
      /* If l->next is not null, we know that TEMP contained "$@", since that
	 is the only expansion that creates more than one word. */
      if (qdollaratp && ((l_hasdollat && quoted) || l->next))
	{
/*itrace("parameter_brace_expand_rhs: %s:%s: l != NULL, set *qdollaratp", name, value);*/
	  *qdollaratp = 1;
	}

      /* The expansion of TEMP returned something.  We need to treat things
	  slightly differently if L_HASDOLLAT is non-zero.  If we have "$@",
	  the individual words have already been quoted.  We need to turn them
	  into a string with the words separated by the first character of
	  $IFS without any additional quoting, so string_list_dollar_at won't
	  do the right thing.  If IFS is null, we want "$@" to split into
	  separate arguments, not be concatenated, so we use string_list_internal
	  and mark the word to be split on spaces later.  We use
	  string_list_dollar_star for "$@" otherwise. */
      if (l->next && ifs_is_null)
	{
	  temp = string_list_internal (l, " ");
	  w->flags |= W_SPLITSPACE;
	}
      else if (l_hasdollat || l->next)
	temp = string_list_dollar_star (l, quoted, 0);
      else
	{
	  temp = string_list (l);
	  if (temp && (QUOTED_NULL (temp) == 0) && (l->word->flags & W_SAWQUOTEDNULL))
	    w->flags |= W_SAWQUOTEDNULL;	/* XXX */
	}

      /* If we have a quoted null result (QUOTED_NULL(temp)) and the word is
	 a quoted null (l->next == 0 && QUOTED_NULL(l->word->word)), the
	 flags indicate it (l->word->flags & W_HASQUOTEDNULL), and the
	 expansion is quoted (quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES))
	 (which is more paranoia than anything else), we need to return the
	 quoted null string and set the flags to indicate it. */
      if (l->next == 0 && (quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)) && QUOTED_NULL (temp) && QUOTED_NULL (l->word->word) && (l->word->flags & W_HASQUOTEDNULL))
	{
	  w->flags |= W_HASQUOTEDNULL;
/*itrace("parameter_brace_expand_rhs (%s:%s): returning quoted null, turning off qdollaratp", name, value);*/
	  /* If we return a quoted null with L_HASDOLLARAT, we either have a
	     construct like "${@-$@}" or "${@-${@-$@}}" with no positional
	     parameters or a quoted expansion of "$@" with $1 == ''.  In either
	     case, we don't want to enable special handling of $@. */
	  if (qdollaratp && l_hasdollat)
	    *qdollaratp = 0;
	}
      dispose_words (l);
    }
  else if ((quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)) && l_hasdollat)
    {
      /* Posix interp 221 changed the rules on this.  The idea is that
	 something like "$xxx$@" should expand the same as "${foo-$xxx$@}"
	 when foo and xxx are unset.  The problem is that it's not in any
	 way backwards compatible and few other shells do it.  We're eventually
	 going to try and split the difference (heh) a little bit here. */
      /* l_hasdollat == 1 means we saw a quoted dollar at.  */

      /* The brace expansion occurred between double quotes and there was
	 a $@ in TEMP.  It does not matter if the $@ is quoted, as long as
	 it does not expand to anything.  In this case, we want to return
	 a quoted empty string.  Posix interp 888 */
      temp = make_quoted_char ('\0');
      w->flags |= W_HASQUOTEDNULL;
/*itrace("parameter_brace_expand_rhs (%s:%s): returning quoted null", name, value);*/
    }
  else
    temp = (char *)NULL;

  if (op == '-' || op == '+')
    {
      w->word = temp;
      return w;
    }

  /* op == '=' */
  t1 = temp ? dequote_string (temp) : savestring ("");
  free (temp);

  /* bash-4.4/5.0 */
  vname = name;
  if (*name == '!' &&
      (legal_variable_starter ((unsigned char)name[1]) || DIGIT (name[1]) || VALID_INDIR_PARAM (name[1])))
    {
      vname = parameter_brace_find_indir (name + 1, SPECIAL_VAR (name, 1), quoted, 1);
      if (vname == 0 || *vname == 0)
	{
	  report_error (_("%s: invalid indirect expansion"), name);
	  free (vname);
	  free (t1);
	  dispose_word (w);
	  return &expand_wdesc_error;
	}
      if (legal_identifier (vname) == 0)
	{
	  report_error (_("%s: invalid variable name"), vname);
	  free (vname);
	  free (t1);
	  dispose_word (w);
	  return &expand_wdesc_error;
	}
    }
    
#if defined (ARRAY_VARS)
  if (valid_array_reference (vname, 0))
    v = assign_array_element (vname, t1, 0);
  else
#endif /* ARRAY_VARS */
  v = bind_variable (vname, t1, 0);

  if (v == 0 || readonly_p (v) || noassign_p (v))	/* expansion error  */
    {
      if ((v == 0 || readonly_p (v)) && interactive_shell == 0 && posixly_correct)
	{
	  last_command_exit_value = EXECUTION_FAILURE;
	  exp_jump_to_top_level (FORCE_EOF);
	}
      else
	{
	  if (vname != name)
	    free (vname);
	  last_command_exit_value = EX_BADUSAGE;
	  exp_jump_to_top_level (DISCARD);
	}
    }

  stupidly_hack_special_variables (vname);

  if (vname != name)
    free (vname);

  /* From Posix group discussion Feb-March 2010.  Issue 7 0000221 */

  /* If we are double-quoted or if we are not going to be performing word
     splitting, we want to quote the value we return appropriately, like
     the other expansions this function handles. */
  w->word = (quoted & (Q_DOUBLE_QUOTES|Q_HERE_DOCUMENT)) ? quote_string (t1) : quote_escapes (t1);
  /* If we have something that's non-null, that's not a quoted null string,
     and we're not going to be performing word splitting (we know we're not
     because the operator is `='), we can forget we saw a quoted null. */
  if (w->word && w->word[0] && QUOTED_NULL (w->word) == 0)
    w->flags &= ~W_SAWQUOTEDNULL;
  free (t1);

  /* If we convert a null string into a quoted null, make sure the caller
     knows it. */
  if ((quoted & (Q_DOUBLE_QUOTES|Q_HERE_DOCUMENT)) && QUOTED_NULL (w->word))
    w->flags |= W_HASQUOTEDNULL;

  return w;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:7,035
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:7,239
parsing error 
{
  WORD_LIST *l;
  char *temp;

  set_exit_status (EXECUTION_FAILURE);	/* ensure it's non-zero */
  if (value && *value)
    {
      l = expand_string (value, 0);
      temp =  string_list (l);
      report_error ("%s: %s", name, temp ? temp : "");	/* XXX was value not "" */
      FREE (temp);
      dispose_words (l);
    }
  else if (check_null == 0)
    report_error (_("%s: parameter not set"), name);
  else
    report_error (_("%s: parameter null or not set"), name);

  /* Free the data we have allocated during this expansion, since we
     are about to longjmp out. */
  free (name);
  FREE (value);
}
warning: parse error {
  WORD_LIST *l;
  char *temp;

  set_exit_status (EXECUTION_FAILURE);	/* ensure it's non-zero */
  if (value && *value)
    {
      l = expand_string (value, 0);
      temp =  string_list (l);
      report_error ("%s: %s", name, temp ? temp : "");	/* XXX was value not "" */
      FREE (temp);
      dispose_words (l);
    }
  else if (check_null == 0)
    report_error (_("%s: parameter not set"), name);
  else
    report_error (_("%s: parameter null or not set"), name);

  /* Free the data we have allocated during this expansion, since we
     are about to longjmp out. */
  free (name);
  FREE (value);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:7,242
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:7,269
parsing error 
{
  return (name[1] == '\0' ||					/* ${#} */
	  ((sh_syntaxtab[(unsigned char) name[1]] & CSPECVAR) && name[2] == '\0') ||  /* special param */
	  (DIGIT (name[1]) && all_digits (name + 1)) ||	/* ${#11} */
#if defined (ARRAY_VARS)
	  valid_array_reference (name + 1, 0) ||		/* ${#a[7]} */
#endif
	  legal_identifier (name + 1));				/* ${#PS1} */
}
warning: parse error {
  return (name[1] == '\0' ||					/* ${#} */
	  ((sh_syntaxtab[(unsigned char) name[1]] & CSPECVAR) && name[2] == '\0') ||  /* special param */
	  (DIGIT (name[1]) && all_digits (name + 1)) ||	/* ${#11} */
#if defined (ARRAY_VARS)
	  valid_array_reference (name + 1, 0) ||		/* ${#a[7]} */
#endif
	  legal_identifier (name + 1));				/* ${#PS1} */
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:7,271
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:7,284
parsing error 
{
  char *t, *newname;
  intmax_t number, arg_index;
  WORD_LIST *list;
  SHELL_VAR *var;

  var = (SHELL_VAR *)NULL;

  if (name[1] == '\0')			/* ${#} */
    number = number_of_args ();
  else if (DOLLAR_AT_STAR (name[1]) && name[2] == '\0')	/* ${#@}, ${#*} */
    number = number_of_args ();
  else if ((sh_syntaxtab[(unsigned char) name[1]] & CSPECVAR) && name[2] == '\0')
    {
      /* Take the lengths of some of the shell's special parameters. */
      switch (name[1])
	{
	case '-':
	  t = which_set_flags ();
	  break;
	case '?':
	  t = itos (last_command_exit_value);
	  break;
	case '$':
	  t = itos (dollar_dollar_pid);
	  break;
	case '!':
	  if (last_asynchronous_pid == NO_PID)
	    t = (char *)NULL;	/* XXX - error if set -u set? */
	  else
	    t = itos (last_asynchronous_pid);
	  break;
	case '#':
	  t = itos (number_of_args ());
	  break;
	}
      number = STRLEN (t);
      FREE (t);
    }
#if defined (ARRAY_VARS)
  else if (valid_array_reference (name + 1, 0))
    number = array_length_reference (name + 1);
#endif /* ARRAY_VARS */
  else
    {
      number = 0;

      if (legal_number (name + 1, &arg_index))		/* ${#1} */
	{
	  t = get_dollar_var_value (arg_index);
	  if (t == 0 && unbound_vars_is_error)
	    return INTMAX_MIN;
	  number = MB_STRLEN (t);
	  FREE (t);
	}
#if defined (ARRAY_VARS)
      else if ((var = find_variable (name + 1)) && (invisible_p (var) == 0) && (array_p (var) || assoc_p (var)))
	{
	  if (assoc_p (var))
	    t = assoc_reference (assoc_cell (var), "0");
	  else
	    t = array_reference (array_cell (var), 0);
	  if (t == 0 && unbound_vars_is_error)
	    return INTMAX_MIN;
	  number = MB_STRLEN (t);
	}
#endif
      /* Fast path for the common case of taking the length of a non-dynamic
	 scalar variable value. */
      else if ((var || (var = find_variable (name + 1))) &&
      		invisible_p (var) == 0 &&
		array_p (var) == 0 && assoc_p (var) == 0 &&
		var->dynamic_value == 0)
	number = value_cell (var) ? MB_STRLEN (value_cell (var)) : 0;
      else if (var == 0 && unbound_vars_is_error == 0)
	number = 0;
      else				/* ${#PS1} */
	{
	  newname = savestring (name);
	  newname[0] = '$';
	  list = expand_string (newname, Q_DOUBLE_QUOTES);
	  t = list ? string_list (list) : (char *)NULL;
	  free (newname);
	  if (list)
	    dispose_words (list);

	  number = t ? MB_STRLEN (t) : 0;
	  FREE (t);
	}
    }

  return (number);
}
warning: parse error {
  char *t, *newname;
  intmax_t number, arg_index;
  WORD_LIST *list;
  SHELL_VAR *var;

  var = (SHELL_VAR *)NULL;

  if (name[1] == '\0')			/* ${#} */
    number = number_of_args ();
  else if (DOLLAR_AT_STAR (name[1]) && name[2] == '\0')	/* ${#@}, ${#*} */
    number = number_of_args ();
  else if ((sh_syntaxtab[(unsigned char) name[1]] & CSPECVAR) && name[2] == '\0')
    {
      /* Take the lengths of some of the shell's special parameters. */
      switch (name[1])
	{
	case '-':
	  t = which_set_flags ();
	  break;
	case '?':
	  t = itos (last_command_exit_value);
	  break;
	case '$':
	  t = itos (dollar_dollar_pid);
	  break;
	case '!':
	  if (last_asynchronous_pid == NO_PID)
	    t = (char *)NULL;	/* XXX - error if set -u set? */
	  else
	    t = itos (last_asynchronous_pid);
	  break;
	case '#':
	  t = itos (number_of_args ());
	  break;
	}
      number = STRLEN (t);
      FREE (t);
    }
#if defined (ARRAY_VARS)
  else if (valid_array_reference (name + 1, 0))
    number = array_length_reference (name + 1);
#endif /* ARRAY_VARS */
  else
    {
      number = 0;

      if (legal_number (name + 1, &arg_index))		/* ${#1} */
	{
	  t = get_dollar_var_value (arg_index);
	  if (t == 0 && unbound_vars_is_error)
	    return INTMAX_MIN;
	  number = MB_STRLEN (t);
	  FREE (t);
	}
#if defined (ARRAY_VARS)
      else if ((var = find_variable (name + 1)) && (invisible_p (var) == 0) && (array_p (var) || assoc_p (var)))
	{
	  if (assoc_p (var))
	    t = assoc_reference (assoc_cell (var), "0");
	  else
	    t = array_reference (array_cell (var), 0);
	  if (t == 0 && unbound_vars_is_error)
	    return INTMAX_MIN;
	  number = MB_STRLEN (t);
	}
#endif
      /* Fast path for the common case of taking the length of a non-dynamic
	 scalar variable value. */
      else if ((var || (var = find_variable (name + 1))) &&
      		invisible_p (var) == 0 &&
		array_p (var) == 0 && assoc_p (var) == 0 &&
		var->dynamic_value == 0)
	number = value_cell (var) ? MB_STRLEN (value_cell (var)) : 0;
      else if (var == 0 && unbound_vars_is_error == 0)
	number = 0;
      else				/* ${#PS1} */
	{
	  newname = savestring (name);
	  newname[0] = '$';
	  list = expand_string (newname, Q_DOUBLE_QUOTES);
	  t = list ? string_list (list) : (char *)NULL;
	  free (newname);
	  if (list)
	    dispose_words (list);

	  number = t ? MB_STRLEN (t) : 0;
	  FREE (t);
	}
    }

  return (number);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:7,286
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:7,389
parsing error 
{
  int i;
  char delims[2];

  delims[0] = delim;
  delims[1] = '\0';

  i = skip_to_delim (substr, 0, delims, SD_ARITHEXP);
  return (substr + i);
}
warning: parse error {
  int i;
  char delims[2];

  delims[0] = delim;
  delims[1] = '\0';

  i = skip_to_delim (substr, 0, delims, SD_ARITHEXP);
  return (substr + i);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:7,392
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:7,410
parsing error 
{
  char *t, *temp1, *temp2;
  arrayind_t len;
  int expok;
#if defined (ARRAY_VARS)
 ARRAY *a;
 HASH_TABLE *h;
#endif

  /* duplicate behavior of strchr(3) */
  t = skiparith (substr, ':');
  if (*t && *t == ':')
    *t = '\0';
  else
    t = (char *)0;

  temp1 = expand_arith_string (substr, Q_DOUBLE_QUOTES);
  *e1p = evalexp (temp1, 0, &expok);		/* XXX - EXP_EXPANDED? */
  free (temp1);
  if (expok == 0)
    return (0);

  len = -1;	/* paranoia */
  switch (vtype)
    {
    case VT_VARIABLE:
    case VT_ARRAYMEMBER:
      len = MB_STRLEN (value);
      break;
    case VT_POSPARMS:
      len = number_of_args () + 1;
      if (*e1p == 0)
	len++;		/* add one arg if counting from $0 */
      break;
#if defined (ARRAY_VARS)
    case VT_ARRAYVAR:
      /* For arrays, the first value deals with array indices.  Negative
	 offsets count from one past the array's maximum index.  Associative
	 arrays treat the number of elements as the maximum index. */
      if (assoc_p (v))
	{
	  h = assoc_cell (v);
	  len = assoc_num_elements (h) + (*e1p < 0);
	}
      else
	{
	  a = (ARRAY *)value;
	  len = array_max_index (a) + (*e1p < 0);	/* arrays index from 0 to n - 1 */
	}
      break;
#endif
    }

  if (len == -1)	/* paranoia */
    return -1;

  if (*e1p < 0)		/* negative offsets count from end */
    *e1p += len;

  if (*e1p > len || *e1p < 0)
    return (-1);

#if defined (ARRAY_VARS)
  /* For arrays, the second offset deals with the number of elements. */
  if (vtype == VT_ARRAYVAR)
    len = assoc_p (v) ? assoc_num_elements (h) : array_num_elements (a);
#endif

  if (t)
    {
      t++;
      temp2 = savestring (t);
      temp1 = expand_arith_string (temp2, Q_DOUBLE_QUOTES);
      free (temp2);
      t[-1] = ':';
      *e2p = evalexp (temp1, 0, &expok);	/* XXX - EXP_EXPANDED? */
      free (temp1);
      if (expok == 0)
	return (0);

      /* Should we allow positional parameter length < 0 to count backwards
	 from end of positional parameters? */
#if 1
      if ((vtype == VT_ARRAYVAR || vtype == VT_POSPARMS) && *e2p < 0)
#else /* TAG: bash-5.2 */
      if (vtype == VT_ARRAYVAR && *e2p < 0)
#endif
	{
	  internal_error (_("%s: substring expression < 0"), t);
	  return (0);
	}
#if defined (ARRAY_VARS)
      /* In order to deal with sparse arrays, push the intelligence about how
	 to deal with the number of elements desired down to the array-
	 specific functions.  */
      if (vtype != VT_ARRAYVAR)
#endif
	{
	  if (*e2p < 0)
	    {
	      *e2p += len;
	      if (*e2p < 0 || *e2p < *e1p)
		{
		  internal_error (_("%s: substring expression < 0"), t);
		  return (0);
		}
	    }
	  else
	    *e2p += *e1p;		/* want E2 chars starting at E1 */
	  if (*e2p > len)
	    *e2p = len;
	}
    }
  else
    *e2p = len;

  return (1);
}
warning: parse error {
  char *t, *temp1, *temp2;
  arrayind_t len;
  int expok;
#if defined (ARRAY_VARS)
 ARRAY *a;
 HASH_TABLE *h;
#endif

  /* duplicate behavior of strchr(3) */
  t = skiparith (substr, ':');
  if (*t && *t == ':')
    *t = '\0';
  else
    t = (char *)0;

  temp1 = expand_arith_string (substr, Q_DOUBLE_QUOTES);
  *e1p = evalexp (temp1, 0, &expok);		/* XXX - EXP_EXPANDED? */
  free (temp1);
  if (expok == 0)
    return (0);

  len = -1;	/* paranoia */
  switch (vtype)
    {
    case VT_VARIABLE:
    case VT_ARRAYMEMBER:
      len = MB_STRLEN (value);
      break;
    case VT_POSPARMS:
      len = number_of_args () + 1;
      if (*e1p == 0)
	len++;		/* add one arg if counting from $0 */
      break;
#if defined (ARRAY_VARS)
    case VT_ARRAYVAR:
      /* For arrays, the first value deals with array indices.  Negative
	 offsets count from one past the array's maximum index.  Associative
	 arrays treat the number of elements as the maximum index. */
      if (assoc_p (v))
	{
	  h = assoc_cell (v);
	  len = assoc_num_elements (h) + (*e1p < 0);
	}
      else
	{
	  a = (ARRAY *)value;
	  len = array_max_index (a) + (*e1p < 0);	/* arrays index from 0 to n - 1 */
	}
      break;
#endif
    }

  if (len == -1)	/* paranoia */
    return -1;

  if (*e1p < 0)		/* negative offsets count from end */
    *e1p += len;

  if (*e1p > len || *e1p < 0)
    return (-1);

#if defined (ARRAY_VARS)
  /* For arrays, the second offset deals with the number of elements. */
  if (vtype == VT_ARRAYVAR)
    len = assoc_p (v) ? assoc_num_elements (h) : array_num_elements (a);
#endif

  if (t)
    {
      t++;
      temp2 = savestring (t);
      temp1 = expand_arith_string (temp2, Q_DOUBLE_QUOTES);
      free (temp2);
      t[-1] = ':';
      *e2p = evalexp (temp1, 0, &expok);	/* XXX - EXP_EXPANDED? */
      free (temp1);
      if (expok == 0)
	return (0);

      /* Should we allow positional parameter length < 0 to count backwards
	 from end of positional parameters? */
#if 1
      if ((vtype == VT_ARRAYVAR || vtype == VT_POSPARMS) && *e2p < 0)
#else /* TAG: bash-5.2 */
      if (vtype == VT_ARRAYVAR && *e2p < 0)
#endif
	{
	  internal_error (_("%s: substring expression < 0"), t);
	  return (0);
	}
#if defined (ARRAY_VARS)
      /* In order to deal with sparse arrays, push the intelligence about how
	 to deal with the number of elements desired down to the array-
	 specific functions.  */
      if (vtype != VT_ARRAYVAR)
#endif
	{
	  if (*e2p < 0)
	    {
	      *e2p += len;
	      if (*e2p < 0 || *e2p < *e1p)
		{
		  internal_error (_("%s: substring expression < 0"), t);
		  return (0);
		}
	    }
	  else
	    *e2p += *e1p;		/* want E2 chars starting at E1 */
	  if (*e2p > len)
	    *e2p = len;
	}
    }
  else
    *e2p = len;

  return (1);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:7,415
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:7,545
parsing error 
{
  int vtype, want_indir;
  char *temp, *vname;
  SHELL_VAR *v;
  arrayind_t lind;

  want_indir = *varname == '!' &&
    (legal_variable_starter ((unsigned char)varname[1]) || DIGIT (varname[1])
					|| VALID_INDIR_PARAM (varname[1]));
  if (want_indir)
    vname = parameter_brace_find_indir (varname+1, SPECIAL_VAR (varname, 1), quoted, 1);
    /* XXX - what if vname == 0 || *vname == 0 ? */
  else
    vname = varname;

  if (vname == 0)
    {
      vtype = VT_VARIABLE;
      *varp = (SHELL_VAR *)NULL;
      *valp = (char *)NULL;
      return (vtype);
    }

  /* This sets vtype to VT_VARIABLE or VT_POSPARMS */
  vtype = STR_DOLLAR_AT_STAR (vname);
  if (vtype == VT_POSPARMS && vname[0] == '*')
    vtype |= VT_STARSUB;
  *varp = (SHELL_VAR *)NULL;

#if defined (ARRAY_VARS)
  if (valid_array_reference (vname, 0))
    {
      v = array_variable_part (vname, 0, &temp, (int *)0);
      /* If we want to signal array_value to use an already-computed index,
	 set LIND to that index */
      lind = (ind != INTMAX_MIN && (flags & AV_USEIND)) ? ind : 0;
      if (v && invisible_p (v))
	{
	  vtype = VT_ARRAYMEMBER;
	  *varp = (SHELL_VAR *)NULL;
	  *valp = (char *)NULL;
	}
      if (v && (array_p (v) || assoc_p (v)))
	{
	  if (ALL_ELEMENT_SUB (temp[0]) && temp[1] == RBRACK)
	    {
	      /* Callers have to differentiate between indexed and associative */
	      vtype = VT_ARRAYVAR;
	      if (temp[0] == '*')
		vtype |= VT_STARSUB;
	      *valp = array_p (v) ? (char *)array_cell (v) : (char *)assoc_cell (v);
	    }
	  else
	    {
	      vtype = VT_ARRAYMEMBER;
	      *valp = array_value (vname, Q_DOUBLE_QUOTES, flags, (int *)NULL, &lind);
	    }
	  *varp = v;
	}
      else if (v && (ALL_ELEMENT_SUB (temp[0]) && temp[1] == RBRACK))
	{
	  vtype = VT_VARIABLE;
	  *varp = v;
	  if (quoted & (Q_DOUBLE_QUOTES|Q_HERE_DOCUMENT))
	    *valp = value ? dequote_string (value) : (char *)NULL;
	  else
	    *valp = value ? dequote_escapes (value) : (char *)NULL;
	}
      else
	{
	  vtype = VT_ARRAYMEMBER;
	  *varp = v;
	  *valp = array_value (vname, Q_DOUBLE_QUOTES, flags, (int *)NULL, &lind);
	}
    }
  else if ((v = find_variable (vname)) && (invisible_p (v) == 0) && (assoc_p (v) || array_p (v)))
    {
      vtype = VT_ARRAYMEMBER;
      *varp = v;
      *valp = assoc_p (v) ? assoc_reference (assoc_cell (v), "0") : array_reference (array_cell (v), 0);
    }
  else
#endif
    {
      if (value && vtype == VT_VARIABLE)
	{
	  *varp = find_variable (vname);
	  if (quoted & (Q_DOUBLE_QUOTES|Q_HERE_DOCUMENT))
	    *valp = dequote_string (value);
	  else
	    *valp = dequote_escapes (value);
	}
      else
	*valp = value;
    }

  if (want_indir)
    free (vname);

  return vtype;
}
warning: parse error {
  int vtype, want_indir;
  char *temp, *vname;
  SHELL_VAR *v;
  arrayind_t lind;

  want_indir = *varname == '!' &&
    (legal_variable_starter ((unsigned char)varname[1]) || DIGIT (varname[1])
					|| VALID_INDIR_PARAM (varname[1]));
  if (want_indir)
    vname = parameter_brace_find_indir (varname+1, SPECIAL_VAR (varname, 1), quoted, 1);
    /* XXX - what if vname == 0 || *vname == 0 ? */
  else
    vname = varname;

  if (vname == 0)
    {
      vtype = VT_VARIABLE;
      *varp = (SHELL_VAR *)NULL;
      *valp = (char *)NULL;
      return (vtype);
    }

  /* This sets vtype to VT_VARIABLE or VT_POSPARMS */
  vtype = STR_DOLLAR_AT_STAR (vname);
  if (vtype == VT_POSPARMS && vname[0] == '*')
    vtype |= VT_STARSUB;
  *varp = (SHELL_VAR *)NULL;

#if defined (ARRAY_VARS)
  if (valid_array_reference (vname, 0))
    {
      v = array_variable_part (vname, 0, &temp, (int *)0);
      /* If we want to signal array_value to use an already-computed index,
	 set LIND to that index */
      lind = (ind != INTMAX_MIN && (flags & AV_USEIND)) ? ind : 0;
      if (v && invisible_p (v))
	{
	  vtype = VT_ARRAYMEMBER;
	  *varp = (SHELL_VAR *)NULL;
	  *valp = (char *)NULL;
	}
      if (v && (array_p (v) || assoc_p (v)))
	{
	  if (ALL_ELEMENT_SUB (temp[0]) && temp[1] == RBRACK)
	    {
	      /* Callers have to differentiate between indexed and associative */
	      vtype = VT_ARRAYVAR;
	      if (temp[0] == '*')
		vtype |= VT_STARSUB;
	      *valp = array_p (v) ? (char *)array_cell (v) : (char *)assoc_cell (v);
	    }
	  else
	    {
	      vtype = VT_ARRAYMEMBER;
	      *valp = array_value (vname, Q_DOUBLE_QUOTES, flags, (int *)NULL, &lind);
	    }
	  *varp = v;
	}
      else if (v && (ALL_ELEMENT_SUB (temp[0]) && temp[1] == RBRACK))
	{
	  vtype = VT_VARIABLE;
	  *varp = v;
	  if (quoted & (Q_DOUBLE_QUOTES|Q_HERE_DOCUMENT))
	    *valp = value ? dequote_string (value) : (char *)NULL;
	  else
	    *valp = value ? dequote_escapes (value) : (char *)NULL;
	}
      else
	{
	  vtype = VT_ARRAYMEMBER;
	  *varp = v;
	  *valp = array_value (vname, Q_DOUBLE_QUOTES, flags, (int *)NULL, &lind);
	}
    }
  else if ((v = find_variable (vname)) && (invisible_p (v) == 0) && (assoc_p (v) || array_p (v)))
    {
      vtype = VT_ARRAYMEMBER;
      *varp = v;
      *valp = assoc_p (v) ? assoc_reference (assoc_cell (v), "0") : array_reference (array_cell (v), 0);
    }
  else
#endif
    {
      if (value && vtype == VT_VARIABLE)
	{
	  *varp = find_variable (vname);
	  if (quoted & (Q_DOUBLE_QUOTES|Q_HERE_DOCUMENT))
	    *valp = dequote_string (value);
	  else
	    *valp = dequote_escapes (value);
	}
      else
	*valp = value;
    }

  if (want_indir)
    free (vname);

  return vtype;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:7,551
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:7,660
parsing error 
{
  char flags[MAX_ATTRIBUTES], *ret, *val;
  int i;

  val = (v && (invisible_p (v) || var_isset (v) == 0)) ? (char *)NULL : sh_quote_reusable (s, 0);
  i = var_attribute_string (v, 0, flags);
  if (i == 0 && val == 0)
    return (char *)NULL;

  ret = (char *)xmalloc (i + STRLEN (val) + strlen (v->name) + 16 + MAX_ATTRIBUTES);
  if (i > 0 && val == 0)
    sprintf (ret, "declare -%s %s", flags, v->name);
  else if (i > 0)
    sprintf (ret, "declare -%s %s=%s", flags, v->name, val);
  else
    sprintf (ret, "%s=%s", v->name, val);
  free (val);
  return ret;
}
warning: parse error {
  char flags[MAX_ATTRIBUTES], *ret, *val;
  int i;

  val = (v && (invisible_p (v) || var_isset (v) == 0)) ? (char *)NULL : sh_quote_reusable (s, 0);
  i = var_attribute_string (v, 0, flags);
  if (i == 0 && val == 0)
    return (char *)NULL;

  ret = (char *)xmalloc (i + STRLEN (val) + strlen (v->name) + 16 + MAX_ATTRIBUTES);
  if (i > 0 && val == 0)
    sprintf (ret, "declare -%s %s", flags, v->name);
  else if (i > 0)
    sprintf (ret, "declare -%s %s=%s", flags, v->name, val);
  else
    sprintf (ret, "%s=%s", v->name, val);
  free (val);
  return ret;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:7,663
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:7,732
parsing error 
{
  char *temp, *ret;

  /* first, we transform the list to quote each word. */
  temp = list_transform ('Q', (SHELL_VAR *)0, list, itype, quoted);
  ret = (char *)xmalloc (strlen (temp) + 8);
  strcpy (ret, "set -- ");
  strcpy (ret + 7, temp);
  free (temp);
  return ret;
}
warning: parse error {
  char *temp, *ret;

  /* first, we transform the list to quote each word. */
  temp = list_transform ('Q', (SHELL_VAR *)0, list, itype, quoted);
  ret = (char *)xmalloc (strlen (temp) + 8);
  strcpy (ret, "set -- ");
  strcpy (ret + 7, temp);
  free (temp);
  return ret;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:7,736
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:7,749
parsing error 
{
  char *ret, flags[MAX_ATTRIBUTES], *t;
  int i;

  if (((xc == 'A' || xc == 'a') && v == 0))
    return (char *)NULL;
  else if (xc != 'a' && xc != 'A' && s == 0)
    return (char *)NULL;

  switch (xc)
    {
      /* Transformations that interrogate the variable */
      case 'a':
	i = var_attribute_string (v, 0, flags);
	ret = (i > 0) ? savestring (flags) : (char *)NULL;
	break;
      case 'A':
	ret = string_var_assignment (v, s);
	break;
      case 'K':
	ret = sh_quote_reusable (s, 0);
	break;
      /* Transformations that modify the variable's value */
      case 'E':
	t = ansiexpand (s, 0, strlen (s), (int *)0);
	ret = dequote_escapes (t);
	free (t);
	break;
      case 'P':
	ret = decode_prompt_string (s);
	break;
      case 'Q':
	ret = sh_quote_reusable (s, 0);
	break;
      case 'U':
	ret = sh_modcase (s, 0, CASE_UPPER);
	break;
      case 'u':
	ret = sh_modcase (s, 0, CASE_UPFIRST);	/* capitalize */
 	break;
      case 'L':
 	ret = sh_modcase (s, 0, CASE_LOWER);
 	break;
      default:
	ret = (char *)NULL;
	break;
    }
  return ret;
}
warning: parse error {
  char *ret, flags[MAX_ATTRIBUTES], *t;
  int i;

  if (((xc == 'A' || xc == 'a') && v == 0))
    return (char *)NULL;
  else if (xc != 'a' && xc != 'A' && s == 0)
    return (char *)NULL;

  switch (xc)
    {
      /* Transformations that interrogate the variable */
      case 'a':
	i = var_attribute_string (v, 0, flags);
	ret = (i > 0) ? savestring (flags) : (char *)NULL;
	break;
      case 'A':
	ret = string_var_assignment (v, s);
	break;
      case 'K':
	ret = sh_quote_reusable (s, 0);
	break;
      /* Transformations that modify the variable's value */
      case 'E':
	t = ansiexpand (s, 0, strlen (s), (int *)0);
	ret = dequote_escapes (t);
	free (t);
	break;
      case 'P':
	ret = decode_prompt_string (s);
	break;
      case 'Q':
	ret = sh_quote_reusable (s, 0);
	break;
      case 'U':
	ret = sh_modcase (s, 0, CASE_UPPER);
	break;
      case 'u':
	ret = sh_modcase (s, 0, CASE_UPFIRST);	/* capitalize */
 	break;
      case 'L':
 	ret = sh_modcase (s, 0, CASE_LOWER);
 	break;
      default:
	ret = (char *)NULL;
	break;
    }
  return ret;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:7,753
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:7,804
parsing error 
{
  WORD_LIST *new, *l;
  WORD_DESC *w;
  char *tword;
  int qflags;

  for (new = (WORD_LIST *)NULL, l = list; l; l = l->next)
    {
      tword = string_transform (xc, v, l->word->word);
      w = alloc_word_desc ();
      w->word = tword ? tword : savestring ("");	/* XXX */
      new = make_word_list (w, new);
    }
  l = REVERSE_LIST (new, WORD_LIST *);

  qflags = quoted;
  /* If we are expanding in a context where word splitting will not be
     performed, treat as quoted.  This changes how $* will be expanded. */
  if (itype == '*' && expand_no_split_dollar_star && ifs_is_null)
    qflags |= Q_DOUBLE_QUOTES;		/* Posix interp 888 */

  tword = string_list_pos_params (itype, l, qflags, 0);
  dispose_words (l);

  return (tword);
}
warning: parse error {
  WORD_LIST *new, *l;
  WORD_DESC *w;
  char *tword;
  int qflags;

  for (new = (WORD_LIST *)NULL, l = list; l; l = l->next)
    {
      tword = string_transform (xc, v, l->word->word);
      w = alloc_word_desc ();
      w->word = tword ? tword : savestring ("");	/* XXX */
      new = make_word_list (w, new);
    }
  l = REVERSE_LIST (new, WORD_LIST *);

  qflags = quoted;
  /* If we are expanding in a context where word splitting will not be
     performed, treat as quoted.  This changes how $* will be expanded. */
  if (itype == '*' && expand_no_split_dollar_star && ifs_is_null)
    qflags |= Q_DOUBLE_QUOTES;		/* Posix interp 888 */

  tword = string_list_pos_params (itype, l, qflags, 0);
  dispose_words (l);

  return (tword);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:7,809
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:7,837
parsing error 
{
  char *ret;
  WORD_LIST *list;

  list = list_rest_of_args ();
  if (list == 0)
    return ((char *)NULL);
  if (xc == 'A')
    ret = pos_params_assignment (list, itype, quoted);
  else
    ret = list_transform (xc, (SHELL_VAR *)0, list, itype, quoted);
  dispose_words (list);
  return (ret);
}
warning: parse error {
  char *ret;
  WORD_LIST *list;

  list = list_rest_of_args ();
  if (list == 0)
    return ((char *)NULL);
  if (xc == 'A')
    ret = pos_params_assignment (list, itype, quoted);
  else
    ret = list_transform (xc, (SHELL_VAR *)0, list, itype, quoted);
  dispose_words (list);
  return (ret);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:7,841
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:7,904
parsing error 
{
  if (xform[1])
    return 0;

  /* check for valid values of xform[0] */
  switch (xform[0])
    {
    case 'a':		/* expand to a string with just attributes */
    case 'A':		/* expand as an assignment statement with attributes */
    case 'K':		/* expand assoc array to list of key/value pairs */
    case 'E':		/* expand like $'...' */
    case 'P':		/* expand like prompt string */
    case 'Q':		/* quote reusably */
    case 'U':		/* transform to uppercase */
    case 'u':		/* tranform by capitalizing */
    case 'L':		/* transform to lowercase */
      return 1;
    default:
      return 0;
    }
}
warning: parse error {
  if (xform[1])
    return 0;

  /* check for valid values of xform[0] */
  switch (xform[0])
    {
    case 'a':		/* expand to a string with just attributes */
    case 'A':		/* expand as an assignment statement with attributes */
    case 'K':		/* expand assoc array to list of key/value pairs */
    case 'E':		/* expand like $'...' */
    case 'P':		/* expand like prompt string */
    case 'Q':		/* quote reusably */
    case 'U':		/* transform to uppercase */
    case 'u':		/* tranform by capitalizing */
    case 'L':		/* transform to lowercase */
      return 1;
    default:
      return 0;
    }
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:7,906
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:7,929
parsing error 
{
  int vtype, xc, starsub;
  char *temp1, *val, *oname;
  SHELL_VAR *v;

  xc = xform[0];
  if (value == 0 && xc != 'A' && xc != 'a')
    return ((char *)NULL);

  oname = this_command_name;
  this_command_name = varname;

  vtype = get_var_and_type (varname, value, ind, quoted, flags, &v, &val);
  if (vtype == -1)
    {
      this_command_name = oname;
      return ((char *)NULL);
    }

  if (valid_parameter_transform (xform) == 0)
    {
      this_command_name = oname;
#if 0 /* TAG: bash-5.2 Martin Schulte <gnu@schrader-schulte.de> 10/2020 */
      return (interactive_shell ? &expand_param_error : &expand_param_fatal);
#else
      return &expand_param_error;
#endif
    }

  starsub = vtype & VT_STARSUB;
  vtype &= ~VT_STARSUB;

  /* If we are asked to display the attributes of an unset variable, V will
     be NULL after the call to get_var_and_type. Double-check here. */
  if ((xc == 'a' || xc == 'A') && vtype == VT_VARIABLE && varname && v == 0)
    v = find_variable (varname);

  temp1 = (char *)NULL;		/* shut up gcc */
  switch (vtype)
    {
    case VT_VARIABLE:
    case VT_ARRAYMEMBER:
      temp1 = string_transform (xc, v, val);
      if (vtype == VT_VARIABLE)
	FREE (val);
      if (temp1)
	{
	  val = (quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES))
			? quote_string (temp1)
			: quote_escapes (temp1);
	  free (temp1);
	  temp1 = val;
	}
      break;
#if defined (ARRAY_VARS)
    case VT_ARRAYVAR:
      temp1 = array_transform (xc, v, starsub, quoted);
      if (temp1 && quoted == 0 && ifs_is_null)
	{
		/* Posix interp 888 */
	}
      else if (temp1 && ((quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)) == 0))
	{
	  val = quote_escapes (temp1);
	  free (temp1);
	  temp1 = val;
	}
      break;
#endif
    case VT_POSPARMS:
      temp1 = parameter_list_transform (xc, varname[0], quoted);
      if (temp1 && quoted == 0 && ifs_is_null)
	{
		/* Posix interp 888 */
	}
      else if (temp1 && ((quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)) == 0))
	{
	  val = quote_escapes (temp1);
	  free (temp1);
	  temp1 = val;
	}
      break;
    }

  this_command_name = oname;
  return temp1;
}
warning: parse error {
  int vtype, xc, starsub;
  char *temp1, *val, *oname;
  SHELL_VAR *v;

  xc = xform[0];
  if (value == 0 && xc != 'A' && xc != 'a')
    return ((char *)NULL);

  oname = this_command_name;
  this_command_name = varname;

  vtype = get_var_and_type (varname, value, ind, quoted, flags, &v, &val);
  if (vtype == -1)
    {
      this_command_name = oname;
      return ((char *)NULL);
    }

  if (valid_parameter_transform (xform) == 0)
    {
      this_command_name = oname;
#if 0 /* TAG: bash-5.2 Martin Schulte <gnu@schrader-schulte.de> 10/2020 */
      return (interactive_shell ? &expand_param_error : &expand_param_fatal);
#else
      return &expand_param_error;
#endif
    }

  starsub = vtype & VT_STARSUB;
  vtype &= ~VT_STARSUB;

  /* If we are asked to display the attributes of an unset variable, V will
     be NULL after the call to get_var_and_type. Double-check here. */
  if ((xc == 'a' || xc == 'A') && vtype == VT_VARIABLE && varname && v == 0)
    v = find_variable (varname);

  temp1 = (char *)NULL;		/* shut up gcc */
  switch (vtype)
    {
    case VT_VARIABLE:
    case VT_ARRAYMEMBER:
      temp1 = string_transform (xc, v, val);
      if (vtype == VT_VARIABLE)
	FREE (val);
      if (temp1)
	{
	  val = (quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES))
			? quote_string (temp1)
			: quote_escapes (temp1);
	  free (temp1);
	  temp1 = val;
	}
      break;
#if defined (ARRAY_VARS)
    case VT_ARRAYVAR:
      temp1 = array_transform (xc, v, starsub, quoted);
      if (temp1 && quoted == 0 && ifs_is_null)
	{
		/* Posix interp 888 */
	}
      else if (temp1 && ((quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)) == 0))
	{
	  val = quote_escapes (temp1);
	  free (temp1);
	  temp1 = val;
	}
      break;
#endif
    case VT_POSPARMS:
      temp1 = parameter_list_transform (xc, varname[0], quoted);
      if (temp1 && quoted == 0 && ifs_is_null)
	{
		/* Posix interp 888 */
	}
      else if (temp1 && ((quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)) == 0))
	{
	  val = quote_escapes (temp1);
	  free (temp1);
	  temp1 = val;
	}
      break;
    }

  this_command_name = oname;
  return temp1;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:7,934
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:8,064
parsing error 
{
  intmax_t e1, e2;
  int vtype, r, starsub;
  char *temp, *val, *tt, *oname;
  SHELL_VAR *v;

  if (value == 0 && ((varname[0] != '@' && varname[0] != '*') || varname[1]))
    return ((char *)NULL);

  oname = this_command_name;
  this_command_name = varname;

  vtype = get_var_and_type (varname, value, ind, quoted, flags, &v, &val);
  if (vtype == -1)
    {
      this_command_name = oname;
      return ((char *)NULL);
    }

  starsub = vtype & VT_STARSUB;
  vtype &= ~VT_STARSUB;

  r = verify_substring_values (v, val, substr, vtype, &e1, &e2);
  this_command_name = oname;
  if (r <= 0)
    {
      if (vtype == VT_VARIABLE)
	FREE (val);
      return ((r == 0) ? &expand_param_error : (char *)NULL);
    }

  switch (vtype)
    {
    case VT_VARIABLE:
    case VT_ARRAYMEMBER:
#if defined (HANDLE_MULTIBYTE)
      if (MB_CUR_MAX > 1)
	tt = mb_substring (val, e1, e2);
      else
#endif
      tt = substring (val, e1, e2);

      if (vtype == VT_VARIABLE)
	FREE (val);
      if (quoted & (Q_DOUBLE_QUOTES|Q_HERE_DOCUMENT))
	temp = quote_string (tt);
      else
	temp = tt ? quote_escapes (tt) : (char *)NULL;
      FREE (tt);
      break;
    case VT_POSPARMS:
    case VT_ARRAYVAR:
      if (vtype == VT_POSPARMS)
	tt = pos_params (varname, e1, e2, quoted, pflags);
#if defined (ARRAY_VARS)
        /* assoc_subrange and array_subrange both call string_list_pos_params,
	   so we can treat this case just like VT_POSPARAMS. */
      else if (assoc_p (v))
	/* we convert to list and take first e2 elements starting at e1th
	   element -- officially undefined for now */	
	tt = assoc_subrange (assoc_cell (v), e1, e2, starsub, quoted, pflags);
      else
	/* We want E2 to be the number of elements desired (arrays can be
	   sparse, so verify_substring_values just returns the numbers
	   specified and we rely on array_subrange to understand how to
	   deal with them). */
	tt = array_subrange (array_cell (v), e1, e2, starsub, quoted, pflags);
#endif
      /* We want to leave this alone in every case where pos_params/
	 string_list_pos_params quotes the list members */
      if (tt && quoted == 0 && ifs_is_null)
	{
	  temp = tt;	/* Posix interp 888 */
	}
      else if (tt && quoted == 0 && (pflags & PF_ASSIGNRHS))
	{
	  temp = tt;	/* Posix interp 888 */
	}
      else if ((quoted & (Q_DOUBLE_QUOTES|Q_HERE_DOCUMENT)) == 0)
	{
	  temp = tt ? quote_escapes (tt) : (char *)NULL;
	  FREE (tt);
	}
      else
	temp = tt;
      break;

    default:
      temp = (char *)NULL;
    }

  return temp;
}
warning: parse error {
  intmax_t e1, e2;
  int vtype, r, starsub;
  char *temp, *val, *tt, *oname;
  SHELL_VAR *v;

  if (value == 0 && ((varname[0] != '@' && varname[0] != '*') || varname[1]))
    return ((char *)NULL);

  oname = this_command_name;
  this_command_name = varname;

  vtype = get_var_and_type (varname, value, ind, quoted, flags, &v, &val);
  if (vtype == -1)
    {
      this_command_name = oname;
      return ((char *)NULL);
    }

  starsub = vtype & VT_STARSUB;
  vtype &= ~VT_STARSUB;

  r = verify_substring_values (v, val, substr, vtype, &e1, &e2);
  this_command_name = oname;
  if (r <= 0)
    {
      if (vtype == VT_VARIABLE)
	FREE (val);
      return ((r == 0) ? &expand_param_error : (char *)NULL);
    }

  switch (vtype)
    {
    case VT_VARIABLE:
    case VT_ARRAYMEMBER:
#if defined (HANDLE_MULTIBYTE)
      if (MB_CUR_MAX > 1)
	tt = mb_substring (val, e1, e2);
      else
#endif
      tt = substring (val, e1, e2);

      if (vtype == VT_VARIABLE)
	FREE (val);
      if (quoted & (Q_DOUBLE_QUOTES|Q_HERE_DOCUMENT))
	temp = quote_string (tt);
      else
	temp = tt ? quote_escapes (tt) : (char *)NULL;
      FREE (tt);
      break;
    case VT_POSPARMS:
    case VT_ARRAYVAR:
      if (vtype == VT_POSPARMS)
	tt = pos_params (varname, e1, e2, quoted, pflags);
#if defined (ARRAY_VARS)
        /* assoc_subrange and array_subrange both call string_list_pos_params,
	   so we can treat this case just like VT_POSPARAMS. */
      else if (assoc_p (v))
	/* we convert to list and take first e2 elements starting at e1th
	   element -- officially undefined for now */	
	tt = assoc_subrange (assoc_cell (v), e1, e2, starsub, quoted, pflags);
      else
	/* We want E2 to be the number of elements desired (arrays can be
	   sparse, so verify_substring_values just returns the numbers
	   specified and we rely on array_subrange to understand how to
	   deal with them). */
	tt = array_subrange (array_cell (v), e1, e2, starsub, quoted, pflags);
#endif
      /* We want to leave this alone in every case where pos_params/
	 string_list_pos_params quotes the list members */
      if (tt && quoted == 0 && ifs_is_null)
	{
	  temp = tt;	/* Posix interp 888 */
	}
      else if (tt && quoted == 0 && (pflags & PF_ASSIGNRHS))
	{
	  temp = tt;	/* Posix interp 888 */
	}
      else if ((quoted & (Q_DOUBLE_QUOTES|Q_HERE_DOCUMENT)) == 0)
	{
	  temp = tt ? quote_escapes (tt) : (char *)NULL;
	  FREE (tt);
	}
      else
	temp = tt;
      break;

    default:
      temp = (char *)NULL;
    }

  return temp;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:8,069
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:8,188
parsing error 
{
  char *ret, *s, *e, *str, *rstr, *mstr, *send;
  int rptr, mtype, rxpand, mlen;
  size_t rsize, l, replen, rslen;
  DECLARE_MBSTATE;

  if (string == 0)
    return (savestring (""));

  mtype = mflags & MATCH_TYPEMASK;

#if 0	/* TAG: bash-5.2? */
  rxpand = (rep && *rep) ? shouldexp_replacement (rep) : 0;
#else
  rxpand = 0;
#endif

  /* Special cases:
   * 	1.  A null pattern with mtype == MATCH_BEG means to prefix STRING
   *	    with REP and return the result.
   *	2.  A null pattern with mtype == MATCH_END means to append REP to
   *	    STRING and return the result.
   *	3.  A null STRING with a matching pattern means to append REP to
   *	    STRING and return the result.
   * These don't understand or process `&' in the replacement string.
   */
  if ((pat == 0 || *pat == 0) && (mtype == MATCH_BEG || mtype == MATCH_END))
    {
      replen = STRLEN (rep);
      l = STRLEN (string);
      ret = (char *)xmalloc (replen + l + 2);
      if (replen == 0)
	strcpy (ret, string);
      else if (mtype == MATCH_BEG)
	{
	  strcpy (ret, rep);
	  strcpy (ret + replen, string);
	}
      else
	{
	  strcpy (ret, string);
	  strcpy (ret + l, rep);
	}
      return (ret);
    }
  else if (*string == 0 && (match_pattern (string, pat, mtype, &s, &e) != 0))
    {
      replen = STRLEN (rep);
      ret = (char *)xmalloc (replen + 1);
      if (replen == 0)
	ret[0] = '\0';
      else
	strcpy (ret, rep);
      return (ret);
    }

  ret = (char *)xmalloc (rsize = 64);
  ret[0] = '\0';
  send = string + strlen (string);

  for (replen = STRLEN (rep), rptr = 0, str = string; *str;)
    {
      if (match_pattern (str, pat, mtype, &s, &e) == 0)
	break;
      l = s - str;

      if (rep && rxpand)
        {
	  int x;
	  mlen = e - s;
	  mstr = xmalloc (mlen + 1);
	  for (x = 0; x < mlen; x++)
	    mstr[x] = s[x];
	  mstr[mlen] = '\0';
	  rstr = strcreplace (rep, '&', mstr, 0);
	  free (mstr);
	  rslen = strlen (rstr);
        }
      else
	{
	  rstr = rep;
	  rslen = replen;
	}
        
      RESIZE_MALLOCED_BUFFER (ret, rptr, (l + rslen), rsize, 64);

      /* OK, now copy the leading unmatched portion of the string (from
	 str to s) to ret starting at rptr (the current offset).  Then copy
	 the replacement string at ret + rptr + (s - str).  Increment
	 rptr (if necessary) and str and go on. */
      if (l)
	{
	  strncpy (ret + rptr, str, l);
	  rptr += l;
	}
      if (replen)
	{
	  strncpy (ret + rptr, rstr, rslen);
	  rptr += rslen;
	}
      str = e;		/* e == end of match */

      if (rstr != rep)
	free (rstr);

      if (((mflags & MATCH_GLOBREP) == 0) || mtype != MATCH_ANY)
	break;

      if (s == e)
	{
	  /* On a zero-length match, make sure we copy one character, since
	     we increment one character to avoid infinite recursion. */
	  char *p, *origp, *origs;
	  size_t clen;

	  RESIZE_MALLOCED_BUFFER (ret, rptr, locale_mb_cur_max, rsize, 64);
#if defined (HANDLE_MULTIBYTE)
	  p = origp = ret + rptr;
	  origs = str;
	  COPY_CHAR_P (p, str, send);
	  rptr += p - origp;
	  e += str - origs;
#else
	  ret[rptr++] = *str++;
	  e++;		/* avoid infinite recursion on zero-length match */
#endif
	}
    }

  /* Now copy the unmatched portion of the input string */
  if (str && *str)
    {
      RESIZE_MALLOCED_BUFFER (ret, rptr, STRLEN(str) + 1, rsize, 64);
      strcpy (ret + rptr, str);
    }
  else
    ret[rptr] = '\0';

  return ret;
}
warning: parse error {
  char *ret, *s, *e, *str, *rstr, *mstr, *send;
  int rptr, mtype, rxpand, mlen;
  size_t rsize, l, replen, rslen;
  DECLARE_MBSTATE;

  if (string == 0)
    return (savestring (""));

  mtype = mflags & MATCH_TYPEMASK;

#if 0	/* TAG: bash-5.2? */
  rxpand = (rep && *rep) ? shouldexp_replacement (rep) : 0;
#else
  rxpand = 0;
#endif

  /* Special cases:
   * 	1.  A null pattern with mtype == MATCH_BEG means to prefix STRING
   *	    with REP and return the result.
   *	2.  A null pattern with mtype == MATCH_END means to append REP to
   *	    STRING and return the result.
   *	3.  A null STRING with a matching pattern means to append REP to
   *	    STRING and return the result.
   * These don't understand or process `&' in the replacement string.
   */
  if ((pat == 0 || *pat == 0) && (mtype == MATCH_BEG || mtype == MATCH_END))
    {
      replen = STRLEN (rep);
      l = STRLEN (string);
      ret = (char *)xmalloc (replen + l + 2);
      if (replen == 0)
	strcpy (ret, string);
      else if (mtype == MATCH_BEG)
	{
	  strcpy (ret, rep);
	  strcpy (ret + replen, string);
	}
      else
	{
	  strcpy (ret, string);
	  strcpy (ret + l, rep);
	}
      return (ret);
    }
  else if (*string == 0 && (match_pattern (string, pat, mtype, &s, &e) != 0))
    {
      replen = STRLEN (rep);
      ret = (char *)xmalloc (replen + 1);
      if (replen == 0)
	ret[0] = '\0';
      else
	strcpy (ret, rep);
      return (ret);
    }

  ret = (char *)xmalloc (rsize = 64);
  ret[0] = '\0';
  send = string + strlen (string);

  for (replen = STRLEN (rep), rptr = 0, str = string; *str;)
    {
      if (match_pattern (str, pat, mtype, &s, &e) == 0)
	break;
      l = s - str;

      if (rep && rxpand)
        {
	  int x;
	  mlen = e - s;
	  mstr = xmalloc (mlen + 1);
	  for (x = 0; x < mlen; x++)
	    mstr[x] = s[x];
	  mstr[mlen] = '\0';
	  rstr = strcreplace (rep, '&', mstr, 0);
	  free (mstr);
	  rslen = strlen (rstr);
        }
      else
	{
	  rstr = rep;
	  rslen = replen;
	}
        
      RESIZE_MALLOCED_BUFFER (ret, rptr, (l + rslen), rsize, 64);

      /* OK, now copy the leading unmatched portion of the string (from
	 str to s) to ret starting at rptr (the current offset).  Then copy
	 the replacement string at ret + rptr + (s - str).  Increment
	 rptr (if necessary) and str and go on. */
      if (l)
	{
	  strncpy (ret + rptr, str, l);
	  rptr += l;
	}
      if (replen)
	{
	  strncpy (ret + rptr, rstr, rslen);
	  rptr += rslen;
	}
      str = e;		/* e == end of match */

      if (rstr != rep)
	free (rstr);

      if (((mflags & MATCH_GLOBREP) == 0) || mtype != MATCH_ANY)
	break;

      if (s == e)
	{
	  /* On a zero-length match, make sure we copy one character, since
	     we increment one character to avoid infinite recursion. */
	  char *p, *origp, *origs;
	  size_t clen;

	  RESIZE_MALLOCED_BUFFER (ret, rptr, locale_mb_cur_max, rsize, 64);
#if defined (HANDLE_MULTIBYTE)
	  p = origp = ret + rptr;
	  origs = str;
	  COPY_CHAR_P (p, str, send);
	  rptr += p - origp;
	  e += str - origs;
#else
	  ret[rptr++] = *str++;
	  e++;		/* avoid infinite recursion on zero-length match */
#endif
	}
    }

  /* Now copy the unmatched portion of the input string */
  if (str && *str)
    {
      RESIZE_MALLOCED_BUFFER (ret, rptr, STRLEN(str) + 1, rsize, 64);
      strcpy (ret + rptr, str);
    }
  else
    ret[rptr] = '\0';

  return ret;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:8,191
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:8,334
parsing error 
{
  WORD_LIST *save, *params;
  WORD_DESC *w;
  char *ret;
  int pchar, qflags, pflags;

  save = params = list_rest_of_args ();
  if (save == 0)
    return ((char *)NULL);

  for ( ; params; params = params->next)
    {
      ret = pat_subst (params->word->word, pat, rep, mflags);
      w = alloc_word_desc ();
      w->word = ret ? ret : savestring ("");
      dispose_word (params->word);
      params->word = w;
    }

  pchar = (mflags & MATCH_STARSUB) == MATCH_STARSUB ? '*' : '@';
  qflags = (mflags & MATCH_QUOTED) == MATCH_QUOTED ? Q_DOUBLE_QUOTES : 0;
  pflags = (mflags & MATCH_ASSIGNRHS) == MATCH_ASSIGNRHS ? PF_ASSIGNRHS : 0;

  /* If we are expanding in a context where word splitting will not be
     performed, treat as quoted. This changes how $* will be expanded. */
  if (pchar == '*' && (mflags & MATCH_ASSIGNRHS) && expand_no_split_dollar_star && ifs_is_null)
    qflags |= Q_DOUBLE_QUOTES;		/* Posix interp 888 */

  ret = string_list_pos_params (pchar, save, qflags, pflags);
  dispose_words (save);

  return (ret);
}
warning: parse error {
  WORD_LIST *save, *params;
  WORD_DESC *w;
  char *ret;
  int pchar, qflags, pflags;

  save = params = list_rest_of_args ();
  if (save == 0)
    return ((char *)NULL);

  for ( ; params; params = params->next)
    {
      ret = pat_subst (params->word->word, pat, rep, mflags);
      w = alloc_word_desc ();
      w->word = ret ? ret : savestring ("");
      dispose_word (params->word);
      params->word = w;
    }

  pchar = (mflags & MATCH_STARSUB) == MATCH_STARSUB ? '*' : '@';
  qflags = (mflags & MATCH_QUOTED) == MATCH_QUOTED ? Q_DOUBLE_QUOTES : 0;
  pflags = (mflags & MATCH_ASSIGNRHS) == MATCH_ASSIGNRHS ? PF_ASSIGNRHS : 0;

  /* If we are expanding in a context where word splitting will not be
     performed, treat as quoted. This changes how $* will be expanded. */
  if (pchar == '*' && (mflags & MATCH_ASSIGNRHS) && expand_no_split_dollar_star && ifs_is_null)
    qflags |= Q_DOUBLE_QUOTES;		/* Posix interp 888 */

  ret = string_list_pos_params (pchar, save, qflags, pflags);
  dispose_words (save);

  return (ret);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:8,337
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:8,376
parsing error 
{
  int vtype, mflags, starsub, delim;
  char *val, *temp, *pat, *rep, *p, *lpatsub, *tt, *oname;
  SHELL_VAR *v;

  if (value == 0)
    return ((char *)NULL);

  oname = this_command_name;
  this_command_name = varname;		/* error messages */

  vtype = get_var_and_type (varname, value, ind, quoted, flags, &v, &val);
  if (vtype == -1)
    {
      this_command_name = oname;
      return ((char *)NULL);
    }

  starsub = vtype & VT_STARSUB;
  vtype &= ~VT_STARSUB;

  mflags = 0;
  /* PATSUB is never NULL when this is called. */
  if (*patsub == '/')
    {
      mflags |= MATCH_GLOBREP;
      patsub++;
    }

  /* Malloc this because expand_string_if_necessary or one of the expansion
     functions in its call chain may free it on a substitution error. */
  lpatsub = savestring (patsub);

  if (quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES))
    mflags |= MATCH_QUOTED;

  if (starsub)
    mflags |= MATCH_STARSUB;

  if (pflags & PF_ASSIGNRHS)
    mflags |= MATCH_ASSIGNRHS;

  /* If the pattern starts with a `/', make sure we skip over it when looking
     for the replacement delimiter. */
  delim = skip_to_delim (lpatsub, ((*patsub == '/') ? 1 : 0), "/", 0);
  if (lpatsub[delim] == '/')
    {
      lpatsub[delim] = 0;
      rep = lpatsub + delim + 1;
    }
  else
    rep = (char *)NULL;

  if (rep && *rep == '\0')
    rep = (char *)NULL;

  /* Perform the same expansions on the pattern as performed by the
     pattern removal expansions. */
  pat = getpattern (lpatsub, quoted, 1);

  if (rep)
    {
      /* We want to perform quote removal on the expanded replacement even if
	 the entire expansion is double-quoted because the parser and string
	 extraction functions treated quotes in the replacement string as
	 special.  THIS IS NOT BACKWARDS COMPATIBLE WITH BASH-4.2. */
      if (shell_compatibility_level > 42)
	rep = expand_string_if_necessary (rep, quoted & ~(Q_DOUBLE_QUOTES|Q_HERE_DOCUMENT), expand_string_unsplit);
      /* This is the bash-4.2 code. */      
      else if ((mflags & MATCH_QUOTED) == 0)
	rep = expand_string_if_necessary (rep, quoted, expand_string_unsplit);
      else
	rep = expand_string_to_string_internal (rep, quoted, expand_string_unsplit);
    }

  /* ksh93 doesn't allow the match specifier to be a part of the expanded
     pattern.  This is an extension.  Make sure we don't anchor the pattern
     at the beginning or end of the string if we're doing global replacement,
     though. */
  p = pat;
  if (mflags & MATCH_GLOBREP)
    mflags |= MATCH_ANY;
  else if (pat && pat[0] == '#')
    {
      mflags |= MATCH_BEG;
      p++;
    }
  else if (pat && pat[0] == '%')
    {
      mflags |= MATCH_END;
      p++;
    }
  else
    mflags |= MATCH_ANY;

  /* OK, we now want to substitute REP for PAT in VAL.  If
     flags & MATCH_GLOBREP is non-zero, the substitution is done
     everywhere, otherwise only the first occurrence of PAT is
     replaced.  The pattern matching code doesn't understand
     CTLESC quoting CTLESC and CTLNUL so we use the dequoted variable
     values passed in (VT_VARIABLE) so the pattern substitution
     code works right.  We need to requote special chars after
     we're done for VT_VARIABLE and VT_ARRAYMEMBER, and for the
     other cases if QUOTED == 0, since the posparams and arrays
     indexed by * or @ do special things when QUOTED != 0. */

  switch (vtype)
    {
    case VT_VARIABLE:
    case VT_ARRAYMEMBER:
      temp = pat_subst (val, p, rep, mflags);
      if (vtype == VT_VARIABLE)
	FREE (val);
      if (temp)
	{
	  tt = (mflags & MATCH_QUOTED) ? quote_string (temp) : quote_escapes (temp);
	  free (temp);
	  temp = tt;
	}
      break;
    case VT_POSPARMS:
      /* This does the right thing for the case where we are not performing
	 word splitting. MATCH_STARSUB restricts it to ${* /foo/bar}, and
	 pos_params_pat_subst/string_list_pos_params will do the right thing
	 in turn for the case where ifs_is_null. Posix interp 888 */
      if ((pflags & PF_NOSPLIT2) && (mflags & MATCH_STARSUB))
        mflags |= MATCH_ASSIGNRHS;
      temp = pos_params_pat_subst (val, p, rep, mflags);
      if (temp && quoted == 0 && ifs_is_null)
	{
	  /* Posix interp 888 */
	}
      else if (temp && quoted == 0 && (pflags & PF_ASSIGNRHS))
	{
	  /* Posix interp 888 */
	}
      else if (temp && (mflags & MATCH_QUOTED) == 0)
	{
	  tt = quote_escapes (temp);
	  free (temp);
	  temp = tt;
	}
      break;
#if defined (ARRAY_VARS)
    case VT_ARRAYVAR:
      /* If we are expanding in a context where word splitting will not be
	 performed, treat as quoted.  This changes how ${A[*]} will be
	 expanded to make it identical to $*. */
      if ((mflags & MATCH_STARSUB) && (mflags & MATCH_ASSIGNRHS) && ifs_is_null)
	mflags |= MATCH_QUOTED;		/* Posix interp 888 */

      /* these eventually call string_list_pos_params */
      if (assoc_p (v))
	temp = assoc_patsub (assoc_cell (v), p, rep, mflags);
      else
	temp = array_patsub (array_cell (v), p, rep, mflags);

      if (temp && quoted == 0 && ifs_is_null)
	{
	  /* Posix interp 888 */
	}
      else if (temp && (mflags & MATCH_QUOTED) == 0)
	{
	  tt = quote_escapes (temp);
	  free (temp);
	  temp = tt;
	}
      break;
#endif
    }

  FREE (pat);
  FREE (rep);
  free (lpatsub);

  this_command_name = oname;

  return temp;
}
warning: parse error {
  int vtype, mflags, starsub, delim;
  char *val, *temp, *pat, *rep, *p, *lpatsub, *tt, *oname;
  SHELL_VAR *v;

  if (value == 0)
    return ((char *)NULL);

  oname = this_command_name;
  this_command_name = varname;		/* error messages */

  vtype = get_var_and_type (varname, value, ind, quoted, flags, &v, &val);
  if (vtype == -1)
    {
      this_command_name = oname;
      return ((char *)NULL);
    }

  starsub = vtype & VT_STARSUB;
  vtype &= ~VT_STARSUB;

  mflags = 0;
  /* PATSUB is never NULL when this is called. */
  if (*patsub == '/')
    {
      mflags |= MATCH_GLOBREP;
      patsub++;
    }

  /* Malloc this because expand_string_if_necessary or one of the expansion
     functions in its call chain may free it on a substitution error. */
  lpatsub = savestring (patsub);

  if (quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES))
    mflags |= MATCH_QUOTED;

  if (starsub)
    mflags |= MATCH_STARSUB;

  if (pflags & PF_ASSIGNRHS)
    mflags |= MATCH_ASSIGNRHS;

  /* If the pattern starts with a `/', make sure we skip over it when looking
     for the replacement delimiter. */
  delim = skip_to_delim (lpatsub, ((*patsub == '/') ? 1 : 0), "/", 0);
  if (lpatsub[delim] == '/')
    {
      lpatsub[delim] = 0;
      rep = lpatsub + delim + 1;
    }
  else
    rep = (char *)NULL;

  if (rep && *rep == '\0')
    rep = (char *)NULL;

  /* Perform the same expansions on the pattern as performed by the
     pattern removal expansions. */
  pat = getpattern (lpatsub, quoted, 1);

  if (rep)
    {
      /* We want to perform quote removal on the expanded replacement even if
	 the entire expansion is double-quoted because the parser and string
	 extraction functions treated quotes in the replacement string as
	 special.  THIS IS NOT BACKWARDS COMPATIBLE WITH BASH-4.2. */
      if (shell_compatibility_level > 42)
	rep = expand_string_if_necessary (rep, quoted & ~(Q_DOUBLE_QUOTES|Q_HERE_DOCUMENT), expand_string_unsplit);
      /* This is the bash-4.2 code. */      
      else if ((mflags & MATCH_QUOTED) == 0)
	rep = expand_string_if_necessary (rep, quoted, expand_string_unsplit);
      else
	rep = expand_string_to_string_internal (rep, quoted, expand_string_unsplit);
    }

  /* ksh93 doesn't allow the match specifier to be a part of the expanded
     pattern.  This is an extension.  Make sure we don't anchor the pattern
     at the beginning or end of the string if we're doing global replacement,
     though. */
  p = pat;
  if (mflags & MATCH_GLOBREP)
    mflags |= MATCH_ANY;
  else if (pat && pat[0] == '#')
    {
      mflags |= MATCH_BEG;
      p++;
    }
  else if (pat && pat[0] == '%')
    {
      mflags |= MATCH_END;
      p++;
    }
  else
    mflags |= MATCH_ANY;

  /* OK, we now want to substitute REP for PAT in VAL.  If
     flags & MATCH_GLOBREP is non-zero, the substitution is done
     everywhere, otherwise only the first occurrence of PAT is
     replaced.  The pattern matching code doesn't understand
     CTLESC quoting CTLESC and CTLNUL so we use the dequoted variable
     values passed in (VT_VARIABLE) so the pattern substitution
     code works right.  We need to requote special chars after
     we're done for VT_VARIABLE and VT_ARRAYMEMBER, and for the
     other cases if QUOTED == 0, since the posparams and arrays
     indexed by * or @ do special things when QUOTED != 0. */

  switch (vtype)
    {
    case VT_VARIABLE:
    case VT_ARRAYMEMBER:
      temp = pat_subst (val, p, rep, mflags);
      if (vtype == VT_VARIABLE)
	FREE (val);
      if (temp)
	{
	  tt = (mflags & MATCH_QUOTED) ? quote_string (temp) : quote_escapes (temp);
	  free (temp);
	  temp = tt;
	}
      break;
    case VT_POSPARMS:
      /* This does the right thing for the case where we are not performing
	 word splitting. MATCH_STARSUB restricts it to ${* /foo/bar}, and
	 pos_params_pat_subst/string_list_pos_params will do the right thing
	 in turn for the case where ifs_is_null. Posix interp 888 */
      if ((pflags & PF_NOSPLIT2) && (mflags & MATCH_STARSUB))
        mflags |= MATCH_ASSIGNRHS;
      temp = pos_params_pat_subst (val, p, rep, mflags);
      if (temp && quoted == 0 && ifs_is_null)
	{
	  /* Posix interp 888 */
	}
      else if (temp && quoted == 0 && (pflags & PF_ASSIGNRHS))
	{
	  /* Posix interp 888 */
	}
      else if (temp && (mflags & MATCH_QUOTED) == 0)
	{
	  tt = quote_escapes (temp);
	  free (temp);
	  temp = tt;
	}
      break;
#if defined (ARRAY_VARS)
    case VT_ARRAYVAR:
      /* If we are expanding in a context where word splitting will not be
	 performed, treat as quoted.  This changes how ${A[*]} will be
	 expanded to make it identical to $*. */
      if ((mflags & MATCH_STARSUB) && (mflags & MATCH_ASSIGNRHS) && ifs_is_null)
	mflags |= MATCH_QUOTED;		/* Posix interp 888 */

      /* these eventually call string_list_pos_params */
      if (assoc_p (v))
	temp = assoc_patsub (assoc_cell (v), p, rep, mflags);
      else
	temp = array_patsub (array_cell (v), p, rep, mflags);

      if (temp && quoted == 0 && ifs_is_null)
	{
	  /* Posix interp 888 */
	}
      else if (temp && (mflags & MATCH_QUOTED) == 0)
	{
	  tt = quote_escapes (temp);
	  free (temp);
	  temp = tt;
	}
      break;
#endif
    }

  FREE (pat);
  FREE (rep);
  free (lpatsub);

  this_command_name = oname;

  return temp;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:8,381
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:8,570
parsing error 
{
  WORD_LIST *save, *params;
  WORD_DESC *w;
  char *ret;
  int pchar, qflags, pflags;

  save = params = list_rest_of_args ();
  if (save == 0)
    return ((char *)NULL);

  for ( ; params; params = params->next)
    {
      ret = sh_modcase (params->word->word, pat, modop);
      w = alloc_word_desc ();
      w->word = ret ? ret : savestring ("");
      dispose_word (params->word);
      params->word = w;
    }

  pchar = (mflags & MATCH_STARSUB) == MATCH_STARSUB ? '*' : '@';
  qflags = (mflags & MATCH_QUOTED) == MATCH_QUOTED ? Q_DOUBLE_QUOTES : 0;
  pflags = (mflags & MATCH_ASSIGNRHS) == MATCH_ASSIGNRHS ? PF_ASSIGNRHS : 0;

  /* If we are expanding in a context where word splitting will not be
     performed, treat as quoted.  This changes how $* will be expanded. */
  if (pchar == '*' && (mflags & MATCH_ASSIGNRHS) && ifs_is_null)
    qflags |= Q_DOUBLE_QUOTES;		/* Posix interp 888 */

  ret = string_list_pos_params (pchar, save, qflags, pflags);
  dispose_words (save);

  return (ret);
}
warning: parse error {
  WORD_LIST *save, *params;
  WORD_DESC *w;
  char *ret;
  int pchar, qflags, pflags;

  save = params = list_rest_of_args ();
  if (save == 0)
    return ((char *)NULL);

  for ( ; params; params = params->next)
    {
      ret = sh_modcase (params->word->word, pat, modop);
      w = alloc_word_desc ();
      w->word = ret ? ret : savestring ("");
      dispose_word (params->word);
      params->word = w;
    }

  pchar = (mflags & MATCH_STARSUB) == MATCH_STARSUB ? '*' : '@';
  qflags = (mflags & MATCH_QUOTED) == MATCH_QUOTED ? Q_DOUBLE_QUOTES : 0;
  pflags = (mflags & MATCH_ASSIGNRHS) == MATCH_ASSIGNRHS ? PF_ASSIGNRHS : 0;

  /* If we are expanding in a context where word splitting will not be
     performed, treat as quoted.  This changes how $* will be expanded. */
  if (pchar == '*' && (mflags & MATCH_ASSIGNRHS) && ifs_is_null)
    qflags |= Q_DOUBLE_QUOTES;		/* Posix interp 888 */

  ret = string_list_pos_params (pchar, save, qflags, pflags);
  dispose_words (save);

  return (ret);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:8,574
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:8,613
parsing error 
{
  int vtype, starsub, modop, mflags, x;
  char *val, *temp, *pat, *p, *lpat, *tt, *oname;
  SHELL_VAR *v;

  if (value == 0)
    return ((char *)NULL);

  oname = this_command_name;
  this_command_name = varname;

  vtype = get_var_and_type (varname, value, ind, quoted, flags, &v, &val);
  if (vtype == -1)
    {
      this_command_name = oname;
      return ((char *)NULL);
    }

  starsub = vtype & VT_STARSUB;
  vtype &= ~VT_STARSUB;

  modop = 0;
  mflags = 0;
  if (quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES))
    mflags |= MATCH_QUOTED;
  if (starsub)
    mflags |= MATCH_STARSUB;
  if (pflags & PF_ASSIGNRHS)
    mflags |= MATCH_ASSIGNRHS;
  
  p = patspec;
  if (modspec == '^')
    {
      x = p && p[0] == modspec;
      modop = x ? CASE_UPPER : CASE_UPFIRST;
      p += x;
    }
  else if (modspec == ',')
    {
      x = p && p[0] == modspec;
      modop = x ? CASE_LOWER : CASE_LOWFIRST;
      p += x;
    }
  else if (modspec == '~')
    {
      x = p && p[0] == modspec;
      modop = x ? CASE_TOGGLEALL : CASE_TOGGLE;
      p += x;
    }
    
  lpat = p ? savestring (p) : 0;
  /* Perform the same expansions on the pattern as performed by the
     pattern removal expansions. */
  pat = lpat ? getpattern (lpat, quoted, 1) : 0;

  /* OK, now we do the case modification. */
  switch (vtype)
    {
    case VT_VARIABLE:
    case VT_ARRAYMEMBER:
      temp = sh_modcase (val, pat, modop);
      if (vtype == VT_VARIABLE)
	FREE (val);
      if (temp)
	{
	  tt = (mflags & MATCH_QUOTED) ? quote_string (temp) : quote_escapes (temp);
	  free (temp);
	  temp = tt;
	}
      break;

    case VT_POSPARMS:
      temp = pos_params_modcase (val, pat, modop, mflags);
      if (temp && quoted == 0 && ifs_is_null)
	{
	  /* Posix interp 888 */
	}
      else if (temp && (mflags & MATCH_QUOTED) == 0)
	{
	  tt = quote_escapes (temp);
	  free (temp);
	  temp = tt;
	}
      break;

#if defined (ARRAY_VARS)
    case VT_ARRAYVAR:
      /* If we are expanding in a context where word splitting will not be
	 performed, treat as quoted.  This changes how ${A[*]} will be
	 expanded to make it identical to $*. */
      if ((mflags & MATCH_STARSUB) && (mflags & MATCH_ASSIGNRHS) && ifs_is_null)
	mflags |= MATCH_QUOTED;		/* Posix interp 888 */

      temp = assoc_p (v) ? assoc_modcase (assoc_cell (v), pat, modop, mflags)
			 : array_modcase (array_cell (v), pat, modop, mflags);

      if (temp && quoted == 0 && ifs_is_null)
	{
	  /* Posix interp 888 */
	}
      else if (temp && (mflags & MATCH_QUOTED) == 0)
	{
	  tt = quote_escapes (temp);
	  free (temp);
	  temp = tt;
	}

      break;
#endif
    }

  FREE (pat);
  free (lpat);

  this_command_name = oname;

  return temp;
}
warning: parse error {
  int vtype, starsub, modop, mflags, x;
  char *val, *temp, *pat, *p, *lpat, *tt, *oname;
  SHELL_VAR *v;

  if (value == 0)
    return ((char *)NULL);

  oname = this_command_name;
  this_command_name = varname;

  vtype = get_var_and_type (varname, value, ind, quoted, flags, &v, &val);
  if (vtype == -1)
    {
      this_command_name = oname;
      return ((char *)NULL);
    }

  starsub = vtype & VT_STARSUB;
  vtype &= ~VT_STARSUB;

  modop = 0;
  mflags = 0;
  if (quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES))
    mflags |= MATCH_QUOTED;
  if (starsub)
    mflags |= MATCH_STARSUB;
  if (pflags & PF_ASSIGNRHS)
    mflags |= MATCH_ASSIGNRHS;
  
  p = patspec;
  if (modspec == '^')
    {
      x = p && p[0] == modspec;
      modop = x ? CASE_UPPER : CASE_UPFIRST;
      p += x;
    }
  else if (modspec == ',')
    {
      x = p && p[0] == modspec;
      modop = x ? CASE_LOWER : CASE_LOWFIRST;
      p += x;
    }
  else if (modspec == '~')
    {
      x = p && p[0] == modspec;
      modop = x ? CASE_TOGGLEALL : CASE_TOGGLE;
      p += x;
    }
    
  lpat = p ? savestring (p) : 0;
  /* Perform the same expansions on the pattern as performed by the
     pattern removal expansions. */
  pat = lpat ? getpattern (lpat, quoted, 1) : 0;

  /* OK, now we do the case modification. */
  switch (vtype)
    {
    case VT_VARIABLE:
    case VT_ARRAYMEMBER:
      temp = sh_modcase (val, pat, modop);
      if (vtype == VT_VARIABLE)
	FREE (val);
      if (temp)
	{
	  tt = (mflags & MATCH_QUOTED) ? quote_string (temp) : quote_escapes (temp);
	  free (temp);
	  temp = tt;
	}
      break;

    case VT_POSPARMS:
      temp = pos_params_modcase (val, pat, modop, mflags);
      if (temp && quoted == 0 && ifs_is_null)
	{
	  /* Posix interp 888 */
	}
      else if (temp && (mflags & MATCH_QUOTED) == 0)
	{
	  tt = quote_escapes (temp);
	  free (temp);
	  temp = tt;
	}
      break;

#if defined (ARRAY_VARS)
    case VT_ARRAYVAR:
      /* If we are expanding in a context where word splitting will not be
	 performed, treat as quoted.  This changes how ${A[*]} will be
	 expanded to make it identical to $*. */
      if ((mflags & MATCH_STARSUB) && (mflags & MATCH_ASSIGNRHS) && ifs_is_null)
	mflags |= MATCH_QUOTED;		/* Posix interp 888 */

      temp = assoc_p (v) ? assoc_modcase (assoc_cell (v), pat, modop, mflags)
			 : array_modcase (array_cell (v), pat, modop, mflags);

      if (temp && quoted == 0 && ifs_is_null)
	{
	  /* Posix interp 888 */
	}
      else if (temp && (mflags & MATCH_QUOTED) == 0)
	{
	  tt = quote_escapes (temp);
	  free (temp);
	  temp = tt;
	}

      break;
#endif
    }

  FREE (pat);
  free (lpat);

  this_command_name = oname;

  return temp;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:8,618
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:8,745
parsing error 
{
  int i, count;
  DECLARE_MBSTATE;

  i = count = 0;
  while (i < len)
    {
      if (s[i] == LPAREN)
	count++;
      else if (s[i] == RPAREN)
	{
	  count--;
	  if (count < 0)
	    return 0;
	}

      switch (s[i])
	{
	default:
	  ADVANCE_CHAR (s, len, i);
	  break;

	case '\\':
	  i++;
	  if (s[i])
	    ADVANCE_CHAR (s, len, i);
	  break;

	case '\'':
	  i = skip_single_quoted (s, len, ++i, 0);
	  break;

	case '"':
	  i = skip_double_quoted ((char *)s, len, ++i, 0);
	  break;
	}
    }

  return (count == 0);
}
warning: parse error {
  int i, count;
  DECLARE_MBSTATE;

  i = count = 0;
  while (i < len)
    {
      if (s[i] == LPAREN)
	count++;
      else if (s[i] == RPAREN)
	{
	  count--;
	  if (count < 0)
	    return 0;
	}

      switch (s[i])
	{
	default:
	  ADVANCE_CHAR (s, len, i);
	  break;

	case '\\':
	  i++;
	  if (s[i])
	    ADVANCE_CHAR (s, len, i);
	  break;

	case '\'':
	  i = skip_single_quoted (s, len, ++i, 0);
	  break;

	case '"':
	  i = skip_double_quoted ((char *)s, len, ++i, 0);
	  break;
	}
    }

  return (count == 0);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:8,747
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:8,796
parsing error 
{
  int check_nullness, var_is_set, var_is_null, var_is_special;
  int want_substring, want_indir, want_patsub, want_casemod, want_attributes;
  char *name, *value, *temp, *temp1;
  WORD_DESC *tdesc, *ret;
  int t_index, sindex, c, tflag, modspec, local_pflags, all_element_arrayref;
  intmax_t number;
  arrayind_t ind;

  temp = temp1 = value = (char *)NULL;
  var_is_set = var_is_null = var_is_special = check_nullness = 0;
  want_substring = want_indir = want_patsub = want_casemod = want_attributes = 0;

  local_pflags = 0;
  all_element_arrayref = 0;

  sindex = *indexp;
  t_index = ++sindex;
  /* ${#var} doesn't have any of the other parameter expansions on it. */
  if (string[t_index] == '#' && legal_variable_starter (string[t_index+1]))		/* {{ */
    name = string_extract (string, &t_index, "}", SX_VARNAME);
  else
#if defined (CASEMOD_EXPANSIONS)
    /* To enable case-toggling expansions using the `~' operator character
       define CASEMOD_TOGGLECASE in config-top.h */
#  if defined (CASEMOD_TOGGLECASE)
    name = string_extract (string, &t_index, "#%^,~:-=?+/@}", SX_VARNAME);
#  else
    name = string_extract (string, &t_index, "#%^,:-=?+/@}", SX_VARNAME);
#  endif /* CASEMOD_TOGGLECASE */
#else
    name = string_extract (string, &t_index, "#%:-=?+/@}", SX_VARNAME);
#endif /* CASEMOD_EXPANSIONS */

  /* Handle ${@[stuff]} now that @ is a word expansion operator.  Not exactly
     the cleanest code ever. */
  if (*name == 0 && sindex == t_index && string[sindex] == '@')
    {
      name = (char *)xrealloc (name, 2);
      name[0] = '@';
      name[1] = '\0';
      t_index++;
    }
  else if (*name == '!' && t_index > sindex && string[t_index] == '@' && string[t_index+1] == RBRACE)
    {
      name = (char *)xrealloc (name, t_index - sindex + 2);
      name[t_index - sindex] = '@';
      name[t_index - sindex + 1] = '\0';
      t_index++;
    }

  ret = 0;
  tflag = 0;

  ind = INTMAX_MIN;

  /* If the name really consists of a special variable, then make sure
     that we have the entire name.  We don't allow indirect references
     to special variables except `#', `?', `@' and `*'.  This clause is
     designed to handle ${#SPECIAL} and ${!SPECIAL}, not anything more
     general. */
  if ((sindex == t_index && VALID_SPECIAL_LENGTH_PARAM (string[t_index])) ||
      (sindex == t_index && string[sindex] == '#' && VALID_SPECIAL_LENGTH_PARAM (string[sindex + 1])) ||
      (sindex == t_index - 1 && string[sindex] == '!' && VALID_INDIR_PARAM (string[t_index])))
    {
      t_index++;
      temp1 = string_extract (string, &t_index, "#%:-=?+/@}", 0);
      name = (char *)xrealloc (name, 3 + (strlen (temp1)));
      *name = string[sindex];
      if (string[sindex] == '!')
	{
	  /* indirect reference of $#, $?, $@, or $* */
	  name[1] = string[sindex + 1];
	  strcpy (name + 2, temp1);
	}
      else	
	strcpy (name + 1, temp1);
      free (temp1);
    }
  sindex = t_index;

  /* Find out what character ended the variable name.  Then
     do the appropriate thing. */
  if (c = string[sindex])
    sindex++;

  /* If c is followed by one of the valid parameter expansion
     characters, move past it as normal.  If not, assume that
     a substring specification is being given, and do not move
     past it. */
  if (c == ':' && VALID_PARAM_EXPAND_CHAR (string[sindex]))
    {
      check_nullness++;
      if (c = string[sindex])
	sindex++;
    }
  else if (c == ':' && string[sindex] != RBRACE)
    want_substring = 1;
  else if (c == '/' /* && string[sindex] != RBRACE */)	/* XXX */
    want_patsub = 1;
#if defined (CASEMOD_EXPANSIONS)
  else if (c == '^' || c == ',' || c == '~')
    {
      modspec = c;
      want_casemod = 1;
    }
#endif
  else if (c == '@' && (string[sindex] == 'a' || string[sindex] == 'A') && string[sindex+1] == RBRACE)
    {
      /* special case because we do not want to shortcut foo as foo[0] here */
      want_attributes = 1;
      local_pflags |= PF_ALLINDS;
    }

  /* Catch the valid and invalid brace expressions that made it through the
     tests above. */
  /* ${#-} is a valid expansion and means to take the length of $-.
     Similarly for ${#?} and ${##}... */
  if (name[0] == '#' && name[1] == '\0' && check_nullness == 0 &&
	VALID_SPECIAL_LENGTH_PARAM (c) && string[sindex] == RBRACE)
    {
      name = (char *)xrealloc (name, 3);
      name[1] = c;
      name[2] = '\0';
      c = string[sindex++];
    }

  /* ...but ${#%}, ${#:}, ${#=}, ${#+}, and ${#/} are errors. */
  if (name[0] == '#' && name[1] == '\0' && check_nullness == 0 &&
	member (c, "%:=+/") && string[sindex] == RBRACE)
    {
      temp = (char *)NULL;
      goto bad_substitution;	/* XXX - substitution error */
    }

  /* Indirect expansion begins with a `!'.  A valid indirect expansion is
     either a variable name, one of the positional parameters or a special
     variable that expands to one of the positional parameters. */
  want_indir = *name == '!' &&
    (legal_variable_starter ((unsigned char)name[1]) || DIGIT (name[1])
					|| VALID_INDIR_PARAM (name[1]));

  /* Determine the value of this variable whose name is NAME. */

  /* Check for special variables, directly referenced. */
  if (SPECIAL_VAR (name, want_indir))
    var_is_special++;

  /* Check for special expansion things, like the length of a parameter */
  if (*name == '#' && name[1])
    {
      /* If we are not pointing at the character just after the
	 closing brace, then we haven't gotten all of the name.
	 Since it begins with a special character, this is a bad
	 substitution.  Also check NAME for validity before trying
	 to go on. */
      if (string[sindex - 1] != RBRACE || (valid_length_expression (name) == 0))
	{
	  temp = (char *)NULL;
	  goto bad_substitution;	/* substitution error */
	}

      number = parameter_brace_expand_length (name);
      if (number == INTMAX_MIN && unbound_vars_is_error)
	{
	  set_exit_status (EXECUTION_FAILURE);
	  err_unboundvar (name+1);
	  free (name);
	  return (interactive_shell ? &expand_wdesc_error : &expand_wdesc_fatal);
	}
      free (name);

      *indexp = sindex;
      if (number < 0)
        return (&expand_wdesc_error);
      else
	{
	  ret = alloc_word_desc ();
	  ret->word = itos (number);
	  return ret;
	}
    }

  /* ${@} is identical to $@. */
  if (name[0] == '@' && name[1] == '\0')
    {
      if ((quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)) && quoted_dollar_atp)
	*quoted_dollar_atp = 1;

      if (contains_dollar_at)
	*contains_dollar_at = 1;

      tflag |= W_DOLLARAT;
    }

  /* Process ${!PREFIX*} expansion. */
  if (want_indir && string[sindex - 1] == RBRACE &&
      (string[sindex - 2] == '*' || string[sindex - 2] == '@') &&
      legal_variable_starter ((unsigned char) name[1]))
    {
      char **x;
      WORD_LIST *xlist;

      temp1 = savestring (name + 1);
      number = strlen (temp1);
      temp1[number - 1] = '\0';
      x = all_variables_matching_prefix (temp1);
      xlist = strvec_to_word_list (x, 0, 0);
      if (string[sindex - 2] == '*')
	temp = string_list_dollar_star (xlist, quoted, 0);
      else
	{
	  temp = string_list_dollar_at (xlist, quoted, 0);
	  if ((quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)) && quoted_dollar_atp)
	    *quoted_dollar_atp = 1;
	  if (contains_dollar_at)
	    *contains_dollar_at = 1;

	  tflag |= W_DOLLARAT;
	}
      free (x);
      dispose_words (xlist);
      free (temp1);
      *indexp = sindex;

      free (name);

      ret = alloc_word_desc ();
      ret->word = temp;
      ret->flags = tflag;	/* XXX */
      return ret;
    }

#if defined (ARRAY_VARS)      
  /* Process ${!ARRAY[@]} and ${!ARRAY[*]} expansion. */
  if (want_indir && string[sindex - 1] == RBRACE &&
      string[sindex - 2] == RBRACK && valid_array_reference (name+1, 0))
    {
      char *x, *x1;

      temp1 = savestring (name + 1);
      x = array_variable_name (temp1, 0, &x1, (int *)0);
      FREE (x);
      if (ALL_ELEMENT_SUB (x1[0]) && x1[1] == RBRACK)
	{
	  temp = array_keys (temp1, quoted, pflags);	/* handles assoc vars too */
	  if (x1[0] == '@')
	    {
	      if ((quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)) && quoted_dollar_atp)
		*quoted_dollar_atp = 1;
	      if (contains_dollar_at)
		*contains_dollar_at = 1;

	      tflag |= W_DOLLARAT;
	    }	    

	  free (name);
	  free (temp1);
	  *indexp = sindex;

	  ret = alloc_word_desc ();
	  ret->word = temp;
	  ret->flags = tflag;	/* XXX */
	  return ret;
	}

      free (temp1);
    }
#endif /* ARRAY_VARS */
      
  /* Make sure that NAME is valid before trying to go on. */
  if (valid_brace_expansion_word (want_indir ? name + 1 : name,
					var_is_special) == 0)
    {
      temp = (char *)NULL;
      goto bad_substitution;		/* substitution error */
    }

  if (want_indir)
    {
      tdesc = parameter_brace_expand_indir (name + 1, var_is_special, quoted, pflags|local_pflags, quoted_dollar_atp, contains_dollar_at);
      if (tdesc == &expand_wdesc_error || tdesc == &expand_wdesc_fatal)
	{
	  temp = (char *)NULL;
	  goto bad_substitution;
	}

      /* Turn off the W_ARRAYIND flag because there is no way for this function
	 to return the index we're supposed to be using. */
      if (tdesc && tdesc->flags)
	tdesc->flags &= ~W_ARRAYIND;
    }
  else
    {
      local_pflags |= PF_IGNUNBOUND|(pflags&(PF_NOSPLIT2|PF_ASSIGNRHS));
      tdesc = parameter_brace_expand_word (name, var_is_special, quoted, local_pflags, &ind);
    }

  if (tdesc == &expand_wdesc_error || tdesc == &expand_wdesc_fatal)
    {
      tflag = 0;
      tdesc = 0;
    }

  if (tdesc)
    {
      temp = tdesc->word;
      tflag = tdesc->flags;
      dispose_word_desc (tdesc);
    }
  else
    temp = (char  *)0;

  if (temp == &expand_param_error || temp == &expand_param_fatal)
    {
      FREE (name);
      FREE (value);
      return (temp == &expand_param_error ? &expand_wdesc_error : &expand_wdesc_fatal);
    }

#if defined (ARRAY_VARS)
  if (valid_array_reference (name, 0))
    {
      int qflags;
      char *t;

      qflags = quoted;
      /* If in a context where word splitting will not take place, treat as
	 if double-quoted.  Has effects with $* and ${array[*]} */

      if (pflags & PF_ASSIGNRHS)
	qflags |= Q_DOUBLE_QUOTES;
      /* We duplicate a little code here */
      t = mbschr (name, LBRACK);
      if (t && ALL_ELEMENT_SUB (t[1]) && t[2] == RBRACK)
	{
	  all_element_arrayref = 1;
	  if (expand_no_split_dollar_star && t[1] == '*')	/* XXX */
	    qflags |= Q_DOUBLE_QUOTES;
	}
      chk_atstar (name, qflags, pflags, quoted_dollar_atp, contains_dollar_at);
    }
#endif

  var_is_set = temp != (char *)0;
  var_is_null = check_nullness && (var_is_set == 0 || *temp == 0);
  /* XXX - this may not need to be restricted to special variables */
  if (check_nullness)
    var_is_null |= var_is_set && var_is_special && (quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)) && QUOTED_NULL (temp);
#if defined (ARRAY_VARS)
  if (check_nullness)
    var_is_null |= var_is_set && 
		   (quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)) &&
		   QUOTED_NULL (temp) &&
		   valid_array_reference (name, 0) &&
		   chk_atstar (name, 0, 0, (int *)0, (int *)0);
#endif

  /* Get the rest of the stuff inside the braces. */
  if (c && c != RBRACE)
    {
      /* Extract the contents of the ${ ... } expansion
	 according to the Posix.2 rules. */
      value = extract_dollar_brace_string (string, &sindex, quoted, (c == '%' || c == '#' || c =='/' || c == '^' || c == ',' || c ==':') ? SX_POSIXEXP|SX_WORD : SX_WORD);
      if (string[sindex] == RBRACE)
	sindex++;
      else
	goto bad_substitution;		/* substitution error */
    }
  else
    value = (char *)NULL;

  *indexp = sindex;

  /* All the cases where an expansion can possibly generate an unbound
     variable error. */
  if (want_substring || want_patsub || want_casemod || c == '@' || c == '#' || c == '%' || c == RBRACE)
    {
      if (var_is_set == 0 && unbound_vars_is_error && ((name[0] != '@' && name[0] != '*') || name[1]) && all_element_arrayref == 0)
	{
	  set_exit_status (EXECUTION_FAILURE);
	  err_unboundvar (name);
	  FREE (value);
	  FREE (temp);
	  free (name);
	  return (interactive_shell ? &expand_wdesc_error : &expand_wdesc_fatal);
	}
    }
    
  /* If this is a substring spec, process it and add the result. */
  if (want_substring)
    {
      temp1 = parameter_brace_substring (name, temp, ind, value, quoted, pflags, (tflag & W_ARRAYIND) ? AV_USEIND : 0);
      FREE (value);
      FREE (temp);

      if (temp1 == &expand_param_error || temp1 == &expand_param_fatal)
        {
          FREE (name);
	  return (temp1 == &expand_param_error ? &expand_wdesc_error : &expand_wdesc_fatal);
        }

      ret = alloc_word_desc ();
      ret->word = temp1;
      /* We test quoted_dollar_atp because we want variants with double-quoted
	 "$@" to take a different code path. In fact, we make sure at the end
	 of expand_word_internal that we're only looking at these flags if
	 quoted_dollar_at == 0. */
      if (temp1 &&
          (quoted_dollar_atp == 0 || *quoted_dollar_atp == 0) &&
	  QUOTED_NULL (temp1) && (quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)))
	ret->flags |= W_QUOTED|W_HASQUOTEDNULL;
      else if (temp1 && (name[0] == '*' && name[1] == 0) && quoted == 0 &&
		(pflags & PF_ASSIGNRHS))
	ret->flags |= W_SPLITSPACE;	/* Posix interp 888 */	
      /* Special handling for $* when unquoted and $IFS is null. Posix interp 888 */
      else if (temp1 && (name[0] == '*' && name[1] == 0) && quoted == 0 && ifs_is_null)
	ret->flags |= W_SPLITSPACE;	/* Posix interp 888 */

      FREE (name);
      return ret;
    }
  else if (want_patsub)
    {
      temp1 = parameter_brace_patsub (name, temp, ind, value, quoted, pflags, (tflag & W_ARRAYIND) ? AV_USEIND : 0);
      FREE (value);
      FREE (temp);

      if (temp1 == &expand_param_error || temp1 == &expand_param_fatal)
        {
          FREE (name);
	  return (temp1 == &expand_param_error ? &expand_wdesc_error : &expand_wdesc_fatal);
        }

      ret = alloc_word_desc ();
      ret->word = temp1;
      if (temp1 && 
          (quoted_dollar_atp == 0 || *quoted_dollar_atp == 0) &&
	  QUOTED_NULL (temp1) && (quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)))
	ret->flags |= W_QUOTED|W_HASQUOTEDNULL;
      /* Special handling for $* when unquoted and $IFS is null. Posix interp 888 */
      else if (temp1 && (name[0] == '*' && name[1] == 0) && quoted == 0 && ifs_is_null)
	ret->flags |= W_SPLITSPACE;	/* Posix interp 888 */

      FREE (name);
      return ret;
    }
#if defined (CASEMOD_EXPANSIONS)
  else if (want_casemod)
    {
      temp1 = parameter_brace_casemod (name, temp, ind, modspec, value, quoted, pflags, (tflag & W_ARRAYIND) ? AV_USEIND : 0);
      FREE (value);
      FREE (temp);

      if (temp1 == &expand_param_error || temp1 == &expand_param_fatal)
        {
          FREE (name);
	  return (temp1 == &expand_param_error ? &expand_wdesc_error : &expand_wdesc_fatal);
        }

      ret = alloc_word_desc ();
      ret->word = temp1;
      if (temp1 &&
          (quoted_dollar_atp == 0 || *quoted_dollar_atp == 0) &&
	  QUOTED_NULL (temp1) && (quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)))
	ret->flags |= W_QUOTED|W_HASQUOTEDNULL;
      /* Special handling for $* when unquoted and $IFS is null. Posix interp 888 */
      else if (temp1 && (name[0] == '*' && name[1] == 0) && quoted == 0 && ifs_is_null)
	ret->flags |= W_SPLITSPACE;	/* Posix interp 888 */

      FREE (name);
      return ret;
    }
#endif

  /* Do the right thing based on which character ended the variable name. */
  switch (c)
    {
    default:
    case '\0':
bad_substitution:
      set_exit_status (EXECUTION_FAILURE);
      report_error (_("%s: bad substitution"), string ? string : "??");
      FREE (value);
      FREE (temp);
      free (name);
      if (shell_compatibility_level <= 43)
	return &expand_wdesc_error;
      else
	return ((posixly_correct && interactive_shell == 0) ? &expand_wdesc_fatal : &expand_wdesc_error);

    case RBRACE:
      break;

    case '@':
      temp1 = parameter_brace_transform (name, temp, ind, value, c, quoted, pflags, (tflag & W_ARRAYIND) ? AV_USEIND : 0);
      free (temp);
      free (value);

      if (temp1 == &expand_param_error || temp1 == &expand_param_fatal)
	{
	  free (name);
	  set_exit_status (EXECUTION_FAILURE);
	  report_error (_("%s: bad substitution"), string ? string : "??");
	  return (temp1 == &expand_param_error ? &expand_wdesc_error : &expand_wdesc_fatal);
	}

      ret = alloc_word_desc ();
      ret->word = temp1;
      if (temp1 && QUOTED_NULL (temp1) && (quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)))
	ret->flags |= W_QUOTED|W_HASQUOTEDNULL;
      /* Special handling for $* when unquoted and $IFS is null. Posix interp 888 */
      else if (temp1 && (name[0] == '*' && name[1] == 0) && quoted == 0 && ifs_is_null)
	ret->flags |= W_SPLITSPACE;	/* Posix interp 888 */

      free (name);
      return ret;

    case '#':	/* ${param#[#]pattern} */
    case '%':	/* ${param%[%]pattern} */
      if (value == 0 || *value == '\0' || temp == 0 || *temp == '\0')
	{
	  FREE (value);
	  break;
	}
      temp1 = parameter_brace_remove_pattern (name, temp, ind, value, c, quoted, (tflag & W_ARRAYIND) ? AV_USEIND : 0);
      free (temp);
      free (value);

      ret = alloc_word_desc ();
      ret->word = temp1;
      if (temp1 && QUOTED_NULL (temp1) && (quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)))
	ret->flags |= W_QUOTED|W_HASQUOTEDNULL;
      /* Special handling for $* when unquoted and $IFS is null. Posix interp 888 */
      else if (temp1 && (name[0] == '*' && name[1] == 0) && quoted == 0 && ifs_is_null)
	ret->flags |= W_SPLITSPACE;	/* Posix interp 888 */

      free (name);
      return ret;

    case '-':
    case '=':
    case '?':
    case '+':
      if (var_is_set && var_is_null == 0)
	{
	  /* If the operator is `+', we don't want the value of the named
	     variable for anything, just the value of the right hand side. */
	  if (c == '+')
	    {
	      /* XXX -- if we're double-quoted and the named variable is "$@",
			we want to turn off any special handling of "$@" --
			we're not using it, so whatever is on the rhs applies. */
	      if ((quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)) && quoted_dollar_atp)
		*quoted_dollar_atp = 0;
	      if (contains_dollar_at)
		*contains_dollar_at = 0;

	      FREE (temp);
	      if (value)
		{
		  /* From Posix discussion on austin-group list.  Issue 221
		     requires that backslashes escaping `}' inside
		     double-quoted ${...} be removed. */
		  if (quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES))
		    quoted |= Q_DOLBRACE;
		  ret = parameter_brace_expand_rhs (name, value, c,
						    quoted,
						    pflags,
						    quoted_dollar_atp,
						    contains_dollar_at);
		  /* XXX - fix up later, esp. noting presence of
			   W_HASQUOTEDNULL in ret->flags */
		  free (value);
		}
	      else
		temp = (char *)NULL;
	    }
	  else
	    {
	      FREE (value);
	    }
	  /* Otherwise do nothing; just use the value in TEMP. */
	}
      else	/* VAR not set or VAR is NULL. */
	{
	  FREE (temp);
	  temp = (char *)NULL;
	  if (c == '=' && var_is_special)
	    {
	      set_exit_status (EXECUTION_FAILURE);
	      report_error (_("$%s: cannot assign in this way"), name);
	      free (name);
	      free (value);
	      return &expand_wdesc_error;
	    }
	  else if (c == '?')
	    {
	      parameter_brace_expand_error (name, value, check_nullness);
	      return (interactive_shell ? &expand_wdesc_error : &expand_wdesc_fatal);
	    }
	  else if (c != '+')
	    {
	      /* XXX -- if we're double-quoted and the named variable is "$@",
			we want to turn off any special handling of "$@" --
			we're not using it, so whatever is on the rhs applies. */
	      if ((quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)) && quoted_dollar_atp)
		*quoted_dollar_atp = 0;
	      if (contains_dollar_at)
		*contains_dollar_at = 0;

	      /* From Posix discussion on austin-group list.  Issue 221 requires
		 that backslashes escaping `}' inside double-quoted ${...} be
		 removed. */
	      if (quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES))
		quoted |= Q_DOLBRACE;
	      ret = parameter_brace_expand_rhs (name, value, c, quoted, pflags,
						quoted_dollar_atp,
						contains_dollar_at);
	      /* XXX - fix up later, esp. noting presence of
		       W_HASQUOTEDNULL in tdesc->flags */
	    }
	  free (value);
	}

      break;
    }
  free (name);

  if (ret == 0)
    {
      ret = alloc_word_desc ();
      ret->flags = tflag;
      ret->word = temp;
    }
  return (ret);
}
warning: parse error {
  int check_nullness, var_is_set, var_is_null, var_is_special;
  int want_substring, want_indir, want_patsub, want_casemod, want_attributes;
  char *name, *value, *temp, *temp1;
  WORD_DESC *tdesc, *ret;
  int t_index, sindex, c, tflag, modspec, local_pflags, all_element_arrayref;
  intmax_t number;
  arrayind_t ind;

  temp = temp1 = value = (char *)NULL;
  var_is_set = var_is_null = var_is_special = check_nullness = 0;
  want_substring = want_indir = want_patsub = want_casemod = want_attributes = 0;

  local_pflags = 0;
  all_element_arrayref = 0;

  sindex = *indexp;
  t_index = ++sindex;
  /* ${#var} doesn't have any of the other parameter expansions on it. */
  if (string[t_index] == '#' && legal_variable_starter (string[t_index+1]))		/* {{ */
    name = string_extract (string, &t_index, "}", SX_VARNAME);
  else
#if defined (CASEMOD_EXPANSIONS)
    /* To enable case-toggling expansions using the `~' operator character
       define CASEMOD_TOGGLECASE in config-top.h */
#  if defined (CASEMOD_TOGGLECASE)
    name = string_extract (string, &t_index, "#%^,~:-=?+/@}", SX_VARNAME);
#  else
    name = string_extract (string, &t_index, "#%^,:-=?+/@}", SX_VARNAME);
#  endif /* CASEMOD_TOGGLECASE */
#else
    name = string_extract (string, &t_index, "#%:-=?+/@}", SX_VARNAME);
#endif /* CASEMOD_EXPANSIONS */

  /* Handle ${@[stuff]} now that @ is a word expansion operator.  Not exactly
     the cleanest code ever. */
  if (*name == 0 && sindex == t_index && string[sindex] == '@')
    {
      name = (char *)xrealloc (name, 2);
      name[0] = '@';
      name[1] = '\0';
      t_index++;
    }
  else if (*name == '!' && t_index > sindex && string[t_index] == '@' && string[t_index+1] == RBRACE)
    {
      name = (char *)xrealloc (name, t_index - sindex + 2);
      name[t_index - sindex] = '@';
      name[t_index - sindex + 1] = '\0';
      t_index++;
    }

  ret = 0;
  tflag = 0;

  ind = INTMAX_MIN;

  /* If the name really consists of a special variable, then make sure
     that we have the entire name.  We don't allow indirect references
     to special variables except `#', `?', `@' and `*'.  This clause is
     designed to handle ${#SPECIAL} and ${!SPECIAL}, not anything more
     general. */
  if ((sindex == t_index && VALID_SPECIAL_LENGTH_PARAM (string[t_index])) ||
      (sindex == t_index && string[sindex] == '#' && VALID_SPECIAL_LENGTH_PARAM (string[sindex + 1])) ||
      (sindex == t_index - 1 && string[sindex] == '!' && VALID_INDIR_PARAM (string[t_index])))
    {
      t_index++;
      temp1 = string_extract (string, &t_index, "#%:-=?+/@}", 0);
      name = (char *)xrealloc (name, 3 + (strlen (temp1)));
      *name = string[sindex];
      if (string[sindex] == '!')
	{
	  /* indirect reference of $#, $?, $@, or $* */
	  name[1] = string[sindex + 1];
	  strcpy (name + 2, temp1);
	}
      else	
	strcpy (name + 1, temp1);
      free (temp1);
    }
  sindex = t_index;

  /* Find out what character ended the variable name.  Then
     do the appropriate thing. */
  if (c = string[sindex])
    sindex++;

  /* If c is followed by one of the valid parameter expansion
     characters, move past it as normal.  If not, assume that
     a substring specification is being given, and do not move
     past it. */
  if (c == ':' && VALID_PARAM_EXPAND_CHAR (string[sindex]))
    {
      check_nullness++;
      if (c = string[sindex])
	sindex++;
    }
  else if (c == ':' && string[sindex] != RBRACE)
    want_substring = 1;
  else if (c == '/' /* && string[sindex] != RBRACE */)	/* XXX */
    want_patsub = 1;
#if defined (CASEMOD_EXPANSIONS)
  else if (c == '^' || c == ',' || c == '~')
    {
      modspec = c;
      want_casemod = 1;
    }
#endif
  else if (c == '@' && (string[sindex] == 'a' || string[sindex] == 'A') && string[sindex+1] == RBRACE)
    {
      /* special case because we do not want to shortcut foo as foo[0] here */
      want_attributes = 1;
      local_pflags |= PF_ALLINDS;
    }

  /* Catch the valid and invalid brace expressions that made it through the
     tests above. */
  /* ${#-} is a valid expansion and means to take the length of $-.
     Similarly for ${#?} and ${##}... */
  if (name[0] == '#' && name[1] == '\0' && check_nullness == 0 &&
	VALID_SPECIAL_LENGTH_PARAM (c) && string[sindex] == RBRACE)
    {
      name = (char *)xrealloc (name, 3);
      name[1] = c;
      name[2] = '\0';
      c = string[sindex++];
    }

  /* ...but ${#%}, ${#:}, ${#=}, ${#+}, and ${#/} are errors. */
  if (name[0] == '#' && name[1] == '\0' && check_nullness == 0 &&
	member (c, "%:=+/") && string[sindex] == RBRACE)
    {
      temp = (char *)NULL;
      goto bad_substitution;	/* XXX - substitution error */
    }

  /* Indirect expansion begins with a `!'.  A valid indirect expansion is
     either a variable name, one of the positional parameters or a special
     variable that expands to one of the positional parameters. */
  want_indir = *name == '!' &&
    (legal_variable_starter ((unsigned char)name[1]) || DIGIT (name[1])
					|| VALID_INDIR_PARAM (name[1]));

  /* Determine the value of this variable whose name is NAME. */

  /* Check for special variables, directly referenced. */
  if (SPECIAL_VAR (name, want_indir))
    var_is_special++;

  /* Check for special expansion things, like the length of a parameter */
  if (*name == '#' && name[1])
    {
      /* If we are not pointing at the character just after the
	 closing brace, then we haven't gotten all of the name.
	 Since it begins with a special character, this is a bad
	 substitution.  Also check NAME for validity before trying
	 to go on. */
      if (string[sindex - 1] != RBRACE || (valid_length_expression (name) == 0))
	{
	  temp = (char *)NULL;
	  goto bad_substitution;	/* substitution error */
	}

      number = parameter_brace_expand_length (name);
      if (number == INTMAX_MIN && unbound_vars_is_error)
	{
	  set_exit_status (EXECUTION_FAILURE);
	  err_unboundvar (name+1);
	  free (name);
	  return (interactive_shell ? &expand_wdesc_error : &expand_wdesc_fatal);
	}
      free (name);

      *indexp = sindex;
      if (number < 0)
        return (&expand_wdesc_error);
      else
	{
	  ret = alloc_word_desc ();
	  ret->word = itos (number);
	  return ret;
	}
    }

  /* ${@} is identical to $@. */
  if (name[0] == '@' && name[1] == '\0')
    {
      if ((quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)) && quoted_dollar_atp)
	*quoted_dollar_atp = 1;

      if (contains_dollar_at)
	*contains_dollar_at = 1;

      tflag |= W_DOLLARAT;
    }

  /* Process ${!PREFIX*} expansion. */
  if (want_indir && string[sindex - 1] == RBRACE &&
      (string[sindex - 2] == '*' || string[sindex - 2] == '@') &&
      legal_variable_starter ((unsigned char) name[1]))
    {
      char **x;
      WORD_LIST *xlist;

      temp1 = savestring (name + 1);
      number = strlen (temp1);
      temp1[number - 1] = '\0';
      x = all_variables_matching_prefix (temp1);
      xlist = strvec_to_word_list (x, 0, 0);
      if (string[sindex - 2] == '*')
	temp = string_list_dollar_star (xlist, quoted, 0);
      else
	{
	  temp = string_list_dollar_at (xlist, quoted, 0);
	  if ((quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)) && quoted_dollar_atp)
	    *quoted_dollar_atp = 1;
	  if (contains_dollar_at)
	    *contains_dollar_at = 1;

	  tflag |= W_DOLLARAT;
	}
      free (x);
      dispose_words (xlist);
      free (temp1);
      *indexp = sindex;

      free (name);

      ret = alloc_word_desc ();
      ret->word = temp;
      ret->flags = tflag;	/* XXX */
      return ret;
    }

#if defined (ARRAY_VARS)      
  /* Process ${!ARRAY[@]} and ${!ARRAY[*]} expansion. */
  if (want_indir && string[sindex - 1] == RBRACE &&
      string[sindex - 2] == RBRACK && valid_array_reference (name+1, 0))
    {
      char *x, *x1;

      temp1 = savestring (name + 1);
      x = array_variable_name (temp1, 0, &x1, (int *)0);
      FREE (x);
      if (ALL_ELEMENT_SUB (x1[0]) && x1[1] == RBRACK)
	{
	  temp = array_keys (temp1, quoted, pflags);	/* handles assoc vars too */
	  if (x1[0] == '@')
	    {
	      if ((quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)) && quoted_dollar_atp)
		*quoted_dollar_atp = 1;
	      if (contains_dollar_at)
		*contains_dollar_at = 1;

	      tflag |= W_DOLLARAT;
	    }	    

	  free (name);
	  free (temp1);
	  *indexp = sindex;

	  ret = alloc_word_desc ();
	  ret->word = temp;
	  ret->flags = tflag;	/* XXX */
	  return ret;
	}

      free (temp1);
    }
#endif /* ARRAY_VARS */
      
  /* Make sure that NAME is valid before trying to go on. */
  if (valid_brace_expansion_word (want_indir ? name + 1 : name,
					var_is_special) == 0)
    {
      temp = (char *)NULL;
      goto bad_substitution;		/* substitution error */
    }

  if (want_indir)
    {
      tdesc = parameter_brace_expand_indir (name + 1, var_is_special, quoted, pflags|local_pflags, quoted_dollar_atp, contains_dollar_at);
      if (tdesc == &expand_wdesc_error || tdesc == &expand_wdesc_fatal)
	{
	  temp = (char *)NULL;
	  goto bad_substitution;
	}

      /* Turn off the W_ARRAYIND flag because there is no way for this function
	 to return the index we're supposed to be using. */
      if (tdesc && tdesc->flags)
	tdesc->flags &= ~W_ARRAYIND;
    }
  else
    {
      local_pflags |= PF_IGNUNBOUND|(pflags&(PF_NOSPLIT2|PF_ASSIGNRHS));
      tdesc = parameter_brace_expand_word (name, var_is_special, quoted, local_pflags, &ind);
    }

  if (tdesc == &expand_wdesc_error || tdesc == &expand_wdesc_fatal)
    {
      tflag = 0;
      tdesc = 0;
    }

  if (tdesc)
    {
      temp = tdesc->word;
      tflag = tdesc->flags;
      dispose_word_desc (tdesc);
    }
  else
    temp = (char  *)0;

  if (temp == &expand_param_error || temp == &expand_param_fatal)
    {
      FREE (name);
      FREE (value);
      return (temp == &expand_param_error ? &expand_wdesc_error : &expand_wdesc_fatal);
    }

#if defined (ARRAY_VARS)
  if (valid_array_reference (name, 0))
    {
      int qflags;
      char *t;

      qflags = quoted;
      /* If in a context where word splitting will not take place, treat as
	 if double-quoted.  Has effects with $* and ${array[*]} */

      if (pflags & PF_ASSIGNRHS)
	qflags |= Q_DOUBLE_QUOTES;
      /* We duplicate a little code here */
      t = mbschr (name, LBRACK);
      if (t && ALL_ELEMENT_SUB (t[1]) && t[2] == RBRACK)
	{
	  all_element_arrayref = 1;
	  if (expand_no_split_dollar_star && t[1] == '*')	/* XXX */
	    qflags |= Q_DOUBLE_QUOTES;
	}
      chk_atstar (name, qflags, pflags, quoted_dollar_atp, contains_dollar_at);
    }
#endif

  var_is_set = temp != (char *)0;
  var_is_null = check_nullness && (var_is_set == 0 || *temp == 0);
  /* XXX - this may not need to be restricted to special variables */
  if (check_nullness)
    var_is_null |= var_is_set && var_is_special && (quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)) && QUOTED_NULL (temp);
#if defined (ARRAY_VARS)
  if (check_nullness)
    var_is_null |= var_is_set && 
		   (quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)) &&
		   QUOTED_NULL (temp) &&
		   valid_array_reference (name, 0) &&
		   chk_atstar (name, 0, 0, (int *)0, (int *)0);
#endif

  /* Get the rest of the stuff inside the braces. */
  if (c && c != RBRACE)
    {
      /* Extract the contents of the ${ ... } expansion
	 according to the Posix.2 rules. */
      value = extract_dollar_brace_string (string, &sindex, quoted, (c == '%' || c == '#' || c =='/' || c == '^' || c == ',' || c ==':') ? SX_POSIXEXP|SX_WORD : SX_WORD);
      if (string[sindex] == RBRACE)
	sindex++;
      else
	goto bad_substitution;		/* substitution error */
    }
  else
    value = (char *)NULL;

  *indexp = sindex;

  /* All the cases where an expansion can possibly generate an unbound
     variable error. */
  if (want_substring || want_patsub || want_casemod || c == '@' || c == '#' || c == '%' || c == RBRACE)
    {
      if (var_is_set == 0 && unbound_vars_is_error && ((name[0] != '@' && name[0] != '*') || name[1]) && all_element_arrayref == 0)
	{
	  set_exit_status (EXECUTION_FAILURE);
	  err_unboundvar (name);
	  FREE (value);
	  FREE (temp);
	  free (name);
	  return (interactive_shell ? &expand_wdesc_error : &expand_wdesc_fatal);
	}
    }
    
  /* If this is a substring spec, process it and add the result. */
  if (want_substring)
    {
      temp1 = parameter_brace_substring (name, temp, ind, value, quoted, pflags, (tflag & W_ARRAYIND) ? AV_USEIND : 0);
      FREE (value);
      FREE (temp);

      if (temp1 == &expand_param_error || temp1 == &expand_param_fatal)
        {
          FREE (name);
	  return (temp1 == &expand_param_error ? &expand_wdesc_error : &expand_wdesc_fatal);
        }

      ret = alloc_word_desc ();
      ret->word = temp1;
      /* We test quoted_dollar_atp because we want variants with double-quoted
	 "$@" to take a different code path. In fact, we make sure at the end
	 of expand_word_internal that we're only looking at these flags if
	 quoted_dollar_at == 0. */
      if (temp1 &&
          (quoted_dollar_atp == 0 || *quoted_dollar_atp == 0) &&
	  QUOTED_NULL (temp1) && (quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)))
	ret->flags |= W_QUOTED|W_HASQUOTEDNULL;
      else if (temp1 && (name[0] == '*' && name[1] == 0) && quoted == 0 &&
		(pflags & PF_ASSIGNRHS))
	ret->flags |= W_SPLITSPACE;	/* Posix interp 888 */	
      /* Special handling for $* when unquoted and $IFS is null. Posix interp 888 */
      else if (temp1 && (name[0] == '*' && name[1] == 0) && quoted == 0 && ifs_is_null)
	ret->flags |= W_SPLITSPACE;	/* Posix interp 888 */

      FREE (name);
      return ret;
    }
  else if (want_patsub)
    {
      temp1 = parameter_brace_patsub (name, temp, ind, value, quoted, pflags, (tflag & W_ARRAYIND) ? AV_USEIND : 0);
      FREE (value);
      FREE (temp);

      if (temp1 == &expand_param_error || temp1 == &expand_param_fatal)
        {
          FREE (name);
	  return (temp1 == &expand_param_error ? &expand_wdesc_error : &expand_wdesc_fatal);
        }

      ret = alloc_word_desc ();
      ret->word = temp1;
      if (temp1 && 
          (quoted_dollar_atp == 0 || *quoted_dollar_atp == 0) &&
	  QUOTED_NULL (temp1) && (quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)))
	ret->flags |= W_QUOTED|W_HASQUOTEDNULL;
      /* Special handling for $* when unquoted and $IFS is null. Posix interp 888 */
      else if (temp1 && (name[0] == '*' && name[1] == 0) && quoted == 0 && ifs_is_null)
	ret->flags |= W_SPLITSPACE;	/* Posix interp 888 */

      FREE (name);
      return ret;
    }
#if defined (CASEMOD_EXPANSIONS)
  else if (want_casemod)
    {
      temp1 = parameter_brace_casemod (name, temp, ind, modspec, value, quoted, pflags, (tflag & W_ARRAYIND) ? AV_USEIND : 0);
      FREE (value);
      FREE (temp);

      if (temp1 == &expand_param_error || temp1 == &expand_param_fatal)
        {
          FREE (name);
	  return (temp1 == &expand_param_error ? &expand_wdesc_error : &expand_wdesc_fatal);
        }

      ret = alloc_word_desc ();
      ret->word = temp1;
      if (temp1 &&
          (quoted_dollar_atp == 0 || *quoted_dollar_atp == 0) &&
	  QUOTED_NULL (temp1) && (quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)))
	ret->flags |= W_QUOTED|W_HASQUOTEDNULL;
      /* Special handling for $* when unquoted and $IFS is null. Posix interp 888 */
      else if (temp1 && (name[0] == '*' && name[1] == 0) && quoted == 0 && ifs_is_null)
	ret->flags |= W_SPLITSPACE;	/* Posix interp 888 */

      FREE (name);
      return ret;
    }
#endif

  /* Do the right thing based on which character ended the variable name. */
  switch (c)
    {
    default:
    case '\0':
bad_substitution:
      set_exit_status (EXECUTION_FAILURE);
      report_error (_("%s: bad substitution"), string ? string : "??");
      FREE (value);
      FREE (temp);
      free (name);
      if (shell_compatibility_level <= 43)
	return &expand_wdesc_error;
      else
	return ((posixly_correct && interactive_shell == 0) ? &expand_wdesc_fatal : &expand_wdesc_error);

    case RBRACE:
      break;

    case '@':
      temp1 = parameter_brace_transform (name, temp, ind, value, c, quoted, pflags, (tflag & W_ARRAYIND) ? AV_USEIND : 0);
      free (temp);
      free (value);

      if (temp1 == &expand_param_error || temp1 == &expand_param_fatal)
	{
	  free (name);
	  set_exit_status (EXECUTION_FAILURE);
	  report_error (_("%s: bad substitution"), string ? string : "??");
	  return (temp1 == &expand_param_error ? &expand_wdesc_error : &expand_wdesc_fatal);
	}

      ret = alloc_word_desc ();
      ret->word = temp1;
      if (temp1 && QUOTED_NULL (temp1) && (quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)))
	ret->flags |= W_QUOTED|W_HASQUOTEDNULL;
      /* Special handling for $* when unquoted and $IFS is null. Posix interp 888 */
      else if (temp1 && (name[0] == '*' && name[1] == 0) && quoted == 0 && ifs_is_null)
	ret->flags |= W_SPLITSPACE;	/* Posix interp 888 */

      free (name);
      return ret;

    case '#':	/* ${param#[#]pattern} */
    case '%':	/* ${param%[%]pattern} */
      if (value == 0 || *value == '\0' || temp == 0 || *temp == '\0')
	{
	  FREE (value);
	  break;
	}
      temp1 = parameter_brace_remove_pattern (name, temp, ind, value, c, quoted, (tflag & W_ARRAYIND) ? AV_USEIND : 0);
      free (temp);
      free (value);

      ret = alloc_word_desc ();
      ret->word = temp1;
      if (temp1 && QUOTED_NULL (temp1) && (quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)))
	ret->flags |= W_QUOTED|W_HASQUOTEDNULL;
      /* Special handling for $* when unquoted and $IFS is null. Posix interp 888 */
      else if (temp1 && (name[0] == '*' && name[1] == 0) && quoted == 0 && ifs_is_null)
	ret->flags |= W_SPLITSPACE;	/* Posix interp 888 */

      free (name);
      return ret;

    case '-':
    case '=':
    case '?':
    case '+':
      if (var_is_set && var_is_null == 0)
	{
	  /* If the operator is `+', we don't want the value of the named
	     variable for anything, just the value of the right hand side. */
	  if (c == '+')
	    {
	      /* XXX -- if we're double-quoted and the named variable is "$@",
			we want to turn off any special handling of "$@" --
			we're not using it, so whatever is on the rhs applies. */
	      if ((quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)) && quoted_dollar_atp)
		*quoted_dollar_atp = 0;
	      if (contains_dollar_at)
		*contains_dollar_at = 0;

	      FREE (temp);
	      if (value)
		{
		  /* From Posix discussion on austin-group list.  Issue 221
		     requires that backslashes escaping `}' inside
		     double-quoted ${...} be removed. */
		  if (quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES))
		    quoted |= Q_DOLBRACE;
		  ret = parameter_brace_expand_rhs (name, value, c,
						    quoted,
						    pflags,
						    quoted_dollar_atp,
						    contains_dollar_at);
		  /* XXX - fix up later, esp. noting presence of
			   W_HASQUOTEDNULL in ret->flags */
		  free (value);
		}
	      else
		temp = (char *)NULL;
	    }
	  else
	    {
	      FREE (value);
	    }
	  /* Otherwise do nothing; just use the value in TEMP. */
	}
      else	/* VAR not set or VAR is NULL. */
	{
	  FREE (temp);
	  temp = (char *)NULL;
	  if (c == '=' && var_is_special)
	    {
	      set_exit_status (EXECUTION_FAILURE);
	      report_error (_("$%s: cannot assign in this way"), name);
	      free (name);
	      free (value);
	      return &expand_wdesc_error;
	    }
	  else if (c == '?')
	    {
	      parameter_brace_expand_error (name, value, check_nullness);
	      return (interactive_shell ? &expand_wdesc_error : &expand_wdesc_fatal);
	    }
	  else if (c != '+')
	    {
	      /* XXX -- if we're double-quoted and the named variable is "$@",
			we want to turn off any special handling of "$@" --
			we're not using it, so whatever is on the rhs applies. */
	      if ((quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)) && quoted_dollar_atp)
		*quoted_dollar_atp = 0;
	      if (contains_dollar_at)
		*contains_dollar_at = 0;

	      /* From Posix discussion on austin-group list.  Issue 221 requires
		 that backslashes escaping `}' inside double-quoted ${...} be
		 removed. */
	      if (quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES))
		quoted |= Q_DOLBRACE;
	      ret = parameter_brace_expand_rhs (name, value, c, quoted, pflags,
						quoted_dollar_atp,
						contains_dollar_at);
	      /* XXX - fix up later, esp. noting presence of
		       W_HASQUOTEDNULL in tdesc->flags */
	    }
	  free (value);
	}

      break;
    }
  free (name);

  if (ret == 0)
    {
      ret = alloc_word_desc ();
      ret->flags = tflag;
      ret->word = temp;
    }
  return (ret);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:8,799
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:9,443
parsing error 
{
  char *temp, *temp1, uerror[3], *savecmd;
  int zindex, t_index, expok;
  unsigned char c;
  intmax_t number;
  SHELL_VAR *var;
  WORD_LIST *list, *l;
  WORD_DESC *tdesc, *ret;
  int tflag, nullarg;

/*itrace("param_expand: `%s' pflags = %d", string+*sindex, pflags);*/
  zindex = *sindex;
  c = string[++zindex];

  temp = (char *)NULL;
  ret = tdesc = (WORD_DESC *)NULL;
  tflag = 0;

  /* Do simple cases first. Switch on what follows '$'. */
  switch (c)
    {
    /* $0 .. $9? */
    case '0':
    case '1':
    case '2':
    case '3':
    case '4':
    case '5':
    case '6':
    case '7':
    case '8':
    case '9':
      temp1 = dollar_vars[TODIGIT (c)];
      /* This doesn't get called when (pflags&PF_IGNUNBOUND) != 0 */
      if (unbound_vars_is_error && temp1 == (char *)NULL)
	{
	  uerror[0] = '$';
	  uerror[1] = c;
	  uerror[2] = '\0';
	  set_exit_status (EXECUTION_FAILURE);
	  err_unboundvar (uerror);
	  return (interactive_shell ? &expand_wdesc_error : &expand_wdesc_fatal);
	}
      if (temp1)
	temp = (*temp1 && (quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)))
		  ? quote_string (temp1)
		  : quote_escapes (temp1);
      else
	temp = (char *)NULL;

      break;

    /* $$ -- pid of the invoking shell. */
    case '$':
      temp = itos (dollar_dollar_pid);
      break;

    /* $# -- number of positional parameters. */
    case '#':
      temp = itos (number_of_args ());
      break;

    /* $? -- return value of the last synchronous command. */
    case '?':
      temp = itos (last_command_exit_value);
      break;

    /* $- -- flags supplied to the shell on invocation or by `set'. */
    case '-':
      temp = which_set_flags ();
      break;

      /* $! -- Pid of the last asynchronous command. */
    case '!':
      /* If no asynchronous pids have been created, expand to nothing.
	 If `set -u' has been executed, and no async processes have
	 been created, this is an expansion error. */
      if (last_asynchronous_pid == NO_PID)
	{
	  if (expanded_something)
	    *expanded_something = 0;
	  temp = (char *)NULL;
	  if (unbound_vars_is_error && (pflags & PF_IGNUNBOUND) == 0)
	    {
	      uerror[0] = '$';
	      uerror[1] = c;
	      uerror[2] = '\0';
	      set_exit_status (EXECUTION_FAILURE);
	      err_unboundvar (uerror);
	      return (interactive_shell ? &expand_wdesc_error : &expand_wdesc_fatal);
	    }
	}
      else
	temp = itos (last_asynchronous_pid);
      break;

    /* The only difference between this and $@ is when the arg is quoted. */
    case '*':		/* `$*' */
      list = list_rest_of_args ();

#if 0
      /* According to austin-group posix proposal by Geoff Clare in
	 <20090505091501.GA10097@squonk.masqnet> of 5 May 2009:

 	"The shell shall write a message to standard error and
 	 immediately exit when it tries to expand an unset parameter
 	 other than the '@' and '*' special parameters."
      */

      if (list == 0 && unbound_vars_is_error && (pflags & PF_IGNUNBOUND) == 0)
	{
	  uerror[0] = '$';
	  uerror[1] = '*';
	  uerror[2] = '\0';
	  set_exit_status (EXECUTION_FAILURE);
	  err_unboundvar (uerror);
	  return (interactive_shell ? &expand_wdesc_error : &expand_wdesc_fatal);
	}
#endif

      /* If there are no command-line arguments, this should just
	 disappear if there are other characters in the expansion,
	 even if it's quoted. */
      if ((quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)) && list == 0)
	temp = (char *)NULL;
      else if (quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES|Q_PATQUOTE))
	{
	  /* If we have "$*" we want to make a string of the positional
	     parameters, separated by the first character of $IFS, and
	     quote the whole string, including the separators.  If IFS
	     is unset, the parameters are separated by ' '; if $IFS is
	     null, the parameters are concatenated. */
	  temp = (quoted & (Q_DOUBLE_QUOTES|Q_PATQUOTE)) ? string_list_dollar_star (list, quoted, 0) : string_list (list);
	  if (temp)
	    {
	      temp1 = (quoted & Q_DOUBLE_QUOTES) ? quote_string (temp) : temp;
	      if (*temp == 0)
		tflag |= W_HASQUOTEDNULL;
	      if (temp != temp1)
		free (temp);
	      temp = temp1;
	    }
	}
      else
	{
	  /* We check whether or not we're eventually going to split $* here,
	     for example when IFS is empty and we are processing the rhs of
	     an assignment statement.  In that case, we don't separate the
	     arguments at all.  Otherwise, if the $* is not quoted it is
	     identical to $@ */
	  if (expand_no_split_dollar_star && quoted == 0 && ifs_is_set == 0 && (pflags & PF_ASSIGNRHS))
	    {
	      /* Posix interp 888: RHS of assignment, IFS unset: no splitting,
		 separate with space */
	      temp1 = string_list_dollar_star (list, quoted, pflags);
	      temp = temp1 ? quote_string (temp1) : temp1;
	      /* XXX - tentative - note that we saw a quoted null here */
	      if (temp1 && *temp1 == 0 && QUOTED_NULL (temp))
		tflag |= W_SAWQUOTEDNULL;
	      FREE (temp1);
	    }
	  else if (expand_no_split_dollar_star && quoted == 0 && ifs_is_null && (pflags & PF_ASSIGNRHS))
	    {
	      /* Posix interp 888: RHS of assignment, IFS set to '' */
	      temp1 = string_list_dollar_star (list, quoted, pflags);
	      temp = temp1 ? quote_escapes (temp1) : temp1;
	      FREE (temp1);
	    }
	  else if (expand_no_split_dollar_star && quoted == 0 && ifs_is_set && ifs_is_null == 0 && (pflags & PF_ASSIGNRHS))
	    {
	      /* Posix interp 888: RHS of assignment, IFS set to non-null value */
	      temp1 = string_list_dollar_star (list, quoted, pflags);
	      temp = temp1 ? quote_string (temp1) : temp1;

	      /* XXX - tentative - note that we saw a quoted null here */
	      if (temp1 && *temp1 == 0 && QUOTED_NULL (temp))
		tflag |= W_SAWQUOTEDNULL;
	      FREE (temp1);
	    }
	  /* XXX - should we check ifs_is_set here as well? */
#  if defined (HANDLE_MULTIBYTE)
	  else if (expand_no_split_dollar_star && ifs_firstc[0] == 0)
#  else
	  else if (expand_no_split_dollar_star && ifs_firstc == 0)
#  endif
	    /* Posix interp 888: not RHS, no splitting, IFS set to '' */
	    temp = string_list_dollar_star (list, quoted, 0);
	  else
	    {
	      temp = string_list_dollar_at (list, quoted, 0);
	      /* Set W_SPLITSPACE to make sure the individual positional
		 parameters are split into separate arguments */
#if 0
	      if (quoted == 0 && (ifs_is_set == 0 || ifs_is_null))
#else	/* change with bash-5.0 */
	      if (quoted == 0 && ifs_is_null)
#endif
		tflag |= W_SPLITSPACE;
	      /* If we're not quoted but we still don't want word splitting, make
		 we quote the IFS characters to protect them from splitting (e.g.,
		 when $@ is in the string as well). */
	      else if (temp && quoted == 0 && ifs_is_set && (pflags & PF_ASSIGNRHS))
		{
		  temp1 = quote_string (temp);
		  free (temp);
		  temp = temp1;
		}
	    }

	  if (expand_no_split_dollar_star == 0 && contains_dollar_at)
	    *contains_dollar_at = 1;
	}

      dispose_words (list);
      break;

    /* When we have "$@" what we want is "$1" "$2" "$3" ... This
       means that we have to turn quoting off after we split into
       the individually quoted arguments so that the final split
       on the first character of $IFS is still done.  */
    case '@':		/* `$@' */
      list = list_rest_of_args ();

#if 0
      /* According to austin-group posix proposal by Geoff Clare in
	 <20090505091501.GA10097@squonk.masqnet> of 5 May 2009:

 	"The shell shall write a message to standard error and
 	 immediately exit when it tries to expand an unset parameter
 	 other than the '@' and '*' special parameters."
      */

      if (list == 0 && unbound_vars_is_error && (pflags & PF_IGNUNBOUND) == 0)
	{
	  uerror[0] = '$';
	  uerror[1] = '@';
	  uerror[2] = '\0';
	  set_exit_status (EXECUTION_FAILURE);
	  err_unboundvar (uerror);
	  return (interactive_shell ? &expand_wdesc_error : &expand_wdesc_fatal);
	}
#endif

      for (nullarg = 0, l = list; l; l = l->next)
	{
	  if (l->word && (l->word->word == 0 || l->word->word[0] == 0))
	    nullarg = 1;
	}

      /* We want to flag the fact that we saw this.  We can't turn
	 off quoting entirely, because other characters in the
	 string might need it (consider "\"$@\""), but we need some
	 way to signal that the final split on the first character
	 of $IFS should be done, even though QUOTED is 1. */
      /* XXX - should this test include Q_PATQUOTE? */
      if (quoted_dollar_at_p && (quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)))
	*quoted_dollar_at_p = 1;
      if (contains_dollar_at)
	*contains_dollar_at = 1;

      /* We want to separate the positional parameters with the first
	 character of $IFS in case $IFS is something other than a space.
	 We also want to make sure that splitting is done no matter what --
	 according to POSIX.2, this expands to a list of the positional
	 parameters no matter what IFS is set to. */
      /* XXX - what to do when in a context where word splitting is not
	 performed? Even when IFS is not the default, posix seems to imply
	 that we have to expand $@ to all the positional parameters and
	 separate them with spaces, which are preserved because word splitting
	 doesn't take place.  See below for how we use PF_NOSPLIT2 here. */

      /* These are the cases where word splitting will not be performed. */
      if (pflags & PF_ASSIGNRHS)
	{
	  temp = string_list_dollar_at (list, (quoted|Q_DOUBLE_QUOTES), pflags);
	  if (nullarg)
	    tflag |= W_HASQUOTEDNULL;	/* we know quoting produces quoted nulls */
	}

      /* This needs to match what expand_word_internal does with non-quoted $@
	 does with separating with spaces.  Passing Q_DOUBLE_QUOTES means that
	 the characters in LIST will be quoted, and PF_ASSIGNRHS ensures that
	 they will separated by spaces. After doing this, we need the special
	 handling for PF_NOSPLIT2 in expand_word_internal to remove the CTLESC
	 quotes. */
      else if (pflags & PF_NOSPLIT2)
        {
#if defined (HANDLE_MULTIBYTE)
	  if (quoted == 0 && ifs_is_set && ifs_is_null == 0 && ifs_firstc[0] != ' ')
#else
	  if (quoted == 0 && ifs_is_set && ifs_is_null == 0 && ifs_firstc != ' ')
#endif
	    /* Posix interp 888 */
	    temp = string_list_dollar_at (list, Q_DOUBLE_QUOTES, pflags);
	  else
	    temp = string_list_dollar_at (list, quoted, pflags);
	}
      else
	temp = string_list_dollar_at (list, quoted, pflags);

      tflag |= W_DOLLARAT;
      dispose_words (list);
      break;

    case LBRACE:
      tdesc = parameter_brace_expand (string, &zindex, quoted, pflags,
				      quoted_dollar_at_p,
				      contains_dollar_at);

      if (tdesc == &expand_wdesc_error || tdesc == &expand_wdesc_fatal)
	return (tdesc);
      temp = tdesc ? tdesc->word : (char *)0;

      /* XXX */
      /* Quoted nulls should be removed if there is anything else
	 in the string. */
      /* Note that we saw the quoted null so we can add one back at
	 the end of this function if there are no other characters
	 in the string, discard TEMP, and go on.  The exception to
	 this is when we have "${@}" and $1 is '', since $@ needs
	 special handling. */
      if (tdesc && tdesc->word && (tdesc->flags & W_HASQUOTEDNULL) && QUOTED_NULL (temp))
	{
	  if (had_quoted_null_p)
	    *had_quoted_null_p = 1;
	  if (*quoted_dollar_at_p == 0)
	    {
	      free (temp);
	      tdesc->word = temp = (char *)NULL;
	    }
	    
	}

      ret = tdesc;
      goto return0;

    /* Do command or arithmetic substitution. */
    case LPAREN:
      /* We have to extract the contents of this paren substitution. */
      t_index = zindex + 1;
      /* XXX - might want to check for string[t_index+2] == LPAREN and parse
	 as arithmetic substitution immediately. */
      temp = extract_command_subst (string, &t_index, (pflags&PF_COMPLETE) ? SX_COMPLETE : 0);
      zindex = t_index;

      /* For Posix.2-style `$(( ))' arithmetic substitution,
	 extract the expression and pass it to the evaluator. */
      if (temp && *temp == LPAREN)
	{
	  char *temp2;
	  temp1 = temp + 1;
	  temp2 = savestring (temp1);
	  t_index = strlen (temp2) - 1;

	  if (temp2[t_index] != RPAREN)
	    {
	      free (temp2);
	      goto comsub;
	    }

	  /* Cut off ending `)' */
	  temp2[t_index] = '\0';

	  if (chk_arithsub (temp2, t_index) == 0)
	    {
	      free (temp2);
#if 0
	      internal_warning (_("future versions of the shell will force evaluation as an arithmetic substitution"));
#endif
	      goto comsub;
	    }

	  /* Expand variables found inside the expression. */
	  temp1 = expand_arith_string (temp2, Q_DOUBLE_QUOTES|Q_ARITH);
	  free (temp2);

arithsub:
	  /* No error messages. */
	  savecmd = this_command_name;
	  this_command_name = (char *)NULL;
	  number = evalexp (temp1, EXP_EXPANDED, &expok);
	  this_command_name = savecmd;
	  free (temp);
	  free (temp1);
	  if (expok == 0)
	    {
	      if (interactive_shell == 0 && posixly_correct)
		{
		  set_exit_status (EXECUTION_FAILURE);
		  return (&expand_wdesc_fatal);
		}
	      else
		return (&expand_wdesc_error);
	    }
	  temp = itos (number);
	  break;
	}

comsub:
      if (pflags & PF_NOCOMSUB)
	/* we need zindex+1 because string[zindex] == RPAREN */
	temp1 = substring (string, *sindex, zindex+1);
      else
	{
	  tdesc = command_substitute (temp, quoted, pflags&PF_ASSIGNRHS);
	  temp1 = tdesc ? tdesc->word : (char *)NULL;
	  if (tdesc)
	    dispose_word_desc (tdesc);
	}
      FREE (temp);
      temp = temp1;
      break;

    /* Do POSIX.2d9-style arithmetic substitution.  This will probably go
       away in a future bash release. */
    case '[':		/*]*/
      /* Extract the contents of this arithmetic substitution. */
      t_index = zindex + 1;
      temp = extract_arithmetic_subst (string, &t_index);
      zindex = t_index;
      if (temp == 0)
	{
	  temp = savestring (string);
	  if (expanded_something)
	    *expanded_something = 0;
	  goto return0;
	}	  

       /* Do initial variable expansion. */
      temp1 = expand_arith_string (temp, Q_DOUBLE_QUOTES|Q_ARITH);

      goto arithsub;

    default:
      /* Find the variable in VARIABLE_LIST. */
      temp = (char *)NULL;

      for (t_index = zindex; (c = string[zindex]) && legal_variable_char (c); zindex++)
	;
      temp1 = (zindex > t_index) ? substring (string, t_index, zindex) : (char *)NULL;

      /* If this isn't a variable name, then just output the `$'. */
      if (temp1 == 0 || *temp1 == '\0')
	{
	  FREE (temp1);
	  temp = (char *)xmalloc (2);
	  temp[0] = '$';
	  temp[1] = '\0';
	  if (expanded_something)
	    *expanded_something = 0;
	  goto return0;
	}

      /* If the variable exists, return its value cell. */
      var = find_variable (temp1);

      if (var && invisible_p (var) == 0 && var_isset (var))
	{
#if defined (ARRAY_VARS)
	  if (assoc_p (var) || array_p (var))
	    {
	      temp = array_p (var) ? array_reference (array_cell (var), 0)
				   : assoc_reference (assoc_cell (var), "0");
	      if (temp)
		temp = (*temp && (quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)))
			  ? quote_string (temp)
			  : quote_escapes (temp);
	      else if (unbound_vars_is_error)
		goto unbound_variable;
	    }
	  else
#endif
	    {
	      temp = value_cell (var);

	      temp = (*temp && (quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)))
			? quote_string (temp)
			: ((pflags & PF_ASSIGNRHS) ? quote_rhs (temp)
						   : quote_escapes (temp));
	    }

	  free (temp1);

	  goto return0;
	}
      else if (var && (invisible_p (var) || var_isset (var) == 0))
	temp = (char *)NULL;
      else if ((var = find_variable_last_nameref (temp1, 0)) && var_isset (var) && invisible_p (var) == 0)
	{
	  temp = nameref_cell (var);
#if defined (ARRAY_VARS)
	  if (temp && *temp && valid_array_reference (temp, 0))
	    {
	      tdesc = parameter_brace_expand_word (temp, SPECIAL_VAR (temp, 0), quoted, pflags, (arrayind_t *)NULL);
	      if (tdesc == &expand_wdesc_error || tdesc == &expand_wdesc_fatal)
		return (tdesc);
	      ret = tdesc;
	      goto return0;
	    }
	  else
#endif
	  /* y=2 ; typeset -n x=y; echo $x is not the same as echo $2 in ksh */
	  if (temp && *temp && legal_identifier (temp) == 0)
	    {
	      set_exit_status (EXECUTION_FAILURE);
	      report_error (_("%s: invalid variable name for name reference"), temp);
	      return (&expand_wdesc_error);	/* XXX */
	    }
	  else
	    temp = (char *)NULL;
	}

      temp = (char *)NULL;

unbound_variable:
      if (unbound_vars_is_error)
	{
	  set_exit_status (EXECUTION_FAILURE);
	  err_unboundvar (temp1);
	}
      else
	{
	  free (temp1);
	  goto return0;
	}

      free (temp1);
      set_exit_status (EXECUTION_FAILURE);
      return ((unbound_vars_is_error && interactive_shell == 0)
		? &expand_wdesc_fatal
		: &expand_wdesc_error);
    }

  if (string[zindex])
    zindex++;

return0:
  *sindex = zindex;

  if (ret == 0)
    {
      ret = alloc_word_desc ();
      ret->flags = tflag;	/* XXX */
      ret->word = temp;
    }
  return ret;
}
warning: parse error {
  char *temp, *temp1, uerror[3], *savecmd;
  int zindex, t_index, expok;
  unsigned char c;
  intmax_t number;
  SHELL_VAR *var;
  WORD_LIST *list, *l;
  WORD_DESC *tdesc, *ret;
  int tflag, nullarg;

/*itrace("param_expand: `%s' pflags = %d", string+*sindex, pflags);*/
  zindex = *sindex;
  c = string[++zindex];

  temp = (char *)NULL;
  ret = tdesc = (WORD_DESC *)NULL;
  tflag = 0;

  /* Do simple cases first. Switch on what follows '$'. */
  switch (c)
    {
    /* $0 .. $9? */
    case '0':
    case '1':
    case '2':
    case '3':
    case '4':
    case '5':
    case '6':
    case '7':
    case '8':
    case '9':
      temp1 = dollar_vars[TODIGIT (c)];
      /* This doesn't get called when (pflags&PF_IGNUNBOUND) != 0 */
      if (unbound_vars_is_error && temp1 == (char *)NULL)
	{
	  uerror[0] = '$';
	  uerror[1] = c;
	  uerror[2] = '\0';
	  set_exit_status (EXECUTION_FAILURE);
	  err_unboundvar (uerror);
	  return (interactive_shell ? &expand_wdesc_error : &expand_wdesc_fatal);
	}
      if (temp1)
	temp = (*temp1 && (quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)))
		  ? quote_string (temp1)
		  : quote_escapes (temp1);
      else
	temp = (char *)NULL;

      break;

    /* $$ -- pid of the invoking shell. */
    case '$':
      temp = itos (dollar_dollar_pid);
      break;

    /* $# -- number of positional parameters. */
    case '#':
      temp = itos (number_of_args ());
      break;

    /* $? -- return value of the last synchronous command. */
    case '?':
      temp = itos (last_command_exit_value);
      break;

    /* $- -- flags supplied to the shell on invocation or by `set'. */
    case '-':
      temp = which_set_flags ();
      break;

      /* $! -- Pid of the last asynchronous command. */
    case '!':
      /* If no asynchronous pids have been created, expand to nothing.
	 If `set -u' has been executed, and no async processes have
	 been created, this is an expansion error. */
      if (last_asynchronous_pid == NO_PID)
	{
	  if (expanded_something)
	    *expanded_something = 0;
	  temp = (char *)NULL;
	  if (unbound_vars_is_error && (pflags & PF_IGNUNBOUND) == 0)
	    {
	      uerror[0] = '$';
	      uerror[1] = c;
	      uerror[2] = '\0';
	      set_exit_status (EXECUTION_FAILURE);
	      err_unboundvar (uerror);
	      return (interactive_shell ? &expand_wdesc_error : &expand_wdesc_fatal);
	    }
	}
      else
	temp = itos (last_asynchronous_pid);
      break;

    /* The only difference between this and $@ is when the arg is quoted. */
    case '*':		/* `$*' */
      list = list_rest_of_args ();

#if 0
      /* According to austin-group posix proposal by Geoff Clare in
	 <20090505091501.GA10097@squonk.masqnet> of 5 May 2009:

 	"The shell shall write a message to standard error and
 	 immediately exit when it tries to expand an unset parameter
 	 other than the '@' and '*' special parameters."
      */

      if (list == 0 && unbound_vars_is_error && (pflags & PF_IGNUNBOUND) == 0)
	{
	  uerror[0] = '$';
	  uerror[1] = '*';
	  uerror[2] = '\0';
	  set_exit_status (EXECUTION_FAILURE);
	  err_unboundvar (uerror);
	  return (interactive_shell ? &expand_wdesc_error : &expand_wdesc_fatal);
	}
#endif

      /* If there are no command-line arguments, this should just
	 disappear if there are other characters in the expansion,
	 even if it's quoted. */
      if ((quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)) && list == 0)
	temp = (char *)NULL;
      else if (quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES|Q_PATQUOTE))
	{
	  /* If we have "$*" we want to make a string of the positional
	     parameters, separated by the first character of $IFS, and
	     quote the whole string, including the separators.  If IFS
	     is unset, the parameters are separated by ' '; if $IFS is
	     null, the parameters are concatenated. */
	  temp = (quoted & (Q_DOUBLE_QUOTES|Q_PATQUOTE)) ? string_list_dollar_star (list, quoted, 0) : string_list (list);
	  if (temp)
	    {
	      temp1 = (quoted & Q_DOUBLE_QUOTES) ? quote_string (temp) : temp;
	      if (*temp == 0)
		tflag |= W_HASQUOTEDNULL;
	      if (temp != temp1)
		free (temp);
	      temp = temp1;
	    }
	}
      else
	{
	  /* We check whether or not we're eventually going to split $* here,
	     for example when IFS is empty and we are processing the rhs of
	     an assignment statement.  In that case, we don't separate the
	     arguments at all.  Otherwise, if the $* is not quoted it is
	     identical to $@ */
	  if (expand_no_split_dollar_star && quoted == 0 && ifs_is_set == 0 && (pflags & PF_ASSIGNRHS))
	    {
	      /* Posix interp 888: RHS of assignment, IFS unset: no splitting,
		 separate with space */
	      temp1 = string_list_dollar_star (list, quoted, pflags);
	      temp = temp1 ? quote_string (temp1) : temp1;
	      /* XXX - tentative - note that we saw a quoted null here */
	      if (temp1 && *temp1 == 0 && QUOTED_NULL (temp))
		tflag |= W_SAWQUOTEDNULL;
	      FREE (temp1);
	    }
	  else if (expand_no_split_dollar_star && quoted == 0 && ifs_is_null && (pflags & PF_ASSIGNRHS))
	    {
	      /* Posix interp 888: RHS of assignment, IFS set to '' */
	      temp1 = string_list_dollar_star (list, quoted, pflags);
	      temp = temp1 ? quote_escapes (temp1) : temp1;
	      FREE (temp1);
	    }
	  else if (expand_no_split_dollar_star && quoted == 0 && ifs_is_set && ifs_is_null == 0 && (pflags & PF_ASSIGNRHS))
	    {
	      /* Posix interp 888: RHS of assignment, IFS set to non-null value */
	      temp1 = string_list_dollar_star (list, quoted, pflags);
	      temp = temp1 ? quote_string (temp1) : temp1;

	      /* XXX - tentative - note that we saw a quoted null here */
	      if (temp1 && *temp1 == 0 && QUOTED_NULL (temp))
		tflag |= W_SAWQUOTEDNULL;
	      FREE (temp1);
	    }
	  /* XXX - should we check ifs_is_set here as well? */
#  if defined (HANDLE_MULTIBYTE)
	  else if (expand_no_split_dollar_star && ifs_firstc[0] == 0)
#  else
	  else if (expand_no_split_dollar_star && ifs_firstc == 0)
#  endif
	    /* Posix interp 888: not RHS, no splitting, IFS set to '' */
	    temp = string_list_dollar_star (list, quoted, 0);
	  else
	    {
	      temp = string_list_dollar_at (list, quoted, 0);
	      /* Set W_SPLITSPACE to make sure the individual positional
		 parameters are split into separate arguments */
#if 0
	      if (quoted == 0 && (ifs_is_set == 0 || ifs_is_null))
#else	/* change with bash-5.0 */
	      if (quoted == 0 && ifs_is_null)
#endif
		tflag |= W_SPLITSPACE;
	      /* If we're not quoted but we still don't want word splitting, make
		 we quote the IFS characters to protect them from splitting (e.g.,
		 when $@ is in the string as well). */
	      else if (temp && quoted == 0 && ifs_is_set && (pflags & PF_ASSIGNRHS))
		{
		  temp1 = quote_string (temp);
		  free (temp);
		  temp = temp1;
		}
	    }

	  if (expand_no_split_dollar_star == 0 && contains_dollar_at)
	    *contains_dollar_at = 1;
	}

      dispose_words (list);
      break;

    /* When we have "$@" what we want is "$1" "$2" "$3" ... This
       means that we have to turn quoting off after we split into
       the individually quoted arguments so that the final split
       on the first character of $IFS is still done.  */
    case '@':		/* `$@' */
      list = list_rest_of_args ();

#if 0
      /* According to austin-group posix proposal by Geoff Clare in
	 <20090505091501.GA10097@squonk.masqnet> of 5 May 2009:

 	"The shell shall write a message to standard error and
 	 immediately exit when it tries to expand an unset parameter
 	 other than the '@' and '*' special parameters."
      */

      if (list == 0 && unbound_vars_is_error && (pflags & PF_IGNUNBOUND) == 0)
	{
	  uerror[0] = '$';
	  uerror[1] = '@';
	  uerror[2] = '\0';
	  set_exit_status (EXECUTION_FAILURE);
	  err_unboundvar (uerror);
	  return (interactive_shell ? &expand_wdesc_error : &expand_wdesc_fatal);
	}
#endif

      for (nullarg = 0, l = list; l; l = l->next)
	{
	  if (l->word && (l->word->word == 0 || l->word->word[0] == 0))
	    nullarg = 1;
	}

      /* We want to flag the fact that we saw this.  We can't turn
	 off quoting entirely, because other characters in the
	 string might need it (consider "\"$@\""), but we need some
	 way to signal that the final split on the first character
	 of $IFS should be done, even though QUOTED is 1. */
      /* XXX - should this test include Q_PATQUOTE? */
      if (quoted_dollar_at_p && (quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)))
	*quoted_dollar_at_p = 1;
      if (contains_dollar_at)
	*contains_dollar_at = 1;

      /* We want to separate the positional parameters with the first
	 character of $IFS in case $IFS is something other than a space.
	 We also want to make sure that splitting is done no matter what --
	 according to POSIX.2, this expands to a list of the positional
	 parameters no matter what IFS is set to. */
      /* XXX - what to do when in a context where word splitting is not
	 performed? Even when IFS is not the default, posix seems to imply
	 that we have to expand $@ to all the positional parameters and
	 separate them with spaces, which are preserved because word splitting
	 doesn't take place.  See below for how we use PF_NOSPLIT2 here. */

      /* These are the cases where word splitting will not be performed. */
      if (pflags & PF_ASSIGNRHS)
	{
	  temp = string_list_dollar_at (list, (quoted|Q_DOUBLE_QUOTES), pflags);
	  if (nullarg)
	    tflag |= W_HASQUOTEDNULL;	/* we know quoting produces quoted nulls */
	}

      /* This needs to match what expand_word_internal does with non-quoted $@
	 does with separating with spaces.  Passing Q_DOUBLE_QUOTES means that
	 the characters in LIST will be quoted, and PF_ASSIGNRHS ensures that
	 they will separated by spaces. After doing this, we need the special
	 handling for PF_NOSPLIT2 in expand_word_internal to remove the CTLESC
	 quotes. */
      else if (pflags & PF_NOSPLIT2)
        {
#if defined (HANDLE_MULTIBYTE)
	  if (quoted == 0 && ifs_is_set && ifs_is_null == 0 && ifs_firstc[0] != ' ')
#else
	  if (quoted == 0 && ifs_is_set && ifs_is_null == 0 && ifs_firstc != ' ')
#endif
	    /* Posix interp 888 */
	    temp = string_list_dollar_at (list, Q_DOUBLE_QUOTES, pflags);
	  else
	    temp = string_list_dollar_at (list, quoted, pflags);
	}
      else
	temp = string_list_dollar_at (list, quoted, pflags);

      tflag |= W_DOLLARAT;
      dispose_words (list);
      break;

    case LBRACE:
      tdesc = parameter_brace_expand (string, &zindex, quoted, pflags,
				      quoted_dollar_at_p,
				      contains_dollar_at);

      if (tdesc == &expand_wdesc_error || tdesc == &expand_wdesc_fatal)
	return (tdesc);
      temp = tdesc ? tdesc->word : (char *)0;

      /* XXX */
      /* Quoted nulls should be removed if there is anything else
	 in the string. */
      /* Note that we saw the quoted null so we can add one back at
	 the end of this function if there are no other characters
	 in the string, discard TEMP, and go on.  The exception to
	 this is when we have "${@}" and $1 is '', since $@ needs
	 special handling. */
      if (tdesc && tdesc->word && (tdesc->flags & W_HASQUOTEDNULL) && QUOTED_NULL (temp))
	{
	  if (had_quoted_null_p)
	    *had_quoted_null_p = 1;
	  if (*quoted_dollar_at_p == 0)
	    {
	      free (temp);
	      tdesc->word = temp = (char *)NULL;
	    }
	    
	}

      ret = tdesc;
      goto return0;

    /* Do command or arithmetic substitution. */
    case LPAREN:
      /* We have to extract the contents of this paren substitution. */
      t_index = zindex + 1;
      /* XXX - might want to check for string[t_index+2] == LPAREN and parse
	 as arithmetic substitution immediately. */
      temp = extract_command_subst (string, &t_index, (pflags&PF_COMPLETE) ? SX_COMPLETE : 0);
      zindex = t_index;

      /* For Posix.2-style `$(( ))' arithmetic substitution,
	 extract the expression and pass it to the evaluator. */
      if (temp && *temp == LPAREN)
	{
	  char *temp2;
	  temp1 = temp + 1;
	  temp2 = savestring (temp1);
	  t_index = strlen (temp2) - 1;

	  if (temp2[t_index] != RPAREN)
	    {
	      free (temp2);
	      goto comsub;
	    }

	  /* Cut off ending `)' */
	  temp2[t_index] = '\0';

	  if (chk_arithsub (temp2, t_index) == 0)
	    {
	      free (temp2);
#if 0
	      internal_warning (_("future versions of the shell will force evaluation as an arithmetic substitution"));
#endif
	      goto comsub;
	    }

	  /* Expand variables found inside the expression. */
	  temp1 = expand_arith_string (temp2, Q_DOUBLE_QUOTES|Q_ARITH);
	  free (temp2);

arithsub:
	  /* No error messages. */
	  savecmd = this_command_name;
	  this_command_name = (char *)NULL;
	  number = evalexp (temp1, EXP_EXPANDED, &expok);
	  this_command_name = savecmd;
	  free (temp);
	  free (temp1);
	  if (expok == 0)
	    {
	      if (interactive_shell == 0 && posixly_correct)
		{
		  set_exit_status (EXECUTION_FAILURE);
		  return (&expand_wdesc_fatal);
		}
	      else
		return (&expand_wdesc_error);
	    }
	  temp = itos (number);
	  break;
	}

comsub:
      if (pflags & PF_NOCOMSUB)
	/* we need zindex+1 because string[zindex] == RPAREN */
	temp1 = substring (string, *sindex, zindex+1);
      else
	{
	  tdesc = command_substitute (temp, quoted, pflags&PF_ASSIGNRHS);
	  temp1 = tdesc ? tdesc->word : (char *)NULL;
	  if (tdesc)
	    dispose_word_desc (tdesc);
	}
      FREE (temp);
      temp = temp1;
      break;

    /* Do POSIX.2d9-style arithmetic substitution.  This will probably go
       away in a future bash release. */
    case '[':		/*]*/
      /* Extract the contents of this arithmetic substitution. */
      t_index = zindex + 1;
      temp = extract_arithmetic_subst (string, &t_index);
      zindex = t_index;
      if (temp == 0)
	{
	  temp = savestring (string);
	  if (expanded_something)
	    *expanded_something = 0;
	  goto return0;
	}	  

       /* Do initial variable expansion. */
      temp1 = expand_arith_string (temp, Q_DOUBLE_QUOTES|Q_ARITH);

      goto arithsub;

    default:
      /* Find the variable in VARIABLE_LIST. */
      temp = (char *)NULL;

      for (t_index = zindex; (c = string[zindex]) && legal_variable_char (c); zindex++)
	;
      temp1 = (zindex > t_index) ? substring (string, t_index, zindex) : (char *)NULL;

      /* If this isn't a variable name, then just output the `$'. */
      if (temp1 == 0 || *temp1 == '\0')
	{
	  FREE (temp1);
	  temp = (char *)xmalloc (2);
	  temp[0] = '$';
	  temp[1] = '\0';
	  if (expanded_something)
	    *expanded_something = 0;
	  goto return0;
	}

      /* If the variable exists, return its value cell. */
      var = find_variable (temp1);

      if (var && invisible_p (var) == 0 && var_isset (var))
	{
#if defined (ARRAY_VARS)
	  if (assoc_p (var) || array_p (var))
	    {
	      temp = array_p (var) ? array_reference (array_cell (var), 0)
				   : assoc_reference (assoc_cell (var), "0");
	      if (temp)
		temp = (*temp && (quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)))
			  ? quote_string (temp)
			  : quote_escapes (temp);
	      else if (unbound_vars_is_error)
		goto unbound_variable;
	    }
	  else
#endif
	    {
	      temp = value_cell (var);

	      temp = (*temp && (quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)))
			? quote_string (temp)
			: ((pflags & PF_ASSIGNRHS) ? quote_rhs (temp)
						   : quote_escapes (temp));
	    }

	  free (temp1);

	  goto return0;
	}
      else if (var && (invisible_p (var) || var_isset (var) == 0))
	temp = (char *)NULL;
      else if ((var = find_variable_last_nameref (temp1, 0)) && var_isset (var) && invisible_p (var) == 0)
	{
	  temp = nameref_cell (var);
#if defined (ARRAY_VARS)
	  if (temp && *temp && valid_array_reference (temp, 0))
	    {
	      tdesc = parameter_brace_expand_word (temp, SPECIAL_VAR (temp, 0), quoted, pflags, (arrayind_t *)NULL);
	      if (tdesc == &expand_wdesc_error || tdesc == &expand_wdesc_fatal)
		return (tdesc);
	      ret = tdesc;
	      goto return0;
	    }
	  else
#endif
	  /* y=2 ; typeset -n x=y; echo $x is not the same as echo $2 in ksh */
	  if (temp && *temp && legal_identifier (temp) == 0)
	    {
	      set_exit_status (EXECUTION_FAILURE);
	      report_error (_("%s: invalid variable name for name reference"), temp);
	      return (&expand_wdesc_error);	/* XXX */
	    }
	  else
	    temp = (char *)NULL;
	}

      temp = (char *)NULL;

unbound_variable:
      if (unbound_vars_is_error)
	{
	  set_exit_status (EXECUTION_FAILURE);
	  err_unboundvar (temp1);
	}
      else
	{
	  free (temp1);
	  goto return0;
	}

      free (temp1);
      set_exit_status (EXECUTION_FAILURE);
      return ((unbound_vars_is_error && interactive_shell == 0)
		? &expand_wdesc_fatal
		: &expand_wdesc_error);
    }

  if (string[zindex])
    zindex++;

return0:
  *sindex = zindex;

  if (ret == 0)
    {
      ret = alloc_word_desc ();
      ret->flags = tflag;	/* XXX */
      ret->word = temp;
    }
  return ret;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:9,447
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:10,029
parsing error 
{
  WORD_LIST *list;
  WORD_DESC *tword;

  /* The intermediate string that we build while expanding. */
  char *istring;

  /* The current size of the above object. */
  size_t istring_size;

  /* Index into ISTRING. */
  int istring_index;

  /* Temporary string storage. */
  char *temp, *temp1;

  /* The text of WORD. */
  register char *string;

  /* The size of STRING. */
  size_t string_size;

  /* The index into STRING. */
  int sindex;

  /* This gets 1 if we see a $@ while quoted. */
  int quoted_dollar_at;

  /* One of UNQUOTED, PARTIALLY_QUOTED, or WHOLLY_QUOTED, depending on
     whether WORD contains no quoting characters, a partially quoted
     string (e.g., "xx"ab), or is fully quoted (e.g., "xxab"). */
  int quoted_state;

  /* State flags */
  int had_quoted_null;
  int has_quoted_ifs;		/* did we add a quoted $IFS character here? */
  int has_dollar_at, temp_has_dollar_at;
  int split_on_spaces;
  int local_expanded;
  int tflag;
  int pflags;			/* flags passed to param_expand */
  int mb_cur_max;

  int assignoff;		/* If assignment, offset of `=' */

  register unsigned char c;	/* Current character. */
  int t_index;			/* For calls to string_extract_xxx. */

  char twochars[2];

  DECLARE_MBSTATE;

  /* OK, let's see if we can optimize a common idiom: "$@" */
  if (STREQ (word->word, "\"$@\"") &&
      (word->flags == (W_HASDOLLAR|W_QUOTED)) &&
      dollar_vars[1])		/* XXX - check IFS here as well? */
    {
      if (contains_dollar_at)
	*contains_dollar_at = 1;
      if (expanded_something)
	*expanded_something = 1;
      if (cached_quoted_dollar_at)
	return (copy_word_list (cached_quoted_dollar_at));
      list = list_rest_of_args ();
      list = quote_list (list);
      cached_quoted_dollar_at = copy_word_list (list);
      return (list);
    }

  istring = (char *)xmalloc (istring_size = DEFAULT_INITIAL_ARRAY_SIZE);
  istring[istring_index = 0] = '\0';
  quoted_dollar_at = had_quoted_null = has_dollar_at = 0;
  has_quoted_ifs = 0;
  split_on_spaces = 0;
  quoted_state = UNQUOTED;

  string = word->word;
  if (string == 0)
    goto finished_with_string;
  mb_cur_max = MB_CUR_MAX;

  /* Don't need the string length for the SADD... and COPY_ macros unless
     multibyte characters are possible, but do need it for bounds checking. */
  string_size = (mb_cur_max > 1) ? strlen (string) : 1;

  if (contains_dollar_at)
    *contains_dollar_at = 0;

  assignoff = -1;

  /* Begin the expansion. */

  for (sindex = 0; ;)
    {
      c = string[sindex];

      /* Case on top-level character. */
      switch (c)
	{
	case '\0':
	  goto finished_with_string;

	case CTLESC:
	  sindex++;
#if HANDLE_MULTIBYTE
	  if (mb_cur_max > 1 && string[sindex])
	    {
	      SADD_MBQCHAR_BODY(temp, string, sindex, string_size);
	    }
	  else
#endif
	    {
	      temp = (char *)xmalloc (3);
	      temp[0] = CTLESC;
	      temp[1] = c = string[sindex];
	      temp[2] = '\0';
	    }

dollar_add_string:
	  if (string[sindex])
	    sindex++;

add_string:
	  if (temp)
	    {
	      istring = sub_append_string (temp, istring, &istring_index, &istring_size);
	      temp = (char *)0;
	    }

	  break;

#if defined (PROCESS_SUBSTITUTION)
	  /* Process substitution. */
	case '<':
	case '>':
	  {
	       /* XXX - technically this should only be expanded at the start
	       of a word */
	    if (string[++sindex] != LPAREN || (quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)) || (word->flags & (W_DQUOTE|W_NOPROCSUB)))
	      {
		sindex--;	/* add_character: label increments sindex */
		goto add_character;
	      }
	    else
	      t_index = sindex + 1; /* skip past both '<' and LPAREN */

	    temp1 = extract_process_subst (string, (c == '<') ? "<(" : ">(", &t_index, 0); /*))*/
	    sindex = t_index;

	    /* If the process substitution specification is `<()', we want to
	       open the pipe for writing in the child and produce output; if
	       it is `>()', we want to open the pipe for reading in the child
	       and consume input. */
	    temp = temp1 ? process_substitute (temp1, (c == '>')) : (char *)0;

	    FREE (temp1);

	    goto dollar_add_string;
	  }
#endif /* PROCESS_SUBSTITUTION */

	case '=':
	  /* Posix.2 section 3.6.1 says that tildes following `=' in words
	     which are not assignment statements are not expanded.  If the
	     shell isn't in posix mode, though, we perform tilde expansion
	     on `likely candidate' unquoted assignment statements (flags
	     include W_ASSIGNMENT but not W_QUOTED).  A likely candidate
	     contains an unquoted :~ or =~.  Something to think about: we
	     now have a flag that says  to perform tilde expansion on arguments
	     to `assignment builtins' like declare and export that look like
	     assignment statements.  We now do tilde expansion on such words
	     even in POSIX mode. */	
	  if (word->flags & (W_ASSIGNRHS|W_NOTILDE))
	    {
	      if (isexp == 0 && (word->flags & (W_NOSPLIT|W_NOSPLIT2)) == 0 && isifs (c))
		goto add_ifs_character;
	      else
		goto add_character;
	    }
	  /* If we're not in posix mode or forcing assignment-statement tilde
	     expansion, note where the first `=' appears in the word and prepare
	     to do tilde expansion following the first `='. We have to keep
	     track of the first `=' (using assignoff) to avoid being confused
	     by an `=' in the rhs of the assignment statement. */
	  if ((word->flags & W_ASSIGNMENT) &&
	      (posixly_correct == 0 || (word->flags & W_TILDEEXP)) &&
	      assignoff == -1 && sindex > 0)
	    assignoff = sindex;
	  if (sindex == assignoff && string[sindex+1] == '~')	/* XXX */
	    word->flags |= W_ITILDE;

	  if (word->flags & W_ASSIGNARG)
	    word->flags |= W_ASSIGNRHS;		/* affects $@ */

	  if (isexp == 0 && (word->flags & (W_NOSPLIT|W_NOSPLIT2)) == 0 && isifs (c))
	    {
	      has_quoted_ifs++;
	      goto add_ifs_character;
	    }
	  else
	    goto add_character;

	case ':':
	  if (word->flags & (W_NOTILDE|W_NOASSNTILDE))
	    {
	      if (isexp == 0 && (word->flags & (W_NOSPLIT|W_NOSPLIT2)) == 0 && isifs (c))
		goto add_ifs_character;
	      else
		goto add_character;
	    }

	  if ((word->flags & (W_ASSIGNMENT|W_ASSIGNRHS)) &&
	      (posixly_correct == 0 || (word->flags & W_TILDEEXP)) &&
	      string[sindex+1] == '~')
	    word->flags |= W_ITILDE;

	  if (isexp == 0 && (word->flags & (W_NOSPLIT|W_NOSPLIT2)) == 0 && isifs (c))
	    goto add_ifs_character;
	  else
	    goto add_character;

	case '~':
	  /* If the word isn't supposed to be tilde expanded, or we're not
	     at the start of a word or after an unquoted : or = in an
	     assignment statement, we don't do tilde expansion.  We don't
	     do tilde expansion if quoted or in an arithmetic context. */

	  if ((word->flags & (W_NOTILDE|W_DQUOTE)) ||
	      (sindex > 0 && ((word->flags & W_ITILDE) == 0)) ||
	      (quoted & (Q_DOUBLE_QUOTES|Q_HERE_DOCUMENT)))
	    {
	      word->flags &= ~W_ITILDE;
	      if (isexp == 0 && (word->flags & (W_NOSPLIT|W_NOSPLIT2)) == 0 && isifs (c) && (quoted & (Q_DOUBLE_QUOTES|Q_HERE_DOCUMENT)) == 0)
		goto add_ifs_character;
	      else
		goto add_character;
	    }

	  if (word->flags & W_ASSIGNRHS)
	    tflag = 2;
	  else if (word->flags & (W_ASSIGNMENT|W_TILDEEXP))
	    tflag = 1;
	  else
	    tflag = 0;

	  temp = bash_tilde_find_word (string + sindex, tflag, &t_index);
	    
	  word->flags &= ~W_ITILDE;

	  if (temp && *temp && t_index > 0)
	    {
	      temp1 = bash_tilde_expand (temp, tflag);
	      if  (temp1 && *temp1 == '~' && STREQ (temp, temp1))
		{
		  FREE (temp);
		  FREE (temp1);
		  goto add_character;		/* tilde expansion failed */
		}
	      free (temp);
	      temp = temp1;
	      sindex += t_index;
	      goto add_quoted_string;		/* XXX was add_string */
	    }
	  else
	    {
	      FREE (temp);
	      goto add_character;
	    }
	
	case '$':
	  if (expanded_something)
	    *expanded_something = 1;
	  local_expanded = 1;

	  temp_has_dollar_at = 0;
	  pflags = (word->flags & W_NOCOMSUB) ? PF_NOCOMSUB : 0;
	  if (word->flags & W_NOSPLIT2)
	    pflags |= PF_NOSPLIT2;
	  if (word->flags & W_ASSIGNRHS)
	    pflags |= PF_ASSIGNRHS;
	  if (word->flags & W_COMPLETE)
	    pflags |= PF_COMPLETE;

	  tword = param_expand (string, &sindex, quoted, expanded_something,
			       &temp_has_dollar_at, &quoted_dollar_at,
			       &had_quoted_null, pflags);
	  has_dollar_at += temp_has_dollar_at;
	  split_on_spaces += (tword->flags & W_SPLITSPACE);

	  if (tword == &expand_wdesc_error || tword == &expand_wdesc_fatal)
	    {
	      free (string);
	      free (istring);
	      return ((tword == &expand_wdesc_error) ? &expand_word_error
						     : &expand_word_fatal);
	    }
	  if (contains_dollar_at && has_dollar_at)
	    *contains_dollar_at = 1;

	  if (tword && (tword->flags & W_HASQUOTEDNULL))
	    had_quoted_null = 1;		/* note for later */
	  if (tword && (tword->flags & W_SAWQUOTEDNULL))
	    had_quoted_null = 1;		/* XXX */

	  temp = tword ? tword->word : (char *)NULL;
	  dispose_word_desc (tword);

	  /* Kill quoted nulls; we will add them back at the end of
	     expand_word_internal if nothing else in the string */
	  if (had_quoted_null && temp && QUOTED_NULL (temp))
	    {
	      FREE (temp);
	      temp = (char *)NULL;
	    }

	  goto add_string;
	  break;

	case '`':		/* Backquoted command substitution. */
	  {
	    t_index = sindex++;

	    temp = string_extract (string, &sindex, "`", SX_REQMATCH);
	    /* The test of sindex against t_index is to allow bare instances of
	       ` to pass through, for backwards compatibility. */
	    if (temp == &extract_string_error || temp == &extract_string_fatal)
	      {
		if (sindex - 1 == t_index)
		  {
		    sindex = t_index;
		    goto add_character;
		  }
		set_exit_status (EXECUTION_FAILURE);
		report_error (_("bad substitution: no closing \"`\" in %s") , string+t_index);
		free (string);
		free (istring);
		return ((temp == &extract_string_error) ? &expand_word_error
							: &expand_word_fatal);
	      }
		
	    if (expanded_something)
	      *expanded_something = 1;
	    local_expanded = 1;

	    if (word->flags & W_NOCOMSUB)
	      /* sindex + 1 because string[sindex] == '`' */
	      temp1 = substring (string, t_index, sindex + 1);
	    else
	      {
		de_backslash (temp);
		tword = command_substitute (temp, quoted, 0);
		temp1 = tword ? tword->word : (char *)NULL;
		if (tword)
		  dispose_word_desc (tword);
	      }
	    FREE (temp);
	    temp = temp1;
	    goto dollar_add_string;
	  }

	case '\\':
	  if (string[sindex + 1] == '\n')
	    {
	      sindex += 2;
	      continue;
	    }

	  c = string[++sindex];

	  /* "However, the double-quote character ( '"' ) shall not be treated
	     specially within a here-document, except when the double-quote
	     appears within "$()", "``", or "${}"." */
	  if ((quoted & Q_HERE_DOCUMENT) && (quoted & Q_DOLBRACE) && c == '"')
	    tflag = CBSDQUOTE;		/* special case */
	  else if (quoted & Q_HERE_DOCUMENT)
	    tflag = CBSHDOC;
	  else if (quoted & Q_DOUBLE_QUOTES)
	    tflag = CBSDQUOTE;
	  else
	    tflag = 0;

	  /* From Posix discussion on austin-group list:  Backslash escaping
	     a } in ${...} is removed.  Issue 0000221 */
	  if ((quoted & Q_DOLBRACE) && c == RBRACE)
	    {
	      SCOPY_CHAR_I (twochars, CTLESC, c, string, sindex, string_size);
	    }
	  /* This is the fix for " $@\ " */
	  else if ((quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)) && ((sh_syntaxtab[c] & tflag) == 0) && isexp == 0 && isifs (c))
	    {
	      RESIZE_MALLOCED_BUFFER (istring, istring_index, 2, istring_size,
				      DEFAULT_ARRAY_SIZE);
	      istring[istring_index++] = CTLESC;
	      istring[istring_index++] = '\\';
	      istring[istring_index] = '\0';

	      SCOPY_CHAR_I (twochars, CTLESC, c, string, sindex, string_size);
	    }
	  else if ((quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)) && c == 0)
	    {
	      RESIZE_MALLOCED_BUFFER (istring, istring_index, 2, istring_size,
				      DEFAULT_ARRAY_SIZE);
	      istring[istring_index++] = CTLESC;
	      istring[istring_index++] = '\\';
	      istring[istring_index] = '\0';
	      break;	      
	    }
	  else if ((quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)) && ((sh_syntaxtab[c] & tflag) == 0))
	    {
	      SCOPY_CHAR_I (twochars, '\\', c, string, sindex, string_size);
	    }
	  else if (c == 0)
	    {
	      c = CTLNUL;
	      sindex--;		/* add_character: label increments sindex */
	      goto add_character;
	    }
	  else
	    {
	      SCOPY_CHAR_I (twochars, CTLESC, c, string, sindex, string_size);
	    }

	  sindex++;
add_twochars:
	  /* BEFORE jumping here, we need to increment sindex if appropriate */
	  RESIZE_MALLOCED_BUFFER (istring, istring_index, 2, istring_size,
				  DEFAULT_ARRAY_SIZE);
	  istring[istring_index++] = twochars[0];
	  istring[istring_index++] = twochars[1];
	  istring[istring_index] = '\0';

	  break;

	case '"':
	  if ((quoted & (Q_DOUBLE_QUOTES|Q_HERE_DOCUMENT)) && ((quoted & Q_ARITH) == 0))
	    goto add_character;

	  t_index = ++sindex;
	  temp = string_extract_double_quoted (string, &sindex, (word->flags & W_COMPLETE) ? SX_COMPLETE : 0);

	  /* If the quotes surrounded the entire string, then the
	     whole word was quoted. */
	  quoted_state = (t_index == 1 && string[sindex] == '\0')
			    ? WHOLLY_QUOTED
			    : PARTIALLY_QUOTED;

	  if (temp && *temp)
	    {
	      tword = alloc_word_desc ();
	      tword->word = temp;

	      if (word->flags & W_ASSIGNARG)
		tword->flags |= word->flags & (W_ASSIGNARG|W_ASSIGNRHS); /* affects $@ */
	      if (word->flags & W_COMPLETE)
		tword->flags |= W_COMPLETE;	/* for command substitutions */
	      if (word->flags & W_NOCOMSUB)
		tword->flags |= W_NOCOMSUB;
	      if (word->flags & W_NOPROCSUB)
		tword->flags |= W_NOPROCSUB;

	      if (word->flags & W_ASSIGNRHS)
		tword->flags |= W_ASSIGNRHS;

	      temp = (char *)NULL;

	      temp_has_dollar_at = 0;	/* does this quoted (sub)string include $@? */
	      /* Need to get W_HASQUOTEDNULL flag through this function. */
	      list = expand_word_internal (tword, Q_DOUBLE_QUOTES, 0, &temp_has_dollar_at, (int *)NULL);
	      has_dollar_at += temp_has_dollar_at;

	      if (list == &expand_word_error || list == &expand_word_fatal)
		{
		  free (istring);
		  free (string);
		  /* expand_word_internal has already freed temp_word->word
		     for us because of the way it prints error messages. */
		  tword->word = (char *)NULL;
		  dispose_word (tword);
		  return list;
		}

	      dispose_word (tword);

	      /* "$@" (a double-quoted dollar-at) expands into nothing,
		 not even a NULL word, when there are no positional
		 parameters.  Posix interp 888 says that other parts of the
		 word that expand to quoted nulls result in quoted nulls, so
		 we can't just throw the entire word away if we have "$@"
		 anywhere in it.  We use had_quoted_null to keep track */
	      if (list == 0 && temp_has_dollar_at)	/* XXX - was has_dollar_at */
		{
		  quoted_dollar_at++;
		  break;
		}

	      /* If this list comes back with a quoted null from expansion,
		 we have either "$x" or "$@" with $1 == ''. In either case,
		 we need to make sure we add a quoted null argument and
		 disable the special handling that "$@" gets. */
	      if (list && list->word && list->next == 0 && (list->word->flags & W_HASQUOTEDNULL))
		{
		  if (had_quoted_null && temp_has_dollar_at)
		    quoted_dollar_at++;
		  had_quoted_null = 1;		/* XXX */
		}

	      /* If we get "$@", we know we have expanded something, so we
		 need to remember it for the final split on $IFS.  This is
		 a special case; it's the only case where a quoted string
		 can expand into more than one word.  It's going to come back
		 from the above call to expand_word_internal as a list with
		 multiple words. */
	      if (list)
		dequote_list (list);

	      if (temp_has_dollar_at)		/* XXX - was has_dollar_at */
		{
		  quoted_dollar_at++;
		  if (contains_dollar_at)
		    *contains_dollar_at = 1;
		  if (expanded_something)
		    *expanded_something = 1;
		  local_expanded = 1;
		}
	    }
	  else
	    {
	      /* What we have is "".  This is a minor optimization. */
	      FREE (temp);
	      list = (WORD_LIST *)NULL;
	      had_quoted_null = 1;	/* note for later */
	    }

	  /* The code above *might* return a list (consider the case of "$@",
	     where it returns "$1", "$2", etc.).  We can't throw away the
	     rest of the list, and we have to make sure each word gets added
	     as quoted.  We test on tresult->next:  if it is non-NULL, we
	     quote the whole list, save it to a string with string_list, and
	     add that string. We don't need to quote the results of this
	     (and it would be wrong, since that would quote the separators
	     as well), so we go directly to add_string. */
	  if (list)
	    {
	      if (list->next)
		{
		  /* Testing quoted_dollar_at makes sure that "$@" is
		     split correctly when $IFS does not contain a space. */
		  temp = quoted_dollar_at
				? string_list_dollar_at (list, Q_DOUBLE_QUOTES, 0)
				: string_list (quote_list (list));
		  dispose_words (list);
		  goto add_string;
		}
	      else
		{
		  temp = savestring (list->word->word);
		  tflag = list->word->flags;
		  dispose_words (list);

		  /* If the string is not a quoted null string, we want
		     to remove any embedded unquoted CTLNUL characters.
		     We do not want to turn quoted null strings back into
		     the empty string, though.  We do this because we
		     want to remove any quoted nulls from expansions that
		     contain other characters.  For example, if we have
		     x"$*"y or "x$*y" and there are no positional parameters,
		     the $* should expand into nothing. */
		  /* We use the W_HASQUOTEDNULL flag to differentiate the
		     cases:  a quoted null character as above and when
		     CTLNUL is contained in the (non-null) expansion
		     of some variable.  We use the had_quoted_null flag to
		     pass the value through this function to its caller. */
		  if ((tflag & W_HASQUOTEDNULL) && QUOTED_NULL (temp) == 0)
		    remove_quoted_nulls (temp);	/* XXX */
		}
	    }
	  else
	    temp = (char *)NULL;

	  if (temp == 0 && quoted_state == PARTIALLY_QUOTED)
	    had_quoted_null = 1;	/* note for later */

	  /* We do not want to add quoted nulls to strings that are only
	     partially quoted; we can throw them away.  The exception to
	     this is when we are going to be performing word splitting,
	     since we have to preserve a null argument if the next character
	     will cause word splitting. */
	  if (temp == 0 && quoted_state == PARTIALLY_QUOTED && quoted == 0 && (word->flags & (W_NOSPLIT|W_EXPANDRHS|W_ASSIGNRHS)) == W_EXPANDRHS)
	    {
	      c = CTLNUL;
	      sindex--;
	      had_quoted_null = 1;
	      goto add_character;
	    }
	  if (temp == 0 && quoted_state == PARTIALLY_QUOTED && (word->flags & (W_NOSPLIT|W_NOSPLIT2)))
	    continue;

	add_quoted_string:

	  if (temp)
	    {
	      temp1 = temp;
	      temp = quote_string (temp);
	      free (temp1);
	      goto add_string;
	    }
	  else
	    {
	      /* Add NULL arg. */
	      c = CTLNUL;
	      sindex--;		/* add_character: label increments sindex */
	      had_quoted_null = 1;	/* note for later */
	      goto add_character;
	    }

	  /* break; */

	case '\'':
	  if ((quoted & (Q_DOUBLE_QUOTES|Q_HERE_DOCUMENT)))
	    goto add_character;

	  t_index = ++sindex;
	  temp = string_extract_single_quoted (string, &sindex);

	  /* If the entire STRING was surrounded by single quotes,
	     then the string is wholly quoted. */
	  quoted_state = (t_index == 1 && string[sindex] == '\0')
			    ? WHOLLY_QUOTED
			    : PARTIALLY_QUOTED;

	  /* If all we had was '', it is a null expansion. */
	  if (*temp == '\0')
	    {
	      free (temp);
	      temp = (char *)NULL;
	    }
	  else
	    remove_quoted_escapes (temp);	/* ??? */

	  if (temp == 0 && quoted_state == PARTIALLY_QUOTED)
	    had_quoted_null = 1;	/* note for later */

	  /* We do not want to add quoted nulls to strings that are only
	     partially quoted; such nulls are discarded.  See above for the
	     exception, which is when the string is going to be split.
	     Posix interp 888/1129 */
	  if (temp == 0 && quoted_state == PARTIALLY_QUOTED && quoted == 0 && (word->flags & (W_NOSPLIT|W_EXPANDRHS|W_ASSIGNRHS)) == W_EXPANDRHS)
	    {
	      c = CTLNUL;
	      sindex--;
	      goto add_character;
	    }

	  if (temp == 0 && (quoted_state == PARTIALLY_QUOTED) && (word->flags & (W_NOSPLIT|W_NOSPLIT2)))
	    continue;

	  /* If we have a quoted null expansion, add a quoted NULL to istring. */
	  if (temp == 0)
	    {
	      c = CTLNUL;
	      sindex--;		/* add_character: label increments sindex */
	      goto add_character;
	    }
	  else
	    goto add_quoted_string;

	  /* break; */

	case ' ':
	  /* If we are in a context where the word is not going to be split, but
	     we need to account for $@ and $* producing one word for each
	     positional parameter, add quoted spaces so the spaces in the
	     expansion of "$@", if any, behave correctly. We still may need to
	     split if we are expanding the rhs of a word expansion. */
	  if (ifs_is_null || split_on_spaces || ((word->flags & (W_NOSPLIT|W_NOSPLIT2|W_ASSIGNRHS)) && (word->flags & W_EXPANDRHS) == 0))
	    {
	      if (string[sindex])
		sindex++;
	      twochars[0] = CTLESC;
	      twochars[1] = c;
	      goto add_twochars;
	    }
	  /* FALLTHROUGH */
	  
	default:
	  /* This is the fix for " $@ " */
add_ifs_character:
	  if ((quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)) || (isexp == 0 && isifs (c) && (word->flags & (W_NOSPLIT|W_NOSPLIT2)) == 0))
	    {
	      if ((quoted&(Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)) == 0)
		has_quoted_ifs++;
add_quoted_character:
	      if (string[sindex])	/* from old goto dollar_add_string */
		sindex++;
	      if (c == 0)
		{
		  c = CTLNUL;
		  goto add_character;
		}
	      else
		{
#if HANDLE_MULTIBYTE
		  /* XXX - should make sure that c is actually multibyte,
		     otherwise we can use the twochars branch */
		  if (mb_cur_max > 1)
		    sindex--;

		  if (mb_cur_max > 1)
		    {
		      SADD_MBQCHAR_BODY(temp, string, sindex, string_size);
		    }
		  else
#endif
		    {
		      twochars[0] = CTLESC;
		      twochars[1] = c;
		      goto add_twochars;
		    }
		}
	    }

	  SADD_MBCHAR (temp, string, sindex, string_size);

add_character:
	  RESIZE_MALLOCED_BUFFER (istring, istring_index, 1, istring_size,
				  DEFAULT_ARRAY_SIZE);
	  istring[istring_index++] = c;
	  istring[istring_index] = '\0';

	  /* Next character. */
	  sindex++;
	}
    }

finished_with_string:
  /* OK, we're ready to return.  If we have a quoted string, and
     quoted_dollar_at is not set, we do no splitting at all; otherwise
     we split on ' '.  The routines that call this will handle what to
     do if nothing has been expanded. */

  /* Partially and wholly quoted strings which expand to the empty
     string are retained as an empty arguments.  Unquoted strings
     which expand to the empty string are discarded.  The single
     exception is the case of expanding "$@" when there are no
     positional parameters.  In that case, we discard the expansion. */

  /* Because of how the code that handles "" and '' in partially
     quoted strings works, we need to make ISTRING into a QUOTED_NULL
     if we saw quoting characters, but the expansion was empty.
     "" and '' are tossed away before we get to this point when
     processing partially quoted strings.  This makes "" and $xxx""
     equivalent when xxx is unset.  We also look to see whether we
     saw a quoted null from a ${} expansion and add one back if we
     need to. */

  /* If we expand to nothing and there were no single or double quotes
     in the word, we throw it away.  Otherwise, we return a NULL word.
     The single exception is for $@ surrounded by double quotes when
     there are no positional parameters.  In that case, we also throw
     the word away. */

  if (*istring == '\0')
    {
      if (quoted_dollar_at == 0 && (had_quoted_null || quoted_state == PARTIALLY_QUOTED))
	{
	  istring[0] = CTLNUL;
	  istring[1] = '\0';
	  tword = alloc_word_desc ();
	  tword->word = istring;
	  istring = 0;		/* avoid later free() */
	  tword->flags |= W_HASQUOTEDNULL;		/* XXX */
	  list = make_word_list (tword, (WORD_LIST *)NULL);
	  if (quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES))
	    tword->flags |= W_QUOTED;
	}
      /* According to sh, ksh, and Posix.2, if a word expands into nothing
	 and a double-quoted "$@" appears anywhere in it, then the entire
	 word is removed. */
      /* XXX - exception appears to be that quoted null strings result in
	 null arguments */
      else  if (quoted_state == UNQUOTED || quoted_dollar_at)
	list = (WORD_LIST *)NULL;
      else
	list = (WORD_LIST *)NULL;
    }
  else if (word->flags & W_NOSPLIT)
    {
      tword = alloc_word_desc ();
      tword->word = istring;
      if (had_quoted_null && QUOTED_NULL (istring))
	tword->flags |= W_HASQUOTEDNULL;
      istring = 0;		/* avoid later free() */
      if (word->flags & W_ASSIGNMENT)
	tword->flags |= W_ASSIGNMENT;	/* XXX */
      if (word->flags & W_COMPASSIGN)
	tword->flags |= W_COMPASSIGN;	/* XXX */
      if (word->flags & W_NOGLOB)
	tword->flags |= W_NOGLOB;	/* XXX */
      if (word->flags & W_NOBRACE)
	tword->flags |= W_NOBRACE;	/* XXX */
      if (quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES))
	tword->flags |= W_QUOTED;
      list = make_word_list (tword, (WORD_LIST *)NULL);
    }
  else if (word->flags & W_ASSIGNRHS)
    {
      list = list_string (istring, "", quoted);
      tword = list->word;
      if (had_quoted_null && QUOTED_NULL (istring))
	tword->flags |= W_HASQUOTEDNULL;
      free (list);
      free (istring);
      istring = 0;			/* avoid later free() */
      goto set_word_flags;
    }
  else
    {
      char *ifs_chars;

      ifs_chars = (quoted_dollar_at || has_dollar_at) ? ifs_value : (char *)NULL;

      /* If we have $@, we need to split the results no matter what.  If
	 IFS is unset or NULL, string_list_dollar_at has separated the
	 positional parameters with a space, so we split on space (we have
	 set ifs_chars to " \t\n" above if ifs is unset).  If IFS is set,
	 string_list_dollar_at has separated the positional parameters
	 with the first character of $IFS, so we split on $IFS.  If
	 SPLIT_ON_SPACES is set, we expanded $* (unquoted) with IFS either
	 unset or null, and we want to make sure that we split on spaces
	 regardless of what else has happened to IFS since the expansion,
	 or we expanded "$@" with IFS null and we need to split the positional
	 parameters into separate words. */
      if (split_on_spaces)
	{
	  /* If IFS is not set, and the word is not quoted, we want to split
	     the individual words on $' \t\n'. We rely on previous steps to
	     quote the portions of the word that should not be split */
	  if (ifs_is_set == 0)
	    list = list_string (istring, " \t\n", 1);	/* XXX quoted == 1? */
	  else
	    list = list_string (istring, " ", 1);	/* XXX quoted == 1? */
	}

      /* If we have $@ (has_dollar_at != 0) and we are in a context where we
	 don't want to split the result (W_NOSPLIT2), and we are not quoted,
	 we have already separated the arguments with the first character of
	 $IFS.  In this case, we want to return a list with a single word
	 with the separator possibly replaced with a space (it's what other
	 shells seem to do).
	 quoted_dollar_at is internal to this function and is set if we are
	 passed an argument that is unquoted (quoted == 0) but we encounter a
	 double-quoted $@ while expanding it. */
      else if (has_dollar_at && quoted_dollar_at == 0 && ifs_chars && quoted == 0 && (word->flags & W_NOSPLIT2))
	{
	  tword = alloc_word_desc ();
	  /* Only split and rejoin if we have to */
	  if (*ifs_chars && *ifs_chars != ' ')
	    {
	      /* list_string dequotes CTLESCs in the string it's passed, so we
		 need it to get the space separation right if space isn't the
		 first character in IFS (but is present) and to remove the 
		 quoting we added back in param_expand(). */
	      list = list_string (istring, *ifs_chars ? ifs_chars : " ", 1);
	      /* This isn't exactly right in the case where we're expanding
		 the RHS of an expansion like ${var-$@} where IFS=: (for
		 example). The W_NOSPLIT2 means we do the separation with :;
		 the list_string removes the quotes and breaks the string into
		 a list, and the string_list rejoins it on spaces. When we
		 return, we expect to be able to split the results, but the
		 space separation means the right split doesn't happen. */
	      tword->word = string_list (list);	
	    }
	  else
	    tword->word = istring;
	  if (had_quoted_null && QUOTED_NULL (istring))
	    tword->flags |= W_HASQUOTEDNULL;	/* XXX */
	  if (tword->word != istring)
	    free (istring);
	  istring = 0;			/* avoid later free() */
	  goto set_word_flags;
	}
      else if (has_dollar_at && ifs_chars)
	list = list_string (istring, *ifs_chars ? ifs_chars : " ", 1);
      else
	{
	  tword = alloc_word_desc ();
	  if (expanded_something && *expanded_something == 0 && has_quoted_ifs)
	    tword->word = remove_quoted_ifs (istring);
	  else
	    tword->word = istring;
	  if (had_quoted_null && QUOTED_NULL (istring))	/* should check for more than one */
	    tword->flags |= W_HASQUOTEDNULL;	/* XXX */
	  else if (had_quoted_null)
	    tword->flags |= W_SAWQUOTEDNULL;	/* XXX */
	  if (tword->word != istring)
	    free (istring);
	  istring = 0;			/* avoid later free() */
set_word_flags:
	  if ((quoted & (Q_DOUBLE_QUOTES|Q_HERE_DOCUMENT)) || (quoted_state == WHOLLY_QUOTED))
	    tword->flags |= W_QUOTED;
	  if (word->flags & W_ASSIGNMENT)
	    tword->flags |= W_ASSIGNMENT;
	  if (word->flags & W_COMPASSIGN)
	    tword->flags |= W_COMPASSIGN;
	  if (word->flags & W_NOGLOB)
	    tword->flags |= W_NOGLOB;
	  if (word->flags & W_NOBRACE)
	    tword->flags |= W_NOBRACE;
	  list = make_word_list (tword, (WORD_LIST *)NULL);
	}
    }

  free (istring);
  return (list);
}
warning: parse error {
  WORD_LIST *list;
  WORD_DESC *tword;

  /* The intermediate string that we build while expanding. */
  char *istring;

  /* The current size of the above object. */
  size_t istring_size;

  /* Index into ISTRING. */
  int istring_index;

  /* Temporary string storage. */
  char *temp, *temp1;

  /* The text of WORD. */
  register char *string;

  /* The size of STRING. */
  size_t string_size;

  /* The index into STRING. */
  int sindex;

  /* This gets 1 if we see a $@ while quoted. */
  int quoted_dollar_at;

  /* One of UNQUOTED, PARTIALLY_QUOTED, or WHOLLY_QUOTED, depending on
     whether WORD contains no quoting characters, a partially quoted
     string (e.g., "xx"ab), or is fully quoted (e.g., "xxab"). */
  int quoted_state;

  /* State flags */
  int had_quoted_null;
  int has_quoted_ifs;		/* did we add a quoted $IFS character here? */
  int has_dollar_at, temp_has_dollar_at;
  int split_on_spaces;
  int local_expanded;
  int tflag;
  int pflags;			/* flags passed to param_expand */
  int mb_cur_max;

  int assignoff;		/* If assignment, offset of `=' */

  register unsigned char c;	/* Current character. */
  int t_index;			/* For calls to string_extract_xxx. */

  char twochars[2];

  DECLARE_MBSTATE;

  /* OK, let's see if we can optimize a common idiom: "$@" */
  if (STREQ (word->word, "\"$@\"") &&
      (word->flags == (W_HASDOLLAR|W_QUOTED)) &&
      dollar_vars[1])		/* XXX - check IFS here as well? */
    {
      if (contains_dollar_at)
	*contains_dollar_at = 1;
      if (expanded_something)
	*expanded_something = 1;
      if (cached_quoted_dollar_at)
	return (copy_word_list (cached_quoted_dollar_at));
      list = list_rest_of_args ();
      list = quote_list (list);
      cached_quoted_dollar_at = copy_word_list (list);
      return (list);
    }

  istring = (char *)xmalloc (istring_size = DEFAULT_INITIAL_ARRAY_SIZE);
  istring[istring_index = 0] = '\0';
  quoted_dollar_at = had_quoted_null = has_dollar_at = 0;
  has_quoted_ifs = 0;
  split_on_spaces = 0;
  quoted_state = UNQUOTED;

  string = word->word;
  if (string == 0)
    goto finished_with_string;
  mb_cur_max = MB_CUR_MAX;

  /* Don't need the string length for the SADD... and COPY_ macros unless
     multibyte characters are possible, but do need it for bounds checking. */
  string_size = (mb_cur_max > 1) ? strlen (string) : 1;

  if (contains_dollar_at)
    *contains_dollar_at = 0;

  assignoff = -1;

  /* Begin the expansion. */

  for (sindex = 0; ;)
    {
      c = string[sindex];

      /* Case on top-level character. */
      switch (c)
	{
	case '\0':
	  goto finished_with_string;

	case CTLESC:
	  sindex++;
#if HANDLE_MULTIBYTE
	  if (mb_cur_max > 1 && string[sindex])
	    {
	      SADD_MBQCHAR_BODY(temp, string, sindex, string_size);
	    }
	  else
#endif
	    {
	      temp = (char *)xmalloc (3);
	      temp[0] = CTLESC;
	      temp[1] = c = string[sindex];
	      temp[2] = '\0';
	    }

dollar_add_string:
	  if (string[sindex])
	    sindex++;

add_string:
	  if (temp)
	    {
	      istring = sub_append_string (temp, istring, &istring_index, &istring_size);
	      temp = (char *)0;
	    }

	  break;

#if defined (PROCESS_SUBSTITUTION)
	  /* Process substitution. */
	case '<':
	case '>':
	  {
	       /* XXX - technically this should only be expanded at the start
	       of a word */
	    if (string[++sindex] != LPAREN || (quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)) || (word->flags & (W_DQUOTE|W_NOPROCSUB)))
	      {
		sindex--;	/* add_character: label increments sindex */
		goto add_character;
	      }
	    else
	      t_index = sindex + 1; /* skip past both '<' and LPAREN */

	    temp1 = extract_process_subst (string, (c == '<') ? "<(" : ">(", &t_index, 0); /*))*/
	    sindex = t_index;

	    /* If the process substitution specification is `<()', we want to
	       open the pipe for writing in the child and produce output; if
	       it is `>()', we want to open the pipe for reading in the child
	       and consume input. */
	    temp = temp1 ? process_substitute (temp1, (c == '>')) : (char *)0;

	    FREE (temp1);

	    goto dollar_add_string;
	  }
#endif /* PROCESS_SUBSTITUTION */

	case '=':
	  /* Posix.2 section 3.6.1 says that tildes following `=' in words
	     which are not assignment statements are not expanded.  If the
	     shell isn't in posix mode, though, we perform tilde expansion
	     on `likely candidate' unquoted assignment statements (flags
	     include W_ASSIGNMENT but not W_QUOTED).  A likely candidate
	     contains an unquoted :~ or =~.  Something to think about: we
	     now have a flag that says  to perform tilde expansion on arguments
	     to `assignment builtins' like declare and export that look like
	     assignment statements.  We now do tilde expansion on such words
	     even in POSIX mode. */	
	  if (word->flags & (W_ASSIGNRHS|W_NOTILDE))
	    {
	      if (isexp == 0 && (word->flags & (W_NOSPLIT|W_NOSPLIT2)) == 0 && isifs (c))
		goto add_ifs_character;
	      else
		goto add_character;
	    }
	  /* If we're not in posix mode or forcing assignment-statement tilde
	     expansion, note where the first `=' appears in the word and prepare
	     to do tilde expansion following the first `='. We have to keep
	     track of the first `=' (using assignoff) to avoid being confused
	     by an `=' in the rhs of the assignment statement. */
	  if ((word->flags & W_ASSIGNMENT) &&
	      (posixly_correct == 0 || (word->flags & W_TILDEEXP)) &&
	      assignoff == -1 && sindex > 0)
	    assignoff = sindex;
	  if (sindex == assignoff && string[sindex+1] == '~')	/* XXX */
	    word->flags |= W_ITILDE;

	  if (word->flags & W_ASSIGNARG)
	    word->flags |= W_ASSIGNRHS;		/* affects $@ */

	  if (isexp == 0 && (word->flags & (W_NOSPLIT|W_NOSPLIT2)) == 0 && isifs (c))
	    {
	      has_quoted_ifs++;
	      goto add_ifs_character;
	    }
	  else
	    goto add_character;

	case ':':
	  if (word->flags & (W_NOTILDE|W_NOASSNTILDE))
	    {
	      if (isexp == 0 && (word->flags & (W_NOSPLIT|W_NOSPLIT2)) == 0 && isifs (c))
		goto add_ifs_character;
	      else
		goto add_character;
	    }

	  if ((word->flags & (W_ASSIGNMENT|W_ASSIGNRHS)) &&
	      (posixly_correct == 0 || (word->flags & W_TILDEEXP)) &&
	      string[sindex+1] == '~')
	    word->flags |= W_ITILDE;

	  if (isexp == 0 && (word->flags & (W_NOSPLIT|W_NOSPLIT2)) == 0 && isifs (c))
	    goto add_ifs_character;
	  else
	    goto add_character;

	case '~':
	  /* If the word isn't supposed to be tilde expanded, or we're not
	     at the start of a word or after an unquoted : or = in an
	     assignment statement, we don't do tilde expansion.  We don't
	     do tilde expansion if quoted or in an arithmetic context. */

	  if ((word->flags & (W_NOTILDE|W_DQUOTE)) ||
	      (sindex > 0 && ((word->flags & W_ITILDE) == 0)) ||
	      (quoted & (Q_DOUBLE_QUOTES|Q_HERE_DOCUMENT)))
	    {
	      word->flags &= ~W_ITILDE;
	      if (isexp == 0 && (word->flags & (W_NOSPLIT|W_NOSPLIT2)) == 0 && isifs (c) && (quoted & (Q_DOUBLE_QUOTES|Q_HERE_DOCUMENT)) == 0)
		goto add_ifs_character;
	      else
		goto add_character;
	    }

	  if (word->flags & W_ASSIGNRHS)
	    tflag = 2;
	  else if (word->flags & (W_ASSIGNMENT|W_TILDEEXP))
	    tflag = 1;
	  else
	    tflag = 0;

	  temp = bash_tilde_find_word (string + sindex, tflag, &t_index);
	    
	  word->flags &= ~W_ITILDE;

	  if (temp && *temp && t_index > 0)
	    {
	      temp1 = bash_tilde_expand (temp, tflag);
	      if  (temp1 && *temp1 == '~' && STREQ (temp, temp1))
		{
		  FREE (temp);
		  FREE (temp1);
		  goto add_character;		/* tilde expansion failed */
		}
	      free (temp);
	      temp = temp1;
	      sindex += t_index;
	      goto add_quoted_string;		/* XXX was add_string */
	    }
	  else
	    {
	      FREE (temp);
	      goto add_character;
	    }
	
	case '$':
	  if (expanded_something)
	    *expanded_something = 1;
	  local_expanded = 1;

	  temp_has_dollar_at = 0;
	  pflags = (word->flags & W_NOCOMSUB) ? PF_NOCOMSUB : 0;
	  if (word->flags & W_NOSPLIT2)
	    pflags |= PF_NOSPLIT2;
	  if (word->flags & W_ASSIGNRHS)
	    pflags |= PF_ASSIGNRHS;
	  if (word->flags & W_COMPLETE)
	    pflags |= PF_COMPLETE;

	  tword = param_expand (string, &sindex, quoted, expanded_something,
			       &temp_has_dollar_at, &quoted_dollar_at,
			       &had_quoted_null, pflags);
	  has_dollar_at += temp_has_dollar_at;
	  split_on_spaces += (tword->flags & W_SPLITSPACE);

	  if (tword == &expand_wdesc_error || tword == &expand_wdesc_fatal)
	    {
	      free (string);
	      free (istring);
	      return ((tword == &expand_wdesc_error) ? &expand_word_error
						     : &expand_word_fatal);
	    }
	  if (contains_dollar_at && has_dollar_at)
	    *contains_dollar_at = 1;

	  if (tword && (tword->flags & W_HASQUOTEDNULL))
	    had_quoted_null = 1;		/* note for later */
	  if (tword && (tword->flags & W_SAWQUOTEDNULL))
	    had_quoted_null = 1;		/* XXX */

	  temp = tword ? tword->word : (char *)NULL;
	  dispose_word_desc (tword);

	  /* Kill quoted nulls; we will add them back at the end of
	     expand_word_internal if nothing else in the string */
	  if (had_quoted_null && temp && QUOTED_NULL (temp))
	    {
	      FREE (temp);
	      temp = (char *)NULL;
	    }

	  goto add_string;
	  break;

	case '`':		/* Backquoted command substitution. */
	  {
	    t_index = sindex++;

	    temp = string_extract (string, &sindex, "`", SX_REQMATCH);
	    /* The test of sindex against t_index is to allow bare instances of
	       ` to pass through, for backwards compatibility. */
	    if (temp == &extract_string_error || temp == &extract_string_fatal)
	      {
		if (sindex - 1 == t_index)
		  {
		    sindex = t_index;
		    goto add_character;
		  }
		set_exit_status (EXECUTION_FAILURE);
		report_error (_("bad substitution: no closing \"`\" in %s") , string+t_index);
		free (string);
		free (istring);
		return ((temp == &extract_string_error) ? &expand_word_error
							: &expand_word_fatal);
	      }
		
	    if (expanded_something)
	      *expanded_something = 1;
	    local_expanded = 1;

	    if (word->flags & W_NOCOMSUB)
	      /* sindex + 1 because string[sindex] == '`' */
	      temp1 = substring (string, t_index, sindex + 1);
	    else
	      {
		de_backslash (temp);
		tword = command_substitute (temp, quoted, 0);
		temp1 = tword ? tword->word : (char *)NULL;
		if (tword)
		  dispose_word_desc (tword);
	      }
	    FREE (temp);
	    temp = temp1;
	    goto dollar_add_string;
	  }

	case '\\':
	  if (string[sindex + 1] == '\n')
	    {
	      sindex += 2;
	      continue;
	    }

	  c = string[++sindex];

	  /* "However, the double-quote character ( '"' ) shall not be treated
	     specially within a here-document, except when the double-quote
	     appears within "$()", "``", or "${}"." */
	  if ((quoted & Q_HERE_DOCUMENT) && (quoted & Q_DOLBRACE) && c == '"')
	    tflag = CBSDQUOTE;		/* special case */
	  else if (quoted & Q_HERE_DOCUMENT)
	    tflag = CBSHDOC;
	  else if (quoted & Q_DOUBLE_QUOTES)
	    tflag = CBSDQUOTE;
	  else
	    tflag = 0;

	  /* From Posix discussion on austin-group list:  Backslash escaping
	     a } in ${...} is removed.  Issue 0000221 */
	  if ((quoted & Q_DOLBRACE) && c == RBRACE)
	    {
	      SCOPY_CHAR_I (twochars, CTLESC, c, string, sindex, string_size);
	    }
	  /* This is the fix for " $@\ " */
	  else if ((quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)) && ((sh_syntaxtab[c] & tflag) == 0) && isexp == 0 && isifs (c))
	    {
	      RESIZE_MALLOCED_BUFFER (istring, istring_index, 2, istring_size,
				      DEFAULT_ARRAY_SIZE);
	      istring[istring_index++] = CTLESC;
	      istring[istring_index++] = '\\';
	      istring[istring_index] = '\0';

	      SCOPY_CHAR_I (twochars, CTLESC, c, string, sindex, string_size);
	    }
	  else if ((quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)) && c == 0)
	    {
	      RESIZE_MALLOCED_BUFFER (istring, istring_index, 2, istring_size,
				      DEFAULT_ARRAY_SIZE);
	      istring[istring_index++] = CTLESC;
	      istring[istring_index++] = '\\';
	      istring[istring_index] = '\0';
	      break;	      
	    }
	  else if ((quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)) && ((sh_syntaxtab[c] & tflag) == 0))
	    {
	      SCOPY_CHAR_I (twochars, '\\', c, string, sindex, string_size);
	    }
	  else if (c == 0)
	    {
	      c = CTLNUL;
	      sindex--;		/* add_character: label increments sindex */
	      goto add_character;
	    }
	  else
	    {
	      SCOPY_CHAR_I (twochars, CTLESC, c, string, sindex, string_size);
	    }

	  sindex++;
add_twochars:
	  /* BEFORE jumping here, we need to increment sindex if appropriate */
	  RESIZE_MALLOCED_BUFFER (istring, istring_index, 2, istring_size,
				  DEFAULT_ARRAY_SIZE);
	  istring[istring_index++] = twochars[0];
	  istring[istring_index++] = twochars[1];
	  istring[istring_index] = '\0';

	  break;

	case '"':
	  if ((quoted & (Q_DOUBLE_QUOTES|Q_HERE_DOCUMENT)) && ((quoted & Q_ARITH) == 0))
	    goto add_character;

	  t_index = ++sindex;
	  temp = string_extract_double_quoted (string, &sindex, (word->flags & W_COMPLETE) ? SX_COMPLETE : 0);

	  /* If the quotes surrounded the entire string, then the
	     whole word was quoted. */
	  quoted_state = (t_index == 1 && string[sindex] == '\0')
			    ? WHOLLY_QUOTED
			    : PARTIALLY_QUOTED;

	  if (temp && *temp)
	    {
	      tword = alloc_word_desc ();
	      tword->word = temp;

	      if (word->flags & W_ASSIGNARG)
		tword->flags |= word->flags & (W_ASSIGNARG|W_ASSIGNRHS); /* affects $@ */
	      if (word->flags & W_COMPLETE)
		tword->flags |= W_COMPLETE;	/* for command substitutions */
	      if (word->flags & W_NOCOMSUB)
		tword->flags |= W_NOCOMSUB;
	      if (word->flags & W_NOPROCSUB)
		tword->flags |= W_NOPROCSUB;

	      if (word->flags & W_ASSIGNRHS)
		tword->flags |= W_ASSIGNRHS;

	      temp = (char *)NULL;

	      temp_has_dollar_at = 0;	/* does this quoted (sub)string include $@? */
	      /* Need to get W_HASQUOTEDNULL flag through this function. */
	      list = expand_word_internal (tword, Q_DOUBLE_QUOTES, 0, &temp_has_dollar_at, (int *)NULL);
	      has_dollar_at += temp_has_dollar_at;

	      if (list == &expand_word_error || list == &expand_word_fatal)
		{
		  free (istring);
		  free (string);
		  /* expand_word_internal has already freed temp_word->word
		     for us because of the way it prints error messages. */
		  tword->word = (char *)NULL;
		  dispose_word (tword);
		  return list;
		}

	      dispose_word (tword);

	      /* "$@" (a double-quoted dollar-at) expands into nothing,
		 not even a NULL word, when there are no positional
		 parameters.  Posix interp 888 says that other parts of the
		 word that expand to quoted nulls result in quoted nulls, so
		 we can't just throw the entire word away if we have "$@"
		 anywhere in it.  We use had_quoted_null to keep track */
	      if (list == 0 && temp_has_dollar_at)	/* XXX - was has_dollar_at */
		{
		  quoted_dollar_at++;
		  break;
		}

	      /* If this list comes back with a quoted null from expansion,
		 we have either "$x" or "$@" with $1 == ''. In either case,
		 we need to make sure we add a quoted null argument and
		 disable the special handling that "$@" gets. */
	      if (list && list->word && list->next == 0 && (list->word->flags & W_HASQUOTEDNULL))
		{
		  if (had_quoted_null && temp_has_dollar_at)
		    quoted_dollar_at++;
		  had_quoted_null = 1;		/* XXX */
		}

	      /* If we get "$@", we know we have expanded something, so we
		 need to remember it for the final split on $IFS.  This is
		 a special case; it's the only case where a quoted string
		 can expand into more than one word.  It's going to come back
		 from the above call to expand_word_internal as a list with
		 multiple words. */
	      if (list)
		dequote_list (list);

	      if (temp_has_dollar_at)		/* XXX - was has_dollar_at */
		{
		  quoted_dollar_at++;
		  if (contains_dollar_at)
		    *contains_dollar_at = 1;
		  if (expanded_something)
		    *expanded_something = 1;
		  local_expanded = 1;
		}
	    }
	  else
	    {
	      /* What we have is "".  This is a minor optimization. */
	      FREE (temp);
	      list = (WORD_LIST *)NULL;
	      had_quoted_null = 1;	/* note for later */
	    }

	  /* The code above *might* return a list (consider the case of "$@",
	     where it returns "$1", "$2", etc.).  We can't throw away the
	     rest of the list, and we have to make sure each word gets added
	     as quoted.  We test on tresult->next:  if it is non-NULL, we
	     quote the whole list, save it to a string with string_list, and
	     add that string. We don't need to quote the results of this
	     (and it would be wrong, since that would quote the separators
	     as well), so we go directly to add_string. */
	  if (list)
	    {
	      if (list->next)
		{
		  /* Testing quoted_dollar_at makes sure that "$@" is
		     split correctly when $IFS does not contain a space. */
		  temp = quoted_dollar_at
				? string_list_dollar_at (list, Q_DOUBLE_QUOTES, 0)
				: string_list (quote_list (list));
		  dispose_words (list);
		  goto add_string;
		}
	      else
		{
		  temp = savestring (list->word->word);
		  tflag = list->word->flags;
		  dispose_words (list);

		  /* If the string is not a quoted null string, we want
		     to remove any embedded unquoted CTLNUL characters.
		     We do not want to turn quoted null strings back into
		     the empty string, though.  We do this because we
		     want to remove any quoted nulls from expansions that
		     contain other characters.  For example, if we have
		     x"$*"y or "x$*y" and there are no positional parameters,
		     the $* should expand into nothing. */
		  /* We use the W_HASQUOTEDNULL flag to differentiate the
		     cases:  a quoted null character as above and when
		     CTLNUL is contained in the (non-null) expansion
		     of some variable.  We use the had_quoted_null flag to
		     pass the value through this function to its caller. */
		  if ((tflag & W_HASQUOTEDNULL) && QUOTED_NULL (temp) == 0)
		    remove_quoted_nulls (temp);	/* XXX */
		}
	    }
	  else
	    temp = (char *)NULL;

	  if (temp == 0 && quoted_state == PARTIALLY_QUOTED)
	    had_quoted_null = 1;	/* note for later */

	  /* We do not want to add quoted nulls to strings that are only
	     partially quoted; we can throw them away.  The exception to
	     this is when we are going to be performing word splitting,
	     since we have to preserve a null argument if the next character
	     will cause word splitting. */
	  if (temp == 0 && quoted_state == PARTIALLY_QUOTED && quoted == 0 && (word->flags & (W_NOSPLIT|W_EXPANDRHS|W_ASSIGNRHS)) == W_EXPANDRHS)
	    {
	      c = CTLNUL;
	      sindex--;
	      had_quoted_null = 1;
	      goto add_character;
	    }
	  if (temp == 0 && quoted_state == PARTIALLY_QUOTED && (word->flags & (W_NOSPLIT|W_NOSPLIT2)))
	    continue;

	add_quoted_string:

	  if (temp)
	    {
	      temp1 = temp;
	      temp = quote_string (temp);
	      free (temp1);
	      goto add_string;
	    }
	  else
	    {
	      /* Add NULL arg. */
	      c = CTLNUL;
	      sindex--;		/* add_character: label increments sindex */
	      had_quoted_null = 1;	/* note for later */
	      goto add_character;
	    }

	  /* break; */

	case '\'':
	  if ((quoted & (Q_DOUBLE_QUOTES|Q_HERE_DOCUMENT)))
	    goto add_character;

	  t_index = ++sindex;
	  temp = string_extract_single_quoted (string, &sindex);

	  /* If the entire STRING was surrounded by single quotes,
	     then the string is wholly quoted. */
	  quoted_state = (t_index == 1 && string[sindex] == '\0')
			    ? WHOLLY_QUOTED
			    : PARTIALLY_QUOTED;

	  /* If all we had was '', it is a null expansion. */
	  if (*temp == '\0')
	    {
	      free (temp);
	      temp = (char *)NULL;
	    }
	  else
	    remove_quoted_escapes (temp);	/* ??? */

	  if (temp == 0 && quoted_state == PARTIALLY_QUOTED)
	    had_quoted_null = 1;	/* note for later */

	  /* We do not want to add quoted nulls to strings that are only
	     partially quoted; such nulls are discarded.  See above for the
	     exception, which is when the string is going to be split.
	     Posix interp 888/1129 */
	  if (temp == 0 && quoted_state == PARTIALLY_QUOTED && quoted == 0 && (word->flags & (W_NOSPLIT|W_EXPANDRHS|W_ASSIGNRHS)) == W_EXPANDRHS)
	    {
	      c = CTLNUL;
	      sindex--;
	      goto add_character;
	    }

	  if (temp == 0 && (quoted_state == PARTIALLY_QUOTED) && (word->flags & (W_NOSPLIT|W_NOSPLIT2)))
	    continue;

	  /* If we have a quoted null expansion, add a quoted NULL to istring. */
	  if (temp == 0)
	    {
	      c = CTLNUL;
	      sindex--;		/* add_character: label increments sindex */
	      goto add_character;
	    }
	  else
	    goto add_quoted_string;

	  /* break; */

	case ' ':
	  /* If we are in a context where the word is not going to be split, but
	     we need to account for $@ and $* producing one word for each
	     positional parameter, add quoted spaces so the spaces in the
	     expansion of "$@", if any, behave correctly. We still may need to
	     split if we are expanding the rhs of a word expansion. */
	  if (ifs_is_null || split_on_spaces || ((word->flags & (W_NOSPLIT|W_NOSPLIT2|W_ASSIGNRHS)) && (word->flags & W_EXPANDRHS) == 0))
	    {
	      if (string[sindex])
		sindex++;
	      twochars[0] = CTLESC;
	      twochars[1] = c;
	      goto add_twochars;
	    }
	  /* FALLTHROUGH */
	  
	default:
	  /* This is the fix for " $@ " */
add_ifs_character:
	  if ((quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)) || (isexp == 0 && isifs (c) && (word->flags & (W_NOSPLIT|W_NOSPLIT2)) == 0))
	    {
	      if ((quoted&(Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)) == 0)
		has_quoted_ifs++;
add_quoted_character:
	      if (string[sindex])	/* from old goto dollar_add_string */
		sindex++;
	      if (c == 0)
		{
		  c = CTLNUL;
		  goto add_character;
		}
	      else
		{
#if HANDLE_MULTIBYTE
		  /* XXX - should make sure that c is actually multibyte,
		     otherwise we can use the twochars branch */
		  if (mb_cur_max > 1)
		    sindex--;

		  if (mb_cur_max > 1)
		    {
		      SADD_MBQCHAR_BODY(temp, string, sindex, string_size);
		    }
		  else
#endif
		    {
		      twochars[0] = CTLESC;
		      twochars[1] = c;
		      goto add_twochars;
		    }
		}
	    }

	  SADD_MBCHAR (temp, string, sindex, string_size);

add_character:
	  RESIZE_MALLOCED_BUFFER (istring, istring_index, 1, istring_size,
				  DEFAULT_ARRAY_SIZE);
	  istring[istring_index++] = c;
	  istring[istring_index] = '\0';

	  /* Next character. */
	  sindex++;
	}
    }

finished_with_string:
  /* OK, we're ready to return.  If we have a quoted string, and
     quoted_dollar_at is not set, we do no splitting at all; otherwise
     we split on ' '.  The routines that call this will handle what to
     do if nothing has been expanded. */

  /* Partially and wholly quoted strings which expand to the empty
     string are retained as an empty arguments.  Unquoted strings
     which expand to the empty string are discarded.  The single
     exception is the case of expanding "$@" when there are no
     positional parameters.  In that case, we discard the expansion. */

  /* Because of how the code that handles "" and '' in partially
     quoted strings works, we need to make ISTRING into a QUOTED_NULL
     if we saw quoting characters, but the expansion was empty.
     "" and '' are tossed away before we get to this point when
     processing partially quoted strings.  This makes "" and $xxx""
     equivalent when xxx is unset.  We also look to see whether we
     saw a quoted null from a ${} expansion and add one back if we
     need to. */

  /* If we expand to nothing and there were no single or double quotes
     in the word, we throw it away.  Otherwise, we return a NULL word.
     The single exception is for $@ surrounded by double quotes when
     there are no positional parameters.  In that case, we also throw
     the word away. */

  if (*istring == '\0')
    {
      if (quoted_dollar_at == 0 && (had_quoted_null || quoted_state == PARTIALLY_QUOTED))
	{
	  istring[0] = CTLNUL;
	  istring[1] = '\0';
	  tword = alloc_word_desc ();
	  tword->word = istring;
	  istring = 0;		/* avoid later free() */
	  tword->flags |= W_HASQUOTEDNULL;		/* XXX */
	  list = make_word_list (tword, (WORD_LIST *)NULL);
	  if (quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES))
	    tword->flags |= W_QUOTED;
	}
      /* According to sh, ksh, and Posix.2, if a word expands into nothing
	 and a double-quoted "$@" appears anywhere in it, then the entire
	 word is removed. */
      /* XXX - exception appears to be that quoted null strings result in
	 null arguments */
      else  if (quoted_state == UNQUOTED || quoted_dollar_at)
	list = (WORD_LIST *)NULL;
      else
	list = (WORD_LIST *)NULL;
    }
  else if (word->flags & W_NOSPLIT)
    {
      tword = alloc_word_desc ();
      tword->word = istring;
      if (had_quoted_null && QUOTED_NULL (istring))
	tword->flags |= W_HASQUOTEDNULL;
      istring = 0;		/* avoid later free() */
      if (word->flags & W_ASSIGNMENT)
	tword->flags |= W_ASSIGNMENT;	/* XXX */
      if (word->flags & W_COMPASSIGN)
	tword->flags |= W_COMPASSIGN;	/* XXX */
      if (word->flags & W_NOGLOB)
	tword->flags |= W_NOGLOB;	/* XXX */
      if (word->flags & W_NOBRACE)
	tword->flags |= W_NOBRACE;	/* XXX */
      if (quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES))
	tword->flags |= W_QUOTED;
      list = make_word_list (tword, (WORD_LIST *)NULL);
    }
  else if (word->flags & W_ASSIGNRHS)
    {
      list = list_string (istring, "", quoted);
      tword = list->word;
      if (had_quoted_null && QUOTED_NULL (istring))
	tword->flags |= W_HASQUOTEDNULL;
      free (list);
      free (istring);
      istring = 0;			/* avoid later free() */
      goto set_word_flags;
    }
  else
    {
      char *ifs_chars;

      ifs_chars = (quoted_dollar_at || has_dollar_at) ? ifs_value : (char *)NULL;

      /* If we have $@, we need to split the results no matter what.  If
	 IFS is unset or NULL, string_list_dollar_at has separated the
	 positional parameters with a space, so we split on space (we have
	 set ifs_chars to " \t\n" above if ifs is unset).  If IFS is set,
	 string_list_dollar_at has separated the positional parameters
	 with the first character of $IFS, so we split on $IFS.  If
	 SPLIT_ON_SPACES is set, we expanded $* (unquoted) with IFS either
	 unset or null, and we want to make sure that we split on spaces
	 regardless of what else has happened to IFS since the expansion,
	 or we expanded "$@" with IFS null and we need to split the positional
	 parameters into separate words. */
      if (split_on_spaces)
	{
	  /* If IFS is not set, and the word is not quoted, we want to split
	     the individual words on $' \t\n'. We rely on previous steps to
	     quote the portions of the word that should not be split */
	  if (ifs_is_set == 0)
	    list = list_string (istring, " \t\n", 1);	/* XXX quoted == 1? */
	  else
	    list = list_string (istring, " ", 1);	/* XXX quoted == 1? */
	}

      /* If we have $@ (has_dollar_at != 0) and we are in a context where we
	 don't want to split the result (W_NOSPLIT2), and we are not quoted,
	 we have already separated the arguments with the first character of
	 $IFS.  In this case, we want to return a list with a single word
	 with the separator possibly replaced with a space (it's what other
	 shells seem to do).
	 quoted_dollar_at is internal to this function and is set if we are
	 passed an argument that is unquoted (quoted == 0) but we encounter a
	 double-quoted $@ while expanding it. */
      else if (has_dollar_at && quoted_dollar_at == 0 && ifs_chars && quoted == 0 && (word->flags & W_NOSPLIT2))
	{
	  tword = alloc_word_desc ();
	  /* Only split and rejoin if we have to */
	  if (*ifs_chars && *ifs_chars != ' ')
	    {
	      /* list_string dequotes CTLESCs in the string it's passed, so we
		 need it to get the space separation right if space isn't the
		 first character in IFS (but is present) and to remove the 
		 quoting we added back in param_expand(). */
	      list = list_string (istring, *ifs_chars ? ifs_chars : " ", 1);
	      /* This isn't exactly right in the case where we're expanding
		 the RHS of an expansion like ${var-$@} where IFS=: (for
		 example). The W_NOSPLIT2 means we do the separation with :;
		 the list_string removes the quotes and breaks the string into
		 a list, and the string_list rejoins it on spaces. When we
		 return, we expect to be able to split the results, but the
		 space separation means the right split doesn't happen. */
	      tword->word = string_list (list);	
	    }
	  else
	    tword->word = istring;
	  if (had_quoted_null && QUOTED_NULL (istring))
	    tword->flags |= W_HASQUOTEDNULL;	/* XXX */
	  if (tword->word != istring)
	    free (istring);
	  istring = 0;			/* avoid later free() */
	  goto set_word_flags;
	}
      else if (has_dollar_at && ifs_chars)
	list = list_string (istring, *ifs_chars ? ifs_chars : " ", 1);
      else
	{
	  tword = alloc_word_desc ();
	  if (expanded_something && *expanded_something == 0 && has_quoted_ifs)
	    tword->word = remove_quoted_ifs (istring);
	  else
	    tword->word = istring;
	  if (had_quoted_null && QUOTED_NULL (istring))	/* should check for more than one */
	    tword->flags |= W_HASQUOTEDNULL;	/* XXX */
	  else if (had_quoted_null)
	    tword->flags |= W_SAWQUOTEDNULL;	/* XXX */
	  if (tword->word != istring)
	    free (istring);
	  istring = 0;			/* avoid later free() */
set_word_flags:
	  if ((quoted & (Q_DOUBLE_QUOTES|Q_HERE_DOCUMENT)) || (quoted_state == WHOLLY_QUOTED))
	    tword->flags |= W_QUOTED;
	  if (word->flags & W_ASSIGNMENT)
	    tword->flags |= W_ASSIGNMENT;
	  if (word->flags & W_COMPASSIGN)
	    tword->flags |= W_COMPASSIGN;
	  if (word->flags & W_NOGLOB)
	    tword->flags |= W_NOGLOB;
	  if (word->flags & W_NOBRACE)
	    tword->flags |= W_NOBRACE;
	  list = make_word_list (tword, (WORD_LIST *)NULL);
	}
    }

  free (istring);
  return (list);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:10,034
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:10,959
parsing error 
{
  size_t slen;
  char *r, *result_string, *temp, *send;
  int sindex, tindex, dquote;
  unsigned char c;
  DECLARE_MBSTATE;

  /* The result can be no longer than the original string. */
  slen = strlen (string);
  send = string + slen;

  r = result_string = (char *)xmalloc (slen + 1);

  for (dquote = sindex = 0; c = string[sindex];)
    {
      switch (c)
	{
	case '\\':
	  c = string[++sindex];
	  if (c == 0)
	    {
	      *r++ = '\\';
	      break;
	    }
	  if (((quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)) || dquote) && (sh_syntaxtab[c] & CBSDQUOTE) == 0)
	    *r++ = '\\';
	  /* FALLTHROUGH */

	default:
	  SCOPY_CHAR_M (r, string, send, sindex);
	  break;

	case '\'':
	  if ((quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)) || dquote)
	    {
	      *r++ = c;
	      sindex++;
	      break;
	    }
	  tindex = sindex + 1;
	  temp = string_extract_single_quoted (string, &tindex);
	  if (temp)
	    {
	      strcpy (r, temp);
	      r += strlen (r);
	      free (temp);
	    }
	  sindex = tindex;
	  break;

	case '"':
	  dquote = 1 - dquote;
	  sindex++;
	  break;
	}
    }
    *r = '\0';
    return (result_string);
}
warning: parse error {
  size_t slen;
  char *r, *result_string, *temp, *send;
  int sindex, tindex, dquote;
  unsigned char c;
  DECLARE_MBSTATE;

  /* The result can be no longer than the original string. */
  slen = strlen (string);
  send = string + slen;

  r = result_string = (char *)xmalloc (slen + 1);

  for (dquote = sindex = 0; c = string[sindex];)
    {
      switch (c)
	{
	case '\\':
	  c = string[++sindex];
	  if (c == 0)
	    {
	      *r++ = '\\';
	      break;
	    }
	  if (((quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)) || dquote) && (sh_syntaxtab[c] & CBSDQUOTE) == 0)
	    *r++ = '\\';
	  /* FALLTHROUGH */

	default:
	  SCOPY_CHAR_M (r, string, send, sindex);
	  break;

	case '\'':
	  if ((quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)) || dquote)
	    {
	      *r++ = c;
	      sindex++;
	      break;
	    }
	  tindex = sindex + 1;
	  temp = string_extract_single_quoted (string, &tindex);
	  if (temp)
	    {
	      strcpy (r, temp);
	      r += strlen (r);
	      free (temp);
	    }
	  sindex = tindex;
	  break;

	case '"':
	  dquote = 1 - dquote;
	  sindex++;
	  break;
	}
    }
    *r = '\0';
    return (result_string);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:10,962
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:11,077
parsing error 
{
  char *t;
  unsigned char uc;

  ifs_var = v;
  ifs_value = (v && value_cell (v)) ? value_cell (v) : " \t\n";

  ifs_is_set = ifs_var != 0;
  ifs_is_null = ifs_is_set && (*ifs_value == 0);

  /* Should really merge ifs_cmap with sh_syntaxtab.  XXX - doesn't yet
     handle multibyte chars in IFS */
  memset (ifs_cmap, '\0', sizeof (ifs_cmap));
  for (t = ifs_value ; t && *t; t++)
    {
      uc = *t;
      ifs_cmap[uc] = 1;
    }

#if defined (HANDLE_MULTIBYTE)
  if (ifs_value == 0)
    {
      ifs_firstc[0] = '\0';	/* XXX - ? */
      ifs_firstc_len = 1;
    }
  else
    {
      if (locale_utf8locale && UTF8_SINGLEBYTE (*ifs_value))
	ifs_firstc_len = (*ifs_value != 0) ? 1 : 0;
      else
	{
	  size_t ifs_len;
	  ifs_len = strnlen (ifs_value, MB_CUR_MAX);
	  ifs_firstc_len = MBLEN (ifs_value, ifs_len);
	}
      if (ifs_firstc_len == 1 || ifs_firstc_len == 0 || MB_INVALIDCH (ifs_firstc_len))
	{
	  ifs_firstc[0] = ifs_value[0];
	  ifs_firstc[1] = '\0';
	  ifs_firstc_len = 1;
	}
      else
	memcpy (ifs_firstc, ifs_value, ifs_firstc_len);
    }
#else
  ifs_firstc = ifs_value ? *ifs_value : 0;
#endif
}
warning: parse error {
  char *t;
  unsigned char uc;

  ifs_var = v;
  ifs_value = (v && value_cell (v)) ? value_cell (v) : " \t\n";

  ifs_is_set = ifs_var != 0;
  ifs_is_null = ifs_is_set && (*ifs_value == 0);

  /* Should really merge ifs_cmap with sh_syntaxtab.  XXX - doesn't yet
     handle multibyte chars in IFS */
  memset (ifs_cmap, '\0', sizeof (ifs_cmap));
  for (t = ifs_value ; t && *t; t++)
    {
      uc = *t;
      ifs_cmap[uc] = 1;
    }

#if defined (HANDLE_MULTIBYTE)
  if (ifs_value == 0)
    {
      ifs_firstc[0] = '\0';	/* XXX - ? */
      ifs_firstc_len = 1;
    }
  else
    {
      if (locale_utf8locale && UTF8_SINGLEBYTE (*ifs_value))
	ifs_firstc_len = (*ifs_value != 0) ? 1 : 0;
      else
	{
	  size_t ifs_len;
	  ifs_len = strnlen (ifs_value, MB_CUR_MAX);
	  ifs_firstc_len = MBLEN (ifs_value, ifs_len);
	}
      if (ifs_firstc_len == 1 || ifs_firstc_len == 0 || MB_INVALIDCH (ifs_firstc_len))
	{
	  ifs_firstc[0] = ifs_value[0];
	  ifs_firstc[1] = '\0';
	  ifs_firstc_len = 1;
	}
      else
	memcpy (ifs_firstc, ifs_value, ifs_firstc_len);
    }
#else
  ifs_firstc = ifs_value ? *ifs_value : 0;
#endif
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:11,079
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:11,138
parsing error 
{
  WORD_LIST *result;

  if (w)
    {
      char *xifs;

      xifs = ((w->flags & W_QUOTED) || ifs_chars == 0) ? "" : ifs_chars;
      result = list_string (w->word, xifs, w->flags & W_QUOTED);
    }
  else
    result = (WORD_LIST *)NULL;

  return (result);
}
warning: parse error {
  WORD_LIST *result;

  if (w)
    {
      char *xifs;

      xifs = ((w->flags & W_QUOTED) || ifs_chars == 0) ? "" : ifs_chars;
      result = list_string (w->word, xifs, w->flags & W_QUOTED);
    }
  else
    result = (WORD_LIST *)NULL;

  return (result);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:11,141
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:11,160
parsing error 
{
  WORD_LIST *result, *t, *tresult, *e;
  WORD_DESC *w;

  for (t = list, result = (WORD_LIST *)NULL; t; t = t->next)
    {
      tresult = word_split (t->word, ifs_value);
      /* POSIX 2.6: "If the complete expansion appropriate for a word results
	 in an empty field, that empty field shall be deleted from the list
	 of fields that form the completely expanded command, unless the
	 original word contained single-quote or double-quote characters."
	 This is where we handle these words that contain quoted null strings
	 and other characters that expand to nothing after word splitting. */
      if (tresult == 0 && t->word && (t->word->flags & W_SAWQUOTEDNULL))	/* XXX */
	{
	  w = alloc_word_desc ();
	  w->word = (char *)xmalloc (1);
	  w->word[0] = '\0';
	  tresult = make_word_list (w, (WORD_LIST *)NULL);
	}
      if (result == 0)
        result = e = tresult;
      else
	{
	  e->next = tresult;
	  while (e->next)
	    e = e->next;
	}
    }
  return (result);
}
warning: parse error {
  WORD_LIST *result, *t, *tresult, *e;
  WORD_DESC *w;

  for (t = list, result = (WORD_LIST *)NULL; t; t = t->next)
    {
      tresult = word_split (t->word, ifs_value);
      /* POSIX 2.6: "If the complete expansion appropriate for a word results
	 in an empty field, that empty field shall be deleted from the list
	 of fields that form the completely expanded command, unless the
	 original word contained single-quote or double-quote characters."
	 This is where we handle these words that contain quoted null strings
	 and other characters that expand to nothing after word splitting. */
      if (tresult == 0 && t->word && (t->word->flags & W_SAWQUOTEDNULL))	/* XXX */
	{
	  w = alloc_word_desc ();
	  w->word = (char *)xmalloc (1);
	  w->word[0] = '\0';
	  tresult = make_word_list (w, (WORD_LIST *)NULL);
	}
      if (result == 0)
        result = e = tresult;
      else
	{
	  e->next = tresult;
	  while (e->next)
	    e = e->next;
	}
    }
  return (result);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:11,162
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:11,202
parsing error 
{
  set_pipestatus_from_exit (last_command_exit_value);

  /* Cleanup code goes here. */
  expand_no_split_dollar_star = 0;	/* XXX */
  if (expanding_redir)
    undo_partial_redirects ();
  expanding_redir = 0;
  assigning_in_environment = 0;

  if (parse_and_execute_level == 0)
    top_level_cleanup ();			/* from sig.c */

  jump_to_top_level (v);
}
warning: parse error {
  set_pipestatus_from_exit (last_command_exit_value);

  /* Cleanup code goes here. */
  expand_no_split_dollar_star = 0;	/* XXX */
  if (expanding_redir)
    undo_partial_redirects ();
  expanding_redir = 0;
  assigning_in_environment = 0;

  if (parse_and_execute_level == 0)
    top_level_cleanup ();			/* from sig.c */

  jump_to_top_level (v);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:11,204
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:11,230
parsing error 
{
  register WORD_LIST *vp, *lp;

  if (tlist == 0)
    return ((WORD_LIST *)NULL);

  if (subst_assign_varlist)
    dispose_words (subst_assign_varlist);	/* Clean up after previous error */

  subst_assign_varlist = (WORD_LIST *)NULL;
  vp = lp = tlist;

  /* Separate out variable assignments at the start of the command.
     Loop invariant: vp->next == lp
     Loop postcondition:
	lp = list of words left after assignment statements skipped
	tlist = original list of words
  */
  while (lp && (lp->word->flags & W_ASSIGNMENT))
    {
      vp = lp;
      lp = lp->next;
    }

  /* If lp != tlist, we have some initial assignment statements.
     We make SUBST_ASSIGN_VARLIST point to the list of assignment
     words and TLIST point to the remaining words.  */
  if (lp != tlist)
    {
      subst_assign_varlist = tlist;
      /* ASSERT(vp->next == lp); */
      vp->next = (WORD_LIST *)NULL;	/* terminate variable list */
      tlist = lp;			/* remainder of word list */
    }

  /* vp == end of variable list */
  /* tlist == remainder of original word list without variable assignments */
  if (!tlist)
    /* All the words in tlist were assignment statements */
    return ((WORD_LIST *)NULL);

  /* ASSERT(tlist != NULL); */
  /* ASSERT((tlist->word->flags & W_ASSIGNMENT) == 0); */

  /* If the -k option is in effect, we need to go through the remaining
     words, separate out the assignment words, and place them on
     SUBST_ASSIGN_VARLIST. */
  if (place_keywords_in_env)
    {
      WORD_LIST *tp;	/* tp == running pointer into tlist */

      tp = tlist;
      lp = tlist->next;

      /* Loop Invariant: tp->next == lp */
      /* Loop postcondition: tlist == word list without assignment statements */
      while (lp)
	{
	  if (lp->word->flags & W_ASSIGNMENT)
	    {
	      /* Found an assignment statement, add this word to end of
		 subst_assign_varlist (vp). */
	      if (!subst_assign_varlist)
		subst_assign_varlist = vp = lp;
	      else
		{
		  vp->next = lp;
		  vp = lp;
		}

	      /* Remove the word pointed to by LP from TLIST. */
	      tp->next = lp->next;
	      /* ASSERT(vp == lp); */
	      lp->next = (WORD_LIST *)NULL;
	      lp = tp->next;
	    }
	  else
	    {
	      tp = lp;
	      lp = lp->next;
	    }
	}
    }
  return (tlist);
}
warning: parse error {
  register WORD_LIST *vp, *lp;

  if (tlist == 0)
    return ((WORD_LIST *)NULL);

  if (subst_assign_varlist)
    dispose_words (subst_assign_varlist);	/* Clean up after previous error */

  subst_assign_varlist = (WORD_LIST *)NULL;
  vp = lp = tlist;

  /* Separate out variable assignments at the start of the command.
     Loop invariant: vp->next == lp
     Loop postcondition:
	lp = list of words left after assignment statements skipped
	tlist = original list of words
  */
  while (lp && (lp->word->flags & W_ASSIGNMENT))
    {
      vp = lp;
      lp = lp->next;
    }

  /* If lp != tlist, we have some initial assignment statements.
     We make SUBST_ASSIGN_VARLIST point to the list of assignment
     words and TLIST point to the remaining words.  */
  if (lp != tlist)
    {
      subst_assign_varlist = tlist;
      /* ASSERT(vp->next == lp); */
      vp->next = (WORD_LIST *)NULL;	/* terminate variable list */
      tlist = lp;			/* remainder of word list */
    }

  /* vp == end of variable list */
  /* tlist == remainder of original word list without variable assignments */
  if (!tlist)
    /* All the words in tlist were assignment statements */
    return ((WORD_LIST *)NULL);

  /* ASSERT(tlist != NULL); */
  /* ASSERT((tlist->word->flags & W_ASSIGNMENT) == 0); */

  /* If the -k option is in effect, we need to go through the remaining
     words, separate out the assignment words, and place them on
     SUBST_ASSIGN_VARLIST. */
  if (place_keywords_in_env)
    {
      WORD_LIST *tp;	/* tp == running pointer into tlist */

      tp = tlist;
      lp = tlist->next;

      /* Loop Invariant: tp->next == lp */
      /* Loop postcondition: tlist == word list without assignment statements */
      while (lp)
	{
	  if (lp->word->flags & W_ASSIGNMENT)
	    {
	      /* Found an assignment statement, add this word to end of
		 subst_assign_varlist (vp). */
	      if (!subst_assign_varlist)
		subst_assign_varlist = vp = lp;
	      else
		{
		  vp->next = lp;
		  vp = lp;
		}

	      /* Remove the word pointed to by LP from TLIST. */
	      tp->next = lp->next;
	      /* ASSERT(vp == lp); */
	      lp->next = (WORD_LIST *)NULL;
	      lp = tp->next;
	    }
	  else
	    {
	      tp = lp;
	      lp = lp->next;
	    }
	}
    }
  return (tlist);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:11,232
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:11,342
parsing error 
{
  return (expand_word_list_internal (list, WEXP_ALL));
}
warning: parse error {
  return (expand_word_list_internal (list, WEXP_ALL));
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:11,344
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:11,351
parsing error 
{
  return (expand_word_list_internal (list, WEXP_NOVARS));
}
warning: parse error {
  return (expand_word_list_internal (list, WEXP_NOVARS));
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:11,353
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:11,358
parsing error 
{
  return (expand_word_list_internal (list, WEXP_SHELLEXP));
}
warning: parse error {
  return (expand_word_list_internal (list, WEXP_SHELLEXP));
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:11,360
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:11,365
parsing error 
{
  char **glob_array, *temp_string;
  register int glob_index;
  WORD_LIST *glob_list, *output_list, *disposables, *next;
  WORD_DESC *tword;
  int x;

  output_list = disposables = (WORD_LIST *)NULL;
  glob_array = (char **)NULL;
  while (tlist)
    {
      /* For each word, either globbing is attempted or the word is
	 added to orig_list.  If globbing succeeds, the results are
	 added to orig_list and the word (tlist) is added to the list
	 of disposable words.  If globbing fails and failed glob
	 expansions are left unchanged (the shell default), the
	 original word is added to orig_list.  If globbing fails and
	 failed glob expansions are removed, the original word is
	 added to the list of disposable words.  orig_list ends up
	 in reverse order and requires a call to REVERSE_LIST to
	 be set right.  After all words are examined, the disposable
	 words are freed. */
      next = tlist->next;

      /* If the word isn't an assignment and contains an unquoted
	 pattern matching character, then glob it. */
      if ((tlist->word->flags & W_NOGLOB) == 0 &&
	  unquoted_glob_pattern_p (tlist->word->word))
	{
	  glob_array = shell_glob_filename (tlist->word->word, QGLOB_CTLESC);	/* XXX */

	  /* Handle error cases.
	     I don't think we should report errors like "No such file
	     or directory".  However, I would like to report errors
	     like "Read failed". */

	  if (glob_array == 0 || GLOB_FAILED (glob_array))
	    {
	      glob_array = (char **)xmalloc (sizeof (char *));
	      glob_array[0] = (char *)NULL;
	    }

	  /* Dequote the current word in case we have to use it. */
	  if (glob_array[0] == NULL)
	    {
	      temp_string = dequote_string (tlist->word->word);
	      free (tlist->word->word);
	      tlist->word->word = temp_string;
	    }

	  /* Make the array into a word list. */
	  glob_list = (WORD_LIST *)NULL;
	  for (glob_index = 0; glob_array[glob_index]; glob_index++)
	    {
	      tword = make_bare_word (glob_array[glob_index]);
	      glob_list = make_word_list (tword, glob_list);
	    }

	  if (glob_list)
	    {
	      output_list = (WORD_LIST *)list_append (glob_list, output_list);
	      PREPEND_LIST (tlist, disposables);
	    }
	  else if (fail_glob_expansion != 0)
	    {
	      last_command_exit_value = EXECUTION_FAILURE;
	      report_error (_("no match: %s"), tlist->word->word);
	      exp_jump_to_top_level (DISCARD);
	    }
	  else if (allow_null_glob_expansion == 0)
	    {
	      /* Failed glob expressions are left unchanged. */
	      PREPEND_LIST (tlist, output_list);
	    }
	  else
	    {
	      /* Failed glob expressions are removed. */
	      PREPEND_LIST (tlist, disposables);
	    }
	}
      else
	{
	  /* Dequote the string. */
	  temp_string = dequote_string (tlist->word->word);
	  free (tlist->word->word);
	  tlist->word->word = temp_string;
	  PREPEND_LIST (tlist, output_list);
	}

      strvec_dispose (glob_array);
      glob_array = (char **)NULL;

      tlist = next;
    }

  if (disposables)
    dispose_words (disposables);

  if (output_list)
    output_list = REVERSE_LIST (output_list, WORD_LIST *);

  return (output_list);
}
warning: parse error {
  char **glob_array, *temp_string;
  register int glob_index;
  WORD_LIST *glob_list, *output_list, *disposables, *next;
  WORD_DESC *tword;
  int x;

  output_list = disposables = (WORD_LIST *)NULL;
  glob_array = (char **)NULL;
  while (tlist)
    {
      /* For each word, either globbing is attempted or the word is
	 added to orig_list.  If globbing succeeds, the results are
	 added to orig_list and the word (tlist) is added to the list
	 of disposable words.  If globbing fails and failed glob
	 expansions are left unchanged (the shell default), the
	 original word is added to orig_list.  If globbing fails and
	 failed glob expansions are removed, the original word is
	 added to the list of disposable words.  orig_list ends up
	 in reverse order and requires a call to REVERSE_LIST to
	 be set right.  After all words are examined, the disposable
	 words are freed. */
      next = tlist->next;

      /* If the word isn't an assignment and contains an unquoted
	 pattern matching character, then glob it. */
      if ((tlist->word->flags & W_NOGLOB) == 0 &&
	  unquoted_glob_pattern_p (tlist->word->word))
	{
	  glob_array = shell_glob_filename (tlist->word->word, QGLOB_CTLESC);	/* XXX */

	  /* Handle error cases.
	     I don't think we should report errors like "No such file
	     or directory".  However, I would like to report errors
	     like "Read failed". */

	  if (glob_array == 0 || GLOB_FAILED (glob_array))
	    {
	      glob_array = (char **)xmalloc (sizeof (char *));
	      glob_array[0] = (char *)NULL;
	    }

	  /* Dequote the current word in case we have to use it. */
	  if (glob_array[0] == NULL)
	    {
	      temp_string = dequote_string (tlist->word->word);
	      free (tlist->word->word);
	      tlist->word->word = temp_string;
	    }

	  /* Make the array into a word list. */
	  glob_list = (WORD_LIST *)NULL;
	  for (glob_index = 0; glob_array[glob_index]; glob_index++)
	    {
	      tword = make_bare_word (glob_array[glob_index]);
	      glob_list = make_word_list (tword, glob_list);
	    }

	  if (glob_list)
	    {
	      output_list = (WORD_LIST *)list_append (glob_list, output_list);
	      PREPEND_LIST (tlist, disposables);
	    }
	  else if (fail_glob_expansion != 0)
	    {
	      last_command_exit_value = EXECUTION_FAILURE;
	      report_error (_("no match: %s"), tlist->word->word);
	      exp_jump_to_top_level (DISCARD);
	    }
	  else if (allow_null_glob_expansion == 0)
	    {
	      /* Failed glob expressions are left unchanged. */
	      PREPEND_LIST (tlist, output_list);
	    }
	  else
	    {
	      /* Failed glob expressions are removed. */
	      PREPEND_LIST (tlist, disposables);
	    }
	}
      else
	{
	  /* Dequote the string. */
	  temp_string = dequote_string (tlist->word->word);
	  free (tlist->word->word);
	  tlist->word->word = temp_string;
	  PREPEND_LIST (tlist, output_list);
	}

      strvec_dispose (glob_array);
      glob_array = (char **)NULL;

      tlist = next;
    }

  if (disposables)
    dispose_words (disposables);

  if (output_list)
    output_list = REVERSE_LIST (output_list, WORD_LIST *);

  return (output_list);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:11,368
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:11,836
parsing error 
{
  WORD_LIST *expanded, *orig_list, *new_list, *next, *temp_list, *wcmd;
  int expanded_something, has_dollar_at;

  /* We do tilde expansion all the time.  This is what 1003.2 says. */
  wcmd = new_list = (WORD_LIST *)NULL;

  for (orig_list = tlist; tlist; tlist = next)
    {
      if (wcmd == 0 && (tlist->word->flags & W_ASSNBLTIN))
	wcmd = tlist;
	
      next = tlist->next;

#if defined (ARRAY_VARS)
      /* If this is a compound array assignment to a builtin that accepts
         such assignments (e.g., `declare'), take the assignment and perform
         it separately, handling the semantics of declarations inside shell
         functions.  This avoids the double-evaluation of such arguments,
         because `declare' does some evaluation of compound assignments on
         its own. */
      if ((tlist->word->flags & (W_COMPASSIGN|W_ASSIGNARG)) == (W_COMPASSIGN|W_ASSIGNARG))
	expand_declaration_argument (tlist, wcmd);
#endif

      expanded_something = 0;
      expanded = expand_word_internal
	(tlist->word, 0, 0, &has_dollar_at, &expanded_something);

      if (expanded == &expand_word_error || expanded == &expand_word_fatal)
	{
	  /* By convention, each time this error is returned,
	     tlist->word->word has already been freed. */
	  tlist->word->word = (char *)NULL;

	  /* Dispose our copy of the original list. */
	  dispose_words (orig_list);
	  /* Dispose the new list we're building. */
	  dispose_words (new_list);

	  last_command_exit_value = EXECUTION_FAILURE;
	  if (expanded == &expand_word_error)
	    exp_jump_to_top_level (DISCARD);
	  else
	    exp_jump_to_top_level (FORCE_EOF);
	}

      /* Don't split words marked W_NOSPLIT. */
      if (expanded_something && (tlist->word->flags & W_NOSPLIT) == 0)
	{
	  temp_list = word_list_split (expanded);
	  dispose_words (expanded);
	}
      else
	{
	  /* If no parameter expansion, command substitution, process
	     substitution, or arithmetic substitution took place, then
	     do not do word splitting.  We still have to remove quoted
	     null characters from the result. */
	  word_list_remove_quoted_nulls (expanded);
	  temp_list = expanded;
	}

      expanded = REVERSE_LIST (temp_list, WORD_LIST *);
      new_list = (WORD_LIST *)list_append (expanded, new_list);
    }

  if (orig_list)  
    dispose_words (orig_list);

  if (new_list)
    new_list = REVERSE_LIST (new_list, WORD_LIST *);

  return (new_list);
}
warning: parse error {
  WORD_LIST *expanded, *orig_list, *new_list, *next, *temp_list, *wcmd;
  int expanded_something, has_dollar_at;

  /* We do tilde expansion all the time.  This is what 1003.2 says. */
  wcmd = new_list = (WORD_LIST *)NULL;

  for (orig_list = tlist; tlist; tlist = next)
    {
      if (wcmd == 0 && (tlist->word->flags & W_ASSNBLTIN))
	wcmd = tlist;
	
      next = tlist->next;

#if defined (ARRAY_VARS)
      /* If this is a compound array assignment to a builtin that accepts
         such assignments (e.g., `declare'), take the assignment and perform
         it separately, handling the semantics of declarations inside shell
         functions.  This avoids the double-evaluation of such arguments,
         because `declare' does some evaluation of compound assignments on
         its own. */
      if ((tlist->word->flags & (W_COMPASSIGN|W_ASSIGNARG)) == (W_COMPASSIGN|W_ASSIGNARG))
	expand_declaration_argument (tlist, wcmd);
#endif

      expanded_something = 0;
      expanded = expand_word_internal
	(tlist->word, 0, 0, &has_dollar_at, &expanded_something);

      if (expanded == &expand_word_error || expanded == &expand_word_fatal)
	{
	  /* By convention, each time this error is returned,
	     tlist->word->word has already been freed. */
	  tlist->word->word = (char *)NULL;

	  /* Dispose our copy of the original list. */
	  dispose_words (orig_list);
	  /* Dispose the new list we're building. */
	  dispose_words (new_list);

	  last_command_exit_value = EXECUTION_FAILURE;
	  if (expanded == &expand_word_error)
	    exp_jump_to_top_level (DISCARD);
	  else
	    exp_jump_to_top_level (FORCE_EOF);
	}

      /* Don't split words marked W_NOSPLIT. */
      if (expanded_something && (tlist->word->flags & W_NOSPLIT) == 0)
	{
	  temp_list = word_list_split (expanded);
	  dispose_words (expanded);
	}
      else
	{
	  /* If no parameter expansion, command substitution, process
	     substitution, or arithmetic substitution took place, then
	     do not do word splitting.  We still have to remove quoted
	     null characters from the result. */
	  word_list_remove_quoted_nulls (expanded);
	  temp_list = expanded;
	}

      expanded = REVERSE_LIST (temp_list, WORD_LIST *);
      new_list = (WORD_LIST *)list_append (expanded, new_list);
    }

  if (orig_list)  
    dispose_words (orig_list);

  if (new_list)
    new_list = REVERSE_LIST (new_list, WORD_LIST *);

  return (new_list);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:11,839
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:11,929
parsing error 
{
  WORD_LIST *new_list, *temp_list;
  int tint;
  char *savecmd;

  tempenv_assign_error = 0;
  if (list == 0)
    return ((WORD_LIST *)NULL);

  garglist = new_list = copy_word_list (list);
  if (eflags & WEXP_VARASSIGN)
    {
      garglist = new_list = separate_out_assignments (new_list);
      if (new_list == 0)
	{
	  if (subst_assign_varlist)
	    {
	      /* All the words were variable assignments, so they are placed
		 into the shell's environment. */
	      for (temp_list = subst_assign_varlist; temp_list; temp_list = temp_list->next)
		{
		  savecmd = this_command_name;
		  this_command_name = (char *)NULL;	/* no arithmetic errors */
		  tint = do_word_assignment (temp_list->word, 0);
		  this_command_name = savecmd;
		  /* Variable assignment errors in non-interactive shells
		     running in Posix.2 mode cause the shell to exit, unless
		     they are being run by the `command' builtin. */
		  if (tint == 0)
		    {
		      last_command_exit_value = EXECUTION_FAILURE;
		      if (interactive_shell == 0 && posixly_correct && executing_command_builtin == 0)
			exp_jump_to_top_level (FORCE_EOF);
		      else
			exp_jump_to_top_level (DISCARD);
		    }
		}
	      dispose_words (subst_assign_varlist);
	      subst_assign_varlist = (WORD_LIST *)NULL;
	    }
	  return ((WORD_LIST *)NULL);
	}
    }

  /* Begin expanding the words that remain.  The expansions take place on
     things that aren't really variable assignments. */

#if defined (BRACE_EXPANSION)
  /* Do brace expansion on this word if there are any brace characters
     in the string. */
  if ((eflags & WEXP_BRACEEXP) && brace_expansion && new_list)
    new_list = brace_expand_word_list (new_list, eflags);
#endif /* BRACE_EXPANSION */

  /* Perform the `normal' shell expansions: tilde expansion, parameter and
     variable substitution, command substitution, arithmetic expansion,
     and word splitting. */
  new_list = shell_expand_word_list (new_list, eflags);

  /* Okay, we're almost done.  Now let's just do some filename
     globbing. */
  if (new_list)
    {
      if ((eflags & WEXP_PATHEXP) && disallow_filename_globbing == 0)
	/* Glob expand the word list unless globbing has been disabled. */
	new_list = glob_expand_word_list (new_list, eflags);
      else
	/* Dequote the words, because we're not performing globbing. */
	new_list = dequote_list (new_list);
    }

  if ((eflags & WEXP_VARASSIGN) && subst_assign_varlist)
    {
      sh_wassign_func_t *assign_func;
      int is_special_builtin, is_builtin_or_func;

      /* If the remainder of the words expand to nothing, Posix.2 requires
	 that the variable and environment assignments affect the shell's
	 environment. */
      assign_func = new_list ? assign_in_env : do_word_assignment;
      tempenv_assign_error = 0;

      is_builtin_or_func = (new_list && new_list->word && (find_shell_builtin (new_list->word->word) || find_function (new_list->word->word)));
      /* Posix says that special builtins exit if a variable assignment error
	 occurs in an assignment preceding it. */
      is_special_builtin = (posixly_correct && new_list && new_list->word && find_special_builtin (new_list->word->word));
      
      for (temp_list = subst_assign_varlist; temp_list; temp_list = temp_list->next)
	{
	  savecmd = this_command_name;
	  this_command_name = (char *)NULL;
	  assigning_in_environment = (assign_func == assign_in_env);
	  tint = (*assign_func) (temp_list->word, is_builtin_or_func);
	  assigning_in_environment = 0;
	  this_command_name = savecmd;
	  /* Variable assignment errors in non-interactive shells running
	     in Posix.2 mode cause the shell to exit. */
	  if (tint == 0)
	    {
	      if (assign_func == do_word_assignment)
		{
		  last_command_exit_value = EXECUTION_FAILURE;
		  if (interactive_shell == 0 && posixly_correct)
		    exp_jump_to_top_level (FORCE_EOF);
		  else
		    exp_jump_to_top_level (DISCARD);
		}
	      else if (interactive_shell == 0 && is_special_builtin)
		{
		  last_command_exit_value = EXECUTION_FAILURE;
		  exp_jump_to_top_level (FORCE_EOF);
		}
	      else
		tempenv_assign_error++;
	    }
	}

      dispose_words (subst_assign_varlist);
      subst_assign_varlist = (WORD_LIST *)NULL;
    }

  return (new_list);
}
warning: parse error {
  WORD_LIST *new_list, *temp_list;
  int tint;
  char *savecmd;

  tempenv_assign_error = 0;
  if (list == 0)
    return ((WORD_LIST *)NULL);

  garglist = new_list = copy_word_list (list);
  if (eflags & WEXP_VARASSIGN)
    {
      garglist = new_list = separate_out_assignments (new_list);
      if (new_list == 0)
	{
	  if (subst_assign_varlist)
	    {
	      /* All the words were variable assignments, so they are placed
		 into the shell's environment. */
	      for (temp_list = subst_assign_varlist; temp_list; temp_list = temp_list->next)
		{
		  savecmd = this_command_name;
		  this_command_name = (char *)NULL;	/* no arithmetic errors */
		  tint = do_word_assignment (temp_list->word, 0);
		  this_command_name = savecmd;
		  /* Variable assignment errors in non-interactive shells
		     running in Posix.2 mode cause the shell to exit, unless
		     they are being run by the `command' builtin. */
		  if (tint == 0)
		    {
		      last_command_exit_value = EXECUTION_FAILURE;
		      if (interactive_shell == 0 && posixly_correct && executing_command_builtin == 0)
			exp_jump_to_top_level (FORCE_EOF);
		      else
			exp_jump_to_top_level (DISCARD);
		    }
		}
	      dispose_words (subst_assign_varlist);
	      subst_assign_varlist = (WORD_LIST *)NULL;
	    }
	  return ((WORD_LIST *)NULL);
	}
    }

  /* Begin expanding the words that remain.  The expansions take place on
     things that aren't really variable assignments. */

#if defined (BRACE_EXPANSION)
  /* Do brace expansion on this word if there are any brace characters
     in the string. */
  if ((eflags & WEXP_BRACEEXP) && brace_expansion && new_list)
    new_list = brace_expand_word_list (new_list, eflags);
#endif /* BRACE_EXPANSION */

  /* Perform the `normal' shell expansions: tilde expansion, parameter and
     variable substitution, command substitution, arithmetic expansion,
     and word splitting. */
  new_list = shell_expand_word_list (new_list, eflags);

  /* Okay, we're almost done.  Now let's just do some filename
     globbing. */
  if (new_list)
    {
      if ((eflags & WEXP_PATHEXP) && disallow_filename_globbing == 0)
	/* Glob expand the word list unless globbing has been disabled. */
	new_list = glob_expand_word_list (new_list, eflags);
      else
	/* Dequote the words, because we're not performing globbing. */
	new_list = dequote_list (new_list);
    }

  if ((eflags & WEXP_VARASSIGN) && subst_assign_varlist)
    {
      sh_wassign_func_t *assign_func;
      int is_special_builtin, is_builtin_or_func;

      /* If the remainder of the words expand to nothing, Posix.2 requires
	 that the variable and environment assignments affect the shell's
	 environment. */
      assign_func = new_list ? assign_in_env : do_word_assignment;
      tempenv_assign_error = 0;

      is_builtin_or_func = (new_list && new_list->word && (find_shell_builtin (new_list->word->word) || find_function (new_list->word->word)));
      /* Posix says that special builtins exit if a variable assignment error
	 occurs in an assignment preceding it. */
      is_special_builtin = (posixly_correct && new_list && new_list->word && find_special_builtin (new_list->word->word));
      
      for (temp_list = subst_assign_varlist; temp_list; temp_list = temp_list->next)
	{
	  savecmd = this_command_name;
	  this_command_name = (char *)NULL;
	  assigning_in_environment = (assign_func == assign_in_env);
	  tint = (*assign_func) (temp_list->word, is_builtin_or_func);
	  assigning_in_environment = 0;
	  this_command_name = savecmd;
	  /* Variable assignment errors in non-interactive shells running
	     in Posix.2 mode cause the shell to exit. */
	  if (tint == 0)
	    {
	      if (assign_func == do_word_assignment)
		{
		  last_command_exit_value = EXECUTION_FAILURE;
		  if (interactive_shell == 0 && posixly_correct)
		    exp_jump_to_top_level (FORCE_EOF);
		  else
		    exp_jump_to_top_level (DISCARD);
		}
	      else if (interactive_shell == 0 && is_special_builtin)
		{
		  last_command_exit_value = EXECUTION_FAILURE;
		  exp_jump_to_top_level (FORCE_EOF);
		}
	      else
		tempenv_assign_error++;
	    }
	}

      dispose_words (subst_assign_varlist);
      subst_assign_varlist = (WORD_LIST *)NULL;
    }

  return (new_list);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\subst.c:11,932
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\support\bashversion.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\stdc.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashansi.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\conftypes.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\support\bashversion.c:63
parsing error 
{
  int opt, oflags;
  char dv[128], *rv;

  if (progname = strrchr (argv[0], '/'))
    progname++;
  else
    progname = argv[0];

  oflags = 0;
  while ((opt = getopt(argc, argv, "hrvmpslx")) != EOF)
    {
      switch (opt)
	{
	case 'h':
	  usage ();
	  exit (0);
	case 'r':
	  oflags |= RFLAG;	/* release */
	  break;
	case 'v':
	  oflags |= VFLAG;	/* version */
	  break;
	case 'm':
	  oflags |= MFLAG;	/* machtype */
	  break;
	case 'p':
	  oflags |= PFLAG;	/* patchlevel */
	  break;
	case 's':		/* short version string */
	  oflags |= SFLAG;
	  break;
	case 'l':		/* long version string */
	  oflags |= LFLAG;
	  break;
	case 'x':		/* extended version information */
	  oflags |= XFLAG;
	  break;
	default:
	  usage ();
	  exit (2);
	}
    }

  argc -= optind;
  argv += optind;

  if (argc > 0)
    {
      usage ();
      exit (2);
    }

  /* default behavior */  
  if (oflags == 0)
    oflags = SFLAG;

  if (oflags & (RFLAG|VFLAG))
    {
      strcpy (dv, dist_version);
      rv = strchr (dv, '.');
      if (rv)
        *rv++ = '\0';
      else
        rv = "00";
    }
  if (oflags & RFLAG)
    printf ("%s\n", dv);
  else if (oflags & VFLAG)
    printf ("%s\n", rv);
  else if (oflags & MFLAG)
    printf ("%s\n", MACHTYPE);
  else if (oflags & PFLAG)
    printf ("%d\n", patch_level);
  else if (oflags & SFLAG)
    printf ("%s\n", shell_version_string ());
  else if (oflags & LFLAG)
    show_shell_version (0);
  else if (oflags & XFLAG)
    show_shell_version (1);

  exit (0);
}
warning: parse error {
  int opt, oflags;
  char dv[128], *rv;

  if (progname = strrchr (argv[0], '/'))
    progname++;
  else
    progname = argv[0];

  oflags = 0;
  while ((opt = getopt(argc, argv, "hrvmpslx")) != EOF)
    {
      switch (opt)
	{
	case 'h':
	  usage ();
	  exit (0);
	case 'r':
	  oflags |= RFLAG;	/* release */
	  break;
	case 'v':
	  oflags |= VFLAG;	/* version */
	  break;
	case 'm':
	  oflags |= MFLAG;	/* machtype */
	  break;
	case 'p':
	  oflags |= PFLAG;	/* patchlevel */
	  break;
	case 's':		/* short version string */
	  oflags |= SFLAG;
	  break;
	case 'l':		/* long version string */
	  oflags |= LFLAG;
	  break;
	case 'x':		/* extended version information */
	  oflags |= XFLAG;
	  break;
	default:
	  usage ();
	  exit (2);
	}
    }

  argc -= optind;
  argv += optind;

  if (argc > 0)
    {
      usage ();
      exit (2);
    }

  /* default behavior */  
  if (oflags == 0)
    oflags = SFLAG;

  if (oflags & (RFLAG|VFLAG))
    {
      strcpy (dv, dist_version);
      rv = strchr (dv, '.');
      if (rv)
        *rv++ = '\0';
      else
        rv = "00";
    }
  if (oflags & RFLAG)
    printf ("%s\n", dv);
  else if (oflags & VFLAG)
    printf ("%s\n", rv);
  else if (oflags & MFLAG)
    printf ("%s\n", MACHTYPE);
  else if (oflags & PFLAG)
    printf ("%d\n", patch_level);
  else if (oflags & SFLAG)
    printf ("%s\n", shell_version_string ());
  else if (oflags & LFLAG)
    show_shell_version (0);
  else if (oflags & XFLAG)
    show_shell_version (1);

  exit (0);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\support\bashversion.c:66
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\support\man2html.c...
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\support\mksignames.c...
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\support\mksignames.c:48
parsing error 
{
  register int i;

  fprintf (stream, "/* This file was automatically created by %s.\n",
	   progname);
  fprintf (stream, "   Do not edit.  Edit support/mksignames.c instead. */\n\n");
  fprintf (stream,
	   "/* A translation list so we can be polite to our users. */\n");
#if defined (CROSS_COMPILING)
  fprintf (stream, "extern char *signal_names[];\n\n");
  fprintf (stream, "extern void initialize_signames PARAMS((void));\n\n");
#else
  fprintf (stream, "char *signal_names[NSIG + 4] = {\n");

  for (i = 0; i <= LASTSIG; i++)
    fprintf (stream, "    \"%s\",\n", signal_names[i]);

  fprintf (stream, "    (char *)0x0\n");
  fprintf (stream, "};\n\n");
  fprintf (stream, "#define initialize_signames()\n\n");
#endif
}
warning: parse error {
  register int i;

  fprintf (stream, "/* This file was automatically created by %s.\n",
	   progname);
  fprintf (stream, "   Do not edit.  Edit support/mksignames.c instead. */\n\n");
  fprintf (stream,
	   "/* A translation list so we can be polite to our users. */\n");
#if defined (CROSS_COMPILING)
  fprintf (stream, "extern char *signal_names[];\n\n");
  fprintf (stream, "extern void initialize_signames PARAMS((void));\n\n");
#else
  fprintf (stream, "char *signal_names[NSIG + 4] = {\n");

  for (i = 0; i <= LASTSIG; i++)
    fprintf (stream, "    \"%s\",\n", signal_names[i]);

  fprintf (stream, "    (char *)0x0\n");
  fprintf (stream, "};\n\n");
  fprintf (stream, "#define initialize_signames()\n\n");
#endif
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\support\mksignames.c:50
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\support\mksignames.c:74
parsing error 
{
  char *stream_name;
  FILE *stream;

  progname = argv[0];

  if (argc == 1)
    {
      stream_name = "stdout";
      stream = stdout;
    }
  else if (argc == 2)
    {
      stream_name = argv[1];
      stream = fopen (stream_name, "w");
    }
  else
    {
      fprintf (stderr, "Usage: %s [output-file]\n", progname);
      exit (1);
    }

  if (!stream)
    {
      fprintf (stderr, "%s: %s: cannot open for writing\n",
	       progname, stream_name);
      exit (2);
    }

#if !defined (CROSS_COMPILING)
  initialize_signames ();
#endif
  write_signames (stream);
  exit (0);
}
warning: parse error {
  char *stream_name;
  FILE *stream;

  progname = argv[0];

  if (argc == 1)
    {
      stream_name = "stdout";
      stream = stdout;
    }
  else if (argc == 2)
    {
      stream_name = argv[1];
      stream = fopen (stream_name, "w");
    }
  else
    {
      fprintf (stderr, "Usage: %s [output-file]\n", progname);
      exit (1);
    }

  if (!stream)
    {
      fprintf (stderr, "%s: %s: cannot open for writing\n",
	       progname, stream_name);
      exit (2);
    }

#if !defined (CROSS_COMPILING)
  initialize_signames ();
#endif
  write_signames (stream);
  exit (0);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\support\mksignames.c:77
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\support\printenv.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashansi.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\support\printenv.c:37
parsing error 
{
  register char **envp, *eval;
  int len;

  argv++;
  argc--;

  /* printenv */
  if (argc == 0)
    {
      for (envp = environ; *envp; envp++)
	puts (*envp);
      exit (0);
    }

  /* printenv varname */
  len = strlen (*argv);
  for (envp = environ; *envp; envp++)
    {
      if (**argv == **envp && strncmp (*envp, *argv, len) == 0)
	{
	  eval = *envp + len;
	  /* If the environment variable doesn't have an `=', ignore it. */
	  if (*eval == '=')
	    {
	      puts (eval + 1);
	      exit (0);
	    }
	}
    }
  exit (1);
}
warning: parse error {
  register char **envp, *eval;
  int len;

  argv++;
  argc--;

  /* printenv */
  if (argc == 0)
    {
      for (envp = environ; *envp; envp++)
	puts (*envp);
      exit (0);
    }

  /* printenv varname */
  len = strlen (*argv);
  for (envp = environ; *envp; envp++)
    {
      if (**argv == **envp && strncmp (*envp, *argv, len) == 0)
	{
	  eval = *envp + len;
	  /* If the environment variable doesn't have an `=', ignore it. */
	  if (*eval == '=')
	    {
	      puts (eval + 1);
	      exit (0);
	    }
	}
    }
  exit (1);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\support\printenv.c:40
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\support\recho.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashansi.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\support\recho.c:37
parsing error 
{
	register int	i;

	for (i = 1; i < argc; i++) {
		printf("argv[%d] = <", i);
		strprint(argv[i]);
		printf(">\n");
	}
	exit(0);
}
warning: parse error {
	register int	i;

	for (i = 1; i < argc; i++) {
		printf("argv[%d] = <", i);
		strprint(argv[i]);
		printf(">\n");
	}
	exit(0);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\support\recho.c:40
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\support\recho.c:52
parsing error 
{
	register unsigned char *s;

	for (s = (unsigned char *)str; s && *s; s++) {
		if (*s < ' ') {
			putchar('^');
			putchar(*s+64);
		} else if (*s == 127) {
			putchar('^');
			putchar('?');
		} else
			putchar(*s);
	}
}
warning: parse error {
	register unsigned char *s;

	for (s = (unsigned char *)str; s && *s; s++) {
		if (*s < ' ') {
			putchar('^');
			putchar(*s+64);
		} else if (*s == 127) {
			putchar('^');
			putchar('?');
		} else
			putchar(*s);
	}
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\support\recho.c:54
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\support\signames.c...
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\support\xcase.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashansi.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\support\xcase.c:45
parsing error 
{
	int	c, x;
	int	op;
	FILE	*inf;

	op = 0;
	while ((c = getopt(ac, av, "lnu")) != EOF) {
		switch (c) {
		case 'n':
			setbuf (stdout, (char *)NULL);
			break;
		case 'u':
			op = UPPER;
			break;
		case 'l':
			op = LOWER;
			break;
		default:
			fprintf(stderr, "casemod: usage: casemod [-lnu] [file]\n");
			exit(2);
		}
	}
	av += optind;
	ac -= optind;

	if (av[0] && (av[0][0] != '-' || av[0][1])) {
		inf = fopen(av[0], "r");
		if (inf == 0) {
			fprintf(stderr, "casemod: %s: cannot open: %s\n", av[0], strerror(errno));
			exit(1);
		}
	} else
		inf = stdin;

	while ((c = getc(inf)) != EOF) {
		switch (op) {
		case UPPER:
			x = islower(c) ? toupper(c) : c;
			break;
		case LOWER:
			x = isupper(c) ? tolower(c) : c;
			break;
		default:
			x = c;
			break;
		}
		putchar(x);
	}
			
	exit(0);
}
warning: parse error {
	int	c, x;
	int	op;
	FILE	*inf;

	op = 0;
	while ((c = getopt(ac, av, "lnu")) != EOF) {
		switch (c) {
		case 'n':
			setbuf (stdout, (char *)NULL);
			break;
		case 'u':
			op = UPPER;
			break;
		case 'l':
			op = LOWER;
			break;
		default:
			fprintf(stderr, "casemod: usage: casemod [-lnu] [file]\n");
			exit(2);
		}
	}
	av += optind;
	ac -= optind;

	if (av[0] && (av[0][0] != '-' || av[0][1])) {
		inf = fopen(av[0], "r");
		if (inf == 0) {
			fprintf(stderr, "casemod: %s: cannot open: %s\n", av[0], strerror(errno));
			exit(1);
		}
	} else
		inf = stdin;

	while ((c = getc(inf)) != EOF) {
		switch (op) {
		case UPPER:
			x = islower(c) ? toupper(c) : c;
			break;
		case LOWER:
			x = isupper(c) ? tolower(c) : c;
			break;
		default:
			x = c;
			break;
		}
		putchar(x);
	}
			
	exit(0);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\support\xcase.c:48
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\support\zecho.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashansi.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\support\zecho.c:29
parsing error 
{
	argv++;

	while (*argv) {
		(void)printf("%s", *argv);
		if (*++argv)
			putchar(' ');
	}

	putchar('\n');
	exit(0);
}
warning: parse error {
	argv++;

	while (*argv) {
		(void)printf("%s", *argv);
		if (*++argv)
			putchar(' ');
	}

	putchar('\n');
	exit(0);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\support\zecho.c:32
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\test.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashtypes.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\posixstat.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\filecntl.h...skip
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\stat-time.h...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashintl.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\shell.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\pathexp.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\test.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\common.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\glob\strmatch.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\test.c:133
parsing error 
{
  builtin_error (format, arg);
  test_exit (TEST_ERREXIT_STATUS);
}
warning: parse error {
  builtin_error (format, arg);
  test_exit (TEST_ERREXIT_STATUS);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\test.c:135
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\test.c:153
parsing error 
{
  test_syntax_error (_("%s: integer expression expected"), pch);
}
warning: parse error {
  test_syntax_error (_("%s: integer expression expected"), pch);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\test.c:155
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\test.c:291
parsing error 
{
  int r;

  r = sh_stat (fn, st);
  if (r < 0)
    return r;
  *ts = get_stat_mtime (st);
  return 0;
}
warning: parse error {
  int r;

  r = sh_stat (fn, st);
  if (r < 0)
    return r;
  *ts = get_stat_mtime (st);
  return 0;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\test.c:295
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\test.c:306
parsing error 
{
  struct stat st1, st2;
  struct timespec ts1, ts2;
  int r1, r2;

  if ((r1 = stat_mtime (s, &st1, &ts1)) < 0)
    {
      if (op == EF)
	return (FALSE);
    }
  if ((r2 = stat_mtime (t, &st2, &ts2)) < 0)
    {
      if (op == EF)
	return (FALSE);
    }
  
  switch (op)
    {
    case OT: return (r1 < r2 || (r2 == 0 && timespec_cmp (ts1, ts2) < 0));
    case NT: return (r1 > r2 || (r1 == 0 && timespec_cmp (ts1, ts2) > 0));
    case EF: return (same_file (s, t, &st1, &st2));
    }
  return (FALSE);
}
warning: parse error {
  struct stat st1, st2;
  struct timespec ts1, ts2;
  int r1, r2;

  if ((r1 = stat_mtime (s, &st1, &ts1)) < 0)
    {
      if (op == EF)
	return (FALSE);
    }
  if ((r2 = stat_mtime (t, &st2, &ts2)) < 0)
    {
      if (op == EF)
	return (FALSE);
    }
  
  switch (op)
    {
    case OT: return (r1 < r2 || (r2 == 0 && timespec_cmp (ts1, ts2) < 0));
    case NT: return (r1 > r2 || (r1 == 0 && timespec_cmp (ts1, ts2) > 0));
    case EF: return (same_file (s, t, &st1, &st2));
    }
  return (FALSE);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\test.c:309
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\test.c:335
parsing error 
{
  intmax_t l, r;
  int expok;

  if (flags & TEST_ARITHEXP)
    {
      l = evalexp (s, EXP_EXPANDED, &expok);
      if (expok == 0)
	return (FALSE);		/* should probably longjmp here */
      r = evalexp (t, EXP_EXPANDED, &expok);
      if (expok == 0)
	return (FALSE);		/* ditto */
    }
  else
    {
      if (legal_number (s, &l) == 0)
	integer_expected_error (s);
      if (legal_number (t, &r) == 0)
	integer_expected_error (t);
    }

  switch (op)
    {
    case EQ: return (l == r);
    case NE: return (l != r);
    case LT: return (l < r);
    case GT: return (l > r);
    case LE: return (l <= r);
    case GE: return (l >= r);
    }

  return (FALSE);
}
warning: parse error {
  intmax_t l, r;
  int expok;

  if (flags & TEST_ARITHEXP)
    {
      l = evalexp (s, EXP_EXPANDED, &expok);
      if (expok == 0)
	return (FALSE);		/* should probably longjmp here */
      r = evalexp (t, EXP_EXPANDED, &expok);
      if (expok == 0)
	return (FALSE);		/* ditto */
    }
  else
    {
      if (legal_number (s, &l) == 0)
	integer_expected_error (s);
      if (legal_number (t, &r) == 0)
	integer_expected_error (t);
    }

  switch (op)
    {
    case EQ: return (l == r);
    case NE: return (l != r);
    case LT: return (l < r);
    case GT: return (l > r);
    case LE: return (l <= r);
    case GE: return (l >= r);
    }

  return (FALSE);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\test.c:338
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\test.c:373
parsing error 
{
  int m;

  m = strmatch (pat, string, FNMATCH_EXTFLAG|FNMATCH_IGNCASE);
  return ((op == EQ) ? (m == 0) : (m != 0));
}
warning: parse error {
  int m;

  m = strmatch (pat, string, FNMATCH_EXTFLAG|FNMATCH_IGNCASE);
  return ((op == EQ) ? (m == 0) : (m != 0));
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\test.c:376
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\test.c:384
parsing error 
{
  int patmatch;

  patmatch = (flags & TEST_PATMATCH);

  if (op[0] == '=' && (op[1] == '\0' || (op[1] == '=' && op[2] == '\0')))
    return (patmatch ? patcomp (arg1, arg2, EQ) : STREQ (arg1, arg2));
  else if ((op[0] == '>' || op[0] == '<') && op[1] == '\0')
    {
#if defined (HAVE_STRCOLL)
      if (shell_compatibility_level > 40 && flags & TEST_LOCALE)
	return ((op[0] == '>') ? (strcoll (arg1, arg2) > 0) : (strcoll (arg1, arg2) < 0));
      else
#endif
	return ((op[0] == '>') ? (strcmp (arg1, arg2) > 0) : (strcmp (arg1, arg2) < 0));
    }
  else if (op[0] == '!' && op[1] == '=' && op[2] == '\0')
    return (patmatch ? patcomp (arg1, arg2, NE) : (STREQ (arg1, arg2) == 0));
    

  else if (op[2] == 't')
    {
      switch (op[1])
	{
	case 'n': return (filecomp (arg1, arg2, NT));		/* -nt */
	case 'o': return (filecomp (arg1, arg2, OT));		/* -ot */
	case 'l': return (arithcomp (arg1, arg2, LT, flags));	/* -lt */
	case 'g': return (arithcomp (arg1, arg2, GT, flags));	/* -gt */
	}
    }
  else if (op[1] == 'e')
    {
      switch (op[2])
	{
	case 'f': return (filecomp (arg1, arg2, EF));		/* -ef */
	case 'q': return (arithcomp (arg1, arg2, EQ, flags));	/* -eq */
	}
    }
  else if (op[2] == 'e')
    {
      switch (op[1])
	{
	case 'n': return (arithcomp (arg1, arg2, NE, flags));	/* -ne */
	case 'g': return (arithcomp (arg1, arg2, GE, flags));	/* -ge */
	case 'l': return (arithcomp (arg1, arg2, LE, flags));	/* -le */
	}
    }

  return (FALSE);	/* should never get here */
}
warning: parse error {
  int patmatch;

  patmatch = (flags & TEST_PATMATCH);

  if (op[0] == '=' && (op[1] == '\0' || (op[1] == '=' && op[2] == '\0')))
    return (patmatch ? patcomp (arg1, arg2, EQ) : STREQ (arg1, arg2));
  else if ((op[0] == '>' || op[0] == '<') && op[1] == '\0')
    {
#if defined (HAVE_STRCOLL)
      if (shell_compatibility_level > 40 && flags & TEST_LOCALE)
	return ((op[0] == '>') ? (strcoll (arg1, arg2) > 0) : (strcoll (arg1, arg2) < 0));
      else
#endif
	return ((op[0] == '>') ? (strcmp (arg1, arg2) > 0) : (strcmp (arg1, arg2) < 0));
    }
  else if (op[0] == '!' && op[1] == '=' && op[2] == '\0')
    return (patmatch ? patcomp (arg1, arg2, NE) : (STREQ (arg1, arg2) == 0));
    

  else if (op[2] == 't')
    {
      switch (op[1])
	{
	case 'n': return (filecomp (arg1, arg2, NT));		/* -nt */
	case 'o': return (filecomp (arg1, arg2, OT));		/* -ot */
	case 'l': return (arithcomp (arg1, arg2, LT, flags));	/* -lt */
	case 'g': return (arithcomp (arg1, arg2, GT, flags));	/* -gt */
	}
    }
  else if (op[1] == 'e')
    {
      switch (op[2])
	{
	case 'f': return (filecomp (arg1, arg2, EF));		/* -ef */
	case 'q': return (arithcomp (arg1, arg2, EQ, flags));	/* -eq */
	}
    }
  else if (op[2] == 'e')
    {
      switch (op[1])
	{
	case 'n': return (arithcomp (arg1, arg2, NE, flags));	/* -ne */
	case 'g': return (arithcomp (arg1, arg2, GE, flags));	/* -ge */
	case 'l': return (arithcomp (arg1, arg2, LE, flags));	/* -le */
	}
    }

  return (FALSE);	/* should never get here */
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\test.c:387
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\test.c:513
parsing error 
{
  intmax_t r;
  struct stat stat_buf;
  struct timespec mtime, atime;
  SHELL_VAR *v;
     
  switch (op[1])
    {
    case 'a':			/* file exists in the file system? */
    case 'e':
      return (sh_stat (arg, &stat_buf) == 0);

    case 'r':			/* file is readable? */
      return (sh_eaccess (arg, R_OK) == 0);

    case 'w':			/* File is writeable? */
      return (sh_eaccess (arg, W_OK) == 0);

    case 'x':			/* File is executable? */
      return (sh_eaccess (arg, X_OK) == 0);

    case 'O':			/* File is owned by you? */
      return (sh_stat (arg, &stat_buf) == 0 &&
	      (uid_t) current_user.euid == (uid_t) stat_buf.st_uid);

    case 'G':			/* File is owned by your group? */
      return (sh_stat (arg, &stat_buf) == 0 &&
	      (gid_t) current_user.egid == (gid_t) stat_buf.st_gid);

    case 'N':
      if (sh_stat (arg, &stat_buf) < 0)
	return (FALSE);
      atime = get_stat_atime (&stat_buf);
      mtime = get_stat_mtime (&stat_buf);
      return (timespec_cmp (mtime, atime) > 0);

    case 'f':			/* File is a file? */
      if (sh_stat (arg, &stat_buf) < 0)
	return (FALSE);

      /* -f is true if the given file exists and is a regular file. */
#if defined (S_IFMT)
      return (S_ISREG (stat_buf.st_mode) || (stat_buf.st_mode & S_IFMT) == 0);
#else
      return (S_ISREG (stat_buf.st_mode));
#endif /* !S_IFMT */

    case 'd':			/* File is a directory? */
      return (sh_stat (arg, &stat_buf) == 0 && (S_ISDIR (stat_buf.st_mode)));

    case 's':			/* File has something in it? */
      return (sh_stat (arg, &stat_buf) == 0 && stat_buf.st_size > (off_t) 0);

    case 'S':			/* File is a socket? */
#if !defined (S_ISSOCK)
      return (FALSE);
#else
      return (sh_stat (arg, &stat_buf) == 0 && S_ISSOCK (stat_buf.st_mode));
#endif /* S_ISSOCK */

    case 'c':			/* File is character special? */
      return (sh_stat (arg, &stat_buf) == 0 && S_ISCHR (stat_buf.st_mode));

    case 'b':			/* File is block special? */
      return (sh_stat (arg, &stat_buf) == 0 && S_ISBLK (stat_buf.st_mode));

    case 'p':			/* File is a named pipe? */
#ifndef S_ISFIFO
      return (FALSE);
#else
      return (sh_stat (arg, &stat_buf) == 0 && S_ISFIFO (stat_buf.st_mode));
#endif /* S_ISFIFO */

    case 'L':			/* Same as -h  */
    case 'h':			/* File is a symbolic link? */
#if !defined (S_ISLNK) || !defined (HAVE_LSTAT)
      return (FALSE);
#else
      return ((arg[0] != '\0') &&
	      (lstat (arg, &stat_buf) == 0) && S_ISLNK (stat_buf.st_mode));
#endif /* S_IFLNK && HAVE_LSTAT */

    case 'u':			/* File is setuid? */
      return (sh_stat (arg, &stat_buf) == 0 && (stat_buf.st_mode & S_ISUID) != 0);

    case 'g':			/* File is setgid? */
      return (sh_stat (arg, &stat_buf) == 0 && (stat_buf.st_mode & S_ISGID) != 0);

    case 'k':			/* File has sticky bit set? */
#if !defined (S_ISVTX)
      /* This is not Posix, and is not defined on some Posix systems. */
      return (FALSE);
#else
      return (sh_stat (arg, &stat_buf) == 0 && (stat_buf.st_mode & S_ISVTX) != 0);
#endif

    case 't':	/* File fd is a terminal? */
      if (legal_number (arg, &r) == 0)
	return (FALSE);
      return ((r == (int)r) && isatty ((int)r));

    case 'n':			/* True if arg has some length. */
      return (arg[0] != '\0');

    case 'z':			/* True if arg has no length. */
      return (arg[0] == '\0');

    case 'o':			/* True if option `arg' is set. */
      return (minus_o_option_value (arg) == 1);

    case 'v':
#if defined (ARRAY_VARS)
      if (valid_array_reference (arg, 0))
	{
	  char *t;
	  int rtype, ret, flags;

	  /* Let's assume that this has already been expanded once. */
	  flags = assoc_expand_once ? AV_NOEXPAND : 0;
	  t = array_value (arg, 0, flags, &rtype, (arrayind_t *)0);
	  ret = t ? TRUE : FALSE;
	  if (rtype > 0)	/* subscript is * or @ */
	    free (t);
	  return ret;
	}
      else if (legal_number (arg, &r))		/* -v n == is $n set? */
	return ((r >= 0 && r <= number_of_args()) ? TRUE : FALSE);
      v = find_variable (arg);
      if (v && invisible_p (v) == 0 && array_p (v))
	{
	  char *t;
	  /* [[ -v foo ]] == [[ -v foo[0] ]] */
	  t = array_reference (array_cell (v), 0);
	  return (t ? TRUE : FALSE);
	}
      else if (v && invisible_p (v) == 0 && assoc_p (v))
	{
	  char *t;
	  t = assoc_reference (assoc_cell (v), "0");
	  return (t ? TRUE : FALSE);
	}
#else
      v = find_variable (arg);
#endif
      return (v && invisible_p (v) == 0 && var_isset (v) ? TRUE : FALSE);

    case 'R':
      v = find_variable_noref (arg);
      return ((v && invisible_p (v) == 0 && var_isset (v) && nameref_p (v)) ? TRUE : FALSE);
    }

  /* We can't actually get here, but this shuts up gcc. */
  return (FALSE);
}
warning: parse error {
  intmax_t r;
  struct stat stat_buf;
  struct timespec mtime, atime;
  SHELL_VAR *v;
     
  switch (op[1])
    {
    case 'a':			/* file exists in the file system? */
    case 'e':
      return (sh_stat (arg, &stat_buf) == 0);

    case 'r':			/* file is readable? */
      return (sh_eaccess (arg, R_OK) == 0);

    case 'w':			/* File is writeable? */
      return (sh_eaccess (arg, W_OK) == 0);

    case 'x':			/* File is executable? */
      return (sh_eaccess (arg, X_OK) == 0);

    case 'O':			/* File is owned by you? */
      return (sh_stat (arg, &stat_buf) == 0 &&
	      (uid_t) current_user.euid == (uid_t) stat_buf.st_uid);

    case 'G':			/* File is owned by your group? */
      return (sh_stat (arg, &stat_buf) == 0 &&
	      (gid_t) current_user.egid == (gid_t) stat_buf.st_gid);

    case 'N':
      if (sh_stat (arg, &stat_buf) < 0)
	return (FALSE);
      atime = get_stat_atime (&stat_buf);
      mtime = get_stat_mtime (&stat_buf);
      return (timespec_cmp (mtime, atime) > 0);

    case 'f':			/* File is a file? */
      if (sh_stat (arg, &stat_buf) < 0)
	return (FALSE);

      /* -f is true if the given file exists and is a regular file. */
#if defined (S_IFMT)
      return (S_ISREG (stat_buf.st_mode) || (stat_buf.st_mode & S_IFMT) == 0);
#else
      return (S_ISREG (stat_buf.st_mode));
#endif /* !S_IFMT */

    case 'd':			/* File is a directory? */
      return (sh_stat (arg, &stat_buf) == 0 && (S_ISDIR (stat_buf.st_mode)));

    case 's':			/* File has something in it? */
      return (sh_stat (arg, &stat_buf) == 0 && stat_buf.st_size > (off_t) 0);

    case 'S':			/* File is a socket? */
#if !defined (S_ISSOCK)
      return (FALSE);
#else
      return (sh_stat (arg, &stat_buf) == 0 && S_ISSOCK (stat_buf.st_mode));
#endif /* S_ISSOCK */

    case 'c':			/* File is character special? */
      return (sh_stat (arg, &stat_buf) == 0 && S_ISCHR (stat_buf.st_mode));

    case 'b':			/* File is block special? */
      return (sh_stat (arg, &stat_buf) == 0 && S_ISBLK (stat_buf.st_mode));

    case 'p':			/* File is a named pipe? */
#ifndef S_ISFIFO
      return (FALSE);
#else
      return (sh_stat (arg, &stat_buf) == 0 && S_ISFIFO (stat_buf.st_mode));
#endif /* S_ISFIFO */

    case 'L':			/* Same as -h  */
    case 'h':			/* File is a symbolic link? */
#if !defined (S_ISLNK) || !defined (HAVE_LSTAT)
      return (FALSE);
#else
      return ((arg[0] != '\0') &&
	      (lstat (arg, &stat_buf) == 0) && S_ISLNK (stat_buf.st_mode));
#endif /* S_IFLNK && HAVE_LSTAT */

    case 'u':			/* File is setuid? */
      return (sh_stat (arg, &stat_buf) == 0 && (stat_buf.st_mode & S_ISUID) != 0);

    case 'g':			/* File is setgid? */
      return (sh_stat (arg, &stat_buf) == 0 && (stat_buf.st_mode & S_ISGID) != 0);

    case 'k':			/* File has sticky bit set? */
#if !defined (S_ISVTX)
      /* This is not Posix, and is not defined on some Posix systems. */
      return (FALSE);
#else
      return (sh_stat (arg, &stat_buf) == 0 && (stat_buf.st_mode & S_ISVTX) != 0);
#endif

    case 't':	/* File fd is a terminal? */
      if (legal_number (arg, &r) == 0)
	return (FALSE);
      return ((r == (int)r) && isatty ((int)r));

    case 'n':			/* True if arg has some length. */
      return (arg[0] != '\0');

    case 'z':			/* True if arg has no length. */
      return (arg[0] == '\0');

    case 'o':			/* True if option `arg' is set. */
      return (minus_o_option_value (arg) == 1);

    case 'v':
#if defined (ARRAY_VARS)
      if (valid_array_reference (arg, 0))
	{
	  char *t;
	  int rtype, ret, flags;

	  /* Let's assume that this has already been expanded once. */
	  flags = assoc_expand_once ? AV_NOEXPAND : 0;
	  t = array_value (arg, 0, flags, &rtype, (arrayind_t *)0);
	  ret = t ? TRUE : FALSE;
	  if (rtype > 0)	/* subscript is * or @ */
	    free (t);
	  return ret;
	}
      else if (legal_number (arg, &r))		/* -v n == is $n set? */
	return ((r >= 0 && r <= number_of_args()) ? TRUE : FALSE);
      v = find_variable (arg);
      if (v && invisible_p (v) == 0 && array_p (v))
	{
	  char *t;
	  /* [[ -v foo ]] == [[ -v foo[0] ]] */
	  t = array_reference (array_cell (v), 0);
	  return (t ? TRUE : FALSE);
	}
      else if (v && invisible_p (v) == 0 && assoc_p (v))
	{
	  char *t;
	  t = assoc_reference (assoc_cell (v), "0");
	  return (t ? TRUE : FALSE);
	}
#else
      v = find_variable (arg);
#endif
      return (v && invisible_p (v) == 0 && var_isset (v) ? TRUE : FALSE);

    case 'R':
      v = find_variable_noref (arg);
      return ((v && invisible_p (v) == 0 && var_isset (v) && nameref_p (v)) ? TRUE : FALSE);
    }

  /* We can't actually get here, but this shuts up gcc. */
  return (FALSE);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\test.c:515
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\test.c:672
parsing error 
{
  if (op[0] == '=' && op[1] == '\0')
    return (1);		/* '=' */
  else if ((op[0] == '<' || op[0] == '>') && op[1] == '\0')  /* string <, > */
    return (1);
  else if ((op[0] == '=' || op[0] == '!') && op[1] == '=' && op[2] == '\0')
    return (1);		/* `==' and `!=' */
#if defined (PATTERN_MATCHING)
  else if (op[2] == '\0' && op[1] == '~' && (op[0] == '=' || op[0] == '!'))
    return (1);
#endif
  else if (op[0] != '-' || op[1] == '\0' || op[2] == '\0' || op[3] != '\0')
    return (0);
  else
    {
      if (op[2] == 't')
	switch (op[1])
	  {
	  case 'n':		/* -nt */
	  case 'o':		/* -ot */
	  case 'l':		/* -lt */
	  case 'g':		/* -gt */
	    return (1);
	  default:
	    return (0);
	  }
      else if (op[1] == 'e')
	switch (op[2])
	  {
	  case 'q':		/* -eq */
	  case 'f':		/* -ef */
	    return (1);
	  default:
	    return (0);
	  }
      else if (op[2] == 'e')
	switch (op[1])
	  {
	  case 'n':		/* -ne */
	  case 'g':		/* -ge */
	  case 'l':		/* -le */
	    return (1);
	  default:
	    return (0);
	  }
      else
	return (0);
    }
}
warning: parse error {
  if (op[0] == '=' && op[1] == '\0')
    return (1);		/* '=' */
  else if ((op[0] == '<' || op[0] == '>') && op[1] == '\0')  /* string <, > */
    return (1);
  else if ((op[0] == '=' || op[0] == '!') && op[1] == '=' && op[2] == '\0')
    return (1);		/* `==' and `!=' */
#if defined (PATTERN_MATCHING)
  else if (op[2] == '\0' && op[1] == '~' && (op[0] == '=' || op[0] == '!'))
    return (1);
#endif
  else if (op[0] != '-' || op[1] == '\0' || op[2] == '\0' || op[3] != '\0')
    return (0);
  else
    {
      if (op[2] == 't')
	switch (op[1])
	  {
	  case 'n':		/* -nt */
	  case 'o':		/* -ot */
	  case 'l':		/* -lt */
	  case 'g':		/* -gt */
	    return (1);
	  default:
	    return (0);
	  }
      else if (op[1] == 'e')
	switch (op[2])
	  {
	  case 'q':		/* -eq */
	  case 'f':		/* -ef */
	    return (1);
	  default:
	    return (0);
	  }
      else if (op[2] == 'e')
	switch (op[1])
	  {
	  case 'n':		/* -ne */
	  case 'g':		/* -ge */
	  case 'l':		/* -le */
	    return (1);
	  default:
	    return (0);
	  }
      else
	return (0);
    }
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\test.c:674
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\test.c:726
parsing error 
{
  if (op[0] != '-' || (op[1] && op[2] != 0))
    return (0);

  switch (op[1])
    {
    case 'a': case 'b': case 'c': case 'd': case 'e':
    case 'f': case 'g': case 'h': case 'k': case 'n':
    case 'o': case 'p': case 'r': case 's': case 't':
    case 'u': case 'v': case 'w': case 'x': case 'z':
    case 'G': case 'L': case 'O': case 'S': case 'N':
    case 'R':
      return (1);
    }

  return (0);
}
warning: parse error {
  if (op[0] != '-' || (op[1] && op[2] != 0))
    return (0);

  switch (op[1])
    {
    case 'a': case 'b': case 'c': case 'd': case 'e':
    case 'f': case 'g': case 'h': case 'k': case 'n':
    case 'o': case 'p': case 'r': case 's': case 't':
    case 'u': case 'v': case 'w': case 'x': case 'z':
    case 'G': case 'L': case 'O': case 'S': case 'N':
    case 'R':
      return (1);
    }

  return (0);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\test.c:728
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\test.c:860
parsing error 
{
  int value;
  int code;

  USE_VAR(margc);

  code = setjmp_nosigs (test_exit_buf);

  if (code)
    return (test_error_return);

  argv = margv;

  if (margv[0] && margv[0][0] == '[' && margv[0][1] == '\0')
    {
      --margc;

      if (margv[margc] && (margv[margc][0] != ']' || margv[margc][1]))
	test_syntax_error (_("missing `]'"), (char *)NULL);

      if (margc < 2)
	test_exit (SHELL_BOOLEAN (FALSE));
    }

  argc = margc;
  pos = 1;

  if (pos >= argc)
    test_exit (SHELL_BOOLEAN (FALSE));

  noeval = 0;
  value = posixtest ();

  if (pos != argc)
    {
      if (pos < argc && argv[pos][0] == '-')
	test_syntax_error (_("syntax error: `%s' unexpected"), argv[pos]);
      else
	test_syntax_error (_("too many arguments"), (char *)NULL);
    }

  test_exit (SHELL_BOOLEAN (value));
}
warning: parse error {
  int value;
  int code;

  USE_VAR(margc);

  code = setjmp_nosigs (test_exit_buf);

  if (code)
    return (test_error_return);

  argv = margv;

  if (margv[0] && margv[0][0] == '[' && margv[0][1] == '\0')
    {
      --margc;

      if (margv[margc] && (margv[margc][0] != ']' || margv[margc][1]))
	test_syntax_error (_("missing `]'"), (char *)NULL);

      if (margc < 2)
	test_exit (SHELL_BOOLEAN (FALSE));
    }

  argc = margc;
  pos = 1;

  if (pos >= argc)
    test_exit (SHELL_BOOLEAN (FALSE));

  noeval = 0;
  value = posixtest ();

  if (pos != argc)
    {
      if (pos < argc && argv[pos][0] == '-')
	test_syntax_error (_("syntax error: `%s' unexpected"), argv[pos]);
      else
	test_syntax_error (_("too many arguments"), (char *)NULL);
    }

  test_exit (SHELL_BOOLEAN (value));
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\test.c:863
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\trap.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashtypes.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashansi.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashintl.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\trap.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\shell.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\execute_cmd.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\flags.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\parser.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\input.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\jobs.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\common.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\trap.c:213
parsing error 
{
  char *ret;

  /* on cygwin32, signal_names[sig] could be null */
  ret = (sig >= BASH_NSIG || sig < 0 || signal_names[sig] == NULL)
	? _("invalid signal number")
	: signal_names[sig];

  return ret;
}
warning: parse error {
  char *ret;

  /* on cygwin32, signal_names[sig] could be null */
  ret = (sig >= BASH_NSIG || sig < 0 || signal_names[sig] == NULL)
	? _("invalid signal number")
	: signal_names[sig];

  return ret;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\trap.c:215
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\trap.c:231
parsing error 
{
  intmax_t sig;
  char *name;

  if (legal_number (string, &sig))
    return ((sig >= 0 && sig < NSIG) ? (int)sig : NO_SIG);

#if defined (SIGRTMIN) && defined (SIGRTMAX)
  if (STREQN (string, "SIGRTMIN+", 9) || ((flags & DSIG_NOCASE) && strncasecmp (string, "SIGRTMIN+", 9) == 0))
    {
      if (legal_number (string+9, &sig) && sig >= 0 && sig <= SIGRTMAX - SIGRTMIN)
	return (SIGRTMIN + sig);
      else
	return NO_SIG;
    }
  else if (STREQN (string, "RTMIN+", 6) || ((flags & DSIG_NOCASE) && strncasecmp (string, "RTMIN+", 6) == 0))
    {
      if (legal_number (string+6, &sig) && sig >= 0 && sig <= SIGRTMAX - SIGRTMIN)
	return (SIGRTMIN + sig);
      else
	return NO_SIG;
    }
#endif /* SIGRTMIN && SIGRTMAX */

  /* A leading `SIG' may be omitted. */
  for (sig = 0; sig < BASH_NSIG; sig++)
    {
      name = signal_names[sig];
      if (name == 0 || name[0] == '\0')
	continue;

      /* Check name without the SIG prefix first case sensitively or
	 insensitively depending on whether flags includes DSIG_NOCASE */
      if (STREQN (name, "SIG", 3))
	{
	  name += 3;

	  if ((flags & DSIG_NOCASE) && strcasecmp (string, name) == 0)
	    return ((int)sig);
	  else if ((flags & DSIG_NOCASE) == 0 && strcmp (string, name) == 0)
	    return ((int)sig);
	  /* If we can't use the `SIG' prefix to match, punt on this
	     name now. */
	  else if ((flags & DSIG_SIGPREFIX) == 0)
	    continue;
	}

      /* Check name with SIG prefix case sensitively or insensitively
	 depending on whether flags includes DSIG_NOCASE */
      name = signal_names[sig];
      if ((flags & DSIG_NOCASE) && strcasecmp (string, name) == 0)
	return ((int)sig);
      else if ((flags & DSIG_NOCASE) == 0 && strcmp (string, name) == 0)
	return ((int)sig);
    }

  return (NO_SIG);
}
warning: parse error {
  intmax_t sig;
  char *name;

  if (legal_number (string, &sig))
    return ((sig >= 0 && sig < NSIG) ? (int)sig : NO_SIG);

#if defined (SIGRTMIN) && defined (SIGRTMAX)
  if (STREQN (string, "SIGRTMIN+", 9) || ((flags & DSIG_NOCASE) && strncasecmp (string, "SIGRTMIN+", 9) == 0))
    {
      if (legal_number (string+9, &sig) && sig >= 0 && sig <= SIGRTMAX - SIGRTMIN)
	return (SIGRTMIN + sig);
      else
	return NO_SIG;
    }
  else if (STREQN (string, "RTMIN+", 6) || ((flags & DSIG_NOCASE) && strncasecmp (string, "RTMIN+", 6) == 0))
    {
      if (legal_number (string+6, &sig) && sig >= 0 && sig <= SIGRTMAX - SIGRTMIN)
	return (SIGRTMIN + sig);
      else
	return NO_SIG;
    }
#endif /* SIGRTMIN && SIGRTMAX */

  /* A leading `SIG' may be omitted. */
  for (sig = 0; sig < BASH_NSIG; sig++)
    {
      name = signal_names[sig];
      if (name == 0 || name[0] == '\0')
	continue;

      /* Check name without the SIG prefix first case sensitively or
	 insensitively depending on whether flags includes DSIG_NOCASE */
      if (STREQN (name, "SIG", 3))
	{
	  name += 3;

	  if ((flags & DSIG_NOCASE) && strcasecmp (string, name) == 0)
	    return ((int)sig);
	  else if ((flags & DSIG_NOCASE) == 0 && strcmp (string, name) == 0)
	    return ((int)sig);
	  /* If we can't use the `SIG' prefix to match, punt on this
	     name now. */
	  else if ((flags & DSIG_SIGPREFIX) == 0)
	    continue;
	}

      /* Check name with SIG prefix case sensitively or insensitively
	 depending on whether flags includes DSIG_NOCASE */
      name = signal_names[sig];
      if ((flags & DSIG_NOCASE) && strcasecmp (string, name) == 0)
	return ((int)sig);
      else if ((flags & DSIG_NOCASE) == 0 && strcmp (string, name) == 0)
	return ((int)sig);
    }

  return (NO_SIG);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\trap.c:234
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\trap.c:462
parsing error 
{
  catch_flag = 1;
  pending_traps[sig]++;
  trapped_signal_received = sig;
}
warning: parse error {
  catch_flag = 1;
  pending_traps[sig]++;
  trapped_signal_received = sig;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\trap.c:464
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\trap.c:471
parsing error 
{
  int oerrno;

  if ((sigmodes[sig] & SIG_TRAPPED) == 0)
    {
#if defined (DEBUG)
      internal_warning ("trap_handler: signal %d: signal not trapped", sig);
#endif
      SIGRETURN (0);
    }

  if ((sig >= NSIG) ||
      (trap_list[sig] == (char *)DEFAULT_SIG) ||
      (trap_list[sig] == (char *)IGNORE_SIG))
    programming_error (_("trap_handler: bad signal %d"), sig);
  else
    {
      oerrno = errno;
#if defined (MUST_REINSTALL_SIGHANDLERS)
#  if defined (JOB_CONTROL) && defined (SIGCHLD)
      if (sig != SIGCHLD)
#  endif /* JOB_CONTROL && SIGCHLD */
      set_signal_handler (sig, trap_handler);
#endif /* MUST_REINSTALL_SIGHANDLERS */

      set_trap_state (sig);

      if (this_shell_builtin && (this_shell_builtin == wait_builtin))
	{
	  wait_signal_received = sig;
	  if (waiting_for_child && wait_intr_flag)
	    sh_longjmp (wait_intr_buf, 1);
	}

#if defined (READLINE)
      /* Set the event hook so readline will call it after the signal handlers
	 finish executing, so if this interrupted character input we can get
	 quick response. */
      if (RL_ISSTATE (RL_STATE_SIGHANDLER))
        bashline_set_event_hook ();
#endif

      errno = oerrno;
    }
  
  SIGRETURN (0);
}
warning: parse error {
  int oerrno;

  if ((sigmodes[sig] & SIG_TRAPPED) == 0)
    {
#if defined (DEBUG)
      internal_warning ("trap_handler: signal %d: signal not trapped", sig);
#endif
      SIGRETURN (0);
    }

  if ((sig >= NSIG) ||
      (trap_list[sig] == (char *)DEFAULT_SIG) ||
      (trap_list[sig] == (char *)IGNORE_SIG))
    programming_error (_("trap_handler: bad signal %d"), sig);
  else
    {
      oerrno = errno;
#if defined (MUST_REINSTALL_SIGHANDLERS)
#  if defined (JOB_CONTROL) && defined (SIGCHLD)
      if (sig != SIGCHLD)
#  endif /* JOB_CONTROL && SIGCHLD */
      set_signal_handler (sig, trap_handler);
#endif /* MUST_REINSTALL_SIGHANDLERS */

      set_trap_state (sig);

      if (this_shell_builtin && (this_shell_builtin == wait_builtin))
	{
	  wait_signal_received = sig;
	  if (waiting_for_child && wait_intr_flag)
	    sh_longjmp (wait_intr_buf, 1);
	}

#if defined (READLINE)
      /* Set the event hook so readline will call it after the signal handlers
	 finish executing, so if this interrupted character input we can get
	 quick response. */
      if (RL_ISSTATE (RL_STATE_SIGHANDLER))
        bashline_set_event_hook ();
#endif

      errno = oerrno;
    }
  
  SIGRETURN (0);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\trap.c:473
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\trap.c:522
parsing error 
{
  register int i;

  for (i = start; i < NSIG; i++)
    if (pending_traps[i])
      return i;
  return -1;
}
warning: parse error {
  register int i;

  for (i = start; i < NSIG; i++)
    if (pending_traps[i])
      return i;
  return -1;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\trap.c:524
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\trap.c:631
parsing error 
{
  if ((sigmodes[sig] & SIG_TRAPPED) == 0)
    set_signal (sig, command);
}
warning: parse error {
  if ((sigmodes[sig] & SIG_TRAPPED) == 0)
    set_signal (sig, command);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\trap.c:634
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\trap.c:640
parsing error 
{
  set_signal (DEBUG_TRAP, command);
}
warning: parse error {
  set_signal (DEBUG_TRAP, command);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\trap.c:642
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\trap.c:653
parsing error 
{
  trap_if_untrapped (DEBUG_TRAP, command);
}
warning: parse error {
  trap_if_untrapped (DEBUG_TRAP, command);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\trap.c:655
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\trap.c:660
parsing error 
{
  set_signal (ERROR_TRAP, command);
}
warning: parse error {
  set_signal (ERROR_TRAP, command);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\trap.c:662
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\trap.c:667
parsing error 
{
  trap_if_untrapped (ERROR_TRAP, command);
}
warning: parse error {
  trap_if_untrapped (ERROR_TRAP, command);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\trap.c:669
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\trap.c:674
parsing error 
{
  set_signal (RETURN_TRAP, command);
}
warning: parse error {
  set_signal (RETURN_TRAP, command);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\trap.c:676
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\trap.c:681
parsing error 
{
  trap_if_untrapped (RETURN_TRAP, command);
}
warning: parse error {
  trap_if_untrapped (RETURN_TRAP, command);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\trap.c:683
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\trap.c:722
parsing error 
{
  if (sigmodes[sig] & (SIG_IGNORED|SIG_HARD_IGNORE))
    return (SIG_IGN);
  else if (sigmodes[sig] & SIG_TRAPPED)
    return (trap_handler);
  else
    return (SIG_DFL);
}
warning: parse error {
  if (sigmodes[sig] & (SIG_IGNORED|SIG_HARD_IGNORE))
    return (SIG_IGN);
  else if (sigmodes[sig] & SIG_TRAPPED)
    return (trap_handler);
  else
    return (SIG_DFL);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\trap.c:724
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\trap.c:735
parsing error 
{
  sigset_t set, oset;

  if (SPECIAL_TRAP (sig))
    {
      change_signal (sig, savestring (string));
      if (sig == EXIT_TRAP && interactive == 0)
	initialize_terminating_signals ();
      return;
    }

  /* A signal ignored on entry to the shell cannot be trapped or reset, but
     no error is reported when attempting to do so.  -- Posix.2 */
  if (sigmodes[sig] & SIG_HARD_IGNORE)
    return;

  /* Make sure we have original_signals[sig] if the signal has not yet
     been trapped. */
  if ((sigmodes[sig] & SIG_TRAPPED) == 0)
    {
      /* If we aren't sure of the original value, check it. */
      if (original_signals[sig] == IMPOSSIBLE_TRAP_HANDLER)
        GETORIGSIG (sig);
      if (original_signals[sig] == SIG_IGN)
	return;
    }

  /* Only change the system signal handler if SIG_NO_TRAP is not set.
     The trap command string is changed in either case.  The shell signal
     handlers for SIGINT and SIGCHLD run the user specified traps in an
     environment in which it is safe to do so. */
  if ((sigmodes[sig] & SIG_NO_TRAP) == 0)
    {
      BLOCK_SIGNAL (sig, set, oset);
      change_signal (sig, savestring (string));
      set_signal_handler (sig, trap_handler);
      UNBLOCK_SIGNAL (oset);
    }
  else
    change_signal (sig, savestring (string));
}
warning: parse error {
  sigset_t set, oset;

  if (SPECIAL_TRAP (sig))
    {
      change_signal (sig, savestring (string));
      if (sig == EXIT_TRAP && interactive == 0)
	initialize_terminating_signals ();
      return;
    }

  /* A signal ignored on entry to the shell cannot be trapped or reset, but
     no error is reported when attempting to do so.  -- Posix.2 */
  if (sigmodes[sig] & SIG_HARD_IGNORE)
    return;

  /* Make sure we have original_signals[sig] if the signal has not yet
     been trapped. */
  if ((sigmodes[sig] & SIG_TRAPPED) == 0)
    {
      /* If we aren't sure of the original value, check it. */
      if (original_signals[sig] == IMPOSSIBLE_TRAP_HANDLER)
        GETORIGSIG (sig);
      if (original_signals[sig] == SIG_IGN)
	return;
    }

  /* Only change the system signal handler if SIG_NO_TRAP is not set.
     The trap command string is changed in either case.  The shell signal
     handlers for SIGINT and SIGCHLD run the user specified traps in an
     environment in which it is safe to do so. */
  if ((sigmodes[sig] & SIG_NO_TRAP) == 0)
    {
      BLOCK_SIGNAL (sig, set, oset);
      change_signal (sig, savestring (string));
      set_signal_handler (sig, trap_handler);
      UNBLOCK_SIGNAL (oset);
    }
  else
    change_signal (sig, savestring (string));
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\trap.c:738
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\trap.c:781
parsing error 
{
  if ((sigmodes[sig] & SIG_TRAPPED) && trap_list[sig] &&
      (trap_list[sig] != (char *)IGNORE_SIG) &&
      (trap_list[sig] != (char *)DEFAULT_SIG) &&
      (trap_list[sig] != (char *)IMPOSSIBLE_TRAP_HANDLER))
    free (trap_list[sig]);
}
warning: parse error {
  if ((sigmodes[sig] & SIG_TRAPPED) && trap_list[sig] &&
      (trap_list[sig] != (char *)IGNORE_SIG) &&
      (trap_list[sig] != (char *)DEFAULT_SIG) &&
      (trap_list[sig] != (char *)IMPOSSIBLE_TRAP_HANDLER))
    free (trap_list[sig]);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\trap.c:783
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\trap.c:794
parsing error 
{
  if ((sigmodes[sig] & SIG_INPROGRESS) == 0)
    free_trap_command (sig);
  trap_list[sig] = value;

  sigmodes[sig] |= SIG_TRAPPED;
  if (value == (char *)IGNORE_SIG)
    sigmodes[sig] |= SIG_IGNORED;
  else
    sigmodes[sig] &= ~SIG_IGNORED;
  if (sigmodes[sig] & SIG_INPROGRESS)
    sigmodes[sig] |= SIG_CHANGED;
}
warning: parse error {
  if ((sigmodes[sig] & SIG_INPROGRESS) == 0)
    free_trap_command (sig);
  trap_list[sig] = value;

  sigmodes[sig] |= SIG_TRAPPED;
  if (value == (char *)IGNORE_SIG)
    sigmodes[sig] |= SIG_IGNORED;
  else
    sigmodes[sig] &= ~SIG_IGNORED;
  if (sigmodes[sig] & SIG_INPROGRESS)
    sigmodes[sig] |= SIG_CHANGED;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\trap.c:797
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\trap.c:812
parsing error 
{
  /* If we aren't sure the of the original value, then get it. */
  if (sig > 0 && sig < NSIG && original_signals[sig] == (SigHandler *)IMPOSSIBLE_TRAP_HANDLER)
    GETORIGSIG (sig);
}
warning: parse error {
  /* If we aren't sure the of the original value, then get it. */
  if (sig > 0 && sig < NSIG && original_signals[sig] == (SigHandler *)IMPOSSIBLE_TRAP_HANDLER)
    GETORIGSIG (sig);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\trap.c:814
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\trap.c:830
parsing error 
{
  if (sig > 0 && sig < NSIG && original_signals[sig] == (SigHandler *)IMPOSSIBLE_TRAP_HANDLER)
    SETORIGSIG (sig, handler);
}
warning: parse error {
  if (sig > 0 && sig < NSIG && original_signals[sig] == (SigHandler *)IMPOSSIBLE_TRAP_HANDLER)
    SETORIGSIG (sig, handler);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\trap.c:833
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\trap.c:843
parsing error 
{
  if (SPECIAL_TRAP (sig))
    {
      if ((sig != DEBUG_TRAP && sig != ERROR_TRAP && sig != RETURN_TRAP) ||
	  (sigmodes[sig] & SIG_INPROGRESS) == 0)
	free_trap_command (sig);
      trap_list[sig] = (char *)NULL;
      sigmodes[sig] &= ~SIG_TRAPPED;
      if (sigmodes[sig] & SIG_INPROGRESS)
	sigmodes[sig] |= SIG_CHANGED;
      return;
    }

  GET_ORIGINAL_SIGNAL (sig);

  /* A signal ignored on entry to the shell cannot be trapped or reset, but
     no error is reported when attempting to do so.  Thanks Posix.2. */
  if (sigmodes[sig] & SIG_HARD_IGNORE)
    return;

  /* If we aren't trapping this signal, don't bother doing anything else. */
  /* We special-case SIGCHLD and IMPOSSIBLE_TRAP_HANDLER (see above) as a
     sentinel to determine whether or not disposition is reset to the default
     while the trap handler is executing. */
  if (((sigmodes[sig] & SIG_TRAPPED) == 0) &&
      (sig != SIGCHLD || (sigmodes[sig] & SIG_INPROGRESS) == 0 || trap_list[sig] != (char *)IMPOSSIBLE_TRAP_HANDLER))
    return;

  /* Only change the signal handler for SIG if it allows it. */
  if ((sigmodes[sig] & SIG_NO_TRAP) == 0)
    set_signal_handler (sig, original_signals[sig]);

  /* Change the trap command in either case. */
  change_signal (sig, (char *)DEFAULT_SIG);

  /* Mark the signal as no longer trapped. */
  sigmodes[sig] &= ~SIG_TRAPPED;
}
warning: parse error {
  if (SPECIAL_TRAP (sig))
    {
      if ((sig != DEBUG_TRAP && sig != ERROR_TRAP && sig != RETURN_TRAP) ||
	  (sigmodes[sig] & SIG_INPROGRESS) == 0)
	free_trap_command (sig);
      trap_list[sig] = (char *)NULL;
      sigmodes[sig] &= ~SIG_TRAPPED;
      if (sigmodes[sig] & SIG_INPROGRESS)
	sigmodes[sig] |= SIG_CHANGED;
      return;
    }

  GET_ORIGINAL_SIGNAL (sig);

  /* A signal ignored on entry to the shell cannot be trapped or reset, but
     no error is reported when attempting to do so.  Thanks Posix.2. */
  if (sigmodes[sig] & SIG_HARD_IGNORE)
    return;

  /* If we aren't trapping this signal, don't bother doing anything else. */
  /* We special-case SIGCHLD and IMPOSSIBLE_TRAP_HANDLER (see above) as a
     sentinel to determine whether or not disposition is reset to the default
     while the trap handler is executing. */
  if (((sigmodes[sig] & SIG_TRAPPED) == 0) &&
      (sig != SIGCHLD || (sigmodes[sig] & SIG_INPROGRESS) == 0 || trap_list[sig] != (char *)IMPOSSIBLE_TRAP_HANDLER))
    return;

  /* Only change the signal handler for SIG if it allows it. */
  if ((sigmodes[sig] & SIG_NO_TRAP) == 0)
    set_signal_handler (sig, original_signals[sig]);

  /* Change the trap command in either case. */
  change_signal (sig, (char *)DEFAULT_SIG);

  /* Mark the signal as no longer trapped. */
  sigmodes[sig] &= ~SIG_TRAPPED;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\trap.c:845
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\trap.c:886
parsing error 
{
  if (SPECIAL_TRAP (sig) && ((sigmodes[sig] & SIG_IGNORED) == 0))
    {
      change_signal (sig, (char *)IGNORE_SIG);
      return;
    }

  GET_ORIGINAL_SIGNAL (sig);

  /* A signal ignored on entry to the shell cannot be trapped or reset.
     No error is reported when the user attempts to do so. */
  if (sigmodes[sig] & SIG_HARD_IGNORE)
    return;

  /* If already trapped and ignored, no change necessary. */
  if (sigmodes[sig] & SIG_IGNORED)
    return;

  /* Only change the signal handler for SIG if it allows it. */
  if ((sigmodes[sig] & SIG_NO_TRAP) == 0)
    set_signal_handler (sig, SIG_IGN);

  /* Change the trap command in either case. */
  change_signal (sig, (char *)IGNORE_SIG);
}
warning: parse error {
  if (SPECIAL_TRAP (sig) && ((sigmodes[sig] & SIG_IGNORED) == 0))
    {
      change_signal (sig, (char *)IGNORE_SIG);
      return;
    }

  GET_ORIGINAL_SIGNAL (sig);

  /* A signal ignored on entry to the shell cannot be trapped or reset.
     No error is reported when the user attempts to do so. */
  if (sigmodes[sig] & SIG_HARD_IGNORE)
    return;

  /* If already trapped and ignored, no change necessary. */
  if (sigmodes[sig] & SIG_IGNORED)
    return;

  /* Only change the signal handler for SIG if it allows it. */
  if ((sigmodes[sig] & SIG_NO_TRAP) == 0)
    set_signal_handler (sig, SIG_IGN);

  /* Change the trap command in either case. */
  change_signal (sig, (char *)IGNORE_SIG);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\trap.c:888
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\trap.c:980
parsing error 
{
  /* XXX - should we clean up trap_list[sig] == IMPOSSIBLE_TRAP_HANDLER? */
  sigmodes[sig] &= ~(SIG_INPROGRESS|SIG_CHANGED);
}
warning: parse error {
  /* XXX - should we clean up trap_list[sig] == IMPOSSIBLE_TRAP_HANDLER? */
  sigmodes[sig] &= ~(SIG_INPROGRESS|SIG_CHANGED);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\trap.c:982
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\trap.c:992
parsing error 
{
  char *trap_command, *old_trap;
  int trap_exit_value;
  volatile int save_return_catch_flag, function_code;
  int old_modes, old_running, old_int;
  int flags;
  procenv_t save_return_catch;
  WORD_LIST *save_subst_varlist;
  HASH_TABLE *save_tempenv;
  sh_parser_state_t pstate;
#if defined (ARRAY_VARS)
  ARRAY *ps;
#endif

  old_modes = old_running = -1;

  trap_exit_value = function_code = 0;
  trap_saved_exit_value = last_command_exit_value;
  /* Run the trap only if SIG is trapped and not ignored, and we are not
     currently executing in the trap handler. */
  if ((sigmodes[sig] & SIG_TRAPPED) && ((sigmodes[sig] & SIG_IGNORED) == 0) &&
      (trap_list[sig] != (char *)IMPOSSIBLE_TRAP_HANDLER) &&
#if 1
      /* Uncomment this to allow some special signals to recursively execute
	 trap handlers. */
      (RECURSIVE_SIG (sig) || (sigmodes[sig] & SIG_INPROGRESS) == 0))
#else
      ((sigmodes[sig] & SIG_INPROGRESS) == 0))
#endif
    {
      old_trap = trap_list[sig];
      old_modes = sigmodes[sig];
      old_running = running_trap;

      sigmodes[sig] |= SIG_INPROGRESS;
      sigmodes[sig] &= ~SIG_CHANGED;		/* just to be sure */
      trap_command =  savestring (old_trap);

      running_trap = sig + 1;

      old_int = interrupt_state;	/* temporarily suppress pending interrupts */
      CLRINTERRUPT;

#if defined (ARRAY_VARS)
      ps = save_pipestatus_array ();
#endif

      save_parser_state (&pstate);
      save_subst_varlist = subst_assign_varlist;
      subst_assign_varlist = 0;
      save_tempenv = temporary_env;
      temporary_env = 0;	/* traps should not run with temporary env */

#if defined (JOB_CONTROL)
      if (sig != DEBUG_TRAP)	/* run_debug_trap does this */
	save_pipeline (1);	/* XXX only provides one save level */
#endif

      /* If we're in a function, make sure return longjmps come here, too. */
      save_return_catch_flag = return_catch_flag;
      if (return_catch_flag)
	{
	  COPY_PROCENV (return_catch, save_return_catch);
	  function_code = setjmp_nosigs (return_catch);
	}

      flags = SEVAL_NONINT|SEVAL_NOHIST;
      if (sig != DEBUG_TRAP && sig != RETURN_TRAP && sig != ERROR_TRAP)
	flags |= SEVAL_RESETLINE;
      evalnest++;
      if (function_code == 0)
        {
	  parse_and_execute (trap_command, tag, flags);
	  trap_exit_value = last_command_exit_value;
        }
      else
        trap_exit_value = return_catch_value;
      evalnest--;

#if defined (JOB_CONTROL)
      if (sig != DEBUG_TRAP)	/* run_debug_trap does this */
	restore_pipeline (1);
#endif

      subst_assign_varlist = save_subst_varlist;
      restore_parser_state (&pstate);

#if defined (ARRAY_VARS)
      restore_pipestatus_array (ps);
#endif

      temporary_env = save_tempenv;

      if ((old_modes & SIG_INPROGRESS) == 0)
	sigmodes[sig] &= ~SIG_INPROGRESS;

      running_trap = old_running;
      interrupt_state = old_int;

      if (sigmodes[sig] & SIG_CHANGED)
	{
#if 0
	  /* Special traps like EXIT, DEBUG, RETURN are handled explicitly in
	     the places where they can be changed using unwind-protects.  For
	     example, look at execute_cmd.c:execute_function(). */
	  if (SPECIAL_TRAP (sig) == 0)
#endif
	    free (old_trap);
	  sigmodes[sig] &= ~SIG_CHANGED;

	  CHECK_TERMSIG;	/* some pathological conditions lead here */
	}

      if (save_return_catch_flag)
	{
	  return_catch_flag = save_return_catch_flag;
	  return_catch_value = trap_exit_value;
	  COPY_PROCENV (save_return_catch, return_catch);
	  if (function_code)
	    {
#if 0
	      from_return_trap = sig == RETURN_TRAP;
#endif
	      sh_longjmp (return_catch, 1);
	    }
	}
    }

  return trap_exit_value;
}
warning: parse error {
  char *trap_command, *old_trap;
  int trap_exit_value;
  volatile int save_return_catch_flag, function_code;
  int old_modes, old_running, old_int;
  int flags;
  procenv_t save_return_catch;
  WORD_LIST *save_subst_varlist;
  HASH_TABLE *save_tempenv;
  sh_parser_state_t pstate;
#if defined (ARRAY_VARS)
  ARRAY *ps;
#endif

  old_modes = old_running = -1;

  trap_exit_value = function_code = 0;
  trap_saved_exit_value = last_command_exit_value;
  /* Run the trap only if SIG is trapped and not ignored, and we are not
     currently executing in the trap handler. */
  if ((sigmodes[sig] & SIG_TRAPPED) && ((sigmodes[sig] & SIG_IGNORED) == 0) &&
      (trap_list[sig] != (char *)IMPOSSIBLE_TRAP_HANDLER) &&
#if 1
      /* Uncomment this to allow some special signals to recursively execute
	 trap handlers. */
      (RECURSIVE_SIG (sig) || (sigmodes[sig] & SIG_INPROGRESS) == 0))
#else
      ((sigmodes[sig] & SIG_INPROGRESS) == 0))
#endif
    {
      old_trap = trap_list[sig];
      old_modes = sigmodes[sig];
      old_running = running_trap;

      sigmodes[sig] |= SIG_INPROGRESS;
      sigmodes[sig] &= ~SIG_CHANGED;		/* just to be sure */
      trap_command =  savestring (old_trap);

      running_trap = sig + 1;

      old_int = interrupt_state;	/* temporarily suppress pending interrupts */
      CLRINTERRUPT;

#if defined (ARRAY_VARS)
      ps = save_pipestatus_array ();
#endif

      save_parser_state (&pstate);
      save_subst_varlist = subst_assign_varlist;
      subst_assign_varlist = 0;
      save_tempenv = temporary_env;
      temporary_env = 0;	/* traps should not run with temporary env */

#if defined (JOB_CONTROL)
      if (sig != DEBUG_TRAP)	/* run_debug_trap does this */
	save_pipeline (1);	/* XXX only provides one save level */
#endif

      /* If we're in a function, make sure return longjmps come here, too. */
      save_return_catch_flag = return_catch_flag;
      if (return_catch_flag)
	{
	  COPY_PROCENV (return_catch, save_return_catch);
	  function_code = setjmp_nosigs (return_catch);
	}

      flags = SEVAL_NONINT|SEVAL_NOHIST;
      if (sig != DEBUG_TRAP && sig != RETURN_TRAP && sig != ERROR_TRAP)
	flags |= SEVAL_RESETLINE;
      evalnest++;
      if (function_code == 0)
        {
	  parse_and_execute (trap_command, tag, flags);
	  trap_exit_value = last_command_exit_value;
        }
      else
        trap_exit_value = return_catch_value;
      evalnest--;

#if defined (JOB_CONTROL)
      if (sig != DEBUG_TRAP)	/* run_debug_trap does this */
	restore_pipeline (1);
#endif

      subst_assign_varlist = save_subst_varlist;
      restore_parser_state (&pstate);

#if defined (ARRAY_VARS)
      restore_pipestatus_array (ps);
#endif

      temporary_env = save_tempenv;

      if ((old_modes & SIG_INPROGRESS) == 0)
	sigmodes[sig] &= ~SIG_INPROGRESS;

      running_trap = old_running;
      interrupt_state = old_int;

      if (sigmodes[sig] & SIG_CHANGED)
	{
#if 0
	  /* Special traps like EXIT, DEBUG, RETURN are handled explicitly in
	     the places where they can be changed using unwind-protects.  For
	     example, look at execute_cmd.c:execute_function(). */
	  if (SPECIAL_TRAP (sig) == 0)
#endif
	    free (old_trap);
	  sigmodes[sig] &= ~SIG_CHANGED;

	  CHECK_TERMSIG;	/* some pathological conditions lead here */
	}

      if (save_return_catch_flag)
	{
	  return_catch_flag = save_return_catch_flag;
	  return_catch_value = trap_exit_value;
	  COPY_PROCENV (save_return_catch, return_catch);
	  if (function_code)
	    {
#if 0
	      from_return_trap = sig == RETURN_TRAP;
#endif
	      sh_longjmp (return_catch, 1);
	    }
	}
    }

  return trap_exit_value;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\trap.c:995
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\trap.c:1,210
parsing error 
{
  if (will_throw && running_trap > 0)
    run_trap_cleanup (running_trap - 1);
  pending_traps[SIGINT] = 0;	/* run_pending_traps does this */
  catch_flag = 0;
  _run_trap_internal (SIGINT, "interrupt trap");
}
warning: parse error {
  if (will_throw && running_trap > 0)
    run_trap_cleanup (running_trap - 1);
  pending_traps[SIGINT] = 0;	/* run_pending_traps does this */
  catch_flag = 0;
  _run_trap_internal (SIGINT, "interrupt trap");
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\trap.c:1,212
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\trap.c:1,251
parsing error 
{
  change_signal (sig, (char *)DEFAULT_SIG);
  sigmodes[sig] &= ~SIG_TRAPPED;		/* XXX - SIG_INPROGRESS? */
}
warning: parse error {
  change_signal (sig, (char *)DEFAULT_SIG);
  sigmodes[sig] &= ~SIG_TRAPPED;		/* XXX - SIG_INPROGRESS? */
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\trap.c:1,253
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\trap.c:1,261
parsing error 
{
  set_signal_handler (sig, original_signals[sig]);
  sigmodes[sig] &= ~SIG_TRAPPED;		/* XXX - SIG_INPROGRESS? */
}
warning: parse error {
  set_signal_handler (sig, original_signals[sig]);
  sigmodes[sig] &= ~SIG_TRAPPED;		/* XXX - SIG_INPROGRESS? */
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\trap.c:1,263
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\trap.c:1,271
parsing error 
{
  set_signal_handler (sig, original_signals[sig]);
  change_signal (sig, (char *)DEFAULT_SIG);
  sigmodes[sig] &= ~SIG_TRAPPED;
}
warning: parse error {
  set_signal_handler (sig, original_signals[sig]);
  change_signal (sig, (char *)DEFAULT_SIG);
  sigmodes[sig] &= ~SIG_TRAPPED;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\trap.c:1,273
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\trap.c:1,280
parsing error 
{
  register int i;

  /* Take care of the exit trap first */
  if (sigmodes[EXIT_TRAP] & SIG_TRAPPED)
    {
      sigmodes[EXIT_TRAP] &= ~SIG_TRAPPED;	/* XXX - SIG_INPROGRESS? */
      if (reset != reset_signal)
	{
	  free_trap_command (EXIT_TRAP);
	  trap_list[EXIT_TRAP] = (char *)NULL;
	}
    }

  for (i = 1; i < NSIG; i++)
    {
      if (sigmodes[i] & SIG_TRAPPED)
	{
	  if (trap_list[i] == (char *)IGNORE_SIG)
	    set_signal_handler (i, SIG_IGN);
	  else
	    (*reset) (i);
	}
      else if (sigmodes[i] & SIG_SPECIAL)
	(*reset) (i);
      pending_traps[i] = 0;	/* XXX */
    }

  /* Command substitution and other child processes don't inherit the
     debug, error, or return traps.  If we're in the debugger, and the
     `functrace' or `errtrace' options have been set, then let command
     substitutions inherit them.  Let command substitution inherit the
     RETURN trap if we're in the debugger and tracing functions. */
  if (function_trace_mode == 0)
    {
      sigmodes[DEBUG_TRAP] &= ~SIG_TRAPPED;
      sigmodes[RETURN_TRAP] &= ~SIG_TRAPPED;
    }
  if (error_trace_mode == 0)
    sigmodes[ERROR_TRAP] &= ~SIG_TRAPPED;
}
warning: parse error {
  register int i;

  /* Take care of the exit trap first */
  if (sigmodes[EXIT_TRAP] & SIG_TRAPPED)
    {
      sigmodes[EXIT_TRAP] &= ~SIG_TRAPPED;	/* XXX - SIG_INPROGRESS? */
      if (reset != reset_signal)
	{
	  free_trap_command (EXIT_TRAP);
	  trap_list[EXIT_TRAP] = (char *)NULL;
	}
    }

  for (i = 1; i < NSIG; i++)
    {
      if (sigmodes[i] & SIG_TRAPPED)
	{
	  if (trap_list[i] == (char *)IGNORE_SIG)
	    set_signal_handler (i, SIG_IGN);
	  else
	    (*reset) (i);
	}
      else if (sigmodes[i] & SIG_SPECIAL)
	(*reset) (i);
      pending_traps[i] = 0;	/* XXX */
    }

  /* Command substitution and other child processes don't inherit the
     debug, error, or return traps.  If we're in the debugger, and the
     `functrace' or `errtrace' options have been set, then let command
     substitutions inherit them.  Let command substitution inherit the
     RETURN trap if we're in the debugger and tracing functions. */
  if (function_trace_mode == 0)
    {
      sigmodes[DEBUG_TRAP] &= ~SIG_TRAPPED;
      sigmodes[RETURN_TRAP] &= ~SIG_TRAPPED;
    }
  if (error_trace_mode == 0)
    sigmodes[ERROR_TRAP] &= ~SIG_TRAPPED;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\trap.c:1,282
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\trap.c:1,345
parsing error 
{
  /* Call the trap handler for SIG if the signal is trapped and not ignored. */
  if ((sigmodes[sig] & SIG_TRAPPED) && ((sigmodes[sig] & SIG_IGNORED) == 0))
    {
      switch (sig)
	{
	case SIGINT:
	  run_interrupt_trap (0);
	  break;
	case EXIT_TRAP:
	  run_exit_trap ();
	  break;
	case DEBUG_TRAP:
	  run_debug_trap ();
	  break;
	case ERROR_TRAP:
	  run_error_trap ();
	  break;
	default:
	  trap_handler (sig);
	  break;
	}
      return (1);
    }
  else
    return (0);
}
warning: parse error {
  /* Call the trap handler for SIG if the signal is trapped and not ignored. */
  if ((sigmodes[sig] & SIG_TRAPPED) && ((sigmodes[sig] & SIG_IGNORED) == 0))
    {
      switch (sig)
	{
	case SIGINT:
	  run_interrupt_trap (0);
	  break;
	case EXIT_TRAP:
	  run_exit_trap ();
	  break;
	case DEBUG_TRAP:
	  run_debug_trap ();
	  break;
	case ERROR_TRAP:
	  run_error_trap ();
	  break;
	default:
	  trap_handler (sig);
	  break;
	}
      return (1);
    }
  else
    return (0);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\trap.c:1,347
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\trap.c:1,376
parsing error 
{
  return (sigmodes[sig] & SIG_TRAPPED);
}
warning: parse error {
  return (sigmodes[sig] & SIG_TRAPPED);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\trap.c:1,378
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\trap.c:1,383
parsing error 
{
  return (pending_traps[sig]);
}
warning: parse error {
  return (pending_traps[sig]);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\trap.c:1,385
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\trap.c:1,390
parsing error 
{
  return (sigmodes[sig] & SIG_SPECIAL);
}
warning: parse error {
  return (sigmodes[sig] & SIG_SPECIAL);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\trap.c:1,392
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\trap.c:1,397
parsing error 
{
  return (sigmodes[sig] & SIG_IGNORED);
}
warning: parse error {
  return (sigmodes[sig] & SIG_IGNORED);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\trap.c:1,399
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\trap.c:1,404
parsing error 
{
  return (sigmodes[sig] & SIG_HARD_IGNORE);
}
warning: parse error {
  return (sigmodes[sig] & SIG_HARD_IGNORE);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\trap.c:1,406
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\trap.c:1,411
parsing error 
{
  sigmodes[sig] |= SIG_HARD_IGNORE;
  original_signals[sig] = SIG_IGN;
}
warning: parse error {
  sigmodes[sig] |= SIG_HARD_IGNORE;
  original_signals[sig] = SIG_IGN;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\trap.c:1,413
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\trap.c:1,419
parsing error 
{
  original_signals[sig] = SIG_IGN;
}
warning: parse error {
  original_signals[sig] = SIG_IGN;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\trap.c:1,421
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\trap.c:1,426
parsing error 
{
  return (sigmodes[sig] & SIG_INPROGRESS);
}
warning: parse error {
  return (sigmodes[sig] & SIG_INPROGRESS);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\trap.c:1,428
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\unwind_prot.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashtypes.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashansi.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\command.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\general.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\unwind_prot.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\sig.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\quit.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\error.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\ocache.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\unwind_prot.c:113
parsing error 
{
  (*function)(arg1, arg2);
}
warning: parse error {
  (*function)(arg1, arg2);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\unwind_prot.c:116
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\unwind_prot.c:122
parsing error 
{
  add_unwind_protect ((Function *)NULL, tag);
}
warning: parse error {
  add_unwind_protect ((Function *)NULL, tag);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\unwind_prot.c:124
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\unwind_prot.c:130
parsing error 
{
  if (unwind_protect_list)
    without_interrupts (unwind_frame_discard_internal, tag, (char *)NULL);
}
warning: parse error {
  if (unwind_protect_list)
    without_interrupts (unwind_frame_discard_internal, tag, (char *)NULL);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\unwind_prot.c:132
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\unwind_prot.c:139
parsing error 
{
  if (unwind_protect_list)
    without_interrupts (unwind_frame_run_internal, tag, (char *)NULL);
}
warning: parse error {
  if (unwind_protect_list)
    without_interrupts (unwind_frame_run_internal, tag, (char *)NULL);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\unwind_prot.c:141
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\unwind_prot.c:148
parsing error 
{
  without_interrupts (add_unwind_protect_internal, (char *)cleanup, arg);
}
warning: parse error {
  without_interrupts (add_unwind_protect_internal, (char *)cleanup, arg);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\unwind_prot.c:151
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\unwind_prot.c:175
parsing error 
{
  char *flag;

  if (unwind_protect_list)
    {
      flag = flags ? "" : (char *)NULL;
      without_interrupts
        (clear_unwind_protects_internal, flag, (char *)NULL);
    }
}
warning: parse error {
  char *flag;

  if (unwind_protect_list)
    {
      flag = flags ? "" : (char *)NULL;
      without_interrupts
        (clear_unwind_protects_internal, flag, (char *)NULL);
    }
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\unwind_prot.c:177
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\unwind_prot.c:196
parsing error 
{
  UNWIND_ELT *elt;

  elt = unwind_protect_list;
  while (elt)
    {
      if (elt->head.cleanup == 0 && STREQ (elt->arg.v, tag))
	return 1;
      elt = elt->head.next;
    }
  return 0;
}
warning: parse error {
  UNWIND_ELT *elt;

  elt = unwind_protect_list;
  while (elt)
    {
      if (elt->head.cleanup == 0 && STREQ (elt->arg.v, tag))
	return 1;
      elt = elt->head.next;
    }
  return 0;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\unwind_prot.c:197
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\unwind_prot.c:217
parsing error 
{
  UNWIND_ELT *elt;

  uwpalloc (elt);
  elt->head.next = unwind_protect_list;
  elt->head.cleanup = cleanup;
  elt->arg.v = arg;
  unwind_protect_list = elt;
}
warning: parse error {
  UNWIND_ELT *elt;

  uwpalloc (elt);
  elt->head.next = unwind_protect_list;
  elt->head.cleanup = cleanup;
  elt->arg.v = arg;
  unwind_protect_list = elt;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\unwind_prot.c:220
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\unwind_prot.c:231
parsing error 
{
  UNWIND_ELT *elt;

  elt = unwind_protect_list;
  if (elt)
    {
      unwind_protect_list = unwind_protect_list->head.next;
      uwpfree (elt);
    }
}
warning: parse error {
  UNWIND_ELT *elt;

  elt = unwind_protect_list;
  if (elt)
    {
      unwind_protect_list = unwind_protect_list->head.next;
      uwpfree (elt);
    }
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\unwind_prot.c:233
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\unwind_prot.c:245
parsing error 
{
  unwind_frame_run_internal ((char *) NULL, (char *) NULL);
}
warning: parse error {
  unwind_frame_run_internal ((char *) NULL, (char *) NULL);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\unwind_prot.c:247
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\unwind_prot.c:252
parsing error 
{
  if (flag)
    {
      while (unwind_protect_list)
	remove_unwind_protect_internal ((char *)NULL, (char *)NULL);
    }
  unwind_protect_list = (UNWIND_ELT *)NULL;
}
warning: parse error {
  if (flag)
    {
      while (unwind_protect_list)
	remove_unwind_protect_internal ((char *)NULL, (char *)NULL);
    }
  unwind_protect_list = (UNWIND_ELT *)NULL;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\unwind_prot.c:254
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\unwind_prot.c:264
parsing error 
{
  UNWIND_ELT *elt;
  int found;

  found = 0;
  while (elt = unwind_protect_list)
    {
      unwind_protect_list = unwind_protect_list->head.next;
      if (elt->head.cleanup == 0 && (STREQ (elt->arg.v, tag)))
	{
	  uwpfree (elt);
	  found = 1;
	  break;
	}
      else
	uwpfree (elt);
    }

  if (found == 0)
    internal_warning ("unwind_frame_discard: %s: frame not found", tag);
}
warning: parse error {
  UNWIND_ELT *elt;
  int found;

  found = 0;
  while (elt = unwind_protect_list)
    {
      unwind_protect_list = unwind_protect_list->head.next;
      if (elt->head.cleanup == 0 && (STREQ (elt->arg.v, tag)))
	{
	  uwpfree (elt);
	  found = 1;
	  break;
	}
      else
	uwpfree (elt);
    }

  if (found == 0)
    internal_warning ("unwind_frame_discard: %s: frame not found", tag);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\unwind_prot.c:266
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\unwind_prot.c:292
parsing error 
{
  FASTCOPY (sv->desired_setting, sv->variable, sv->size);
}
warning: parse error {
  FASTCOPY (sv->desired_setting, sv->variable, sv->size);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\unwind_prot.c:294
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\unwind_prot.c:299
parsing error 
{
  UNWIND_ELT *elt;
  int found;

  found = 0;
  while (elt = unwind_protect_list)
    {
      unwind_protect_list = elt->head.next;

      /* If tag, then compare. */
      if (elt->head.cleanup == 0)
	{
	  if (tag && STREQ (elt->arg.v, tag))
	    {
	      uwpfree (elt);
	      found = 1;
	      break;
	    }
	}
      else
	{
	  if (elt->head.cleanup == (Function *) restore_variable)
	    restore_variable (&elt->sv.v);
	  else
	    (*(elt->head.cleanup)) (elt->arg.v);
	}

      uwpfree (elt);
    }
  if (tag && found == 0)
    internal_warning ("unwind_frame_run: %s: frame not found", tag);
}
warning: parse error {
  UNWIND_ELT *elt;
  int found;

  found = 0;
  while (elt = unwind_protect_list)
    {
      unwind_protect_list = elt->head.next;

      /* If tag, then compare. */
      if (elt->head.cleanup == 0)
	{
	  if (tag && STREQ (elt->arg.v, tag))
	    {
	      uwpfree (elt);
	      found = 1;
	      break;
	    }
	}
      else
	{
	  if (elt->head.cleanup == (Function *) restore_variable)
	    restore_variable (&elt->sv.v);
	  else
	    (*(elt->head.cleanup)) (elt->arg.v);
	}

      uwpfree (elt);
    }
  if (tag && found == 0)
    internal_warning ("unwind_frame_run: %s: frame not found", tag);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\unwind_prot.c:301
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\unwind_prot.c:335
parsing error 
{
  int size, allocated;
  UNWIND_ELT *elt;

  size = *(int *) psize;
  allocated = size + offsetof (UNWIND_ELT, sv.v.desired_setting[0]);
  if (allocated < sizeof (UNWIND_ELT))
    allocated = sizeof (UNWIND_ELT);
  elt = (UNWIND_ELT *)xmalloc (allocated);
  elt->head.next = unwind_protect_list;
  elt->head.cleanup = (Function *) restore_variable;
  elt->sv.v.variable = var;
  elt->sv.v.size = size;
  FASTCOPY (var, elt->sv.v.desired_setting, size);
  unwind_protect_list = elt;
}
warning: parse error {
  int size, allocated;
  UNWIND_ELT *elt;

  size = *(int *) psize;
  allocated = size + offsetof (UNWIND_ELT, sv.v.desired_setting[0]);
  if (allocated < sizeof (UNWIND_ELT))
    allocated = sizeof (UNWIND_ELT);
  elt = (UNWIND_ELT *)xmalloc (allocated);
  elt->head.next = unwind_protect_list;
  elt->head.cleanup = (Function *) restore_variable;
  elt->sv.v.variable = var;
  elt->sv.v.size = size;
  FASTCOPY (var, elt->sv.v.desired_setting, size);
  unwind_protect_list = elt;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\unwind_prot.c:338
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\unwind_prot.c:359
parsing error 
{
  without_interrupts (unwind_protect_mem_internal, var, (char *) &size);
}
warning: parse error {
  without_interrupts (unwind_protect_mem_internal, var, (char *) &size);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\unwind_prot.c:362
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashtypes.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\posixstat.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\posixtime.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\chartypes.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashansi.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashintl.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\filecntl.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\shell.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\parser.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\flags.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\execute_cmd.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\findcmd.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\mailcheck.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\input.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\hashcmd.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\pathexp.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\alias.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\jobs.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\getopt.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\common.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:346
parsing error 
{
  char *name, *string, *temp_string;
  int c, char_index, string_index, string_length, ro;
  SHELL_VAR *temp_var;

  create_variable_tables ();

  for (string_index = 0; env && (string = env[string_index++]); )
    {
      char_index = 0;
      name = string;
      while ((c = *string++) && c != '=')
	;
      if (string[-1] == '=')
	char_index = string - name - 1;

      /* If there are weird things in the environment, like `=xxx' or a
	 string without an `=', just skip them. */
      if (char_index == 0)
	continue;

      /* ASSERT(name[char_index] == '=') */
      name[char_index] = '\0';
      /* Now, name = env variable name, string = env variable value, and
	 char_index == strlen (name) */

      temp_var = (SHELL_VAR *)NULL;

#if defined (FUNCTION_IMPORT)
      /* If exported function, define it now.  Don't import functions from
	 the environment in privileged mode. */
      if (privmode == 0 && read_but_dont_execute == 0 && 
          STREQN (BASHFUNC_PREFIX, name, BASHFUNC_PREFLEN) &&
          STREQ (BASHFUNC_SUFFIX, name + char_index - BASHFUNC_SUFFLEN) &&
	  STREQN ("() {", string, 4))
	{
	  size_t namelen;
	  char *tname;		/* desired imported function name */

	  namelen = char_index - BASHFUNC_PREFLEN - BASHFUNC_SUFFLEN;

	  tname = name + BASHFUNC_PREFLEN;	/* start of func name */
	  tname[namelen] = '\0';		/* now tname == func name */

	  string_length = strlen (string);
	  temp_string = (char *)xmalloc (namelen + string_length + 2);

	  memcpy (temp_string, tname, namelen);
	  temp_string[namelen] = ' ';
	  memcpy (temp_string + namelen + 1, string, string_length + 1);

	  /* Don't import function names that are invalid identifiers from the
	     environment in posix mode, though we still allow them to be defined as
	     shell variables. */
	  if (absolute_program (tname) == 0 && (posixly_correct == 0 || legal_identifier (tname)))
	    parse_and_execute (temp_string, tname, SEVAL_NONINT|SEVAL_NOHIST|SEVAL_FUNCDEF|SEVAL_ONECMD);
	  else
	    free (temp_string);		/* parse_and_execute does this */

	  if (temp_var = find_function (tname))
	    {
	      VSETATTR (temp_var, (att_exported|att_imported));
	      array_needs_making = 1;
	    }
	  else
	    {
	      if (temp_var = bind_invalid_envvar (name, string, 0))
		{
		  VSETATTR (temp_var, (att_exported | att_imported | att_invisible));
		  array_needs_making = 1;
		}
	      last_command_exit_value = EXECUTION_FAILURE;
	      report_error (_("error importing function definition for `%s'"), tname);
	    }

	  /* Restore original suffix */
	  tname[namelen] = BASHFUNC_SUFFIX[0];
	}
      else
#endif /* FUNCTION_IMPORT */
#if defined (ARRAY_VARS)
#  if ARRAY_EXPORT
      /* Array variables may not yet be exported. */
      if (*string == '(' && string[1] == '[' && string[strlen (string) - 1] == ')')
	{
	  string_length = 1;
	  temp_string = extract_array_assignment_list (string, &string_length);
	  temp_var = assign_array_from_string (name, temp_string, 0);
	  FREE (temp_string);
	  VSETATTR (temp_var, (att_exported | att_imported));
	  array_needs_making = 1;
	}
      else
#  endif /* ARRAY_EXPORT */
#endif
	{
	  ro = 0;
	  /* If we processed a command-line option that caused SHELLOPTS to be
	     set, it may already be set (and read-only) by the time we process
	     the shell's environment. */
	  if (/* posixly_correct &&*/ STREQ (name, "SHELLOPTS"))
	    {
	      temp_var = find_variable ("SHELLOPTS");
	      ro = temp_var && readonly_p (temp_var);
	      if (temp_var)
		VUNSETATTR (temp_var, att_readonly);
	    }
	  if (legal_identifier (name))
	    {
	      temp_var = bind_variable (name, string, 0);
	      if (temp_var)
		{
		  VSETATTR (temp_var, (att_exported | att_imported));
		  if (ro)
		    VSETATTR (temp_var, att_readonly);
		}
	    }
	  else
	    {
	      temp_var = bind_invalid_envvar (name, string, 0);
	      if (temp_var)
		VSETATTR (temp_var, (att_exported | att_imported | att_invisible));
	    }
	  if (temp_var)
	    array_needs_making = 1;
	}

      name[char_index] = '=';
      /* temp_var can be NULL if it was an exported function with a syntax
	 error (a different bug, but it still shouldn't dump core). */
      if (temp_var && function_p (temp_var) == 0)	/* XXX not yet */
	{
	  CACHE_IMPORTSTR (temp_var, name);
	}
    }

  set_pwd ();

  /* Set up initial value of $_ */
  temp_var = set_if_not ("_", dollar_vars[0]);

  /* Remember this pid. */
  dollar_dollar_pid = getpid ();

  /* Now make our own defaults in case the vars that we think are
     important are missing. */
  temp_var = set_if_not ("PATH", DEFAULT_PATH_VALUE);
  temp_var = set_if_not ("TERM", "dumb");

#if defined (__QNX__)
  /* set node id -- don't import it from the environment */
  {
    char node_name[22];
#  if defined (__QNXNTO__)
    netmgr_ndtostr(ND2S_LOCAL_STR, ND_LOCAL_NODE, node_name, sizeof(node_name));
#  else
    qnx_nidtostr (getnid (), node_name, sizeof (node_name));
#  endif
    temp_var = bind_variable ("NODE", node_name, 0);
    if (temp_var)
      set_auto_export (temp_var);
  }
#endif

  /* set up the prompts. */
  if (interactive_shell)
    {
#if defined (PROMPT_STRING_DECODE)
      set_if_not ("PS1", primary_prompt);
#else
      if (current_user.uid == -1)
	get_current_user_info ();
      set_if_not ("PS1", current_user.euid == 0 ? "# " : primary_prompt);
#endif
      set_if_not ("PS2", secondary_prompt);
    }

  if (current_user.euid == 0)
    bind_variable ("PS4", "+ ", 0);
  else
    set_if_not ("PS4", "+ ");

  /* Don't allow IFS to be imported from the environment. */
  temp_var = bind_variable ("IFS", " \t\n", 0);
  setifs (temp_var);

  /* Magic machine types.  Pretty convenient. */
  set_machine_vars ();

  /* Default MAILCHECK for interactive shells.  Defer the creation of a
     default MAILPATH until the startup files are read, because MAIL
     names a mail file if MAILPATH is not set, and we should provide a
     default only if neither is set. */
  if (interactive_shell)
    {
      temp_var = set_if_not ("MAILCHECK", posixly_correct ? "600" : "60");
      VSETATTR (temp_var, att_integer);
    }

  /* Do some things with shell level. */
  initialize_shell_level ();

  set_ppid ();

  set_argv0 ();

  /* Initialize the `getopts' stuff. */
  temp_var = bind_variable ("OPTIND", "1", 0);
  VSETATTR (temp_var, att_integer);
  getopts_reset (0);
  bind_variable ("OPTERR", "1", 0);
  sh_opterr = 1;

  if (login_shell == 1 && posixly_correct == 0)
    set_home_var ();

  /* Get the full pathname to THIS shell, and set the BASH variable
     to it. */
  name = get_bash_name ();
  temp_var = bind_variable ("BASH", name, 0);
  free (name);

  /* Make the exported environment variable SHELL be the user's login
     shell.  Note that the `tset' command looks at this variable
     to determine what style of commands to output; if it ends in "csh",
     then C-shell commands are output, else Bourne shell commands. */
  set_shell_var ();

  /* Make a variable called BASH_VERSION which contains the version info. */
  bind_variable ("BASH_VERSION", shell_version_string (), 0);
#if defined (ARRAY_VARS)
  make_vers_array ();
#endif

  if (command_execution_string)
    bind_variable ("BASH_EXECUTION_STRING", command_execution_string, 0);

  /* Find out if we're supposed to be in Posix.2 mode via an
     environment variable. */
  temp_var = find_variable ("POSIXLY_CORRECT");
  if (!temp_var)
    temp_var = find_variable ("POSIX_PEDANTIC");
  if (temp_var && imported_p (temp_var))
    sv_strict_posix (temp_var->name);

#if defined (HISTORY)
  /* Set history variables to defaults, and then do whatever we would
     do if the variable had just been set.  Do this only in the case
     that we are remembering commands on the history list. */
  if (remember_on_history)
    {
      name = bash_tilde_expand (posixly_correct ? "~/.sh_history" : "~/.bash_history", 0);

      set_if_not ("HISTFILE", name);
      free (name);
    }
#endif /* HISTORY */

  /* Seed the random number generators. */
  seedrand ();
  seedrand32 ();

  /* Handle some "special" variables that we may have inherited from a
     parent shell. */
  if (interactive_shell)
    {
      temp_var = find_variable ("IGNOREEOF");
      if (!temp_var)
	temp_var = find_variable ("ignoreeof");
      if (temp_var && imported_p (temp_var))
	sv_ignoreeof (temp_var->name);
    }

#if defined (HISTORY)
  if (interactive_shell && remember_on_history)
    {
      sv_history_control ("HISTCONTROL");
      sv_histignore ("HISTIGNORE");
      sv_histtimefmt ("HISTTIMEFORMAT");
    }
#endif /* HISTORY */

#if defined (READLINE) && defined (STRICT_POSIX)
  /* POSIXLY_CORRECT will be 1 here if the shell was compiled
     -DSTRICT_POSIX or if POSIXLY_CORRECT was supplied in the shell's
     environment */
  if (interactive_shell && posixly_correct && no_line_editing == 0)
    rl_prefer_env_winsize = 1;
#endif /* READLINE && STRICT_POSIX */

     /*
      * 24 October 2001
      *
      * I'm tired of the arguing and bug reports.  Bash now leaves SSH_CLIENT
      * and SSH2_CLIENT alone.  I'm going to rely on the shell_level check in
      * isnetconn() to avoid running the startup files more often than wanted.
      * That will, of course, only work if the user's login shell is bash, so
      * I've made that behavior conditional on SSH_SOURCE_BASHRC being defined
      * in config-top.h.
      */
#if 0
  temp_var = find_variable ("SSH_CLIENT");
  if (temp_var && imported_p (temp_var))
    {
      VUNSETATTR (temp_var, att_exported);
      array_needs_making = 1;
    }
  temp_var = find_variable ("SSH2_CLIENT");
  if (temp_var && imported_p (temp_var))
    {
      VUNSETATTR (temp_var, att_exported);
      array_needs_making = 1;
    }
#endif

  /* Get the user's real and effective user ids. */
  uidset ();

  temp_var = find_variable ("BASH_XTRACEFD");
  if (temp_var && imported_p (temp_var))
    sv_xtracefd (temp_var->name);

  sv_shcompat ("BASH_COMPAT");

  /* Allow FUNCNEST to be inherited from the environment. */
  sv_funcnest ("FUNCNEST");

  /* Initialize the dynamic variables, and seed their values. */
  initialize_dynamic_variables ();
}
warning: parse error {
  char *name, *string, *temp_string;
  int c, char_index, string_index, string_length, ro;
  SHELL_VAR *temp_var;

  create_variable_tables ();

  for (string_index = 0; env && (string = env[string_index++]); )
    {
      char_index = 0;
      name = string;
      while ((c = *string++) && c != '=')
	;
      if (string[-1] == '=')
	char_index = string - name - 1;

      /* If there are weird things in the environment, like `=xxx' or a
	 string without an `=', just skip them. */
      if (char_index == 0)
	continue;

      /* ASSERT(name[char_index] == '=') */
      name[char_index] = '\0';
      /* Now, name = env variable name, string = env variable value, and
	 char_index == strlen (name) */

      temp_var = (SHELL_VAR *)NULL;

#if defined (FUNCTION_IMPORT)
      /* If exported function, define it now.  Don't import functions from
	 the environment in privileged mode. */
      if (privmode == 0 && read_but_dont_execute == 0 && 
          STREQN (BASHFUNC_PREFIX, name, BASHFUNC_PREFLEN) &&
          STREQ (BASHFUNC_SUFFIX, name + char_index - BASHFUNC_SUFFLEN) &&
	  STREQN ("() {", string, 4))
	{
	  size_t namelen;
	  char *tname;		/* desired imported function name */

	  namelen = char_index - BASHFUNC_PREFLEN - BASHFUNC_SUFFLEN;

	  tname = name + BASHFUNC_PREFLEN;	/* start of func name */
	  tname[namelen] = '\0';		/* now tname == func name */

	  string_length = strlen (string);
	  temp_string = (char *)xmalloc (namelen + string_length + 2);

	  memcpy (temp_string, tname, namelen);
	  temp_string[namelen] = ' ';
	  memcpy (temp_string + namelen + 1, string, string_length + 1);

	  /* Don't import function names that are invalid identifiers from the
	     environment in posix mode, though we still allow them to be defined as
	     shell variables. */
	  if (absolute_program (tname) == 0 && (posixly_correct == 0 || legal_identifier (tname)))
	    parse_and_execute (temp_string, tname, SEVAL_NONINT|SEVAL_NOHIST|SEVAL_FUNCDEF|SEVAL_ONECMD);
	  else
	    free (temp_string);		/* parse_and_execute does this */

	  if (temp_var = find_function (tname))
	    {
	      VSETATTR (temp_var, (att_exported|att_imported));
	      array_needs_making = 1;
	    }
	  else
	    {
	      if (temp_var = bind_invalid_envvar (name, string, 0))
		{
		  VSETATTR (temp_var, (att_exported | att_imported | att_invisible));
		  array_needs_making = 1;
		}
	      last_command_exit_value = EXECUTION_FAILURE;
	      report_error (_("error importing function definition for `%s'"), tname);
	    }

	  /* Restore original suffix */
	  tname[namelen] = BASHFUNC_SUFFIX[0];
	}
      else
#endif /* FUNCTION_IMPORT */
#if defined (ARRAY_VARS)
#  if ARRAY_EXPORT
      /* Array variables may not yet be exported. */
      if (*string == '(' && string[1] == '[' && string[strlen (string) - 1] == ')')
	{
	  string_length = 1;
	  temp_string = extract_array_assignment_list (string, &string_length);
	  temp_var = assign_array_from_string (name, temp_string, 0);
	  FREE (temp_string);
	  VSETATTR (temp_var, (att_exported | att_imported));
	  array_needs_making = 1;
	}
      else
#  endif /* ARRAY_EXPORT */
#endif
	{
	  ro = 0;
	  /* If we processed a command-line option that caused SHELLOPTS to be
	     set, it may already be set (and read-only) by the time we process
	     the shell's environment. */
	  if (/* posixly_correct &&*/ STREQ (name, "SHELLOPTS"))
	    {
	      temp_var = find_variable ("SHELLOPTS");
	      ro = temp_var && readonly_p (temp_var);
	      if (temp_var)
		VUNSETATTR (temp_var, att_readonly);
	    }
	  if (legal_identifier (name))
	    {
	      temp_var = bind_variable (name, string, 0);
	      if (temp_var)
		{
		  VSETATTR (temp_var, (att_exported | att_imported));
		  if (ro)
		    VSETATTR (temp_var, att_readonly);
		}
	    }
	  else
	    {
	      temp_var = bind_invalid_envvar (name, string, 0);
	      if (temp_var)
		VSETATTR (temp_var, (att_exported | att_imported | att_invisible));
	    }
	  if (temp_var)
	    array_needs_making = 1;
	}

      name[char_index] = '=';
      /* temp_var can be NULL if it was an exported function with a syntax
	 error (a different bug, but it still shouldn't dump core). */
      if (temp_var && function_p (temp_var) == 0)	/* XXX not yet */
	{
	  CACHE_IMPORTSTR (temp_var, name);
	}
    }

  set_pwd ();

  /* Set up initial value of $_ */
  temp_var = set_if_not ("_", dollar_vars[0]);

  /* Remember this pid. */
  dollar_dollar_pid = getpid ();

  /* Now make our own defaults in case the vars that we think are
     important are missing. */
  temp_var = set_if_not ("PATH", DEFAULT_PATH_VALUE);
  temp_var = set_if_not ("TERM", "dumb");

#if defined (__QNX__)
  /* set node id -- don't import it from the environment */
  {
    char node_name[22];
#  if defined (__QNXNTO__)
    netmgr_ndtostr(ND2S_LOCAL_STR, ND_LOCAL_NODE, node_name, sizeof(node_name));
#  else
    qnx_nidtostr (getnid (), node_name, sizeof (node_name));
#  endif
    temp_var = bind_variable ("NODE", node_name, 0);
    if (temp_var)
      set_auto_export (temp_var);
  }
#endif

  /* set up the prompts. */
  if (interactive_shell)
    {
#if defined (PROMPT_STRING_DECODE)
      set_if_not ("PS1", primary_prompt);
#else
      if (current_user.uid == -1)
	get_current_user_info ();
      set_if_not ("PS1", current_user.euid == 0 ? "# " : primary_prompt);
#endif
      set_if_not ("PS2", secondary_prompt);
    }

  if (current_user.euid == 0)
    bind_variable ("PS4", "+ ", 0);
  else
    set_if_not ("PS4", "+ ");

  /* Don't allow IFS to be imported from the environment. */
  temp_var = bind_variable ("IFS", " \t\n", 0);
  setifs (temp_var);

  /* Magic machine types.  Pretty convenient. */
  set_machine_vars ();

  /* Default MAILCHECK for interactive shells.  Defer the creation of a
     default MAILPATH until the startup files are read, because MAIL
     names a mail file if MAILPATH is not set, and we should provide a
     default only if neither is set. */
  if (interactive_shell)
    {
      temp_var = set_if_not ("MAILCHECK", posixly_correct ? "600" : "60");
      VSETATTR (temp_var, att_integer);
    }

  /* Do some things with shell level. */
  initialize_shell_level ();

  set_ppid ();

  set_argv0 ();

  /* Initialize the `getopts' stuff. */
  temp_var = bind_variable ("OPTIND", "1", 0);
  VSETATTR (temp_var, att_integer);
  getopts_reset (0);
  bind_variable ("OPTERR", "1", 0);
  sh_opterr = 1;

  if (login_shell == 1 && posixly_correct == 0)
    set_home_var ();

  /* Get the full pathname to THIS shell, and set the BASH variable
     to it. */
  name = get_bash_name ();
  temp_var = bind_variable ("BASH", name, 0);
  free (name);

  /* Make the exported environment variable SHELL be the user's login
     shell.  Note that the `tset' command looks at this variable
     to determine what style of commands to output; if it ends in "csh",
     then C-shell commands are output, else Bourne shell commands. */
  set_shell_var ();

  /* Make a variable called BASH_VERSION which contains the version info. */
  bind_variable ("BASH_VERSION", shell_version_string (), 0);
#if defined (ARRAY_VARS)
  make_vers_array ();
#endif

  if (command_execution_string)
    bind_variable ("BASH_EXECUTION_STRING", command_execution_string, 0);

  /* Find out if we're supposed to be in Posix.2 mode via an
     environment variable. */
  temp_var = find_variable ("POSIXLY_CORRECT");
  if (!temp_var)
    temp_var = find_variable ("POSIX_PEDANTIC");
  if (temp_var && imported_p (temp_var))
    sv_strict_posix (temp_var->name);

#if defined (HISTORY)
  /* Set history variables to defaults, and then do whatever we would
     do if the variable had just been set.  Do this only in the case
     that we are remembering commands on the history list. */
  if (remember_on_history)
    {
      name = bash_tilde_expand (posixly_correct ? "~/.sh_history" : "~/.bash_history", 0);

      set_if_not ("HISTFILE", name);
      free (name);
    }
#endif /* HISTORY */

  /* Seed the random number generators. */
  seedrand ();
  seedrand32 ();

  /* Handle some "special" variables that we may have inherited from a
     parent shell. */
  if (interactive_shell)
    {
      temp_var = find_variable ("IGNOREEOF");
      if (!temp_var)
	temp_var = find_variable ("ignoreeof");
      if (temp_var && imported_p (temp_var))
	sv_ignoreeof (temp_var->name);
    }

#if defined (HISTORY)
  if (interactive_shell && remember_on_history)
    {
      sv_history_control ("HISTCONTROL");
      sv_histignore ("HISTIGNORE");
      sv_histtimefmt ("HISTTIMEFORMAT");
    }
#endif /* HISTORY */

#if defined (READLINE) && defined (STRICT_POSIX)
  /* POSIXLY_CORRECT will be 1 here if the shell was compiled
     -DSTRICT_POSIX or if POSIXLY_CORRECT was supplied in the shell's
     environment */
  if (interactive_shell && posixly_correct && no_line_editing == 0)
    rl_prefer_env_winsize = 1;
#endif /* READLINE && STRICT_POSIX */

     /*
      * 24 October 2001
      *
      * I'm tired of the arguing and bug reports.  Bash now leaves SSH_CLIENT
      * and SSH2_CLIENT alone.  I'm going to rely on the shell_level check in
      * isnetconn() to avoid running the startup files more often than wanted.
      * That will, of course, only work if the user's login shell is bash, so
      * I've made that behavior conditional on SSH_SOURCE_BASHRC being defined
      * in config-top.h.
      */
#if 0
  temp_var = find_variable ("SSH_CLIENT");
  if (temp_var && imported_p (temp_var))
    {
      VUNSETATTR (temp_var, att_exported);
      array_needs_making = 1;
    }
  temp_var = find_variable ("SSH2_CLIENT");
  if (temp_var && imported_p (temp_var))
    {
      VUNSETATTR (temp_var, att_exported);
      array_needs_making = 1;
    }
#endif

  /* Get the user's real and effective user ids. */
  uidset ();

  temp_var = find_variable ("BASH_XTRACEFD");
  if (temp_var && imported_p (temp_var))
    sv_xtracefd (temp_var->name);

  sv_shcompat ("BASH_COMPAT");

  /* Allow FUNCNEST to be inherited from the environment. */
  sv_funcnest ("FUNCNEST");

  /* Initialize the dynamic variables, and seed their values. */
  initialize_dynamic_variables ();
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:349
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:817
parsing error 
{
  char new_level[5], *old_SHLVL;
  intmax_t old_level;
  SHELL_VAR *temp_var;

  old_SHLVL = get_string_value ("SHLVL");
  if (old_SHLVL == 0 || *old_SHLVL == '\0' || legal_number (old_SHLVL, &old_level) == 0)
    old_level = 0;

  shell_level = old_level + change;
  if (shell_level < 0)
    shell_level = 0;
  else if (shell_level >= 1000)
    {
      internal_warning (_("shell level (%d) too high, resetting to 1"), shell_level);
      shell_level = 1;
    }

  /* We don't need the full generality of itos here. */
  if (shell_level < 10)
    {
      new_level[0] = shell_level + '0';
      new_level[1] = '\0';
    }
  else if (shell_level < 100)
    {
      new_level[0] = (shell_level / 10) + '0';
      new_level[1] = (shell_level % 10) + '0';
      new_level[2] = '\0';
    }
  else if (shell_level < 1000)
    {
      new_level[0] = (shell_level / 100) + '0';
      old_level = shell_level % 100;
      new_level[1] = (old_level / 10) + '0';
      new_level[2] = (old_level % 10) + '0';
      new_level[3] = '\0';
    }

  temp_var = bind_variable ("SHLVL", new_level, 0);
  set_auto_export (temp_var);
}
warning: parse error {
  char new_level[5], *old_SHLVL;
  intmax_t old_level;
  SHELL_VAR *temp_var;

  old_SHLVL = get_string_value ("SHLVL");
  if (old_SHLVL == 0 || *old_SHLVL == '\0' || legal_number (old_SHLVL, &old_level) == 0)
    old_level = 0;

  shell_level = old_level + change;
  if (shell_level < 0)
    shell_level = 0;
  else if (shell_level >= 1000)
    {
      internal_warning (_("shell level (%d) too high, resetting to 1"), shell_level);
      shell_level = 1;
    }

  /* We don't need the full generality of itos here. */
  if (shell_level < 10)
    {
      new_level[0] = shell_level + '0';
      new_level[1] = '\0';
    }
  else if (shell_level < 100)
    {
      new_level[0] = (shell_level / 10) + '0';
      new_level[1] = (shell_level % 10) + '0';
      new_level[2] = '\0';
    }
  else if (shell_level < 1000)
    {
      new_level[0] = (shell_level / 100) + '0';
      old_level = shell_level % 100;
      new_level[1] = (old_level / 10) + '0';
      new_level[2] = (old_level % 10) + '0';
      new_level[3] = '\0';
    }

  temp_var = bind_variable ("SHLVL", new_level, 0);
  set_auto_export (temp_var);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:819
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:1,009
parsing error 
{
  char val[INT_STRLEN_BOUND(int) + 1], *v;

#if defined (READLINE)
  /* If we are currently assigning to LINES or COLUMNS, don't do anything. */
  if (winsize_assignment)
    return;
#endif

  v = inttostr (lines, val, sizeof (val));
  bind_variable ("LINES", v, 0);

  v = inttostr (cols, val, sizeof (val));
  bind_variable ("COLUMNS", v, 0);
}
warning: parse error {
  char val[INT_STRLEN_BOUND(int) + 1], *v;

#if defined (READLINE)
  /* If we are currently assigning to LINES or COLUMNS, don't do anything. */
  if (winsize_assignment)
    return;
#endif

  v = inttostr (lines, val, sizeof (val));
  bind_variable ("LINES", v, 0);

  v = inttostr (cols, val, sizeof (val));
  bind_variable ("COLUMNS", v, 0);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:1,011
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:1,036
parsing error 
{
  register int i;
  register SHELL_VAR *var;

  for (i = 0; list && (var = list[i]); i++)
    if (invisible_p (var) == 0)
      print_assignment (var);
}
warning: parse error {
  register int i;
  register SHELL_VAR *var;

  for (i = 0; list && (var = list[i]); i++)
    if (invisible_p (var) == 0)
      print_assignment (var);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:1,038
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:1,050
parsing error 
{
  register int i;
  register SHELL_VAR *var;

  for (i = 0; list && (var = list[i]); i++)
    {
      printf ("%s ", var->name);
      print_var_function (var);
      printf ("\n");
    }
}
warning: parse error {
  register int i;
  register SHELL_VAR *var;

  for (i = 0; list && (var = list[i]); i++)
    {
      printf ("%s ", var->name);
      print_var_function (var);
      printf ("\n");
    }
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:1,052
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:1,068
parsing error 
{
  if (var_isset (var) == 0)
    return;

  if (function_p (var))
    {
      printf ("%s", var->name);
      print_var_function (var);
      printf ("\n");
    }
#if defined (ARRAY_VARS)
  else if (array_p (var))
    print_array_assignment (var, 0);
  else if (assoc_p (var))
    print_assoc_assignment (var, 0);
#endif /* ARRAY_VARS */
  else
    {
      printf ("%s=", var->name);
      print_var_value (var, 1);
      printf ("\n");
    }
}
warning: parse error {
  if (var_isset (var) == 0)
    return;

  if (function_p (var))
    {
      printf ("%s", var->name);
      print_var_function (var);
      printf ("\n");
    }
#if defined (ARRAY_VARS)
  else if (array_p (var))
    print_array_assignment (var, 0);
  else if (assoc_p (var))
    print_assoc_assignment (var, 0);
#endif /* ARRAY_VARS */
  else
    {
      printf ("%s=", var->name);
      print_var_value (var, 1);
      printf ("\n");
    }
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:1,070
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:1,099
parsing error 
{
  char *t;

  if (var_isset (var) == 0)
    return;

  if (quote && posixly_correct == 0 && ansic_shouldquote (value_cell (var)))
    {
      t = ansic_quote (value_cell (var), 0, (int *)0);
      printf ("%s", t);
      free (t);
    }
  else if (quote && sh_contains_shell_metas (value_cell (var)))
    {
      t = sh_single_quote (value_cell (var));
      printf ("%s", t);
      free (t);
    }
  else
    printf ("%s", value_cell (var));
}
warning: parse error {
  char *t;

  if (var_isset (var) == 0)
    return;

  if (quote && posixly_correct == 0 && ansic_shouldquote (value_cell (var)))
    {
      t = ansic_quote (value_cell (var), 0, (int *)0);
      printf ("%s", t);
      free (t);
    }
  else if (quote && sh_contains_shell_metas (value_cell (var)))
    {
      t = sh_single_quote (value_cell (var));
      printf ("%s", t);
      free (t);
    }
  else
    printf ("%s", value_cell (var));
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:1,102
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:1,127
parsing error 
{
  char *x;

  if (function_p (var) && var_isset (var))
    {
      x = named_function_string ((char *)NULL, function_cell(var), FUNC_MULTILINE|FUNC_EXTERNAL);
      printf ("%s", x);
    }
}
warning: parse error {
  char *x;

  if (function_p (var) && var_isset (var))
    {
      x = named_function_string ((char *)NULL, function_cell(var), FUNC_MULTILINE|FUNC_EXTERNAL);
      printf ("%s", x);
    }
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:1,129
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:1,206
parsing error 
{
  return (self);
}
warning: parse error {
  return (self);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:1,211
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:1,230
parsing error 
{
  return (self);
}
warning: parse error {
  return (self);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:1,232
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:1,282
parsing error 
{
  intmax_t nval;
  int expok;

  if (integer_p (self))
    nval = evalexp (value, 0, &expok);
  else
    expok = legal_number (value, &nval);
  seconds_value_assigned = expok ? nval : 0;
  gettimeofday (&shellstart, NULL);
  shell_start_time = shellstart.tv_sec;
  return (self);
}
warning: parse error {
  intmax_t nval;
  int expok;

  if (integer_p (self))
    nval = evalexp (value, 0, &expok);
  else
    expok = legal_number (value, &nval);
  seconds_value_assigned = expok ? nval : 0;
  gettimeofday (&shellstart, NULL);
  shell_start_time = shellstart.tv_sec;
  return (self);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:1,287
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:1,302
parsing error 
{
  time_t time_since_start;
  char *p;
  struct timeval tv;

  gettimeofday(&tv, NULL);
  time_since_start = tv.tv_sec - shell_start_time;
  p = itos(seconds_value_assigned + time_since_start);

  FREE (value_cell (var));

  VSETATTR (var, att_integer);
  var_setvalue (var, p);
  return (var);
}
warning: parse error {
  time_t time_since_start;
  char *p;
  struct timeval tv;

  gettimeofday(&tv, NULL);
  time_since_start = tv.tv_sec - shell_start_time;
  p = itos(seconds_value_assigned + time_since_start);

  FREE (value_cell (var));

  VSETATTR (var, att_integer);
  var_setvalue (var, p);
  return (var);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:1,304
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:1,341
parsing error 
{
  intmax_t seedval;
  int expok;

  if (integer_p (self))
    seedval = evalexp (value, 0, &expok);
  else
    expok = legal_number (value, &seedval);
  if (expok == 0)
    return (self);
  sbrand (seedval);
  if (subshell_environment)
    seeded_subshell = getpid ();
  return (self);
}
warning: parse error {
  intmax_t seedval;
  int expok;

  if (integer_p (self))
    seedval = evalexp (value, 0, &expok);
  else
    expok = legal_number (value, &seedval);
  if (expok == 0)
    return (self);
  sbrand (seedval);
  if (subshell_environment)
    seeded_subshell = getpid ();
  return (self);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:1,346
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:1,383
parsing error 
{
  int rv;
  char *p;

  rv = get_random_number ();
  p = itos (rv);

  FREE (value_cell (var));

  VSETATTR (var, att_integer);
  var_setvalue (var, p);
  return (var);
}
warning: parse error {
  int rv;
  char *p;

  rv = get_random_number ();
  p = itos (rv);

  FREE (value_cell (var));

  VSETATTR (var, att_integer);
  var_setvalue (var, p);
  return (var);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:1,385
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:1,400
parsing error 
{
  u_bits32_t rv;
  char *p;

  rv = get_urandom32 ();
  p = itos (rv);

  FREE (value_cell (var));

  VSETATTR (var, att_integer);
  var_setvalue (var, p);
  return (var);
}
warning: parse error {
  u_bits32_t rv;
  char *p;

  rv = get_urandom32 ();
  p = itos (rv);

  FREE (value_cell (var));

  VSETATTR (var, att_integer);
  var_setvalue (var, p);
  return (var);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:1,402
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:1,417
parsing error 
{
  intmax_t new_value;

  if (value == 0 || *value == '\0' || legal_number (value, &new_value) == 0)
    new_value = 0;
  line_number = line_number_base = new_value;
  return var;
}
warning: parse error {
  intmax_t new_value;

  if (value == 0 || *value == '\0' || legal_number (value, &new_value) == 0)
    new_value = 0;
  line_number = line_number_base = new_value;
  return var;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:1,422
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:1,433
parsing error 
{
  char *p;
  int ln;

  ln = executing_line_number ();
  p = itos (ln);
  FREE (value_cell (var));
  var_setvalue (var, p);
  return (var);
}
warning: parse error {
  char *p;
  int ln;

  ln = executing_line_number ();
  p = itos (ln);
  FREE (value_cell (var));
  var_setvalue (var, p);
  return (var);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:1,435
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:1,447
parsing error 
{
  intmax_t new_value;

  if (value == 0 || *value == '\0' || legal_number (value, &new_value) == 0)
    new_value = 0;
  subshell_level = new_value;
  return var;
}
warning: parse error {
  intmax_t new_value;

  if (value == 0 || *value == '\0' || legal_number (value, &new_value) == 0)
    new_value = 0;
  subshell_level = new_value;
  return var;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:1,452
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:1,462
parsing error 
{
  char *p;

  p = itos (subshell_level);
  FREE (value_cell (var));
  var_setvalue (var, p);
  return (var);
}
warning: parse error {
  char *p;

  p = itos (subshell_level);
  FREE (value_cell (var));
  var_setvalue (var, p);
  return (var);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:1,464
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:1,474
parsing error 
{
  intmax_t now;
  char *p;

  now = NOW;
  p = itos (now);

  FREE (value_cell (var));
  var_setvalue (var, p);
  return (var);
}
warning: parse error {
  intmax_t now;
  char *p;

  now = NOW;
  p = itos (now);

  FREE (value_cell (var));
  var_setvalue (var, p);
  return (var);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:1,476
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:1,489
parsing error 
{
  char buf[32];
  char *p;
  struct timeval tv;

  gettimeofday (&tv, NULL);
  snprintf (buf, sizeof (buf), "%u%c%06u", (unsigned)tv.tv_sec,
					   locale_decpoint (),
					   (unsigned)tv.tv_usec);

  p = savestring (buf);
  FREE (value_cell (var));
  var_setvalue (var, p);
  return (var);
}
warning: parse error {
  char buf[32];
  char *p;
  struct timeval tv;

  gettimeofday (&tv, NULL);
  snprintf (buf, sizeof (buf), "%u%c%06u", (unsigned)tv.tv_sec,
					   locale_decpoint (),
					   (unsigned)tv.tv_usec);

  p = savestring (buf);
  FREE (value_cell (var));
  var_setvalue (var, p);
  return (var);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:1,491
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:1,508
parsing error 
{
  int pid;
  char *p;

  pid = getpid ();
  p = itos (pid);

  FREE (value_cell (var));
  VSETATTR (var, att_integer);	/* XXX - was also att_readonly */
  var_setvalue (var, p);
  return (var);
}
warning: parse error {
  int pid;
  char *p;

  pid = getpid ();
  p = itos (pid);

  FREE (value_cell (var));
  VSETATTR (var, att_integer);	/* XXX - was also att_readonly */
  var_setvalue (var, p);
  return (var);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:1,510
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:1,524
parsing error 
{
  char *p;

  p = savestring (dollar_vars[0]);
  FREE (value_cell (var));
  var_setvalue (var, p);
  return var;
}
warning: parse error {
  char *p;

  p = savestring (dollar_vars[0]);
  FREE (value_cell (var));
  var_setvalue (var, p);
  return var;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:1,526
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:1,538
parsing error 
{
  size_t vlen;

  if (value == 0)
    return var;

  FREE (dollar_vars[0]);
  dollar_vars[0] = savestring (value);

  /* Need these gyrations because shell_name isn't dynamically allocated */
  vlen = STRLEN (value);
  static_shell_name = xrealloc (static_shell_name, vlen + 1);
  strcpy (static_shell_name, value);
  
  shell_name = static_shell_name;
  return var;
}
warning: parse error {
  size_t vlen;

  if (value == 0)
    return var;

  FREE (dollar_vars[0]);
  dollar_vars[0] = savestring (value);

  /* Need these gyrations because shell_name isn't dynamically allocated */
  vlen = STRLEN (value);
  static_shell_name = xrealloc (static_shell_name, vlen + 1);
  strcpy (static_shell_name, value);
  
  shell_name = static_shell_name;
  return var;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:1,543
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:1,572
parsing error 
{
  char *p;

  if (the_printed_command_except_trap)
    p = savestring (the_printed_command_except_trap);
  else
    {
      p = (char *)xmalloc (1);
      p[0] = '\0';
    }
  FREE (value_cell (var));
  var_setvalue (var, p);
  return (var);
}
warning: parse error {
  char *p;

  if (the_printed_command_except_trap)
    p = savestring (the_printed_command_except_trap);
  else
    {
      p = (char *)xmalloc (1);
      p[0] = '\0';
    }
  FREE (value_cell (var));
  var_setvalue (var, p);
  return (var);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:1,574
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:1,857
parsing error 
{
#if ! defined (ARRAY_VARS)
  char *t;
  if (variable_context && this_shell_function)
    {
      FREE (value_cell (self));
      t = savestring (this_shell_function->name);
      var_setvalue (self, t);
    }
#endif
  return (self);
}
warning: parse error {
#if ! defined (ARRAY_VARS)
  char *t;
  if (variable_context && this_shell_function)
    {
      FREE (value_cell (self));
      t = savestring (this_shell_function->name);
      var_setvalue (self, t);
    }
#endif
  return (self);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:1,859
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:1,873
parsing error 
{
  SHELL_VAR *v;

  v = find_variable ("FUNCNAME");
  if (v == 0 || v->dynamic_value == 0)
    return;

  if (on_or_off)
    VUNSETATTR (v, att_invisible);
  else
    VSETATTR (v, att_invisible);
}
warning: parse error {
  SHELL_VAR *v;

  v = find_variable ("FUNCNAME");
  if (v == 0 || v->dynamic_value == 0)
    return;

  if (on_or_off)
    VUNSETATTR (v, att_invisible);
  else
    VSETATTR (v, att_invisible);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:1,875
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:1,992
parsing error 
{
  BUCKET_CONTENTS *bucket;

  bucket = hash_search (name, hashed_vars, 0);
  /* If we find the name in HASHED_VARS, set LAST_TABLE_SEARCHED to that
     table. */
  if (bucket)
    last_table_searched = hashed_vars;
  return (bucket ? (SHELL_VAR *)bucket->data : (SHELL_VAR *)NULL);
}
warning: parse error {
  BUCKET_CONTENTS *bucket;

  bucket = hash_search (name, hashed_vars, 0);
  /* If we find the name in HASHED_VARS, set LAST_TABLE_SEARCHED to that
     table. */
  if (bucket)
    last_table_searched = hashed_vars;
  return (bucket ? (SHELL_VAR *)bucket->data : (SHELL_VAR *)NULL);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:1,994
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:2,007
parsing error 
{
  VAR_CONTEXT *vc;
  SHELL_VAR *v;

  v = (SHELL_VAR *)NULL;
  for (vc = vcontext; vc; vc = vc->down)
    if (v = hash_lookup (name, vc->table))
      break;

  return v;
}
warning: parse error {
  VAR_CONTEXT *vc;
  SHELL_VAR *v;

  v = (SHELL_VAR *)NULL;
  for (vc = vcontext; vc; vc = vc->down)
    if (v = hash_lookup (name, vc->table))
      break;

  return v;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:2,009
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:2,030
parsing error 
{
  SHELL_VAR *var;
  int search_tempenv, force_tempenv;
  VAR_CONTEXT *vc;

  var = (SHELL_VAR *)NULL;

  force_tempenv = (flags & FV_FORCETEMPENV);

  /* If explicitly requested, first look in the temporary environment for
     the variable.  This allows constructs such as "foo=x eval 'echo $foo'"
     to get the `exported' value of $foo.  This happens if we are executing
     a function or builtin, or if we are looking up a variable in a
     "subshell environment". */
  search_tempenv = force_tempenv || (expanding_redir == 0 && subshell_environment);

  if (search_tempenv && temporary_env)		
    var = hash_lookup (name, temporary_env);

  if (var == 0)
    {
      if ((flags & FV_SKIPINVISIBLE) == 0)
	var = var_lookup (name, shell_variables);
      else
	{
	  /* essentially var_lookup expanded inline so we can check for
	     att_invisible */
	  for (vc = shell_variables; vc; vc = vc->down)
	    {
	      var = hash_lookup (name, vc->table);
	      if (var && invisible_p (var))
		var = 0;
	      if (var)
		break;
	    }
	}
    }

  if (var == 0)
    return ((SHELL_VAR *)NULL);

  return (var->dynamic_value ? (*(var->dynamic_value)) (var) : var);
}
warning: parse error {
  SHELL_VAR *var;
  int search_tempenv, force_tempenv;
  VAR_CONTEXT *vc;

  var = (SHELL_VAR *)NULL;

  force_tempenv = (flags & FV_FORCETEMPENV);

  /* If explicitly requested, first look in the temporary environment for
     the variable.  This allows constructs such as "foo=x eval 'echo $foo'"
     to get the `exported' value of $foo.  This happens if we are executing
     a function or builtin, or if we are looking up a variable in a
     "subshell environment". */
  search_tempenv = force_tempenv || (expanding_redir == 0 && subshell_environment);

  if (search_tempenv && temporary_env)		
    var = hash_lookup (name, temporary_env);

  if (var == 0)
    {
      if ((flags & FV_SKIPINVISIBLE) == 0)
	var = var_lookup (name, shell_variables);
      else
	{
	  /* essentially var_lookup expanded inline so we can check for
	     att_invisible */
	  for (vc = shell_variables; vc; vc = vc->down)
	    {
	      var = hash_lookup (name, vc->table);
	      if (var && invisible_p (var))
		var = 0;
	      if (var)
		break;
	    }
	}
    }

  if (var == 0)
    return ((SHELL_VAR *)NULL);

  return (var->dynamic_value ? (*(var->dynamic_value)) (var) : var);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:2,032
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:2,079
parsing error 
{
  int level, flags;
  char *newname;
  SHELL_VAR *orig, *oldv;

  level = 0;
  orig = v;
  while (v && nameref_p (v))
    {
      level++;
      if (level > NAMEREF_MAX)
	return ((SHELL_VAR *)0);	/* error message here? */
      newname = nameref_cell (v);
      if (newname == 0 || *newname == '\0')
	return ((SHELL_VAR *)0);
      oldv = v;
      flags = 0;
      if (expanding_redir == 0 && (assigning_in_environment || executing_builtin))
	flags |= FV_FORCETEMPENV;
      /* We don't handle array subscripts here. */
      v = find_variable_internal (newname, flags);
      if (v == orig || v == oldv)
	{
	  internal_warning (_("%s: circular name reference"), orig->name);
#if 1
	  /* XXX - provisional change - circular refs go to
	     global scope for resolution, without namerefs. */
	  if (variable_context && v->context)
	    return (find_global_variable_noref (v->name));
	  else
#endif
	  return ((SHELL_VAR *)0);
	}
    }
  return v;
}
warning: parse error {
  int level, flags;
  char *newname;
  SHELL_VAR *orig, *oldv;

  level = 0;
  orig = v;
  while (v && nameref_p (v))
    {
      level++;
      if (level > NAMEREF_MAX)
	return ((SHELL_VAR *)0);	/* error message here? */
      newname = nameref_cell (v);
      if (newname == 0 || *newname == '\0')
	return ((SHELL_VAR *)0);
      oldv = v;
      flags = 0;
      if (expanding_redir == 0 && (assigning_in_environment || executing_builtin))
	flags |= FV_FORCETEMPENV;
      /* We don't handle array subscripts here. */
      v = find_variable_internal (newname, flags);
      if (v == orig || v == oldv)
	{
	  internal_warning (_("%s: circular name reference"), orig->name);
#if 1
	  /* XXX - provisional change - circular refs go to
	     global scope for resolution, without namerefs. */
	  if (variable_context && v->context)
	    return (find_global_variable_noref (v->name));
	  else
#endif
	  return ((SHELL_VAR *)0);
	}
    }
  return v;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:2,081
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:2,121
parsing error 
{
  SHELL_VAR *v, *nv;
  char *newname;
  int level, flags;

  nv = v = find_variable_noref (name);
  level = 0;
  while (v && nameref_p (v))
    {
      level++;
      if (level > NAMEREF_MAX)
        return ((SHELL_VAR *)0);	/* error message here? */
      newname = nameref_cell (v);
      if (newname == 0 || *newname == '\0')
	return ((vflags && invisible_p (v)) ? v : (SHELL_VAR *)0);
      nv = v;
      flags = 0;
      if (expanding_redir == 0 && (assigning_in_environment || executing_builtin))
	flags |= FV_FORCETEMPENV;
      /* We don't accommodate array subscripts here. */
      v = find_variable_internal (newname, flags);
    }
  return nv;
}
warning: parse error {
  SHELL_VAR *v, *nv;
  char *newname;
  int level, flags;

  nv = v = find_variable_noref (name);
  level = 0;
  while (v && nameref_p (v))
    {
      level++;
      if (level > NAMEREF_MAX)
        return ((SHELL_VAR *)0);	/* error message here? */
      newname = nameref_cell (v);
      if (newname == 0 || *newname == '\0')
	return ((vflags && invisible_p (v)) ? v : (SHELL_VAR *)0);
      nv = v;
      flags = 0;
      if (expanding_redir == 0 && (assigning_in_environment || executing_builtin))
	flags |= FV_FORCETEMPENV;
      /* We don't accommodate array subscripts here. */
      v = find_variable_internal (newname, flags);
    }
  return nv;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:2,123
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:2,151
parsing error 
{
  SHELL_VAR *v, *nv;
  char *newname;
  int level;

  nv = v = find_global_variable_noref (name);
  level = 0;
  while (v && nameref_p (v))
    {
      level++;
      if (level > NAMEREF_MAX)
        return ((SHELL_VAR *)0);	/* error message here? */
      newname = nameref_cell (v);
      if (newname == 0 || *newname == '\0')
	return ((vflags && invisible_p (v)) ? v : (SHELL_VAR *)0);
      nv = v;
      /* We don't accommodate array subscripts here. */
      v = find_global_variable_noref (newname);
    }
  return nv;
}
warning: parse error {
  SHELL_VAR *v, *nv;
  char *newname;
  int level;

  nv = v = find_global_variable_noref (name);
  level = 0;
  while (v && nameref_p (v))
    {
      level++;
      if (level > NAMEREF_MAX)
        return ((SHELL_VAR *)0);	/* error message here? */
      newname = nameref_cell (v);
      if (newname == 0 || *newname == '\0')
	return ((vflags && invisible_p (v)) ? v : (SHELL_VAR *)0);
      nv = v;
      /* We don't accommodate array subscripts here. */
      v = find_global_variable_noref (newname);
    }
  return nv;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:2,153
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:2,176
parsing error 
{
  SHELL_VAR *nv, *nv2;
  char *newname;
  int level;

  nv = v;
  level = 1;
  while (nv && nameref_p (nv))
    {
      level++;
      if (level > NAMEREF_MAX)
        return (&nameref_maxloop_value);
      newname = nameref_cell (nv);
      if (newname == 0 || *newname == '\0')
        return ((SHELL_VAR *)NULL);      
      nv2 = hash_lookup (newname, vc->table);
      if (nv2 == 0)
        break;
      nv = nv2;
    }
  return nv;
}
warning: parse error {
  SHELL_VAR *nv, *nv2;
  char *newname;
  int level;

  nv = v;
  level = 1;
  while (nv && nameref_p (nv))
    {
      level++;
      if (level > NAMEREF_MAX)
        return (&nameref_maxloop_value);
      newname = nameref_cell (nv);
      if (newname == 0 || *newname == '\0')
        return ((SHELL_VAR *)NULL);      
      nv2 = hash_lookup (newname, vc->table);
      if (nv2 == 0)
        break;
      nv = nv2;
    }
  return nv;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:2,179
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:2,208
parsing error 
{
  SHELL_VAR *nv, *nv2;
  VAR_CONTEXT *nvc;

  /* Look starting at the current context all the way `up' */
  for (nv = v, nvc = vc; nvc; nvc = nvc->down)
    {
      nv2 = find_nameref_at_context (nv, nvc);
      if (nv2 == &nameref_maxloop_value)
	return (nv2);			/* XXX */
      if (nv2 == 0)
        continue;
      nv = nv2;
      if (*nvcp)
        *nvcp = nvc;
      if (nameref_p (nv) == 0)
        break;
    }
  return (nameref_p (nv) ? (SHELL_VAR *)NULL : nv);
}
warning: parse error {
  SHELL_VAR *nv, *nv2;
  VAR_CONTEXT *nvc;

  /* Look starting at the current context all the way `up' */
  for (nv = v, nvc = vc; nvc; nvc = nvc->down)
    {
      nv2 = find_nameref_at_context (nv, nvc);
      if (nv2 == &nameref_maxloop_value)
	return (nv2);			/* XXX */
      if (nv2 == 0)
        continue;
      nv = nv2;
      if (*nvcp)
        *nvcp = nvc;
      if (nameref_p (nv) == 0)
        break;
    }
  return (nameref_p (nv) ? (SHELL_VAR *)NULL : nv);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:2,212
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:2,239
parsing error 
{
  SHELL_VAR *nv, *nv2;
  VAR_CONTEXT *nvc;

  /* Look starting at the current context all the way `up' */
  for (nv = v, nvc = vc; nvc; nvc = nvc->down)
    {
      nv2 = find_nameref_at_context (nv, nvc);
      if (nv2 == &nameref_maxloop_value)
	return (nv2);			/* XXX */
      if (nv2 == 0)
	continue;
      nv = nv2;
      if (*nvcp)
        *nvcp = nvc;
    }
  return (nameref_p (nv) ? nv : (SHELL_VAR *)NULL);
}
warning: parse error {
  SHELL_VAR *nv, *nv2;
  VAR_CONTEXT *nvc;

  /* Look starting at the current context all the way `up' */
  for (nv = v, nvc = vc; nvc; nvc = nvc->down)
    {
      nv2 = find_nameref_at_context (nv, nvc);
      if (nv2 == &nameref_maxloop_value)
	return (nv2);			/* XXX */
      if (nv2 == 0)
	continue;
      nv = nv2;
      if (*nvcp)
        *nvcp = nvc;
    }
  return (nameref_p (nv) ? nv : (SHELL_VAR *)NULL);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:2,243
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:2,264
parsing error 
{
  SHELL_VAR *var;

  /* See if we have a nameref pointing to a variable that hasn't been
     created yet. */
  var = find_variable_last_nameref (name, 1);
  if ((flags&1) && var && nameref_p (var) && invisible_p (var))
    {
      internal_warning (_("%s: removing nameref attribute"), name);
      VUNSETATTR (var, att_nameref);
    }
  if (var && nameref_p (var))
    {
      if (legal_identifier (nameref_cell (var)) == 0)
	{
	  sh_invalidid (nameref_cell (var) ? nameref_cell (var) : "");
	  return ((SHELL_VAR *)INVALID_NAMEREF_VALUE);
	}
    }
  return (var);
}
warning: parse error {
  SHELL_VAR *var;

  /* See if we have a nameref pointing to a variable that hasn't been
     created yet. */
  var = find_variable_last_nameref (name, 1);
  if ((flags&1) && var && nameref_p (var) && invisible_p (var))
    {
      internal_warning (_("%s: removing nameref attribute"), name);
      VUNSETATTR (var, att_nameref);
    }
  if (var && nameref_p (var))
    {
      if (legal_identifier (nameref_cell (var)) == 0)
	{
	  sh_invalidid (nameref_cell (var) ? nameref_cell (var) : "");
	  return ((SHELL_VAR *)INVALID_NAMEREF_VALUE);
	}
    }
  return (var);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:2,266
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:2,290
parsing error 
{
  SHELL_VAR *var;

  /* See if we have a nameref pointing to a variable that hasn't been
     created yet. */
  var = find_variable_last_nameref (name, 1);
  if (var && nameref_p (var) && invisible_p (var))	/* XXX - flags */
    {
      internal_warning (_("%s: removing nameref attribute"), name);
      VUNSETATTR (var, att_nameref);
    }
  if (var && nameref_p (var))
    {
      if (valid_nameref_value (nameref_cell (var), 1) == 0)
	{
	  sh_invalidid (nameref_cell (var) ? nameref_cell (var) : "");
	  return ((SHELL_VAR *)INVALID_NAMEREF_VALUE);
	}
    }
  return (var);
}
warning: parse error {
  SHELL_VAR *var;

  /* See if we have a nameref pointing to a variable that hasn't been
     created yet. */
  var = find_variable_last_nameref (name, 1);
  if (var && nameref_p (var) && invisible_p (var))	/* XXX - flags */
    {
      internal_warning (_("%s: removing nameref attribute"), name);
      VUNSETATTR (var, att_nameref);
    }
  if (var && nameref_p (var))
    {
      if (valid_nameref_value (nameref_cell (var), 1) == 0)
	{
	  sh_invalidid (nameref_cell (var) ? nameref_cell (var) : "");
	  return ((SHELL_VAR *)INVALID_NAMEREF_VALUE);
	}
    }
  return (var);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:2,292
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:2,320
parsing error 
{
  SHELL_VAR *v;
  char *newname;

  v = 0;
  if (flags & ASS_MKLOCAL)
    {
      v = find_variable_last_nameref (name, 1);
      /* If we're making local variables, only follow namerefs that point to
	 non-existent variables at the same variable context. */
      if (v && v->context != variable_context)
	v = 0;
    }
  else if (flags & ASS_MKGLOBAL)
    v = (flags & ASS_CHKLOCAL) ? find_variable_last_nameref (name, 1)
			       : find_global_variable_last_nameref (name, 1);
  if (v && nameref_p (v) && valid_nameref_value (nameref_cell (v), 1))
    return nameref_cell (v);
  return name;
}
warning: parse error {
  SHELL_VAR *v;
  char *newname;

  v = 0;
  if (flags & ASS_MKLOCAL)
    {
      v = find_variable_last_nameref (name, 1);
      /* If we're making local variables, only follow namerefs that point to
	 non-existent variables at the same variable context. */
      if (v && v->context != variable_context)
	v = 0;
    }
  else if (flags & ASS_MKGLOBAL)
    v = (flags & ASS_CHKLOCAL) ? find_variable_last_nameref (name, 1)
			       : find_global_variable_last_nameref (name, 1);
  if (v && nameref_p (v) && valid_nameref_value (nameref_cell (v), 1))
    return nameref_cell (v);
  return name;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:2,323
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:2,347
parsing error 
{
  SHELL_VAR *var;

  var = find_variable_internal (name, FV_FORCETEMPENV);
  if (var && nameref_p (var))
    var = find_variable_nameref (var);
  return (var);
}
warning: parse error {
  SHELL_VAR *var;

  var = find_variable_internal (name, FV_FORCETEMPENV);
  if (var && nameref_p (var))
    var = find_variable_nameref (var);
  return (var);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:2,348
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:2,360
parsing error 
{
  SHELL_VAR *var;

  var = find_variable_internal (name, 0);
  if (var && nameref_p (var))
    var = find_variable_nameref (var);
  return (var);
}
warning: parse error {
  SHELL_VAR *var;

  var = find_variable_internal (name, 0);
  if (var && nameref_p (var))
    var = find_variable_nameref (var);
  return (var);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:2,361
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:2,372
parsing error 
{
  SHELL_VAR *var;

  var = var_lookup (name, global_variables);
  if (var && nameref_p (var))
    var = find_variable_nameref (var);

  if (var == 0)
    return ((SHELL_VAR *)NULL);

  return (var->dynamic_value ? (*(var->dynamic_value)) (var) : var);
}
warning: parse error {
  SHELL_VAR *var;

  var = var_lookup (name, global_variables);
  if (var && nameref_p (var))
    var = find_variable_nameref (var);

  if (var == 0)
    return ((SHELL_VAR *)NULL);

  return (var->dynamic_value ? (*(var->dynamic_value)) (var) : var);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:2,373
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:2,388
parsing error 
{
  SHELL_VAR *var;

  var = var_lookup (name, global_variables);

  if (var == 0)
    return ((SHELL_VAR *)NULL);

  return (var->dynamic_value ? (*(var->dynamic_value)) (var) : var);
}
warning: parse error {
  SHELL_VAR *var;

  var = var_lookup (name, global_variables);

  if (var == 0)
    return ((SHELL_VAR *)NULL);

  return (var->dynamic_value ? (*(var->dynamic_value)) (var) : var);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:2,389
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:2,402
parsing error 
{
  SHELL_VAR *var;

  var = var_lookup (name, shell_variables);
  if (var && nameref_p (var))
    var = find_variable_nameref (var);

  if (var == 0)
    return ((SHELL_VAR *)NULL);

  return (var->dynamic_value ? (*(var->dynamic_value)) (var) : var);
}
warning: parse error {
  SHELL_VAR *var;

  var = var_lookup (name, shell_variables);
  if (var && nameref_p (var))
    var = find_variable_nameref (var);

  if (var == 0)
    return ((SHELL_VAR *)NULL);

  return (var->dynamic_value ? (*(var->dynamic_value)) (var) : var);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:2,403
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:2,419
parsing error 
{
  SHELL_VAR *v;
  int flags;

  last_table_searched = 0;
  flags = 0;
  if (expanding_redir == 0 && (assigning_in_environment || executing_builtin))
    flags |= FV_FORCETEMPENV;
  v = find_variable_internal (name, flags);
  if (v && nameref_p (v))
    v = find_variable_nameref (v);
  return v;
}
warning: parse error {
  SHELL_VAR *v;
  int flags;

  last_table_searched = 0;
  flags = 0;
  if (expanding_redir == 0 && (assigning_in_environment || executing_builtin))
    flags |= FV_FORCETEMPENV;
  v = find_variable_internal (name, flags);
  if (v && nameref_p (v))
    v = find_variable_nameref (v);
  return v;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:2,420
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:2,439
parsing error 
{
  SHELL_VAR *v;
  int flags;

  last_table_searched = 0;
  flags = FV_SKIPINVISIBLE;
  if (expanding_redir == 0 && (assigning_in_environment || executing_builtin))
    flags |= FV_FORCETEMPENV;
  v = find_variable_internal (name, flags);
  if (v && nameref_p (v))
    v = find_variable_nameref (v);
  return v;
}
warning: parse error {
  SHELL_VAR *v;
  int flags;

  last_table_searched = 0;
  flags = FV_SKIPINVISIBLE;
  if (expanding_redir == 0 && (assigning_in_environment || executing_builtin))
    flags |= FV_FORCETEMPENV;
  v = find_variable_internal (name, flags);
  if (v && nameref_p (v))
    v = find_variable_nameref (v);
  return v;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:2,440
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:2,458
parsing error 
{
  SHELL_VAR *v;
  int flags;

  last_table_searched = 0;
  flags = 0;
  if (expanding_redir == 0 && (assigning_in_environment || executing_builtin))
    flags |= FV_FORCETEMPENV;
  v = find_variable_internal (name, flags);
  if (v && nameref_p (v))
    v = find_variable_nameref (v);
  return v;
}
warning: parse error {
  SHELL_VAR *v;
  int flags;

  last_table_searched = 0;
  flags = 0;
  if (expanding_redir == 0 && (assigning_in_environment || executing_builtin))
    flags |= FV_FORCETEMPENV;
  v = find_variable_internal (name, flags);
  if (v && nameref_p (v))
    v = find_variable_nameref (v);
  return v;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:2,459
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:2,475
parsing error 
{
  SHELL_VAR *v;
  int flags;

  flags = 0;
  if (expanding_redir == 0 && (assigning_in_environment || executing_builtin))
    flags |= FV_FORCETEMPENV;
  v = find_variable_internal (name, flags);
  return v;
}
warning: parse error {
  SHELL_VAR *v;
  int flags;

  flags = 0;
  if (expanding_redir == 0 && (assigning_in_environment || executing_builtin))
    flags |= FV_FORCETEMPENV;
  v = find_variable_internal (name, flags);
  return v;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:2,476
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:2,491
parsing error 
{
  return (hash_lookup (name, shell_functions));
}
warning: parse error {
  return (hash_lookup (name, shell_functions));
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:2,492
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:2,500
parsing error 
{
#if defined (DEBUGGER)
  return ((FUNCTION_DEF *)hash_lookup (name, shell_function_defs));
#else
  return ((FUNCTION_DEF *)0);
#endif
}
warning: parse error {
#if defined (DEBUGGER)
  return ((FUNCTION_DEF *)hash_lookup (name, shell_function_defs));
#else
  return ((FUNCTION_DEF *)0);
#endif
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:2,501
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:2,512
parsing error 
{
  if (var == 0)
    return ((char *)NULL);
#if defined (ARRAY_VARS)
  else if (array_p (var))
    return (array_reference (array_cell (var), 0));
  else if (assoc_p (var))
    return (assoc_reference (assoc_cell (var), "0"));
#endif
  else
    return (value_cell (var));
}
warning: parse error {
  if (var == 0)
    return ((char *)NULL);
#if defined (ARRAY_VARS)
  else if (array_p (var))
    return (array_reference (array_cell (var), 0));
  else if (assoc_p (var))
    return (assoc_reference (assoc_cell (var), "0"));
#endif
  else
    return (value_cell (var));
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:2,514
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:2,534
parsing error 
{
  SHELL_VAR *var;

  var = find_variable (var_name);
  return ((var) ? get_variable_value (var) : (char *)NULL);
}
warning: parse error {
  SHELL_VAR *var;

  var = find_variable (var_name);
  return ((var) ? get_variable_value (var) : (char *)NULL);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:2,535
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:2,545
parsing error 
{
  return get_string_value (v);
}
warning: parse error {
  return get_string_value (v);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:2,546
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:2,557
parsing error 
{
  if (v1 == 0 || v2 == 0)
    return 0;
#if defined (ARRAY_VARS)
  else if (assoc_p (v1) && assoc_p (v2))
    return 1;
  else if (array_p (v1) && array_p (v2))
    return 1;
  else if (array_p (v1) || array_p (v2))
    return 0;
  else if (assoc_p (v1) || assoc_p (v2))
    return 0;
#endif
  else
    return 1;
}
warning: parse error {
  if (v1 == 0 || v2 == 0)
    return 0;
#if defined (ARRAY_VARS)
  else if (assoc_p (v1) && assoc_p (v2))
    return 1;
  else if (array_p (v1) && array_p (v2))
    return 1;
  else if (array_p (v1) || array_p (v2))
    return 0;
  else if (assoc_p (v1) || assoc_p (v2))
    return 0;
#endif
  else
    return 1;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:2,560
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:2,578
parsing error 
{
#if defined (ARRAY_VARS)
  if (type == att_array && assoc_p (var))
    return 0;
  else if (type == att_assoc && array_p (var))
    return 0;
  else
#endif
  return 1;	/* should we run convert_var_to_array here or let the caller? */
}
warning: parse error {
#if defined (ARRAY_VARS)
  if (type == att_array && assoc_p (var))
    return 0;
  else if (type == att_assoc && array_p (var))
    return 0;
  else
#endif
  return 1;	/* should we run convert_var_to_array here or let the caller? */
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:2,581
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:2,594
parsing error 
{
  SHELL_VAR *v;

  if (shell_variables == 0)
    create_variable_tables ();

  v = find_variable (name);
  if (v == 0)
    v = bind_variable_internal (name, value, global_variables->table, HASH_NOSRCH, 0);
  return (v);
}
warning: parse error {
  SHELL_VAR *v;

  if (shell_variables == 0)
    create_variable_tables ();

  v = find_variable (name);
  if (v == 0)
    v = bind_variable_internal (name, value, global_variables->table, HASH_NOSRCH, 0);
  return (v);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:2,596
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:2,611
parsing error 
{
  SHELL_VAR *new_var, *old_var, *old_ref;
  VAR_CONTEXT *vc;
  int was_tmpvar;
  char *old_value;

  /* We don't want to follow the nameref chain when making local variables; we
     just want to create them. */
  old_ref = find_variable_noref (name);
  if (old_ref && nameref_p (old_ref) == 0)
    old_ref = 0;
  /* local foo; local foo;  is a no-op. */
  old_var = find_variable (name);
  if (old_ref == 0 && old_var && local_p (old_var) && old_var->context == variable_context)
    return (old_var);

  /* local -n foo; local -n foo;  is a no-op. */
  if (old_ref && local_p (old_ref) && old_ref->context == variable_context)
    return (old_ref);

  /* From here on, we want to use the refvar, not the variable it references */
  if (old_ref)
    old_var = old_ref;

  was_tmpvar = old_var && tempvar_p (old_var);
  /* If we're making a local variable in a shell function, the temporary env
     has already been merged into the function's variable context stack.  We
     can assume that a temporary var in the same context appears in the same
     VAR_CONTEXT and can safely be returned without creating a new variable
     (which results in duplicate names in the same VAR_CONTEXT->table */
  /* We can't just test tmpvar_p because variables in the temporary env given
     to a shell function appear in the function's local variable VAR_CONTEXT
     but retain their tempvar attribute.  We want temporary variables that are
     found in temporary_env, hence the test for last_table_searched, which is
     set in hash_lookup and only (so far) checked here. */
  if (was_tmpvar && old_var->context == variable_context && last_table_searched != temporary_env)
    {
      VUNSETATTR (old_var, att_invisible);	/* XXX */
      /* We still want to flag this variable as local, though, and set things
         up so that it gets treated as a local variable. */
      new_var = old_var;
      /* Since we found the variable in a temporary environment, this will
	 succeed. */
      for (vc = shell_variables; vc; vc = vc->down)
	if (vc_isfuncenv (vc) && vc->scope == variable_context)
	  break;
      goto set_local_var_flags;

      return (old_var);
    }

  /* If we want to change to "inherit the old variable's value" semantics,
     here is where to save the old value. */
  old_value = was_tmpvar ? value_cell (old_var) : (char *)NULL;

  for (vc = shell_variables; vc; vc = vc->down)
    if (vc_isfuncenv (vc) && vc->scope == variable_context)
      break;

  if (vc == 0)
    {
      internal_error (_("make_local_variable: no function context at current scope"));
      return ((SHELL_VAR *)NULL);
    }
  else if (vc->table == 0)
    vc->table = hash_create (TEMPENV_HASH_BUCKETS);

  /* Since this is called only from the local/declare/typeset code, we can
     call builtin_error here without worry (of course, it will also work
     for anything that sets this_command_name).  Variables with the `noassign'
     attribute may not be made local.  The test against old_var's context
     level is to disallow local copies of readonly global variables (since I
     believe that this could be a security hole).  Readonly copies of calling
     function local variables are OK. */
  if (old_var && (noassign_p (old_var) ||
		 (readonly_p (old_var) && old_var->context == 0)))
    {
      if (readonly_p (old_var))
	sh_readonly (name);
      else if (noassign_p (old_var))
	builtin_error (_("%s: variable may not be assigned value"), name);
#if 0
      /* Let noassign variables through with a warning */
      if (readonly_p (old_var))
#endif
	return ((SHELL_VAR *)NULL);
    }

  if (old_var == 0)
    new_var = make_new_variable (name, vc->table);
  else
    {
      new_var = make_new_variable (name, vc->table);

      /* If we found this variable in one of the temporary environments,
	 inherit its value.  Watch to see if this causes problems with
	 things like `x=4 local x'. XXX - see above for temporary env
	 variables with the same context level as variable_context */
      /* XXX - we should only do this if the variable is not an array. */
      /* If we want to change the local variable semantics to "inherit
	 the old variable's value" here is where to set it.  And we would
	 need to use copy_variable (currently unused) to do it for all
	 possible variable values. */
      if (was_tmpvar)
	var_setvalue (new_var, savestring (old_value));
      else if (localvar_inherit || (flags & MKLOC_INHERIT))
	{
	  /* This may not make sense for nameref variables that are shadowing
	     variables with the same name, but we don't know that yet. */
#if defined (ARRAY_VARS)
	  if (assoc_p (old_var))
	    var_setassoc (new_var, assoc_copy (assoc_cell (old_var)));
	  else if (array_p (old_var))
	    var_setarray (new_var, array_copy (array_cell (old_var)));
	  else if (value_cell (old_var))
#else
	  if (value_cell (old_var))
#endif
	    var_setvalue (new_var, savestring (value_cell (old_var)));
	  else
	    var_setvalue (new_var, (char *)NULL);
	}

      if (localvar_inherit || (flags & MKLOC_INHERIT))
	{
	  /* It doesn't make sense to inherit the nameref attribute */
	  new_var->attributes = old_var->attributes & ~att_nameref;
	  new_var->dynamic_value = old_var->dynamic_value;
	  new_var->assign_func = old_var->assign_func;
	}
      else
	/* We inherit the export attribute, but no others. */
	new_var->attributes = exported_p (old_var) ? att_exported : 0;
    }

set_local_var_flags:
  vc->flags |= VC_HASLOCAL;

  new_var->context = variable_context;
  VSETATTR (new_var, att_local);

  if (ifsname (name))
    setifs (new_var);

  /* value_cell will be 0 if localvar_inherit == 0 or there was no old variable
     with the same name or the old variable was invisible */
  if (was_tmpvar == 0 && value_cell (new_var) == 0)
    VSETATTR (new_var, att_invisible);	/* XXX */
  return (new_var);
}
warning: parse error {
  SHELL_VAR *new_var, *old_var, *old_ref;
  VAR_CONTEXT *vc;
  int was_tmpvar;
  char *old_value;

  /* We don't want to follow the nameref chain when making local variables; we
     just want to create them. */
  old_ref = find_variable_noref (name);
  if (old_ref && nameref_p (old_ref) == 0)
    old_ref = 0;
  /* local foo; local foo;  is a no-op. */
  old_var = find_variable (name);
  if (old_ref == 0 && old_var && local_p (old_var) && old_var->context == variable_context)
    return (old_var);

  /* local -n foo; local -n foo;  is a no-op. */
  if (old_ref && local_p (old_ref) && old_ref->context == variable_context)
    return (old_ref);

  /* From here on, we want to use the refvar, not the variable it references */
  if (old_ref)
    old_var = old_ref;

  was_tmpvar = old_var && tempvar_p (old_var);
  /* If we're making a local variable in a shell function, the temporary env
     has already been merged into the function's variable context stack.  We
     can assume that a temporary var in the same context appears in the same
     VAR_CONTEXT and can safely be returned without creating a new variable
     (which results in duplicate names in the same VAR_CONTEXT->table */
  /* We can't just test tmpvar_p because variables in the temporary env given
     to a shell function appear in the function's local variable VAR_CONTEXT
     but retain their tempvar attribute.  We want temporary variables that are
     found in temporary_env, hence the test for last_table_searched, which is
     set in hash_lookup and only (so far) checked here. */
  if (was_tmpvar && old_var->context == variable_context && last_table_searched != temporary_env)
    {
      VUNSETATTR (old_var, att_invisible);	/* XXX */
      /* We still want to flag this variable as local, though, and set things
         up so that it gets treated as a local variable. */
      new_var = old_var;
      /* Since we found the variable in a temporary environment, this will
	 succeed. */
      for (vc = shell_variables; vc; vc = vc->down)
	if (vc_isfuncenv (vc) && vc->scope == variable_context)
	  break;
      goto set_local_var_flags;

      return (old_var);
    }

  /* If we want to change to "inherit the old variable's value" semantics,
     here is where to save the old value. */
  old_value = was_tmpvar ? value_cell (old_var) : (char *)NULL;

  for (vc = shell_variables; vc; vc = vc->down)
    if (vc_isfuncenv (vc) && vc->scope == variable_context)
      break;

  if (vc == 0)
    {
      internal_error (_("make_local_variable: no function context at current scope"));
      return ((SHELL_VAR *)NULL);
    }
  else if (vc->table == 0)
    vc->table = hash_create (TEMPENV_HASH_BUCKETS);

  /* Since this is called only from the local/declare/typeset code, we can
     call builtin_error here without worry (of course, it will also work
     for anything that sets this_command_name).  Variables with the `noassign'
     attribute may not be made local.  The test against old_var's context
     level is to disallow local copies of readonly global variables (since I
     believe that this could be a security hole).  Readonly copies of calling
     function local variables are OK. */
  if (old_var && (noassign_p (old_var) ||
		 (readonly_p (old_var) && old_var->context == 0)))
    {
      if (readonly_p (old_var))
	sh_readonly (name);
      else if (noassign_p (old_var))
	builtin_error (_("%s: variable may not be assigned value"), name);
#if 0
      /* Let noassign variables through with a warning */
      if (readonly_p (old_var))
#endif
	return ((SHELL_VAR *)NULL);
    }

  if (old_var == 0)
    new_var = make_new_variable (name, vc->table);
  else
    {
      new_var = make_new_variable (name, vc->table);

      /* If we found this variable in one of the temporary environments,
	 inherit its value.  Watch to see if this causes problems with
	 things like `x=4 local x'. XXX - see above for temporary env
	 variables with the same context level as variable_context */
      /* XXX - we should only do this if the variable is not an array. */
      /* If we want to change the local variable semantics to "inherit
	 the old variable's value" here is where to set it.  And we would
	 need to use copy_variable (currently unused) to do it for all
	 possible variable values. */
      if (was_tmpvar)
	var_setvalue (new_var, savestring (old_value));
      else if (localvar_inherit || (flags & MKLOC_INHERIT))
	{
	  /* This may not make sense for nameref variables that are shadowing
	     variables with the same name, but we don't know that yet. */
#if defined (ARRAY_VARS)
	  if (assoc_p (old_var))
	    var_setassoc (new_var, assoc_copy (assoc_cell (old_var)));
	  else if (array_p (old_var))
	    var_setarray (new_var, array_copy (array_cell (old_var)));
	  else if (value_cell (old_var))
#else
	  if (value_cell (old_var))
#endif
	    var_setvalue (new_var, savestring (value_cell (old_var)));
	  else
	    var_setvalue (new_var, (char *)NULL);
	}

      if (localvar_inherit || (flags & MKLOC_INHERIT))
	{
	  /* It doesn't make sense to inherit the nameref attribute */
	  new_var->attributes = old_var->attributes & ~att_nameref;
	  new_var->dynamic_value = old_var->dynamic_value;
	  new_var->assign_func = old_var->assign_func;
	}
      else
	/* We inherit the export attribute, but no others. */
	new_var->attributes = exported_p (old_var) ? att_exported : 0;
    }

set_local_var_flags:
  vc->flags |= VC_HASLOCAL;

  new_var->context = variable_context;
  VSETATTR (new_var, att_local);

  if (ifsname (name))
    setifs (new_var);

  /* value_cell will be 0 if localvar_inherit == 0 or there was no old variable
     with the same name or the old variable was invisible */
  if (was_tmpvar == 0 && value_cell (new_var) == 0)
    VSETATTR (new_var, att_invisible);	/* XXX */
  return (new_var);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:2,613
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:2,767
parsing error 
{
  SHELL_VAR *entry;

  entry = (SHELL_VAR *)xmalloc (sizeof (SHELL_VAR));

  entry->name = savestring (name);
  var_setvalue (entry, (char *)NULL);
  CLEAR_EXPORTSTR (entry);

  entry->dynamic_value = (sh_var_value_func_t *)NULL;
  entry->assign_func = (sh_var_assign_func_t *)NULL;

  entry->attributes = 0;

  /* Always assume variables are to be made at toplevel!
     make_local_variable has the responsibility of changing the
     variable context. */
  entry->context = 0;

  return (entry);
}
warning: parse error {
  SHELL_VAR *entry;

  entry = (SHELL_VAR *)xmalloc (sizeof (SHELL_VAR));

  entry->name = savestring (name);
  var_setvalue (entry, (char *)NULL);
  CLEAR_EXPORTSTR (entry);

  entry->dynamic_value = (sh_var_value_func_t *)NULL;
  entry->assign_func = (sh_var_assign_func_t *)NULL;

  entry->attributes = 0;

  /* Always assume variables are to be made at toplevel!
     make_local_variable has the responsibility of changing the
     variable context. */
  entry->context = 0;

  return (entry);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:2,768
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:2,794
parsing error 
{
  SHELL_VAR *entry;
  BUCKET_CONTENTS *elt;

  entry = new_shell_variable (name);

  /* Make sure we have a shell_variables hash table to add to. */
  if (shell_variables == 0)
    create_variable_tables ();

  elt = hash_insert (savestring (name), table, HASH_NOSRCH);
  elt->data = (PTR_T)entry;

  return entry;
}
warning: parse error {
  SHELL_VAR *entry;
  BUCKET_CONTENTS *elt;

  entry = new_shell_variable (name);

  /* Make sure we have a shell_variables hash table to add to. */
  if (shell_variables == 0)
    create_variable_tables ();

  elt = hash_insert (savestring (name), table, HASH_NOSRCH);
  elt->data = (PTR_T)entry;

  return entry;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:2,796
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:2,927
parsing error 
{
  char *retval, *oval;
  intmax_t lval, rval;
  int expok, olen, op;

  /* If this variable has had its type set to integer (via `declare -i'),
     then do expression evaluation on it and store the result.  The
     functions in expr.c (evalexp()) and bind_int_variable() are responsible
     for turning off the integer flag if they don't want further
     evaluation done.  Callers that find it inconvenient to do this can set
     the ASS_NOEVAL flag.  For the special case of arithmetic expression
     evaluation, the caller can set ASS_NOLONGJMP to avoid jumping out to
     top_level. */
  if ((flags & ASS_NOEVAL) == 0 && integer_p (var))
    {
      if (flags & ASS_APPEND)
	{
	  oval = value_cell (var);
	  lval = evalexp (oval, 0, &expok);	/* ksh93 seems to do this */
	  if (expok == 0)
	    {
	      if (flags & ASS_NOLONGJMP)
		goto make_value;
	      else
		{
		  top_level_cleanup ();
		  jump_to_top_level (DISCARD);
		}
	    }
	}
      rval = evalexp (value, 0, &expok);
      if (expok == 0)
	{
	  if (flags & ASS_NOLONGJMP)
	    goto make_value;
	  else
	    {
	      top_level_cleanup ();
	      jump_to_top_level (DISCARD);
	    }
	}
      /* This can be fooled if the variable's value changes while evaluating
	 `rval'.  We can change it if we move the evaluation of lval to here. */
      if (flags & ASS_APPEND)
	rval += lval;
      retval = itos (rval);
    }
#if defined (CASEMOD_ATTRS)
  else if ((flags & ASS_NOEVAL) == 0 && (capcase_p (var) || uppercase_p (var) || lowercase_p (var)))
    {
      if (flags & ASS_APPEND)
	{
	  oval = get_variable_value (var);
	  if (oval == 0)	/* paranoia */
	    oval = "";
	  olen = STRLEN (oval);
	  retval = (char *)xmalloc (olen + (value ? STRLEN (value) : 0) + 1);
	  strcpy (retval, oval);
	  if (value)
	    strcpy (retval+olen, value);
	}
      else if (*value)
	retval = savestring (value);
      else
	{
	  retval = (char *)xmalloc (1);
	  retval[0] = '\0';
	}
      op = capcase_p (var) ? CASE_CAPITALIZE
			 : (uppercase_p (var) ? CASE_UPPER : CASE_LOWER);
      oval = sh_modcase (retval, (char *)0, op);
      free (retval);
      retval = oval;
    }
#endif /* CASEMOD_ATTRS */
  else if (value)
    {
make_value:
      if (flags & ASS_APPEND)
	{
	  oval = get_variable_value (var);
	  if (oval == 0)	/* paranoia */
	    oval = "";
	  olen = STRLEN (oval);
	  retval = (char *)xmalloc (olen + (value ? STRLEN (value) : 0) + 1);
	  strcpy (retval, oval);
	  if (value)
	    strcpy (retval+olen, value);
	}
      else if (*value)
	retval = savestring (value);
      else
	{
	  retval = (char *)xmalloc (1);
	  retval[0] = '\0';
	}
    }
  else
    retval = (char *)NULL;

  return retval;
}
warning: parse error {
  char *retval, *oval;
  intmax_t lval, rval;
  int expok, olen, op;

  /* If this variable has had its type set to integer (via `declare -i'),
     then do expression evaluation on it and store the result.  The
     functions in expr.c (evalexp()) and bind_int_variable() are responsible
     for turning off the integer flag if they don't want further
     evaluation done.  Callers that find it inconvenient to do this can set
     the ASS_NOEVAL flag.  For the special case of arithmetic expression
     evaluation, the caller can set ASS_NOLONGJMP to avoid jumping out to
     top_level. */
  if ((flags & ASS_NOEVAL) == 0 && integer_p (var))
    {
      if (flags & ASS_APPEND)
	{
	  oval = value_cell (var);
	  lval = evalexp (oval, 0, &expok);	/* ksh93 seems to do this */
	  if (expok == 0)
	    {
	      if (flags & ASS_NOLONGJMP)
		goto make_value;
	      else
		{
		  top_level_cleanup ();
		  jump_to_top_level (DISCARD);
		}
	    }
	}
      rval = evalexp (value, 0, &expok);
      if (expok == 0)
	{
	  if (flags & ASS_NOLONGJMP)
	    goto make_value;
	  else
	    {
	      top_level_cleanup ();
	      jump_to_top_level (DISCARD);
	    }
	}
      /* This can be fooled if the variable's value changes while evaluating
	 `rval'.  We can change it if we move the evaluation of lval to here. */
      if (flags & ASS_APPEND)
	rval += lval;
      retval = itos (rval);
    }
#if defined (CASEMOD_ATTRS)
  else if ((flags & ASS_NOEVAL) == 0 && (capcase_p (var) || uppercase_p (var) || lowercase_p (var)))
    {
      if (flags & ASS_APPEND)
	{
	  oval = get_variable_value (var);
	  if (oval == 0)	/* paranoia */
	    oval = "";
	  olen = STRLEN (oval);
	  retval = (char *)xmalloc (olen + (value ? STRLEN (value) : 0) + 1);
	  strcpy (retval, oval);
	  if (value)
	    strcpy (retval+olen, value);
	}
      else if (*value)
	retval = savestring (value);
      else
	{
	  retval = (char *)xmalloc (1);
	  retval[0] = '\0';
	}
      op = capcase_p (var) ? CASE_CAPITALIZE
			 : (uppercase_p (var) ? CASE_UPPER : CASE_LOWER);
      oval = sh_modcase (retval, (char *)0, op);
      free (retval);
      retval = oval;
    }
#endif /* CASEMOD_ATTRS */
  else if (value)
    {
make_value:
      if (flags & ASS_APPEND)
	{
	  oval = get_variable_value (var);
	  if (oval == 0)	/* paranoia */
	    oval = "";
	  olen = STRLEN (oval);
	  retval = (char *)xmalloc (olen + (value ? STRLEN (value) : 0) + 1);
	  strcpy (retval, oval);
	  if (value)
	    strcpy (retval+olen, value);
	}
      else if (*value)
	retval = savestring (value);
      else
	{
	  retval = (char *)xmalloc (1);
	  retval[0] = '\0';
	}
    }
  else
    retval = (char *)NULL;

  return retval;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:2,931
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:3,036
parsing error 
{
  if ((aflags & ASS_APPEND) == 0)
    return 0;
#if defined (ARRAY_VARS)
  if (array_p (entry) || assoc_p (entry))
    return 0;
#endif
  if (integer_p (entry) || uppercase_p (entry) || lowercase_p (entry) || capcase_p (entry))
    return 0;
  if (readonly_p (entry) || noassign_p (entry))
    return 0;
  return 1;
}
warning: parse error {
  if ((aflags & ASS_APPEND) == 0)
    return 0;
#if defined (ARRAY_VARS)
  if (array_p (entry) || assoc_p (entry))
    return 0;
#endif
  if (integer_p (entry) || uppercase_p (entry) || lowercase_p (entry) || capcase_p (entry))
    return 0;
  if (readonly_p (entry) || noassign_p (entry))
    return 0;
  return 1;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:3,040
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:3,056
parsing error 
{
  size_t len, vlen;
  char *v, *new;

  v = value_cell (entry);
  len = STRLEN (v);
  vlen = STRLEN (value);

  new = (char *)xrealloc (v, len + vlen + 8);	/* for now */
  if (vlen == 1)
    {
      new[len] = *value;
      new[len+1] = '\0';
    }
  else
    strcpy (new + len, value);
  var_setvalue (entry, new);
  return entry;
}
warning: parse error {
  size_t len, vlen;
  char *v, *new;

  v = value_cell (entry);
  len = STRLEN (v);
  vlen = STRLEN (value);

  new = (char *)xrealloc (v, len + vlen + 8);	/* for now */
  if (vlen == 1)
    {
      new[len] = *value;
      new[len+1] = '\0';
    }
  else
    strcpy (new + len, value);
  var_setvalue (entry, new);
  return entry;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:3,060
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:3,085
parsing error 
{
  char *newval, *tname;
  SHELL_VAR *entry, *tentry;

  entry = (hflags & HASH_NOSRCH) ? (SHELL_VAR *)NULL : hash_lookup (name, table);
  /* Follow the nameref chain here if this is the global variables table */
  if (entry && nameref_p (entry) && (invisible_p (entry) == 0) && table == global_variables->table)
    {
      entry = find_global_variable (entry->name);
      /* Let's see if we have a nameref referencing a variable that hasn't yet
	 been created. */
      if (entry == 0)
	entry = find_variable_last_nameref (name, 0);	/* XXX */
      if (entry == 0)					/* just in case */
        return (entry);
    }

  /* The first clause handles `declare -n ref; ref=x;' or `declare -n ref;
     declare -n ref' */
  if (entry && invisible_p (entry) && nameref_p (entry))
    {
      if ((aflags & ASS_FORCE) == 0 && value && valid_nameref_value (value, 0) == 0)
	{
	  sh_invalidid (value);
	  return ((SHELL_VAR *)NULL);
	}
      goto assign_value;
    }
  else if (entry && nameref_p (entry))
    {
      newval = nameref_cell (entry);	/* XXX - newval can't be NULL here */
      if (valid_nameref_value (newval, 0) == 0)
	{
	  sh_invalidid (newval);
	  return ((SHELL_VAR *)NULL);
	}
#if defined (ARRAY_VARS)
      /* declare -n foo=x[2] ; foo=bar */
      if (valid_array_reference (newval, 0))
	{
	  tname = array_variable_name (newval, 0, (char **)0, (int *)0);
	  if (tname && (tentry = find_variable_noref (tname)) && nameref_p (tentry))
	    {
	      /* nameref variables can't be arrays */
	      internal_warning (_("%s: removing nameref attribute"), name_cell (tentry));
	      FREE (value_cell (tentry));		/* XXX - bash-4.3 compat */
	      var_setvalue (tentry, (char *)NULL);
	      VUNSETATTR (tentry, att_nameref);
	    }
	  free (tname);
          /* XXX - should it be aflags? */
	  entry = assign_array_element (newval, make_variable_value (entry, value, aflags), aflags|ASS_NAMEREF);
	  if (entry == 0)
	    return entry;
	}
      else
#endif
	{
	  entry = make_new_variable (newval, table);
	  var_setvalue (entry, make_variable_value (entry, value, aflags));
	}
    }
  else if (entry == 0)
    {
      entry = make_new_variable (name, table);
      var_setvalue (entry, make_variable_value (entry, value, aflags)); /* XXX */
    }
  else if (entry->assign_func)	/* array vars have assign functions now */
    {
      if ((readonly_p (entry) && (aflags & ASS_FORCE) == 0) || noassign_p (entry))
	{
	  if (readonly_p (entry))
	    err_readonly (name_cell (entry));
	  return (entry);
	}

      INVALIDATE_EXPORTSTR (entry);
      newval = (aflags & ASS_APPEND) ? make_variable_value (entry, value, aflags) : value;
      if (assoc_p (entry))
	entry = (*(entry->assign_func)) (entry, newval, -1, savestring ("0"));
      else if (array_p (entry))
	entry = (*(entry->assign_func)) (entry, newval, 0, 0);
      else
	entry = (*(entry->assign_func)) (entry, newval, -1, 0);
      if (newval != value)
	free (newval);
      return (entry);
    }
  else
    {
assign_value:
      if ((readonly_p (entry) && (aflags & ASS_FORCE) == 0) || noassign_p (entry))
	{
	  if (readonly_p (entry))
	    err_readonly (name_cell (entry));
	  return (entry);
	}

      /* Variables which are bound are visible. */
      VUNSETATTR (entry, att_invisible);

      /* If we can optimize the assignment, do so and return.  Right now, we
	 optimize appends to string variables. */
      if (can_optimize_assignment (entry, value, aflags))
	{
	  INVALIDATE_EXPORTSTR (entry);
	  optimized_assignment (entry, value, aflags);

	  if (mark_modified_vars)
	    VSETATTR (entry, att_exported);

	  if (exported_p (entry))
	    array_needs_making = 1;

	  return (entry);
	}

#if defined (ARRAY_VARS)
      if (assoc_p (entry) || array_p (entry))
        newval = make_array_variable_value (entry, 0, "0", value, aflags);
      else
#endif
      newval = make_variable_value (entry, value, aflags);	/* XXX */

      /* Invalidate any cached export string */
      INVALIDATE_EXPORTSTR (entry);

#if defined (ARRAY_VARS)
      /* XXX -- this bears looking at again -- XXX */
      /* If an existing array variable x is being assigned to with x=b or
	 `read x' or something of that nature, silently convert it to
	 x[0]=b or `read x[0]'. */
      if (assoc_p (entry))
	{
	  assoc_insert (assoc_cell (entry), savestring ("0"), newval);
	  free (newval);
	}
      else if (array_p (entry))
	{
	  array_insert (array_cell (entry), 0, newval);
	  free (newval);
	}
      else
#endif
	{
	  FREE (value_cell (entry));
	  var_setvalue (entry, newval);
	}
    }

  if (mark_modified_vars)
    VSETATTR (entry, att_exported);

  if (exported_p (entry))
    array_needs_making = 1;

  return (entry);
}
warning: parse error {
  char *newval, *tname;
  SHELL_VAR *entry, *tentry;

  entry = (hflags & HASH_NOSRCH) ? (SHELL_VAR *)NULL : hash_lookup (name, table);
  /* Follow the nameref chain here if this is the global variables table */
  if (entry && nameref_p (entry) && (invisible_p (entry) == 0) && table == global_variables->table)
    {
      entry = find_global_variable (entry->name);
      /* Let's see if we have a nameref referencing a variable that hasn't yet
	 been created. */
      if (entry == 0)
	entry = find_variable_last_nameref (name, 0);	/* XXX */
      if (entry == 0)					/* just in case */
        return (entry);
    }

  /* The first clause handles `declare -n ref; ref=x;' or `declare -n ref;
     declare -n ref' */
  if (entry && invisible_p (entry) && nameref_p (entry))
    {
      if ((aflags & ASS_FORCE) == 0 && value && valid_nameref_value (value, 0) == 0)
	{
	  sh_invalidid (value);
	  return ((SHELL_VAR *)NULL);
	}
      goto assign_value;
    }
  else if (entry && nameref_p (entry))
    {
      newval = nameref_cell (entry);	/* XXX - newval can't be NULL here */
      if (valid_nameref_value (newval, 0) == 0)
	{
	  sh_invalidid (newval);
	  return ((SHELL_VAR *)NULL);
	}
#if defined (ARRAY_VARS)
      /* declare -n foo=x[2] ; foo=bar */
      if (valid_array_reference (newval, 0))
	{
	  tname = array_variable_name (newval, 0, (char **)0, (int *)0);
	  if (tname && (tentry = find_variable_noref (tname)) && nameref_p (tentry))
	    {
	      /* nameref variables can't be arrays */
	      internal_warning (_("%s: removing nameref attribute"), name_cell (tentry));
	      FREE (value_cell (tentry));		/* XXX - bash-4.3 compat */
	      var_setvalue (tentry, (char *)NULL);
	      VUNSETATTR (tentry, att_nameref);
	    }
	  free (tname);
          /* XXX - should it be aflags? */
	  entry = assign_array_element (newval, make_variable_value (entry, value, aflags), aflags|ASS_NAMEREF);
	  if (entry == 0)
	    return entry;
	}
      else
#endif
	{
	  entry = make_new_variable (newval, table);
	  var_setvalue (entry, make_variable_value (entry, value, aflags));
	}
    }
  else if (entry == 0)
    {
      entry = make_new_variable (name, table);
      var_setvalue (entry, make_variable_value (entry, value, aflags)); /* XXX */
    }
  else if (entry->assign_func)	/* array vars have assign functions now */
    {
      if ((readonly_p (entry) && (aflags & ASS_FORCE) == 0) || noassign_p (entry))
	{
	  if (readonly_p (entry))
	    err_readonly (name_cell (entry));
	  return (entry);
	}

      INVALIDATE_EXPORTSTR (entry);
      newval = (aflags & ASS_APPEND) ? make_variable_value (entry, value, aflags) : value;
      if (assoc_p (entry))
	entry = (*(entry->assign_func)) (entry, newval, -1, savestring ("0"));
      else if (array_p (entry))
	entry = (*(entry->assign_func)) (entry, newval, 0, 0);
      else
	entry = (*(entry->assign_func)) (entry, newval, -1, 0);
      if (newval != value)
	free (newval);
      return (entry);
    }
  else
    {
assign_value:
      if ((readonly_p (entry) && (aflags & ASS_FORCE) == 0) || noassign_p (entry))
	{
	  if (readonly_p (entry))
	    err_readonly (name_cell (entry));
	  return (entry);
	}

      /* Variables which are bound are visible. */
      VUNSETATTR (entry, att_invisible);

      /* If we can optimize the assignment, do so and return.  Right now, we
	 optimize appends to string variables. */
      if (can_optimize_assignment (entry, value, aflags))
	{
	  INVALIDATE_EXPORTSTR (entry);
	  optimized_assignment (entry, value, aflags);

	  if (mark_modified_vars)
	    VSETATTR (entry, att_exported);

	  if (exported_p (entry))
	    array_needs_making = 1;

	  return (entry);
	}

#if defined (ARRAY_VARS)
      if (assoc_p (entry) || array_p (entry))
        newval = make_array_variable_value (entry, 0, "0", value, aflags);
      else
#endif
      newval = make_variable_value (entry, value, aflags);	/* XXX */

      /* Invalidate any cached export string */
      INVALIDATE_EXPORTSTR (entry);

#if defined (ARRAY_VARS)
      /* XXX -- this bears looking at again -- XXX */
      /* If an existing array variable x is being assigned to with x=b or
	 `read x' or something of that nature, silently convert it to
	 x[0]=b or `read x[0]'. */
      if (assoc_p (entry))
	{
	  assoc_insert (assoc_cell (entry), savestring ("0"), newval);
	  free (newval);
	}
      else if (array_p (entry))
	{
	  array_insert (array_cell (entry), 0, newval);
	  free (newval);
	}
      else
#endif
	{
	  FREE (value_cell (entry));
	  var_setvalue (entry, newval);
	}
    }

  if (mark_modified_vars)
    VSETATTR (entry, att_exported);

  if (exported_p (entry))
    array_needs_making = 1;

  return (entry);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:3,089
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:3,254
parsing error 
{
  SHELL_VAR *v, *nv;
  VAR_CONTEXT *vc, *nvc;

  if (shell_variables == 0)
    create_variable_tables ();

  /* If we have a temporary environment, look there first for the variable,
     and, if found, modify the value there before modifying it in the
     shell_variables table.  This allows sourced scripts to modify values
     given to them in a temporary environment while modifying the variable
     value that the caller sees. */
  if (temporary_env && value)		/* XXX - can value be null here? */
    bind_tempenv_variable (name, value);

  /* XXX -- handle local variables here. */
  for (vc = shell_variables; vc; vc = vc->down)
    {
      if (vc_isfuncenv (vc) || vc_isbltnenv (vc))
	{
	  v = hash_lookup (name, vc->table);
	  nvc = vc;
	  if (v && nameref_p (v))
	    {
	      /* This starts at the context where we found the nameref. If we
		 want to start the name resolution over again at the original
		 context, this is where we need to change it */
	      nv = find_variable_nameref_context (v, vc, &nvc);
	      if (nv == 0)
		{
		  nv = find_variable_last_nameref_context (v, vc, &nvc);
		  if (nv && nameref_p (nv))
		    {
		      /* If this nameref variable doesn't have a value yet,
			 set the value.  Otherwise, assign using the value as
			 normal. */
		      if (nameref_cell (nv) == 0)
			return (bind_variable_internal (nv->name, value, nvc->table, 0, flags));
#if defined (ARRAY_VARS)
		      else if (valid_array_reference (nameref_cell (nv), 0))
			return (assign_array_element (nameref_cell (nv), value, flags));
		      else
#endif
		      return (bind_variable_internal (nameref_cell (nv), value, nvc->table, 0, flags));
		    }
		  else if (nv == &nameref_maxloop_value)
		    {
		      internal_warning (_("%s: circular name reference"), v->name);
		      return (bind_global_variable (v->name, value, flags));
		    }
		  else
		    v = nv;
		}
	      else if (nv == &nameref_maxloop_value)
		{
		  internal_warning (_("%s: circular name reference"), v->name);
		  return (bind_global_variable (v->name, value, flags));
		}
	      else
	        v = nv;
	    }
	  if (v)
	    return (bind_variable_internal (v->name, value, nvc->table, 0, flags));
	}
    }
  /* bind_variable_internal will handle nameref resolution in this case */
  return (bind_variable_internal (name, value, global_variables->table, 0, flags));
}
warning: parse error {
  SHELL_VAR *v, *nv;
  VAR_CONTEXT *vc, *nvc;

  if (shell_variables == 0)
    create_variable_tables ();

  /* If we have a temporary environment, look there first for the variable,
     and, if found, modify the value there before modifying it in the
     shell_variables table.  This allows sourced scripts to modify values
     given to them in a temporary environment while modifying the variable
     value that the caller sees. */
  if (temporary_env && value)		/* XXX - can value be null here? */
    bind_tempenv_variable (name, value);

  /* XXX -- handle local variables here. */
  for (vc = shell_variables; vc; vc = vc->down)
    {
      if (vc_isfuncenv (vc) || vc_isbltnenv (vc))
	{
	  v = hash_lookup (name, vc->table);
	  nvc = vc;
	  if (v && nameref_p (v))
	    {
	      /* This starts at the context where we found the nameref. If we
		 want to start the name resolution over again at the original
		 context, this is where we need to change it */
	      nv = find_variable_nameref_context (v, vc, &nvc);
	      if (nv == 0)
		{
		  nv = find_variable_last_nameref_context (v, vc, &nvc);
		  if (nv && nameref_p (nv))
		    {
		      /* If this nameref variable doesn't have a value yet,
			 set the value.  Otherwise, assign using the value as
			 normal. */
		      if (nameref_cell (nv) == 0)
			return (bind_variable_internal (nv->name, value, nvc->table, 0, flags));
#if defined (ARRAY_VARS)
		      else if (valid_array_reference (nameref_cell (nv), 0))
			return (assign_array_element (nameref_cell (nv), value, flags));
		      else
#endif
		      return (bind_variable_internal (nameref_cell (nv), value, nvc->table, 0, flags));
		    }
		  else if (nv == &nameref_maxloop_value)
		    {
		      internal_warning (_("%s: circular name reference"), v->name);
		      return (bind_global_variable (v->name, value, flags));
		    }
		  else
		    v = nv;
		}
	      else if (nv == &nameref_maxloop_value)
		{
		  internal_warning (_("%s: circular name reference"), v->name);
		  return (bind_global_variable (v->name, value, flags));
		}
	      else
	        v = nv;
	    }
	  if (v)
	    return (bind_variable_internal (v->name, value, nvc->table, 0, flags));
	}
    }
  /* bind_variable_internal will handle nameref resolution in this case */
  return (bind_variable_internal (name, value, global_variables->table, 0, flags));
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:3,257
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:3,328
parsing error 
{
  if (shell_variables == 0)
    create_variable_tables ();

  /* bind_variable_internal will handle nameref resolution in this case */
  return (bind_variable_internal (name, value, global_variables->table, 0, flags));
}
warning: parse error {
  if (shell_variables == 0)
    create_variable_tables ();

  /* bind_variable_internal will handle nameref resolution in this case */
  return (bind_variable_internal (name, value, global_variables->table, 0, flags));
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:3,331
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:3,341
parsing error 
{
  if (invalid_env == 0)
    invalid_env = hash_create (64);	/* XXX */
  return (bind_variable_internal (name, value, invalid_env, HASH_NOSRCH, flags));
}
warning: parse error {
  if (invalid_env == 0)
    invalid_env = hash_create (64);	/* XXX */
  return (bind_variable_internal (name, value, invalid_env, HASH_NOSRCH, flags));
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:3,344
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:3,356
parsing error 
{
  char *t;
  int invis;

  invis = invisible_p (var);
  VUNSETATTR (var, att_invisible);

  if (var->assign_func)
    {
      /* If we're appending, we need the old value, so use
	 make_variable_value */
      t = (aflags & ASS_APPEND) ? make_variable_value (var, value, aflags) : value;
      (*(var->assign_func)) (var, t, -1, 0);
      if (t != value && t)
	free (t);      
    }
  else
    {
      t = make_variable_value (var, value, aflags);
      if ((aflags & (ASS_NAMEREF|ASS_FORCE)) == ASS_NAMEREF && check_selfref (name_cell (var), t, 0))
	{
	  if (variable_context)
	    internal_warning (_("%s: circular name reference"), name_cell (var));
	  else
	    {
	      internal_error (_("%s: nameref variable self references not allowed"), name_cell (var));
	      free (t);
	      if (invis)
		VSETATTR (var, att_invisible);	/* XXX */
	      return ((SHELL_VAR *)NULL);
	    }
	}
      if ((aflags & ASS_NAMEREF) && (valid_nameref_value (t, 0) == 0))
	{
	  free (t);
	  if (invis)
	    VSETATTR (var, att_invisible);	/* XXX */
	  return ((SHELL_VAR *)NULL);
	}
      FREE (value_cell (var));
      var_setvalue (var, t);
    }

  INVALIDATE_EXPORTSTR (var);

  if (mark_modified_vars)
    VSETATTR (var, att_exported);

  if (exported_p (var))
    array_needs_making = 1;

  return (var);
}
warning: parse error {
  char *t;
  int invis;

  invis = invisible_p (var);
  VUNSETATTR (var, att_invisible);

  if (var->assign_func)
    {
      /* If we're appending, we need the old value, so use
	 make_variable_value */
      t = (aflags & ASS_APPEND) ? make_variable_value (var, value, aflags) : value;
      (*(var->assign_func)) (var, t, -1, 0);
      if (t != value && t)
	free (t);      
    }
  else
    {
      t = make_variable_value (var, value, aflags);
      if ((aflags & (ASS_NAMEREF|ASS_FORCE)) == ASS_NAMEREF && check_selfref (name_cell (var), t, 0))
	{
	  if (variable_context)
	    internal_warning (_("%s: circular name reference"), name_cell (var));
	  else
	    {
	      internal_error (_("%s: nameref variable self references not allowed"), name_cell (var));
	      free (t);
	      if (invis)
		VSETATTR (var, att_invisible);	/* XXX */
	      return ((SHELL_VAR *)NULL);
	    }
	}
      if ((aflags & ASS_NAMEREF) && (valid_nameref_value (t, 0) == 0))
	{
	  free (t);
	  if (invis)
	    VSETATTR (var, att_invisible);	/* XXX */
	  return ((SHELL_VAR *)NULL);
	}
      FREE (value_cell (var));
      var_setvalue (var, t);
    }

  INVALIDATE_EXPORTSTR (var);

  if (mark_modified_vars)
    VSETATTR (var, att_exported);

  if (exported_p (var))
    array_needs_making = 1;

  return (var);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:3,360
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:3,425
parsing error 
{
  register SHELL_VAR *v;
  int isint, isarr, implicitarray;

  isint = isarr = implicitarray = 0;
#if defined (ARRAY_VARS)
  if (valid_array_reference (lhs, (flags & ASS_NOEXPAND) != 0))
    {
      isarr = 1;
      v = array_variable_part (lhs, (flags & ASS_NOEXPAND) != 0, (char **)0, (int *)0);
    }
  else if (legal_identifier (lhs) == 0)
    {
      sh_invalidid (lhs);
      return ((SHELL_VAR *)NULL);      
    }
  else
#endif
    v = find_variable (lhs);

  if (v)
    {
      isint = integer_p (v);
      VUNSETATTR (v, att_integer);
#if defined (ARRAY_VARS)
      if (array_p (v) && isarr == 0)
	implicitarray = 1;
#endif
    }

#if defined (ARRAY_VARS)
  if (isarr)
    v = assign_array_element (lhs, rhs, flags);
  else if (implicitarray)
    v = bind_array_variable (lhs, 0, rhs, 0);	/* XXX - check on flags */
  else
#endif
    v = bind_variable (lhs, rhs, 0);	/* why not use bind_variable_value? */

  if (v)
    {
      if (isint)
	VSETATTR (v, att_integer);
      VUNSETATTR (v, att_invisible);
    }

  if (v && nameref_p (v))
    internal_warning (_("%s: assigning integer to name reference"), lhs);
     
  return (v);
}
warning: parse error {
  register SHELL_VAR *v;
  int isint, isarr, implicitarray;

  isint = isarr = implicitarray = 0;
#if defined (ARRAY_VARS)
  if (valid_array_reference (lhs, (flags & ASS_NOEXPAND) != 0))
    {
      isarr = 1;
      v = array_variable_part (lhs, (flags & ASS_NOEXPAND) != 0, (char **)0, (int *)0);
    }
  else if (legal_identifier (lhs) == 0)
    {
      sh_invalidid (lhs);
      return ((SHELL_VAR *)NULL);      
    }
  else
#endif
    v = find_variable (lhs);

  if (v)
    {
      isint = integer_p (v);
      VUNSETATTR (v, att_integer);
#if defined (ARRAY_VARS)
      if (array_p (v) && isarr == 0)
	implicitarray = 1;
#endif
    }

#if defined (ARRAY_VARS)
  if (isarr)
    v = assign_array_element (lhs, rhs, flags);
  else if (implicitarray)
    v = bind_array_variable (lhs, 0, rhs, 0);	/* XXX - check on flags */
  else
#endif
    v = bind_variable (lhs, rhs, 0);	/* why not use bind_variable_value? */

  if (v)
    {
      if (isint)
	VSETATTR (v, att_integer);
      VUNSETATTR (v, att_invisible);
    }

  if (v && nameref_p (v))
    internal_warning (_("%s: assigning integer to name reference"), lhs);
     
  return (v);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:3,428
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:3,481
parsing error 
{
  char ibuf[INT_STRLEN_BOUND (intmax_t) + 1], *p;

  p = fmtulong (val, 10, ibuf, sizeof (ibuf), 0);
  return (bind_int_variable (var, p, 0));
}
warning: parse error {
  char ibuf[INT_STRLEN_BOUND (intmax_t) + 1], *p;

  p = fmtulong (val, 10, ibuf, sizeof (ibuf), 0);
  return (bind_int_variable (var, p, 0));
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:3,484
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:3,495
parsing error 
{
  SHELL_VAR *entry;

  entry = find_function (name);
  if (entry == 0)
    {
      BUCKET_CONTENTS *elt;

      elt = hash_insert (savestring (name), shell_functions, HASH_NOSRCH);
      entry = new_shell_variable (name);
      elt->data = (PTR_T)entry;
    }
  else
    INVALIDATE_EXPORTSTR (entry);

  if (var_isset (entry))
    dispose_command (function_cell (entry));

  if (value)
    var_setfunc (entry, copy_command (value));
  else
    var_setfunc (entry, 0);

  VSETATTR (entry, att_function);

  if (mark_modified_vars)
    VSETATTR (entry, att_exported);

  VUNSETATTR (entry, att_invisible);		/* Just to be sure */

  if (exported_p (entry))
    array_needs_making = 1;

#if defined (PROGRAMMABLE_COMPLETION)
  set_itemlist_dirty (&it_functions);
#endif

  return (entry);
}
warning: parse error {
  SHELL_VAR *entry;

  entry = find_function (name);
  if (entry == 0)
    {
      BUCKET_CONTENTS *elt;

      elt = hash_insert (savestring (name), shell_functions, HASH_NOSRCH);
      entry = new_shell_variable (name);
      elt->data = (PTR_T)entry;
    }
  else
    INVALIDATE_EXPORTSTR (entry);

  if (var_isset (entry))
    dispose_command (function_cell (entry));

  if (value)
    var_setfunc (entry, copy_command (value));
  else
    var_setfunc (entry, 0);

  VSETATTR (entry, att_function);

  if (mark_modified_vars)
    VSETATTR (entry, att_exported);

  VUNSETATTR (entry, att_invisible);		/* Just to be sure */

  if (exported_p (entry))
    array_needs_making = 1;

#if defined (PROGRAMMABLE_COMPLETION)
  set_itemlist_dirty (&it_functions);
#endif

  return (entry);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:3,497
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:3,578
parsing error 
{
  int offset, aflags;
  char *name, *temp, *value, *newname;
  SHELL_VAR *var;
  const char *string;

  string = word->word;

  aflags = 0;
  offset = assignment (string, 0);
  newname = name = savestring (string);
  value = (char *)NULL;

  if (name[offset] == '=')
    {
      name[offset] = 0;

      /* don't ignore the `+' when assigning temporary environment */
      if (name[offset - 1] == '+')
	{
	  name[offset - 1] = '\0';
	  aflags |= ASS_APPEND;
	}

      if (legal_identifier (name) == 0)
	{
	  sh_invalidid (name);
	  return (0);
	}
  
      var = find_variable (name);
      if (var == 0)
	{
	  var = find_variable_last_nameref (name, 1);
	  /* If we're assigning a value to a nameref variable in the temp
	     environment, and the value of the nameref is valid for assignment,
	     but the variable does not already exist, assign to the nameref
	     target and add the target to the temporary environment.  This is
	     what ksh93 does */
	  /* We use 2 in the call to valid_nameref_value because we don't want
	     to allow array references here at all (newname will be used to
	     create a variable directly below) */
	  if (var && nameref_p (var) && valid_nameref_value (nameref_cell (var), 2))
	    {
	      newname = nameref_cell (var);
	      var = 0;		/* don't use it for append */
	    }
	}
      else
        newname = name_cell (var);	/* no-op if not nameref */
	  
      if (var && (readonly_p (var) || noassign_p (var)))
	{
	  if (readonly_p (var))
	    err_readonly (name);
	  free (name);
  	  return (0);
	}
      temp = name + offset + 1;

      value = expand_assignment_string_to_string (temp, 0);

      if (var && (aflags & ASS_APPEND))
	{
	  if (value == 0)
	    {
	      value = (char *)xmalloc (1);	/* like do_assignment_internal */
	      value[0] = '\0';
	    }
	  temp = make_variable_value (var, value, aflags);
	  FREE (value);
	  value = temp;
	}
    }

  if (temporary_env == 0)
    temporary_env = hash_create (TEMPENV_HASH_BUCKETS);

  var = hash_lookup (newname, temporary_env);
  if (var == 0)
    var = make_new_variable (newname, temporary_env);
  else
    FREE (value_cell (var));

  if (value == 0)
    {
      value = (char *)xmalloc (1);	/* see above */
      value[0] = '\0';
    }

  var_setvalue (var, value);
  var->attributes |= (att_exported|att_tempvar);
  var->context = variable_context;	/* XXX */

  INVALIDATE_EXPORTSTR (var);
  var->exportstr = mk_env_string (newname, value, 0);

  array_needs_making = 1;

  if (flags)
    {
      if (STREQ (newname, "POSIXLY_CORRECT") || STREQ (newname, "POSIX_PEDANDTIC"))
	save_posix_options ();		/* XXX one level of saving right now */
      stupidly_hack_special_variables (newname);
    }

  if (echo_command_at_execute)
    /* The Korn shell prints the `+ ' in front of assignment statements,
	so we do too. */
    xtrace_print_assignment (name, value, 0, 1);

  free (name);
  return 1;
}
warning: parse error {
  int offset, aflags;
  char *name, *temp, *value, *newname;
  SHELL_VAR *var;
  const char *string;

  string = word->word;

  aflags = 0;
  offset = assignment (string, 0);
  newname = name = savestring (string);
  value = (char *)NULL;

  if (name[offset] == '=')
    {
      name[offset] = 0;

      /* don't ignore the `+' when assigning temporary environment */
      if (name[offset - 1] == '+')
	{
	  name[offset - 1] = '\0';
	  aflags |= ASS_APPEND;
	}

      if (legal_identifier (name) == 0)
	{
	  sh_invalidid (name);
	  return (0);
	}
  
      var = find_variable (name);
      if (var == 0)
	{
	  var = find_variable_last_nameref (name, 1);
	  /* If we're assigning a value to a nameref variable in the temp
	     environment, and the value of the nameref is valid for assignment,
	     but the variable does not already exist, assign to the nameref
	     target and add the target to the temporary environment.  This is
	     what ksh93 does */
	  /* We use 2 in the call to valid_nameref_value because we don't want
	     to allow array references here at all (newname will be used to
	     create a variable directly below) */
	  if (var && nameref_p (var) && valid_nameref_value (nameref_cell (var), 2))
	    {
	      newname = nameref_cell (var);
	      var = 0;		/* don't use it for append */
	    }
	}
      else
        newname = name_cell (var);	/* no-op if not nameref */
	  
      if (var && (readonly_p (var) || noassign_p (var)))
	{
	  if (readonly_p (var))
	    err_readonly (name);
	  free (name);
  	  return (0);
	}
      temp = name + offset + 1;

      value = expand_assignment_string_to_string (temp, 0);

      if (var && (aflags & ASS_APPEND))
	{
	  if (value == 0)
	    {
	      value = (char *)xmalloc (1);	/* like do_assignment_internal */
	      value[0] = '\0';
	    }
	  temp = make_variable_value (var, value, aflags);
	  FREE (value);
	  value = temp;
	}
    }

  if (temporary_env == 0)
    temporary_env = hash_create (TEMPENV_HASH_BUCKETS);

  var = hash_lookup (newname, temporary_env);
  if (var == 0)
    var = make_new_variable (newname, temporary_env);
  else
    FREE (value_cell (var));

  if (value == 0)
    {
      value = (char *)xmalloc (1);	/* see above */
      value[0] = '\0';
    }

  var_setvalue (var, value);
  var->attributes |= (att_exported|att_tempvar);
  var->context = variable_context;	/* XXX */

  INVALIDATE_EXPORTSTR (var);
  var->exportstr = mk_env_string (newname, value, 0);

  array_needs_making = 1;

  if (flags)
    {
      if (STREQ (newname, "POSIXLY_CORRECT") || STREQ (newname, "POSIX_PEDANDTIC"))
	save_posix_options ();		/* XXX one level of saving right now */
      stupidly_hack_special_variables (newname);
    }

  if (echo_command_at_execute)
    /* The Korn shell prints the `+ ' in front of assignment statements,
	so we do too. */
    xtrace_print_assignment (name, value, 0, 1);

  free (name);
  return 1;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:3,581
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:3,751
parsing error 
{
  if (function_p (var))
    dispose_command (function_cell (var));
#if defined (ARRAY_VARS)
  else if (array_p (var))
    array_dispose (array_cell (var));
  else if (assoc_p (var))
    assoc_dispose (assoc_cell (var));
#endif
  else if (nameref_p (var))
    FREE (nameref_cell (var));
  else
    FREE (value_cell (var));
}
warning: parse error {
  if (function_p (var))
    dispose_command (function_cell (var));
#if defined (ARRAY_VARS)
  else if (array_p (var))
    array_dispose (array_cell (var));
  else if (assoc_p (var))
    assoc_dispose (assoc_cell (var));
#endif
  else if (nameref_p (var))
    FREE (nameref_cell (var));
  else
    FREE (value_cell (var));
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:3,753
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:3,769
parsing error 
{
  if (var == 0)
    return;

  if (nofree_p (var) == 0)
    dispose_variable_value (var);

  FREE_EXPORTSTR (var);

  free (var->name);

  if (exported_p (var))
    array_needs_making = 1;

  free (var);
}
warning: parse error {
  if (var == 0)
    return;

  if (nofree_p (var) == 0)
    dispose_variable_value (var);

  FREE_EXPORTSTR (var);

  free (var->name);

  if (exported_p (var))
    array_needs_making = 1;

  free (var);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:3,771
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:3,792
parsing error 
{
  SHELL_VAR *v, *nv;
  int r;

  v = var_lookup (name, shell_variables);
  nv = (v && nameref_p (v)) ? find_variable_nameref (v) : (SHELL_VAR *)NULL;

  r = nv ? makunbound (nv->name, shell_variables) : makunbound (name, shell_variables);
  return r;
}
warning: parse error {
  SHELL_VAR *v, *nv;
  int r;

  v = var_lookup (name, shell_variables);
  nv = (v && nameref_p (v)) ? find_variable_nameref (v) : (SHELL_VAR *)NULL;

  r = nv ? makunbound (nv->name, shell_variables) : makunbound (name, shell_variables);
  return r;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:3,793
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:3,807
parsing error 
{
  SHELL_VAR *v;

  v = var_lookup (name, shell_variables);
  if (v && nameref_p (v))
    return makunbound (name, shell_variables);
  return 0;
}
warning: parse error {
  SHELL_VAR *v;

  v = var_lookup (name, shell_variables);
  if (v && nameref_p (v))
    return makunbound (name, shell_variables);
  return 0;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:3,808
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:3,820
parsing error 
{
  SHELL_VAR *v;

  v = var_lookup (name, shell_variables);
  if (v)
    return makunbound (name, shell_variables);
  return 0;
}
warning: parse error {
  SHELL_VAR *v;

  v = var_lookup (name, shell_variables);
  if (v)
    return makunbound (name, shell_variables);
  return 0;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:3,821
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:3,832
parsing error 
{
  SHELL_VAR *v;

  v = find_variable (name);
  if (v && readonly_p (v))
    {
      internal_error (_("%s: cannot unset: readonly %s"), name, "variable");
      return -2;
    }
  else if (v && non_unsettable_p (v))
    {
      internal_error (_("%s: cannot unset"), name);
      return -2;
    }
  return (unbind_variable (name));
}
warning: parse error {
  SHELL_VAR *v;

  v = find_variable (name);
  if (v && readonly_p (v))
    {
      internal_error (_("%s: cannot unset: readonly %s"), name, "variable");
      return -2;
    }
  else if (v && non_unsettable_p (v))
    {
      internal_error (_("%s: cannot unset"), name);
      return -2;
    }
  return (unbind_variable (name));
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:3,833
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:3,853
parsing error 
{
  BUCKET_CONTENTS *elt;
  SHELL_VAR *func;

  elt = hash_remove (name, shell_functions, 0);

  if (elt == 0)
    return -1;

#if defined (PROGRAMMABLE_COMPLETION)
  set_itemlist_dirty (&it_functions);
#endif

  func = (SHELL_VAR *)elt->data;
  if (func)
    {
      if (exported_p (func))
	array_needs_making++;
      dispose_variable (func);
    }

  free (elt->key);
  free (elt);

  return 0;  
}
warning: parse error {
  BUCKET_CONTENTS *elt;
  SHELL_VAR *func;

  elt = hash_remove (name, shell_functions, 0);

  if (elt == 0)
    return -1;

#if defined (PROGRAMMABLE_COMPLETION)
  set_itemlist_dirty (&it_functions);
#endif

  func = (SHELL_VAR *)elt->data;
  if (func)
    {
      if (exported_p (func))
	array_needs_making++;
      dispose_variable (func);
    }

  free (elt->key);
  free (elt);

  return 0;  
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:3,854
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:3,907
parsing error 
{
  BUCKET_CONTENTS *elt;
  SHELL_VAR *old_var;
  VAR_CONTEXT *v;

  for (elt = (BUCKET_CONTENTS *)NULL, v = vc; v; v = v->down)
    if (elt = hash_remove (name, v->table, 0))
      break;

  if (elt == 0)
    return (-1);

  old_var = (SHELL_VAR *)elt->data;
  free (elt->key);
  free (elt);

  dispose_variable (old_var);
  return (0);
}
warning: parse error {
  BUCKET_CONTENTS *elt;
  SHELL_VAR *old_var;
  VAR_CONTEXT *v;

  for (elt = (BUCKET_CONTENTS *)NULL, v = vc; v; v = v->down)
    if (elt = hash_remove (name, v->table, 0))
      break;

  if (elt == 0)
    return (-1);

  old_var = (SHELL_VAR *)elt->data;
  free (elt->key);
  free (elt);

  dispose_variable (old_var);
  return (0);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:3,909
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:3,935
parsing error 
{
  BUCKET_CONTENTS *elt, *new_elt;
  SHELL_VAR *old_var;
  VAR_CONTEXT *v;
  char *t;

  for (elt = (BUCKET_CONTENTS *)NULL, v = vc; v; v = v->down)
    if (elt = hash_remove (name, v->table, 0))
      break;

  if (elt == 0)
    return (-1);

  old_var = (SHELL_VAR *)elt->data;

  if (old_var && exported_p (old_var))
    array_needs_making++;

  /* If we're unsetting a local variable and we're still executing inside
     the function, just mark the variable as invisible.  The function
     eventually called by pop_var_context() will clean it up later.  This
     must be done so that if the variable is subsequently assigned a new
     value inside the function, the `local' attribute is still present.
     We also need to add it back into the correct hash table. */
  if (old_var && local_p (old_var) &&
	(old_var->context == variable_context || (localvar_unset && old_var->context < variable_context)))
    {
      if (nofree_p (old_var))
	var_setvalue (old_var, (char *)NULL);
#if defined (ARRAY_VARS)
      else if (array_p (old_var))
	array_dispose (array_cell (old_var));
      else if (assoc_p (old_var))
	assoc_dispose (assoc_cell (old_var));
#endif
      else if (nameref_p (old_var))
	FREE (nameref_cell (old_var));
      else
	FREE (value_cell (old_var));
      /* Reset the attributes.  Preserve the export attribute if the variable
	 came from a temporary environment.  Make sure it stays local, and
	 make it invisible. */ 
      old_var->attributes = (exported_p (old_var) && tempvar_p (old_var)) ? att_exported : 0;
      VSETATTR (old_var, att_local);
      VSETATTR (old_var, att_invisible);
      var_setvalue (old_var, (char *)NULL);
      INVALIDATE_EXPORTSTR (old_var);

      new_elt = hash_insert (savestring (old_var->name), v->table, 0);
      new_elt->data = (PTR_T)old_var;
      stupidly_hack_special_variables (old_var->name);

      free (elt->key);
      free (elt);
      return (0);
    }

  /* Have to save a copy of name here, because it might refer to
     old_var->name.  If so, stupidly_hack_special_variables will
     reference freed memory. */
  t = savestring (name);

  free (elt->key);
  free (elt);

  dispose_variable (old_var);
  stupidly_hack_special_variables (t);
  free (t);

  return (0);
}
warning: parse error {
  BUCKET_CONTENTS *elt, *new_elt;
  SHELL_VAR *old_var;
  VAR_CONTEXT *v;
  char *t;

  for (elt = (BUCKET_CONTENTS *)NULL, v = vc; v; v = v->down)
    if (elt = hash_remove (name, v->table, 0))
      break;

  if (elt == 0)
    return (-1);

  old_var = (SHELL_VAR *)elt->data;

  if (old_var && exported_p (old_var))
    array_needs_making++;

  /* If we're unsetting a local variable and we're still executing inside
     the function, just mark the variable as invisible.  The function
     eventually called by pop_var_context() will clean it up later.  This
     must be done so that if the variable is subsequently assigned a new
     value inside the function, the `local' attribute is still present.
     We also need to add it back into the correct hash table. */
  if (old_var && local_p (old_var) &&
	(old_var->context == variable_context || (localvar_unset && old_var->context < variable_context)))
    {
      if (nofree_p (old_var))
	var_setvalue (old_var, (char *)NULL);
#if defined (ARRAY_VARS)
      else if (array_p (old_var))
	array_dispose (array_cell (old_var));
      else if (assoc_p (old_var))
	assoc_dispose (assoc_cell (old_var));
#endif
      else if (nameref_p (old_var))
	FREE (nameref_cell (old_var));
      else
	FREE (value_cell (old_var));
      /* Reset the attributes.  Preserve the export attribute if the variable
	 came from a temporary environment.  Make sure it stays local, and
	 make it invisible. */ 
      old_var->attributes = (exported_p (old_var) && tempvar_p (old_var)) ? att_exported : 0;
      VSETATTR (old_var, att_local);
      VSETATTR (old_var, att_invisible);
      var_setvalue (old_var, (char *)NULL);
      INVALIDATE_EXPORTSTR (old_var);

      new_elt = hash_insert (savestring (old_var->name), v->table, 0);
      new_elt->data = (PTR_T)old_var;
      stupidly_hack_special_variables (old_var->name);

      free (elt->key);
      free (elt);
      return (0);
    }

  /* Have to save a copy of name here, because it might refer to
     old_var->name.  If so, stupidly_hack_special_variables will
     reference freed memory. */
  t = savestring (name);

  free (elt->key);
  free (elt);

  dispose_variable (old_var);
  stupidly_hack_special_variables (t);
  free (t);

  return (0);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:3,937
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:4,030
parsing error 
{
  SHELL_VAR *var;

  var = (SHELL_VAR *)data;
  dispose_variable (var);
}
warning: parse error {
  SHELL_VAR *var;

  var = (SHELL_VAR *)data;
  dispose_variable (var);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:4,032
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:4,041
parsing error 
{
  hash_flush (hashed_vars, free_variable_hash_data);
}
warning: parse error {
  hash_flush (hashed_vars, free_variable_hash_data);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:4,043
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:4,068
parsing error 
{
  SHELL_VAR *entry;

  FIND_OR_MAKE_VARIABLE (name, entry);
  VSETATTR (entry, att_readonly);
}
warning: parse error {
  SHELL_VAR *entry;

  FIND_OR_MAKE_VARIABLE (name, entry);
  VSETATTR (entry, att_readonly);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:4,070
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:4,123
parsing error 
{
  VARLIST  *vlist;

  vlist = (VARLIST *)xmalloc (sizeof (VARLIST));
  vlist->list = (SHELL_VAR **)xmalloc ((nentries + 1) * sizeof (SHELL_VAR *));
  vlist->list_size = nentries;
  vlist->list_len = 0;
  vlist->list[0] = (SHELL_VAR *)NULL;

  return vlist;
}
warning: parse error {
  VARLIST  *vlist;

  vlist = (VARLIST *)xmalloc (sizeof (VARLIST));
  vlist->list = (SHELL_VAR **)xmalloc ((nentries + 1) * sizeof (SHELL_VAR *));
  vlist->list_size = nentries;
  vlist->list_len = 0;
  vlist->list[0] = (SHELL_VAR *)NULL;

  return vlist;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:4,125
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:4,138
parsing error 
{
  if (vlist == 0)
    return (vlist = vlist_alloc (n));
  if (n > vlist->list_size)
    {
      vlist->list_size = n;
      vlist->list = (SHELL_VAR **)xrealloc (vlist->list, (vlist->list_size + 1) * sizeof (SHELL_VAR *));
    }
  return vlist;
}
warning: parse error {
  if (vlist == 0)
    return (vlist = vlist_alloc (n));
  if (n > vlist->list_size)
    {
      vlist->list_size = n;
      vlist->list = (SHELL_VAR **)xrealloc (vlist->list, (vlist->list_size + 1) * sizeof (SHELL_VAR *));
    }
  return vlist;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:4,141
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:4,153
parsing error 
{
  register int i;

  for (i = 0; i < vlist->list_len; i++)
    if (STREQ (var->name, vlist->list[i]->name))
      break;
  if (i < vlist->list_len)
    return;

  if (i >= vlist->list_size)
    vlist = vlist_realloc (vlist, vlist->list_size + 16);

  vlist->list[vlist->list_len++] = var;
  vlist->list[vlist->list_len] = (SHELL_VAR *)NULL;
}
warning: parse error {
  register int i;

  for (i = 0; i < vlist->list_len; i++)
    if (STREQ (var->name, vlist->list[i]->name))
      break;
  if (i < vlist->list_len)
    return;

  if (i >= vlist->list_size)
    vlist = vlist_realloc (vlist, vlist->list_size + 16);

  vlist->list[vlist->list_len++] = var;
  vlist->list[vlist->list_len] = (SHELL_VAR *)NULL;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:4,157
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:4,177
parsing error 
{
  VAR_CONTEXT *v;
  VARLIST *vlist;
  SHELL_VAR **ret;
  int nentries;

  for (nentries = 0, v = vc; v; v = v->down)
    nentries += HASH_ENTRIES (v->table);

  if (nentries == 0)
    return (SHELL_VAR **)NULL;

  vlist = vlist_alloc (nentries);

  for (v = vc; v; v = v->down)
    flatten (v->table, function, vlist, 0);

  ret = vlist->list;
  free (vlist);
  return ret;
}
warning: parse error {
  VAR_CONTEXT *v;
  VARLIST *vlist;
  SHELL_VAR **ret;
  int nentries;

  for (nentries = 0, v = vc; v; v = v->down)
    nentries += HASH_ENTRIES (v->table);

  if (nentries == 0)
    return (SHELL_VAR **)NULL;

  vlist = vlist_alloc (nentries);

  for (v = vc; v; v = v->down)
    flatten (v->table, function, vlist, 0);

  ret = vlist->list;
  free (vlist);
  return ret;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:4,180
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:4,203
parsing error 
{
  VARLIST *vlist;
  SHELL_VAR **ret;

  if (shell_functions == 0 || HASH_ENTRIES (shell_functions) == 0)
    return ((SHELL_VAR **)NULL);

  vlist = vlist_alloc (HASH_ENTRIES (shell_functions));

  flatten (shell_functions, function, vlist, 0);

  ret = vlist->list;
  free (vlist);
  return ret;
}
warning: parse error {
  VARLIST *vlist;
  SHELL_VAR **ret;

  if (shell_functions == 0 || HASH_ENTRIES (shell_functions) == 0)
    return ((SHELL_VAR **)NULL);

  vlist = vlist_alloc (HASH_ENTRIES (shell_functions));

  flatten (shell_functions, function, vlist, 0);

  ret = vlist->list;
  free (vlist);
  return ret;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:4,205
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:4,228
parsing error 
{
  register int i;
  register BUCKET_CONTENTS *tlist;
  int r;
  SHELL_VAR *var;

  if (var_hash_table == 0 || (HASH_ENTRIES (var_hash_table) == 0) || (vlist == 0 && func == 0))
    return;

  for (i = 0; i < var_hash_table->nbuckets; i++)
    {
      for (tlist = hash_items (i, var_hash_table); tlist; tlist = tlist->next)
	{
	  var = (SHELL_VAR *)tlist->data;

	  r = func ? (*func) (var) : 1;
	  if (r && vlist)
	    vlist_add (vlist, var, flags);
	}
    }
}
warning: parse error {
  register int i;
  register BUCKET_CONTENTS *tlist;
  int r;
  SHELL_VAR *var;

  if (var_hash_table == 0 || (HASH_ENTRIES (var_hash_table) == 0) || (vlist == 0 && func == 0))
    return;

  for (i = 0; i < var_hash_table->nbuckets; i++)
    {
      for (tlist = hash_items (i, var_hash_table); tlist; tlist = tlist->next)
	{
	  var = (SHELL_VAR *)tlist->data;

	  r = func ? (*func) (var) : 1;
	  if (r && vlist)
	    vlist_add (vlist, var, flags);
	}
    }
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:4,233
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:4,256
parsing error 
{
  qsort (array, strvec_len ((char **)array), sizeof (SHELL_VAR *), (QSFUNC *)qsort_var_comp);
}
warning: parse error {
  qsort (array, strvec_len ((char **)array), sizeof (SHELL_VAR *), (QSFUNC *)qsort_var_comp);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:4,258
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:4,263
parsing error 
{
  int result;

  if ((result = (*var1)->name[0] - (*var2)->name[0]) == 0)
    result = strcmp ((*var1)->name, (*var2)->name);

  return (result);
}
warning: parse error {
  int result;

  if ((result = (*var1)->name[0] - (*var2)->name[0]) == 0)
    result = strcmp ((*var1)->name, (*var2)->name);

  return (result);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:4,265
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:4,277
parsing error 
{
  SHELL_VAR **list;

  list = map_over (func, shell_variables);
  if (list /* && posixly_correct */)
    sort_variables (list);
  return (list);
}
warning: parse error {
  SHELL_VAR **list;

  list = map_over (func, shell_variables);
  if (list /* && posixly_correct */)
    sort_variables (list);
  return (list);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:4,279
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:4,291
parsing error 
{
  SHELL_VAR **list;

  list = map_over_funcs (func);
  if (list /* && posixly_correct */)
    sort_variables (list);
  return (list);
}
warning: parse error {
  SHELL_VAR **list;

  list = map_over_funcs (func);
  if (list /* && posixly_correct */)
    sort_variables (list);
  return (list);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:4,293
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:4,317
parsing error 
{
  return (invisible_p (var) == 0);
}
warning: parse error {
  return (invisible_p (var) == 0);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:4,319
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:4,338
parsing error 
{
  return (invisible_p (var) == 0 && exported_p (var));
}
warning: parse error {
  return (invisible_p (var) == 0 && exported_p (var));
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:4,340
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:4,348
parsing error 
{
  return (exported_p (var) && (invisible_p (var) == 0 || imported_p (var)));
}
warning: parse error {
  return (exported_p (var) && (invisible_p (var) == 0 || imported_p (var)));
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:4,350
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:4,357
parsing error 
{
  return (invisible_p (var) == 0 && local_p (var) && var->context == variable_context && exported_p (var));
}
warning: parse error {
  return (invisible_p (var) == 0 && local_p (var) && var->context == variable_context && exported_p (var));
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:4,359
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:4,376
parsing error 
{
  return (local_p (var) && var->context == variable_context);
}
warning: parse error {
  return (local_p (var) && var->context == variable_context);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:4,378
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:4,383
parsing error 
{
  return (invisible_p (var) == 0 && local_p (var) && var->context == variable_context);
}
warning: parse error {
  return (invisible_p (var) == 0 && local_p (var) && var->context == variable_context);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:4,385
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:4,390
parsing error 
{
  VARLIST *vlist;
  SHELL_VAR **ret;
  VAR_CONTEXT *vc;

  vc = shell_variables;
  for (vc = shell_variables; vc; vc = vc->down)
    if (vc_isfuncenv (vc) && vc->scope == variable_context)
      break;

  if (vc == 0)
    {
      internal_error (_("all_local_variables: no function context at current scope"));
      return (SHELL_VAR **)NULL;
    }
  if (vc->table == 0 || HASH_ENTRIES (vc->table) == 0 || vc_haslocals (vc) == 0)
    return (SHELL_VAR **)NULL;
    
  vlist = vlist_alloc (HASH_ENTRIES (vc->table));

  if (visible_only)
    flatten (vc->table, visible_variable_in_context, vlist, 0);
  else
    flatten (vc->table, variable_in_context, vlist, 0);

  ret = vlist->list;
  free (vlist);
  if (ret)
    sort_variables (ret);
  return ret;
}
warning: parse error {
  VARLIST *vlist;
  SHELL_VAR **ret;
  VAR_CONTEXT *vc;

  vc = shell_variables;
  for (vc = shell_variables; vc; vc = vc->down)
    if (vc_isfuncenv (vc) && vc->scope == variable_context)
      break;

  if (vc == 0)
    {
      internal_error (_("all_local_variables: no function context at current scope"));
      return (SHELL_VAR **)NULL;
    }
  if (vc->table == 0 || HASH_ENTRIES (vc->table) == 0 || vc_haslocals (vc) == 0)
    return (SHELL_VAR **)NULL;
    
  vlist = vlist_alloc (HASH_ENTRIES (vc->table));

  if (visible_only)
    flatten (vc->table, visible_variable_in_context, vlist, 0);
  else
    flatten (vc->table, variable_in_context, vlist, 0);

  ret = vlist->list;
  free (vlist);
  if (ret)
    sort_variables (ret);
  return ret;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:4,392
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:4,442
parsing error 
{
  SHELL_VAR **varlist;
  char **rlist;
  int vind, rind, plen;

  plen = STRLEN (prefix);
  varlist = all_visible_variables ();
  for (vind = 0; varlist && varlist[vind]; vind++)
    ;
  if (varlist == 0 || vind == 0)
    return ((char **)NULL);
  rlist = strvec_create (vind + 1);
  for (vind = rind = 0; varlist[vind]; vind++)
    {
      if (plen == 0 || STREQN (prefix, varlist[vind]->name, plen))
	rlist[rind++] = savestring (varlist[vind]->name);
    }
  rlist[rind] = (char *)0;
  free (varlist);

  return rlist;
}
warning: parse error {
  SHELL_VAR **varlist;
  char **rlist;
  int vind, rind, plen;

  plen = STRLEN (prefix);
  varlist = all_visible_variables ();
  for (vind = 0; varlist && varlist[vind]; vind++)
    ;
  if (varlist == 0 || vind == 0)
    return ((char **)NULL);
  rlist = strvec_create (vind + 1);
  for (vind = rind = 0; varlist[vind]; vind++)
    {
      if (plen == 0 || STREQN (prefix, varlist[vind]->name, plen))
	rlist[rind++] = savestring (varlist[vind]->name);
    }
  rlist[rind] = (char *)0;
  free (varlist);

  return rlist;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:4,443
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:4,475
parsing error 
{
  SHELL_VAR *var;

  var = temporary_env ? hash_lookup (name, temporary_env) : (SHELL_VAR *)NULL;

  if (var)
    {
      FREE (value_cell (var));
      var_setvalue (var, savestring (value));
      INVALIDATE_EXPORTSTR (var);
    }

  return (var);
}
warning: parse error {
  SHELL_VAR *var;

  var = temporary_env ? hash_lookup (name, temporary_env) : (SHELL_VAR *)NULL;

  if (var)
    {
      FREE (value_cell (var));
      var_setvalue (var, savestring (value));
      INVALIDATE_EXPORTSTR (var);
    }

  return (var);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:4,477
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:4,496
parsing error 
{
  return (temporary_env ? hash_lookup (name, temporary_env) : (SHELL_VAR *)NULL);
}
warning: parse error {
  return (temporary_env ? hash_lookup (name, temporary_env) : (SHELL_VAR *)NULL);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:4,497
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:4,509
parsing error 
{
  SHELL_VAR *var, *v;
  HASH_TABLE *binding_table;

  var = (SHELL_VAR *)data;

  /* Just like do_assignment_internal(). This makes assignments preceding
     special builtins act like standalone assignment statements when in
     posix mode, satisfying the posix requirement that this affect the
     "current execution environment." */
  v = bind_variable (var->name, value_cell (var), ASS_FORCE|ASS_NOLONGJMP);

  /* XXX - do we need to worry about array variables here? */

  /* If this modifies an existing local variable, v->context will be non-zero.
     If it comes back with v->context == 0, we bound at the global context.
     Set binding_table appropriately. It doesn't matter whether it's correct
     if the variable is local, only that it's not global_variables->table */
  binding_table = v->context ? shell_variables->table : global_variables->table;

  /* global variables are no longer temporary and don't need propagating. */
  if (v->context == 0)
    var->attributes &= ~(att_tempvar|att_propagate);

  if (v)
    {
      v->attributes |= var->attributes;		/* preserve tempvar attribute if appropriate */
      /* If we don't bind a local variable, propagate the value. If we bind a
	 local variable (the "current execution environment"), keep it as local
	 and don't propagate it to the calling environment. */
      if (v->context > 0 && local_p (v) == 0)
	v->attributes |= att_propagate;
      else
	v->attributes &= ~att_propagate;
    }

  if (find_special_var (var->name) >= 0)
    tempvar_list[tvlist_ind++] = savestring (var->name);

  dispose_variable (var);
}
warning: parse error {
  SHELL_VAR *var, *v;
  HASH_TABLE *binding_table;

  var = (SHELL_VAR *)data;

  /* Just like do_assignment_internal(). This makes assignments preceding
     special builtins act like standalone assignment statements when in
     posix mode, satisfying the posix requirement that this affect the
     "current execution environment." */
  v = bind_variable (var->name, value_cell (var), ASS_FORCE|ASS_NOLONGJMP);

  /* XXX - do we need to worry about array variables here? */

  /* If this modifies an existing local variable, v->context will be non-zero.
     If it comes back with v->context == 0, we bound at the global context.
     Set binding_table appropriately. It doesn't matter whether it's correct
     if the variable is local, only that it's not global_variables->table */
  binding_table = v->context ? shell_variables->table : global_variables->table;

  /* global variables are no longer temporary and don't need propagating. */
  if (v->context == 0)
    var->attributes &= ~(att_tempvar|att_propagate);

  if (v)
    {
      v->attributes |= var->attributes;		/* preserve tempvar attribute if appropriate */
      /* If we don't bind a local variable, propagate the value. If we bind a
	 local variable (the "current execution environment"), keep it as local
	 and don't propagate it to the calling environment. */
      if (v->context > 0 && local_p (v) == 0)
	v->attributes |= att_propagate;
      else
	v->attributes &= ~att_propagate;
    }

  if (find_special_var (var->name) >= 0)
    tempvar_list[tvlist_ind++] = savestring (var->name);

  dispose_variable (var);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:4,511
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:4,564
parsing error 
{
  SHELL_VAR *var, *v;
  HASH_TABLE *binding_table;

  var = (SHELL_VAR *)data;

  binding_table = shell_variables->table;
  if (binding_table == 0)
    {
      if (shell_variables == global_variables)
	/* shouldn't happen */
	binding_table = shell_variables->table = global_variables->table = hash_create (VARIABLES_HASH_BUCKETS);
      else
	binding_table = shell_variables->table = hash_create (TEMPENV_HASH_BUCKETS);
    }

  v = bind_variable_internal (var->name, value_cell (var), binding_table, 0, ASS_FORCE|ASS_NOLONGJMP);

  /* XXX - should we set the context here?  It shouldn't matter because of how
     assign_in_env works, but we do it anyway. */
  if (v)
    v->context = shell_variables->scope;

  if (binding_table == global_variables->table)		/* XXX */
    var->attributes &= ~(att_tempvar|att_propagate);
  else
    {
      var->attributes |= att_propagate;			/* XXX - propagate more than once? */
      if  (binding_table == shell_variables->table)
	shell_variables->flags |= VC_HASTMPVAR;
    }
  if (v)
    v->attributes |= var->attributes;

  if (find_special_var (var->name) >= 0)
    tempvar_list[tvlist_ind++] = savestring (var->name);

  dispose_variable (var);
}
warning: parse error {
  SHELL_VAR *var, *v;
  HASH_TABLE *binding_table;

  var = (SHELL_VAR *)data;

  binding_table = shell_variables->table;
  if (binding_table == 0)
    {
      if (shell_variables == global_variables)
	/* shouldn't happen */
	binding_table = shell_variables->table = global_variables->table = hash_create (VARIABLES_HASH_BUCKETS);
      else
	binding_table = shell_variables->table = hash_create (TEMPENV_HASH_BUCKETS);
    }

  v = bind_variable_internal (var->name, value_cell (var), binding_table, 0, ASS_FORCE|ASS_NOLONGJMP);

  /* XXX - should we set the context here?  It shouldn't matter because of how
     assign_in_env works, but we do it anyway. */
  if (v)
    v->context = shell_variables->scope;

  if (binding_table == global_variables->table)		/* XXX */
    var->attributes &= ~(att_tempvar|att_propagate);
  else
    {
      var->attributes |= att_propagate;			/* XXX - propagate more than once? */
      if  (binding_table == shell_variables->table)
	shell_variables->flags |= VC_HASTMPVAR;
    }
  if (v)
    v->attributes |= var->attributes;

  if (find_special_var (var->name) >= 0)
    tempvar_list[tvlist_ind++] = savestring (var->name);

  dispose_variable (var);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:4,566
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:4,611
parsing error 
{
  SHELL_VAR *var;

  var = (SHELL_VAR *)data;
  if (tempvar_p (var) && (var->attributes & att_propagate))
    push_temp_var (data);
  else
    {
      if (find_special_var (var->name) >= 0)
	tempvar_list[tvlist_ind++] = savestring (var->name);
      dispose_variable (var);
    }
}
warning: parse error {
  SHELL_VAR *var;

  var = (SHELL_VAR *)data;
  if (tempvar_p (var) && (var->attributes & att_propagate))
    push_temp_var (data);
  else
    {
      if (find_special_var (var->name) >= 0)
	tempvar_list[tvlist_ind++] = savestring (var->name);
      dispose_variable (var);
    }
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:4,613
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:4,635
parsing error 
{
  int i;
  HASH_TABLE *disposer;

  tempvar_list = strvec_create (HASH_ENTRIES (temporary_env) + 1);
  tempvar_list[tvlist_ind = 0] = 0;

  disposer = temporary_env;
  temporary_env = (HASH_TABLE *)NULL;

  hash_flush (disposer, pushf);
  hash_dispose (disposer);

  tempvar_list[tvlist_ind] = 0;

  array_needs_making = 1;

  for (i = 0; i < tvlist_ind; i++)
    stupidly_hack_special_variables (tempvar_list[i]);

  strvec_dispose (tempvar_list);
  tempvar_list = 0;
  tvlist_ind = 0;
}
warning: parse error {
  int i;
  HASH_TABLE *disposer;

  tempvar_list = strvec_create (HASH_ENTRIES (temporary_env) + 1);
  tempvar_list[tvlist_ind = 0] = 0;

  disposer = temporary_env;
  temporary_env = (HASH_TABLE *)NULL;

  hash_flush (disposer, pushf);
  hash_dispose (disposer);

  tempvar_list[tvlist_ind] = 0;

  array_needs_making = 1;

  for (i = 0; i < tvlist_ind; i++)
    stupidly_hack_special_variables (tempvar_list[i]);

  strvec_dispose (tempvar_list);
  tempvar_list = 0;
  tvlist_ind = 0;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:4,637
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:4,712
parsing error 
{
  size_t name_len, value_len;
  char	*p, *q, *t;

  name_len = strlen (name);
  value_len = STRLEN (value);

  /* If we are exporting a shell function, construct the encoded function
     name. */
  if (isfunc && value)
    {
      p = (char *)xmalloc (BASHFUNC_PREFLEN + name_len + BASHFUNC_SUFFLEN + value_len + 2);
      q = p;
      memcpy (q, BASHFUNC_PREFIX, BASHFUNC_PREFLEN);
      q += BASHFUNC_PREFLEN;
      memcpy (q, name, name_len);
      q += name_len;
      memcpy (q, BASHFUNC_SUFFIX, BASHFUNC_SUFFLEN);
      q += BASHFUNC_SUFFLEN;
    }
  else
    {
      p = (char *)xmalloc (2 + name_len + value_len);
      memcpy (p, name, name_len);
      q = p + name_len;
    }

  q[0] = '=';
  if (value && *value)
    {
      if (isfunc)
	{
	  t = dequote_escapes (value);
	  value_len = STRLEN (t);
	  memcpy (q + 1, t, value_len + 1);
	  free (t);
	}
      else
	memcpy (q + 1, value, value_len + 1);
    }
  else
    q[1] = '\0';

  return (p);
}
warning: parse error {
  size_t name_len, value_len;
  char	*p, *q, *t;

  name_len = strlen (name);
  value_len = STRLEN (value);

  /* If we are exporting a shell function, construct the encoded function
     name. */
  if (isfunc && value)
    {
      p = (char *)xmalloc (BASHFUNC_PREFLEN + name_len + BASHFUNC_SUFFLEN + value_len + 2);
      q = p;
      memcpy (q, BASHFUNC_PREFIX, BASHFUNC_PREFLEN);
      q += BASHFUNC_PREFLEN;
      memcpy (q, name, name_len);
      q += name_len;
      memcpy (q, BASHFUNC_SUFFIX, BASHFUNC_SUFFLEN);
      q += BASHFUNC_SUFFLEN;
    }
  else
    {
      p = (char *)xmalloc (2 + name_len + value_len);
      memcpy (p, name, name_len);
      q = p + name_len;
    }

  q[0] = '=';
  if (value && *value)
    {
      if (isfunc)
	{
	  t = dequote_escapes (value);
	  value_len = STRLEN (t);
	  memcpy (q + 1, t, value_len + 1);
	  free (t);
	}
      else
	memcpy (q + 1, value, value_len + 1);
    }
  else
    q[1] = '\0';

  return (p);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:4,714
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:4,799
parsing error 
{
  register int i, list_index;
  register SHELL_VAR *var;
  char **list, *value;

  list = strvec_create ((1 + strvec_len ((char **)vars)));

#define USE_EXPORTSTR (value == var->exportstr)

  for (i = 0, list_index = 0; var = vars[i]; i++)
    {
#if defined (__CYGWIN__)
      /* We don't use the exportstr stuff on Cygwin at all. */
      INVALIDATE_EXPORTSTR (var);
#endif

      /* If the value is generated dynamically, generate it here. */
      if (regen_p (var) && var->dynamic_value)
	{
	  var = (*(var->dynamic_value)) (var);
	  INVALIDATE_EXPORTSTR (var);
	}

      if (var->exportstr)
	value = var->exportstr;
      else if (function_p (var))
	value = named_function_string ((char *)NULL, function_cell (var), 0);
#if defined (ARRAY_VARS)
      else if (array_p (var))
#  if ARRAY_EXPORT
	value = array_to_assign (array_cell (var), 0);
#  else
	continue;	/* XXX array vars cannot yet be exported */
#  endif /* ARRAY_EXPORT */
      else if (assoc_p (var))
#  if 0
	value = assoc_to_assign (assoc_cell (var), 0);
#  else
	continue;	/* XXX associative array vars cannot yet be exported */
#  endif
#endif
      else
	value = value_cell (var);

      if (value)
	{
	  /* Gee, I'd like to get away with not using savestring() if we're
	     using the cached exportstr... */
	  list[list_index] = USE_EXPORTSTR ? savestring (value)
					   : mk_env_string (var->name, value, function_p (var));
	  if (USE_EXPORTSTR == 0)
	    SAVE_EXPORTSTR (var, list[list_index]);

	  list_index++;
#undef USE_EXPORTSTR

#if 0	/* not yet */
#if defined (ARRAY_VARS)
	  if (array_p (var) || assoc_p (var))
	    free (value);
#endif
#endif
	}
    }

  list[list_index] = (char *)NULL;
  return (list);
}
warning: parse error {
  register int i, list_index;
  register SHELL_VAR *var;
  char **list, *value;

  list = strvec_create ((1 + strvec_len ((char **)vars)));

#define USE_EXPORTSTR (value == var->exportstr)

  for (i = 0, list_index = 0; var = vars[i]; i++)
    {
#if defined (__CYGWIN__)
      /* We don't use the exportstr stuff on Cygwin at all. */
      INVALIDATE_EXPORTSTR (var);
#endif

      /* If the value is generated dynamically, generate it here. */
      if (regen_p (var) && var->dynamic_value)
	{
	  var = (*(var->dynamic_value)) (var);
	  INVALIDATE_EXPORTSTR (var);
	}

      if (var->exportstr)
	value = var->exportstr;
      else if (function_p (var))
	value = named_function_string ((char *)NULL, function_cell (var), 0);
#if defined (ARRAY_VARS)
      else if (array_p (var))
#  if ARRAY_EXPORT
	value = array_to_assign (array_cell (var), 0);
#  else
	continue;	/* XXX array vars cannot yet be exported */
#  endif /* ARRAY_EXPORT */
      else if (assoc_p (var))
#  if 0
	value = assoc_to_assign (assoc_cell (var), 0);
#  else
	continue;	/* XXX associative array vars cannot yet be exported */
#  endif
#endif
      else
	value = value_cell (var);

      if (value)
	{
	  /* Gee, I'd like to get away with not using savestring() if we're
	     using the cached exportstr... */
	  list[list_index] = USE_EXPORTSTR ? savestring (value)
					   : mk_env_string (var->name, value, function_p (var));
	  if (USE_EXPORTSTR == 0)
	    SAVE_EXPORTSTR (var, list[list_index]);

	  list_index++;
#undef USE_EXPORTSTR

#if 0	/* not yet */
#if defined (ARRAY_VARS)
	  if (array_p (var) || assoc_p (var))
	    free (value);
#endif
#endif
	}
    }

  list[list_index] = (char *)NULL;
  return (list);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:4,801
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:4,874
parsing error 
{
  char **list;
  SHELL_VAR **vars;

#if 0
  vars = map_over (visible_and_exported, vcxt);
#else
  vars = map_over (export_environment_candidate, vcxt);
#endif

  if (vars == 0)
    return (char **)NULL;

  list = make_env_array_from_var_list (vars);

  free (vars);
  return (list);
}
warning: parse error {
  char **list;
  SHELL_VAR **vars;

#if 0
  vars = map_over (visible_and_exported, vcxt);
#else
  vars = map_over (export_environment_candidate, vcxt);
#endif

  if (vars == 0)
    return (char **)NULL;

  list = make_env_array_from_var_list (vars);

  free (vars);
  return (list);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:4,876
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:4,928
parsing error 
{
  register int i;
  int equal_offset;

  equal_offset = assignment (assign, 0);
  if (equal_offset == 0)
    return (export_env);

  /* If this is a function, then only supersede the function definition.
     We do this by including the `=() {' in the comparison, like
     initialize_shell_variables does. */
  if (assign[equal_offset + 1] == '(' &&
     strncmp (assign + equal_offset + 2, ") {", 3) == 0)		/* } */
    equal_offset += 4;

  for (i = 0; i < export_env_index; i++)
    {
      if (STREQN (assign, export_env[i], equal_offset + 1))
	{
	  free (export_env[i]);
	  export_env[i] = do_alloc ? savestring (assign) : assign;
	  return (export_env);
	}
    }
  add_to_export_env (assign, do_alloc);
  return (export_env);
}
warning: parse error {
  register int i;
  int equal_offset;

  equal_offset = assignment (assign, 0);
  if (equal_offset == 0)
    return (export_env);

  /* If this is a function, then only supersede the function definition.
     We do this by including the `=() {' in the comparison, like
     initialize_shell_variables does. */
  if (assign[equal_offset + 1] == '(' &&
     strncmp (assign + equal_offset + 2, ") {", 3) == 0)		/* } */
    equal_offset += 4;

  for (i = 0; i < export_env_index; i++)
    {
      if (STREQN (assign, export_env[i], equal_offset + 1))
	{
	  free (export_env[i]);
	  export_env[i] = do_alloc ? savestring (assign) : assign;
	  return (export_env);
	}
    }
  add_to_export_env (assign, do_alloc);
  return (export_env);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:4,931
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:4,960
parsing error 
{
  register int i;

  if (temp_array == 0)
    return;

  for (i = 0; temp_array[i]; i++)
    {
      if (do_supercede)
	export_env = add_or_supercede_exported_var (temp_array[i], do_alloc);
      else
	add_to_export_env (temp_array[i], do_alloc);
    }

  free (temp_array);
}
warning: parse error {
  register int i;

  if (temp_array == 0)
    return;

  for (i = 0; temp_array[i]; i++)
    {
      if (do_supercede)
	export_env = add_or_supercede_exported_var (temp_array[i], do_alloc);
      else
	add_to_export_env (temp_array[i], do_alloc);
    }

  free (temp_array);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:4,963
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:5,008
parsing error 
{
  SHELL_VAR *v;

  v = find_variable (name);
  if (v && exported_p (v))
    {
      array_needs_making = 1;
      maybe_make_export_env ();
      return 1;
    }
  return 0;
}
warning: parse error {
  SHELL_VAR *v;

  v = find_variable (name);
  if (v && exported_p (v))
    {
      array_needs_making = 1;
      maybe_make_export_env ();
      return 1;
    }
  return 0;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:5,010
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:5,104
parsing error 
{
  char *evar;

  evar = (char *)xmalloc (STRLEN (value) + preflen + 1);
  strcpy (evar, env_prefix);
  if (value)
    strcpy (evar + preflen, value);
  export_env = add_or_supercede_exported_var (evar, 0);
}
warning: parse error {
  char *evar;

  evar = (char *)xmalloc (STRLEN (value) + preflen + 1);
  strcpy (evar, env_prefix);
  if (value)
    strcpy (evar + preflen, value);
  export_env = add_or_supercede_exported_var (evar, 0);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:5,108
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:5,120
parsing error 
{
  update_export_env_inplace ("_=", 2, command_name);
}
warning: parse error {
  update_export_env_inplace ("_=", 2, command_name);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:5,122
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:5,136
parsing error 
{
  VAR_CONTEXT *vc;

  vc = (VAR_CONTEXT *)xmalloc (sizeof (VAR_CONTEXT));
  vc->name = name ? savestring (name) : (char *)NULL;
  vc->scope = variable_context;
  vc->flags = flags;

  vc->up = vc->down = (VAR_CONTEXT *)NULL;
  vc->table = (HASH_TABLE *)NULL;

  return vc;
}
warning: parse error {
  VAR_CONTEXT *vc;

  vc = (VAR_CONTEXT *)xmalloc (sizeof (VAR_CONTEXT));
  vc->name = name ? savestring (name) : (char *)NULL;
  vc->scope = variable_context;
  vc->flags = flags;

  vc->up = vc->down = (VAR_CONTEXT *)NULL;
  vc->table = (HASH_TABLE *)NULL;

  return vc;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:5,139
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:5,156
parsing error 
{
  FREE (vc->name);

  if (vc->table)
    {
      delete_all_variables (vc->table);
      hash_dispose (vc->table);
    }

  free (vc);
}
warning: parse error {
  FREE (vc->name);

  if (vc->table)
    {
      delete_all_variables (vc->table);
      hash_dispose (vc->table);
    }

  free (vc);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:5,158
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:5,172
parsing error 
{
  return (var->context = variable_context);
}
warning: parse error {
  return (var->context = variable_context);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:5,174
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:5,182
parsing error 
{
  VAR_CONTEXT *vc;
  int posix_func_behavior;

  /* As of IEEE Std 1003.1-2017, assignment statements preceding shell
     functions no longer behave like assignment statements preceding
     special builtins, and do not persist in the current shell environment.
     This is austin group interp #654, though nobody implements it yet. */
  posix_func_behavior = 0;

  vc = new_var_context (name, flags);
  /* Posix interp 1009, temporary assignments preceding function calls modify
     the current environment *before* the command is executed. */
  if (posix_func_behavior && (flags & VC_FUNCENV) && tempvars == temporary_env)
    merge_temporary_env ();
  else if (tempvars)
    {
      vc->table = tempvars;
      /* Have to do this because the temp environment was created before
	 variable_context was incremented. */
      /* XXX - only need to do it if flags&VC_FUNCENV */
      flatten (tempvars, set_context, (VARLIST *)NULL, 0);
      vc->flags |= VC_HASTMPVAR;
    }
  vc->down = shell_variables;
  shell_variables->up = vc;

  return (shell_variables = vc);
}
warning: parse error {
  VAR_CONTEXT *vc;
  int posix_func_behavior;

  /* As of IEEE Std 1003.1-2017, assignment statements preceding shell
     functions no longer behave like assignment statements preceding
     special builtins, and do not persist in the current shell environment.
     This is austin group interp #654, though nobody implements it yet. */
  posix_func_behavior = 0;

  vc = new_var_context (name, flags);
  /* Posix interp 1009, temporary assignments preceding function calls modify
     the current environment *before* the command is executed. */
  if (posix_func_behavior && (flags & VC_FUNCENV) && tempvars == temporary_env)
    merge_temporary_env ();
  else if (tempvars)
    {
      vc->table = tempvars;
      /* Have to do this because the temp environment was created before
	 variable_context was incremented. */
      /* XXX - only need to do it if flags&VC_FUNCENV */
      flatten (tempvars, set_context, (VARLIST *)NULL, 0);
      vc->flags |= VC_HASTMPVAR;
    }
  vc->down = shell_variables;
  shell_variables->up = vc;

  return (shell_variables = vc);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:5,186
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:5,229
parsing error 
{
  SHELL_VAR *v;
  int posix_var_behavior;

  /* As of IEEE Std 1003.1-2017, assignment statements preceding shell
     functions no longer behave like assignment statements preceding
     special builtins, and do not persist in the current shell environment.
     This is austin group interp #654, though nobody implements it yet. */
  posix_var_behavior = posixly_correct && isbltin;
  v = 0;

  if (local_p (var) && STREQ (var->name, "-"))
    {
      set_current_options (value_cell (var));
      set_shellopts ();
    }
  /* This takes variable assignments preceding special builtins that can execute
     multiple commands (source, eval, etc.) and performs the equivalent of
     an assignment statement to modify the closest enclosing variable (the
     posix "current execution environment"). This makes the behavior the same
     as push_posix_temp_var; but the circumstances of calling are slightly
     different. */
  else if (tempvar_p (var) && posix_var_behavior)
    {
      /* similar to push_posix_temp_var */
      v = bind_variable (var->name, value_cell (var), ASS_FORCE|ASS_NOLONGJMP);
      if (v)
	{
	  v->attributes |= var->attributes;
	  if (v->context == 0)
	    v->attributes &= ~(att_tempvar|att_propagate);
	  /* XXX - set att_propagate here if v->context > 0? */
	}
    }
  else if (tempvar_p (var) && propagate_p (var))
    {
      /* Make sure we have a hash table to store the variable in while it is
	 being propagated down to the global variables table.  Create one if
	 we have to */
      if ((vc_isfuncenv (shell_variables) || vc_istempenv (shell_variables)) && shell_variables->table == 0)
	shell_variables->table = hash_create (VARIABLES_HASH_BUCKETS);
      v = bind_variable_internal (var->name, value_cell (var), shell_variables->table, 0, 0);
      /* XXX - should we set v->context here? */
      if (v)
	v->context = shell_variables->scope;
      if (shell_variables == global_variables)
	var->attributes &= ~(att_tempvar|att_propagate);
      else
	shell_variables->flags |= VC_HASTMPVAR;
      if (v)
	v->attributes |= var->attributes;
    }
  else
    stupidly_hack_special_variables (var->name);	/* XXX */

#if defined (ARRAY_VARS)
  if (v && (array_p (var) || assoc_p (var)))
    {
      FREE (value_cell (v));
      if (array_p (var))
	var_setarray (v, array_copy (array_cell (var)));
      else
	var_setassoc (v, assoc_copy (assoc_cell (var)));
    }
#endif	  

  dispose_variable (var);
}
warning: parse error {
  SHELL_VAR *v;
  int posix_var_behavior;

  /* As of IEEE Std 1003.1-2017, assignment statements preceding shell
     functions no longer behave like assignment statements preceding
     special builtins, and do not persist in the current shell environment.
     This is austin group interp #654, though nobody implements it yet. */
  posix_var_behavior = posixly_correct && isbltin;
  v = 0;

  if (local_p (var) && STREQ (var->name, "-"))
    {
      set_current_options (value_cell (var));
      set_shellopts ();
    }
  /* This takes variable assignments preceding special builtins that can execute
     multiple commands (source, eval, etc.) and performs the equivalent of
     an assignment statement to modify the closest enclosing variable (the
     posix "current execution environment"). This makes the behavior the same
     as push_posix_temp_var; but the circumstances of calling are slightly
     different. */
  else if (tempvar_p (var) && posix_var_behavior)
    {
      /* similar to push_posix_temp_var */
      v = bind_variable (var->name, value_cell (var), ASS_FORCE|ASS_NOLONGJMP);
      if (v)
	{
	  v->attributes |= var->attributes;
	  if (v->context == 0)
	    v->attributes &= ~(att_tempvar|att_propagate);
	  /* XXX - set att_propagate here if v->context > 0? */
	}
    }
  else if (tempvar_p (var) && propagate_p (var))
    {
      /* Make sure we have a hash table to store the variable in while it is
	 being propagated down to the global variables table.  Create one if
	 we have to */
      if ((vc_isfuncenv (shell_variables) || vc_istempenv (shell_variables)) && shell_variables->table == 0)
	shell_variables->table = hash_create (VARIABLES_HASH_BUCKETS);
      v = bind_variable_internal (var->name, value_cell (var), shell_variables->table, 0, 0);
      /* XXX - should we set v->context here? */
      if (v)
	v->context = shell_variables->scope;
      if (shell_variables == global_variables)
	var->attributes &= ~(att_tempvar|att_propagate);
      else
	shell_variables->flags |= VC_HASTMPVAR;
      if (v)
	v->attributes |= var->attributes;
    }
  else
    stupidly_hack_special_variables (var->name);	/* XXX */

#if defined (ARRAY_VARS)
  if (v && (array_p (var) || assoc_p (var)))
    {
      FREE (value_cell (v));
      if (array_p (var))
	var_setarray (v, array_copy (array_cell (var)));
      else
	var_setassoc (v, assoc_copy (assoc_cell (var)));
    }
#endif	  

  dispose_variable (var);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:5,232
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:5,302
parsing error 
{
  SHELL_VAR *var;

  var = (SHELL_VAR *)data;
  push_posix_tempvar_internal (var, 0);
}
warning: parse error {
  SHELL_VAR *var;

  var = (SHELL_VAR *)data;
  push_posix_tempvar_internal (var, 0);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:5,304
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:5,312
parsing error 
{
  SHELL_VAR *var;

  var = (SHELL_VAR *)data;
  push_posix_tempvar_internal (var, 1);
}
warning: parse error {
  SHELL_VAR *var;

  var = (SHELL_VAR *)data;
  push_posix_tempvar_internal (var, 1);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:5,314
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:5,350
parsing error 
{
  VAR_CONTEXT *v, *t;

  for (v = vcxt; v != global_variables; v = t)
    {
      t = v->down;
      dispose_var_context (v);
    }    

  delete_all_variables (global_variables->table);
  shell_variables = global_variables;
}
warning: parse error {
  VAR_CONTEXT *v, *t;

  for (v = vcxt; v != global_variables; v = t)
    {
      t = v->down;
      dispose_var_context (v);
    }    

  delete_all_variables (global_variables->table);
  shell_variables = global_variables;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:5,352
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:5,372
parsing error 
{
  return (push_var_context ((char *)NULL, flags, tmpvars));
}
warning: parse error {
  return (push_var_context ((char *)NULL, flags, tmpvars));
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:5,375
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:5,380
parsing error 
{
  SHELL_VAR *var, *v;

  var = (SHELL_VAR *)data;

  /* If a temp var had its export attribute set, or it's marked to be
     propagated, bind it in the previous scope before disposing it. */
  /* XXX - This isn't exactly right, because all tempenv variables have the
    export attribute set. */
  if (tempvar_p (var) && exported_p (var) && (var->attributes & att_propagate))
    {
      var->attributes &= ~att_tempvar;		/* XXX */
      v = bind_variable_internal (var->name, value_cell (var), shell_variables->table, 0, 0);
      if (shell_variables == global_variables)
	var->attributes &= ~att_propagate;
      if (v)
	{
	  v->attributes |= var->attributes;
	  v->context = shell_variables->scope;
	}
    }
  else
    stupidly_hack_special_variables (var->name);	/* XXX */

  dispose_variable (var);
}
warning: parse error {
  SHELL_VAR *var, *v;

  var = (SHELL_VAR *)data;

  /* If a temp var had its export attribute set, or it's marked to be
     propagated, bind it in the previous scope before disposing it. */
  /* XXX - This isn't exactly right, because all tempenv variables have the
    export attribute set. */
  if (tempvar_p (var) && exported_p (var) && (var->attributes & att_propagate))
    {
      var->attributes &= ~att_tempvar;		/* XXX */
      v = bind_variable_internal (var->name, value_cell (var), shell_variables->table, 0, 0);
      if (shell_variables == global_variables)
	var->attributes &= ~att_propagate;
      if (v)
	{
	  v->attributes |= var->attributes;
	  v->context = shell_variables->scope;
	}
    }
  else
    stupidly_hack_special_variables (var->name);	/* XXX */

  dispose_variable (var);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:5,382
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:5,415
parsing error 
{
  VAR_CONTEXT *vcxt, *ret;
  int is_bltinenv;

  vcxt = shell_variables;
  if (vc_istempscope (vcxt) == 0)
    {
      internal_error (_("pop_scope: head of shell_variables not a temporary environment scope"));
      return;
    }
  is_bltinenv = vc_isbltnenv (vcxt);	/* XXX - for later */

  ret = vcxt->down;
  if (ret)
    ret->up = (VAR_CONTEXT *)NULL;

  shell_variables = ret;

  /* Now we can take care of merging variables in VCXT into set of scopes
     whose head is RET (shell_variables). */
  FREE (vcxt->name);
  if (vcxt->table)
    {
      if (is_special)
	hash_flush (vcxt->table, push_builtin_var);
      else
	hash_flush (vcxt->table, push_exported_var);
      hash_dispose (vcxt->table);
    }
  free (vcxt);

  sv_ifs ("IFS");	/* XXX here for now */
}
warning: parse error {
  VAR_CONTEXT *vcxt, *ret;
  int is_bltinenv;

  vcxt = shell_variables;
  if (vc_istempscope (vcxt) == 0)
    {
      internal_error (_("pop_scope: head of shell_variables not a temporary environment scope"));
      return;
    }
  is_bltinenv = vc_isbltnenv (vcxt);	/* XXX - for later */

  ret = vcxt->down;
  if (ret)
    ret->up = (VAR_CONTEXT *)NULL;

  shell_variables = ret;

  /* Now we can take care of merging variables in VCXT into set of scopes
     whose head is RET (shell_variables). */
  FREE (vcxt->name);
  if (vcxt->table)
    {
      if (is_special)
	hash_flush (vcxt->table, push_builtin_var);
      else
	hash_flush (vcxt->table, push_exported_var);
      hash_dispose (vcxt->table);
    }
  free (vcxt);

  sv_ifs ("IFS");	/* XXX here for now */
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:5,417
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:5,485
parsing error 
{
  int i;

  for (i = 1; i < 10; i++)
    dollar_vars[i] = args[i];
}
warning: parse error {
  int i;

  for (i = 1; i < 10; i++)
    dollar_vars[i] = args[i];
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:5,487
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:5,507
parsing error 
{
  int i;

  for (i = 1; i < 10; i++)
    FREE (args[i]);
}
warning: parse error {
  int i;

  for (i = 1; i < 10; i++)
    FREE (args[i]);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:5,509
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:5,529
parsing error 
{
  if (is_subshell == 0)
    push_dollar_vars ();
  variable_context++;
  push_var_context (name, VC_FUNCENV, tempvars);
}
warning: parse error {
  if (is_subshell == 0)
    push_dollar_vars ();
  variable_context++;
  push_var_context (name, VC_FUNCENV, tempvars);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:5,533
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:5,636
parsing error 
{
#if defined (ARRAY_VARS) && defined (DEBUGGER)
  SHELL_VAR *bash_argv_v, *bash_argc_v;
  ARRAY *bash_argv_a, *bash_argc_a;
  WORD_LIST *l;
  arrayind_t i;
  char *t;

  GET_ARRAY_FROM_VAR ("BASH_ARGV", bash_argv_v, bash_argv_a);
  GET_ARRAY_FROM_VAR ("BASH_ARGC", bash_argc_v, bash_argc_a);

  for (l = list, i = 0; l; l = l->next, i++)
    array_push (bash_argv_a, l->word->word);

  t = itos (i);
  array_push (bash_argc_a, t);
  free (t);
#endif /* ARRAY_VARS && DEBUGGER */
}
warning: parse error {
#if defined (ARRAY_VARS) && defined (DEBUGGER)
  SHELL_VAR *bash_argv_v, *bash_argc_v;
  ARRAY *bash_argv_a, *bash_argc_a;
  WORD_LIST *l;
  arrayind_t i;
  char *t;

  GET_ARRAY_FROM_VAR ("BASH_ARGV", bash_argv_v, bash_argv_a);
  GET_ARRAY_FROM_VAR ("BASH_ARGC", bash_argc_v, bash_argc_a);

  for (l = list, i = 0; l; l = l->next, i++)
    array_push (bash_argv_a, l->word->word);

  t = itos (i);
  array_push (bash_argc_a, t);
  free (t);
#endif /* ARRAY_VARS && DEBUGGER */
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:5,638
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:5,791
parsing error 
{
  int r;

  if ((r = sv1->name[0] - sv2->name[0]) == 0)
    r = strcmp (sv1->name, sv2->name);
  return r;
}
warning: parse error {
  int r;

  if ((r = sv1->name[0] - sv2->name[0]) == 0)
    r = strcmp (sv1->name, sv2->name);
  return r;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:5,793
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:5,803
parsing error 
{
  register int i, r;

  for (i = 0; special_vars[i].name; i++)
    {
      r = special_vars[i].name[0] - name[0];
      if (r == 0)
	r = strcmp (special_vars[i].name, name);
      if (r == 0)
	return i;
      else if (r > 0)
	/* Can't match any of rest of elements in sorted list.  Take this out
	   if it causes problems in certain environments. */
	break;
    }
  return -1;
}
warning: parse error {
  register int i, r;

  for (i = 0; special_vars[i].name; i++)
    {
      r = special_vars[i].name[0] - name[0];
      if (r == 0)
	r = strcmp (special_vars[i].name, name);
      if (r == 0)
	return i;
      else if (r > 0)
	/* Can't match any of rest of elements in sorted list.  Take this out
	   if it causes problems in certain environments. */
	break;
    }
  return -1;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:5,804
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:5,825
parsing error 
{
  static int sv_sorted = 0;
  int i;

  if (sv_sorted == 0)	/* shouldn't need, but it's fairly cheap. */
    {
      qsort (special_vars, N_SPECIAL_VARS, sizeof (special_vars[0]),
		(QSFUNC *)sv_compare);
      sv_sorted = 1;
    }

  i = find_special_var (name);
  if (i != -1)
    (*(special_vars[i].function)) (name);
}
warning: parse error {
  static int sv_sorted = 0;
  int i;

  if (sv_sorted == 0)	/* shouldn't need, but it's fairly cheap. */
    {
      qsort (special_vars, N_SPECIAL_VARS, sizeof (special_vars[0]),
		(QSFUNC *)sv_compare);
      sv_sorted = 1;
    }

  i = find_special_var (name);
  if (i != -1)
    (*(special_vars[i].function)) (name);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:5,827
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:5,856
parsing error 
{
  SHELL_VAR *v;

  v = find_variable ("IFS");
  setifs (v);
}
warning: parse error {
  SHELL_VAR *v;

  v = find_variable ("IFS");
  setifs (v);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:5,858
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:5,867
parsing error 
{
  /* hash -r */
  phash_flush ();
}
warning: parse error {
  /* hash -r */
  phash_flush ();
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:5,869
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:5,878
parsing error 
{
  /* If the time interval for checking the files has changed, then
     reset the mail timer.  Otherwise, one of the pathname vars
     to the users mailbox has changed, so rebuild the array of
     filenames. */
  if (name[4] == 'C')  /* if (strcmp (name, "MAILCHECK") == 0) */
    reset_mail_timer ();
  else
    {
      free_mail_files ();
      remember_mail_dates ();
    }
}
warning: parse error {
  /* If the time interval for checking the files has changed, then
     reset the mail timer.  Otherwise, one of the pathname vars
     to the users mailbox has changed, so rebuild the array of
     filenames. */
  if (name[4] == 'C')  /* if (strcmp (name, "MAILCHECK") == 0) */
    reset_mail_timer ();
  else
    {
      free_mail_files ();
      remember_mail_dates ();
    }
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:5,880
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:5,895
parsing error 
{
  SHELL_VAR *v;
  intmax_t num;

  v = find_variable (name);
  if (v == 0)
    funcnest_max = 0;
  else if (legal_number (value_cell (v), &num) == 0)
    funcnest_max = 0;
  else
    funcnest_max = num;
}
warning: parse error {
  SHELL_VAR *v;
  intmax_t num;

  v = find_variable (name);
  if (v == 0)
    funcnest_max = 0;
  else if (legal_number (value_cell (v), &num) == 0)
    funcnest_max = 0;
  else
    funcnest_max = num;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:5,897
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:5,912
parsing error 
{
  setup_exec_ignore (name);
}
warning: parse error {
  setup_exec_ignore (name);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:5,914
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:5,920
parsing error 
{
  if (privileged_mode == 0)
    setup_glob_ignore (name);
}
warning: parse error {
  if (privileged_mode == 0)
    setup_glob_ignore (name);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:5,922
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:6,161
parsing error 
{
  SHELL_VAR *tmp_var;
  char *temp;

  eof_encountered = 0;

  tmp_var = find_variable (name);
  ignoreeof = tmp_var && var_isset (tmp_var);
  temp = tmp_var ? value_cell (tmp_var) : (char *)NULL;
  if (temp)
    eof_encountered_limit = (*temp && all_digits (temp)) ? atoi (temp) : 10;
  set_shellopts ();	/* make sure `ignoreeof' is/is not in $SHELLOPTS */
}
warning: parse error {
  SHELL_VAR *tmp_var;
  char *temp;

  eof_encountered = 0;

  tmp_var = find_variable (name);
  ignoreeof = tmp_var && var_isset (tmp_var);
  temp = tmp_var ? value_cell (tmp_var) : (char *)NULL;
  if (temp)
    eof_encountered_limit = (*temp && all_digits (temp)) ? atoi (temp) : 10;
  set_shellopts ();	/* make sure `ignoreeof' is/is not in $SHELLOPTS */
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:6,163
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:6,178
parsing error 
{
  SHELL_VAR *var;
  char *tt;
  int s;

  var = find_variable ("OPTIND");
  tt = var ? get_variable_value (var) : (char *)NULL;

  /* Assume that if var->context < variable_context and variable_context > 0
     then we are restoring the variables's previous state while returning
     from a function. */
  if (tt && *tt)
    {
      s = atoi (tt);

      /* According to POSIX, setting OPTIND=1 resets the internal state
	 of getopt (). */
      if (s < 0 || s == 1)
	s = 0;
    }
  else
    s = 0;
  getopts_reset (s);
}
warning: parse error {
  SHELL_VAR *var;
  char *tt;
  int s;

  var = find_variable ("OPTIND");
  tt = var ? get_variable_value (var) : (char *)NULL;

  /* Assume that if var->context < variable_context and variable_context > 0
     then we are restoring the variables's previous state while returning
     from a function. */
  if (tt && *tt)
    {
      s = atoi (tt);

      /* According to POSIX, setting OPTIND=1 resets the internal state
	 of getopt (). */
      if (s < 0 || s == 1)
	s = 0;
    }
  else
    s = 0;
  getopts_reset (s);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:6,180
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:6,206
parsing error 
{
  char *tt;

  tt = get_string_value ("OPTERR");
  sh_opterr = (tt && *tt) ? atoi (tt) : 1;
}
warning: parse error {
  char *tt;

  tt = get_string_value ("OPTERR");
  sh_opterr = (tt && *tt) ? atoi (tt) : 1;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:6,208
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:6,216
parsing error 
{
  SHELL_VAR *var;

  var = find_variable (name);
  posixly_correct = var && var_isset (var);
  posix_initialize (posixly_correct);
#if defined (READLINE)
  if (interactive_shell)
    posix_readline_initialize (posixly_correct);
#endif /* READLINE */
  set_shellopts ();	/* make sure `posix' is/is not in $SHELLOPTS */
}
warning: parse error {
  SHELL_VAR *var;

  var = find_variable (name);
  posixly_correct = var && var_isset (var);
  posix_initialize (posixly_correct);
#if defined (READLINE)
  if (interactive_shell)
    posix_readline_initialize (posixly_correct);
#endif /* READLINE */
  set_shellopts ();	/* make sure `posix' is/is not in $SHELLOPTS */
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:6,218
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:6,232
parsing error 
{
  char *v;
  int r;

  v = get_string_value (name);
  if (name[0] == 'L' && name[1] == 'A')	/* LANG */
    r = set_lang (name, v);
  else
    r = set_locale_var (name, v);		/* LC_*, TEXTDOMAIN* */

#if 1
  if (r == 0 && posixly_correct)
    set_exit_status (EXECUTION_FAILURE);
#endif
}
warning: parse error {
  char *v;
  int r;

  v = get_string_value (name);
  if (name[0] == 'L' && name[1] == 'A')	/* LANG */
    r = set_lang (name, v);
  else
    r = set_locale_var (name, v);		/* LC_*, TEXTDOMAIN* */

#if 1
  if (r == 0 && posixly_correct)
    set_exit_status (EXECUTION_FAILURE);
#endif
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:6,234
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:6,350
parsing error 
{
#if defined (ARRAY_VARS)
  static int v[2] = { 0, -1 };

  v[0] = s;
  set_pipestatus_array (v, 1);
#endif
}
warning: parse error {
#if defined (ARRAY_VARS)
  static int v[2] = { 0, -1 };

  v[0] = s;
  set_pipestatus_array (v, 1);
#endif
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:6,352
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:6,362
parsing error 
{
  SHELL_VAR *v;
  char *t, *e;
  int fd;
  FILE *fp;

  v = find_variable (name);
  if (v == 0)
    {
      xtrace_reset ();
      return;
    }

  t = value_cell (v);
  if (t == 0 || *t == 0)
    xtrace_reset ();
  else
    {
      fd = (int)strtol (t, &e, 10);
      if (e != t && *e == '\0' && sh_validfd (fd))
	{
	  fp = fdopen (fd, "w");
	  if (fp == 0)
	    internal_error (_("%s: %s: cannot open as FILE"), name, value_cell (v));
	  else
	    xtrace_set (fd, fp);
	}
      else
	internal_error (_("%s: %s: invalid value for trace file descriptor"), name, value_cell (v));
    }
}
warning: parse error {
  SHELL_VAR *v;
  char *t, *e;
  int fd;
  FILE *fp;

  v = find_variable (name);
  if (v == 0)
    {
      xtrace_reset ();
      return;
    }

  t = value_cell (v);
  if (t == 0 || *t == 0)
    xtrace_reset ();
  else
    {
      fd = (int)strtol (t, &e, 10);
      if (e != t && *e == '\0' && sh_validfd (fd))
	{
	  fp = fdopen (fd, "w");
	  if (fp == 0)
	    internal_error (_("%s: %s: cannot open as FILE"), name, value_cell (v));
	  else
	    xtrace_set (fd, fp);
	}
      else
	internal_error (_("%s: %s: invalid value for trace file descriptor"), name, value_cell (v));
    }
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:6,364
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:6,399
parsing error 
{
  SHELL_VAR *v;
  char *val;
  int tens, ones, compatval;

  v = find_variable (name);
  if (v == 0)
    {
      shell_compatibility_level = DEFAULT_COMPAT_LEVEL;
      set_compatibility_opts ();
      return;
    }
  val = value_cell (v);
  if (val == 0 || *val == '\0')
    {
      shell_compatibility_level = DEFAULT_COMPAT_LEVEL;
      set_compatibility_opts ();
      return;
    }
  /* Handle decimal-like compatibility version specifications: 4.2 */
  if (ISDIGIT (val[0]) && val[1] == '.' && ISDIGIT (val[2]) && val[3] == 0)
    {
      tens = val[0] - '0';
      ones = val[2] - '0';
      compatval = tens*10 + ones;
    }
  /* Handle integer-like compatibility version specifications: 42 */
  else if (ISDIGIT (val[0]) && ISDIGIT (val[1]) && val[2] == 0)
    {
      tens = val[0] - '0';
      ones = val[1] - '0';
      compatval = tens*10 + ones;
    }
  else
    {
compat_error:
      internal_error (_("%s: %s: compatibility value out of range"), name, val);
      shell_compatibility_level = DEFAULT_COMPAT_LEVEL;
      set_compatibility_opts ();
      return;
    }

  if (compatval < MIN_COMPAT_LEVEL || compatval > DEFAULT_COMPAT_LEVEL)
    goto compat_error;

  shell_compatibility_level = compatval;
  set_compatibility_opts ();
}
warning: parse error {
  SHELL_VAR *v;
  char *val;
  int tens, ones, compatval;

  v = find_variable (name);
  if (v == 0)
    {
      shell_compatibility_level = DEFAULT_COMPAT_LEVEL;
      set_compatibility_opts ();
      return;
    }
  val = value_cell (v);
  if (val == 0 || *val == '\0')
    {
      shell_compatibility_level = DEFAULT_COMPAT_LEVEL;
      set_compatibility_opts ();
      return;
    }
  /* Handle decimal-like compatibility version specifications: 4.2 */
  if (ISDIGIT (val[0]) && val[1] == '.' && ISDIGIT (val[2]) && val[3] == 0)
    {
      tens = val[0] - '0';
      ones = val[2] - '0';
      compatval = tens*10 + ones;
    }
  /* Handle integer-like compatibility version specifications: 42 */
  else if (ISDIGIT (val[0]) && ISDIGIT (val[1]) && val[2] == 0)
    {
      tens = val[0] - '0';
      ones = val[1] - '0';
      compatval = tens*10 + ones;
    }
  else
    {
compat_error:
      internal_error (_("%s: %s: compatibility value out of range"), name, val);
      shell_compatibility_level = DEFAULT_COMPAT_LEVEL;
      set_compatibility_opts ();
      return;
    }

  if (compatval < MIN_COMPAT_LEVEL || compatval > DEFAULT_COMPAT_LEVEL)
    goto compat_error;

  shell_compatibility_level = compatval;
  set_compatibility_opts ();
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\variables.c:6,401
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\version.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\stdc.h...skip
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\patchlevel.h...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\conftypes.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashintl.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\version.c:83
parsing error 
{
  printf (_("GNU bash, version %s (%s)\n"), shell_version_string (), MACHTYPE);
  if (extended)
    {
      printf ("%s\n", _(bash_copyright));
      printf ("%s\n", _(bash_license));
      printf ("%s\n", _("This is free software; you are free to change and redistribute it."));
      printf ("%s\n", _("There is NO WARRANTY, to the extent permitted by law."));
    }
}
warning: parse error {
  printf (_("GNU bash, version %s (%s)\n"), shell_version_string (), MACHTYPE);
  if (extended)
    {
      printf ("%s\n", _(bash_copyright));
      printf ("%s\n", _(bash_license));
      printf ("%s\n", _("This is free software; you are free to change and redistribute it."));
      printf ("%s\n", _("There is NO WARRANTY, to the extent permitted by law."));
    }
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\version.c:85
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\xmalloc.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashtypes.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\error.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashintl.h...skip
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\lib\malloc\shmalloc.h...
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\xmalloc.c:88
parsing error 
{
#if HAVE_SBRK && defined (USING_BASH_MALLOC)
      allocated = findbrk ();
      fatal_error (_("%s: cannot allocate %lu bytes (%lu bytes allocated)"), func, (unsigned long)bytes, (unsigned long)allocated);
#else
      fatal_error (_("%s: cannot allocate %lu bytes"), func, (unsigned long)bytes);
#endif /* !HAVE_SBRK */
}
warning: parse error {
#if HAVE_SBRK && defined (USING_BASH_MALLOC)
      allocated = findbrk ();
      fatal_error (_("%s: cannot allocate %lu bytes (%lu bytes allocated)"), func, (unsigned long)bytes, (unsigned long)allocated);
#else
      fatal_error (_("%s: cannot allocate %lu bytes"), func, (unsigned long)bytes);
#endif /* !HAVE_SBRK */
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\xmalloc.c:90
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\xmalloc.c:103
parsing error 
{
  PTR_T temp;

#if defined (DEBUG)
  if (bytes == 0)
    internal_warning("xmalloc: size argument is 0");
#endif

  FINDBRK();
  temp = malloc (bytes);

  if (temp == 0)
    allocerr ("xmalloc", bytes);

  return (temp);
}
warning: parse error {
  PTR_T temp;

#if defined (DEBUG)
  if (bytes == 0)
    internal_warning("xmalloc: size argument is 0");
#endif

  FINDBRK();
  temp = malloc (bytes);

  if (temp == 0)
    allocerr ("xmalloc", bytes);

  return (temp);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\xmalloc.c:105
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\xmalloc.c:123
parsing error 
{
  PTR_T temp;

#if defined (DEBUG)
  if (bytes == 0)
    internal_warning("xrealloc: size argument is 0");
#endif

  FINDBRK();
  temp = pointer ? realloc (pointer, bytes) : malloc (bytes);

  if (temp == 0)
    allocerr ("xrealloc", bytes);

  return (temp);
}
warning: parse error {
  PTR_T temp;

#if defined (DEBUG)
  if (bytes == 0)
    internal_warning("xrealloc: size argument is 0");
#endif

  FINDBRK();
  temp = pointer ? realloc (pointer, bytes) : malloc (bytes);

  if (temp == 0)
    allocerr ("xrealloc", bytes);

  return (temp);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\xmalloc.c:126
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\xmalloc.c:146
parsing error 
{
  if (string)
    free (string);
}
warning: parse error {
  if (string)
    free (string);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\xmalloc.c:148
parsing E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\y.tab.c...
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashtypes.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashansi.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\filecntl.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\chartypes.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\memalloc.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\bashintl.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\shell.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\execute_cmd.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\typemax.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\trap.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\flags.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\parser.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\mailcheck.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\test.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\builtins\common.h...skip
already parsed E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\include\shmbutil.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\y.tab.c:3,685
parsing error 
{
  bash_input.type = type;
  FREE (bash_input.name);
  bash_input.name = name ? savestring (name) : (char *)NULL;

  /* XXX */
#if defined (CRAY)
  memcpy((char *)&bash_input.location.string, (char *)&location.string, sizeof(location));
#else
  bash_input.location = location;
#endif
  bash_input.getter = get;
  bash_input.ungetter = unget;
}
warning: parse error {
  bash_input.type = type;
  FREE (bash_input.name);
  bash_input.name = name ? savestring (name) : (char *)NULL;

  /* XXX */
#if defined (CRAY)
  memcpy((char *)&bash_input.location.string, (char *)&location.string, sizeof(location));
#else
  bash_input.location = location;
#endif
  bash_input.getter = get;
  bash_input.ungetter = unget;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\y.tab.c:3,691
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\y.tab.c:3,722
parsing error 
{
  return (*(bash_input.ungetter)) (c);
}
warning: parse error {
  return (*(bash_input.ungetter)) (c);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\y.tab.c:3,724
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\y.tab.c:3,888
parsing error 
{
  *(--bash_input.location.string) = c;
  return (c);
}
warning: parse error {
  *(--bash_input.location.string) = c;
  return (c);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\y.tab.c:3,890
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\y.tab.c:3,896
parsing error 
{
  INPUT_STREAM location;

  location.string = string;
  init_yy_io (yy_string_get, yy_string_unget, st_string, name, location);
}
warning: parse error {
  INPUT_STREAM location;

  location.string = string;
  init_yy_io (yy_string_get, yy_string_unget, st_string, name, location);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\y.tab.c:3,899
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\y.tab.c:3,961
parsing error 
{
  return (ungetc_with_restart (c, bash_input.location.file));
}
warning: parse error {
  return (ungetc_with_restart (c, bash_input.location.file));
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\y.tab.c:3,963
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\y.tab.c:3,968
parsing error 
{
  INPUT_STREAM location;

  location.file = stream;
  init_yy_io (yy_stream_get, yy_stream_unget, st_stream, name, location);
}
warning: parse error {
  INPUT_STREAM location;

  location.file = stream;
  init_yy_io (yy_stream_get, yy_stream_unget, st_stream, name, location);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\y.tab.c:3,971
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\y.tab.c:4,001
parsing error 
{
  STREAM_SAVER *saver = (STREAM_SAVER *)xmalloc (sizeof (STREAM_SAVER));

  xbcopy ((char *)&bash_input, (char *)&(saver->bash_input), sizeof (BASH_INPUT));

#if defined (BUFFERED_INPUT)
  saver->bstream = (BUFFERED_STREAM *)NULL;
  /* If we have a buffered stream, clear out buffers[fd]. */
  if (bash_input.type == st_bstream && bash_input.location.buffered_fd >= 0)
    saver->bstream = set_buffered_stream (bash_input.location.buffered_fd,
    					  (BUFFERED_STREAM *)NULL);
#endif /* BUFFERED_INPUT */

  saver->line = line_number;
  bash_input.name = (char *)NULL;
  saver->next = stream_list;
  stream_list = saver;
  EOF_Reached = 0;
  if (reset_lineno)
    line_number = 0;
}
warning: parse error {
  STREAM_SAVER *saver = (STREAM_SAVER *)xmalloc (sizeof (STREAM_SAVER));

  xbcopy ((char *)&bash_input, (char *)&(saver->bash_input), sizeof (BASH_INPUT));

#if defined (BUFFERED_INPUT)
  saver->bstream = (BUFFERED_STREAM *)NULL;
  /* If we have a buffered stream, clear out buffers[fd]. */
  if (bash_input.type == st_bstream && bash_input.location.buffered_fd >= 0)
    saver->bstream = set_buffered_stream (bash_input.location.buffered_fd,
    					  (BUFFERED_STREAM *)NULL);
#endif /* BUFFERED_INPUT */

  saver->line = line_number;
  bash_input.name = (char *)NULL;
  saver->next = stream_list;
  stream_list = saver;
  EOF_Reached = 0;
  if (reset_lineno)
    line_number = 0;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\y.tab.c:4,003
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\y.tab.c:4,074
parsing error 
{
  register STREAM_SAVER *s;

  for (s = stream_list; s; s = s->next)
    if (s->bash_input.type == type)
      return 1;
  return 0;
}
warning: parse error {
  register STREAM_SAVER *s;

  for (s = stream_list; s; s = s->next)
    if (s->bash_input.type == type)
      return 1;
  return 0;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\y.tab.c:4,076
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\y.tab.c:4,100
parsing error 
{
  if (ts == 0)
    return;
  last_read_token = ts[0];
  token_before_that = ts[1];
  two_tokens_ago = ts[2];
  current_token = ts[3];
}
warning: parse error {
  if (ts == 0)
    return;
  last_read_token = ts[0];
  token_before_that = ts[1];
  two_tokens_ago = ts[2];
  current_token = ts[3];
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\y.tab.c:4,102
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\y.tab.c:4,319
parsing error 
{
  static char *line_buffer = (char *)NULL;
  static int buffer_size = 0;
  int indx, c, peekc, pass_next;

#if defined (READLINE)
  if (no_line_editing && SHOULD_PROMPT ())
#else
  if (SHOULD_PROMPT ())
#endif
    print_prompt ();

  pass_next = indx = 0;
  while (1)
    {
      /* Allow immediate exit if interrupted during input. */
      QUIT;

      c = yy_getc ();

      /* Ignore null bytes in input. */
      if (c == 0)
	{
#if 0
	  internal_warning ("read_a_line: ignored null byte in input");
#endif
	  continue;
	}

      /* If there is no more input, then we return NULL. */
      if (c == EOF)
	{
	  if (interactive && bash_input.type == st_stream)
	    clearerr (stdin);
	  if (indx == 0)
	    return ((char *)NULL);
	  c = '\n';
	}

      /* `+2' in case the final character in the buffer is a newline or we
	 have to handle CTLESC or CTLNUL. */
      RESIZE_MALLOCED_BUFFER (line_buffer, indx, 2, buffer_size, 128);

      /* IF REMOVE_QUOTED_NEWLINES is non-zero, we are reading a
	 here document with an unquoted delimiter.  In this case,
	 the line will be expanded as if it were in double quotes.
	 We allow a backslash to escape the next character, but we
	 need to treat the backslash specially only if a backslash
	 quoting a backslash-newline pair appears in the line. */
      if (pass_next)
	{
	  line_buffer[indx++] = c;
	  pass_next = 0;
	}
      else if (c == '\\' && remove_quoted_newline)
	{
	  QUIT;
	  peekc = yy_getc ();
	  if (peekc == '\n')
	    {
	      line_number++;
	      continue;	/* Make the unquoted \<newline> pair disappear. */
	    }
	  else
	    {
	      yy_ungetc (peekc);
	      pass_next = 1;
	      line_buffer[indx++] = c;		/* Preserve the backslash. */
	    }
	}
      else
	{
	  /* remove_quoted_newline is non-zero if the here-document delimiter
	     is unquoted. In this case, we will be expanding the lines and
	     need to make sure CTLESC and CTLNUL in the input are quoted. */
	  if (remove_quoted_newline && (c == CTLESC || c == CTLNUL))
	    line_buffer[indx++] = CTLESC;
	  line_buffer[indx++] = c;
	}

      if (c == '\n')
	{
	  line_buffer[indx] = '\0';
	  return (line_buffer);
	}
    }
}
warning: parse error {
  static char *line_buffer = (char *)NULL;
  static int buffer_size = 0;
  int indx, c, peekc, pass_next;

#if defined (READLINE)
  if (no_line_editing && SHOULD_PROMPT ())
#else
  if (SHOULD_PROMPT ())
#endif
    print_prompt ();

  pass_next = indx = 0;
  while (1)
    {
      /* Allow immediate exit if interrupted during input. */
      QUIT;

      c = yy_getc ();

      /* Ignore null bytes in input. */
      if (c == 0)
	{
#if 0
	  internal_warning ("read_a_line: ignored null byte in input");
#endif
	  continue;
	}

      /* If there is no more input, then we return NULL. */
      if (c == EOF)
	{
	  if (interactive && bash_input.type == st_stream)
	    clearerr (stdin);
	  if (indx == 0)
	    return ((char *)NULL);
	  c = '\n';
	}

      /* `+2' in case the final character in the buffer is a newline or we
	 have to handle CTLESC or CTLNUL. */
      RESIZE_MALLOCED_BUFFER (line_buffer, indx, 2, buffer_size, 128);

      /* IF REMOVE_QUOTED_NEWLINES is non-zero, we are reading a
	 here document with an unquoted delimiter.  In this case,
	 the line will be expanded as if it were in double quotes.
	 We allow a backslash to escape the next character, but we
	 need to treat the backslash specially only if a backslash
	 quoting a backslash-newline pair appears in the line. */
      if (pass_next)
	{
	  line_buffer[indx++] = c;
	  pass_next = 0;
	}
      else if (c == '\\' && remove_quoted_newline)
	{
	  QUIT;
	  peekc = yy_getc ();
	  if (peekc == '\n')
	    {
	      line_number++;
	      continue;	/* Make the unquoted \<newline> pair disappear. */
	    }
	  else
	    {
	      yy_ungetc (peekc);
	      pass_next = 1;
	      line_buffer[indx++] = c;		/* Preserve the backslash. */
	    }
	}
      else
	{
	  /* remove_quoted_newline is non-zero if the here-document delimiter
	     is unquoted. In this case, we will be expanding the lines and
	     need to make sure CTLESC and CTLNUL in the input are quoted. */
	  if (remove_quoted_newline && (c == CTLESC || c == CTLNUL))
	    line_buffer[indx++] = CTLESC;
	  line_buffer[indx++] = c;
	}

      if (c == '\n')
	{
	  line_buffer[indx] = '\0';
	  return (line_buffer);
	}
    }
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\y.tab.c:4,321
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\y.tab.c:4,415
parsing error 
{
  char *ret;
  int n, c;

  prompt_string_pointer = &ps2_prompt;
  if (SHOULD_PROMPT())
    prompt_again ();
  ret = read_a_line (remove_quoted_newline);
#if defined (HISTORY)
  if (ret && remember_on_history && (parser_state & PST_HEREDOC))
    {
      /* To make adding the here-document body right, we need to rely on
	 history_delimiting_chars() returning \n for the first line of the
	 here-document body and the null string for the second and subsequent
	 lines, so we avoid double newlines.
	 current_command_line_count == 2 for the first line of the body. */

      current_command_line_count++;
      maybe_add_history (ret);
    }
#endif /* HISTORY */
  return ret;
}
warning: parse error {
  char *ret;
  int n, c;

  prompt_string_pointer = &ps2_prompt;
  if (SHOULD_PROMPT())
    prompt_again ();
  ret = read_a_line (remove_quoted_newline);
#if defined (HISTORY)
  if (ret && remember_on_history && (parser_state & PST_HEREDOC))
    {
      /* To make adding the here-document body right, we need to rely on
	 history_delimiting_chars() returning \n for the first line of the
	 here-document body and the null string for the second and subsequent
	 lines, so we avoid double newlines.
	 current_command_line_count == 2 for the first line of the body. */

      current_command_line_count++;
      maybe_add_history (ret);
    }
#endif /* HISTORY */
  return ret;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\y.tab.c:4,417
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\y.tab.c:4,571
parsing error 
{
  register int i;
  int c, truncating, last_was_backslash;
  unsigned char uc;

  QUIT;

  last_was_backslash = 0;
  if (sigwinch_received)
    {
      sigwinch_received = 0;
      get_new_window_size (0, (int *)0, (int *)0);
    }
      
  if (eol_ungetc_lookahead)
    {
      c = eol_ungetc_lookahead;
      eol_ungetc_lookahead = 0;
      return (c);
    }

#if defined (ALIAS) || defined (DPAREN_ARITHMETIC)
  /* If shell_input_line[shell_input_line_index] == 0, but there is
     something on the pushed list of strings, then we don't want to go
     off and get another line.  We let the code down below handle it. */

  if (!shell_input_line || ((!shell_input_line[shell_input_line_index]) &&
			    (pushed_string_list == (STRING_SAVER *)NULL)))
#else /* !ALIAS && !DPAREN_ARITHMETIC */
  if (!shell_input_line || !shell_input_line[shell_input_line_index])
#endif /* !ALIAS && !DPAREN_ARITHMETIC */
    {
      line_number++;

      /* Let's not let one really really long line blow up memory allocation */
      if (shell_input_line && shell_input_line_size >= 32768)
	{
	  free (shell_input_line);
	  shell_input_line = 0;
	  shell_input_line_size = 0;
	}

    restart_read:

      /* Allow immediate exit if interrupted during input. */
      QUIT;

      i = truncating = 0;
      shell_input_line_terminator = 0;

      /* If the shell is interactive, but not currently printing a prompt
         (interactive_shell && interactive == 0), we don't want to print
         notifies or cleanup the jobs -- we want to defer it until we do
         print the next prompt. */
      if (interactive_shell == 0 || SHOULD_PROMPT())
	{
#if defined (JOB_CONTROL)
      /* This can cause a problem when reading a command as the result
	 of a trap, when the trap is called from flush_child.  This call
	 had better not cause jobs to disappear from the job table in
	 that case, or we will have big trouble. */
	  notify_and_cleanup ();
#else /* !JOB_CONTROL */
	  cleanup_dead_jobs ();
#endif /* !JOB_CONTROL */
	}

#if defined (READLINE)
      if (no_line_editing && SHOULD_PROMPT())
#else
      if (SHOULD_PROMPT())
#endif
	print_prompt ();

      if (bash_input.type == st_stream)
	clearerr (stdin);

      while (1)
	{
	  c = yy_getc ();

	  /* Allow immediate exit if interrupted during input. */
	  QUIT;

	  if (c == '\0')
	    {
#if 0
	      internal_warning ("shell_getc: ignored null byte in input");
#endif
	      /* If we get EOS while parsing a string, treat it as EOF so we
		 don't just keep looping. Happens very rarely */
	      if (bash_input.type == st_string)
		{
		  if (i == 0)
		    shell_input_line_terminator = EOF;
		  shell_input_line[i] = '\0';
		  c = EOF;
		  break;
		}
	      continue;
	    }

	  /* Theoretical overflow */
	  /* If we can't put 256 bytes more into the buffer, allocate
	     everything we can and fill it as full as we can. */
	  /* XXX - we ignore rest of line using `truncating' flag */
	  if (shell_input_line_size > (SIZE_MAX - 256))
	    {
	      size_t n;

	      n = SIZE_MAX - i;	/* how much more can we put into the buffer? */
	      if (n <= 2)	/* we have to save 1 for the newline added below */
		{
		  if (truncating == 0)
		    internal_warning(_("shell_getc: shell_input_line_size (%zu) exceeds SIZE_MAX (%lu): line truncated"), shell_input_line_size, (unsigned long)SIZE_MAX);
		  shell_input_line[i] = '\0';
		  truncating = 1;
		}
	      if (shell_input_line_size < SIZE_MAX)
		{
		  shell_input_line_size = SIZE_MAX;
		  shell_input_line = xrealloc (shell_input_line, shell_input_line_size);
		}
	    }
	  else
	    RESIZE_MALLOCED_BUFFER (shell_input_line, i, 2, shell_input_line_size, 256);

	  if (c == EOF)
	    {
	      if (bash_input.type == st_stream)
		clearerr (stdin);

	      if (i == 0)
		shell_input_line_terminator = EOF;

	      shell_input_line[i] = '\0';
	      break;
	    }

	  if (truncating == 0 || c == '\n')
	    shell_input_line[i++] = c;

	  if (c == '\n')
	    {
	      shell_input_line[--i] = '\0';
	      current_command_line_count++;
	      break;
	    }

	  last_was_backslash = last_was_backslash == 0 && c == '\\';
	}

      shell_input_line_index = 0;
      shell_input_line_len = i;		/* == strlen (shell_input_line) */

      set_line_mbstate ();

#if defined (HISTORY)
      if (remember_on_history && shell_input_line && shell_input_line[0])
	{
	  char *expansions;
#  if defined (BANG_HISTORY)
	  /* If the current delimiter is a single quote, we should not be
	     performing history expansion, even if we're on a different
	     line from the original single quote. */
	  if (current_delimiter (dstack) == '\'')
	    history_quoting_state = '\'';
	  else if (current_delimiter (dstack) == '"')
	    history_quoting_state = '"';
	  else
	    history_quoting_state = 0;
#  endif
	  /* Calling with a third argument of 1 allows remember_on_history to
	     determine whether or not the line is saved to the history list */
	  expansions = pre_process_line (shell_input_line, 1, 1);
#  if defined (BANG_HISTORY)
	  history_quoting_state = 0;
#  endif
	  if (expansions != shell_input_line)
	    {
	      free (shell_input_line);
	      shell_input_line = expansions;
	      shell_input_line_len = shell_input_line ?
					strlen (shell_input_line) : 0;
	      if (shell_input_line_len == 0)
		current_command_line_count--;

	      /* We have to force the xrealloc below because we don't know
		 the true allocated size of shell_input_line anymore. */
	      shell_input_line_size = shell_input_line_len;

	      set_line_mbstate ();
	    }
	}
      /* Try to do something intelligent with blank lines encountered while
	 entering multi-line commands.  XXX - this is grotesque */
      else if (remember_on_history && shell_input_line &&
	       shell_input_line[0] == '\0' &&
	       current_command_line_count > 1)
	{
	  if (current_delimiter (dstack))
	    /* We know shell_input_line[0] == 0 and we're reading some sort of
	       quoted string.  This means we've got a line consisting of only
	       a newline in a quoted string.  We want to make sure this line
	       gets added to the history. */
	    maybe_add_history (shell_input_line);
	  else
	    {
	      char *hdcs;
	      hdcs = history_delimiting_chars (shell_input_line);
	      if (hdcs && hdcs[0] == ';')
		maybe_add_history (shell_input_line);
	    }
	}

#endif /* HISTORY */

      if (shell_input_line)
	{
	  /* Lines that signify the end of the shell's input should not be
	     echoed.  We should not echo lines while parsing command
	     substitutions with recursive calls into the parsing engine; those
	     should only be echoed once when we read the word.  That is the
	     reason for the test against shell_eof_token, which is set to a
	     right paren when parsing the contents of command substitutions. */
	  if (echo_input_at_read && (shell_input_line[0] ||
				       shell_input_line_terminator != EOF) &&
				     shell_eof_token == 0)
	    fprintf (stderr, "%s\n", shell_input_line);
	}
      else
	{
	  shell_input_line_size = 0;
	  prompt_string_pointer = &current_prompt_string;
	  if (SHOULD_PROMPT ())
	    prompt_again ();
	  goto restart_read;
	}

      /* Add the newline to the end of this string, iff the string does
	 not already end in an EOF character.  */
      if (shell_input_line_terminator != EOF)
	{
	  if (shell_input_line_size < SIZE_MAX-3 && (shell_input_line_len+3 > shell_input_line_size))
	    shell_input_line = (char *)xrealloc (shell_input_line,
					1 + (shell_input_line_size += 2));

	  /* Don't add a newline to a string that ends with a backslash if we're
	     going to be removing quoted newlines, since that will eat the
	     backslash.  Add another backslash instead (will be removed by
	     word expansion). */
	  if (bash_input.type == st_string && expanding_alias() == 0 && last_was_backslash && c == EOF && remove_quoted_newline)
	    shell_input_line[shell_input_line_len] = '\\';
	  else
	    shell_input_line[shell_input_line_len] = '\n';
	  shell_input_line[shell_input_line_len + 1] = '\0';

#if 0
	  set_line_mbstate ();		/* XXX - this is wasteful */
#else
#  if defined (HANDLE_MULTIBYTE)
	  /* This is kind of an abstraction violation, but there's no need to
	     go through the entire shell_input_line again with a call to
	     set_line_mbstate(). */
	  if (shell_input_line_len + 2 > shell_input_line_propsize)
	    {
	      shell_input_line_propsize = shell_input_line_len + 2;
	      shell_input_line_property = (char *)xrealloc (shell_input_line_property,
							    shell_input_line_propsize);
	    }
	  shell_input_line_property[shell_input_line_len] = 1;
#  endif
#endif
	}
    }

next_alias_char:
  if (shell_input_line_index == 0)
    unquoted_backslash = 0;

  uc = shell_input_line[shell_input_line_index];

  if (uc)
    {
      unquoted_backslash = unquoted_backslash == 0 && uc == '\\';
      shell_input_line_index++;
    }

#if defined (ALIAS) || defined (DPAREN_ARITHMETIC)
  /* If UC is NULL, we have reached the end of the current input string.  If
     pushed_string_list is non-empty, it's time to pop to the previous string
     because we have fully consumed the result of the last alias expansion.
     Do it transparently; just return the next character of the string popped
     to. */
  /* If pushed_string_list != 0 but pushed_string_list->expander == 0 (not
     currently tested) and the flags value is not PSH_SOURCE, we are not
     parsing an alias, we have just saved one (push_string, when called by
     the parse_dparen code) In this case, just go on as well.  The PSH_SOURCE
     case is handled below. */

  /* If we're at the end of an alias expansion add a space to make sure that
     the alias remains marked as being in use while we expand its last word.
     This makes sure that pop_string doesn't mark the alias as not in use
     before the string resulting from the alias expansion is tokenized and
     checked for alias expansion, preventing recursion.  At this point, the
     last character in shell_input_line is the last character of the alias
     expansion.  We test that last character to determine whether or not to
     return the space that will delimit the token and postpone the pop_string.
     This set of conditions duplicates what used to be in mk_alexpansion ()
     below, with the addition that we don't add a space if we're currently
     reading a quoted string or in a shell comment. */
#ifndef OLD_ALIAS_HACK
  if (uc == 0 && pushed_string_list && pushed_string_list->flags != PSH_SOURCE &&
      pushed_string_list->flags != PSH_DPAREN &&
      (parser_state & PST_COMMENT) == 0 &&
      (parser_state & PST_ENDALIAS) == 0 &&	/* only once */
      shell_input_line_index > 0 &&
      shellblank (shell_input_line[shell_input_line_index-1]) == 0 &&
      shell_input_line[shell_input_line_index-1] != '\n' &&
      unquoted_backslash == 0 &&
      shellmeta (shell_input_line[shell_input_line_index-1]) == 0 &&
      (current_delimiter (dstack) != '\'' && current_delimiter (dstack) != '"'))
    {
      parser_state |= PST_ENDALIAS;
      return ' ';	/* END_ALIAS */
    }
#endif

pop_alias:
  /* This case works for PSH_DPAREN as well */
  if (uc == 0 && pushed_string_list && pushed_string_list->flags != PSH_SOURCE)
    {
      parser_state &= ~PST_ENDALIAS;
      pop_string ();
      uc = shell_input_line[shell_input_line_index];
      if (uc)
	shell_input_line_index++;
    }
#endif /* ALIAS || DPAREN_ARITHMETIC */

  if MBTEST(uc == '\\' && remove_quoted_newline && shell_input_line[shell_input_line_index] == '\n')
    {
	if (SHOULD_PROMPT ())
	  prompt_again ();
	line_number++;

	/* What do we do here if we're expanding an alias whose definition
	   includes an escaped newline?  If that's the last character in the
	   alias expansion, we just pop the pushed string list (recall that
	   we inhibit the appending of a space if newline is the last
	   character).  If it's not the last character, we need to consume the
	   quoted newline and move to the next character in the expansion. */
#if defined (ALIAS)
	if (expanding_alias () && shell_input_line[shell_input_line_index+1] == '\0')
	  {
	    uc = 0;
	    goto pop_alias;
	  }
	else if (expanding_alias () && shell_input_line[shell_input_line_index+1] != '\0')
	  {
	    shell_input_line_index++;	/* skip newline */
	    goto next_alias_char;	/* and get next character */
	  }
	else
#endif 
	  goto restart_read;
    }

  if (uc == 0 && shell_input_line_terminator == EOF)
    return ((shell_input_line_index != 0) ? '\n' : EOF);

#if defined (ALIAS) || defined (DPAREN_ARITHMETIC)
  /* We already know that we are not parsing an alias expansion because of the
     check for expanding_alias() above.  This knows how parse_and_execute
     handles switching to st_string input while an alias is being expanded,
     hence the check for pushed_string_list without pushed_string_list->expander
     and the check for PSH_SOURCE as pushed_string_list->flags.
     parse_and_execute and parse_string both change the input type to st_string
     and place the string to be parsed and executed into location.string, so
     we should not stop reading that until the pointer is '\0'.
     The check for shell_input_line_terminator may be superfluous.

     This solves the problem of `.' inside a multi-line alias with embedded
     newlines executing things out of order. */
  if (uc == 0 && bash_input.type == st_string && *bash_input.location.string &&
      pushed_string_list && pushed_string_list->flags == PSH_SOURCE &&
      shell_input_line_terminator == 0)
    {
      shell_input_line_index = 0;
      goto restart_read;
    }
#endif

  return (uc);
}
warning: parse error {
  register int i;
  int c, truncating, last_was_backslash;
  unsigned char uc;

  QUIT;

  last_was_backslash = 0;
  if (sigwinch_received)
    {
      sigwinch_received = 0;
      get_new_window_size (0, (int *)0, (int *)0);
    }
      
  if (eol_ungetc_lookahead)
    {
      c = eol_ungetc_lookahead;
      eol_ungetc_lookahead = 0;
      return (c);
    }

#if defined (ALIAS) || defined (DPAREN_ARITHMETIC)
  /* If shell_input_line[shell_input_line_index] == 0, but there is
     something on the pushed list of strings, then we don't want to go
     off and get another line.  We let the code down below handle it. */

  if (!shell_input_line || ((!shell_input_line[shell_input_line_index]) &&
			    (pushed_string_list == (STRING_SAVER *)NULL)))
#else /* !ALIAS && !DPAREN_ARITHMETIC */
  if (!shell_input_line || !shell_input_line[shell_input_line_index])
#endif /* !ALIAS && !DPAREN_ARITHMETIC */
    {
      line_number++;

      /* Let's not let one really really long line blow up memory allocation */
      if (shell_input_line && shell_input_line_size >= 32768)
	{
	  free (shell_input_line);
	  shell_input_line = 0;
	  shell_input_line_size = 0;
	}

    restart_read:

      /* Allow immediate exit if interrupted during input. */
      QUIT;

      i = truncating = 0;
      shell_input_line_terminator = 0;

      /* If the shell is interactive, but not currently printing a prompt
         (interactive_shell && interactive == 0), we don't want to print
         notifies or cleanup the jobs -- we want to defer it until we do
         print the next prompt. */
      if (interactive_shell == 0 || SHOULD_PROMPT())
	{
#if defined (JOB_CONTROL)
      /* This can cause a problem when reading a command as the result
	 of a trap, when the trap is called from flush_child.  This call
	 had better not cause jobs to disappear from the job table in
	 that case, or we will have big trouble. */
	  notify_and_cleanup ();
#else /* !JOB_CONTROL */
	  cleanup_dead_jobs ();
#endif /* !JOB_CONTROL */
	}

#if defined (READLINE)
      if (no_line_editing && SHOULD_PROMPT())
#else
      if (SHOULD_PROMPT())
#endif
	print_prompt ();

      if (bash_input.type == st_stream)
	clearerr (stdin);

      while (1)
	{
	  c = yy_getc ();

	  /* Allow immediate exit if interrupted during input. */
	  QUIT;

	  if (c == '\0')
	    {
#if 0
	      internal_warning ("shell_getc: ignored null byte in input");
#endif
	      /* If we get EOS while parsing a string, treat it as EOF so we
		 don't just keep looping. Happens very rarely */
	      if (bash_input.type == st_string)
		{
		  if (i == 0)
		    shell_input_line_terminator = EOF;
		  shell_input_line[i] = '\0';
		  c = EOF;
		  break;
		}
	      continue;
	    }

	  /* Theoretical overflow */
	  /* If we can't put 256 bytes more into the buffer, allocate
	     everything we can and fill it as full as we can. */
	  /* XXX - we ignore rest of line using `truncating' flag */
	  if (shell_input_line_size > (SIZE_MAX - 256))
	    {
	      size_t n;

	      n = SIZE_MAX - i;	/* how much more can we put into the buffer? */
	      if (n <= 2)	/* we have to save 1 for the newline added below */
		{
		  if (truncating == 0)
		    internal_warning(_("shell_getc: shell_input_line_size (%zu) exceeds SIZE_MAX (%lu): line truncated"), shell_input_line_size, (unsigned long)SIZE_MAX);
		  shell_input_line[i] = '\0';
		  truncating = 1;
		}
	      if (shell_input_line_size < SIZE_MAX)
		{
		  shell_input_line_size = SIZE_MAX;
		  shell_input_line = xrealloc (shell_input_line, shell_input_line_size);
		}
	    }
	  else
	    RESIZE_MALLOCED_BUFFER (shell_input_line, i, 2, shell_input_line_size, 256);

	  if (c == EOF)
	    {
	      if (bash_input.type == st_stream)
		clearerr (stdin);

	      if (i == 0)
		shell_input_line_terminator = EOF;

	      shell_input_line[i] = '\0';
	      break;
	    }

	  if (truncating == 0 || c == '\n')
	    shell_input_line[i++] = c;

	  if (c == '\n')
	    {
	      shell_input_line[--i] = '\0';
	      current_command_line_count++;
	      break;
	    }

	  last_was_backslash = last_was_backslash == 0 && c == '\\';
	}

      shell_input_line_index = 0;
      shell_input_line_len = i;		/* == strlen (shell_input_line) */

      set_line_mbstate ();

#if defined (HISTORY)
      if (remember_on_history && shell_input_line && shell_input_line[0])
	{
	  char *expansions;
#  if defined (BANG_HISTORY)
	  /* If the current delimiter is a single quote, we should not be
	     performing history expansion, even if we're on a different
	     line from the original single quote. */
	  if (current_delimiter (dstack) == '\'')
	    history_quoting_state = '\'';
	  else if (current_delimiter (dstack) == '"')
	    history_quoting_state = '"';
	  else
	    history_quoting_state = 0;
#  endif
	  /* Calling with a third argument of 1 allows remember_on_history to
	     determine whether or not the line is saved to the history list */
	  expansions = pre_process_line (shell_input_line, 1, 1);
#  if defined (BANG_HISTORY)
	  history_quoting_state = 0;
#  endif
	  if (expansions != shell_input_line)
	    {
	      free (shell_input_line);
	      shell_input_line = expansions;
	      shell_input_line_len = shell_input_line ?
					strlen (shell_input_line) : 0;
	      if (shell_input_line_len == 0)
		current_command_line_count--;

	      /* We have to force the xrealloc below because we don't know
		 the true allocated size of shell_input_line anymore. */
	      shell_input_line_size = shell_input_line_len;

	      set_line_mbstate ();
	    }
	}
      /* Try to do something intelligent with blank lines encountered while
	 entering multi-line commands.  XXX - this is grotesque */
      else if (remember_on_history && shell_input_line &&
	       shell_input_line[0] == '\0' &&
	       current_command_line_count > 1)
	{
	  if (current_delimiter (dstack))
	    /* We know shell_input_line[0] == 0 and we're reading some sort of
	       quoted string.  This means we've got a line consisting of only
	       a newline in a quoted string.  We want to make sure this line
	       gets added to the history. */
	    maybe_add_history (shell_input_line);
	  else
	    {
	      char *hdcs;
	      hdcs = history_delimiting_chars (shell_input_line);
	      if (hdcs && hdcs[0] == ';')
		maybe_add_history (shell_input_line);
	    }
	}

#endif /* HISTORY */

      if (shell_input_line)
	{
	  /* Lines that signify the end of the shell's input should not be
	     echoed.  We should not echo lines while parsing command
	     substitutions with recursive calls into the parsing engine; those
	     should only be echoed once when we read the word.  That is the
	     reason for the test against shell_eof_token, which is set to a
	     right paren when parsing the contents of command substitutions. */
	  if (echo_input_at_read && (shell_input_line[0] ||
				       shell_input_line_terminator != EOF) &&
				     shell_eof_token == 0)
	    fprintf (stderr, "%s\n", shell_input_line);
	}
      else
	{
	  shell_input_line_size = 0;
	  prompt_string_pointer = &current_prompt_string;
	  if (SHOULD_PROMPT ())
	    prompt_again ();
	  goto restart_read;
	}

      /* Add the newline to the end of this string, iff the string does
	 not already end in an EOF character.  */
      if (shell_input_line_terminator != EOF)
	{
	  if (shell_input_line_size < SIZE_MAX-3 && (shell_input_line_len+3 > shell_input_line_size))
	    shell_input_line = (char *)xrealloc (shell_input_line,
					1 + (shell_input_line_size += 2));

	  /* Don't add a newline to a string that ends with a backslash if we're
	     going to be removing quoted newlines, since that will eat the
	     backslash.  Add another backslash instead (will be removed by
	     word expansion). */
	  if (bash_input.type == st_string && expanding_alias() == 0 && last_was_backslash && c == EOF && remove_quoted_newline)
	    shell_input_line[shell_input_line_len] = '\\';
	  else
	    shell_input_line[shell_input_line_len] = '\n';
	  shell_input_line[shell_input_line_len + 1] = '\0';

#if 0
	  set_line_mbstate ();		/* XXX - this is wasteful */
#else
#  if defined (HANDLE_MULTIBYTE)
	  /* This is kind of an abstraction violation, but there's no need to
	     go through the entire shell_input_line again with a call to
	     set_line_mbstate(). */
	  if (shell_input_line_len + 2 > shell_input_line_propsize)
	    {
	      shell_input_line_propsize = shell_input_line_len + 2;
	      shell_input_line_property = (char *)xrealloc (shell_input_line_property,
							    shell_input_line_propsize);
	    }
	  shell_input_line_property[shell_input_line_len] = 1;
#  endif
#endif
	}
    }

next_alias_char:
  if (shell_input_line_index == 0)
    unquoted_backslash = 0;

  uc = shell_input_line[shell_input_line_index];

  if (uc)
    {
      unquoted_backslash = unquoted_backslash == 0 && uc == '\\';
      shell_input_line_index++;
    }

#if defined (ALIAS) || defined (DPAREN_ARITHMETIC)
  /* If UC is NULL, we have reached the end of the current input string.  If
     pushed_string_list is non-empty, it's time to pop to the previous string
     because we have fully consumed the result of the last alias expansion.
     Do it transparently; just return the next character of the string popped
     to. */
  /* If pushed_string_list != 0 but pushed_string_list->expander == 0 (not
     currently tested) and the flags value is not PSH_SOURCE, we are not
     parsing an alias, we have just saved one (push_string, when called by
     the parse_dparen code) In this case, just go on as well.  The PSH_SOURCE
     case is handled below. */

  /* If we're at the end of an alias expansion add a space to make sure that
     the alias remains marked as being in use while we expand its last word.
     This makes sure that pop_string doesn't mark the alias as not in use
     before the string resulting from the alias expansion is tokenized and
     checked for alias expansion, preventing recursion.  At this point, the
     last character in shell_input_line is the last character of the alias
     expansion.  We test that last character to determine whether or not to
     return the space that will delimit the token and postpone the pop_string.
     This set of conditions duplicates what used to be in mk_alexpansion ()
     below, with the addition that we don't add a space if we're currently
     reading a quoted string or in a shell comment. */
#ifndef OLD_ALIAS_HACK
  if (uc == 0 && pushed_string_list && pushed_string_list->flags != PSH_SOURCE &&
      pushed_string_list->flags != PSH_DPAREN &&
      (parser_state & PST_COMMENT) == 0 &&
      (parser_state & PST_ENDALIAS) == 0 &&	/* only once */
      shell_input_line_index > 0 &&
      shellblank (shell_input_line[shell_input_line_index-1]) == 0 &&
      shell_input_line[shell_input_line_index-1] != '\n' &&
      unquoted_backslash == 0 &&
      shellmeta (shell_input_line[shell_input_line_index-1]) == 0 &&
      (current_delimiter (dstack) != '\'' && current_delimiter (dstack) != '"'))
    {
      parser_state |= PST_ENDALIAS;
      return ' ';	/* END_ALIAS */
    }
#endif

pop_alias:
  /* This case works for PSH_DPAREN as well */
  if (uc == 0 && pushed_string_list && pushed_string_list->flags != PSH_SOURCE)
    {
      parser_state &= ~PST_ENDALIAS;
      pop_string ();
      uc = shell_input_line[shell_input_line_index];
      if (uc)
	shell_input_line_index++;
    }
#endif /* ALIAS || DPAREN_ARITHMETIC */

  if MBTEST(uc == '\\' && remove_quoted_newline && shell_input_line[shell_input_line_index] == '\n')
    {
	if (SHOULD_PROMPT ())
	  prompt_again ();
	line_number++;

	/* What do we do here if we're expanding an alias whose definition
	   includes an escaped newline?  If that's the last character in the
	   alias expansion, we just pop the pushed string list (recall that
	   we inhibit the appending of a space if newline is the last
	   character).  If it's not the last character, we need to consume the
	   quoted newline and move to the next character in the expansion. */
#if defined (ALIAS)
	if (expanding_alias () && shell_input_line[shell_input_line_index+1] == '\0')
	  {
	    uc = 0;
	    goto pop_alias;
	  }
	else if (expanding_alias () && shell_input_line[shell_input_line_index+1] != '\0')
	  {
	    shell_input_line_index++;	/* skip newline */
	    goto next_alias_char;	/* and get next character */
	  }
	else
#endif 
	  goto restart_read;
    }

  if (uc == 0 && shell_input_line_terminator == EOF)
    return ((shell_input_line_index != 0) ? '\n' : EOF);

#if defined (ALIAS) || defined (DPAREN_ARITHMETIC)
  /* We already know that we are not parsing an alias expansion because of the
     check for expanding_alias() above.  This knows how parse_and_execute
     handles switching to st_string input while an alias is being expanded,
     hence the check for pushed_string_list without pushed_string_list->expander
     and the check for PSH_SOURCE as pushed_string_list->flags.
     parse_and_execute and parse_string both change the input type to st_string
     and place the string to be parsed and executed into location.string, so
     we should not stop reading that until the pointer is '\0'.
     The check for shell_input_line_terminator may be superfluous.

     This solves the problem of `.' inside a multi-line alias with embedded
     newlines executing things out of order. */
  if (uc == 0 && bash_input.type == st_string && *bash_input.location.string &&
      pushed_string_list && pushed_string_list->flags == PSH_SOURCE &&
      shell_input_line_terminator == 0)
    {
      shell_input_line_index = 0;
      goto restart_read;
    }
#endif

  return (uc);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\y.tab.c:4,573
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\y.tab.c:4,975
parsing error 
{
  if (shell_input_line && shell_input_line_index)
    shell_input_line[--shell_input_line_index] = c;
  else
    eol_ungetc_lookahead = c;
}
warning: parse error {
  if (shell_input_line && shell_input_line_index)
    shell_input_line[--shell_input_line_index] = c;
  else
    eol_ungetc_lookahead = c;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\y.tab.c:4,977
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\y.tab.c:5,007
parsing error 
{
  int c;

  while ((c = shell_getc (0)) != EOF && c != character)
    ;

  if (c != EOF)
    shell_ungetc (c);
}
warning: parse error {
  int c;

  while ((c = shell_getc (0)) != EOF && c != character)
    ;

  if (c != EOF)
    shell_ungetc (c);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\y.tab.c:5,009
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\y.tab.c:5,020
parsing error 
{
  char *last_lastarg;
  sh_parser_state_t ps;

  save_parser_state (&ps);
  last_lastarg = get_string_value ("_");
  if (last_lastarg)
    last_lastarg = savestring (last_lastarg);

  parse_and_execute (savestring (command), vname, SEVAL_NONINT|SEVAL_NOHIST);

  restore_parser_state (&ps);
  bind_variable ("_", last_lastarg, 0);
  FREE (last_lastarg);

  if (token_to_read == '\n')	/* reset_parser was called */
    token_to_read = 0;
}
warning: parse error {
  char *last_lastarg;
  sh_parser_state_t ps;

  save_parser_state (&ps);
  last_lastarg = get_string_value ("_");
  if (last_lastarg)
    last_lastarg = savestring (last_lastarg);

  parse_and_execute (savestring (command), vname, SEVAL_NONINT|SEVAL_NOHIST);

  restore_parser_state (&ps);
  bind_variable ("_", last_lastarg, 0);
  FREE (last_lastarg);

  if (token_to_read == '\n')	/* reset_parser was called */
    token_to_read = 0;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\y.tab.c:5,022
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\y.tab.c:5,042
parsing error 
{
  two_tokens_ago = token_before_that;
  token_before_that = last_read_token;
  last_read_token = current_token;

  current_token = x;
}
warning: parse error {
  two_tokens_ago = token_before_that;
  token_before_that = last_read_token;
  last_read_token = current_token;

  current_token = x;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\y.tab.c:5,044
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\y.tab.c:5,113
parsing error 
{
  if (need_here_doc >= HEREDOC_MAX)
    {
      last_command_exit_value = EX_BADUSAGE;
      need_here_doc = 0;
      report_syntax_error (_("maximum here-document count exceeded"));
      reset_parser ();
      exit_shell (last_command_exit_value);
    }
  redir_stack[need_here_doc++] = r;
}
warning: parse error {
  if (need_here_doc >= HEREDOC_MAX)
    {
      last_command_exit_value = EX_BADUSAGE;
      need_here_doc = 0;
      report_syntax_error (_("maximum here-document count exceeded"));
      reset_parser ();
      exit_shell (last_command_exit_value);
    }
  redir_stack[need_here_doc++] = r;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\y.tab.c:5,115
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\y.tab.c:5,363
parsing error 
{
  /* Posix grammar rule 6 */
  if ((last_read_token == WORD) &&
#if defined (SELECT_COMMAND)
      ((token_before_that == FOR) || (token_before_that == CASE) || (token_before_that == SELECT)) &&
#else
      ((token_before_that == FOR) || (token_before_that == CASE)) &&
#endif
      (tokstr[0] == 'i' && tokstr[1] == 'n' && tokstr[2] == 0))
    {
      if (token_before_that == CASE)
	{
	  parser_state |= PST_CASEPAT;
	  esacs_needed_count++;
	}
      if (expecting_in_token)
	expecting_in_token--;
      return (IN);
    }

  /* XXX - leaving above code intact for now, but it should eventually be
     removed in favor of this clause. */
  /* Posix grammar rule 6 */
  if (expecting_in_token && (last_read_token == WORD || last_read_token == '\n') &&
      (tokstr[0] == 'i' && tokstr[1] == 'n' && tokstr[2] == 0))
    {
      if (parser_state & PST_CASESTMT)
	{
	  parser_state |= PST_CASEPAT;
	  esacs_needed_count++;
	}
      expecting_in_token--;
      return (IN);
    }
  /* Posix grammar rule 6, third word in FOR: for i; do command-list; done */
  else if (expecting_in_token && (last_read_token == '\n' || last_read_token == ';') &&
    (tokstr[0] == 'd' && tokstr[1] == 'o' && tokstr[2] == '\0'))
    {
      expecting_in_token--;
      return (DO);
    }

  /* for i do; command-list; done */
  if (last_read_token == WORD &&
#if defined (SELECT_COMMAND)
      (token_before_that == FOR || token_before_that == SELECT) &&
#else
      (token_before_that == FOR) &&
#endif
      (tokstr[0] == 'd' && tokstr[1] == 'o' && tokstr[2] == '\0'))
    {
      if (expecting_in_token)
	expecting_in_token--;
      return (DO);
    }

  /* Ditto for ESAC in the CASE case.
     Specifically, this handles "case word in esac", which is a legal
     construct, certainly because someone will pass an empty arg to the
     case construct, and we don't want it to barf.  Of course, we should
     insist that the case construct has at least one pattern in it, but
     the designers disagree. */
  if (esacs_needed_count)
    {
      if (last_read_token == IN && STREQ (tokstr, "esac"))
	{
	  esacs_needed_count--;
	  parser_state &= ~PST_CASEPAT;
	  return (ESAC);
	}
    }

  /* The start of a shell function definition. */
  if (parser_state & PST_ALLOWOPNBRC)
    {
      parser_state &= ~PST_ALLOWOPNBRC;
      if (tokstr[0] == '{' && tokstr[1] == '\0')		/* } */
	{
	  open_brace_count++;
	  function_bstart = line_number;
	  return ('{');					/* } */
	}
    }

  /* We allow a `do' after a for ((...)) without an intervening
     list_terminator */
  if (last_read_token == ARITH_FOR_EXPRS && tokstr[0] == 'd' && tokstr[1] == 'o' && !tokstr[2])
    return (DO);
  if (last_read_token == ARITH_FOR_EXPRS && tokstr[0] == '{' && tokstr[1] == '\0')	/* } */
    {
      open_brace_count++;
      return ('{');			/* } */
    }

  if (open_brace_count && reserved_word_acceptable (last_read_token) && tokstr[0] == '}' && !tokstr[1])
    {
      open_brace_count--;		/* { */
      return ('}');
    }

#if defined (COMMAND_TIMING)
  /* Handle -p after `time'. */
  if (last_read_token == TIME && tokstr[0] == '-' && tokstr[1] == 'p' && !tokstr[2])
    return (TIMEOPT);
  /* Handle -- after `time'. */
  if (last_read_token == TIME && tokstr[0] == '-' && tokstr[1] == '-' && !tokstr[2])
    return (TIMEIGN);
  /* Handle -- after `time -p'. */
  if (last_read_token == TIMEOPT && tokstr[0] == '-' && tokstr[1] == '-' && !tokstr[2])
    return (TIMEIGN);
#endif

#if defined (COND_COMMAND) /* [[ */
  if ((parser_state & PST_CONDEXPR) && tokstr[0] == ']' && tokstr[1] == ']' && tokstr[2] == '\0')
    return (COND_END);
#endif

  return (-1);
}
warning: parse error {
  /* Posix grammar rule 6 */
  if ((last_read_token == WORD) &&
#if defined (SELECT_COMMAND)
      ((token_before_that == FOR) || (token_before_that == CASE) || (token_before_that == SELECT)) &&
#else
      ((token_before_that == FOR) || (token_before_that == CASE)) &&
#endif
      (tokstr[0] == 'i' && tokstr[1] == 'n' && tokstr[2] == 0))
    {
      if (token_before_that == CASE)
	{
	  parser_state |= PST_CASEPAT;
	  esacs_needed_count++;
	}
      if (expecting_in_token)
	expecting_in_token--;
      return (IN);
    }

  /* XXX - leaving above code intact for now, but it should eventually be
     removed in favor of this clause. */
  /* Posix grammar rule 6 */
  if (expecting_in_token && (last_read_token == WORD || last_read_token == '\n') &&
      (tokstr[0] == 'i' && tokstr[1] == 'n' && tokstr[2] == 0))
    {
      if (parser_state & PST_CASESTMT)
	{
	  parser_state |= PST_CASEPAT;
	  esacs_needed_count++;
	}
      expecting_in_token--;
      return (IN);
    }
  /* Posix grammar rule 6, third word in FOR: for i; do command-list; done */
  else if (expecting_in_token && (last_read_token == '\n' || last_read_token == ';') &&
    (tokstr[0] == 'd' && tokstr[1] == 'o' && tokstr[2] == '\0'))
    {
      expecting_in_token--;
      return (DO);
    }

  /* for i do; command-list; done */
  if (last_read_token == WORD &&
#if defined (SELECT_COMMAND)
      (token_before_that == FOR || token_before_that == SELECT) &&
#else
      (token_before_that == FOR) &&
#endif
      (tokstr[0] == 'd' && tokstr[1] == 'o' && tokstr[2] == '\0'))
    {
      if (expecting_in_token)
	expecting_in_token--;
      return (DO);
    }

  /* Ditto for ESAC in the CASE case.
     Specifically, this handles "case word in esac", which is a legal
     construct, certainly because someone will pass an empty arg to the
     case construct, and we don't want it to barf.  Of course, we should
     insist that the case construct has at least one pattern in it, but
     the designers disagree. */
  if (esacs_needed_count)
    {
      if (last_read_token == IN && STREQ (tokstr, "esac"))
	{
	  esacs_needed_count--;
	  parser_state &= ~PST_CASEPAT;
	  return (ESAC);
	}
    }

  /* The start of a shell function definition. */
  if (parser_state & PST_ALLOWOPNBRC)
    {
      parser_state &= ~PST_ALLOWOPNBRC;
      if (tokstr[0] == '{' && tokstr[1] == '\0')		/* } */
	{
	  open_brace_count++;
	  function_bstart = line_number;
	  return ('{');					/* } */
	}
    }

  /* We allow a `do' after a for ((...)) without an intervening
     list_terminator */
  if (last_read_token == ARITH_FOR_EXPRS && tokstr[0] == 'd' && tokstr[1] == 'o' && !tokstr[2])
    return (DO);
  if (last_read_token == ARITH_FOR_EXPRS && tokstr[0] == '{' && tokstr[1] == '\0')	/* } */
    {
      open_brace_count++;
      return ('{');			/* } */
    }

  if (open_brace_count && reserved_word_acceptable (last_read_token) && tokstr[0] == '}' && !tokstr[1])
    {
      open_brace_count--;		/* { */
      return ('}');
    }

#if defined (COMMAND_TIMING)
  /* Handle -p after `time'. */
  if (last_read_token == TIME && tokstr[0] == '-' && tokstr[1] == 'p' && !tokstr[2])
    return (TIMEOPT);
  /* Handle -- after `time'. */
  if (last_read_token == TIME && tokstr[0] == '-' && tokstr[1] == '-' && !tokstr[2])
    return (TIMEIGN);
  /* Handle -- after `time -p'. */
  if (last_read_token == TIMEOPT && tokstr[0] == '-' && tokstr[1] == '-' && !tokstr[2])
    return (TIMEIGN);
#endif

#if defined (COND_COMMAND) /* [[ */
  if ((parser_state & PST_CONDEXPR) && tokstr[0] == ']' && tokstr[1] == ']' && tokstr[2] == '\0')
    return (COND_END);
#endif

  return (-1);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\y.tab.c:5,365
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\y.tab.c:5,535
parsing error 
{
  int character;		/* Current character. */
  int peek_char;		/* Temporary look-ahead character. */
  int result;			/* The thing to return. */

  if (command == RESET)
    {
      reset_parser ();
      return ('\n');
    }

  if (token_to_read)
    {
      result = token_to_read;
      if (token_to_read == WORD || token_to_read == ASSIGNMENT_WORD)
	{
	  yylval.word = word_desc_to_read;
	  word_desc_to_read = (WORD_DESC *)NULL;
	}
      token_to_read = 0;
      return (result);
    }

#if defined (COND_COMMAND)
  if ((parser_state & (PST_CONDCMD|PST_CONDEXPR)) == PST_CONDCMD)
    {
      cond_lineno = line_number;
      parser_state |= PST_CONDEXPR;
      yylval.command = parse_cond_command ();
      if (cond_token != COND_END)
	{
	  cond_error ();
	  return (-1);
	}
      token_to_read = COND_END;
      parser_state &= ~(PST_CONDEXPR|PST_CONDCMD);
      return (COND_CMD);
    }
#endif

#if defined (ALIAS)
  /* This is a place to jump back to once we have successfully expanded a
     token with an alias and pushed the string with push_string () */
 re_read_token:
#endif /* ALIAS */

  /* Read a single word from input.  Start by skipping blanks. */
  while ((character = shell_getc (1)) != EOF && shellblank (character))
    ;

  if (character == EOF)
    {
      EOF_Reached = 1;
      return (yacc_EOF);
    }

  /* If we hit the end of the string and we're not expanding an alias (e.g.,
     we are eval'ing a string that is an incomplete command), return EOF */
  if (character == '\0' && bash_input.type == st_string && expanding_alias() == 0)
    {
#if defined (DEBUG)
itrace("shell_getc: bash_input.location.string = `%s'", bash_input.location.string);
#endif
      EOF_Reached = 1;
      return (yacc_EOF);
    }

  if MBTEST(character == '#' && (!interactive || interactive_comments))
    {
      /* A comment.  Discard until EOL or EOF, and then return a newline. */
      parser_state |= PST_COMMENT;
      discard_until ('\n');
      shell_getc (0);
      parser_state &= ~PST_COMMENT;
      character = '\n';	/* this will take the next if statement and return. */
    }

  if (character == '\n')
    {
      /* If we're about to return an unquoted newline, we can go and collect
	 the text of any pending here document. */
      if (need_here_doc)
	gather_here_documents ();

#if defined (ALIAS)
      parser_state &= ~PST_ALEXPNEXT;
#endif /* ALIAS */

      parser_state &= ~PST_ASSIGNOK;

      return (character);
    }

  if (parser_state & PST_REGEXP)
    goto tokword;

  /* Shell meta-characters. */
  if MBTEST(shellmeta (character) && ((parser_state & PST_DBLPAREN) == 0))
    {
#if defined (ALIAS)
      /* Turn off alias tokenization iff this character sequence would
	 not leave us ready to read a command. */
      if (character == '<' || character == '>')
	parser_state &= ~PST_ALEXPNEXT;
#endif /* ALIAS */

      parser_state &= ~PST_ASSIGNOK;

      /* If we are parsing a command substitution and we have read a character
	 that marks the end of it, don't bother to skip over quoted newlines
	 when we read the next token. We're just interested in a character
	 that will turn this into a two-character token, so we let the higher
	 layers deal with quoted newlines following the command substitution. */
      if ((parser_state & PST_CMDSUBST) && character == shell_eof_token)
	peek_char = shell_getc (0);
      else
	peek_char = shell_getc (1);

      if (character == peek_char)
	{
	  switch (character)
	    {
	    case '<':
	      /* If '<' then we could be at "<<" or at "<<-".  We have to
		 look ahead one more character. */
	      peek_char = shell_getc (1);
	      if MBTEST(peek_char == '-')
		return (LESS_LESS_MINUS);
	      else if MBTEST(peek_char == '<')
		return (LESS_LESS_LESS);
	      else
		{
		  shell_ungetc (peek_char);
		  return (LESS_LESS);
		}

	    case '>':
	      return (GREATER_GREATER);

	    case ';':
	      parser_state |= PST_CASEPAT;
#if defined (ALIAS)
	      parser_state &= ~PST_ALEXPNEXT;
#endif /* ALIAS */

	      peek_char = shell_getc (1);
	      if MBTEST(peek_char == '&')
		return (SEMI_SEMI_AND);
	      else
		{
		  shell_ungetc (peek_char);
		  return (SEMI_SEMI);
		}

	    case '&':
	      return (AND_AND);

	    case '|':
	      return (OR_OR);

#if defined (DPAREN_ARITHMETIC) || defined (ARITH_FOR_COMMAND)
	    case '(':		/* ) */
	      result = parse_dparen (character);
	      if (result == -2)
	        break;
	      else
	        return result;
#endif
	    }
	}
      else if MBTEST(character == '<' && peek_char == '&')
	return (LESS_AND);
      else if MBTEST(character == '>' && peek_char == '&')
	return (GREATER_AND);
      else if MBTEST(character == '<' && peek_char == '>')
	return (LESS_GREATER);
      else if MBTEST(character == '>' && peek_char == '|')
	return (GREATER_BAR);
      else if MBTEST(character == '&' && peek_char == '>')
	{
	  peek_char = shell_getc (1);
	  if MBTEST(peek_char == '>')
	    return (AND_GREATER_GREATER);
	  else
	    {
	      shell_ungetc (peek_char);
	      return (AND_GREATER);
	    }
	}
      else if MBTEST(character == '|' && peek_char == '&')
	return (BAR_AND);
      else if MBTEST(character == ';' && peek_char == '&')
	{
	  parser_state |= PST_CASEPAT;
#if defined (ALIAS)
	  parser_state &= ~PST_ALEXPNEXT;
#endif /* ALIAS */
	  return (SEMI_AND);
	}

      shell_ungetc (peek_char);

      /* If we look like we are reading the start of a function
	 definition, then let the reader know about it so that
	 we will do the right thing with `{'. */
      if MBTEST(character == ')' && last_read_token == '(' && token_before_that == WORD)
	{
	  parser_state |= PST_ALLOWOPNBRC;
#if defined (ALIAS)
	  parser_state &= ~PST_ALEXPNEXT;
#endif /* ALIAS */
	  function_dstart = line_number;
	}

      /* case pattern lists may be preceded by an optional left paren.  If
	 we're not trying to parse a case pattern list, the left paren
	 indicates a subshell. */
      if MBTEST(character == '(' && (parser_state & PST_CASEPAT) == 0) /* ) */
	parser_state |= PST_SUBSHELL;
      /*(*/
      else if MBTEST((parser_state & PST_CASEPAT) && character == ')')
	parser_state &= ~PST_CASEPAT;
      /*(*/
      else if MBTEST((parser_state & PST_SUBSHELL) && character == ')')
	parser_state &= ~PST_SUBSHELL;

#if defined (PROCESS_SUBSTITUTION)
      /* Check for the constructs which introduce process substitution.
	 Shells running in `posix mode' don't do process substitution. */
      if MBTEST((character != '>' && character != '<') || peek_char != '(') /*)*/
#endif /* PROCESS_SUBSTITUTION */
	return (character);
    }

  /* Hack <&- (close stdin) case.  Also <&N- (dup and close). */
  if MBTEST(character == '-' && (last_read_token == LESS_AND || last_read_token == GREATER_AND))
    return (character);

tokword:
  /* Okay, if we got this far, we have to read a word.  Read one,
     and then check it against the known ones. */
  result = read_token_word (character);
#if defined (ALIAS)
  if (result == RE_READ_TOKEN)
    goto re_read_token;
#endif
  return result;
}
warning: parse error {
  int character;		/* Current character. */
  int peek_char;		/* Temporary look-ahead character. */
  int result;			/* The thing to return. */

  if (command == RESET)
    {
      reset_parser ();
      return ('\n');
    }

  if (token_to_read)
    {
      result = token_to_read;
      if (token_to_read == WORD || token_to_read == ASSIGNMENT_WORD)
	{
	  yylval.word = word_desc_to_read;
	  word_desc_to_read = (WORD_DESC *)NULL;
	}
      token_to_read = 0;
      return (result);
    }

#if defined (COND_COMMAND)
  if ((parser_state & (PST_CONDCMD|PST_CONDEXPR)) == PST_CONDCMD)
    {
      cond_lineno = line_number;
      parser_state |= PST_CONDEXPR;
      yylval.command = parse_cond_command ();
      if (cond_token != COND_END)
	{
	  cond_error ();
	  return (-1);
	}
      token_to_read = COND_END;
      parser_state &= ~(PST_CONDEXPR|PST_CONDCMD);
      return (COND_CMD);
    }
#endif

#if defined (ALIAS)
  /* This is a place to jump back to once we have successfully expanded a
     token with an alias and pushed the string with push_string () */
 re_read_token:
#endif /* ALIAS */

  /* Read a single word from input.  Start by skipping blanks. */
  while ((character = shell_getc (1)) != EOF && shellblank (character))
    ;

  if (character == EOF)
    {
      EOF_Reached = 1;
      return (yacc_EOF);
    }

  /* If we hit the end of the string and we're not expanding an alias (e.g.,
     we are eval'ing a string that is an incomplete command), return EOF */
  if (character == '\0' && bash_input.type == st_string && expanding_alias() == 0)
    {
#if defined (DEBUG)
itrace("shell_getc: bash_input.location.string = `%s'", bash_input.location.string);
#endif
      EOF_Reached = 1;
      return (yacc_EOF);
    }

  if MBTEST(character == '#' && (!interactive || interactive_comments))
    {
      /* A comment.  Discard until EOL or EOF, and then return a newline. */
      parser_state |= PST_COMMENT;
      discard_until ('\n');
      shell_getc (0);
      parser_state &= ~PST_COMMENT;
      character = '\n';	/* this will take the next if statement and return. */
    }

  if (character == '\n')
    {
      /* If we're about to return an unquoted newline, we can go and collect
	 the text of any pending here document. */
      if (need_here_doc)
	gather_here_documents ();

#if defined (ALIAS)
      parser_state &= ~PST_ALEXPNEXT;
#endif /* ALIAS */

      parser_state &= ~PST_ASSIGNOK;

      return (character);
    }

  if (parser_state & PST_REGEXP)
    goto tokword;

  /* Shell meta-characters. */
  if MBTEST(shellmeta (character) && ((parser_state & PST_DBLPAREN) == 0))
    {
#if defined (ALIAS)
      /* Turn off alias tokenization iff this character sequence would
	 not leave us ready to read a command. */
      if (character == '<' || character == '>')
	parser_state &= ~PST_ALEXPNEXT;
#endif /* ALIAS */

      parser_state &= ~PST_ASSIGNOK;

      /* If we are parsing a command substitution and we have read a character
	 that marks the end of it, don't bother to skip over quoted newlines
	 when we read the next token. We're just interested in a character
	 that will turn this into a two-character token, so we let the higher
	 layers deal with quoted newlines following the command substitution. */
      if ((parser_state & PST_CMDSUBST) && character == shell_eof_token)
	peek_char = shell_getc (0);
      else
	peek_char = shell_getc (1);

      if (character == peek_char)
	{
	  switch (character)
	    {
	    case '<':
	      /* If '<' then we could be at "<<" or at "<<-".  We have to
		 look ahead one more character. */
	      peek_char = shell_getc (1);
	      if MBTEST(peek_char == '-')
		return (LESS_LESS_MINUS);
	      else if MBTEST(peek_char == '<')
		return (LESS_LESS_LESS);
	      else
		{
		  shell_ungetc (peek_char);
		  return (LESS_LESS);
		}

	    case '>':
	      return (GREATER_GREATER);

	    case ';':
	      parser_state |= PST_CASEPAT;
#if defined (ALIAS)
	      parser_state &= ~PST_ALEXPNEXT;
#endif /* ALIAS */

	      peek_char = shell_getc (1);
	      if MBTEST(peek_char == '&')
		return (SEMI_SEMI_AND);
	      else
		{
		  shell_ungetc (peek_char);
		  return (SEMI_SEMI);
		}

	    case '&':
	      return (AND_AND);

	    case '|':
	      return (OR_OR);

#if defined (DPAREN_ARITHMETIC) || defined (ARITH_FOR_COMMAND)
	    case '(':		/* ) */
	      result = parse_dparen (character);
	      if (result == -2)
	        break;
	      else
	        return result;
#endif
	    }
	}
      else if MBTEST(character == '<' && peek_char == '&')
	return (LESS_AND);
      else if MBTEST(character == '>' && peek_char == '&')
	return (GREATER_AND);
      else if MBTEST(character == '<' && peek_char == '>')
	return (LESS_GREATER);
      else if MBTEST(character == '>' && peek_char == '|')
	return (GREATER_BAR);
      else if MBTEST(character == '&' && peek_char == '>')
	{
	  peek_char = shell_getc (1);
	  if MBTEST(peek_char == '>')
	    return (AND_GREATER_GREATER);
	  else
	    {
	      shell_ungetc (peek_char);
	      return (AND_GREATER);
	    }
	}
      else if MBTEST(character == '|' && peek_char == '&')
	return (BAR_AND);
      else if MBTEST(character == ';' && peek_char == '&')
	{
	  parser_state |= PST_CASEPAT;
#if defined (ALIAS)
	  parser_state &= ~PST_ALEXPNEXT;
#endif /* ALIAS */
	  return (SEMI_AND);
	}

      shell_ungetc (peek_char);

      /* If we look like we are reading the start of a function
	 definition, then let the reader know about it so that
	 we will do the right thing with `{'. */
      if MBTEST(character == ')' && last_read_token == '(' && token_before_that == WORD)
	{
	  parser_state |= PST_ALLOWOPNBRC;
#if defined (ALIAS)
	  parser_state &= ~PST_ALEXPNEXT;
#endif /* ALIAS */
	  function_dstart = line_number;
	}

      /* case pattern lists may be preceded by an optional left paren.  If
	 we're not trying to parse a case pattern list, the left paren
	 indicates a subshell. */
      if MBTEST(character == '(' && (parser_state & PST_CASEPAT) == 0) /* ) */
	parser_state |= PST_SUBSHELL;
      /*(*/
      else if MBTEST((parser_state & PST_CASEPAT) && character == ')')
	parser_state &= ~PST_CASEPAT;
      /*(*/
      else if MBTEST((parser_state & PST_SUBSHELL) && character == ')')
	parser_state &= ~PST_SUBSHELL;

#if defined (PROCESS_SUBSTITUTION)
      /* Check for the constructs which introduce process substitution.
	 Shells running in `posix mode' don't do process substitution. */
      if MBTEST((character != '>' && character != '<') || peek_char != '(') /*)*/
#endif /* PROCESS_SUBSTITUTION */
	return (character);
    }

  /* Hack <&- (close stdin) case.  Also <&N- (dup and close). */
  if MBTEST(character == '-' && (last_read_token == LESS_AND || last_read_token == GREATER_AND))
    return (character);

tokword:
  /* Okay, if we got this far, we have to read a word.  Read one,
     and then check it against the known ones. */
  result = read_token_word (character);
#if defined (ALIAS)
  if (result == RE_READ_TOKEN)
    goto re_read_token;
#endif
  return result;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\y.tab.c:5,537
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\y.tab.c:5,839
parsing error 
{
  int count, ch, prevch, tflags;
  int nestlen, ttranslen, start_lineno;
  char *ret, *nestret, *ttrans;
  int retind, retsize, rflags;
  int dolbrace_state;

  dolbrace_state = (flags & P_DOLBRACE) ? DOLBRACE_PARAM : 0;

/*itrace("parse_matched_pair[%d]: open = %c close = %c flags = %d", line_number, open, close, flags);*/
  count = 1;
  tflags = 0;

  if ((flags & P_COMMAND) && qc != '`' && qc != '\'' && qc != '"' && (flags & P_DQUOTE) == 0)
    tflags |= LEX_CKCOMMENT;

  /* RFLAGS is the set of flags we want to pass to recursive calls. */
  rflags = (qc == '"') ? P_DQUOTE : (flags & P_DQUOTE);

  ret = (char *)xmalloc (retsize = 64);
  retind = 0;

  start_lineno = line_number;
  ch = EOF;		/* just in case */
  while (count)
    {
      prevch = ch;
      ch = shell_getc (qc != '\'' && (tflags & (LEX_PASSNEXT)) == 0);

      if (ch == EOF)
	{
	  free (ret);
	  parser_error (start_lineno, _("unexpected EOF while looking for matching `%c'"), close);
	  EOF_Reached = 1;	/* XXX */
	  return (&matched_pair_error);
	}

      /* Possible reprompting. */
      if (ch == '\n' && SHOULD_PROMPT ())
	prompt_again ();

      /* Don't bother counting parens or doing anything else if in a comment
	 or part of a case statement */
      if (tflags & LEX_INCOMMENT)
	{
	  /* Add this character. */
	  RESIZE_MALLOCED_BUFFER (ret, retind, 1, retsize, 64);
	  ret[retind++] = ch;

	  if (ch == '\n')
	    tflags &= ~LEX_INCOMMENT;

	  continue;
	}

      /* Not exactly right yet, should handle shell metacharacters, too.  If
	 any changes are made to this test, make analogous changes to subst.c:
	 extract_delimited_string(). */
      else if MBTEST((tflags & LEX_CKCOMMENT) && (tflags & LEX_INCOMMENT) == 0 && ch == '#' && (retind == 0 || ret[retind-1] == '\n' || shellblank (ret[retind - 1])))
	tflags |= LEX_INCOMMENT;

      if (tflags & LEX_PASSNEXT)		/* last char was backslash */
	{
	  tflags &= ~LEX_PASSNEXT;
	  if (qc != '\'' && ch == '\n')	/* double-quoted \<newline> disappears. */
	    {
	      if (retind > 0)
		retind--;	/* swallow previously-added backslash */
	      continue;
	    }

	  RESIZE_MALLOCED_BUFFER (ret, retind, 2, retsize, 64);
	  if MBTEST(ch == CTLESC)
	    ret[retind++] = CTLESC;
	  ret[retind++] = ch;
	  continue;
	}
      /* If we're reparsing the input (e.g., from parse_string_to_word_list),
	 we've already prepended CTLESC to single-quoted results of $'...'.
	 We may want to do this for other CTLESC-quoted characters in
	 reparse, too. */
      else if MBTEST((parser_state & PST_REPARSE) && open == '\'' && (ch == CTLESC || ch == CTLNUL))
	{
	  RESIZE_MALLOCED_BUFFER (ret, retind, 1, retsize, 64);
	  ret[retind++] = ch;
	  continue;
	}
      else if MBTEST(ch == CTLESC || ch == CTLNUL)	/* special shell escapes */
	{
	  RESIZE_MALLOCED_BUFFER (ret, retind, 2, retsize, 64);
	  ret[retind++] = CTLESC;
	  ret[retind++] = ch;
	  continue;
	}
      else if MBTEST(ch == close)		/* ending delimiter */
	count--;
      /* handle nested ${...} specially. */
      else if MBTEST(open != close && (tflags & LEX_WASDOL) && open == '{' && ch == open) /* } */
	count++;
      else if MBTEST(((flags & P_FIRSTCLOSE) == 0) && ch == open)	/* nested begin */
	count++;

      /* Add this character. */
      RESIZE_MALLOCED_BUFFER (ret, retind, 1, retsize, 64);
      ret[retind++] = ch;

      /* If we just read the ending character, don't bother continuing. */
      if (count == 0)
	break;

      if (open == '\'')			/* '' inside grouping construct */
	{
	  if MBTEST((flags & P_ALLOWESC) && ch == '\\')
	    tflags |= LEX_PASSNEXT;
	  continue;
	}

      if MBTEST(ch == '\\')			/* backslashes */
	tflags |= LEX_PASSNEXT;

      /* Based on which dolstate is currently in (param, op, or word),
	 decide what the op is.  We're really only concerned if it's % or
	 #, so we can turn on a flag that says whether or not we should
	 treat single quotes as special when inside a double-quoted
	 ${...}. This logic must agree with subst.c:extract_dollar_brace_string
	 since they share the same defines. */
      /* FLAG POSIX INTERP 221 */
      if (flags & P_DOLBRACE)
        {
          /* ${param%[%]word} */
	  if MBTEST(dolbrace_state == DOLBRACE_PARAM && ch == '%' && retind > 1)
	    dolbrace_state = DOLBRACE_QUOTE;
          /* ${param#[#]word} */
	  else if MBTEST(dolbrace_state == DOLBRACE_PARAM && ch == '#' && retind > 1)
	    dolbrace_state = DOLBRACE_QUOTE;
          /* ${param/[/]pat/rep} */
	  else if MBTEST(dolbrace_state == DOLBRACE_PARAM && ch == '/' && retind > 1)
	    dolbrace_state = DOLBRACE_QUOTE2;	/* XXX */
          /* ${param^[^]pat} */
	  else if MBTEST(dolbrace_state == DOLBRACE_PARAM && ch == '^' && retind > 1)
	    dolbrace_state = DOLBRACE_QUOTE;
          /* ${param,[,]pat} */
	  else if MBTEST(dolbrace_state == DOLBRACE_PARAM && ch == ',' && retind > 1)
	    dolbrace_state = DOLBRACE_QUOTE;
	  else if MBTEST(dolbrace_state == DOLBRACE_PARAM && strchr ("#%^,~:-=?+/", ch) != 0)
	    dolbrace_state = DOLBRACE_OP;
	  else if MBTEST(dolbrace_state == DOLBRACE_OP && strchr ("#%^,~:-=?+/", ch) == 0)
	    dolbrace_state = DOLBRACE_WORD;
        }

      /* The big hammer.  Single quotes aren't special in double quotes.  The
         problem is that Posix used to say the single quotes are semi-special:
         within a double-quoted ${...} construct "an even number of
         unescaped double-quotes or single-quotes, if any, shall occur." */
      /* This was changed in Austin Group Interp 221 */
      if MBTEST(posixly_correct && shell_compatibility_level > 41 && dolbrace_state != DOLBRACE_QUOTE && dolbrace_state != DOLBRACE_QUOTE2 && (flags & P_DQUOTE) && (flags & P_DOLBRACE) && ch == '\'')
	continue;

      /* Could also check open == '`' if we want to parse grouping constructs
	 inside old-style command substitution. */
      if (open != close)		/* a grouping construct */
	{
	  if MBTEST(shellquote (ch))
	    {
	      /* '', ``, or "" inside $(...) or other grouping construct. */
	      push_delimiter (dstack, ch);
	      if MBTEST((tflags & LEX_WASDOL) && ch == '\'')	/* $'...' inside group */
		nestret = parse_matched_pair (ch, ch, ch, &nestlen, P_ALLOWESC|rflags);
	      else
		nestret = parse_matched_pair (ch, ch, ch, &nestlen, rflags);
	      pop_delimiter (dstack);
	      CHECK_NESTRET_ERROR ();

	      if MBTEST((tflags & LEX_WASDOL) && ch == '\'' && (extended_quote || (rflags & P_DQUOTE) == 0))
		{
		  /* Translate $'...' here. */
		  ttrans = ansiexpand (nestret, 0, nestlen - 1, &ttranslen);
		  free (nestret);

		  /* If we're parsing a double-quoted brace expansion and we are
		     not in a place where single quotes are treated specially,
		     make sure we single-quote the results of the ansi
		     expansion because quote removal should remove them later */
		  /* FLAG POSIX INTERP 221 */
		  if ((shell_compatibility_level > 42) && (rflags & P_DQUOTE) && (dolbrace_state == DOLBRACE_QUOTE2) && (flags & P_DOLBRACE))
		    {
		      nestret = sh_single_quote (ttrans);
		      free (ttrans);
		      nestlen = strlen (nestret);
		    }
		  else if ((rflags & P_DQUOTE) == 0)
		    {
		      nestret = sh_single_quote (ttrans);
		      free (ttrans);
		      nestlen = strlen (nestret);
		    }
		  else
		    {
		      nestret = ttrans;
		      nestlen = ttranslen;
		    }
		  retind -= 2;		/* back up before the $' */
		}
	      else if MBTEST((tflags & LEX_WASDOL) && ch == '"' && (extended_quote || (rflags & P_DQUOTE) == 0))
		{
		  /* Locale expand $"..." here. */
		  ttrans = localeexpand (nestret, 0, nestlen - 1, start_lineno, &ttranslen);
		  free (nestret);

		  nestret = sh_mkdoublequoted (ttrans, ttranslen, 0);
		  free (ttrans);
		  nestlen = ttranslen + 2;
		  retind -= 2;		/* back up before the $" */
		}

	      APPEND_NESTRET ();
	      FREE (nestret);
	    }
	  else if ((flags & (P_ARRAYSUB|P_DOLBRACE)) && (tflags & LEX_WASDOL) && (ch == '(' || ch == '{' || ch == '['))	/* ) } ] */
	    goto parse_dollar_word;
#if defined (PROCESS_SUBSTITUTION)
	  /* XXX - technically this should only be recognized at the start of
	     a word */
	  else if ((flags & (P_ARRAYSUB|P_DOLBRACE)) && (tflags & LEX_GTLT) && (ch == '('))	/* ) */
	    goto parse_dollar_word;
#endif
	}
      /* Parse an old-style command substitution within double quotes as a
	 single word. */
      /* XXX - sh and ksh93 don't do this - XXX */
      else if MBTEST(open == '"' && ch == '`')
	{
	  nestret = parse_matched_pair (0, '`', '`', &nestlen, rflags);

	  CHECK_NESTRET_ERROR ();
	  APPEND_NESTRET ();

	  FREE (nestret);
	}
      else if MBTEST(open != '`' && (tflags & LEX_WASDOL) && (ch == '(' || ch == '{' || ch == '['))	/* ) } ] */
	/* check for $(), $[], or ${} inside quoted string. */
	{
parse_dollar_word:
	  if (open == ch)	/* undo previous increment */
	    count--;
	  if (ch == '(')		/* ) */
	    nestret = parse_comsub (0, '(', ')', &nestlen, (rflags|P_COMMAND) & ~P_DQUOTE);
	  else if (ch == '{')		/* } */
	    nestret = parse_matched_pair (0, '{', '}', &nestlen, P_FIRSTCLOSE|P_DOLBRACE|rflags);
	  else if (ch == '[')		/* ] */
	    nestret = parse_matched_pair (0, '[', ']', &nestlen, rflags);

	  CHECK_NESTRET_ERROR ();
	  APPEND_NESTRET ();

	  FREE (nestret);
	}
#if defined (PROCESS_SUBSTITUTION)
      if MBTEST((ch == '<' || ch == '>') && (tflags & LEX_GTLT) == 0)
	tflags |= LEX_GTLT;
      else
	tflags &= ~LEX_GTLT;
#endif
      if MBTEST(ch == '$' && (tflags & LEX_WASDOL) == 0)
	tflags |= LEX_WASDOL;
      else
	tflags &= ~LEX_WASDOL;
    }

  ret[retind] = '\0';
  if (lenp)
    *lenp = retind;
/*itrace("parse_matched_pair[%d]: returning %s", line_number, ret);*/
  return ret;
}
warning: parse error {
  int count, ch, prevch, tflags;
  int nestlen, ttranslen, start_lineno;
  char *ret, *nestret, *ttrans;
  int retind, retsize, rflags;
  int dolbrace_state;

  dolbrace_state = (flags & P_DOLBRACE) ? DOLBRACE_PARAM : 0;

/*itrace("parse_matched_pair[%d]: open = %c close = %c flags = %d", line_number, open, close, flags);*/
  count = 1;
  tflags = 0;

  if ((flags & P_COMMAND) && qc != '`' && qc != '\'' && qc != '"' && (flags & P_DQUOTE) == 0)
    tflags |= LEX_CKCOMMENT;

  /* RFLAGS is the set of flags we want to pass to recursive calls. */
  rflags = (qc == '"') ? P_DQUOTE : (flags & P_DQUOTE);

  ret = (char *)xmalloc (retsize = 64);
  retind = 0;

  start_lineno = line_number;
  ch = EOF;		/* just in case */
  while (count)
    {
      prevch = ch;
      ch = shell_getc (qc != '\'' && (tflags & (LEX_PASSNEXT)) == 0);

      if (ch == EOF)
	{
	  free (ret);
	  parser_error (start_lineno, _("unexpected EOF while looking for matching `%c'"), close);
	  EOF_Reached = 1;	/* XXX */
	  return (&matched_pair_error);
	}

      /* Possible reprompting. */
      if (ch == '\n' && SHOULD_PROMPT ())
	prompt_again ();

      /* Don't bother counting parens or doing anything else if in a comment
	 or part of a case statement */
      if (tflags & LEX_INCOMMENT)
	{
	  /* Add this character. */
	  RESIZE_MALLOCED_BUFFER (ret, retind, 1, retsize, 64);
	  ret[retind++] = ch;

	  if (ch == '\n')
	    tflags &= ~LEX_INCOMMENT;

	  continue;
	}

      /* Not exactly right yet, should handle shell metacharacters, too.  If
	 any changes are made to this test, make analogous changes to subst.c:
	 extract_delimited_string(). */
      else if MBTEST((tflags & LEX_CKCOMMENT) && (tflags & LEX_INCOMMENT) == 0 && ch == '#' && (retind == 0 || ret[retind-1] == '\n' || shellblank (ret[retind - 1])))
	tflags |= LEX_INCOMMENT;

      if (tflags & LEX_PASSNEXT)		/* last char was backslash */
	{
	  tflags &= ~LEX_PASSNEXT;
	  if (qc != '\'' && ch == '\n')	/* double-quoted \<newline> disappears. */
	    {
	      if (retind > 0)
		retind--;	/* swallow previously-added backslash */
	      continue;
	    }

	  RESIZE_MALLOCED_BUFFER (ret, retind, 2, retsize, 64);
	  if MBTEST(ch == CTLESC)
	    ret[retind++] = CTLESC;
	  ret[retind++] = ch;
	  continue;
	}
      /* If we're reparsing the input (e.g., from parse_string_to_word_list),
	 we've already prepended CTLESC to single-quoted results of $'...'.
	 We may want to do this for other CTLESC-quoted characters in
	 reparse, too. */
      else if MBTEST((parser_state & PST_REPARSE) && open == '\'' && (ch == CTLESC || ch == CTLNUL))
	{
	  RESIZE_MALLOCED_BUFFER (ret, retind, 1, retsize, 64);
	  ret[retind++] = ch;
	  continue;
	}
      else if MBTEST(ch == CTLESC || ch == CTLNUL)	/* special shell escapes */
	{
	  RESIZE_MALLOCED_BUFFER (ret, retind, 2, retsize, 64);
	  ret[retind++] = CTLESC;
	  ret[retind++] = ch;
	  continue;
	}
      else if MBTEST(ch == close)		/* ending delimiter */
	count--;
      /* handle nested ${...} specially. */
      else if MBTEST(open != close && (tflags & LEX_WASDOL) && open == '{' && ch == open) /* } */
	count++;
      else if MBTEST(((flags & P_FIRSTCLOSE) == 0) && ch == open)	/* nested begin */
	count++;

      /* Add this character. */
      RESIZE_MALLOCED_BUFFER (ret, retind, 1, retsize, 64);
      ret[retind++] = ch;

      /* If we just read the ending character, don't bother continuing. */
      if (count == 0)
	break;

      if (open == '\'')			/* '' inside grouping construct */
	{
	  if MBTEST((flags & P_ALLOWESC) && ch == '\\')
	    tflags |= LEX_PASSNEXT;
	  continue;
	}

      if MBTEST(ch == '\\')			/* backslashes */
	tflags |= LEX_PASSNEXT;

      /* Based on which dolstate is currently in (param, op, or word),
	 decide what the op is.  We're really only concerned if it's % or
	 #, so we can turn on a flag that says whether or not we should
	 treat single quotes as special when inside a double-quoted
	 ${...}. This logic must agree with subst.c:extract_dollar_brace_string
	 since they share the same defines. */
      /* FLAG POSIX INTERP 221 */
      if (flags & P_DOLBRACE)
        {
          /* ${param%[%]word} */
	  if MBTEST(dolbrace_state == DOLBRACE_PARAM && ch == '%' && retind > 1)
	    dolbrace_state = DOLBRACE_QUOTE;
          /* ${param#[#]word} */
	  else if MBTEST(dolbrace_state == DOLBRACE_PARAM && ch == '#' && retind > 1)
	    dolbrace_state = DOLBRACE_QUOTE;
          /* ${param/[/]pat/rep} */
	  else if MBTEST(dolbrace_state == DOLBRACE_PARAM && ch == '/' && retind > 1)
	    dolbrace_state = DOLBRACE_QUOTE2;	/* XXX */
          /* ${param^[^]pat} */
	  else if MBTEST(dolbrace_state == DOLBRACE_PARAM && ch == '^' && retind > 1)
	    dolbrace_state = DOLBRACE_QUOTE;
          /* ${param,[,]pat} */
	  else if MBTEST(dolbrace_state == DOLBRACE_PARAM && ch == ',' && retind > 1)
	    dolbrace_state = DOLBRACE_QUOTE;
	  else if MBTEST(dolbrace_state == DOLBRACE_PARAM && strchr ("#%^,~:-=?+/", ch) != 0)
	    dolbrace_state = DOLBRACE_OP;
	  else if MBTEST(dolbrace_state == DOLBRACE_OP && strchr ("#%^,~:-=?+/", ch) == 0)
	    dolbrace_state = DOLBRACE_WORD;
        }

      /* The big hammer.  Single quotes aren't special in double quotes.  The
         problem is that Posix used to say the single quotes are semi-special:
         within a double-quoted ${...} construct "an even number of
         unescaped double-quotes or single-quotes, if any, shall occur." */
      /* This was changed in Austin Group Interp 221 */
      if MBTEST(posixly_correct && shell_compatibility_level > 41 && dolbrace_state != DOLBRACE_QUOTE && dolbrace_state != DOLBRACE_QUOTE2 && (flags & P_DQUOTE) && (flags & P_DOLBRACE) && ch == '\'')
	continue;

      /* Could also check open == '`' if we want to parse grouping constructs
	 inside old-style command substitution. */
      if (open != close)		/* a grouping construct */
	{
	  if MBTEST(shellquote (ch))
	    {
	      /* '', ``, or "" inside $(...) or other grouping construct. */
	      push_delimiter (dstack, ch);
	      if MBTEST((tflags & LEX_WASDOL) && ch == '\'')	/* $'...' inside group */
		nestret = parse_matched_pair (ch, ch, ch, &nestlen, P_ALLOWESC|rflags);
	      else
		nestret = parse_matched_pair (ch, ch, ch, &nestlen, rflags);
	      pop_delimiter (dstack);
	      CHECK_NESTRET_ERROR ();

	      if MBTEST((tflags & LEX_WASDOL) && ch == '\'' && (extended_quote || (rflags & P_DQUOTE) == 0))
		{
		  /* Translate $'...' here. */
		  ttrans = ansiexpand (nestret, 0, nestlen - 1, &ttranslen);
		  free (nestret);

		  /* If we're parsing a double-quoted brace expansion and we are
		     not in a place where single quotes are treated specially,
		     make sure we single-quote the results of the ansi
		     expansion because quote removal should remove them later */
		  /* FLAG POSIX INTERP 221 */
		  if ((shell_compatibility_level > 42) && (rflags & P_DQUOTE) && (dolbrace_state == DOLBRACE_QUOTE2) && (flags & P_DOLBRACE))
		    {
		      nestret = sh_single_quote (ttrans);
		      free (ttrans);
		      nestlen = strlen (nestret);
		    }
		  else if ((rflags & P_DQUOTE) == 0)
		    {
		      nestret = sh_single_quote (ttrans);
		      free (ttrans);
		      nestlen = strlen (nestret);
		    }
		  else
		    {
		      nestret = ttrans;
		      nestlen = ttranslen;
		    }
		  retind -= 2;		/* back up before the $' */
		}
	      else if MBTEST((tflags & LEX_WASDOL) && ch == '"' && (extended_quote || (rflags & P_DQUOTE) == 0))
		{
		  /* Locale expand $"..." here. */
		  ttrans = localeexpand (nestret, 0, nestlen - 1, start_lineno, &ttranslen);
		  free (nestret);

		  nestret = sh_mkdoublequoted (ttrans, ttranslen, 0);
		  free (ttrans);
		  nestlen = ttranslen + 2;
		  retind -= 2;		/* back up before the $" */
		}

	      APPEND_NESTRET ();
	      FREE (nestret);
	    }
	  else if ((flags & (P_ARRAYSUB|P_DOLBRACE)) && (tflags & LEX_WASDOL) && (ch == '(' || ch == '{' || ch == '['))	/* ) } ] */
	    goto parse_dollar_word;
#if defined (PROCESS_SUBSTITUTION)
	  /* XXX - technically this should only be recognized at the start of
	     a word */
	  else if ((flags & (P_ARRAYSUB|P_DOLBRACE)) && (tflags & LEX_GTLT) && (ch == '('))	/* ) */
	    goto parse_dollar_word;
#endif
	}
      /* Parse an old-style command substitution within double quotes as a
	 single word. */
      /* XXX - sh and ksh93 don't do this - XXX */
      else if MBTEST(open == '"' && ch == '`')
	{
	  nestret = parse_matched_pair (0, '`', '`', &nestlen, rflags);

	  CHECK_NESTRET_ERROR ();
	  APPEND_NESTRET ();

	  FREE (nestret);
	}
      else if MBTEST(open != '`' && (tflags & LEX_WASDOL) && (ch == '(' || ch == '{' || ch == '['))	/* ) } ] */
	/* check for $(), $[], or ${} inside quoted string. */
	{
parse_dollar_word:
	  if (open == ch)	/* undo previous increment */
	    count--;
	  if (ch == '(')		/* ) */
	    nestret = parse_comsub (0, '(', ')', &nestlen, (rflags|P_COMMAND) & ~P_DQUOTE);
	  else if (ch == '{')		/* } */
	    nestret = parse_matched_pair (0, '{', '}', &nestlen, P_FIRSTCLOSE|P_DOLBRACE|rflags);
	  else if (ch == '[')		/* ] */
	    nestret = parse_matched_pair (0, '[', ']', &nestlen, rflags);

	  CHECK_NESTRET_ERROR ();
	  APPEND_NESTRET ();

	  FREE (nestret);
	}
#if defined (PROCESS_SUBSTITUTION)
      if MBTEST((ch == '<' || ch == '>') && (tflags & LEX_GTLT) == 0)
	tflags |= LEX_GTLT;
      else
	tflags &= ~LEX_GTLT;
#endif
      if MBTEST(ch == '$' && (tflags & LEX_WASDOL) == 0)
	tflags |= LEX_WASDOL;
      else
	tflags &= ~LEX_WASDOL;
    }

  ret[retind] = '\0';
  if (lenp)
    *lenp = retind;
/*itrace("parse_matched_pair[%d]: returning %s", line_number, ret);*/
  return ret;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\y.tab.c:5,843
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\y.tab.c:6,197
parsing error 
{
  int count, ch, peekc, tflags, lex_rwlen, lex_wlen, lex_firstind;
  int nestlen, ttranslen, start_lineno, orig_histexp;
  char *ret, *nestret, *ttrans, *heredelim;
  int retind, retsize, rflags, hdlen;

  /* Posix interp 217 says arithmetic expressions have precedence, so
     assume $(( introduces arithmetic expansion and parse accordingly. */
  peekc = shell_getc (0);
  shell_ungetc (peekc);
  if (peekc == '(')
    return (parse_matched_pair (qc, open, close, lenp, 0));

/*itrace("parse_comsub: qc = `%c' open = %c close = %c", qc, open, close);*/
  count = 1;
  tflags = LEX_RESWDOK;
#if defined (BANG_HISTORY)
  orig_histexp = history_expansion_inhibited;
#endif

  if ((flags & P_COMMAND) && qc != '\'' && qc != '"' && (flags & P_DQUOTE) == 0)
    tflags |= LEX_CKCASE;
  if ((tflags & LEX_CKCASE) && (interactive == 0 || interactive_comments))
    tflags |= LEX_CKCOMMENT;

  /* RFLAGS is the set of flags we want to pass to recursive calls. */
  rflags = (flags & P_DQUOTE);

  ret = (char *)xmalloc (retsize = 64);
  retind = 0;

  start_lineno = line_number;
  lex_rwlen = lex_wlen = 0;

  heredelim = 0;
  lex_firstind = -1;

  while (count)
    {
comsub_readchar:
      ch = shell_getc (qc != '\'' && (tflags & (LEX_INCOMMENT|LEX_PASSNEXT|LEX_QUOTEDDOC)) == 0);

      if (ch == EOF)
	{
eof_error:
#if defined (BANG_HISTORY)
	  history_expansion_inhibited = orig_histexp;
#endif
	  free (ret);
	  FREE (heredelim);
	  parser_error (start_lineno, _("unexpected EOF while looking for matching `%c'"), close);
	  EOF_Reached = 1;	/* XXX */
	  return (&matched_pair_error);
	}

      /* If we hit the end of a line and are reading the contents of a here
	 document, and it's not the same line that the document starts on,
	 check for this line being the here doc delimiter.  Otherwise, if
	 we're in a here document, mark the next character as the beginning
	 of a line. */
      if (ch == '\n')
	{
	  if ((tflags & LEX_HEREDELIM) && heredelim)
	    {
	      tflags &= ~LEX_HEREDELIM;
	      tflags |= LEX_INHEREDOC;
#if defined (BANG_HISTORY)
	      history_expansion_inhibited = 1;
#endif
	      lex_firstind = retind + 1;
	    }
	  else if (tflags & LEX_INHEREDOC)
	    {
	      int tind;
	      tind = lex_firstind;
	      while ((tflags & LEX_STRIPDOC) && ret[tind] == '\t')
		tind++;
	      if (retind-tind == hdlen && STREQN (ret + tind, heredelim, hdlen))
		{
		  tflags &= ~(LEX_STRIPDOC|LEX_INHEREDOC|LEX_QUOTEDDOC);
/*itrace("parse_comsub:%d: found here doc end `%s'", line_number, ret + tind);*/
		  free (heredelim);
		  heredelim = 0;
		  lex_firstind = -1;
#if defined (BANG_HISTORY)
		  history_expansion_inhibited = orig_histexp;
#endif
		}
	      else
		lex_firstind = retind + 1;
	    }
	}

      /* Possible reprompting. */
      if (ch == '\n' && SHOULD_PROMPT ())
	prompt_again ();

      /* XXX -- we currently allow here doc to be delimited by ending right
	 paren in default mode and posix mode. To change posix mode, change
	 the #if 1 to #if 0 below */
      if ((tflags & LEX_INHEREDOC) && ch == close && count == 1)
	{
	  int tind;
/*itrace("parse_comsub:%d: in here doc, ch == close, retind - firstind = %d hdlen = %d retind = %d", line_number, retind-lex_firstind, hdlen, retind);*/
	  tind = lex_firstind;
	  while ((tflags & LEX_STRIPDOC) && ret[tind] == '\t')
	    tind++;
#if 1
  	  if (retind-tind == hdlen && STREQN (ret + tind, heredelim, hdlen))
#else
	  /* Posix-mode shells require the newline after the here-document
	     delimiter. */
	  if (retind-tind == hdlen && STREQN (ret + tind, heredelim, hdlen) &&
	      posixly_correct == 0)
#endif
	    {
	      tflags &= ~(LEX_STRIPDOC|LEX_INHEREDOC|LEX_QUOTEDDOC);
/*itrace("parse_comsub:%d: found here doc end `%*s'", line_number, hdlen, ret + tind);*/
	      free (heredelim);
	      heredelim = 0;
	      lex_firstind = -1;
#if defined (BANG_HISTORY)
	      history_expansion_inhibited = orig_histexp;
#endif
	    }
	}

      /* Don't bother counting parens or doing anything else if in a comment or
	 here document (not exactly right for here-docs -- if we want to allow
	 recursive calls to parse_comsub to have their own here documents,
	 change the LEX_INHEREDOC to LEX_QUOTEDDOC here and uncomment the next
	 clause below.  Note that to make this work completely, we need to make
	 additional changes to allow xparse_dolparen to work right when the
	 command substitution is parsed, because read_secondary_line doesn't know
	 to recursively parse through command substitutions embedded in here-
	 documents */
      if (tflags & (LEX_INCOMMENT|LEX_INHEREDOC))
	{
	  /* Add this character. */
	  RESIZE_MALLOCED_BUFFER (ret, retind, 1, retsize, 64);
	  ret[retind++] = ch;

	  if ((tflags & LEX_INCOMMENT) && ch == '\n')
	    {
/*itrace("parse_comsub:%d: lex_incomment -> 0 ch = `%c'", line_number, ch);*/
	      tflags &= ~LEX_INCOMMENT;
	    }

	  continue;
	}
#if 0
      /* If we're going to recursively parse a command substitution inside a
	 here-document, make sure we call parse_comsub recursively below.  See
	 above for additional caveats. */
      if ((tflags & LEX_INHEREDOC) && ((tflags & LEX_WASDOL) == 0 || ch != '(')) /*)*/
	{
	  /* Add this character. */
	  RESIZE_MALLOCED_BUFFER (ret, retind, 1, retsize, 64);
	  ret[retind++] = ch;
	  if MBTEST(ch == '$')
	    tflags |= LEX_WASDOL;
	  else
	    tflags &= ~LEX_WASDOL;
	}
#endif

      if (tflags & LEX_PASSNEXT)		/* last char was backslash */
	{
/*itrace("parse_comsub:%d: lex_passnext -> 0 ch = `%c' (%d)", line_number, ch, __LINE__);*/
	  tflags &= ~LEX_PASSNEXT;
	  if (qc != '\'' && ch == '\n')	/* double-quoted \<newline> disappears. */
	    {
	      if (retind > 0)
		retind--;	/* swallow previously-added backslash */
	      continue;
	    }

	  RESIZE_MALLOCED_BUFFER (ret, retind, 2, retsize, 64);
	  if MBTEST(ch == CTLESC)
	    ret[retind++] = CTLESC;
	  ret[retind++] = ch;
	  continue;
	}

      /* If this is a shell break character, we are not in a word.  If not,
	 we either start or continue a word. */
      if MBTEST(shellbreak (ch))
	{
	  tflags &= ~LEX_INWORD;
/*itrace("parse_comsub:%d: lex_inword -> 0 ch = `%c' (%d)", line_number, ch, __LINE__);*/
	}
      else
	{
	  if (tflags & LEX_INWORD)
	    {
	      lex_wlen++;
/*itrace("parse_comsub:%d: lex_inword == 1 ch = `%c' lex_wlen = %d (%d)", line_number, ch, lex_wlen, __LINE__);*/
	    }	      
	  else
	    {
/*itrace("parse_comsub:%d: lex_inword -> 1 ch = `%c' (%d)", line_number, ch, __LINE__);*/
	      tflags |= LEX_INWORD;
	      lex_wlen = 0;
	      if (tflags & LEX_RESWDOK)
		lex_rwlen = 0;
	    }
	}

      /* Skip whitespace */
      if MBTEST(shellblank (ch) && (tflags & LEX_HEREDELIM) == 0 && lex_rwlen == 0)
        {
	  /* Add this character. */
	  RESIZE_MALLOCED_BUFFER (ret, retind, 1, retsize, 64);
	  ret[retind++] = ch;
	  continue;
        }

      /* Either we are looking for the start of the here-doc delimiter
	 (lex_firstind == -1) or we are reading one (lex_firstind >= 0).
	 If this character is a shell break character and we are reading
	 the delimiter, save it and note that we are now reading a here
	 document.  If we've found the start of the delimiter, note it by
	 setting lex_firstind.  Backslashes can quote shell metacharacters
	 in here-doc delimiters. */
      if (tflags & LEX_HEREDELIM)
	{
	  if (lex_firstind == -1 && shellbreak (ch) == 0)
	    lex_firstind = retind;
#if 0
	  else if (heredelim && (tflags & LEX_PASSNEXT) == 0 && ch == '\n')
	    {
	      tflags |= LEX_INHEREDOC;
	      tflags &= ~LEX_HEREDELIM;
	      lex_firstind = retind + 1;
#if defined (BANG_HISTORY)
	      history_expansion_inhibited = 1;
#endif
	    }
#endif
	  else if (lex_firstind >= 0 && (tflags & LEX_PASSNEXT) == 0 && shellbreak (ch))
	    {
	      if (heredelim == 0)
		{
		  nestret = substring (ret, lex_firstind, retind);
		  heredelim = string_quote_removal (nestret, 0);
		  hdlen = STRLEN(heredelim);
/*itrace("parse_comsub:%d: found here doc delimiter `%s' (%d)", line_number, heredelim, hdlen);*/
		  if (STREQ (heredelim, nestret) == 0)
		    tflags |= LEX_QUOTEDDOC;
		  free (nestret);
		}
	      if (ch == '\n')
		{
		  tflags |= LEX_INHEREDOC;
		  tflags &= ~LEX_HEREDELIM;
		  lex_firstind = retind + 1;
#if defined (BANG_HISTORY)
		  history_expansion_inhibited = 1;
#endif
		}
	      else
		lex_firstind = -1;
	    }
	}

      /* Meta-characters that can introduce a reserved word.  Not perfect yet. */
      if MBTEST((tflags & LEX_RESWDOK) == 0 && (tflags & LEX_CKCASE) && (tflags & LEX_INCOMMENT) == 0 && (shellmeta(ch) || ch == '\n'))
	{
	  /* Add this character. */
	  RESIZE_MALLOCED_BUFFER (ret, retind, 1, retsize, 64);
	  ret[retind++] = ch;
	  peekc = shell_getc (1);
	  if (ch == peekc && (ch == '&' || ch == '|' || ch == ';'))	/* two-character tokens */
	    {
	      RESIZE_MALLOCED_BUFFER (ret, retind, 1, retsize, 64);
	      ret[retind++] = peekc;
/*itrace("parse_comsub:%d: set lex_reswordok = 1, ch = `%c'", line_number, ch);*/
	      tflags |= LEX_RESWDOK;
	      lex_rwlen = 0;
	      continue;
	    }
	  else if (ch == '\n' || COMSUB_META(ch))
	    {
	      shell_ungetc (peekc);
/*itrace("parse_comsub:%d: set lex_reswordok = 1, ch = `%c'", line_number, ch);*/
	      tflags |= LEX_RESWDOK;
	      lex_rwlen = 0;
	      continue;
	    }
	  else if (ch == EOF)
	    goto eof_error;
	  else
	    {
	      /* `unget' the character we just added and fall through */
	      retind--;
	      shell_ungetc (peekc);
	    }
	}

      /* If we can read a reserved word, try to read one. */
      if (tflags & LEX_RESWDOK)
	{
	  if MBTEST(islower ((unsigned char)ch))
	    {
	      /* Add this character. */
	      RESIZE_MALLOCED_BUFFER (ret, retind, 1, retsize, 64);
	      ret[retind++] = ch;
	      lex_rwlen++;
	      continue;
	    }
	  else if MBTEST(lex_rwlen == 4 && shellbreak (ch))
	    {
	      if (STREQN (ret + retind - 4, "case", 4))
		{
		  tflags |= LEX_INCASE;
		  tflags &= ~LEX_RESWDOK;
/*itrace("parse_comsub:%d: found `case', lex_incase -> 1 lex_reswdok -> 0", line_number);*/
		}
	      else if (STREQN (ret + retind - 4, "esac", 4))
		{
		  tflags &= ~LEX_INCASE;
/*itrace("parse_comsub:%d: found `esac', lex_incase -> 0 lex_reswdok -> 1", line_number);*/
		  tflags |= LEX_RESWDOK;
		  lex_rwlen = 0;
		}
	      else if (STREQN (ret + retind - 4, "done", 4) ||
		       STREQN (ret + retind - 4, "then", 4) ||
		       STREQN (ret + retind - 4, "else", 4) ||
		       STREQN (ret + retind - 4, "elif", 4) ||
		       STREQN (ret + retind - 4, "time", 4))
		{
		  /* these are four-character reserved words that can be
		     followed by a reserved word; anything else turns off
		     the reserved-word-ok flag */
/*itrace("parse_comsub:%d: found `%.4s', lex_reswdok -> 1", line_number, ret+retind-4);*/
		  tflags |= LEX_RESWDOK;
		  lex_rwlen = 0;
		}
	       else if (shellmeta (ch) == 0)
		{
		  tflags &= ~LEX_RESWDOK;
/*itrace("parse_comsub:%d: found `%.4s', lex_reswdok -> 0", line_number, ret+retind-4);*/
		}
	      else	/* can't be in a reserved word any more */
	        lex_rwlen = 0;
	    }
	  else if MBTEST((tflags & LEX_CKCOMMENT) && ch == '#' && (lex_rwlen == 0 || ((tflags & LEX_INWORD) && lex_wlen == 0)))
	    ;	/* don't modify LEX_RESWDOK if we're starting a comment */
	  /* Allow `do' followed by space, tab, or newline to preserve the
	     RESWDOK flag, but reset the reserved word length counter so we
	     can read another one. */
	  else if MBTEST(((tflags & LEX_INCASE) == 0) &&
			  (isblank((unsigned char)ch) || ch == '\n') &&
			  lex_rwlen == 2 &&
			  STREQN (ret + retind - 2, "do", 2))
	    {
/*itrace("parse_comsub:%d: lex_incase == 0 found `%c', found \"do\"", line_number, ch);*/
	      lex_rwlen = 0;
	    }
	  else if MBTEST((tflags & LEX_INCASE) && ch != '\n')
	    /* If we can read a reserved word and we're in case, we're at the
	       point where we can read a new pattern list or an esac.  We
	       handle the esac case above.  If we read a newline, we want to
	       leave LEX_RESWDOK alone.  If we read anything else, we want to
	       turn off LEX_RESWDOK, since we're going to read a pattern list. */
	    {
	      tflags &= ~LEX_RESWDOK;
/*itrace("parse_comsub:%d: lex_incase == 1 found `%c', lex_reswordok -> 0", line_number, ch);*/
	    }
	  else if MBTEST(shellbreak (ch) == 0)
	    {
	      tflags &= ~LEX_RESWDOK;
/*itrace("parse_comsub:%d: found `%c', lex_reswordok -> 0", line_number, ch);*/
	    }
#if 0
	  /* If we find a space or tab but have read something and it's not
	     `do', turn off the reserved-word-ok flag */
	  else if MBTEST(isblank ((unsigned char)ch) && lex_rwlen > 0)
	    {
	      tflags &= ~LEX_RESWDOK;
/*itrace("parse_comsub:%d: found `%c', lex_reswordok -> 0", line_number, ch);*/
	    }
#endif
	}

      /* Might be the start of a here-doc delimiter */
      if MBTEST((tflags & LEX_INCOMMENT) == 0 && (tflags & LEX_CKCASE) && ch == '<')
	{
	  /* Add this character. */
	  RESIZE_MALLOCED_BUFFER (ret, retind, 1, retsize, 64);
	  ret[retind++] = ch;
	  peekc = shell_getc (1);
	  if (peekc == EOF)
	    goto eof_error;
	  if (peekc == ch)
	    {
	      RESIZE_MALLOCED_BUFFER (ret, retind, 1, retsize, 64);
	      ret[retind++] = peekc;
	      peekc = shell_getc (1);
	      if (peekc == EOF)
		goto eof_error;
	      if (peekc == '-')
		{
		  RESIZE_MALLOCED_BUFFER (ret, retind, 1, retsize, 64);
		  ret[retind++] = peekc;
		  tflags |= LEX_STRIPDOC;
		}
	      else
		shell_ungetc (peekc);
	      if (peekc != '<')
		{
		  tflags |= LEX_HEREDELIM;
		  lex_firstind = -1;
		}
	      continue;
	    }
	  else
	    {
	      shell_ungetc (peekc);	/* not a here-doc, start over */
	      continue;
	    }
	}
      else if MBTEST((tflags & LEX_CKCOMMENT) && (tflags & LEX_INCOMMENT) == 0 && ch == '#' && (((tflags & LEX_RESWDOK) && lex_rwlen == 0) || ((tflags & LEX_INWORD) && lex_wlen == 0)))
	{
/*itrace("parse_comsub:%d: lex_incomment -> 1 (%d)", line_number, __LINE__);*/
	  tflags |= LEX_INCOMMENT;
	}

      if MBTEST(ch == CTLESC || ch == CTLNUL)	/* special shell escapes */
	{
	  RESIZE_MALLOCED_BUFFER (ret, retind, 2, retsize, 64);
	  ret[retind++] = CTLESC;
	  ret[retind++] = ch;
	  continue;
	}
#if 0
      else if MBTEST((tflags & LEX_INCASE) && ch == close && close == ')')
        tflags &= ~LEX_INCASE;		/* XXX */
#endif
      else if MBTEST(ch == close && (tflags & LEX_INCASE) == 0)		/* ending delimiter */
	{
	  count--;
/*itrace("parse_comsub:%d: found close: count = %d", line_number, count);*/
	}
      else if MBTEST(((flags & P_FIRSTCLOSE) == 0) && (tflags & LEX_INCASE) == 0 && ch == open)	/* nested begin */
	{
	  count++;
/*itrace("parse_comsub:%d: found open: count = %d", line_number, count);*/
	}

      /* Add this character. */
      RESIZE_MALLOCED_BUFFER (ret, retind, 1, retsize, 64);
      ret[retind++] = ch;

      /* If we just read the ending character, don't bother continuing. */
      if (count == 0)
	break;

      if MBTEST(ch == '\\')			/* backslashes */
	tflags |= LEX_PASSNEXT;

      if MBTEST(shellquote (ch))
        {
          /* '', ``, or "" inside $(...). */
          push_delimiter (dstack, ch);
          if MBTEST((tflags & LEX_WASDOL) && ch == '\'')	/* $'...' inside group */
	    nestret = parse_matched_pair (ch, ch, ch, &nestlen, P_ALLOWESC|rflags);
	  else
	    nestret = parse_matched_pair (ch, ch, ch, &nestlen, rflags);
	  pop_delimiter (dstack);
	  CHECK_NESTRET_ERROR ();

	  if MBTEST((tflags & LEX_WASDOL) && ch == '\'' && (extended_quote || (rflags & P_DQUOTE) == 0))
	    {
	      /* Translate $'...' here. */
	      ttrans = ansiexpand (nestret, 0, nestlen - 1, &ttranslen);
	      free (nestret);

	      if ((rflags & P_DQUOTE) == 0)
		{
		  nestret = sh_single_quote (ttrans);
		  free (ttrans);
		  nestlen = strlen (nestret);
		}
	      else
		{
		  nestret = ttrans;
		  nestlen = ttranslen;
		}
	      retind -= 2;		/* back up before the $' */
	    }
	  else if MBTEST((tflags & LEX_WASDOL) && ch == '"' && (extended_quote || (rflags & P_DQUOTE) == 0))
	    {
	      /* Locale expand $"..." here. */
	      ttrans = localeexpand (nestret, 0, nestlen - 1, start_lineno, &ttranslen);
	      free (nestret);

	      nestret = sh_mkdoublequoted (ttrans, ttranslen, 0);
	      free (ttrans);
	      nestlen = ttranslen + 2;
	      retind -= 2;		/* back up before the $" */
	    }

	  APPEND_NESTRET ();
	  FREE (nestret);
	}
      else if MBTEST((tflags & LEX_WASDOL) && (ch == '(' || ch == '{' || ch == '['))	/* ) } ] */
	/* check for $(), $[], or ${} inside command substitution. */
	{
	  if ((tflags & LEX_INCASE) == 0 && open == ch)	/* undo previous increment */
	    count--;
	  if (ch == '(')		/* ) */
	    nestret = parse_comsub (0, '(', ')', &nestlen, (rflags|P_COMMAND) & ~P_DQUOTE);
	  else if (ch == '{')		/* } */
	    nestret = parse_matched_pair (0, '{', '}', &nestlen, P_FIRSTCLOSE|P_DOLBRACE|rflags);
	  else if (ch == '[')		/* ] */
	    nestret = parse_matched_pair (0, '[', ']', &nestlen, rflags);

	  CHECK_NESTRET_ERROR ();
	  APPEND_NESTRET ();

	  FREE (nestret);
	}
      if MBTEST(ch == '$' && (tflags & LEX_WASDOL) == 0)
	tflags |= LEX_WASDOL;
      else
	tflags &= ~LEX_WASDOL;
    }

#if defined (BANG_HISTORY)
  history_expansion_inhibited = orig_histexp;
#endif
  FREE (heredelim);
  ret[retind] = '\0';
  if (lenp)
    *lenp = retind;
/*itrace("parse_comsub:%d: returning `%s'", line_number, ret);*/
  return ret;
}
warning: parse error {
  int count, ch, peekc, tflags, lex_rwlen, lex_wlen, lex_firstind;
  int nestlen, ttranslen, start_lineno, orig_histexp;
  char *ret, *nestret, *ttrans, *heredelim;
  int retind, retsize, rflags, hdlen;

  /* Posix interp 217 says arithmetic expressions have precedence, so
     assume $(( introduces arithmetic expansion and parse accordingly. */
  peekc = shell_getc (0);
  shell_ungetc (peekc);
  if (peekc == '(')
    return (parse_matched_pair (qc, open, close, lenp, 0));

/*itrace("parse_comsub: qc = `%c' open = %c close = %c", qc, open, close);*/
  count = 1;
  tflags = LEX_RESWDOK;
#if defined (BANG_HISTORY)
  orig_histexp = history_expansion_inhibited;
#endif

  if ((flags & P_COMMAND) && qc != '\'' && qc != '"' && (flags & P_DQUOTE) == 0)
    tflags |= LEX_CKCASE;
  if ((tflags & LEX_CKCASE) && (interactive == 0 || interactive_comments))
    tflags |= LEX_CKCOMMENT;

  /* RFLAGS is the set of flags we want to pass to recursive calls. */
  rflags = (flags & P_DQUOTE);

  ret = (char *)xmalloc (retsize = 64);
  retind = 0;

  start_lineno = line_number;
  lex_rwlen = lex_wlen = 0;

  heredelim = 0;
  lex_firstind = -1;

  while (count)
    {
comsub_readchar:
      ch = shell_getc (qc != '\'' && (tflags & (LEX_INCOMMENT|LEX_PASSNEXT|LEX_QUOTEDDOC)) == 0);

      if (ch == EOF)
	{
eof_error:
#if defined (BANG_HISTORY)
	  history_expansion_inhibited = orig_histexp;
#endif
	  free (ret);
	  FREE (heredelim);
	  parser_error (start_lineno, _("unexpected EOF while looking for matching `%c'"), close);
	  EOF_Reached = 1;	/* XXX */
	  return (&matched_pair_error);
	}

      /* If we hit the end of a line and are reading the contents of a here
	 document, and it's not the same line that the document starts on,
	 check for this line being the here doc delimiter.  Otherwise, if
	 we're in a here document, mark the next character as the beginning
	 of a line. */
      if (ch == '\n')
	{
	  if ((tflags & LEX_HEREDELIM) && heredelim)
	    {
	      tflags &= ~LEX_HEREDELIM;
	      tflags |= LEX_INHEREDOC;
#if defined (BANG_HISTORY)
	      history_expansion_inhibited = 1;
#endif
	      lex_firstind = retind + 1;
	    }
	  else if (tflags & LEX_INHEREDOC)
	    {
	      int tind;
	      tind = lex_firstind;
	      while ((tflags & LEX_STRIPDOC) && ret[tind] == '\t')
		tind++;
	      if (retind-tind == hdlen && STREQN (ret + tind, heredelim, hdlen))
		{
		  tflags &= ~(LEX_STRIPDOC|LEX_INHEREDOC|LEX_QUOTEDDOC);
/*itrace("parse_comsub:%d: found here doc end `%s'", line_number, ret + tind);*/
		  free (heredelim);
		  heredelim = 0;
		  lex_firstind = -1;
#if defined (BANG_HISTORY)
		  history_expansion_inhibited = orig_histexp;
#endif
		}
	      else
		lex_firstind = retind + 1;
	    }
	}

      /* Possible reprompting. */
      if (ch == '\n' && SHOULD_PROMPT ())
	prompt_again ();

      /* XXX -- we currently allow here doc to be delimited by ending right
	 paren in default mode and posix mode. To change posix mode, change
	 the #if 1 to #if 0 below */
      if ((tflags & LEX_INHEREDOC) && ch == close && count == 1)
	{
	  int tind;
/*itrace("parse_comsub:%d: in here doc, ch == close, retind - firstind = %d hdlen = %d retind = %d", line_number, retind-lex_firstind, hdlen, retind);*/
	  tind = lex_firstind;
	  while ((tflags & LEX_STRIPDOC) && ret[tind] == '\t')
	    tind++;
#if 1
  	  if (retind-tind == hdlen && STREQN (ret + tind, heredelim, hdlen))
#else
	  /* Posix-mode shells require the newline after the here-document
	     delimiter. */
	  if (retind-tind == hdlen && STREQN (ret + tind, heredelim, hdlen) &&
	      posixly_correct == 0)
#endif
	    {
	      tflags &= ~(LEX_STRIPDOC|LEX_INHEREDOC|LEX_QUOTEDDOC);
/*itrace("parse_comsub:%d: found here doc end `%*s'", line_number, hdlen, ret + tind);*/
	      free (heredelim);
	      heredelim = 0;
	      lex_firstind = -1;
#if defined (BANG_HISTORY)
	      history_expansion_inhibited = orig_histexp;
#endif
	    }
	}

      /* Don't bother counting parens or doing anything else if in a comment or
	 here document (not exactly right for here-docs -- if we want to allow
	 recursive calls to parse_comsub to have their own here documents,
	 change the LEX_INHEREDOC to LEX_QUOTEDDOC here and uncomment the next
	 clause below.  Note that to make this work completely, we need to make
	 additional changes to allow xparse_dolparen to work right when the
	 command substitution is parsed, because read_secondary_line doesn't know
	 to recursively parse through command substitutions embedded in here-
	 documents */
      if (tflags & (LEX_INCOMMENT|LEX_INHEREDOC))
	{
	  /* Add this character. */
	  RESIZE_MALLOCED_BUFFER (ret, retind, 1, retsize, 64);
	  ret[retind++] = ch;

	  if ((tflags & LEX_INCOMMENT) && ch == '\n')
	    {
/*itrace("parse_comsub:%d: lex_incomment -> 0 ch = `%c'", line_number, ch);*/
	      tflags &= ~LEX_INCOMMENT;
	    }

	  continue;
	}
#if 0
      /* If we're going to recursively parse a command substitution inside a
	 here-document, make sure we call parse_comsub recursively below.  See
	 above for additional caveats. */
      if ((tflags & LEX_INHEREDOC) && ((tflags & LEX_WASDOL) == 0 || ch != '(')) /*)*/
	{
	  /* Add this character. */
	  RESIZE_MALLOCED_BUFFER (ret, retind, 1, retsize, 64);
	  ret[retind++] = ch;
	  if MBTEST(ch == '$')
	    tflags |= LEX_WASDOL;
	  else
	    tflags &= ~LEX_WASDOL;
	}
#endif

      if (tflags & LEX_PASSNEXT)		/* last char was backslash */
	{
/*itrace("parse_comsub:%d: lex_passnext -> 0 ch = `%c' (%d)", line_number, ch, __LINE__);*/
	  tflags &= ~LEX_PASSNEXT;
	  if (qc != '\'' && ch == '\n')	/* double-quoted \<newline> disappears. */
	    {
	      if (retind > 0)
		retind--;	/* swallow previously-added backslash */
	      continue;
	    }

	  RESIZE_MALLOCED_BUFFER (ret, retind, 2, retsize, 64);
	  if MBTEST(ch == CTLESC)
	    ret[retind++] = CTLESC;
	  ret[retind++] = ch;
	  continue;
	}

      /* If this is a shell break character, we are not in a word.  If not,
	 we either start or continue a word. */
      if MBTEST(shellbreak (ch))
	{
	  tflags &= ~LEX_INWORD;
/*itrace("parse_comsub:%d: lex_inword -> 0 ch = `%c' (%d)", line_number, ch, __LINE__);*/
	}
      else
	{
	  if (tflags & LEX_INWORD)
	    {
	      lex_wlen++;
/*itrace("parse_comsub:%d: lex_inword == 1 ch = `%c' lex_wlen = %d (%d)", line_number, ch, lex_wlen, __LINE__);*/
	    }	      
	  else
	    {
/*itrace("parse_comsub:%d: lex_inword -> 1 ch = `%c' (%d)", line_number, ch, __LINE__);*/
	      tflags |= LEX_INWORD;
	      lex_wlen = 0;
	      if (tflags & LEX_RESWDOK)
		lex_rwlen = 0;
	    }
	}

      /* Skip whitespace */
      if MBTEST(shellblank (ch) && (tflags & LEX_HEREDELIM) == 0 && lex_rwlen == 0)
        {
	  /* Add this character. */
	  RESIZE_MALLOCED_BUFFER (ret, retind, 1, retsize, 64);
	  ret[retind++] = ch;
	  continue;
        }

      /* Either we are looking for the start of the here-doc delimiter
	 (lex_firstind == -1) or we are reading one (lex_firstind >= 0).
	 If this character is a shell break character and we are reading
	 the delimiter, save it and note that we are now reading a here
	 document.  If we've found the start of the delimiter, note it by
	 setting lex_firstind.  Backslashes can quote shell metacharacters
	 in here-doc delimiters. */
      if (tflags & LEX_HEREDELIM)
	{
	  if (lex_firstind == -1 && shellbreak (ch) == 0)
	    lex_firstind = retind;
#if 0
	  else if (heredelim && (tflags & LEX_PASSNEXT) == 0 && ch == '\n')
	    {
	      tflags |= LEX_INHEREDOC;
	      tflags &= ~LEX_HEREDELIM;
	      lex_firstind = retind + 1;
#if defined (BANG_HISTORY)
	      history_expansion_inhibited = 1;
#endif
	    }
#endif
	  else if (lex_firstind >= 0 && (tflags & LEX_PASSNEXT) == 0 && shellbreak (ch))
	    {
	      if (heredelim == 0)
		{
		  nestret = substring (ret, lex_firstind, retind);
		  heredelim = string_quote_removal (nestret, 0);
		  hdlen = STRLEN(heredelim);
/*itrace("parse_comsub:%d: found here doc delimiter `%s' (%d)", line_number, heredelim, hdlen);*/
		  if (STREQ (heredelim, nestret) == 0)
		    tflags |= LEX_QUOTEDDOC;
		  free (nestret);
		}
	      if (ch == '\n')
		{
		  tflags |= LEX_INHEREDOC;
		  tflags &= ~LEX_HEREDELIM;
		  lex_firstind = retind + 1;
#if defined (BANG_HISTORY)
		  history_expansion_inhibited = 1;
#endif
		}
	      else
		lex_firstind = -1;
	    }
	}

      /* Meta-characters that can introduce a reserved word.  Not perfect yet. */
      if MBTEST((tflags & LEX_RESWDOK) == 0 && (tflags & LEX_CKCASE) && (tflags & LEX_INCOMMENT) == 0 && (shellmeta(ch) || ch == '\n'))
	{
	  /* Add this character. */
	  RESIZE_MALLOCED_BUFFER (ret, retind, 1, retsize, 64);
	  ret[retind++] = ch;
	  peekc = shell_getc (1);
	  if (ch == peekc && (ch == '&' || ch == '|' || ch == ';'))	/* two-character tokens */
	    {
	      RESIZE_MALLOCED_BUFFER (ret, retind, 1, retsize, 64);
	      ret[retind++] = peekc;
/*itrace("parse_comsub:%d: set lex_reswordok = 1, ch = `%c'", line_number, ch);*/
	      tflags |= LEX_RESWDOK;
	      lex_rwlen = 0;
	      continue;
	    }
	  else if (ch == '\n' || COMSUB_META(ch))
	    {
	      shell_ungetc (peekc);
/*itrace("parse_comsub:%d: set lex_reswordok = 1, ch = `%c'", line_number, ch);*/
	      tflags |= LEX_RESWDOK;
	      lex_rwlen = 0;
	      continue;
	    }
	  else if (ch == EOF)
	    goto eof_error;
	  else
	    {
	      /* `unget' the character we just added and fall through */
	      retind--;
	      shell_ungetc (peekc);
	    }
	}

      /* If we can read a reserved word, try to read one. */
      if (tflags & LEX_RESWDOK)
	{
	  if MBTEST(islower ((unsigned char)ch))
	    {
	      /* Add this character. */
	      RESIZE_MALLOCED_BUFFER (ret, retind, 1, retsize, 64);
	      ret[retind++] = ch;
	      lex_rwlen++;
	      continue;
	    }
	  else if MBTEST(lex_rwlen == 4 && shellbreak (ch))
	    {
	      if (STREQN (ret + retind - 4, "case", 4))
		{
		  tflags |= LEX_INCASE;
		  tflags &= ~LEX_RESWDOK;
/*itrace("parse_comsub:%d: found `case', lex_incase -> 1 lex_reswdok -> 0", line_number);*/
		}
	      else if (STREQN (ret + retind - 4, "esac", 4))
		{
		  tflags &= ~LEX_INCASE;
/*itrace("parse_comsub:%d: found `esac', lex_incase -> 0 lex_reswdok -> 1", line_number);*/
		  tflags |= LEX_RESWDOK;
		  lex_rwlen = 0;
		}
	      else if (STREQN (ret + retind - 4, "done", 4) ||
		       STREQN (ret + retind - 4, "then", 4) ||
		       STREQN (ret + retind - 4, "else", 4) ||
		       STREQN (ret + retind - 4, "elif", 4) ||
		       STREQN (ret + retind - 4, "time", 4))
		{
		  /* these are four-character reserved words that can be
		     followed by a reserved word; anything else turns off
		     the reserved-word-ok flag */
/*itrace("parse_comsub:%d: found `%.4s', lex_reswdok -> 1", line_number, ret+retind-4);*/
		  tflags |= LEX_RESWDOK;
		  lex_rwlen = 0;
		}
	       else if (shellmeta (ch) == 0)
		{
		  tflags &= ~LEX_RESWDOK;
/*itrace("parse_comsub:%d: found `%.4s', lex_reswdok -> 0", line_number, ret+retind-4);*/
		}
	      else	/* can't be in a reserved word any more */
	        lex_rwlen = 0;
	    }
	  else if MBTEST((tflags & LEX_CKCOMMENT) && ch == '#' && (lex_rwlen == 0 || ((tflags & LEX_INWORD) && lex_wlen == 0)))
	    ;	/* don't modify LEX_RESWDOK if we're starting a comment */
	  /* Allow `do' followed by space, tab, or newline to preserve the
	     RESWDOK flag, but reset the reserved word length counter so we
	     can read another one. */
	  else if MBTEST(((tflags & LEX_INCASE) == 0) &&
			  (isblank((unsigned char)ch) || ch == '\n') &&
			  lex_rwlen == 2 &&
			  STREQN (ret + retind - 2, "do", 2))
	    {
/*itrace("parse_comsub:%d: lex_incase == 0 found `%c', found \"do\"", line_number, ch);*/
	      lex_rwlen = 0;
	    }
	  else if MBTEST((tflags & LEX_INCASE) && ch != '\n')
	    /* If we can read a reserved word and we're in case, we're at the
	       point where we can read a new pattern list or an esac.  We
	       handle the esac case above.  If we read a newline, we want to
	       leave LEX_RESWDOK alone.  If we read anything else, we want to
	       turn off LEX_RESWDOK, since we're going to read a pattern list. */
	    {
	      tflags &= ~LEX_RESWDOK;
/*itrace("parse_comsub:%d: lex_incase == 1 found `%c', lex_reswordok -> 0", line_number, ch);*/
	    }
	  else if MBTEST(shellbreak (ch) == 0)
	    {
	      tflags &= ~LEX_RESWDOK;
/*itrace("parse_comsub:%d: found `%c', lex_reswordok -> 0", line_number, ch);*/
	    }
#if 0
	  /* If we find a space or tab but have read something and it's not
	     `do', turn off the reserved-word-ok flag */
	  else if MBTEST(isblank ((unsigned char)ch) && lex_rwlen > 0)
	    {
	      tflags &= ~LEX_RESWDOK;
/*itrace("parse_comsub:%d: found `%c', lex_reswordok -> 0", line_number, ch);*/
	    }
#endif
	}

      /* Might be the start of a here-doc delimiter */
      if MBTEST((tflags & LEX_INCOMMENT) == 0 && (tflags & LEX_CKCASE) && ch == '<')
	{
	  /* Add this character. */
	  RESIZE_MALLOCED_BUFFER (ret, retind, 1, retsize, 64);
	  ret[retind++] = ch;
	  peekc = shell_getc (1);
	  if (peekc == EOF)
	    goto eof_error;
	  if (peekc == ch)
	    {
	      RESIZE_MALLOCED_BUFFER (ret, retind, 1, retsize, 64);
	      ret[retind++] = peekc;
	      peekc = shell_getc (1);
	      if (peekc == EOF)
		goto eof_error;
	      if (peekc == '-')
		{
		  RESIZE_MALLOCED_BUFFER (ret, retind, 1, retsize, 64);
		  ret[retind++] = peekc;
		  tflags |= LEX_STRIPDOC;
		}
	      else
		shell_ungetc (peekc);
	      if (peekc != '<')
		{
		  tflags |= LEX_HEREDELIM;
		  lex_firstind = -1;
		}
	      continue;
	    }
	  else
	    {
	      shell_ungetc (peekc);	/* not a here-doc, start over */
	      continue;
	    }
	}
      else if MBTEST((tflags & LEX_CKCOMMENT) && (tflags & LEX_INCOMMENT) == 0 && ch == '#' && (((tflags & LEX_RESWDOK) && lex_rwlen == 0) || ((tflags & LEX_INWORD) && lex_wlen == 0)))
	{
/*itrace("parse_comsub:%d: lex_incomment -> 1 (%d)", line_number, __LINE__);*/
	  tflags |= LEX_INCOMMENT;
	}

      if MBTEST(ch == CTLESC || ch == CTLNUL)	/* special shell escapes */
	{
	  RESIZE_MALLOCED_BUFFER (ret, retind, 2, retsize, 64);
	  ret[retind++] = CTLESC;
	  ret[retind++] = ch;
	  continue;
	}
#if 0
      else if MBTEST((tflags & LEX_INCASE) && ch == close && close == ')')
        tflags &= ~LEX_INCASE;		/* XXX */
#endif
      else if MBTEST(ch == close && (tflags & LEX_INCASE) == 0)		/* ending delimiter */
	{
	  count--;
/*itrace("parse_comsub:%d: found close: count = %d", line_number, count);*/
	}
      else if MBTEST(((flags & P_FIRSTCLOSE) == 0) && (tflags & LEX_INCASE) == 0 && ch == open)	/* nested begin */
	{
	  count++;
/*itrace("parse_comsub:%d: found open: count = %d", line_number, count);*/
	}

      /* Add this character. */
      RESIZE_MALLOCED_BUFFER (ret, retind, 1, retsize, 64);
      ret[retind++] = ch;

      /* If we just read the ending character, don't bother continuing. */
      if (count == 0)
	break;

      if MBTEST(ch == '\\')			/* backslashes */
	tflags |= LEX_PASSNEXT;

      if MBTEST(shellquote (ch))
        {
          /* '', ``, or "" inside $(...). */
          push_delimiter (dstack, ch);
          if MBTEST((tflags & LEX_WASDOL) && ch == '\'')	/* $'...' inside group */
	    nestret = parse_matched_pair (ch, ch, ch, &nestlen, P_ALLOWESC|rflags);
	  else
	    nestret = parse_matched_pair (ch, ch, ch, &nestlen, rflags);
	  pop_delimiter (dstack);
	  CHECK_NESTRET_ERROR ();

	  if MBTEST((tflags & LEX_WASDOL) && ch == '\'' && (extended_quote || (rflags & P_DQUOTE) == 0))
	    {
	      /* Translate $'...' here. */
	      ttrans = ansiexpand (nestret, 0, nestlen - 1, &ttranslen);
	      free (nestret);

	      if ((rflags & P_DQUOTE) == 0)
		{
		  nestret = sh_single_quote (ttrans);
		  free (ttrans);
		  nestlen = strlen (nestret);
		}
	      else
		{
		  nestret = ttrans;
		  nestlen = ttranslen;
		}
	      retind -= 2;		/* back up before the $' */
	    }
	  else if MBTEST((tflags & LEX_WASDOL) && ch == '"' && (extended_quote || (rflags & P_DQUOTE) == 0))
	    {
	      /* Locale expand $"..." here. */
	      ttrans = localeexpand (nestret, 0, nestlen - 1, start_lineno, &ttranslen);
	      free (nestret);

	      nestret = sh_mkdoublequoted (ttrans, ttranslen, 0);
	      free (ttrans);
	      nestlen = ttranslen + 2;
	      retind -= 2;		/* back up before the $" */
	    }

	  APPEND_NESTRET ();
	  FREE (nestret);
	}
      else if MBTEST((tflags & LEX_WASDOL) && (ch == '(' || ch == '{' || ch == '['))	/* ) } ] */
	/* check for $(), $[], or ${} inside command substitution. */
	{
	  if ((tflags & LEX_INCASE) == 0 && open == ch)	/* undo previous increment */
	    count--;
	  if (ch == '(')		/* ) */
	    nestret = parse_comsub (0, '(', ')', &nestlen, (rflags|P_COMMAND) & ~P_DQUOTE);
	  else if (ch == '{')		/* } */
	    nestret = parse_matched_pair (0, '{', '}', &nestlen, P_FIRSTCLOSE|P_DOLBRACE|rflags);
	  else if (ch == '[')		/* ] */
	    nestret = parse_matched_pair (0, '[', ']', &nestlen, rflags);

	  CHECK_NESTRET_ERROR ();
	  APPEND_NESTRET ();

	  FREE (nestret);
	}
      if MBTEST(ch == '$' && (tflags & LEX_WASDOL) == 0)
	tflags |= LEX_WASDOL;
      else
	tflags &= ~LEX_WASDOL;
    }

#if defined (BANG_HISTORY)
  history_expansion_inhibited = orig_histexp;
#endif
  FREE (heredelim);
  ret[retind] = '\0';
  if (lenp)
    *lenp = retind;
/*itrace("parse_comsub:%d: returning `%s'", line_number, ret);*/
  return ret;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\y.tab.c:6,201
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\y.tab.c:6,743
parsing error 
{
  sh_parser_state_t ps;
  sh_input_line_state_t ls;
  int orig_ind, nc, sflags, orig_eof_token, start_lineno;
  char *ret, *ep, *ostring;
#if defined (ALIAS) || defined (DPAREN_ARITHMETIC)
  STRING_SAVER *saved_pushed_strings;
#endif

/*debug_parser(1);*/
  orig_ind = *indp;
  ostring = string;
  start_lineno = line_number;

  if (*string == 0)
    {
      if (flags & SX_NOALLOC) 
	return (char *)NULL;

      ret = xmalloc (1);
      ret[0] = '\0';
      return ret;
    }

/*itrace("xparse_dolparen: size = %d shell_input_line = `%s' string=`%s'", shell_input_line_size, shell_input_line, string);*/
  sflags = SEVAL_NONINT|SEVAL_NOHIST|SEVAL_NOFREE;
  if (flags & SX_NOLONGJMP)
    sflags |= SEVAL_NOLONGJMP;
  save_parser_state (&ps);
  save_input_line_state (&ls);
  orig_eof_token = shell_eof_token;
#if defined (ALIAS) || defined (DPAREN_ARITHMETIC)
  saved_pushed_strings = pushed_string_list;	/* separate parsing context */
  pushed_string_list = (STRING_SAVER *)NULL;
#endif

  /*(*/
  parser_state |= PST_CMDSUBST|PST_EOFTOKEN;	/* allow instant ')' */ /*(*/
  shell_eof_token = ')';

  /* Should we save and restore the bison/yacc lookahead token (yychar) here?
     Or only if it's not YYEMPTY? */

  nc = parse_string (string, "command substitution", sflags, &ep);

  if (current_token == shell_eof_token)
    yyclearin;		/* might want to clear lookahead token unconditionally */

  reset_parser ();
  /* reset_parser() clears shell_input_line and associated variables, including
     parser_state, so we want to reset things, then restore what we need. */
  restore_input_line_state (&ls);

  shell_eof_token = orig_eof_token;
  restore_parser_state (&ps);

#if defined (ALIAS) || defined (DPAREN_ARITHMETIC)
  pushed_string_list = saved_pushed_strings;
#endif

  token_to_read = 0;

  /* If parse_string returns < 0, we need to jump to top level with the
     negative of the return value. We abandon the rest of this input line
     first */
  if (nc < 0)
    {
      clear_shell_input_line ();	/* XXX */
      if (bash_input.type != st_string)	/* paranoia */
	parser_state &= ~(PST_CMDSUBST|PST_EOFTOKEN);
      jump_to_top_level (-nc);	/* XXX */
    }

  /* Need to find how many characters parse_and_execute consumed, update
     *indp, if flags != 0, copy the portion of the string parsed into RET
     and return it.  If flags & 1 (SX_NOALLOC) we can return NULL. */

  /*(*/
  if (ep[-1] != ')')
    {
#if DEBUG
      if (ep[-1] != '\n')
	itrace("xparse_dolparen:%d: ep[-1] != RPAREN (%d), ep = `%s'", line_number, ep[-1], ep);
#endif

      while (ep > ostring && ep[-1] == '\n') ep--;
    }

  nc = ep - ostring;
  *indp = ep - base - 1;

  /*((*/
#if DEBUG
  if (base[*indp] != ')')
    itrace("xparse_dolparen:%d: base[%d] != RPAREN (%d), base = `%s'", line_number, *indp, base[*indp], base);
  if (*indp < orig_ind)
    itrace("xparse_dolparen:%d: *indp (%d) < orig_ind (%d), orig_string = `%s'", line_number, *indp, orig_ind, ostring);
#endif

  if (base[*indp] != ')')
    {
      /*(*/
      parser_error (start_lineno, _("unexpected EOF while looking for matching `%c'"), ')');
      jump_to_top_level (DISCARD);
    }

  if (flags & SX_NOALLOC) 
    return (char *)NULL;

  if (nc == 0)
    {
      ret = xmalloc (1);
      ret[0] = '\0';
    }
  else
    ret = substring (ostring, 0, nc - 1);

  return ret;
}
warning: parse error {
  sh_parser_state_t ps;
  sh_input_line_state_t ls;
  int orig_ind, nc, sflags, orig_eof_token, start_lineno;
  char *ret, *ep, *ostring;
#if defined (ALIAS) || defined (DPAREN_ARITHMETIC)
  STRING_SAVER *saved_pushed_strings;
#endif

/*debug_parser(1);*/
  orig_ind = *indp;
  ostring = string;
  start_lineno = line_number;

  if (*string == 0)
    {
      if (flags & SX_NOALLOC) 
	return (char *)NULL;

      ret = xmalloc (1);
      ret[0] = '\0';
      return ret;
    }

/*itrace("xparse_dolparen: size = %d shell_input_line = `%s' string=`%s'", shell_input_line_size, shell_input_line, string);*/
  sflags = SEVAL_NONINT|SEVAL_NOHIST|SEVAL_NOFREE;
  if (flags & SX_NOLONGJMP)
    sflags |= SEVAL_NOLONGJMP;
  save_parser_state (&ps);
  save_input_line_state (&ls);
  orig_eof_token = shell_eof_token;
#if defined (ALIAS) || defined (DPAREN_ARITHMETIC)
  saved_pushed_strings = pushed_string_list;	/* separate parsing context */
  pushed_string_list = (STRING_SAVER *)NULL;
#endif

  /*(*/
  parser_state |= PST_CMDSUBST|PST_EOFTOKEN;	/* allow instant ')' */ /*(*/
  shell_eof_token = ')';

  /* Should we save and restore the bison/yacc lookahead token (yychar) here?
     Or only if it's not YYEMPTY? */

  nc = parse_string (string, "command substitution", sflags, &ep);

  if (current_token == shell_eof_token)
    yyclearin;		/* might want to clear lookahead token unconditionally */

  reset_parser ();
  /* reset_parser() clears shell_input_line and associated variables, including
     parser_state, so we want to reset things, then restore what we need. */
  restore_input_line_state (&ls);

  shell_eof_token = orig_eof_token;
  restore_parser_state (&ps);

#if defined (ALIAS) || defined (DPAREN_ARITHMETIC)
  pushed_string_list = saved_pushed_strings;
#endif

  token_to_read = 0;

  /* If parse_string returns < 0, we need to jump to top level with the
     negative of the return value. We abandon the rest of this input line
     first */
  if (nc < 0)
    {
      clear_shell_input_line ();	/* XXX */
      if (bash_input.type != st_string)	/* paranoia */
	parser_state &= ~(PST_CMDSUBST|PST_EOFTOKEN);
      jump_to_top_level (-nc);	/* XXX */
    }

  /* Need to find how many characters parse_and_execute consumed, update
     *indp, if flags != 0, copy the portion of the string parsed into RET
     and return it.  If flags & 1 (SX_NOALLOC) we can return NULL. */

  /*(*/
  if (ep[-1] != ')')
    {
#if DEBUG
      if (ep[-1] != '\n')
	itrace("xparse_dolparen:%d: ep[-1] != RPAREN (%d), ep = `%s'", line_number, ep[-1], ep);
#endif

      while (ep > ostring && ep[-1] == '\n') ep--;
    }

  nc = ep - ostring;
  *indp = ep - base - 1;

  /*((*/
#if DEBUG
  if (base[*indp] != ')')
    itrace("xparse_dolparen:%d: base[%d] != RPAREN (%d), base = `%s'", line_number, *indp, base[*indp], base);
  if (*indp < orig_ind)
    itrace("xparse_dolparen:%d: *indp (%d) < orig_ind (%d), orig_string = `%s'", line_number, *indp, orig_ind, ostring);
#endif

  if (base[*indp] != ')')
    {
      /*(*/
      parser_error (start_lineno, _("unexpected EOF while looking for matching `%c'"), ')');
      jump_to_top_level (DISCARD);
    }

  if (flags & SX_NOALLOC) 
    return (char *)NULL;

  if (nc == 0)
    {
      ret = xmalloc (1);
      ret[0] = '\0';
    }
  else
    ret = substring (ostring, 0, nc - 1);

  return ret;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\y.tab.c:6,748
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\y.tab.c:7,272
parsing error 
{
  /* The value for YYLVAL when a WORD is read. */
  WORD_DESC *the_word;

  /* Index into the token that we are building. */
  int token_index;

  /* ALL_DIGITS becomes zero when we see a non-digit. */
  int all_digit_token;

  /* DOLLAR_PRESENT becomes non-zero if we see a `$'. */
  int dollar_present;

  /* COMPOUND_ASSIGNMENT becomes non-zero if we are parsing a compound
     assignment. */
  int compound_assignment;

  /* QUOTED becomes non-zero if we see one of ("), ('), (`), or (\). */
  int quoted;

  /* Non-zero means to ignore the value of the next character, and just
     to add it no matter what. */
  int pass_next_character;

  /* The current delimiting character. */
  int cd;
  int result, peek_char;
  char *ttok, *ttrans;
  int ttoklen, ttranslen;
  intmax_t lvalue;

  if (token_buffer_size < TOKEN_DEFAULT_INITIAL_SIZE)
    token = (char *)xrealloc (token, token_buffer_size = TOKEN_DEFAULT_INITIAL_SIZE);

  token_index = 0;
  all_digit_token = DIGIT (character);
  dollar_present = quoted = pass_next_character = compound_assignment = 0;

  for (;;)
    {
      if (character == EOF)
	goto got_token;

      if (pass_next_character)
	{
	  pass_next_character = 0;
	  goto got_escaped_character;
	}

      cd = current_delimiter (dstack);

      /* Handle backslashes.  Quote lots of things when not inside of
	 double-quotes, quote some things inside of double-quotes. */
      if MBTEST(character == '\\')
	{
	  peek_char = shell_getc (0);

	  /* Backslash-newline is ignored in all cases except
	     when quoted with single quotes. */
	  if (peek_char == '\n')
	    {
	      character = '\n';
	      goto next_character;
	    }
	  else
	    {
	      shell_ungetc (peek_char);

	      /* If the next character is to be quoted, note it now. */
	      if (cd == 0 || cd == '`' ||
		  (cd == '"' && peek_char >= 0 && (sh_syntaxtab[peek_char] & CBSDQUOTE)))
		pass_next_character++;

	      quoted = 1;
	      goto got_character;
	    }
	}

      /* Parse a matched pair of quote characters. */
      if MBTEST(shellquote (character))
	{
	  push_delimiter (dstack, character);
	  ttok = parse_matched_pair (character, character, character, &ttoklen, (character == '`') ? P_COMMAND : 0);
	  pop_delimiter (dstack);
	  if (ttok == &matched_pair_error)
	    return -1;		/* Bail immediately. */
	  RESIZE_MALLOCED_BUFFER (token, token_index, ttoklen + 2,
				  token_buffer_size, TOKEN_DEFAULT_GROW_SIZE);
	  token[token_index++] = character;
	  strcpy (token + token_index, ttok);
	  token_index += ttoklen;
	  all_digit_token = 0;
	  if (character != '`')
	    quoted = 1;
	  dollar_present |= (character == '"' && strchr (ttok, '$') != 0);
	  FREE (ttok);
	  goto next_character;
	}

#ifdef COND_REGEXP
      /* When parsing a regexp as a single word inside a conditional command,
	 we need to special-case characters special to both the shell and
	 regular expressions.  Right now, that is only '(' and '|'. */ /*)*/
      if MBTEST((parser_state & PST_REGEXP) && (character == '(' || character == '|'))		/*)*/
	{
	  if (character == '|')
	    goto got_character;

	  push_delimiter (dstack, character);
	  ttok = parse_matched_pair (cd, '(', ')', &ttoklen, 0);
	  pop_delimiter (dstack);
	  if (ttok == &matched_pair_error)
	    return -1;		/* Bail immediately. */
	  RESIZE_MALLOCED_BUFFER (token, token_index, ttoklen + 2,
				  token_buffer_size, TOKEN_DEFAULT_GROW_SIZE);
	  token[token_index++] = character;
	  strcpy (token + token_index, ttok);
	  token_index += ttoklen;
	  FREE (ttok);
	  dollar_present = all_digit_token = 0;
	  goto next_character;
	}
#endif /* COND_REGEXP */

#ifdef EXTENDED_GLOB
      /* Parse a ksh-style extended pattern matching specification. */
      if MBTEST(extended_glob && PATTERN_CHAR (character))
	{
	  peek_char = shell_getc (1);
	  if MBTEST(peek_char == '(')		/* ) */
	    {
	      push_delimiter (dstack, peek_char);
	      ttok = parse_matched_pair (cd, '(', ')', &ttoklen, 0);
	      pop_delimiter (dstack);
	      if (ttok == &matched_pair_error)
		return -1;		/* Bail immediately. */
	      RESIZE_MALLOCED_BUFFER (token, token_index, ttoklen + 3,
				      token_buffer_size,
				      TOKEN_DEFAULT_GROW_SIZE);
	      token[token_index++] = character;
	      token[token_index++] = peek_char;
	      strcpy (token + token_index, ttok);
	      token_index += ttoklen;
	      FREE (ttok);
	      dollar_present = all_digit_token = 0;
	      goto next_character;
	    }
	  else
	    shell_ungetc (peek_char);
	}
#endif /* EXTENDED_GLOB */

      /* If the delimiter character is not single quote, parse some of
	 the shell expansions that must be read as a single word. */
      if (shellexp (character))
	{
	  peek_char = shell_getc (1);
	  /* $(...), <(...), >(...), $((...)), ${...}, and $[...] constructs */
	  if MBTEST(peek_char == '(' ||
		((peek_char == '{' || peek_char == '[') && character == '$'))	/* ) ] } */
	    {
	      if (peek_char == '{')		/* } */
		ttok = parse_matched_pair (cd, '{', '}', &ttoklen, P_FIRSTCLOSE|P_DOLBRACE);
	      else if (peek_char == '(')		/* ) */
		{
		  /* XXX - push and pop the `(' as a delimiter for use by
		     the command-oriented-history code.  This way newlines
		     appearing in the $(...) string get added to the
		     history literally rather than causing a possibly-
		     incorrect `;' to be added. ) */
		  push_delimiter (dstack, peek_char);
		  ttok = parse_comsub (cd, '(', ')', &ttoklen, P_COMMAND);
		  pop_delimiter (dstack);
		}
	      else
		ttok = parse_matched_pair (cd, '[', ']', &ttoklen, 0);
	      if (ttok == &matched_pair_error)
		return -1;		/* Bail immediately. */
	      RESIZE_MALLOCED_BUFFER (token, token_index, ttoklen + 3,
				      token_buffer_size,
				      TOKEN_DEFAULT_GROW_SIZE);
	      token[token_index++] = character;
	      token[token_index++] = peek_char;
	      strcpy (token + token_index, ttok);
	      token_index += ttoklen;
	      FREE (ttok);
	      dollar_present = 1;
	      all_digit_token = 0;
	      goto next_character;
	    }
	  /* This handles $'...' and $"..." new-style quoted strings. */
	  else if MBTEST(character == '$' && (peek_char == '\'' || peek_char == '"'))
	    {
	      int first_line;

	      first_line = line_number;
	      push_delimiter (dstack, peek_char);
	      ttok = parse_matched_pair (peek_char, peek_char, peek_char,
					 &ttoklen,
					 (peek_char == '\'') ? P_ALLOWESC : 0);
	      pop_delimiter (dstack);
	      if (ttok == &matched_pair_error)
		return -1;
	      if (peek_char == '\'')
		{
		  ttrans = ansiexpand (ttok, 0, ttoklen - 1, &ttranslen);
		  free (ttok);

		  /* Insert the single quotes and correctly quote any
		     embedded single quotes (allowed because P_ALLOWESC was
		     passed to parse_matched_pair). */
		  ttok = sh_single_quote (ttrans);
		  free (ttrans);
		  ttranslen = strlen (ttok);
		  ttrans = ttok;
		}
	      else
		{
		  /* Try to locale-expand the converted string. */
		  ttrans = localeexpand (ttok, 0, ttoklen - 1, first_line, &ttranslen);
		  free (ttok);

		  /* Add the double quotes back */
		  ttok = sh_mkdoublequoted (ttrans, ttranslen, 0);
		  free (ttrans);
		  ttranslen += 2;
		  ttrans = ttok;
		}

	      RESIZE_MALLOCED_BUFFER (token, token_index, ttranslen + 1,
				      token_buffer_size,
				      TOKEN_DEFAULT_GROW_SIZE);
	      strcpy (token + token_index, ttrans);
	      token_index += ttranslen;
	      FREE (ttrans);
	      quoted = 1;
	      all_digit_token = 0;
	      goto next_character;
	    }
	  /* This could eventually be extended to recognize all of the
	     shell's single-character parameter expansions, and set flags.*/
	  else if MBTEST(character == '$' && peek_char == '$')
	    {
	      RESIZE_MALLOCED_BUFFER (token, token_index, 3,
				      token_buffer_size,
				      TOKEN_DEFAULT_GROW_SIZE);
	      token[token_index++] = '$';
	      token[token_index++] = peek_char;
	      dollar_present = 1;
	      all_digit_token = 0;
	      goto next_character;
	    }
	  else
	    shell_ungetc (peek_char);
	}

#if defined (ARRAY_VARS)
      /* Identify possible array subscript assignment; match [...].  If
	 parser_state&PST_COMPASSIGN, we need to parse [sub]=words treating
	 `sub' as if it were enclosed in double quotes. */
      else if MBTEST(character == '[' &&		/* ] */
		     ((token_index > 0 && assignment_acceptable (last_read_token) && token_is_ident (token, token_index)) ||
		      (token_index == 0 && (parser_state&PST_COMPASSIGN))))
        {
	  ttok = parse_matched_pair (cd, '[', ']', &ttoklen, P_ARRAYSUB);
	  if (ttok == &matched_pair_error)
	    return -1;		/* Bail immediately. */
	  RESIZE_MALLOCED_BUFFER (token, token_index, ttoklen + 2,
				  token_buffer_size,
				  TOKEN_DEFAULT_GROW_SIZE);
	  token[token_index++] = character;
	  strcpy (token + token_index, ttok);
	  token_index += ttoklen;
	  FREE (ttok);
	  all_digit_token = 0;
	  goto next_character;
        }
      /* Identify possible compound array variable assignment. */
      else if MBTEST(character == '=' && token_index > 0 && (assignment_acceptable (last_read_token) || (parser_state & PST_ASSIGNOK)) && token_is_assignment (token, token_index))
	{
	  peek_char = shell_getc (1);
	  if MBTEST(peek_char == '(')		/* ) */
	    {
	      ttok = parse_compound_assignment (&ttoklen);

	      RESIZE_MALLOCED_BUFFER (token, token_index, ttoklen + 4,
				      token_buffer_size,
				      TOKEN_DEFAULT_GROW_SIZE);

	      token[token_index++] = '=';
	      token[token_index++] = '(';
	      if (ttok)
		{
		  strcpy (token + token_index, ttok);
		  token_index += ttoklen;
		}
	      token[token_index++] = ')';
	      FREE (ttok);
	      all_digit_token = 0;
	      compound_assignment = 1;
#if 1
	      goto next_character;
#else
	      goto got_token;		/* ksh93 seems to do this */
#endif
	    }
	  else
	    shell_ungetc (peek_char);
	}
#endif

      /* When not parsing a multi-character word construct, shell meta-
	 characters break words. */
      if MBTEST(shellbreak (character))
	{
	  shell_ungetc (character);
	  goto got_token;
	}

got_character:
      if (character == CTLESC || character == CTLNUL)
	{
	  RESIZE_MALLOCED_BUFFER (token, token_index, 2, token_buffer_size,
				  TOKEN_DEFAULT_GROW_SIZE);
	  token[token_index++] = CTLESC;
	}
      else
got_escaped_character:
	RESIZE_MALLOCED_BUFFER (token, token_index, 1, token_buffer_size,
				TOKEN_DEFAULT_GROW_SIZE);

      token[token_index++] = character;

      all_digit_token &= DIGIT (character);
      dollar_present |= character == '$';

    next_character:
      if (character == '\n' && SHOULD_PROMPT ())
	prompt_again ();

      /* We want to remove quoted newlines (that is, a \<newline> pair)
	 unless we are within single quotes or pass_next_character is
	 set (the shell equivalent of literal-next). */
      cd = current_delimiter (dstack);
      character = shell_getc (cd != '\'' && pass_next_character == 0);
    }	/* end for (;;) */

got_token:

  /* Calls to RESIZE_MALLOCED_BUFFER ensure there is sufficient room. */
  token[token_index] = '\0';

  /* Check to see what thing we should return.  If the last_read_token
     is a `<', or a `&', or the character which ended this token is
     a '>' or '<', then, and ONLY then, is this input token a NUMBER.
     Otherwise, it is just a word, and should be returned as such. */
  if MBTEST(all_digit_token && (character == '<' || character == '>' ||
		    last_read_token == LESS_AND ||
		    last_read_token == GREATER_AND))
      {
	if (legal_number (token, &lvalue) && (int)lvalue == lvalue)
	  {
	    yylval.number = lvalue;
	    return (NUMBER);
	  }
      }

  /* Check for special case tokens. */
  result = (last_shell_getc_is_singlebyte) ? special_case_tokens (token) : -1;
  if (result >= 0)
    return result;

#if defined (ALIAS)
  /* Posix.2 does not allow reserved words to be aliased, so check for all
     of them, including special cases, before expanding the current token
     as an alias. */
  if MBTEST(posixly_correct)
    CHECK_FOR_RESERVED_WORD (token);

  /* Aliases are expanded iff EXPAND_ALIASES is non-zero, and quoting
     inhibits alias expansion. */
  if (expand_aliases && quoted == 0)
    {
      result = alias_expand_token (token);
      if (result == RE_READ_TOKEN)
	return (RE_READ_TOKEN);
      else if (result == NO_EXPANSION)
	parser_state &= ~PST_ALEXPNEXT;
    }

  /* If not in Posix.2 mode, check for reserved words after alias
     expansion. */
  if MBTEST(posixly_correct == 0)
#endif
    CHECK_FOR_RESERVED_WORD (token);

  the_word = alloc_word_desc ();
  the_word->word = (char *)xmalloc (1 + token_index);
  the_word->flags = 0;
  strcpy (the_word->word, token);
  if (dollar_present)
    the_word->flags |= W_HASDOLLAR;
  if (quoted)
    the_word->flags |= W_QUOTED;		/*(*/
  if (compound_assignment && token[token_index-1] == ')')
    the_word->flags |= W_COMPASSIGN;
  /* A word is an assignment if it appears at the beginning of a
     simple command, or after another assignment word.  This is
     context-dependent, so it cannot be handled in the grammar. */
  if (assignment (token, (parser_state & PST_COMPASSIGN) != 0))
    {
      the_word->flags |= W_ASSIGNMENT;
      /* Don't perform word splitting on assignment statements. */
      if (assignment_acceptable (last_read_token) || (parser_state & PST_COMPASSIGN) != 0)
	{
	  the_word->flags |= W_NOSPLIT;
	  if (parser_state & PST_COMPASSIGN)
	    the_word->flags |= W_NOGLOB;	/* XXX - W_NOBRACE? */
	}
    }

  if (command_token_position (last_read_token))
    {
      struct builtin *b;
      b = builtin_address_internal (token, 0);
      if (b && (b->flags & ASSIGNMENT_BUILTIN))
	parser_state |= PST_ASSIGNOK;
      else if (STREQ (token, "eval") || STREQ (token, "let"))
	parser_state |= PST_ASSIGNOK;
    }

  yylval.word = the_word;

  /* should we check that quoted == 0 as well? */
  if (token[0] == '{' && token[token_index-1] == '}' &&
      (character == '<' || character == '>'))
    {
      /* can use token; already copied to the_word */
      token[token_index-1] = '\0';
#if defined (ARRAY_VARS)
      if (legal_identifier (token+1) || valid_array_reference (token+1, 0))
#else
      if (legal_identifier (token+1))
#endif
	{
	  strcpy (the_word->word, token+1);
/* itrace("read_token_word: returning REDIR_WORD for %s", the_word->word); */
	  yylval.word = the_word;	/* accommodate recursive call */
	  return (REDIR_WORD);
	}
      else
        /* valid_array_reference can call the parser recursively; need to
	   make sure that yylval.word doesn't change if we are going to
	   return WORD or ASSIGNMENT_WORD */
        yylval.word = the_word;
    }

  result = ((the_word->flags & (W_ASSIGNMENT|W_NOSPLIT)) == (W_ASSIGNMENT|W_NOSPLIT))
		? ASSIGNMENT_WORD : WORD;

  switch (last_read_token)
    {
    case FUNCTION:
      parser_state |= PST_ALLOWOPNBRC;
      function_dstart = line_number;
      break;
    case CASE:
    case SELECT:
    case FOR:
      if (word_top < MAX_CASE_NEST)
	word_top++;
      word_lineno[word_top] = line_number;
      expecting_in_token++;
      break;
    }

  return (result);
}
warning: parse error {
  /* The value for YYLVAL when a WORD is read. */
  WORD_DESC *the_word;

  /* Index into the token that we are building. */
  int token_index;

  /* ALL_DIGITS becomes zero when we see a non-digit. */
  int all_digit_token;

  /* DOLLAR_PRESENT becomes non-zero if we see a `$'. */
  int dollar_present;

  /* COMPOUND_ASSIGNMENT becomes non-zero if we are parsing a compound
     assignment. */
  int compound_assignment;

  /* QUOTED becomes non-zero if we see one of ("), ('), (`), or (\). */
  int quoted;

  /* Non-zero means to ignore the value of the next character, and just
     to add it no matter what. */
  int pass_next_character;

  /* The current delimiting character. */
  int cd;
  int result, peek_char;
  char *ttok, *ttrans;
  int ttoklen, ttranslen;
  intmax_t lvalue;

  if (token_buffer_size < TOKEN_DEFAULT_INITIAL_SIZE)
    token = (char *)xrealloc (token, token_buffer_size = TOKEN_DEFAULT_INITIAL_SIZE);

  token_index = 0;
  all_digit_token = DIGIT (character);
  dollar_present = quoted = pass_next_character = compound_assignment = 0;

  for (;;)
    {
      if (character == EOF)
	goto got_token;

      if (pass_next_character)
	{
	  pass_next_character = 0;
	  goto got_escaped_character;
	}

      cd = current_delimiter (dstack);

      /* Handle backslashes.  Quote lots of things when not inside of
	 double-quotes, quote some things inside of double-quotes. */
      if MBTEST(character == '\\')
	{
	  peek_char = shell_getc (0);

	  /* Backslash-newline is ignored in all cases except
	     when quoted with single quotes. */
	  if (peek_char == '\n')
	    {
	      character = '\n';
	      goto next_character;
	    }
	  else
	    {
	      shell_ungetc (peek_char);

	      /* If the next character is to be quoted, note it now. */
	      if (cd == 0 || cd == '`' ||
		  (cd == '"' && peek_char >= 0 && (sh_syntaxtab[peek_char] & CBSDQUOTE)))
		pass_next_character++;

	      quoted = 1;
	      goto got_character;
	    }
	}

      /* Parse a matched pair of quote characters. */
      if MBTEST(shellquote (character))
	{
	  push_delimiter (dstack, character);
	  ttok = parse_matched_pair (character, character, character, &ttoklen, (character == '`') ? P_COMMAND : 0);
	  pop_delimiter (dstack);
	  if (ttok == &matched_pair_error)
	    return -1;		/* Bail immediately. */
	  RESIZE_MALLOCED_BUFFER (token, token_index, ttoklen + 2,
				  token_buffer_size, TOKEN_DEFAULT_GROW_SIZE);
	  token[token_index++] = character;
	  strcpy (token + token_index, ttok);
	  token_index += ttoklen;
	  all_digit_token = 0;
	  if (character != '`')
	    quoted = 1;
	  dollar_present |= (character == '"' && strchr (ttok, '$') != 0);
	  FREE (ttok);
	  goto next_character;
	}

#ifdef COND_REGEXP
      /* When parsing a regexp as a single word inside a conditional command,
	 we need to special-case characters special to both the shell and
	 regular expressions.  Right now, that is only '(' and '|'. */ /*)*/
      if MBTEST((parser_state & PST_REGEXP) && (character == '(' || character == '|'))		/*)*/
	{
	  if (character == '|')
	    goto got_character;

	  push_delimiter (dstack, character);
	  ttok = parse_matched_pair (cd, '(', ')', &ttoklen, 0);
	  pop_delimiter (dstack);
	  if (ttok == &matched_pair_error)
	    return -1;		/* Bail immediately. */
	  RESIZE_MALLOCED_BUFFER (token, token_index, ttoklen + 2,
				  token_buffer_size, TOKEN_DEFAULT_GROW_SIZE);
	  token[token_index++] = character;
	  strcpy (token + token_index, ttok);
	  token_index += ttoklen;
	  FREE (ttok);
	  dollar_present = all_digit_token = 0;
	  goto next_character;
	}
#endif /* COND_REGEXP */

#ifdef EXTENDED_GLOB
      /* Parse a ksh-style extended pattern matching specification. */
      if MBTEST(extended_glob && PATTERN_CHAR (character))
	{
	  peek_char = shell_getc (1);
	  if MBTEST(peek_char == '(')		/* ) */
	    {
	      push_delimiter (dstack, peek_char);
	      ttok = parse_matched_pair (cd, '(', ')', &ttoklen, 0);
	      pop_delimiter (dstack);
	      if (ttok == &matched_pair_error)
		return -1;		/* Bail immediately. */
	      RESIZE_MALLOCED_BUFFER (token, token_index, ttoklen + 3,
				      token_buffer_size,
				      TOKEN_DEFAULT_GROW_SIZE);
	      token[token_index++] = character;
	      token[token_index++] = peek_char;
	      strcpy (token + token_index, ttok);
	      token_index += ttoklen;
	      FREE (ttok);
	      dollar_present = all_digit_token = 0;
	      goto next_character;
	    }
	  else
	    shell_ungetc (peek_char);
	}
#endif /* EXTENDED_GLOB */

      /* If the delimiter character is not single quote, parse some of
	 the shell expansions that must be read as a single word. */
      if (shellexp (character))
	{
	  peek_char = shell_getc (1);
	  /* $(...), <(...), >(...), $((...)), ${...}, and $[...] constructs */
	  if MBTEST(peek_char == '(' ||
		((peek_char == '{' || peek_char == '[') && character == '$'))	/* ) ] } */
	    {
	      if (peek_char == '{')		/* } */
		ttok = parse_matched_pair (cd, '{', '}', &ttoklen, P_FIRSTCLOSE|P_DOLBRACE);
	      else if (peek_char == '(')		/* ) */
		{
		  /* XXX - push and pop the `(' as a delimiter for use by
		     the command-oriented-history code.  This way newlines
		     appearing in the $(...) string get added to the
		     history literally rather than causing a possibly-
		     incorrect `;' to be added. ) */
		  push_delimiter (dstack, peek_char);
		  ttok = parse_comsub (cd, '(', ')', &ttoklen, P_COMMAND);
		  pop_delimiter (dstack);
		}
	      else
		ttok = parse_matched_pair (cd, '[', ']', &ttoklen, 0);
	      if (ttok == &matched_pair_error)
		return -1;		/* Bail immediately. */
	      RESIZE_MALLOCED_BUFFER (token, token_index, ttoklen + 3,
				      token_buffer_size,
				      TOKEN_DEFAULT_GROW_SIZE);
	      token[token_index++] = character;
	      token[token_index++] = peek_char;
	      strcpy (token + token_index, ttok);
	      token_index += ttoklen;
	      FREE (ttok);
	      dollar_present = 1;
	      all_digit_token = 0;
	      goto next_character;
	    }
	  /* This handles $'...' and $"..." new-style quoted strings. */
	  else if MBTEST(character == '$' && (peek_char == '\'' || peek_char == '"'))
	    {
	      int first_line;

	      first_line = line_number;
	      push_delimiter (dstack, peek_char);
	      ttok = parse_matched_pair (peek_char, peek_char, peek_char,
					 &ttoklen,
					 (peek_char == '\'') ? P_ALLOWESC : 0);
	      pop_delimiter (dstack);
	      if (ttok == &matched_pair_error)
		return -1;
	      if (peek_char == '\'')
		{
		  ttrans = ansiexpand (ttok, 0, ttoklen - 1, &ttranslen);
		  free (ttok);

		  /* Insert the single quotes and correctly quote any
		     embedded single quotes (allowed because P_ALLOWESC was
		     passed to parse_matched_pair). */
		  ttok = sh_single_quote (ttrans);
		  free (ttrans);
		  ttranslen = strlen (ttok);
		  ttrans = ttok;
		}
	      else
		{
		  /* Try to locale-expand the converted string. */
		  ttrans = localeexpand (ttok, 0, ttoklen - 1, first_line, &ttranslen);
		  free (ttok);

		  /* Add the double quotes back */
		  ttok = sh_mkdoublequoted (ttrans, ttranslen, 0);
		  free (ttrans);
		  ttranslen += 2;
		  ttrans = ttok;
		}

	      RESIZE_MALLOCED_BUFFER (token, token_index, ttranslen + 1,
				      token_buffer_size,
				      TOKEN_DEFAULT_GROW_SIZE);
	      strcpy (token + token_index, ttrans);
	      token_index += ttranslen;
	      FREE (ttrans);
	      quoted = 1;
	      all_digit_token = 0;
	      goto next_character;
	    }
	  /* This could eventually be extended to recognize all of the
	     shell's single-character parameter expansions, and set flags.*/
	  else if MBTEST(character == '$' && peek_char == '$')
	    {
	      RESIZE_MALLOCED_BUFFER (token, token_index, 3,
				      token_buffer_size,
				      TOKEN_DEFAULT_GROW_SIZE);
	      token[token_index++] = '$';
	      token[token_index++] = peek_char;
	      dollar_present = 1;
	      all_digit_token = 0;
	      goto next_character;
	    }
	  else
	    shell_ungetc (peek_char);
	}

#if defined (ARRAY_VARS)
      /* Identify possible array subscript assignment; match [...].  If
	 parser_state&PST_COMPASSIGN, we need to parse [sub]=words treating
	 `sub' as if it were enclosed in double quotes. */
      else if MBTEST(character == '[' &&		/* ] */
		     ((token_index > 0 && assignment_acceptable (last_read_token) && token_is_ident (token, token_index)) ||
		      (token_index == 0 && (parser_state&PST_COMPASSIGN))))
        {
	  ttok = parse_matched_pair (cd, '[', ']', &ttoklen, P_ARRAYSUB);
	  if (ttok == &matched_pair_error)
	    return -1;		/* Bail immediately. */
	  RESIZE_MALLOCED_BUFFER (token, token_index, ttoklen + 2,
				  token_buffer_size,
				  TOKEN_DEFAULT_GROW_SIZE);
	  token[token_index++] = character;
	  strcpy (token + token_index, ttok);
	  token_index += ttoklen;
	  FREE (ttok);
	  all_digit_token = 0;
	  goto next_character;
        }
      /* Identify possible compound array variable assignment. */
      else if MBTEST(character == '=' && token_index > 0 && (assignment_acceptable (last_read_token) || (parser_state & PST_ASSIGNOK)) && token_is_assignment (token, token_index))
	{
	  peek_char = shell_getc (1);
	  if MBTEST(peek_char == '(')		/* ) */
	    {
	      ttok = parse_compound_assignment (&ttoklen);

	      RESIZE_MALLOCED_BUFFER (token, token_index, ttoklen + 4,
				      token_buffer_size,
				      TOKEN_DEFAULT_GROW_SIZE);

	      token[token_index++] = '=';
	      token[token_index++] = '(';
	      if (ttok)
		{
		  strcpy (token + token_index, ttok);
		  token_index += ttoklen;
		}
	      token[token_index++] = ')';
	      FREE (ttok);
	      all_digit_token = 0;
	      compound_assignment = 1;
#if 1
	      goto next_character;
#else
	      goto got_token;		/* ksh93 seems to do this */
#endif
	    }
	  else
	    shell_ungetc (peek_char);
	}
#endif

      /* When not parsing a multi-character word construct, shell meta-
	 characters break words. */
      if MBTEST(shellbreak (character))
	{
	  shell_ungetc (character);
	  goto got_token;
	}

got_character:
      if (character == CTLESC || character == CTLNUL)
	{
	  RESIZE_MALLOCED_BUFFER (token, token_index, 2, token_buffer_size,
				  TOKEN_DEFAULT_GROW_SIZE);
	  token[token_index++] = CTLESC;
	}
      else
got_escaped_character:
	RESIZE_MALLOCED_BUFFER (token, token_index, 1, token_buffer_size,
				TOKEN_DEFAULT_GROW_SIZE);

      token[token_index++] = character;

      all_digit_token &= DIGIT (character);
      dollar_present |= character == '$';

    next_character:
      if (character == '\n' && SHOULD_PROMPT ())
	prompt_again ();

      /* We want to remove quoted newlines (that is, a \<newline> pair)
	 unless we are within single quotes or pass_next_character is
	 set (the shell equivalent of literal-next). */
      cd = current_delimiter (dstack);
      character = shell_getc (cd != '\'' && pass_next_character == 0);
    }	/* end for (;;) */

got_token:

  /* Calls to RESIZE_MALLOCED_BUFFER ensure there is sufficient room. */
  token[token_index] = '\0';

  /* Check to see what thing we should return.  If the last_read_token
     is a `<', or a `&', or the character which ended this token is
     a '>' or '<', then, and ONLY then, is this input token a NUMBER.
     Otherwise, it is just a word, and should be returned as such. */
  if MBTEST(all_digit_token && (character == '<' || character == '>' ||
		    last_read_token == LESS_AND ||
		    last_read_token == GREATER_AND))
      {
	if (legal_number (token, &lvalue) && (int)lvalue == lvalue)
	  {
	    yylval.number = lvalue;
	    return (NUMBER);
	  }
      }

  /* Check for special case tokens. */
  result = (last_shell_getc_is_singlebyte) ? special_case_tokens (token) : -1;
  if (result >= 0)
    return result;

#if defined (ALIAS)
  /* Posix.2 does not allow reserved words to be aliased, so check for all
     of them, including special cases, before expanding the current token
     as an alias. */
  if MBTEST(posixly_correct)
    CHECK_FOR_RESERVED_WORD (token);

  /* Aliases are expanded iff EXPAND_ALIASES is non-zero, and quoting
     inhibits alias expansion. */
  if (expand_aliases && quoted == 0)
    {
      result = alias_expand_token (token);
      if (result == RE_READ_TOKEN)
	return (RE_READ_TOKEN);
      else if (result == NO_EXPANSION)
	parser_state &= ~PST_ALEXPNEXT;
    }

  /* If not in Posix.2 mode, check for reserved words after alias
     expansion. */
  if MBTEST(posixly_correct == 0)
#endif
    CHECK_FOR_RESERVED_WORD (token);

  the_word = alloc_word_desc ();
  the_word->word = (char *)xmalloc (1 + token_index);
  the_word->flags = 0;
  strcpy (the_word->word, token);
  if (dollar_present)
    the_word->flags |= W_HASDOLLAR;
  if (quoted)
    the_word->flags |= W_QUOTED;		/*(*/
  if (compound_assignment && token[token_index-1] == ')')
    the_word->flags |= W_COMPASSIGN;
  /* A word is an assignment if it appears at the beginning of a
     simple command, or after another assignment word.  This is
     context-dependent, so it cannot be handled in the grammar. */
  if (assignment (token, (parser_state & PST_COMPASSIGN) != 0))
    {
      the_word->flags |= W_ASSIGNMENT;
      /* Don't perform word splitting on assignment statements. */
      if (assignment_acceptable (last_read_token) || (parser_state & PST_COMPASSIGN) != 0)
	{
	  the_word->flags |= W_NOSPLIT;
	  if (parser_state & PST_COMPASSIGN)
	    the_word->flags |= W_NOGLOB;	/* XXX - W_NOBRACE? */
	}
    }

  if (command_token_position (last_read_token))
    {
      struct builtin *b;
      b = builtin_address_internal (token, 0);
      if (b && (b->flags & ASSIGNMENT_BUILTIN))
	parser_state |= PST_ASSIGNOK;
      else if (STREQ (token, "eval") || STREQ (token, "let"))
	parser_state |= PST_ASSIGNOK;
    }

  yylval.word = the_word;

  /* should we check that quoted == 0 as well? */
  if (token[0] == '{' && token[token_index-1] == '}' &&
      (character == '<' || character == '>'))
    {
      /* can use token; already copied to the_word */
      token[token_index-1] = '\0';
#if defined (ARRAY_VARS)
      if (legal_identifier (token+1) || valid_array_reference (token+1, 0))
#else
      if (legal_identifier (token+1))
#endif
	{
	  strcpy (the_word->word, token+1);
/* itrace("read_token_word: returning REDIR_WORD for %s", the_word->word); */
	  yylval.word = the_word;	/* accommodate recursive call */
	  return (REDIR_WORD);
	}
      else
        /* valid_array_reference can call the parser recursively; need to
	   make sure that yylval.word doesn't change if we are going to
	   return WORD or ASSIGNMENT_WORD */
        yylval.word = the_word;
    }

  result = ((the_word->flags & (W_ASSIGNMENT|W_NOSPLIT)) == (W_ASSIGNMENT|W_NOSPLIT))
		? ASSIGNMENT_WORD : WORD;

  switch (last_read_token)
    {
    case FUNCTION:
      parser_state |= PST_ALLOWOPNBRC;
      function_dstart = line_number;
      break;
    case CASE:
    case SELECT:
    case FOR:
      if (word_top < MAX_CASE_NEST)
	word_top++;
      word_lineno[word_top] = line_number;
      expecting_in_token++;
      break;
    }

  return (result);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\y.tab.c:7,274
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\y.tab.c:7,756
parsing error 
{
  switch (toksym)
    {
    case '\n':
    case ';':
    case '(':
    case ')':
    case '|':
    case '&':
    case '{':
    case '}':		/* XXX */
    case AND_AND:
    case BANG:
    case BAR_AND:
    case DO:
    case DONE:
    case ELIF:
    case ELSE:
    case ESAC:
    case FI:
    case IF:
    case OR_OR:
    case SEMI_SEMI:
    case SEMI_AND:
    case SEMI_SEMI_AND:
    case THEN:
    case TIME:
    case TIMEOPT:
    case TIMEIGN:
    case COPROC:
    case UNTIL:
    case WHILE:
    case 0:
      return 1;
    default:
#if defined (COPROCESS_SUPPORT)
      if (last_read_token == WORD && token_before_that == COPROC)
	return 1;
#endif
      if (last_read_token == WORD && token_before_that == FUNCTION)
	return 1;
      return 0;
    }
}
warning: parse error {
  switch (toksym)
    {
    case '\n':
    case ';':
    case '(':
    case ')':
    case '|':
    case '&':
    case '{':
    case '}':		/* XXX */
    case AND_AND:
    case BANG:
    case BAR_AND:
    case DO:
    case DONE:
    case ELIF:
    case ELSE:
    case ESAC:
    case FI:
    case IF:
    case OR_OR:
    case SEMI_SEMI:
    case SEMI_AND:
    case SEMI_SEMI_AND:
    case THEN:
    case TIME:
    case TIMEOPT:
    case TIMEIGN:
    case COPROC:
    case UNTIL:
    case WHILE:
    case 0:
      return 1;
    default:
#if defined (COPROCESS_SUPPORT)
      if (last_read_token == WORD && token_before_that == COPROC)
	return 1;
#endif
      if (last_read_token == WORD && token_before_that == FUNCTION)
	return 1;
      return 0;
    }
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\y.tab.c:7,758
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\y.tab.c:7,806
parsing error 
{
  int i;
  for (i = 0; word_token_alist[i].word; i++)
    if (STREQ (tokstr, word_token_alist[i].word))
      return i;
  return -1;
}
warning: parse error {
  int i;
  for (i = 0; word_token_alist[i].word; i++)
    if (STREQ (tokstr, word_token_alist[i].word))
      return i;
  return -1;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\y.tab.c:7,808
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\y.tab.c:8,009
parsing error 
{
  prompt_string_pointer = (x == 2) ? &ps2_prompt : &ps1_prompt;
  current_prompt_string = *prompt_string_pointer;
}
warning: parse error {
  prompt_string_pointer = (x == 2) ? &ps2_prompt : &ps1_prompt;
  current_prompt_string = *prompt_string_pointer;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\y.tab.c:8,011
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\y.tab.c:8,081
parsing error 
{
  WORD_LIST *list;
  char *result, *t, *orig_string;
  struct dstack save_dstack;
  int last_exit_value, last_comsub_pid;
#if defined (PROMPT_STRING_DECODE)
  size_t result_size;
  int result_index;
  int c, n, i;
  char *temp, *t_host, octal_string[4];
  struct tm *tm;  
  time_t the_time;
  char timebuf[128];
  char *timefmt;

  result = (char *)xmalloc (result_size = PROMPT_GROWTH);
  result[result_index = 0] = 0;
  temp = (char *)NULL;
  orig_string = string;

  while (c = *string++)
    {
      if (posixly_correct && c == '!')
	{
	  if (*string == '!')
	    {
	      temp = savestring ("!");
	      goto add_string;
	    }
	  else
	    {
#if !defined (HISTORY)
		temp = savestring ("1");
#else /* HISTORY */
		temp = itos (prompt_history_number (orig_string));
#endif /* HISTORY */
		string--;	/* add_string increments string again. */
		goto add_string;
	    }
	}
      if (c == '\\')
	{
	  c = *string;

	  switch (c)
	    {
	    case '0':
	    case '1':
	    case '2':
	    case '3':
	    case '4':
	    case '5':
	    case '6':
	    case '7':
	      strncpy (octal_string, string, 3);
	      octal_string[3] = '\0';

	      n = read_octal (octal_string);
	      temp = (char *)xmalloc (3);

	      if (n == CTLESC || n == CTLNUL)
		{
		  temp[0] = CTLESC;
		  temp[1] = n;
		  temp[2] = '\0';
		}
	      else if (n == -1)
		{
		  temp[0] = '\\';
		  temp[1] = '\0';
		}
	      else
		{
		  temp[0] = n;
		  temp[1] = '\0';
		}

	      for (c = 0; n != -1 && c < 3 && ISOCTAL (*string); c++)
		string++;

	      c = 0;		/* tested at add_string: */
	      goto add_string;

	    case 'd':
	    case 't':
	    case 'T':
	    case '@':
	    case 'A':
	      /* Make the current time/date into a string. */
	      (void) time (&the_time);
#if defined (HAVE_TZSET)
	      sv_tz ("TZ");		/* XXX -- just make sure */
#endif
	      tm = localtime (&the_time);

	      if (c == 'd')
		n = strftime (timebuf, sizeof (timebuf), "%a %b %d", tm);
	      else if (c == 't')
		n = strftime (timebuf, sizeof (timebuf), "%H:%M:%S", tm);
	      else if (c == 'T')
		n = strftime (timebuf, sizeof (timebuf), "%I:%M:%S", tm);
	      else if (c == '@')
		n = strftime (timebuf, sizeof (timebuf), "%I:%M %p", tm);
	      else if (c == 'A')
		n = strftime (timebuf, sizeof (timebuf), "%H:%M", tm);

	      if (n == 0)
		timebuf[0] = '\0';
	      else
		timebuf[sizeof(timebuf) - 1] = '\0';

	      temp = savestring (timebuf);
	      goto add_string;

	    case 'D':		/* strftime format */
	      if (string[1] != '{')		/* } */
		goto not_escape;

	      (void) time (&the_time);
	      tm = localtime (&the_time);
	      string += 2;			/* skip { */
	      timefmt = xmalloc (strlen (string) + 3);
	      for (t = timefmt; *string && *string != '}'; )
		*t++ = *string++;
	      *t = '\0';
	      c = *string;	/* tested at add_string */
	      if (timefmt[0] == '\0')
		{
		  timefmt[0] = '%';
		  timefmt[1] = 'X';	/* locale-specific current time */
		  timefmt[2] = '\0';
		}
	      n = strftime (timebuf, sizeof (timebuf), timefmt, tm);
	      free (timefmt);

	      if (n == 0)
		timebuf[0] = '\0';
	      else
		timebuf[sizeof(timebuf) - 1] = '\0';

	      if (promptvars || posixly_correct)
		/* Make sure that expand_prompt_string is called with a
		   second argument of Q_DOUBLE_QUOTES if we use this
		   function here. */
		temp = sh_backslash_quote_for_double_quotes (timebuf);
	      else
		temp = savestring (timebuf);
	      goto add_string;
	      
	    case 'n':
	      temp = (char *)xmalloc (3);
	      temp[0] = no_line_editing ? '\n' : '\r';
	      temp[1] = no_line_editing ? '\0' : '\n';
	      temp[2] = '\0';
	      goto add_string;

	    case 's':
	      temp = base_pathname (shell_name);
	      /* Try to quote anything the user can set in the file system */
	      if (promptvars || posixly_correct)
		temp = sh_backslash_quote_for_double_quotes (temp);
	      else
		temp = savestring (temp);
	      goto add_string;

	    case 'v':
	    case 'V':
	      temp = (char *)xmalloc (16);
	      if (c == 'v')
		strcpy (temp, dist_version);
	      else
		sprintf (temp, "%s.%d", dist_version, patch_level);
	      goto add_string;

	    case 'w':
	    case 'W':
	      {
		/* Use the value of PWD because it is much more efficient. */
		char t_string[PATH_MAX];
		int tlen;

		temp = get_string_value ("PWD");

		if (temp == 0)
		  {
		    if (getcwd (t_string, sizeof(t_string)) == 0)
		      {
			t_string[0] = '.';
			tlen = 1;
		      }
		    else
		      tlen = strlen (t_string);
		  }
		else
		  {
		    tlen = sizeof (t_string) - 1;
		    strncpy (t_string, temp, tlen);
		  }
		t_string[tlen] = '\0';

#if defined (MACOSX)
		/* Convert from "fs" format to "input" format */
		temp = fnx_fromfs (t_string, strlen (t_string));
		if (temp != t_string)
		  strcpy (t_string, temp);
#endif

#define ROOT_PATH(x)	((x)[0] == '/' && (x)[1] == 0)
#define DOUBLE_SLASH_ROOT(x)	((x)[0] == '/' && (x)[1] == '/' && (x)[2] == 0)
		/* Abbreviate \W as ~ if $PWD == $HOME */
		if (c == 'W' && (((t = get_string_value ("HOME")) == 0) || STREQ (t, t_string) == 0))
		  {
		    if (ROOT_PATH (t_string) == 0 && DOUBLE_SLASH_ROOT (t_string) == 0)
		      {
			t = strrchr (t_string, '/');
			if (t)
			  memmove (t_string, t + 1, strlen (t));	/* strlen(t) to copy NULL */
		      }
		  }
#undef ROOT_PATH
#undef DOUBLE_SLASH_ROOT
		else
		  {
		    /* polite_directory_format is guaranteed to return a string
		       no longer than PATH_MAX - 1 characters. */
		    temp = polite_directory_format (t_string);
		    if (temp != t_string)
		      strcpy (t_string, temp);
		  }

		temp = trim_pathname (t_string, PATH_MAX - 1);
		/* If we're going to be expanding the prompt string later,
		   quote the directory name. */
		if (promptvars || posixly_correct)
		  /* Make sure that expand_prompt_string is called with a
		     second argument of Q_DOUBLE_QUOTES if we use this
		     function here. */
		  temp = sh_backslash_quote_for_double_quotes (t_string);
		else
		  temp = savestring (t_string);

		goto add_string;
	      }

	    case 'u':
	      if (current_user.user_name == 0)
		get_current_user_info ();
	      temp = savestring (current_user.user_name);
	      goto add_string;

	    case 'h':
	    case 'H':
	      t_host = savestring (current_host_name);
	      if (c == 'h' && (t = (char *)strchr (t_host, '.')))
		*t = '\0';
	      if (promptvars || posixly_correct)
		/* Make sure that expand_prompt_string is called with a
		   second argument of Q_DOUBLE_QUOTES if we use this
		   function here. */
		temp = sh_backslash_quote_for_double_quotes (t_host);
	      else
		temp = savestring (t_host);
	      free (t_host);
	      goto add_string;

	    case '#':
	      n = current_command_number;
	      /* If we have already incremented current_command_number (PS4,
		 ${var@P}), compensate */
	      if (orig_string != ps0_prompt && orig_string != ps1_prompt && orig_string != ps2_prompt)
		n--;
	      temp = itos (n);
	      goto add_string;

	    case '!':
#if !defined (HISTORY)
	      temp = savestring ("1");
#else /* HISTORY */
	      temp = itos (prompt_history_number (orig_string));
#endif /* HISTORY */
	      goto add_string;

	    case '$':
	      t = temp = (char *)xmalloc (3);
	      if ((promptvars || posixly_correct) && (current_user.euid != 0))
		*t++ = '\\';
	      *t++ = current_user.euid == 0 ? '#' : '$';
	      *t = '\0';
	      goto add_string;

	    case 'j':
	      temp = itos (count_all_jobs ());
	      goto add_string;

	    case 'l':
#if defined (HAVE_TTYNAME)
	      temp = (char *)ttyname (fileno (stdin));
	      t = temp ? base_pathname (temp) : "tty";
	      temp = savestring (t);
#else
	      temp = savestring ("tty");
#endif /* !HAVE_TTYNAME */
	      goto add_string;

#if defined (READLINE)
	    case '[':
	    case ']':
	      if (no_line_editing)
		{
		  string++;
		  break;
		}
	      temp = (char *)xmalloc (3);
	      n = (c == '[') ? RL_PROMPT_START_IGNORE : RL_PROMPT_END_IGNORE;
	      i = 0;
	      if (n == CTLESC || n == CTLNUL)
		temp[i++] = CTLESC;
	      temp[i++] = n;
	      temp[i] = '\0';
	      goto add_string;
#endif /* READLINE */

	    case '\\':
	    case 'a':
	    case 'e':
	    case 'r':
	      temp = (char *)xmalloc (2);
	      if (c == 'a')
		temp[0] = '\07';
	      else if (c == 'e')
		temp[0] = '\033';
	      else if (c == 'r')
		temp[0] = '\r';
	      else			/* (c == '\\') */
	        temp[0] = c;
	      temp[1] = '\0';
	      goto add_string;

	    default:
not_escape:
	      temp = (char *)xmalloc (3);
	      temp[0] = '\\';
	      temp[1] = c;
	      temp[2] = '\0';

	    add_string:
	      if (c)
		string++;
	      result =
		sub_append_string (temp, result, &result_index, &result_size);
	      temp = (char *)NULL; /* Freed in sub_append_string (). */
	      result[result_index] = '\0';
	      break;
	    }
	}
      else
	{
	  RESIZE_MALLOCED_BUFFER (result, result_index, 3, result_size, PROMPT_GROWTH);
	  /* dequote_string should take care of removing this if we are not
	     performing the rest of the word expansions. */
	  if (c == CTLESC || c == CTLNUL)
	    result[result_index++] = CTLESC;
	  result[result_index++] = c;
	  result[result_index] = '\0';
	}
    }
#else /* !PROMPT_STRING_DECODE */
  result = savestring (string);
#endif /* !PROMPT_STRING_DECODE */

  /* Save the delimiter stack and point `dstack' to temp space so any
     command substitutions in the prompt string won't result in screwing
     up the parser's quoting state. */
  save_dstack = dstack;
  dstack = temp_dstack;
  dstack.delimiter_depth = 0;

  /* Perform variable and parameter expansion and command substitution on
     the prompt string. */
  if (promptvars || posixly_correct)
    {
      last_exit_value = last_command_exit_value;
      last_comsub_pid = last_command_subst_pid;
      list = expand_prompt_string (result, Q_DOUBLE_QUOTES, 0);
      free (result);
      result = string_list (list);
      dispose_words (list);
      last_command_exit_value = last_exit_value;
      last_command_subst_pid = last_comsub_pid;
    }
  else
    {
      t = dequote_string (result);
      free (result);
      result = t;
    }

  dstack = save_dstack;

  return (result);
}
warning: parse error {
  WORD_LIST *list;
  char *result, *t, *orig_string;
  struct dstack save_dstack;
  int last_exit_value, last_comsub_pid;
#if defined (PROMPT_STRING_DECODE)
  size_t result_size;
  int result_index;
  int c, n, i;
  char *temp, *t_host, octal_string[4];
  struct tm *tm;  
  time_t the_time;
  char timebuf[128];
  char *timefmt;

  result = (char *)xmalloc (result_size = PROMPT_GROWTH);
  result[result_index = 0] = 0;
  temp = (char *)NULL;
  orig_string = string;

  while (c = *string++)
    {
      if (posixly_correct && c == '!')
	{
	  if (*string == '!')
	    {
	      temp = savestring ("!");
	      goto add_string;
	    }
	  else
	    {
#if !defined (HISTORY)
		temp = savestring ("1");
#else /* HISTORY */
		temp = itos (prompt_history_number (orig_string));
#endif /* HISTORY */
		string--;	/* add_string increments string again. */
		goto add_string;
	    }
	}
      if (c == '\\')
	{
	  c = *string;

	  switch (c)
	    {
	    case '0':
	    case '1':
	    case '2':
	    case '3':
	    case '4':
	    case '5':
	    case '6':
	    case '7':
	      strncpy (octal_string, string, 3);
	      octal_string[3] = '\0';

	      n = read_octal (octal_string);
	      temp = (char *)xmalloc (3);

	      if (n == CTLESC || n == CTLNUL)
		{
		  temp[0] = CTLESC;
		  temp[1] = n;
		  temp[2] = '\0';
		}
	      else if (n == -1)
		{
		  temp[0] = '\\';
		  temp[1] = '\0';
		}
	      else
		{
		  temp[0] = n;
		  temp[1] = '\0';
		}

	      for (c = 0; n != -1 && c < 3 && ISOCTAL (*string); c++)
		string++;

	      c = 0;		/* tested at add_string: */
	      goto add_string;

	    case 'd':
	    case 't':
	    case 'T':
	    case '@':
	    case 'A':
	      /* Make the current time/date into a string. */
	      (void) time (&the_time);
#if defined (HAVE_TZSET)
	      sv_tz ("TZ");		/* XXX -- just make sure */
#endif
	      tm = localtime (&the_time);

	      if (c == 'd')
		n = strftime (timebuf, sizeof (timebuf), "%a %b %d", tm);
	      else if (c == 't')
		n = strftime (timebuf, sizeof (timebuf), "%H:%M:%S", tm);
	      else if (c == 'T')
		n = strftime (timebuf, sizeof (timebuf), "%I:%M:%S", tm);
	      else if (c == '@')
		n = strftime (timebuf, sizeof (timebuf), "%I:%M %p", tm);
	      else if (c == 'A')
		n = strftime (timebuf, sizeof (timebuf), "%H:%M", tm);

	      if (n == 0)
		timebuf[0] = '\0';
	      else
		timebuf[sizeof(timebuf) - 1] = '\0';

	      temp = savestring (timebuf);
	      goto add_string;

	    case 'D':		/* strftime format */
	      if (string[1] != '{')		/* } */
		goto not_escape;

	      (void) time (&the_time);
	      tm = localtime (&the_time);
	      string += 2;			/* skip { */
	      timefmt = xmalloc (strlen (string) + 3);
	      for (t = timefmt; *string && *string != '}'; )
		*t++ = *string++;
	      *t = '\0';
	      c = *string;	/* tested at add_string */
	      if (timefmt[0] == '\0')
		{
		  timefmt[0] = '%';
		  timefmt[1] = 'X';	/* locale-specific current time */
		  timefmt[2] = '\0';
		}
	      n = strftime (timebuf, sizeof (timebuf), timefmt, tm);
	      free (timefmt);

	      if (n == 0)
		timebuf[0] = '\0';
	      else
		timebuf[sizeof(timebuf) - 1] = '\0';

	      if (promptvars || posixly_correct)
		/* Make sure that expand_prompt_string is called with a
		   second argument of Q_DOUBLE_QUOTES if we use this
		   function here. */
		temp = sh_backslash_quote_for_double_quotes (timebuf);
	      else
		temp = savestring (timebuf);
	      goto add_string;
	      
	    case 'n':
	      temp = (char *)xmalloc (3);
	      temp[0] = no_line_editing ? '\n' : '\r';
	      temp[1] = no_line_editing ? '\0' : '\n';
	      temp[2] = '\0';
	      goto add_string;

	    case 's':
	      temp = base_pathname (shell_name);
	      /* Try to quote anything the user can set in the file system */
	      if (promptvars || posixly_correct)
		temp = sh_backslash_quote_for_double_quotes (temp);
	      else
		temp = savestring (temp);
	      goto add_string;

	    case 'v':
	    case 'V':
	      temp = (char *)xmalloc (16);
	      if (c == 'v')
		strcpy (temp, dist_version);
	      else
		sprintf (temp, "%s.%d", dist_version, patch_level);
	      goto add_string;

	    case 'w':
	    case 'W':
	      {
		/* Use the value of PWD because it is much more efficient. */
		char t_string[PATH_MAX];
		int tlen;

		temp = get_string_value ("PWD");

		if (temp == 0)
		  {
		    if (getcwd (t_string, sizeof(t_string)) == 0)
		      {
			t_string[0] = '.';
			tlen = 1;
		      }
		    else
		      tlen = strlen (t_string);
		  }
		else
		  {
		    tlen = sizeof (t_string) - 1;
		    strncpy (t_string, temp, tlen);
		  }
		t_string[tlen] = '\0';

#if defined (MACOSX)
		/* Convert from "fs" format to "input" format */
		temp = fnx_fromfs (t_string, strlen (t_string));
		if (temp != t_string)
		  strcpy (t_string, temp);
#endif

#define ROOT_PATH(x)	((x)[0] == '/' && (x)[1] == 0)
#define DOUBLE_SLASH_ROOT(x)	((x)[0] == '/' && (x)[1] == '/' && (x)[2] == 0)
		/* Abbreviate \W as ~ if $PWD == $HOME */
		if (c == 'W' && (((t = get_string_value ("HOME")) == 0) || STREQ (t, t_string) == 0))
		  {
		    if (ROOT_PATH (t_string) == 0 && DOUBLE_SLASH_ROOT (t_string) == 0)
		      {
			t = strrchr (t_string, '/');
			if (t)
			  memmove (t_string, t + 1, strlen (t));	/* strlen(t) to copy NULL */
		      }
		  }
#undef ROOT_PATH
#undef DOUBLE_SLASH_ROOT
		else
		  {
		    /* polite_directory_format is guaranteed to return a string
		       no longer than PATH_MAX - 1 characters. */
		    temp = polite_directory_format (t_string);
		    if (temp != t_string)
		      strcpy (t_string, temp);
		  }

		temp = trim_pathname (t_string, PATH_MAX - 1);
		/* If we're going to be expanding the prompt string later,
		   quote the directory name. */
		if (promptvars || posixly_correct)
		  /* Make sure that expand_prompt_string is called with a
		     second argument of Q_DOUBLE_QUOTES if we use this
		     function here. */
		  temp = sh_backslash_quote_for_double_quotes (t_string);
		else
		  temp = savestring (t_string);

		goto add_string;
	      }

	    case 'u':
	      if (current_user.user_name == 0)
		get_current_user_info ();
	      temp = savestring (current_user.user_name);
	      goto add_string;

	    case 'h':
	    case 'H':
	      t_host = savestring (current_host_name);
	      if (c == 'h' && (t = (char *)strchr (t_host, '.')))
		*t = '\0';
	      if (promptvars || posixly_correct)
		/* Make sure that expand_prompt_string is called with a
		   second argument of Q_DOUBLE_QUOTES if we use this
		   function here. */
		temp = sh_backslash_quote_for_double_quotes (t_host);
	      else
		temp = savestring (t_host);
	      free (t_host);
	      goto add_string;

	    case '#':
	      n = current_command_number;
	      /* If we have already incremented current_command_number (PS4,
		 ${var@P}), compensate */
	      if (orig_string != ps0_prompt && orig_string != ps1_prompt && orig_string != ps2_prompt)
		n--;
	      temp = itos (n);
	      goto add_string;

	    case '!':
#if !defined (HISTORY)
	      temp = savestring ("1");
#else /* HISTORY */
	      temp = itos (prompt_history_number (orig_string));
#endif /* HISTORY */
	      goto add_string;

	    case '$':
	      t = temp = (char *)xmalloc (3);
	      if ((promptvars || posixly_correct) && (current_user.euid != 0))
		*t++ = '\\';
	      *t++ = current_user.euid == 0 ? '#' : '$';
	      *t = '\0';
	      goto add_string;

	    case 'j':
	      temp = itos (count_all_jobs ());
	      goto add_string;

	    case 'l':
#if defined (HAVE_TTYNAME)
	      temp = (char *)ttyname (fileno (stdin));
	      t = temp ? base_pathname (temp) : "tty";
	      temp = savestring (t);
#else
	      temp = savestring ("tty");
#endif /* !HAVE_TTYNAME */
	      goto add_string;

#if defined (READLINE)
	    case '[':
	    case ']':
	      if (no_line_editing)
		{
		  string++;
		  break;
		}
	      temp = (char *)xmalloc (3);
	      n = (c == '[') ? RL_PROMPT_START_IGNORE : RL_PROMPT_END_IGNORE;
	      i = 0;
	      if (n == CTLESC || n == CTLNUL)
		temp[i++] = CTLESC;
	      temp[i++] = n;
	      temp[i] = '\0';
	      goto add_string;
#endif /* READLINE */

	    case '\\':
	    case 'a':
	    case 'e':
	    case 'r':
	      temp = (char *)xmalloc (2);
	      if (c == 'a')
		temp[0] = '\07';
	      else if (c == 'e')
		temp[0] = '\033';
	      else if (c == 'r')
		temp[0] = '\r';
	      else			/* (c == '\\') */
	        temp[0] = c;
	      temp[1] = '\0';
	      goto add_string;

	    default:
not_escape:
	      temp = (char *)xmalloc (3);
	      temp[0] = '\\';
	      temp[1] = c;
	      temp[2] = '\0';

	    add_string:
	      if (c)
		string++;
	      result =
		sub_append_string (temp, result, &result_index, &result_size);
	      temp = (char *)NULL; /* Freed in sub_append_string (). */
	      result[result_index] = '\0';
	      break;
	    }
	}
      else
	{
	  RESIZE_MALLOCED_BUFFER (result, result_index, 3, result_size, PROMPT_GROWTH);
	  /* dequote_string should take care of removing this if we are not
	     performing the rest of the word expansions. */
	  if (c == CTLESC || c == CTLNUL)
	    result[result_index++] = CTLESC;
	  result[result_index++] = c;
	  result[result_index] = '\0';
	}
    }
#else /* !PROMPT_STRING_DECODE */
  result = savestring (string);
#endif /* !PROMPT_STRING_DECODE */

  /* Save the delimiter stack and point `dstack' to temp space so any
     command substitutions in the prompt string won't result in screwing
     up the parser's quoting state. */
  save_dstack = dstack;
  dstack = temp_dstack;
  dstack.delimiter_depth = 0;

  /* Perform variable and parameter expansion and command substitution on
     the prompt string. */
  if (promptvars || posixly_correct)
    {
      last_exit_value = last_command_exit_value;
      last_comsub_pid = last_command_subst_pid;
      list = expand_prompt_string (result, Q_DOUBLE_QUOTES, 0);
      free (result);
      result = string_list (list);
      dispose_words (list);
      last_command_exit_value = last_exit_value;
      last_command_subst_pid = last_comsub_pid;
    }
  else
    {
      t = dequote_string (result);
      free (result);
      result = t;
    }

  dstack = save_dstack;

  return (result);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\y.tab.c:8,083
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\y.tab.c:8,495
parsing error 
{
  report_syntax_error ((char *)NULL);
  reset_parser ();
  return (0);
}
warning: parse error {
  report_syntax_error ((char *)NULL);
  reset_parser ();
  return (0);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\y.tab.c:8,496
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\y.tab.c:8,503
parsing error 
{
  char *t;

  if (t = find_token_in_alist (tok, word_token_alist, 0))
    return t;

  if (t = find_token_in_alist (tok, other_token_alist, 0))
    return t;

  t = (char *)NULL;
  /* This stuff is dicy and needs closer inspection */
  switch (current_token)
    {
    case WORD:
    case ASSIGNMENT_WORD:
      if (yylval.word)
	t = savestring (yylval.word->word);
      break;
    case NUMBER:
      t = itos (yylval.number);
      break;
    case ARITH_CMD:
      if (yylval.word_list)
        t = string_list (yylval.word_list);
      break;
    case ARITH_FOR_EXPRS:
      if (yylval.word_list)
	t = string_list_internal (yylval.word_list, " ; ");
      break;
    case COND_CMD:
      t = (char *)NULL;		/* punt */
      break;
    }

  return t;
}
warning: parse error {
  char *t;

  if (t = find_token_in_alist (tok, word_token_alist, 0))
    return t;

  if (t = find_token_in_alist (tok, other_token_alist, 0))
    return t;

  t = (char *)NULL;
  /* This stuff is dicy and needs closer inspection */
  switch (current_token)
    {
    case WORD:
    case ASSIGNMENT_WORD:
      if (yylval.word)
	t = savestring (yylval.word->word);
      break;
    case NUMBER:
      t = itos (yylval.number);
      break;
    case ARITH_CMD:
      if (yylval.word_list)
        t = string_list (yylval.word_list);
      break;
    case ARITH_FOR_EXPRS:
      if (yylval.word_list)
	t = string_list_internal (yylval.word_list, " ; ");
      break;
    case COND_CMD:
      t = (char *)NULL;		/* punt */
      break;
    }

  return t;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\y.tab.c:8,505
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\y.tab.c:8,604
parsing error 
{
  char *msg, *p;

  if (message)
    {
      parser_error (line_number, "%s", message);
      if (interactive && EOF_Reached)
	EOF_Reached = 0;
      last_command_exit_value = (executing_builtin && parse_and_execute_level) ? EX_BADSYNTAX : EX_BADUSAGE;
      set_pipestatus_from_exit (last_command_exit_value);
      return;
    }

  /* If the line of input we're reading is not null, try to find the
     objectionable token.  First, try to figure out what token the
     parser's complaining about by looking at current_token. */
  if (current_token != 0 && EOF_Reached == 0 && (msg = error_token_from_token (current_token)))
    {
      if (ansic_shouldquote (msg))
	{
	  p = ansic_quote (msg, 0, NULL);
	  free (msg);
	  msg = p;
	}
      parser_error (line_number, _("syntax error near unexpected token `%s'"), msg);
      free (msg);

      if (interactive == 0)
	print_offending_line ();

      last_command_exit_value = (executing_builtin && parse_and_execute_level) ? EX_BADSYNTAX : EX_BADUSAGE;
      set_pipestatus_from_exit (last_command_exit_value);
      return;
    }

  /* If looking at the current token doesn't prove fruitful, try to find the
     offending token by analyzing the text of the input line near the current
     input line index and report what we find. */
  if (shell_input_line && *shell_input_line)
    {
      msg = error_token_from_text ();
      if (msg)
	{
	  parser_error (line_number, _("syntax error near `%s'"), msg);
	  free (msg);
	}

      /* If not interactive, print the line containing the error. */
      if (interactive == 0)
        print_offending_line ();
    }
  else
    {
      msg = EOF_Reached ? _("syntax error: unexpected end of file") : _("syntax error");
      parser_error (line_number, "%s", msg);
      /* When the shell is interactive, this file uses EOF_Reached
	 only for error reporting.  Other mechanisms are used to
	 decide whether or not to exit. */
      if (interactive && EOF_Reached)
	EOF_Reached = 0;
    }

  last_command_exit_value = (executing_builtin && parse_and_execute_level) ? EX_BADSYNTAX : EX_BADUSAGE;
  set_pipestatus_from_exit (last_command_exit_value);
}
warning: parse error {
  char *msg, *p;

  if (message)
    {
      parser_error (line_number, "%s", message);
      if (interactive && EOF_Reached)
	EOF_Reached = 0;
      last_command_exit_value = (executing_builtin && parse_and_execute_level) ? EX_BADSYNTAX : EX_BADUSAGE;
      set_pipestatus_from_exit (last_command_exit_value);
      return;
    }

  /* If the line of input we're reading is not null, try to find the
     objectionable token.  First, try to figure out what token the
     parser's complaining about by looking at current_token. */
  if (current_token != 0 && EOF_Reached == 0 && (msg = error_token_from_token (current_token)))
    {
      if (ansic_shouldquote (msg))
	{
	  p = ansic_quote (msg, 0, NULL);
	  free (msg);
	  msg = p;
	}
      parser_error (line_number, _("syntax error near unexpected token `%s'"), msg);
      free (msg);

      if (interactive == 0)
	print_offending_line ();

      last_command_exit_value = (executing_builtin && parse_and_execute_level) ? EX_BADSYNTAX : EX_BADUSAGE;
      set_pipestatus_from_exit (last_command_exit_value);
      return;
    }

  /* If looking at the current token doesn't prove fruitful, try to find the
     offending token by analyzing the text of the input line near the current
     input line index and report what we find. */
  if (shell_input_line && *shell_input_line)
    {
      msg = error_token_from_text ();
      if (msg)
	{
	  parser_error (line_number, _("syntax error near `%s'"), msg);
	  free (msg);
	}

      /* If not interactive, print the line containing the error. */
      if (interactive == 0)
        print_offending_line ();
    }
  else
    {
      msg = EOF_Reached ? _("syntax error: unexpected end of file") : _("syntax error");
      parser_error (line_number, "%s", msg);
      /* When the shell is interactive, this file uses EOF_Reached
	 only for error reporting.  Other mechanisms are used to
	 decide whether or not to exit. */
      if (interactive && EOF_Reached)
	EOF_Reached = 0;
    }

  last_command_exit_value = (executing_builtin && parse_and_execute_level) ? EX_BADSYNTAX : EX_BADUSAGE;
  set_pipestatus_from_exit (last_command_exit_value);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\y.tab.c:8,606
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\y.tab.c:8,678
parsing error 
{
}
warning: parse error {
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\y.tab.c:8,680
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\y.tab.c:8,762
parsing error 
{
  WORD_LIST *wl;
  int tok, orig_current_token, orig_line_number, orig_input_terminator;
  int orig_line_count;
  int old_echo_input, old_expand_aliases, ea;
#if defined (HISTORY)
  int old_remember_on_history, old_history_expansion_inhibited;
#endif

#if defined (HISTORY)
  old_remember_on_history = remember_on_history;
#  if defined (BANG_HISTORY)
  old_history_expansion_inhibited = history_expansion_inhibited;
#  endif
  bash_history_disable ();
#endif

  orig_line_number = line_number;
  orig_line_count = current_command_line_count;
  orig_input_terminator = shell_input_line_terminator;
  old_echo_input = echo_input_at_read;
  old_expand_aliases = expand_aliases;

  push_stream (1);
#if 0 /* TAG: bash-5.2 Alex fxmbsw7 Ratchev <fxmbsw7@gmail.com> 11/17/2020 */
  if (ea = expanding_alias ())
    parser_save_alias ();
#endif
  last_read_token = WORD;		/* WORD to allow reserved words here */
  current_command_line_count = 0;
  echo_input_at_read = expand_aliases = 0;

  with_input_from_string (s, whom);
  wl = (WORD_LIST *)NULL;

  if (flags & 1)
    parser_state |= PST_COMPASSIGN|PST_REPARSE;

  while ((tok = read_token (READ)) != yacc_EOF)
    {
      if (tok == '\n' && *bash_input.location.string == '\0')
	break;
      if (tok == '\n')		/* Allow newlines in compound assignments */
	continue;
      if (tok != WORD && tok != ASSIGNMENT_WORD)
	{
	  line_number = orig_line_number + line_number - 1;
	  orig_current_token = current_token;
	  current_token = tok;
	  yyerror (NULL);	/* does the right thing */
	  current_token = orig_current_token;
	  if (wl)
	    dispose_words (wl);
	  wl = &parse_string_error;
	  break;
	}
      wl = make_word_list (yylval.word, wl);
    }
  
  last_read_token = '\n';
  pop_stream ();

#if 0 /* TAG: bash-5.2 */
  if (ea)
    parser_restore_alias ();
#endif

#if defined (HISTORY)
  remember_on_history = old_remember_on_history;
#  if defined (BANG_HISTORY)
  history_expansion_inhibited = old_history_expansion_inhibited;
#  endif /* BANG_HISTORY */
#endif /* HISTORY */

  echo_input_at_read = old_echo_input;
  expand_aliases = old_expand_aliases;

  current_command_line_count = orig_line_count;
  shell_input_line_terminator = orig_input_terminator;

  if (flags & 1)
    parser_state &= ~(PST_COMPASSIGN|PST_REPARSE);

  if (wl == &parse_string_error)
    {
      set_exit_status (EXECUTION_FAILURE);
      if (interactive_shell == 0 && posixly_correct)
	jump_to_top_level (FORCE_EOF);
      else
	jump_to_top_level (DISCARD);
    }

  return (REVERSE_LIST (wl, WORD_LIST *));
}
warning: parse error {
  WORD_LIST *wl;
  int tok, orig_current_token, orig_line_number, orig_input_terminator;
  int orig_line_count;
  int old_echo_input, old_expand_aliases, ea;
#if defined (HISTORY)
  int old_remember_on_history, old_history_expansion_inhibited;
#endif

#if defined (HISTORY)
  old_remember_on_history = remember_on_history;
#  if defined (BANG_HISTORY)
  old_history_expansion_inhibited = history_expansion_inhibited;
#  endif
  bash_history_disable ();
#endif

  orig_line_number = line_number;
  orig_line_count = current_command_line_count;
  orig_input_terminator = shell_input_line_terminator;
  old_echo_input = echo_input_at_read;
  old_expand_aliases = expand_aliases;

  push_stream (1);
#if 0 /* TAG: bash-5.2 Alex fxmbsw7 Ratchev <fxmbsw7@gmail.com> 11/17/2020 */
  if (ea = expanding_alias ())
    parser_save_alias ();
#endif
  last_read_token = WORD;		/* WORD to allow reserved words here */
  current_command_line_count = 0;
  echo_input_at_read = expand_aliases = 0;

  with_input_from_string (s, whom);
  wl = (WORD_LIST *)NULL;

  if (flags & 1)
    parser_state |= PST_COMPASSIGN|PST_REPARSE;

  while ((tok = read_token (READ)) != yacc_EOF)
    {
      if (tok == '\n' && *bash_input.location.string == '\0')
	break;
      if (tok == '\n')		/* Allow newlines in compound assignments */
	continue;
      if (tok != WORD && tok != ASSIGNMENT_WORD)
	{
	  line_number = orig_line_number + line_number - 1;
	  orig_current_token = current_token;
	  current_token = tok;
	  yyerror (NULL);	/* does the right thing */
	  current_token = orig_current_token;
	  if (wl)
	    dispose_words (wl);
	  wl = &parse_string_error;
	  break;
	}
      wl = make_word_list (yylval.word, wl);
    }
  
  last_read_token = '\n';
  pop_stream ();

#if 0 /* TAG: bash-5.2 */
  if (ea)
    parser_restore_alias ();
#endif

#if defined (HISTORY)
  remember_on_history = old_remember_on_history;
#  if defined (BANG_HISTORY)
  history_expansion_inhibited = old_history_expansion_inhibited;
#  endif /* BANG_HISTORY */
#endif /* HISTORY */

  echo_input_at_read = old_echo_input;
  expand_aliases = old_expand_aliases;

  current_command_line_count = orig_line_count;
  shell_input_line_terminator = orig_input_terminator;

  if (flags & 1)
    parser_state &= ~(PST_COMPASSIGN|PST_REPARSE);

  if (wl == &parse_string_error)
    {
      set_exit_status (EXECUTION_FAILURE);
      if (interactive_shell == 0 && posixly_correct)
	jump_to_top_level (FORCE_EOF);
      else
	jump_to_top_level (DISCARD);
    }

  return (REVERSE_LIST (wl, WORD_LIST *));
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\y.tab.c:8,766
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\y.tab.c:8,862
parsing error 
{
  WORD_LIST *wl, *rl;
  int tok, orig_line_number, orig_token_size, orig_last_token, assignok;
  char *saved_token, *ret;

  saved_token = token;
  orig_token_size = token_buffer_size;
  orig_line_number = line_number;
  orig_last_token = last_read_token;

  last_read_token = WORD;	/* WORD to allow reserved words here */

  token = (char *)NULL;
  token_buffer_size = 0;

  assignok = parser_state&PST_ASSIGNOK;		/* XXX */

  wl = (WORD_LIST *)NULL;	/* ( */
  parser_state |= PST_COMPASSIGN;

  while ((tok = read_token (READ)) != ')')
    {
      if (tok == '\n')			/* Allow newlines in compound assignments */
	{
	  if (SHOULD_PROMPT ())
	    prompt_again ();
	  continue;
	}
      if (tok != WORD && tok != ASSIGNMENT_WORD)
	{
	  current_token = tok;	/* for error reporting */
	  if (tok == yacc_EOF)	/* ( */
	    parser_error (orig_line_number, _("unexpected EOF while looking for matching `)'"));
	  else
	    yyerror(NULL);	/* does the right thing */
	  if (wl)
	    dispose_words (wl);
	  wl = &parse_string_error;
	  break;
	}
      wl = make_word_list (yylval.word, wl);
    }

  FREE (token);
  token = saved_token;
  token_buffer_size = orig_token_size;

  parser_state &= ~PST_COMPASSIGN;

  if (wl == &parse_string_error)
    {
      set_exit_status (EXECUTION_FAILURE);
      last_read_token = '\n';	/* XXX */
      if (interactive_shell == 0 && posixly_correct)
	jump_to_top_level (FORCE_EOF);
      else
	jump_to_top_level (DISCARD);
    }

  last_read_token = orig_last_token;		/* XXX - was WORD? */

  if (wl)
    {
      rl = REVERSE_LIST (wl, WORD_LIST *);
      ret = string_list (rl);
      dispose_words (rl);
    }
  else
    ret = (char *)NULL;

  if (retlenp)
    *retlenp = (ret && *ret) ? strlen (ret) : 0;

  if (assignok)
    parser_state |= PST_ASSIGNOK;

  return ret;
}
warning: parse error {
  WORD_LIST *wl, *rl;
  int tok, orig_line_number, orig_token_size, orig_last_token, assignok;
  char *saved_token, *ret;

  saved_token = token;
  orig_token_size = token_buffer_size;
  orig_line_number = line_number;
  orig_last_token = last_read_token;

  last_read_token = WORD;	/* WORD to allow reserved words here */

  token = (char *)NULL;
  token_buffer_size = 0;

  assignok = parser_state&PST_ASSIGNOK;		/* XXX */

  wl = (WORD_LIST *)NULL;	/* ( */
  parser_state |= PST_COMPASSIGN;

  while ((tok = read_token (READ)) != ')')
    {
      if (tok == '\n')			/* Allow newlines in compound assignments */
	{
	  if (SHOULD_PROMPT ())
	    prompt_again ();
	  continue;
	}
      if (tok != WORD && tok != ASSIGNMENT_WORD)
	{
	  current_token = tok;	/* for error reporting */
	  if (tok == yacc_EOF)	/* ( */
	    parser_error (orig_line_number, _("unexpected EOF while looking for matching `)'"));
	  else
	    yyerror(NULL);	/* does the right thing */
	  if (wl)
	    dispose_words (wl);
	  wl = &parse_string_error;
	  break;
	}
      wl = make_word_list (yylval.word, wl);
    }

  FREE (token);
  token = saved_token;
  token_buffer_size = orig_token_size;

  parser_state &= ~PST_COMPASSIGN;

  if (wl == &parse_string_error)
    {
      set_exit_status (EXECUTION_FAILURE);
      last_read_token = '\n';	/* XXX */
      if (interactive_shell == 0 && posixly_correct)
	jump_to_top_level (FORCE_EOF);
      else
	jump_to_top_level (DISCARD);
    }

  last_read_token = orig_last_token;		/* XXX - was WORD? */

  if (wl)
    {
      rl = REVERSE_LIST (wl, WORD_LIST *);
      ret = string_list (rl);
      dispose_words (rl);
    }
  else
    ret = (char *)NULL;

  if (retlenp)
    *retlenp = (ret && *ret) ? strlen (ret) : 0;

  if (assignok)
    parser_state |= PST_ASSIGNOK;

  return ret;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\y.tab.c:8,864
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\y.tab.c:8,950
parsing error 
{
  if (ps == 0)
    ps = (sh_parser_state_t *)xmalloc (sizeof (sh_parser_state_t));
  if (ps == 0)
    return ((sh_parser_state_t *)NULL);

  ps->parser_state = parser_state;
  ps->token_state = save_token_state ();

  ps->input_line_terminator = shell_input_line_terminator;
  ps->eof_encountered = eof_encountered;

  ps->prompt_string_pointer = prompt_string_pointer;

  ps->current_command_line_count = current_command_line_count;

#if defined (HISTORY)
  ps->remember_on_history = remember_on_history;
#  if defined (BANG_HISTORY)
  ps->history_expansion_inhibited = history_expansion_inhibited;
#  endif
#endif

  ps->last_command_exit_value = last_command_exit_value;
#if defined (ARRAY_VARS)
  ps->pipestatus = save_pipestatus_array ();
#endif
    
  ps->last_shell_builtin = last_shell_builtin;
  ps->this_shell_builtin = this_shell_builtin;

  ps->expand_aliases = expand_aliases;
  ps->echo_input_at_read = echo_input_at_read;
  ps->need_here_doc = need_here_doc;
  ps->here_doc_first_line = here_doc_first_line;

  if (need_here_doc == 0)
    ps->redir_stack[0] = 0;
  else
    memcpy (ps->redir_stack, redir_stack, sizeof (redir_stack[0]) * HEREDOC_MAX);

  ps->token = token;
  ps->token_buffer_size = token_buffer_size;
  /* Force reallocation on next call to read_token_word */
  token = 0;
  token_buffer_size = 0;

  return (ps);
}
warning: parse error {
  if (ps == 0)
    ps = (sh_parser_state_t *)xmalloc (sizeof (sh_parser_state_t));
  if (ps == 0)
    return ((sh_parser_state_t *)NULL);

  ps->parser_state = parser_state;
  ps->token_state = save_token_state ();

  ps->input_line_terminator = shell_input_line_terminator;
  ps->eof_encountered = eof_encountered;

  ps->prompt_string_pointer = prompt_string_pointer;

  ps->current_command_line_count = current_command_line_count;

#if defined (HISTORY)
  ps->remember_on_history = remember_on_history;
#  if defined (BANG_HISTORY)
  ps->history_expansion_inhibited = history_expansion_inhibited;
#  endif
#endif

  ps->last_command_exit_value = last_command_exit_value;
#if defined (ARRAY_VARS)
  ps->pipestatus = save_pipestatus_array ();
#endif
    
  ps->last_shell_builtin = last_shell_builtin;
  ps->this_shell_builtin = this_shell_builtin;

  ps->expand_aliases = expand_aliases;
  ps->echo_input_at_read = echo_input_at_read;
  ps->need_here_doc = need_here_doc;
  ps->here_doc_first_line = here_doc_first_line;

  if (need_here_doc == 0)
    ps->redir_stack[0] = 0;
  else
    memcpy (ps->redir_stack, redir_stack, sizeof (redir_stack[0]) * HEREDOC_MAX);

  ps->token = token;
  ps->token_buffer_size = token_buffer_size;
  /* Force reallocation on next call to read_token_word */
  token = 0;
  token_buffer_size = 0;

  return (ps);
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\y.tab.c:8,952
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\y.tab.c:9,003
parsing error 
{
  int i;

  if (ps == 0)
    return;

  parser_state = ps->parser_state;
  if (ps->token_state)
    {
      restore_token_state (ps->token_state);
      free (ps->token_state);
    }

  shell_input_line_terminator = ps->input_line_terminator;
  eof_encountered = ps->eof_encountered;

  prompt_string_pointer = ps->prompt_string_pointer;

  current_command_line_count = ps->current_command_line_count;

#if defined (HISTORY)
  remember_on_history = ps->remember_on_history;
#  if defined (BANG_HISTORY)
  history_expansion_inhibited = ps->history_expansion_inhibited;
#  endif
#endif

  last_command_exit_value = ps->last_command_exit_value;
#if defined (ARRAY_VARS)
  restore_pipestatus_array (ps->pipestatus);
#endif

  last_shell_builtin = ps->last_shell_builtin;
  this_shell_builtin = ps->this_shell_builtin;

  expand_aliases = ps->expand_aliases;
  echo_input_at_read = ps->echo_input_at_read;
  need_here_doc = ps->need_here_doc;
  here_doc_first_line = ps->here_doc_first_line;

#if 0
  for (i = 0; i < HEREDOC_MAX; i++)
    redir_stack[i] = ps->redir_stack[i];
#else
  if (need_here_doc == 0)
    redir_stack[0] = 0;
  else
    memcpy (redir_stack, ps->redir_stack, sizeof (redir_stack[0]) * HEREDOC_MAX);
#endif

  FREE (token);
  token = ps->token;
  token_buffer_size = ps->token_buffer_size;
}
warning: parse error {
  int i;

  if (ps == 0)
    return;

  parser_state = ps->parser_state;
  if (ps->token_state)
    {
      restore_token_state (ps->token_state);
      free (ps->token_state);
    }

  shell_input_line_terminator = ps->input_line_terminator;
  eof_encountered = ps->eof_encountered;

  prompt_string_pointer = ps->prompt_string_pointer;

  current_command_line_count = ps->current_command_line_count;

#if defined (HISTORY)
  remember_on_history = ps->remember_on_history;
#  if defined (BANG_HISTORY)
  history_expansion_inhibited = ps->history_expansion_inhibited;
#  endif
#endif

  last_command_exit_value = ps->last_command_exit_value;
#if defined (ARRAY_VARS)
  restore_pipestatus_array (ps->pipestatus);
#endif

  last_shell_builtin = ps->last_shell_builtin;
  this_shell_builtin = ps->this_shell_builtin;

  expand_aliases = ps->expand_aliases;
  echo_input_at_read = ps->echo_input_at_read;
  need_here_doc = ps->need_here_doc;
  here_doc_first_line = ps->here_doc_first_line;

#if 0
  for (i = 0; i < HEREDOC_MAX; i++)
    redir_stack[i] = ps->redir_stack[i];
#else
  if (need_here_doc == 0)
    redir_stack[0] = 0;
  else
    memcpy (redir_stack, ps->redir_stack, sizeof (redir_stack[0]) * HEREDOC_MAX);
#endif

  FREE (token);
  token = ps->token;
  token_buffer_size = ps->token_buffer_size;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\y.tab.c:9,005
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\y.tab.c:9,061
parsing error 
{
  if (ls == 0)
    ls = (sh_input_line_state_t *)xmalloc (sizeof (sh_input_line_state_t));
  if (ls == 0)
    return ((sh_input_line_state_t *)NULL);

  ls->input_line = shell_input_line;
  ls->input_line_size = shell_input_line_size;
  ls->input_line_len = shell_input_line_len;
  ls->input_line_index = shell_input_line_index;

#if defined (HANDLE_MULTIBYTE)
  ls->input_property = shell_input_line_property;
  ls->input_propsize = shell_input_line_propsize;
#endif

  /* force reallocation */
  shell_input_line = 0;
  shell_input_line_size = shell_input_line_len = shell_input_line_index = 0;

#if defined (HANDLE_MULTIBYTE)
  shell_input_line_property = 0;
  shell_input_line_propsize = 0;
#endif

  return ls;
}
warning: parse error {
  if (ls == 0)
    ls = (sh_input_line_state_t *)xmalloc (sizeof (sh_input_line_state_t));
  if (ls == 0)
    return ((sh_input_line_state_t *)NULL);

  ls->input_line = shell_input_line;
  ls->input_line_size = shell_input_line_size;
  ls->input_line_len = shell_input_line_len;
  ls->input_line_index = shell_input_line_index;

#if defined (HANDLE_MULTIBYTE)
  ls->input_property = shell_input_line_property;
  ls->input_propsize = shell_input_line_propsize;
#endif

  /* force reallocation */
  shell_input_line = 0;
  shell_input_line_size = shell_input_line_len = shell_input_line_index = 0;

#if defined (HANDLE_MULTIBYTE)
  shell_input_line_property = 0;
  shell_input_line_propsize = 0;
#endif

  return ls;
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\y.tab.c:9,063
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\y.tab.c:9,092
parsing error 
{
  FREE (shell_input_line);
  shell_input_line = ls->input_line;
  shell_input_line_size = ls->input_line_size;
  shell_input_line_len = ls->input_line_len;
  shell_input_line_index = ls->input_line_index;

#if defined (HANDLE_MULTIBYTE)
  FREE (shell_input_line_property);
  shell_input_line_property = ls->input_property;
  shell_input_line_propsize = ls->input_propsize;
#endif

#if 0
  set_line_mbstate ();
#endif
}
warning: parse error {
  FREE (shell_input_line);
  shell_input_line = ls->input_line;
  shell_input_line_size = ls->input_line_size;
  shell_input_line_len = ls->input_line_len;
  shell_input_line_index = ls->input_line_index;

#if defined (HANDLE_MULTIBYTE)
  FREE (shell_input_line_property);
  shell_input_line_property = ls->input_property;
  shell_input_line_propsize = ls->input_propsize;
#endif

#if 0
  set_line_mbstate ();
#endif
}Syntax error in file: E:\XJTU\架构逆向\lda_demoGPT\local\data\bash-5.1\y.tab.c:9,094
all files procceed successfully...
Resolve types and bindings of variables, methods and expressions....
Resolve type bindings....
Dependency analaysing....
types and bindings resolved successfully...
Dependency done....
dependencie data generating...
Start create dependencies matrix....
Finish create dependencies matrix....
reorder dependency matrix...
Dependencies data generating done successfully...
Consumed time: 27.781 s,  or 0.46301666 min.
