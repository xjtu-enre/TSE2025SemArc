Start parsing files...
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\alias.c...
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\chartypes.h...
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\bashansi.h...
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\command.h...
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\stdc.h...
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\general.h...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\stdc.h...skip
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\bashtypes.h...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\chartypes.h...skip
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\xmalloc.h...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\stdc.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\bashansi.h...skip
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\externs.h...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\stdc.h...skip
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\alias.h...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\stdc.h...skip
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\hashlib.h...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\stdc.h...skip
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\array.c...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\bashansi.h...skip
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\shell.h...
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\bashjmp.h...
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\posixjmp.h...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\command.h...skip
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\syntax.h...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\general.h...skip
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\error.h...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\stdc.h...skip
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.h...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\stdc.h...skip
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\array.h...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\stdc.h...skip
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\assoc.h...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\stdc.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\hashlib.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\hashlib.h...skip
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\conftypes.h...
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\arrayfunc.h...
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\quit.h...
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\maxpath.h...
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\unwind_prot.h...
parsing error 
extern void begin_unwind_frame __P((char *));
warning: parse error extern void begin_unwind_frame __P((char *));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\unwind_prot.h:25
parsing error 
extern void discard_unwind_frame __P((char *));
warning: parse error extern void discard_unwind_frame __P((char *));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\unwind_prot.h:26
parsing error 
extern void run_unwind_frame __P((char *));
warning: parse error extern void run_unwind_frame __P((char *));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\unwind_prot.h:27
parsing error 
extern void remove_unwind_protect __P((void));
warning: parse error extern void remove_unwind_protect __P((void));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\unwind_prot.h:29
parsing error 
extern void run_unwind_protects __P((void));
warning: parse error extern void run_unwind_protects __P((void));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\unwind_prot.h:30
parsing error 
extern void clear_unwind_protect_list __P((int));
warning: parse error extern void clear_unwind_protect_list __P((int));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\unwind_prot.h:31
parsing error 
extern int have_unwind_protects __P((void));
warning: parse error extern int have_unwind_protects __P((void));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\unwind_prot.h:32
parsing error 
extern void uwp_init __P((void));
warning: parse error extern void uwp_init __P((void));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\unwind_prot.h:33
parsing error 
extern void unwind_protect_mem __P((char *, int));
warning: parse error extern void unwind_protect_mem __P((char *, int));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\unwind_prot.h:40
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\dispose_cmd.h...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\stdc.h...skip
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\make_cmd.h...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\stdc.h...skip
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\ocache.h...
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\subst.h...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\stdc.h...skip
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\sig.h...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\stdc.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\externs.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\array.h...skip
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\common.h...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\stdc.h...skip
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\arrayfunc.c...
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\bashintl.h...
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\gettext.h...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\shell.h...skip
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\pathexp.h...
parsing error 
extern int unquoted_glob_pattern_p __P((char *));
warning: parse error extern int unquoted_glob_pattern_p __P((char *));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\pathexp.h:52
parsing error 
extern char *quote_string_for_globbing __P((const char *, int));
warning: parse error extern char *quote_string_for_globbing __P((const char *, int));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\pathexp.h:64
parsing error 
extern int glob_char_p __P((const char *));
warning: parse error extern int glob_char_p __P((const char *));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\pathexp.h:66
parsing error 
extern char *quote_globbing_chars __P((char *));
warning: parse error extern char *quote_globbing_chars __P((char *));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\pathexp.h:67
parsing error 
extern char **shell_glob_filename __P((const char *));
warning: parse error extern char **shell_glob_filename __P((const char *));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\pathexp.h:70
parsing error 
typedef int sh_iv_item_func_t __P((struct ign *));
warning: parse error typedef int sh_iv_item_func_t __P((struct ign *));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\pathexp.h:86
parsing error 
extern void setup_ignore_patterns __P((struct ignorevar *));
warning: parse error extern void setup_ignore_patterns __P((struct ignorevar *));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\pathexp.h:96
parsing error 
extern void setup_glob_ignore __P((char *));
warning: parse error extern void setup_glob_ignore __P((char *));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\pathexp.h:98
parsing error 
extern int should_ignore_glob_matches __P((void));
warning: parse error extern int should_ignore_glob_matches __P((void));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\pathexp.h:99
parsing error 
extern void ignore_glob_matches __P((char **));
warning: parse error extern void ignore_glob_matches __P((char **));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\pathexp.h:100
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\shmbutil.h...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\stdc.h...skip
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\shmbchar.h...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\common.h...skip
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\assoc.c...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\bashansi.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\shell.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\array.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\assoc.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\common.h...skip
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\bashhist.c...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\bashtypes.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\bashansi.h...skip
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\posixstat.h...
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\filecntl.h...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\bashintl.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\shell.h...skip
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\flags.h...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\stdc.h...skip
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\input.h...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\stdc.h...skip
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\parser.h...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\pathexp.h...skip
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\bashhist.h...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\stdc.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\common.h...skip
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\history.h...
parsing error 
extern void using_history PARAMS((void));
warning: parse error extern void using_history PARAMS((void));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\history.h:71
parsing error 
extern HISTORY_STATE *history_get_history_state PARAMS((void));
warning: parse error extern HISTORY_STATE *history_get_history_state PARAMS((void));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\history.h:74
parsing error 
extern void history_set_history_state PARAMS((HISTORY_STATE *));
warning: parse error extern void history_set_history_state PARAMS((HISTORY_STATE *));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\history.h:77
parsing error 
extern void add_history PARAMS((const char *));
warning: parse error extern void add_history PARAMS((const char *));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\history.h:83
parsing error 
extern void add_history_time PARAMS((const char *));
warning: parse error extern void add_history_time PARAMS((const char *));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\history.h:87
parsing error 
extern HIST_ENTRY *remove_history PARAMS((int));
warning: parse error extern HIST_ENTRY *remove_history PARAMS((int));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\history.h:92
parsing error 
extern histdata_t free_history_entry PARAMS((HIST_ENTRY *));
warning: parse error extern histdata_t free_history_entry PARAMS((HIST_ENTRY *));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\history.h:96
parsing error 
extern HIST_ENTRY *replace_history_entry PARAMS((int, const char *, histdata_t));
warning: parse error extern HIST_ENTRY *replace_history_entry PARAMS((int, const char *, histdata_t));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\history.h:101
parsing error 
extern void clear_history PARAMS((void));
warning: parse error extern void clear_history PARAMS((void));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\history.h:104
parsing error 
extern void stifle_history PARAMS((int));
warning: parse error extern void stifle_history PARAMS((int));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\history.h:107
parsing error 
extern int unstifle_history PARAMS((void));
warning: parse error extern int unstifle_history PARAMS((void));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\history.h:112
parsing error 
extern int history_is_stifled PARAMS((void));
warning: parse error extern int history_is_stifled PARAMS((void));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\history.h:115
parsing error 
extern HIST_ENTRY **history_list PARAMS((void));
warning: parse error extern HIST_ENTRY **history_list PARAMS((void));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\history.h:122
parsing error 
extern int where_history PARAMS((void));
warning: parse error extern int where_history PARAMS((void));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\history.h:126
parsing error 
extern HIST_ENTRY *current_history PARAMS((void));
warning: parse error extern HIST_ENTRY *current_history PARAMS((void));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\history.h:130
parsing error 
extern HIST_ENTRY *history_get PARAMS((int));
warning: parse error extern HIST_ENTRY *history_get PARAMS((int));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\history.h:134
parsing error 
extern time_t history_get_time PARAMS((HIST_ENTRY *));
warning: parse error extern time_t history_get_time PARAMS((HIST_ENTRY *));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\history.h:138
parsing error 
extern int history_total_bytes PARAMS((void));
warning: parse error extern int history_total_bytes PARAMS((void));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\history.h:142
parsing error 
extern int history_set_pos PARAMS((int));
warning: parse error extern int history_set_pos PARAMS((int));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\history.h:147
parsing error 
extern HIST_ENTRY *previous_history PARAMS((void));
warning: parse error extern HIST_ENTRY *previous_history PARAMS((void));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\history.h:152
parsing error 
extern HIST_ENTRY *next_history PARAMS((void));
warning: parse error extern HIST_ENTRY *next_history PARAMS((void));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\history.h:157
parsing error 
extern int history_search PARAMS((const char *, int));
warning: parse error extern int history_search PARAMS((const char *, int));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\history.h:167
parsing error 
extern int history_search_prefix PARAMS((const char *, int));
warning: parse error extern int history_search_prefix PARAMS((const char *, int));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\history.h:172
parsing error 
extern int history_search_pos PARAMS((const char *, int, int));
warning: parse error extern int history_search_pos PARAMS((const char *, int, int));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\history.h:179
parsing error 
extern int read_history PARAMS((const char *));
warning: parse error extern int read_history PARAMS((const char *));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\history.h:186
parsing error 
extern int read_history_range PARAMS((const char *, int, int));
warning: parse error extern int read_history_range PARAMS((const char *, int, int));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\history.h:193
parsing error 
extern int write_history PARAMS((const char *));
warning: parse error extern int write_history PARAMS((const char *));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\history.h:198
parsing error 
extern int append_history PARAMS((int, const char *));
warning: parse error extern int append_history PARAMS((int, const char *));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\history.h:202
parsing error 
extern int history_truncate_file PARAMS((const char *, int));
warning: parse error extern int history_truncate_file PARAMS((const char *, int));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\history.h:205
parsing error 
extern int history_expand PARAMS((char *, char **));
warning: parse error extern int history_expand PARAMS((char *, char **));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\history.h:221
parsing error 
extern char *history_arg_extract PARAMS((int, int, const char *));
warning: parse error extern char *history_arg_extract PARAMS((int, int, const char *));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\history.h:226
parsing error 
extern char *get_history_event PARAMS((const char *, int *, int));
warning: parse error extern char *get_history_event PARAMS((const char *, int *, int));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\history.h:234
parsing error 
extern char **history_tokenize PARAMS((const char *));
warning: parse error extern char **history_tokenize PARAMS((const char *));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\history.h:238
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\glob\glob.h...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\stdc.h...skip
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\glob\strmatch.h...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\stdc.h...skip
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\bashline.c...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\bashtypes.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\posixstat.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\chartypes.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\bashansi.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\bashintl.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\shell.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\input.h...skip
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins.h...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\command.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\general.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\alias.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\bashhist.h...skip
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\bashline.h...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\stdc.h...skip
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\execute_cmd.h...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\stdc.h...skip
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\findcmd.h...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\stdc.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\pathexp.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\shmbutil.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\common.h...skip
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\rlconf.h...
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h...
parsing error 
extern int rl_digit_argument PARAMS((int, int));
warning: parse error extern int rl_digit_argument PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:82
parsing error 
extern int rl_universal_argument PARAMS((int, int));
warning: parse error extern int rl_universal_argument PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:83
parsing error 
extern int rl_forward_byte PARAMS((int, int));
warning: parse error extern int rl_forward_byte PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:86
parsing error 
extern int rl_forward_char PARAMS((int, int));
warning: parse error extern int rl_forward_char PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:87
parsing error 
extern int rl_forward PARAMS((int, int));
warning: parse error extern int rl_forward PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:88
parsing error 
extern int rl_backward_byte PARAMS((int, int));
warning: parse error extern int rl_backward_byte PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:89
parsing error 
extern int rl_backward_char PARAMS((int, int));
warning: parse error extern int rl_backward_char PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:90
parsing error 
extern int rl_backward PARAMS((int, int));
warning: parse error extern int rl_backward PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:91
parsing error 
extern int rl_beg_of_line PARAMS((int, int));
warning: parse error extern int rl_beg_of_line PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:92
parsing error 
extern int rl_end_of_line PARAMS((int, int));
warning: parse error extern int rl_end_of_line PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:93
parsing error 
extern int rl_forward_word PARAMS((int, int));
warning: parse error extern int rl_forward_word PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:94
parsing error 
extern int rl_backward_word PARAMS((int, int));
warning: parse error extern int rl_backward_word PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:95
parsing error 
extern int rl_refresh_line PARAMS((int, int));
warning: parse error extern int rl_refresh_line PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:96
parsing error 
extern int rl_clear_screen PARAMS((int, int));
warning: parse error extern int rl_clear_screen PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:97
parsing error 
extern int rl_skip_csi_sequence PARAMS((int, int));
warning: parse error extern int rl_skip_csi_sequence PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:98
parsing error 
extern int rl_arrow_keys PARAMS((int, int));
warning: parse error extern int rl_arrow_keys PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:99
parsing error 
extern int rl_insert PARAMS((int, int));
warning: parse error extern int rl_insert PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:102
parsing error 
extern int rl_quoted_insert PARAMS((int, int));
warning: parse error extern int rl_quoted_insert PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:103
parsing error 
extern int rl_tab_insert PARAMS((int, int));
warning: parse error extern int rl_tab_insert PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:104
parsing error 
extern int rl_newline PARAMS((int, int));
warning: parse error extern int rl_newline PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:105
parsing error 
extern int rl_do_lowercase_version PARAMS((int, int));
warning: parse error extern int rl_do_lowercase_version PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:106
parsing error 
extern int rl_rubout PARAMS((int, int));
warning: parse error extern int rl_rubout PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:107
parsing error 
extern int rl_delete PARAMS((int, int));
warning: parse error extern int rl_delete PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:108
parsing error 
extern int rl_rubout_or_delete PARAMS((int, int));
warning: parse error extern int rl_rubout_or_delete PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:109
parsing error 
extern int rl_delete_horizontal_space PARAMS((int, int));
warning: parse error extern int rl_delete_horizontal_space PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:110
parsing error 
extern int rl_delete_or_show_completions PARAMS((int, int));
warning: parse error extern int rl_delete_or_show_completions PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:111
parsing error 
extern int rl_insert_comment PARAMS((int, int));
warning: parse error extern int rl_insert_comment PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:112
parsing error 
extern int rl_upcase_word PARAMS((int, int));
warning: parse error extern int rl_upcase_word PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:115
parsing error 
extern int rl_downcase_word PARAMS((int, int));
warning: parse error extern int rl_downcase_word PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:116
parsing error 
extern int rl_capitalize_word PARAMS((int, int));
warning: parse error extern int rl_capitalize_word PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:117
parsing error 
extern int rl_transpose_words PARAMS((int, int));
warning: parse error extern int rl_transpose_words PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:120
parsing error 
extern int rl_transpose_chars PARAMS((int, int));
warning: parse error extern int rl_transpose_chars PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:121
parsing error 
extern int rl_char_search PARAMS((int, int));
warning: parse error extern int rl_char_search PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:124
parsing error 
extern int rl_backward_char_search PARAMS((int, int));
warning: parse error extern int rl_backward_char_search PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:125
parsing error 
extern int rl_beginning_of_history PARAMS((int, int));
warning: parse error extern int rl_beginning_of_history PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:128
parsing error 
extern int rl_end_of_history PARAMS((int, int));
warning: parse error extern int rl_end_of_history PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:129
parsing error 
extern int rl_get_next_history PARAMS((int, int));
warning: parse error extern int rl_get_next_history PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:130
parsing error 
extern int rl_get_previous_history PARAMS((int, int));
warning: parse error extern int rl_get_previous_history PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:131
parsing error 
extern int rl_set_mark PARAMS((int, int));
warning: parse error extern int rl_set_mark PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:134
parsing error 
extern int rl_exchange_point_and_mark PARAMS((int, int));
warning: parse error extern int rl_exchange_point_and_mark PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:135
parsing error 
extern int rl_vi_editing_mode PARAMS((int, int));
warning: parse error extern int rl_vi_editing_mode PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:138
parsing error 
extern int rl_emacs_editing_mode PARAMS((int, int));
warning: parse error extern int rl_emacs_editing_mode PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:139
parsing error 
extern int rl_overwrite_mode PARAMS((int, int));
warning: parse error extern int rl_overwrite_mode PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:142
parsing error 
extern int rl_re_read_init_file PARAMS((int, int));
warning: parse error extern int rl_re_read_init_file PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:145
parsing error 
extern int rl_dump_functions PARAMS((int, int));
warning: parse error extern int rl_dump_functions PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:146
parsing error 
extern int rl_dump_macros PARAMS((int, int));
warning: parse error extern int rl_dump_macros PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:147
parsing error 
extern int rl_dump_variables PARAMS((int, int));
warning: parse error extern int rl_dump_variables PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:148
parsing error 
extern int rl_complete PARAMS((int, int));
warning: parse error extern int rl_complete PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:151
parsing error 
extern int rl_possible_completions PARAMS((int, int));
warning: parse error extern int rl_possible_completions PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:152
parsing error 
extern int rl_insert_completions PARAMS((int, int));
warning: parse error extern int rl_insert_completions PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:153
parsing error 
extern int rl_old_menu_complete PARAMS((int, int));
warning: parse error extern int rl_old_menu_complete PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:154
parsing error 
extern int rl_menu_complete PARAMS((int, int));
warning: parse error extern int rl_menu_complete PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:155
parsing error 
extern int rl_backward_menu_complete PARAMS((int, int));
warning: parse error extern int rl_backward_menu_complete PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:156
parsing error 
extern int rl_kill_word PARAMS((int, int));
warning: parse error extern int rl_kill_word PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:159
parsing error 
extern int rl_backward_kill_word PARAMS((int, int));
warning: parse error extern int rl_backward_kill_word PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:160
parsing error 
extern int rl_kill_line PARAMS((int, int));
warning: parse error extern int rl_kill_line PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:161
parsing error 
extern int rl_backward_kill_line PARAMS((int, int));
warning: parse error extern int rl_backward_kill_line PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:162
parsing error 
extern int rl_kill_full_line PARAMS((int, int));
warning: parse error extern int rl_kill_full_line PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:163
parsing error 
extern int rl_unix_word_rubout PARAMS((int, int));
warning: parse error extern int rl_unix_word_rubout PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:164
parsing error 
extern int rl_unix_filename_rubout PARAMS((int, int));
warning: parse error extern int rl_unix_filename_rubout PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:165
parsing error 
extern int rl_unix_line_discard PARAMS((int, int));
warning: parse error extern int rl_unix_line_discard PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:166
parsing error 
extern int rl_copy_region_to_kill PARAMS((int, int));
warning: parse error extern int rl_copy_region_to_kill PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:167
parsing error 
extern int rl_kill_region PARAMS((int, int));
warning: parse error extern int rl_kill_region PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:168
parsing error 
extern int rl_copy_forward_word PARAMS((int, int));
warning: parse error extern int rl_copy_forward_word PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:169
parsing error 
extern int rl_copy_backward_word PARAMS((int, int));
warning: parse error extern int rl_copy_backward_word PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:170
parsing error 
extern int rl_yank PARAMS((int, int));
warning: parse error extern int rl_yank PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:171
parsing error 
extern int rl_yank_pop PARAMS((int, int));
warning: parse error extern int rl_yank_pop PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:172
parsing error 
extern int rl_yank_nth_arg PARAMS((int, int));
warning: parse error extern int rl_yank_nth_arg PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:173
parsing error 
extern int rl_yank_last_arg PARAMS((int, int));
warning: parse error extern int rl_yank_last_arg PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:174
parsing error 
extern int rl_paste_from_clipboard PARAMS((int, int));
warning: parse error extern int rl_paste_from_clipboard PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:177
parsing error 
extern int rl_reverse_search_history PARAMS((int, int));
warning: parse error extern int rl_reverse_search_history PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:181
parsing error 
extern int rl_forward_search_history PARAMS((int, int));
warning: parse error extern int rl_forward_search_history PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:182
parsing error 
extern int rl_start_kbd_macro PARAMS((int, int));
warning: parse error extern int rl_start_kbd_macro PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:185
parsing error 
extern int rl_end_kbd_macro PARAMS((int, int));
warning: parse error extern int rl_end_kbd_macro PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:186
parsing error 
extern int rl_call_last_kbd_macro PARAMS((int, int));
warning: parse error extern int rl_call_last_kbd_macro PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:187
parsing error 
extern int rl_revert_line PARAMS((int, int));
warning: parse error extern int rl_revert_line PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:190
parsing error 
extern int rl_undo_command PARAMS((int, int));
warning: parse error extern int rl_undo_command PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:191
parsing error 
extern int rl_tilde_expand PARAMS((int, int));
warning: parse error extern int rl_tilde_expand PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:194
parsing error 
extern int rl_restart_output PARAMS((int, int));
warning: parse error extern int rl_restart_output PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:197
parsing error 
extern int rl_stop_output PARAMS((int, int));
warning: parse error extern int rl_stop_output PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:198
parsing error 
extern int rl_abort PARAMS((int, int));
warning: parse error extern int rl_abort PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:201
parsing error 
extern int rl_tty_status PARAMS((int, int));
warning: parse error extern int rl_tty_status PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:202
parsing error 
extern int rl_history_search_forward PARAMS((int, int));
warning: parse error extern int rl_history_search_forward PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:205
parsing error 
extern int rl_history_search_backward PARAMS((int, int));
warning: parse error extern int rl_history_search_backward PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:206
parsing error 
extern int rl_noninc_forward_search PARAMS((int, int));
warning: parse error extern int rl_noninc_forward_search PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:207
parsing error 
extern int rl_noninc_reverse_search PARAMS((int, int));
warning: parse error extern int rl_noninc_reverse_search PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:208
parsing error 
extern int rl_noninc_forward_search_again PARAMS((int, int));
warning: parse error extern int rl_noninc_forward_search_again PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:209
parsing error 
extern int rl_noninc_reverse_search_again PARAMS((int, int));
warning: parse error extern int rl_noninc_reverse_search_again PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:210
parsing error 
extern int rl_insert_close PARAMS((int, int));
warning: parse error extern int rl_insert_close PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:213
parsing error 
extern void rl_callback_handler_install PARAMS((const char *, rl_vcpfunc_t *));
warning: parse error extern void rl_callback_handler_install PARAMS((const char *, rl_vcpfunc_t *));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:216
parsing error 
extern void rl_callback_read_char PARAMS((void));
warning: parse error extern void rl_callback_read_char PARAMS((void));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:217
parsing error 
extern void rl_callback_handler_remove PARAMS((void));
warning: parse error extern void rl_callback_handler_remove PARAMS((void));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:218
parsing error 
extern int rl_vi_redo PARAMS((int, int));
warning: parse error extern int rl_vi_redo PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:222
parsing error 
extern int rl_vi_undo PARAMS((int, int));
warning: parse error extern int rl_vi_undo PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:223
parsing error 
extern int rl_vi_yank_arg PARAMS((int, int));
warning: parse error extern int rl_vi_yank_arg PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:224
parsing error 
extern int rl_vi_fetch_history PARAMS((int, int));
warning: parse error extern int rl_vi_fetch_history PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:225
parsing error 
extern int rl_vi_search_again PARAMS((int, int));
warning: parse error extern int rl_vi_search_again PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:226
parsing error 
extern int rl_vi_search PARAMS((int, int));
warning: parse error extern int rl_vi_search PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:227
parsing error 
extern int rl_vi_complete PARAMS((int, int));
warning: parse error extern int rl_vi_complete PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:228
parsing error 
extern int rl_vi_tilde_expand PARAMS((int, int));
warning: parse error extern int rl_vi_tilde_expand PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:229
parsing error 
extern int rl_vi_prev_word PARAMS((int, int));
warning: parse error extern int rl_vi_prev_word PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:230
parsing error 
extern int rl_vi_next_word PARAMS((int, int));
warning: parse error extern int rl_vi_next_word PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:231
parsing error 
extern int rl_vi_end_word PARAMS((int, int));
warning: parse error extern int rl_vi_end_word PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:232
parsing error 
extern int rl_vi_insert_beg PARAMS((int, int));
warning: parse error extern int rl_vi_insert_beg PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:233
parsing error 
extern int rl_vi_append_mode PARAMS((int, int));
warning: parse error extern int rl_vi_append_mode PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:234
parsing error 
extern int rl_vi_append_eol PARAMS((int, int));
warning: parse error extern int rl_vi_append_eol PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:235
parsing error 
extern int rl_vi_eof_maybe PARAMS((int, int));
warning: parse error extern int rl_vi_eof_maybe PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:236
parsing error 
extern int rl_vi_insertion_mode PARAMS((int, int));
warning: parse error extern int rl_vi_insertion_mode PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:237
parsing error 
extern int rl_vi_insert_mode PARAMS((int, int));
warning: parse error extern int rl_vi_insert_mode PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:238
parsing error 
extern int rl_vi_movement_mode PARAMS((int, int));
warning: parse error extern int rl_vi_movement_mode PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:239
parsing error 
extern int rl_vi_arg_digit PARAMS((int, int));
warning: parse error extern int rl_vi_arg_digit PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:240
parsing error 
extern int rl_vi_change_case PARAMS((int, int));
warning: parse error extern int rl_vi_change_case PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:241
parsing error 
extern int rl_vi_put PARAMS((int, int));
warning: parse error extern int rl_vi_put PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:242
parsing error 
extern int rl_vi_column PARAMS((int, int));
warning: parse error extern int rl_vi_column PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:243
parsing error 
extern int rl_vi_delete_to PARAMS((int, int));
warning: parse error extern int rl_vi_delete_to PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:244
parsing error 
extern int rl_vi_change_to PARAMS((int, int));
warning: parse error extern int rl_vi_change_to PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:245
parsing error 
extern int rl_vi_yank_to PARAMS((int, int));
warning: parse error extern int rl_vi_yank_to PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:246
parsing error 
extern int rl_vi_rubout PARAMS((int, int));
warning: parse error extern int rl_vi_rubout PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:247
parsing error 
extern int rl_vi_delete PARAMS((int, int));
warning: parse error extern int rl_vi_delete PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:248
parsing error 
extern int rl_vi_back_to_indent PARAMS((int, int));
warning: parse error extern int rl_vi_back_to_indent PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:249
parsing error 
extern int rl_vi_first_print PARAMS((int, int));
warning: parse error extern int rl_vi_first_print PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:250
parsing error 
extern int rl_vi_char_search PARAMS((int, int));
warning: parse error extern int rl_vi_char_search PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:251
parsing error 
extern int rl_vi_match PARAMS((int, int));
warning: parse error extern int rl_vi_match PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:252
parsing error 
extern int rl_vi_change_char PARAMS((int, int));
warning: parse error extern int rl_vi_change_char PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:253
parsing error 
extern int rl_vi_subst PARAMS((int, int));
warning: parse error extern int rl_vi_subst PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:254
parsing error 
extern int rl_vi_overstrike PARAMS((int, int));
warning: parse error extern int rl_vi_overstrike PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:255
parsing error 
extern int rl_vi_overstrike_delete PARAMS((int, int));
warning: parse error extern int rl_vi_overstrike_delete PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:256
parsing error 
extern int rl_vi_replace PARAMS((int, int));
warning: parse error extern int rl_vi_replace PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:257
parsing error 
extern int rl_vi_set_mark PARAMS((int, int));
warning: parse error extern int rl_vi_set_mark PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:258
parsing error 
extern int rl_vi_goto_mark PARAMS((int, int));
warning: parse error extern int rl_vi_goto_mark PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:259
parsing error 
extern int rl_vi_check PARAMS((void));
warning: parse error extern int rl_vi_check PARAMS((void));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:262
parsing error 
extern int rl_vi_domove PARAMS((int, int *));
warning: parse error extern int rl_vi_domove PARAMS((int, int *));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:263
parsing error 
extern int rl_vi_bracktype PARAMS((int));
warning: parse error extern int rl_vi_bracktype PARAMS((int));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:264
parsing error 
extern void rl_vi_start_inserting PARAMS((int, int, int));
warning: parse error extern void rl_vi_start_inserting PARAMS((int, int, int));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:266
parsing error 
extern int rl_vi_fWord PARAMS((int, int));
warning: parse error extern int rl_vi_fWord PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:269
parsing error 
extern int rl_vi_bWord PARAMS((int, int));
warning: parse error extern int rl_vi_bWord PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:270
parsing error 
extern int rl_vi_eWord PARAMS((int, int));
warning: parse error extern int rl_vi_eWord PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:271
parsing error 
extern int rl_vi_fword PARAMS((int, int));
warning: parse error extern int rl_vi_fword PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:272
parsing error 
extern int rl_vi_bword PARAMS((int, int));
warning: parse error extern int rl_vi_bword PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:273
parsing error 
extern int rl_vi_eword PARAMS((int, int));
warning: parse error extern int rl_vi_eword PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:274
parsing error 
extern char *readline PARAMS((const char *));
warning: parse error extern char *readline PARAMS((const char *));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:284
parsing error 
extern int rl_set_prompt PARAMS((const char *));
warning: parse error extern int rl_set_prompt PARAMS((const char *));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:286
parsing error 
extern int rl_expand_prompt PARAMS((char *));
warning: parse error extern int rl_expand_prompt PARAMS((char *));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:287
parsing error 
extern int rl_initialize PARAMS((void));
warning: parse error extern int rl_initialize PARAMS((void));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:289
parsing error 
extern int rl_discard_argument PARAMS((void));
warning: parse error extern int rl_discard_argument PARAMS((void));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:292
parsing error 
extern int rl_add_defun PARAMS((const char *, rl_command_func_t *, int));
warning: parse error extern int rl_add_defun PARAMS((const char *, rl_command_func_t *, int));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:295
parsing error 
extern int rl_bind_key PARAMS((int, rl_command_func_t *));
warning: parse error extern int rl_bind_key PARAMS((int, rl_command_func_t *));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:296
parsing error 
extern int rl_bind_key_in_map PARAMS((int, rl_command_func_t *, Keymap));
warning: parse error extern int rl_bind_key_in_map PARAMS((int, rl_command_func_t *, Keymap));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:297
parsing error 
extern int rl_unbind_key PARAMS((int));
warning: parse error extern int rl_unbind_key PARAMS((int));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:298
parsing error 
extern int rl_unbind_key_in_map PARAMS((int, Keymap));
warning: parse error extern int rl_unbind_key_in_map PARAMS((int, Keymap));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:299
parsing error 
extern int rl_bind_key_if_unbound PARAMS((int, rl_command_func_t *));
warning: parse error extern int rl_bind_key_if_unbound PARAMS((int, rl_command_func_t *));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:300
parsing error 
extern int rl_bind_key_if_unbound_in_map PARAMS((int, rl_command_func_t *, Keymap));
warning: parse error extern int rl_bind_key_if_unbound_in_map PARAMS((int, rl_command_func_t *, Keymap));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:301
parsing error 
extern int rl_unbind_function_in_map PARAMS((rl_command_func_t *, Keymap));
warning: parse error extern int rl_unbind_function_in_map PARAMS((rl_command_func_t *, Keymap));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:302
parsing error 
extern int rl_unbind_command_in_map PARAMS((const char *, Keymap));
warning: parse error extern int rl_unbind_command_in_map PARAMS((const char *, Keymap));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:303
parsing error 
extern int rl_bind_keyseq PARAMS((const char *, rl_command_func_t *));
warning: parse error extern int rl_bind_keyseq PARAMS((const char *, rl_command_func_t *));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:304
parsing error 
extern int rl_bind_keyseq_in_map PARAMS((const char *, rl_command_func_t *, Keymap));
warning: parse error extern int rl_bind_keyseq_in_map PARAMS((const char *, rl_command_func_t *, Keymap));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:305
parsing error 
extern int rl_bind_keyseq_if_unbound PARAMS((const char *, rl_command_func_t *));
warning: parse error extern int rl_bind_keyseq_if_unbound PARAMS((const char *, rl_command_func_t *));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:306
parsing error 
extern int rl_bind_keyseq_if_unbound_in_map PARAMS((const char *, rl_command_func_t *, Keymap));
warning: parse error extern int rl_bind_keyseq_if_unbound_in_map PARAMS((const char *, rl_command_func_t *, Keymap));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:307
parsing error 
extern int rl_generic_bind PARAMS((int, const char *, char *, Keymap));
warning: parse error extern int rl_generic_bind PARAMS((int, const char *, char *, Keymap));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:308
parsing error 
extern char *rl_variable_value PARAMS((const char *));
warning: parse error extern char *rl_variable_value PARAMS((const char *));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:310
parsing error 
extern int rl_variable_bind PARAMS((const char *, const char *));
warning: parse error extern int rl_variable_bind PARAMS((const char *, const char *));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:311
parsing error 
extern int rl_set_key PARAMS((const char *, rl_command_func_t *, Keymap));
warning: parse error extern int rl_set_key PARAMS((const char *, rl_command_func_t *, Keymap));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:314
parsing error 
extern int rl_macro_bind PARAMS((const char *, const char *, Keymap));
warning: parse error extern int rl_macro_bind PARAMS((const char *, const char *, Keymap));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:317
parsing error 
extern int rl_translate_keyseq PARAMS((const char *, char *, int *));
warning: parse error extern int rl_translate_keyseq PARAMS((const char *, char *, int *));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:320
parsing error 
extern char *rl_untranslate_keyseq PARAMS((int));
warning: parse error extern char *rl_untranslate_keyseq PARAMS((int));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:321
parsing error 
extern rl_command_func_t *rl_named_function PARAMS((const char *));
warning: parse error extern rl_command_func_t *rl_named_function PARAMS((const char *));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:323
parsing error 
extern rl_command_func_t *rl_function_of_keyseq PARAMS((const char *, Keymap, int *));
warning: parse error extern rl_command_func_t *rl_function_of_keyseq PARAMS((const char *, Keymap, int *));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:324
parsing error 
extern void rl_list_funmap_names PARAMS((void));
warning: parse error extern void rl_list_funmap_names PARAMS((void));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:326
parsing error 
extern char **rl_invoking_keyseqs_in_map PARAMS((rl_command_func_t *, Keymap));
warning: parse error extern char **rl_invoking_keyseqs_in_map PARAMS((rl_command_func_t *, Keymap));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:327
parsing error 
extern char **rl_invoking_keyseqs PARAMS((rl_command_func_t *));
warning: parse error extern char **rl_invoking_keyseqs PARAMS((rl_command_func_t *));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:328
parsing error 
extern void rl_function_dumper PARAMS((int));
warning: parse error extern void rl_function_dumper PARAMS((int));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:330
parsing error 
extern void rl_macro_dumper PARAMS((int));
warning: parse error extern void rl_macro_dumper PARAMS((int));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:331
parsing error 
extern void rl_variable_dumper PARAMS((int));
warning: parse error extern void rl_variable_dumper PARAMS((int));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:332
parsing error 
extern int rl_read_init_file PARAMS((const char *));
warning: parse error extern int rl_read_init_file PARAMS((const char *));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:334
parsing error 
extern int rl_parse_and_bind PARAMS((char *));
warning: parse error extern int rl_parse_and_bind PARAMS((char *));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:335
parsing error 
extern Keymap rl_make_bare_keymap PARAMS((void));
warning: parse error extern Keymap rl_make_bare_keymap PARAMS((void));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:338
parsing error 
extern Keymap rl_copy_keymap PARAMS((Keymap));
warning: parse error extern Keymap rl_copy_keymap PARAMS((Keymap));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:339
parsing error 
extern Keymap rl_make_keymap PARAMS((void));
warning: parse error extern Keymap rl_make_keymap PARAMS((void));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:340
parsing error 
extern void rl_discard_keymap PARAMS((Keymap));
warning: parse error extern void rl_discard_keymap PARAMS((Keymap));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:341
parsing error 
extern Keymap rl_get_keymap_by_name PARAMS((const char *));
warning: parse error extern Keymap rl_get_keymap_by_name PARAMS((const char *));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:343
parsing error 
extern char *rl_get_keymap_name PARAMS((Keymap));
warning: parse error extern char *rl_get_keymap_name PARAMS((Keymap));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:344
parsing error 
extern void rl_set_keymap PARAMS((Keymap));
warning: parse error extern void rl_set_keymap PARAMS((Keymap));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:345
parsing error 
extern Keymap rl_get_keymap PARAMS((void));
warning: parse error extern Keymap rl_get_keymap PARAMS((void));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:346
parsing error 
extern void rl_set_keymap_from_edit_mode PARAMS((void));
warning: parse error extern void rl_set_keymap_from_edit_mode PARAMS((void));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:348
parsing error 
extern char *rl_get_keymap_name_from_edit_mode PARAMS((void));
warning: parse error extern char *rl_get_keymap_name_from_edit_mode PARAMS((void));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:349
parsing error 
extern int rl_add_funmap_entry PARAMS((const char *, rl_command_func_t *));
warning: parse error extern int rl_add_funmap_entry PARAMS((const char *, rl_command_func_t *));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:352
parsing error 
extern const char **rl_funmap_names PARAMS((void));
warning: parse error extern const char **rl_funmap_names PARAMS((void));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:353
parsing error 
extern void rl_initialize_funmap PARAMS((void));
warning: parse error extern void rl_initialize_funmap PARAMS((void));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:356
parsing error 
extern void rl_push_macro_input PARAMS((char *));
warning: parse error extern void rl_push_macro_input PARAMS((char *));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:359
parsing error 
extern void rl_add_undo PARAMS((enum undo_code, int, int, char *));
warning: parse error extern void rl_add_undo PARAMS((enum undo_code, int, int, char *));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:362
parsing error 
extern void rl_free_undo_list PARAMS((void));
warning: parse error extern void rl_free_undo_list PARAMS((void));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:363
parsing error 
extern int rl_do_undo PARAMS((void));
warning: parse error extern int rl_do_undo PARAMS((void));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:364
parsing error 
extern int rl_begin_undo_group PARAMS((void));
warning: parse error extern int rl_begin_undo_group PARAMS((void));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:365
parsing error 
extern int rl_end_undo_group PARAMS((void));
warning: parse error extern int rl_end_undo_group PARAMS((void));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:366
parsing error 
extern int rl_modifying PARAMS((int, int));
warning: parse error extern int rl_modifying PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:367
parsing error 
extern void rl_redisplay PARAMS((void));
warning: parse error extern void rl_redisplay PARAMS((void));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:370
parsing error 
extern int rl_on_new_line PARAMS((void));
warning: parse error extern int rl_on_new_line PARAMS((void));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:371
parsing error 
extern int rl_on_new_line_with_prompt PARAMS((void));
warning: parse error extern int rl_on_new_line_with_prompt PARAMS((void));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:372
parsing error 
extern int rl_forced_update_display PARAMS((void));
warning: parse error extern int rl_forced_update_display PARAMS((void));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:373
parsing error 
extern int rl_clear_message PARAMS((void));
warning: parse error extern int rl_clear_message PARAMS((void));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:374
parsing error 
extern int rl_reset_line_state PARAMS((void));
warning: parse error extern int rl_reset_line_state PARAMS((void));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:375
parsing error 
extern int rl_crlf PARAMS((void));
warning: parse error extern int rl_crlf PARAMS((void));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:376
parsing error 
extern int rl_show_char PARAMS((int));
warning: parse error extern int rl_show_char PARAMS((int));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:384
parsing error 
extern int rl_character_len PARAMS((int, int));
warning: parse error extern int rl_character_len PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:387
parsing error 
extern void rl_save_prompt PARAMS((void));
warning: parse error extern void rl_save_prompt PARAMS((void));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:390
parsing error 
extern void rl_restore_prompt PARAMS((void));
warning: parse error extern void rl_restore_prompt PARAMS((void));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:391
parsing error 
extern void rl_replace_line PARAMS((const char *, int));
warning: parse error extern void rl_replace_line PARAMS((const char *, int));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:394
parsing error 
extern int rl_insert_text PARAMS((const char *));
warning: parse error extern int rl_insert_text PARAMS((const char *));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:395
parsing error 
extern int rl_delete_text PARAMS((int, int));
warning: parse error extern int rl_delete_text PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:396
parsing error 
extern int rl_kill_text PARAMS((int, int));
warning: parse error extern int rl_kill_text PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:397
parsing error 
extern char *rl_copy_text PARAMS((int, int));
warning: parse error extern char *rl_copy_text PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:398
parsing error 
extern void rl_prep_terminal PARAMS((int));
warning: parse error extern void rl_prep_terminal PARAMS((int));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:401
parsing error 
extern void rl_deprep_terminal PARAMS((void));
warning: parse error extern void rl_deprep_terminal PARAMS((void));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:402
parsing error 
extern void rl_tty_set_default_bindings PARAMS((Keymap));
warning: parse error extern void rl_tty_set_default_bindings PARAMS((Keymap));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:403
parsing error 
extern void rl_tty_unset_default_bindings PARAMS((Keymap));
warning: parse error extern void rl_tty_unset_default_bindings PARAMS((Keymap));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:404
parsing error 
extern int rl_reset_terminal PARAMS((const char *));
warning: parse error extern int rl_reset_terminal PARAMS((const char *));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:406
parsing error 
extern void rl_resize_terminal PARAMS((void));
warning: parse error extern void rl_resize_terminal PARAMS((void));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:407
parsing error 
extern void rl_set_screen_size PARAMS((int, int));
warning: parse error extern void rl_set_screen_size PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:408
parsing error 
extern void rl_get_screen_size PARAMS((int *, int *));
warning: parse error extern void rl_get_screen_size PARAMS((int *, int *));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:409
parsing error 
extern void rl_reset_screen_size PARAMS((void));
warning: parse error extern void rl_reset_screen_size PARAMS((void));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:410
parsing error 
extern char *rl_get_termcap PARAMS((const char *));
warning: parse error extern char *rl_get_termcap PARAMS((const char *));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:412
parsing error 
extern int rl_stuff_char PARAMS((int));
warning: parse error extern int rl_stuff_char PARAMS((int));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:415
parsing error 
extern int rl_execute_next PARAMS((int));
warning: parse error extern int rl_execute_next PARAMS((int));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:416
parsing error 
extern int rl_clear_pending_input PARAMS((void));
warning: parse error extern int rl_clear_pending_input PARAMS((void));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:417
parsing error 
extern int rl_read_key PARAMS((void));
warning: parse error extern int rl_read_key PARAMS((void));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:418
parsing error 
extern int rl_getc PARAMS((FILE *));
warning: parse error extern int rl_getc PARAMS((FILE *));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:419
parsing error 
extern int rl_set_keyboard_input_timeout PARAMS((int));
warning: parse error extern int rl_set_keyboard_input_timeout PARAMS((int));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:420
parsing error 
extern void rl_extend_line_buffer PARAMS((int));
warning: parse error extern void rl_extend_line_buffer PARAMS((int));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:423
parsing error 
extern int rl_ding PARAMS((void));
warning: parse error extern int rl_ding PARAMS((void));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:424
parsing error 
extern int rl_alphabetic PARAMS((int));
warning: parse error extern int rl_alphabetic PARAMS((int));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:425
parsing error 
extern void rl_free PARAMS((void *));
warning: parse error extern void rl_free PARAMS((void *));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:426
parsing error 
extern int rl_set_signals PARAMS((void));
warning: parse error extern int rl_set_signals PARAMS((void));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:429
parsing error 
extern int rl_clear_signals PARAMS((void));
warning: parse error extern int rl_clear_signals PARAMS((void));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:430
parsing error 
extern void rl_cleanup_after_signal PARAMS((void));
warning: parse error extern void rl_cleanup_after_signal PARAMS((void));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:431
parsing error 
extern void rl_reset_after_signal PARAMS((void));
warning: parse error extern void rl_reset_after_signal PARAMS((void));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:432
parsing error 
extern void rl_free_line_state PARAMS((void));
warning: parse error extern void rl_free_line_state PARAMS((void));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:433
parsing error 
extern void rl_echo_signal_char PARAMS((int));
warning: parse error extern void rl_echo_signal_char PARAMS((int));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:435
parsing error 
extern int rl_set_paren_blink_timeout PARAMS((int));
warning: parse error extern int rl_set_paren_blink_timeout PARAMS((int));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:437
parsing error 
extern int rl_maybe_save_line PARAMS((void));
warning: parse error extern int rl_maybe_save_line PARAMS((void));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:440
parsing error 
extern int rl_maybe_unsave_line PARAMS((void));
warning: parse error extern int rl_maybe_unsave_line PARAMS((void));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:441
parsing error 
extern int rl_maybe_replace_line PARAMS((void));
warning: parse error extern int rl_maybe_replace_line PARAMS((void));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:442
parsing error 
extern int rl_complete_internal PARAMS((int));
warning: parse error extern int rl_complete_internal PARAMS((int));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:445
parsing error 
extern void rl_display_match_list PARAMS((char **, int, int));
warning: parse error extern void rl_display_match_list PARAMS((char **, int, int));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:446
parsing error 
extern char **rl_completion_matches PARAMS((const char *, rl_compentry_func_t *));
warning: parse error extern char **rl_completion_matches PARAMS((const char *, rl_compentry_func_t *));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:448
parsing error 
extern char *rl_username_completion_function PARAMS((const char *, int));
warning: parse error extern char *rl_username_completion_function PARAMS((const char *, int));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:449
parsing error 
extern char *rl_filename_completion_function PARAMS((const char *, int));
warning: parse error extern char *rl_filename_completion_function PARAMS((const char *, int));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:450
parsing error 
extern int rl_completion_mode PARAMS((rl_command_func_t *));
warning: parse error extern int rl_completion_mode PARAMS((rl_command_func_t *));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:452
parsing error 
extern void free_undo_list PARAMS((void));
warning: parse error extern void free_undo_list PARAMS((void));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:456
parsing error 
extern int maybe_save_line PARAMS((void));
warning: parse error extern int maybe_save_line PARAMS((void));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:457
parsing error 
extern int maybe_unsave_line PARAMS((void));
warning: parse error extern int maybe_unsave_line PARAMS((void));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:458
parsing error 
extern int maybe_replace_line PARAMS((void));
warning: parse error extern int maybe_replace_line PARAMS((void));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:459
parsing error 
extern int ding PARAMS((void));
warning: parse error extern int ding PARAMS((void));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:461
parsing error 
extern int alphabetic PARAMS((int));
warning: parse error extern int alphabetic PARAMS((int));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:462
parsing error 
extern int crlf PARAMS((void));
warning: parse error extern int crlf PARAMS((void));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:463
parsing error 
extern char **completion_matches PARAMS((char *, rl_compentry_func_t *));
warning: parse error extern char **completion_matches PARAMS((char *, rl_compentry_func_t *));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:465
parsing error 
extern char *username_completion_function PARAMS((const char *, int));
warning: parse error extern char *username_completion_function PARAMS((const char *, int));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:466
parsing error 
extern char *filename_completion_function PARAMS((const char *, int));
warning: parse error extern char *filename_completion_function PARAMS((const char *, int));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:467
parsing error 
extern int rl_save_state PARAMS((struct readline_state *));
warning: parse error extern int rl_save_state PARAMS((struct readline_state *));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:886
parsing error 
extern int rl_restore_state PARAMS((struct readline_state *));
warning: parse error extern int rl_restore_state PARAMS((struct readline_state *));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h:887
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\history.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\glob\glob.h...skip
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\bracecomp.c...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\bashansi.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\shmbutil.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\shell.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h...skip
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\braces.c...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\bashansi.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\general.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\shmbutil.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\chartypes.h...skip
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\bashgetopt.c...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\bashansi.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\chartypes.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\shell.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\common.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\bashgetopt.c:48
parsing error 
{
	register int c;
	register char *cp;
	int	plus;	/* nonzero means to handle +option */
	static char errstr[3] = { '-', '\0', '\0' };

	plus = *opts == '+';
	if (plus)
		opts++;

	if (list == 0) {
		list_optarg = (char *)NULL;
		loptend = (WORD_LIST *)NULL;	/* No non-option arguments */
		return -1;
	}

	if (list != lhead || lhead == 0) {
		/* Hmmm.... called with a different word list.  Reset. */
		sp = 1;
		lcurrent = lhead = list;
		loptend = (WORD_LIST *)NULL;
	}

	if (sp == 1) {
		if (lcurrent == 0 || NOTOPT(lcurrent->word->word)) {
		    	lhead = (WORD_LIST *)NULL;
		    	loptend = lcurrent;
			return(-1);
		} else if (lcurrent->word->word[0] == '-' &&
			   lcurrent->word->word[1] == '-' &&
			   lcurrent->word->word[2] == 0) {
			lhead = (WORD_LIST *)NULL;
			loptend = lcurrent->next;
			return(-1);
		}
		errstr[0] = list_opttype = lcurrent->word->word[0];
	}

	list_optopt = c = lcurrent->word->word[sp];

	if (c == ':' || (cp = strchr(opts, c)) == NULL) {
		errstr[1] = c;
		sh_invalidopt (errstr);		
		if (lcurrent->word->word[++sp] == '\0') {
			lcurrent = lcurrent->next;
			sp = 1;
		}
		list_optarg = NULL;
		if (lcurrent)
			loptend = lcurrent->next;
		return('?');
	}

	if (*++cp == ':' || *cp == ';') {
		/* `:': Option requires an argument. */
		/* `;': option argument may be missing */
		/* We allow -l2 as equivalent to -l 2 */
		if (lcurrent->word->word[sp+1]) {
			list_optarg = lcurrent->word->word + sp + 1;
			lcurrent = lcurrent->next;
		/* If the specifier is `;', don't set optarg if the next
		   argument looks like another option. */
#if 0
		} else if (lcurrent->next && (*cp == ':' || lcurrent->next->word->word[0] != '-')) {
#else
		} else if (lcurrent->next && (*cp == ':' || NOTOPT(lcurrent->next->word->word))) {
#endif
			lcurrent = lcurrent->next;
			list_optarg = lcurrent->word->word;
			lcurrent = lcurrent->next;
		} else if (*cp == ';') {
			list_optarg = (char *)NULL;
			lcurrent = lcurrent->next;
		} else {	/* lcurrent->next == NULL */
			errstr[1] = c;
			sh_needarg (errstr);
			sp = 1;
			list_optarg = (char *)NULL;
			return('?');
		}
		sp = 1;
	} else if (*cp == '#') {
		/* option requires a numeric argument */
		if (lcurrent->word->word[sp+1]) {
			if (DIGIT(lcurrent->word->word[sp+1])) {
				list_optarg = lcurrent->word->word + sp + 1;
				lcurrent = lcurrent->next;
			} else
				list_optarg = (char *)NULL;
		} else {
			if (lcurrent->next && legal_number(lcurrent->next->word->word, (intmax_t *)0)) {
				lcurrent = lcurrent->next;
				list_optarg = lcurrent->word->word;
				lcurrent = lcurrent->next;
			} else {
				errstr[1] = c;
				sh_neednumarg (errstr);
				sp = 1;
				list_optarg = (char *)NULL;
				return ('?');
			}
		}

	} else {
		/* No argument, just return the option. */
		if (lcurrent->word->word[++sp] == '\0') {
			sp = 1;
			lcurrent = lcurrent->next;
		}
		list_optarg = (char *)NULL;
	}

	return(c);
}
warning: parse error {
	register int c;
	register char *cp;
	int	plus;	/* nonzero means to handle +option */
	static char errstr[3] = { '-', '\0', '\0' };

	plus = *opts == '+';
	if (plus)
		opts++;

	if (list == 0) {
		list_optarg = (char *)NULL;
		loptend = (WORD_LIST *)NULL;	/* No non-option arguments */
		return -1;
	}

	if (list != lhead || lhead == 0) {
		/* Hmmm.... called with a different word list.  Reset. */
		sp = 1;
		lcurrent = lhead = list;
		loptend = (WORD_LIST *)NULL;
	}

	if (sp == 1) {
		if (lcurrent == 0 || NOTOPT(lcurrent->word->word)) {
		    	lhead = (WORD_LIST *)NULL;
		    	loptend = lcurrent;
			return(-1);
		} else if (lcurrent->word->word[0] == '-' &&
			   lcurrent->word->word[1] == '-' &&
			   lcurrent->word->word[2] == 0) {
			lhead = (WORD_LIST *)NULL;
			loptend = lcurrent->next;
			return(-1);
		}
		errstr[0] = list_opttype = lcurrent->word->word[0];
	}

	list_optopt = c = lcurrent->word->word[sp];

	if (c == ':' || (cp = strchr(opts, c)) == NULL) {
		errstr[1] = c;
		sh_invalidopt (errstr);		
		if (lcurrent->word->word[++sp] == '\0') {
			lcurrent = lcurrent->next;
			sp = 1;
		}
		list_optarg = NULL;
		if (lcurrent)
			loptend = lcurrent->next;
		return('?');
	}

	if (*++cp == ':' || *cp == ';') {
		/* `:': Option requires an argument. */
		/* `;': option argument may be missing */
		/* We allow -l2 as equivalent to -l 2 */
		if (lcurrent->word->word[sp+1]) {
			list_optarg = lcurrent->word->word + sp + 1;
			lcurrent = lcurrent->next;
		/* If the specifier is `;', don't set optarg if the next
		   argument looks like another option. */
#if 0
		} else if (lcurrent->next && (*cp == ':' || lcurrent->next->word->word[0] != '-')) {
#else
		} else if (lcurrent->next && (*cp == ':' || NOTOPT(lcurrent->next->word->word))) {
#endif
			lcurrent = lcurrent->next;
			list_optarg = lcurrent->word->word;
			lcurrent = lcurrent->next;
		} else if (*cp == ';') {
			list_optarg = (char *)NULL;
			lcurrent = lcurrent->next;
		} else {	/* lcurrent->next == NULL */
			errstr[1] = c;
			sh_needarg (errstr);
			sp = 1;
			list_optarg = (char *)NULL;
			return('?');
		}
		sp = 1;
	} else if (*cp == '#') {
		/* option requires a numeric argument */
		if (lcurrent->word->word[sp+1]) {
			if (DIGIT(lcurrent->word->word[sp+1])) {
				list_optarg = lcurrent->word->word + sp + 1;
				lcurrent = lcurrent->next;
			} else
				list_optarg = (char *)NULL;
		} else {
			if (lcurrent->next && legal_number(lcurrent->next->word->word, (intmax_t *)0)) {
				lcurrent = lcurrent->next;
				list_optarg = lcurrent->word->word;
				lcurrent = lcurrent->next;
			} else {
				errstr[1] = c;
				sh_neednumarg (errstr);
				sp = 1;
				list_optarg = (char *)NULL;
				return ('?');
			}
		}

	} else {
		/* No argument, just return the option. */
		if (lcurrent->word->word[++sp] == '\0') {
			sp = 1;
			lcurrent = lcurrent->next;
		}
		list_optarg = (char *)NULL;
	}

	return(c);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\bashgetopt.c:51
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\common.c...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\chartypes.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\bashtypes.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\posixstat.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\bashansi.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\bashintl.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\shell.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\maxpath.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\flags.h...skip
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\jobs.h...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\quit.h...skip
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\siglist.h...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\stdc.h...skip
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\posixwait.h...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\input.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\execute_cmd.h...skip
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\trap.h...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\stdc.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\bashtypes.h...skip
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\bashgetopt.h...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\stdc.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\common.h...skip
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\tilde\tilde.h...
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\common.c:112
parsing error 
va_dcl
#endif
{
  va_list args;

  builtin_error_prolog ();

  SH_VA_START (args, format);

  vfprintf (stderr, format, args);
  va_end (args);
  fprintf (stderr, "\n");
}
warning: parse error va_dcl
#endif
{
  va_list args;

  builtin_error_prolog ();

  SH_VA_START (args, format);

  vfprintf (stderr, format, args);
  va_end (args);
  fprintf (stderr, "\n");
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\common.c:113
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\common.c:132
parsing error 
va_dcl
#endif
{
  va_list args;

  builtin_error_prolog ();
  fprintf (stderr, _("warning: "));

  SH_VA_START (args, format);

  vfprintf (stderr, format, args);
  va_end (args);
  fprintf (stderr, "\n");
}
warning: parse error va_dcl
#endif
{
  va_list args;

  builtin_error_prolog ();
  fprintf (stderr, _("warning: "));

  SH_VA_START (args, format);

  vfprintf (stderr, format, args);
  va_end (args);
  fprintf (stderr, "\n");
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\common.c:133
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\common.c:161
parsing error 
{
  if (list)
    {
      builtin_error (_("too many arguments"));
      top_level_cleanup ();
      jump_to_top_level (DISCARD);
    }
}
warning: parse error {
  if (list)
    {
      builtin_error (_("too many arguments"));
      top_level_cleanup ();
      jump_to_top_level (DISCARD);
    }
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\common.c:163
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\common.c:175
parsing error 
{
  reset_internal_getopt ();
  if (internal_getopt (list, "") != -1)
    {
      builtin_usage ();
      return (1);
    }
  return (0);
}
warning: parse error {
  reset_internal_getopt ();
  if (internal_getopt (list, "") != -1)
    {
      builtin_usage ();
      return (1);
    }
  return (0);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\common.c:177
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\common.c:188
parsing error 
{
  builtin_error (_("%s: option requires an argument"), s);
}
warning: parse error {
  builtin_error (_("%s: option requires an argument"), s);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\common.c:190
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\common.c:195
parsing error 
{
  builtin_error (_("%s: numeric argument required"), s);
}
warning: parse error {
  builtin_error (_("%s: numeric argument required"), s);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\common.c:197
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\common.c:202
parsing error 
{
  builtin_error (_("%s: not found"), s);
}
warning: parse error {
  builtin_error (_("%s: not found"), s);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\common.c:204
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\common.c:211
parsing error 
{
  builtin_error (_("%s: invalid option"), s);
}
warning: parse error {
  builtin_error (_("%s: invalid option"), s);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\common.c:213
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\common.c:218
parsing error 
{
  builtin_error (_("%s: invalid option name"), s);
}
warning: parse error {
  builtin_error (_("%s: invalid option name"), s);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\common.c:220
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\common.c:225
parsing error 
{
  builtin_error (_("`%s': not a valid identifier"), s);
}
warning: parse error {
  builtin_error (_("`%s': not a valid identifier"), s);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\common.c:227
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\common.c:232
parsing error 
{
  char *msg;

  if (*s == '0' && isdigit (s[1]))
    msg = _("invalid octal number");
  else if (*s == '0' && s[1] == 'x')
    msg = _("invalid hex number");
  else
    msg = _("invalid number");
  builtin_error ("%s: %s", s, msg);
}
warning: parse error {
  char *msg;

  if (*s == '0' && isdigit (s[1]))
    msg = _("invalid octal number");
  else if (*s == '0' && s[1] == 'x')
    msg = _("invalid hex number");
  else
    msg = _("invalid number");
  builtin_error ("%s: %s", s, msg);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\common.c:234
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\common.c:247
parsing error 
{
  builtin_error (_("%s: invalid signal specification"), s);
}
warning: parse error {
  builtin_error (_("%s: invalid signal specification"), s);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\common.c:249
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\common.c:254
parsing error 
{
  builtin_error (_("`%s': not a pid or valid job spec"), s);
}
warning: parse error {
  builtin_error (_("`%s': not a pid or valid job spec"), s);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\common.c:256
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\common.c:262
parsing error 
{
  builtin_error (_("%s: readonly variable"), s);
}
warning: parse error {
  builtin_error (_("%s: readonly variable"), s);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\common.c:263
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\common.c:268
parsing error 
{
  if (s)
    builtin_error (_("%s: %s out of range"), s, desc ? desc : _("argument"));
  else
    builtin_error (_("%s out of range"), desc ? desc : _("argument"));
}
warning: parse error {
  if (s)
    builtin_error (_("%s: %s out of range"), s, desc ? desc : _("argument"));
  else
    builtin_error (_("%s out of range"), desc ? desc : _("argument"));
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\common.c:270
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\common.c:309
parsing error 
{
  builtin_error (_("%s: not a shell builtin"), s);
}
warning: parse error {
  builtin_error (_("%s: not a shell builtin"), s);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\common.c:311
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\common.c:325
parsing error 
{
  if (set)
    builtin_error (_("error setting terminal attributes: %s"), strerror (errno));
  else
    builtin_error (_("error getting terminal attributes: %s"), strerror (errno));
}
warning: parse error {
  if (set)
    builtin_error (_("error setting terminal attributes: %s"), strerror (errno));
  else
    builtin_error (_("error getting terminal attributes: %s"), strerror (errno));
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\common.c:327
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\common.c:335
parsing error 
{
  fflush (stdout);
  if (ferror (stdout))
    {
      sh_wrerror ();
      fpurge (stdout);
      clearerr (stdout);
      return (EXECUTION_FAILURE);
    }
  return (s);
}
warning: parse error {
  fflush (stdout);
  if (ferror (stdout))
    {
      sh_wrerror ();
      fpurge (stdout);
      clearerr (stdout);
      return (EXECUTION_FAILURE);
    }
  return (s);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\common.c:337
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\common.c:359
parsing error 
{
  char **argv;

  argv = strvec_from_word_list (list, 0, 1, ip);
  argv[0] = this_command_name;
  return argv;
}
warning: parse error {
  char **argv;

  argv = strvec_from_word_list (list, 0, 1, ip);
  argv[0] = this_command_name;
  return argv;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\common.c:362
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\common.c:374
parsing error 
{
  register int i;

  for (i = 1; i < 10; i++)
    {
      if ((destructive || list) && dollar_vars[i])
	{
	  free (dollar_vars[i]);
	  dollar_vars[i] = (char *)NULL;
	}

      if (list)
	{
	  dollar_vars[i] = savestring (list->word->word);
	  list = list->next;
	}
    }

  /* If arguments remain, assign them to REST_OF_ARGS.
     Note that copy_word_list (NULL) returns NULL, and
     that dispose_words (NULL) does nothing. */
  if (destructive || list)
    {
      dispose_words (rest_of_args);
      rest_of_args = copy_word_list (list);
    }

  if (destructive)
    set_dollar_vars_changed ();
}
warning: parse error {
  register int i;

  for (i = 1; i < 10; i++)
    {
      if ((destructive || list) && dollar_vars[i])
	{
	  free (dollar_vars[i]);
	  dollar_vars[i] = (char *)NULL;
	}

      if (list)
	{
	  dollar_vars[i] = savestring (list->word->word);
	  list = list->next;
	}
    }

  /* If arguments remain, assign them to REST_OF_ARGS.
     Note that copy_word_list (NULL) returns NULL, and
     that dispose_words (NULL) does nothing. */
  if (destructive || list)
    {
      dispose_words (rest_of_args);
      rest_of_args = copy_word_list (list);
    }

  if (destructive)
    set_dollar_vars_changed ();
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\common.c:377
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\common.c:449
parsing error 
{
  char *arg;

  if (count)
    *count = 1;

  if (list && list->word && ISOPTION (list->word->word, '-'))
    list = list->next;

  if (list)
    {
      arg = list->word->word;
      if (arg == 0 || (legal_number (arg, count) == 0))
	{
	  sh_neednumarg (list->word->word ? list->word->word : "`'");
	  if (fatal == 0)
	    return 0;
	  else if (fatal == 1)		/* fatal == 1; abort */
	    throw_to_top_level ();
	  else				/* fatal == 2; discard current command */
	    {
	      top_level_cleanup ();
	      jump_to_top_level (DISCARD);
	    }
	}
      no_args (list->next);
    }

  return (1);
}
warning: parse error {
  char *arg;

  if (count)
    *count = 1;

  if (list && list->word && ISOPTION (list->word->word, '-'))
    list = list->next;

  if (list)
    {
      arg = list->word->word;
      if (arg == 0 || (legal_number (arg, count) == 0))
	{
	  sh_neednumarg (list->word->word ? list->word->word : "`'");
	  if (fatal == 0)
	    return 0;
	  else if (fatal == 1)		/* fatal == 1; abort */
	    throw_to_top_level ();
	  else				/* fatal == 2; discard current command */
	    {
	      top_level_cleanup ();
	      jump_to_top_level (DISCARD);
	    }
	}
      no_args (list->next);
    }

  return (1);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\common.c:453
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\common.c:486
parsing error 
{
  int status;
  intmax_t sval;
  char *arg;

  if (list && list->word && ISOPTION (list->word->word, '-'))
    list = list->next;

  if (list == 0)
    return (last_command_exit_value);      

  arg = list->word->word;
  if (arg == 0 || legal_number (arg, &sval) == 0)
    {
      sh_neednumarg (list->word->word ? list->word->word : "`'");
      return 255;
    }
  no_args (list->next);

  status = sval & 255;
  return status;
}
warning: parse error {
  int status;
  intmax_t sval;
  char *arg;

  if (list && list->word && ISOPTION (list->word->word, '-'))
    list = list->next;

  if (list == 0)
    return (last_command_exit_value);      

  arg = list->word->word;
  if (arg == 0 || legal_number (arg, &sval) == 0)
    {
      sh_neednumarg (list->word->word ? list->word->word : "`'");
      return 255;
    }
  no_args (list->next);

  status = sval & 255;
  return status;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\common.c:488
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\common.c:514
parsing error 
{
  int result, digits;

  result = digits = 0;
  while (*string && ISOCTAL (*string))
    {
      digits++;
      result = (result * 8) + (*string++ - '0');
      if (result > 0777)
	return -1;
    }

  if (digits == 0 || *string)
    result = -1;

  return (result);
}
warning: parse error {
  int result, digits;

  result = digits = 0;
  while (*string && ISOCTAL (*string))
    {
      digits++;
      result = (result * 8) + (*string++ - '0');
      if (result > 0777)
	return -1;
    }

  if (digits == 0 || *string)
    result = -1;

  return (result);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\common.c:516
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\common.c:545
parsing error 
{
  if (no_symbolic_links)
    {
      FREE (the_current_working_directory);
      the_current_working_directory = (char *)NULL;
    }

  if (the_current_working_directory == 0)
    {
#if defined (GETCWD_BROKEN)
      the_current_working_directory = getcwd (0, PATH_MAX);
#else
      the_current_working_directory = getcwd (0, 0);
#endif
      if (the_current_working_directory == 0)
	{
	  fprintf (stderr, _("%s: error retrieving current directory: %s: %s\n"),
		   (for_whom && *for_whom) ? for_whom : get_name_for_error (),
		   _(bash_getcwd_errstr), strerror (errno));
	  return (char *)NULL;
	}
    }

  return (savestring (the_current_working_directory));
}
warning: parse error {
  if (no_symbolic_links)
    {
      FREE (the_current_working_directory);
      the_current_working_directory = (char *)NULL;
    }

  if (the_current_working_directory == 0)
    {
#if defined (GETCWD_BROKEN)
      the_current_working_directory = getcwd (0, PATH_MAX);
#else
      the_current_working_directory = getcwd (0, 0);
#endif
      if (the_current_working_directory == 0)
	{
	  fprintf (stderr, _("%s: error retrieving current directory: %s: %s\n"),
		   (for_whom && *for_whom) ? for_whom : get_name_for_error (),
		   _(bash_getcwd_errstr), strerror (errno));
	  return (char *)NULL;
	}
    }

  return (savestring (the_current_working_directory));
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\common.c:547
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\common.c:575
parsing error 
{
  FREE (the_current_working_directory);
  the_current_working_directory = savestring (name);
}
warning: parse error {
  FREE (the_current_working_directory);
  the_current_working_directory = savestring (name);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\common.c:577
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\common.c:694
parsing error 
{
  register int i, column;
  char *name;
  int result, signum, dflags;
  intmax_t lsignum;

  result = EXECUTION_SUCCESS;
  if (!list)
    {
      for (i = 1, column = 0; i < NSIG; i++)
	{
	  name = signal_name (i);
	  if (STREQN (name, "SIGJUNK", 7) || STREQN (name, "Unknown", 7))
	    continue;

	  if (posixly_correct && !forcecols)
	    {
	      /* This is for the kill builtin.  POSIX.2 says the signal names
		 are displayed without the `SIG' prefix. */
	      if (STREQN (name, "SIG", 3))
		name += 3;
	      printf ("%s%s", name, (i == NSIG - 1) ? "" : " ");
	    }
	  else
	    {
	      printf ("%2d) %s", i, name);

	      if (++column < 5)
		printf ("\t");
	      else
		{
		  printf ("\n");
		  column = 0;
		}
	    }
	}

      if ((posixly_correct && !forcecols) || column != 0)
	printf ("\n");
      return result;
    }

  /* List individual signal names or numbers. */
  while (list)
    {
      if (legal_number (list->word->word, &lsignum))
	{
	  /* This is specified by Posix.2 so that exit statuses can be
	     mapped into signal numbers. */
	  if (lsignum > 128)
	    lsignum -= 128;
	  if (lsignum < 0 || lsignum >= NSIG)
	    {
	      sh_invalidsig (list->word->word);
	      result = EXECUTION_FAILURE;
	      list = list->next;
	      continue;
	    }

	  signum = lsignum;
	  name = signal_name (signum);
	  if (STREQN (name, "SIGJUNK", 7) || STREQN (name, "Unknown", 7))
	    {
	      list = list->next;
	      continue;
	    }
#if defined (JOB_CONTROL)
	  /* POSIX.2 says that `kill -l signum' prints the signal name without
	     the `SIG' prefix. */
	  printf ("%s\n", (this_shell_builtin == kill_builtin) ? name + 3 : name);
#else
	  printf ("%s\n", name);
#endif
	}
      else
	{
	  dflags = DSIG_NOCASE;
	  if (posixly_correct == 0 || this_shell_builtin != kill_builtin)
	    dflags |= DSIG_SIGPREFIX;
	  signum = decode_signal (list->word->word, dflags);
	  if (signum == NO_SIG)
	    {
	      sh_invalidsig (list->word->word);
	      result = EXECUTION_FAILURE;
	      list = list->next;
	      continue;
	    }
	  printf ("%d\n", signum);
	}
      list = list->next;
    }
  return (result);
}
warning: parse error {
  register int i, column;
  char *name;
  int result, signum, dflags;
  intmax_t lsignum;

  result = EXECUTION_SUCCESS;
  if (!list)
    {
      for (i = 1, column = 0; i < NSIG; i++)
	{
	  name = signal_name (i);
	  if (STREQN (name, "SIGJUNK", 7) || STREQN (name, "Unknown", 7))
	    continue;

	  if (posixly_correct && !forcecols)
	    {
	      /* This is for the kill builtin.  POSIX.2 says the signal names
		 are displayed without the `SIG' prefix. */
	      if (STREQN (name, "SIG", 3))
		name += 3;
	      printf ("%s%s", name, (i == NSIG - 1) ? "" : " ");
	    }
	  else
	    {
	      printf ("%2d) %s", i, name);

	      if (++column < 5)
		printf ("\t");
	      else
		{
		  printf ("\n");
		  column = 0;
		}
	    }
	}

      if ((posixly_correct && !forcecols) || column != 0)
	printf ("\n");
      return result;
    }

  /* List individual signal names or numbers. */
  while (list)
    {
      if (legal_number (list->word->word, &lsignum))
	{
	  /* This is specified by Posix.2 so that exit statuses can be
	     mapped into signal numbers. */
	  if (lsignum > 128)
	    lsignum -= 128;
	  if (lsignum < 0 || lsignum >= NSIG)
	    {
	      sh_invalidsig (list->word->word);
	      result = EXECUTION_FAILURE;
	      list = list->next;
	      continue;
	    }

	  signum = lsignum;
	  name = signal_name (signum);
	  if (STREQN (name, "SIGJUNK", 7) || STREQN (name, "Unknown", 7))
	    {
	      list = list->next;
	      continue;
	    }
#if defined (JOB_CONTROL)
	  /* POSIX.2 says that `kill -l signum' prints the signal name without
	     the `SIG' prefix. */
	  printf ("%s\n", (this_shell_builtin == kill_builtin) ? name + 3 : name);
#else
	  printf ("%s\n", name);
#endif
	}
      else
	{
	  dflags = DSIG_NOCASE;
	  if (posixly_correct == 0 || this_shell_builtin != kill_builtin)
	    dflags |= DSIG_SIGPREFIX;
	  signum = decode_signal (list->word->word, dflags);
	  if (signum == NO_SIG)
	    {
	      sh_invalidsig (list->word->word);
	      result = EXECUTION_FAILURE;
	      list = list->next;
	      continue;
	    }
	  printf ("%d\n", signum);
	}
      list = list->next;
    }
  return (result);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\common.c:697
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\common.c:803
parsing error 
{
  int hi, lo, mid, j;

  hi = num_shell_builtins - 1;
  lo = 0;

  while (lo <= hi)
    {
      mid = (lo + hi) / 2;

      j = shell_builtins[mid].name[0] - name[0];

      if (j == 0)
	j = strcmp (shell_builtins[mid].name, name);

      if (j == 0)
	{
	  /* It must have a function pointer.  It must be enabled, or we
	     must have explicitly allowed disabled functions to be found,
	     and it must not have been deleted. */
	  if (shell_builtins[mid].function &&
	      ((shell_builtins[mid].flags & BUILTIN_DELETED) == 0) &&
	      ((shell_builtins[mid].flags & BUILTIN_ENABLED) || disabled_okay))
	    return (&shell_builtins[mid]);
	  else
	    return ((struct builtin *)NULL);
	}
      if (j > 0)
	hi = mid - 1;
      else
	lo = mid + 1;
    }
  return ((struct builtin *)NULL);
}
warning: parse error {
  int hi, lo, mid, j;

  hi = num_shell_builtins - 1;
  lo = 0;

  while (lo <= hi)
    {
      mid = (lo + hi) / 2;

      j = shell_builtins[mid].name[0] - name[0];

      if (j == 0)
	j = strcmp (shell_builtins[mid].name, name);

      if (j == 0)
	{
	  /* It must have a function pointer.  It must be enabled, or we
	     must have explicitly allowed disabled functions to be found,
	     and it must not have been deleted. */
	  if (shell_builtins[mid].function &&
	      ((shell_builtins[mid].flags & BUILTIN_DELETED) == 0) &&
	      ((shell_builtins[mid].flags & BUILTIN_ENABLED) || disabled_okay))
	    return (&shell_builtins[mid]);
	  else
	    return ((struct builtin *)NULL);
	}
      if (j > 0)
	hi = mid - 1;
      else
	lo = mid + 1;
    }
  return ((struct builtin *)NULL);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\common.c:806
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\common.c:843
parsing error 
{
  current_builtin = builtin_address_internal (name, 0);
  return (current_builtin ? current_builtin->function : (sh_builtin_func_t *)NULL);
}
warning: parse error {
  current_builtin = builtin_address_internal (name, 0);
  return (current_builtin ? current_builtin->function : (sh_builtin_func_t *)NULL);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\common.c:845
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\common.c:852
parsing error 
{
  current_builtin = builtin_address_internal (name, 1);
  return (current_builtin ? current_builtin->function : (sh_builtin_func_t *)NULL);
}
warning: parse error {
  current_builtin = builtin_address_internal (name, 1);
  return (current_builtin ? current_builtin->function : (sh_builtin_func_t *)NULL);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\common.c:854
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\common.c:862
parsing error 
{
  current_builtin = builtin_address_internal (name, 0);
  return ((current_builtin && (current_builtin->flags & SPECIAL_BUILTIN)) ?
  			current_builtin->function :
  			(sh_builtin_func_t *)NULL);
}
warning: parse error {
  current_builtin = builtin_address_internal (name, 0);
  return ((current_builtin && (current_builtin->flags & SPECIAL_BUILTIN)) ?
  			current_builtin->function :
  			(sh_builtin_func_t *)NULL);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\common.c:864
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\common.c:872
parsing error 
{
  int result;

  if ((result = sbp1->name[0] - sbp2->name[0]) == 0)
    result = strcmp (sbp1->name, sbp2->name);

  return (result);
}
warning: parse error {
  int result;

  if ((result = sbp1->name[0] - sbp2->name[0]) == 0)
    result = strcmp (sbp1->name, sbp2->name);

  return (result);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\common.c:874
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\evalfile.c...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\bashtypes.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\posixstat.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\filecntl.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\bashansi.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\bashintl.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\shell.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\jobs.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\flags.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\input.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\execute_cmd.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\trap.h...skip
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\typemax.h...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\common.h...skip
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\evalfile.c:80
parsing error 
{
  volatile int old_interactive;
  procenv_t old_return_catch;
  int return_val, fd, result, pflags, i, nnull;
  ssize_t nr;			/* return value from read(2) */
  char *string;
  struct stat finfo;
  size_t file_size;
  sh_vmsg_func_t *errfunc;
#if defined (ARRAY_VARS)
  SHELL_VAR *funcname_v, *nfv, *bash_source_v, *bash_lineno_v;
  ARRAY *funcname_a, *bash_source_a, *bash_lineno_a;
#  if defined (DEBUGGER)
  SHELL_VAR *bash_argv_v, *bash_argc_v;
  ARRAY *bash_argv_a, *bash_argc_a;
#  endif
  char *t, tt[2];
#endif

  USE_VAR(pflags);

#if defined (ARRAY_VARS)
  GET_ARRAY_FROM_VAR ("FUNCNAME", funcname_v, funcname_a);
  GET_ARRAY_FROM_VAR ("BASH_SOURCE", bash_source_v, bash_source_a);
  GET_ARRAY_FROM_VAR ("BASH_LINENO", bash_lineno_v, bash_lineno_a);
#  if defined (DEBUGGER)
  GET_ARRAY_FROM_VAR ("BASH_ARGV", bash_argv_v, bash_argv_a);
  GET_ARRAY_FROM_VAR ("BASH_ARGC", bash_argc_v, bash_argc_a);
#  endif
#endif
  
  fd = open (filename, O_RDONLY);

  if (fd < 0 || (fstat (fd, &finfo) == -1))
    {
file_error_and_exit:
      if (((flags & FEVAL_ENOENTOK) == 0) || errno != ENOENT)
	file_error (filename);

      if (flags & FEVAL_LONGJMP)
	{
	  last_command_exit_value = 1;
	  jump_to_top_level (EXITPROG);
	}

      return ((flags & FEVAL_BUILTIN) ? EXECUTION_FAILURE
      				      : ((errno == ENOENT) ? 0 : -1));
    }

  errfunc = ((flags & FEVAL_BUILTIN) ? builtin_error : internal_error);

  if (S_ISDIR (finfo.st_mode))
    {
      (*errfunc) (_("%s: is a directory"), filename);
      return ((flags & FEVAL_BUILTIN) ? EXECUTION_FAILURE : -1);
    }
  else if ((flags & FEVAL_REGFILE) && S_ISREG (finfo.st_mode) == 0)
    {
      (*errfunc) (_("%s: not a regular file"), filename);
      return ((flags & FEVAL_BUILTIN) ? EXECUTION_FAILURE : -1);
    }

  file_size = (size_t)finfo.st_size;
  /* Check for overflow with large files. */
  if (file_size != finfo.st_size || file_size + 1 < file_size)
    {
      (*errfunc) (_("%s: file is too large"), filename);
      return ((flags & FEVAL_BUILTIN) ? EXECUTION_FAILURE : -1);
    }      

  if (S_ISREG (finfo.st_mode) && file_size <= SSIZE_MAX)
    {
      string = (char *)xmalloc (1 + file_size);
      nr = read (fd, string, file_size);
      if (nr >= 0)
	string[nr] = '\0';
    }
  else
    nr = zmapfd (fd, &string, 0);

  return_val = errno;
  close (fd);
  errno = return_val;

  if (nr < 0)		/* XXX was != file_size, not < 0 */
    {
      free (string);
      goto file_error_and_exit;
    }

  if (nr == 0)
    {
      free (string);
      return ((flags & FEVAL_BUILTIN) ? EXECUTION_SUCCESS : 1);
    }
      
  if ((flags & FEVAL_CHECKBINARY) && 
      check_binary_file (string, (nr > 80) ? 80 : nr))
    {
      free (string);
      (*errfunc) (_("%s: cannot execute binary file"), filename);
      return ((flags & FEVAL_BUILTIN) ? EX_BINARY_FILE : -1);
    }

  i = strlen (string);
  if (i < nr)
    {
      for (nnull = i = 0; i < nr; i++)
	if (string[i] == '\0')
          {
	    memmove (string+i, string+i+1, nr - i);
	    nr--;
	    /* Even if the `check binary' flag is not set, we want to avoid
	       sourcing files with more than 256 null characters -- that
	       probably indicates a binary file. */
	    if ((flags & FEVAL_BUILTIN) && ++nnull > 256)
	      {
		free (string);
		(*errfunc) (_("%s: cannot execute binary file"), filename);
		return ((flags & FEVAL_BUILTIN) ? EX_BINARY_FILE : -1);
	      }
          }
    }

  if (flags & FEVAL_UNWINDPROT)
    {
      begin_unwind_frame ("_evalfile");

      unwind_protect_int (return_catch_flag);
      unwind_protect_jmp_buf (return_catch);
      if (flags & FEVAL_NONINT)
	unwind_protect_int (interactive);
      unwind_protect_int (sourcelevel);
    }
  else
    {
      COPY_PROCENV (return_catch, old_return_catch);
      if (flags & FEVAL_NONINT)
	old_interactive = interactive;
    }

  if (flags & FEVAL_NONINT)
    interactive = 0;

  return_catch_flag++;
  sourcelevel++;

#if defined (ARRAY_VARS)
  array_push (bash_source_a, (char *)filename);
  t = itos (executing_line_number ());
  array_push (bash_lineno_a, t);
  free (t);
  array_push (funcname_a, "source");	/* not exactly right */
#  if defined (DEBUGGER)
  /* Have to figure out a better way to do this when `source' is supplied
     arguments */
  if ((flags & FEVAL_NOPUSHARGS) == 0)
    {
      array_push (bash_argv_a, (char *)filename);
      tt[0] = '1'; tt[1] = '\0';
      array_push (bash_argc_a, tt);
    }
#  endif
#endif

  /* set the flags to be passed to parse_and_execute */
  pflags = SEVAL_RESETLINE;
  pflags |= (flags & FEVAL_HISTORY) ? 0 : SEVAL_NOHIST;

  if (flags & FEVAL_BUILTIN)
    result = EXECUTION_SUCCESS;

  return_val = setjmp (return_catch);

  /* If `return' was seen outside of a function, but in the script, then
     force parse_and_execute () to clean up. */
  if (return_val)
    {
      parse_and_execute_cleanup ();
      result = return_catch_value;
    }
  else
    result = parse_and_execute (string, filename, pflags);

  if (flags & FEVAL_UNWINDPROT)
    run_unwind_frame ("_evalfile");
  else
    {
      if (flags & FEVAL_NONINT)
	interactive = old_interactive;
      return_catch_flag--;
      sourcelevel--;
      COPY_PROCENV (old_return_catch, return_catch);
    }

#if defined (ARRAY_VARS)
  /* These two variables cannot be unset, and cannot be affected by the
     sourced file. */
  array_pop (bash_source_a);
  array_pop (bash_lineno_a);

  /* FUNCNAME can be unset, and so can potentially be changed by the
     sourced file. */
  GET_ARRAY_FROM_VAR ("FUNCNAME", nfv, funcname_a);
  if (nfv == funcname_v)
    array_pop (funcname_a);
#  if defined (DEBUGGER)
  if ((flags & FEVAL_NOPUSHARGS) == 0)
    {
      array_pop (bash_argc_a);
      array_pop (bash_argv_a);
    }
#  endif
#endif

  return ((flags & FEVAL_BUILTIN) ? result : 1);
}
warning: parse error {
  volatile int old_interactive;
  procenv_t old_return_catch;
  int return_val, fd, result, pflags, i, nnull;
  ssize_t nr;			/* return value from read(2) */
  char *string;
  struct stat finfo;
  size_t file_size;
  sh_vmsg_func_t *errfunc;
#if defined (ARRAY_VARS)
  SHELL_VAR *funcname_v, *nfv, *bash_source_v, *bash_lineno_v;
  ARRAY *funcname_a, *bash_source_a, *bash_lineno_a;
#  if defined (DEBUGGER)
  SHELL_VAR *bash_argv_v, *bash_argc_v;
  ARRAY *bash_argv_a, *bash_argc_a;
#  endif
  char *t, tt[2];
#endif

  USE_VAR(pflags);

#if defined (ARRAY_VARS)
  GET_ARRAY_FROM_VAR ("FUNCNAME", funcname_v, funcname_a);
  GET_ARRAY_FROM_VAR ("BASH_SOURCE", bash_source_v, bash_source_a);
  GET_ARRAY_FROM_VAR ("BASH_LINENO", bash_lineno_v, bash_lineno_a);
#  if defined (DEBUGGER)
  GET_ARRAY_FROM_VAR ("BASH_ARGV", bash_argv_v, bash_argv_a);
  GET_ARRAY_FROM_VAR ("BASH_ARGC", bash_argc_v, bash_argc_a);
#  endif
#endif
  
  fd = open (filename, O_RDONLY);

  if (fd < 0 || (fstat (fd, &finfo) == -1))
    {
file_error_and_exit:
      if (((flags & FEVAL_ENOENTOK) == 0) || errno != ENOENT)
	file_error (filename);

      if (flags & FEVAL_LONGJMP)
	{
	  last_command_exit_value = 1;
	  jump_to_top_level (EXITPROG);
	}

      return ((flags & FEVAL_BUILTIN) ? EXECUTION_FAILURE
      				      : ((errno == ENOENT) ? 0 : -1));
    }

  errfunc = ((flags & FEVAL_BUILTIN) ? builtin_error : internal_error);

  if (S_ISDIR (finfo.st_mode))
    {
      (*errfunc) (_("%s: is a directory"), filename);
      return ((flags & FEVAL_BUILTIN) ? EXECUTION_FAILURE : -1);
    }
  else if ((flags & FEVAL_REGFILE) && S_ISREG (finfo.st_mode) == 0)
    {
      (*errfunc) (_("%s: not a regular file"), filename);
      return ((flags & FEVAL_BUILTIN) ? EXECUTION_FAILURE : -1);
    }

  file_size = (size_t)finfo.st_size;
  /* Check for overflow with large files. */
  if (file_size != finfo.st_size || file_size + 1 < file_size)
    {
      (*errfunc) (_("%s: file is too large"), filename);
      return ((flags & FEVAL_BUILTIN) ? EXECUTION_FAILURE : -1);
    }      

  if (S_ISREG (finfo.st_mode) && file_size <= SSIZE_MAX)
    {
      string = (char *)xmalloc (1 + file_size);
      nr = read (fd, string, file_size);
      if (nr >= 0)
	string[nr] = '\0';
    }
  else
    nr = zmapfd (fd, &string, 0);

  return_val = errno;
  close (fd);
  errno = return_val;

  if (nr < 0)		/* XXX was != file_size, not < 0 */
    {
      free (string);
      goto file_error_and_exit;
    }

  if (nr == 0)
    {
      free (string);
      return ((flags & FEVAL_BUILTIN) ? EXECUTION_SUCCESS : 1);
    }
      
  if ((flags & FEVAL_CHECKBINARY) && 
      check_binary_file (string, (nr > 80) ? 80 : nr))
    {
      free (string);
      (*errfunc) (_("%s: cannot execute binary file"), filename);
      return ((flags & FEVAL_BUILTIN) ? EX_BINARY_FILE : -1);
    }

  i = strlen (string);
  if (i < nr)
    {
      for (nnull = i = 0; i < nr; i++)
	if (string[i] == '\0')
          {
	    memmove (string+i, string+i+1, nr - i);
	    nr--;
	    /* Even if the `check binary' flag is not set, we want to avoid
	       sourcing files with more than 256 null characters -- that
	       probably indicates a binary file. */
	    if ((flags & FEVAL_BUILTIN) && ++nnull > 256)
	      {
		free (string);
		(*errfunc) (_("%s: cannot execute binary file"), filename);
		return ((flags & FEVAL_BUILTIN) ? EX_BINARY_FILE : -1);
	      }
          }
    }

  if (flags & FEVAL_UNWINDPROT)
    {
      begin_unwind_frame ("_evalfile");

      unwind_protect_int (return_catch_flag);
      unwind_protect_jmp_buf (return_catch);
      if (flags & FEVAL_NONINT)
	unwind_protect_int (interactive);
      unwind_protect_int (sourcelevel);
    }
  else
    {
      COPY_PROCENV (return_catch, old_return_catch);
      if (flags & FEVAL_NONINT)
	old_interactive = interactive;
    }

  if (flags & FEVAL_NONINT)
    interactive = 0;

  return_catch_flag++;
  sourcelevel++;

#if defined (ARRAY_VARS)
  array_push (bash_source_a, (char *)filename);
  t = itos (executing_line_number ());
  array_push (bash_lineno_a, t);
  free (t);
  array_push (funcname_a, "source");	/* not exactly right */
#  if defined (DEBUGGER)
  /* Have to figure out a better way to do this when `source' is supplied
     arguments */
  if ((flags & FEVAL_NOPUSHARGS) == 0)
    {
      array_push (bash_argv_a, (char *)filename);
      tt[0] = '1'; tt[1] = '\0';
      array_push (bash_argc_a, tt);
    }
#  endif
#endif

  /* set the flags to be passed to parse_and_execute */
  pflags = SEVAL_RESETLINE;
  pflags |= (flags & FEVAL_HISTORY) ? 0 : SEVAL_NOHIST;

  if (flags & FEVAL_BUILTIN)
    result = EXECUTION_SUCCESS;

  return_val = setjmp (return_catch);

  /* If `return' was seen outside of a function, but in the script, then
     force parse_and_execute () to clean up. */
  if (return_val)
    {
      parse_and_execute_cleanup ();
      result = return_catch_value;
    }
  else
    result = parse_and_execute (string, filename, pflags);

  if (flags & FEVAL_UNWINDPROT)
    run_unwind_frame ("_evalfile");
  else
    {
      if (flags & FEVAL_NONINT)
	interactive = old_interactive;
      return_catch_flag--;
      sourcelevel--;
      COPY_PROCENV (old_return_catch, return_catch);
    }

#if defined (ARRAY_VARS)
  /* These two variables cannot be unset, and cannot be affected by the
     sourced file. */
  array_pop (bash_source_a);
  array_pop (bash_lineno_a);

  /* FUNCNAME can be unset, and so can potentially be changed by the
     sourced file. */
  GET_ARRAY_FROM_VAR ("FUNCNAME", nfv, funcname_a);
  if (nfv == funcname_v)
    array_pop (funcname_a);
#  if defined (DEBUGGER)
  if ((flags & FEVAL_NOPUSHARGS) == 0)
    {
      array_pop (bash_argc_a);
      array_pop (bash_argv_a);
    }
#  endif
#endif

  return ((flags & FEVAL_BUILTIN) ? result : 1);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\evalfile.c:82
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\evalfile.c:302
parsing error 
{
  char *filename;
  int result, flags;

  filename = bash_tilde_expand (fname, 0);
  flags = FEVAL_ENOENTOK;
  if (force_noninteractive)
    flags |= FEVAL_NONINT;
  result = _evalfile (filename, flags);
  free (filename);
  return result;
}
warning: parse error {
  char *filename;
  int result, flags;

  filename = bash_tilde_expand (fname, 0);
  flags = FEVAL_ENOENTOK;
  if (force_noninteractive)
    flags |= FEVAL_NONINT;
  result = _evalfile (filename, flags);
  free (filename);
  return result;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\evalfile.c:304
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\evalfile.c:333
parsing error 
{
  int flags, rval;

  flags = FEVAL_BUILTIN|FEVAL_UNWINDPROT|FEVAL_NONINT;
  if (sflags)
    flags |= FEVAL_NOPUSHARGS;
  /* POSIX shells exit if non-interactive and file error. */
  if (posixly_correct && interactive_shell == 0 && executing_command_builtin == 0)
    flags |= FEVAL_LONGJMP;
  rval = _evalfile (filename, flags);

  run_return_trap ();
  return rval;
}
warning: parse error {
  int flags, rval;

  flags = FEVAL_BUILTIN|FEVAL_UNWINDPROT|FEVAL_NONINT;
  if (sflags)
    flags |= FEVAL_NOPUSHARGS;
  /* POSIX shells exit if non-interactive and file error. */
  if (posixly_correct && interactive_shell == 0 && executing_command_builtin == 0)
    flags |= FEVAL_LONGJMP;
  rval = _evalfile (filename, flags);

  run_return_trap ();
  return rval;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\evalfile.c:335
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\evalstring.c...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\filecntl.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\bashansi.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\shell.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\jobs.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\flags.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\input.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\execute_cmd.h...skip
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\redir.h...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\stdc.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\trap.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\bashintl.h...skip
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\y.tab.h...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\common.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\evalstring.c:106
parsing error 
{
  char *orig_string;
  int x;

  orig_string = string;
  /* Unwind protect this invocation of parse_and_execute (). */
  begin_unwind_frame (tag);
  unwind_protect_int (parse_and_execute_level);
  unwind_protect_jmp_buf (top_level);
  unwind_protect_int (indirection_level);
  unwind_protect_int (line_number);
  unwind_protect_int (loop_level);
  unwind_protect_int (executing_list);
  unwind_protect_int (comsub_ignore_return);
  if (flags & (SEVAL_NONINT|SEVAL_INTERACT))
    unwind_protect_int (interactive);

#if defined (HISTORY)
  if (parse_and_execute_level == 0)
    add_unwind_protect (set_history_remembering, (char *)NULL);
  else
    unwind_protect_int (remember_on_history);	/* can be used in scripts */
#  if defined (BANG_HISTORY)
  if (interactive_shell)
    unwind_protect_int (history_expansion_inhibited);
#  endif /* BANG_HISTORY */
#endif /* HISTORY */

  if (interactive_shell)
    {
      x = get_current_prompt_level ();
      add_unwind_protect (set_current_prompt_level, x);
    }
  
  add_unwind_protect (pop_stream, (char *)NULL);
  if (orig_string && ((flags & SEVAL_NOFREE) == 0))
    add_unwind_protect (xfree, orig_string);
  end_unwind_frame ();

  if (flags & (SEVAL_NONINT|SEVAL_INTERACT))
    interactive = (flags & SEVAL_NONINT) ? 0 : 1;

#if defined (HISTORY)
  if (flags & SEVAL_NOHIST)
    bash_history_disable ();
#endif /* HISTORY */
}
warning: parse error {
  char *orig_string;
  int x;

  orig_string = string;
  /* Unwind protect this invocation of parse_and_execute (). */
  begin_unwind_frame (tag);
  unwind_protect_int (parse_and_execute_level);
  unwind_protect_jmp_buf (top_level);
  unwind_protect_int (indirection_level);
  unwind_protect_int (line_number);
  unwind_protect_int (loop_level);
  unwind_protect_int (executing_list);
  unwind_protect_int (comsub_ignore_return);
  if (flags & (SEVAL_NONINT|SEVAL_INTERACT))
    unwind_protect_int (interactive);

#if defined (HISTORY)
  if (parse_and_execute_level == 0)
    add_unwind_protect (set_history_remembering, (char *)NULL);
  else
    unwind_protect_int (remember_on_history);	/* can be used in scripts */
#  if defined (BANG_HISTORY)
  if (interactive_shell)
    unwind_protect_int (history_expansion_inhibited);
#  endif /* BANG_HISTORY */
#endif /* HISTORY */

  if (interactive_shell)
    {
      x = get_current_prompt_level ();
      add_unwind_protect (set_current_prompt_level, x);
    }
  
  add_unwind_protect (pop_stream, (char *)NULL);
  if (orig_string && ((flags & SEVAL_NOFREE) == 0))
    add_unwind_protect (xfree, orig_string);
  end_unwind_frame ();

  if (flags & (SEVAL_NONINT|SEVAL_INTERACT))
    interactive = (flags & SEVAL_NONINT) ? 0 : 1;

#if defined (HISTORY)
  if (flags & SEVAL_NOHIST)
    bash_history_disable ();
#endif /* HISTORY */
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\evalstring.c:110
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\evalstring.c:170
parsing error 
{
  int code, lreset;
  volatile int should_jump_to_top_level, last_result;
  COMMAND *volatile command;

  parse_prologue (string, flags, PE_TAG);

  parse_and_execute_level++;

  lreset = flags & SEVAL_RESETLINE;

  /* Reset the line number if the caller wants us to.  If we don't reset the
     line number, we have to subtract one, because we will add one just
     before executing the next command (resetting the line number sets it to
     0; the first line number is 1). */
  push_stream (lreset);
  if (lreset == 0)
    line_number--;
    
  indirection_level++;

  code = should_jump_to_top_level = 0;
  last_result = EXECUTION_SUCCESS;

  with_input_from_string (string, from_file);
  while (*(bash_input.location.string))
    {
      command = (COMMAND *)NULL;

      if (interrupt_state)
	{
	  last_result = EXECUTION_FAILURE;
	  break;
	}

      /* Provide a location for functions which `longjmp (top_level)' to
	 jump to.  This prevents errors in substitution from restarting
	 the reader loop directly, for example. */
      code = setjmp (top_level);

      if (code)
	{
	  should_jump_to_top_level = 0;
	  switch (code)
	    {
	    case FORCE_EOF:
	    case ERREXIT:
	    case EXITPROG:
	      if (command)
		run_unwind_frame ("pe_dispose");
	      /* Remember to call longjmp (top_level) after the old
		 value for it is restored. */
	      should_jump_to_top_level = 1;
	      goto out;

	    case DISCARD:
	      if (command)
		run_unwind_frame ("pe_dispose");
	      last_result = last_command_exit_value = EXECUTION_FAILURE; /* XXX */
	      if (subshell_environment)
		{
		  should_jump_to_top_level = 1;
		  goto out;
		}
	      else
		{
#if 0
		  dispose_command (command);	/* pe_dispose does this */
#endif
		  continue;
		}

	    default:
	      command_error ("parse_and_execute", CMDERR_BADJUMP, code, 0);
	      break;
	    }
	}
	  
      if (parse_command () == 0)
	{
	  if ((flags & SEVAL_PARSEONLY) || (interactive_shell == 0 && read_but_dont_execute))
	    {
	      last_result = EXECUTION_SUCCESS;
	      dispose_command (global_command);
	      global_command = (COMMAND *)NULL;
	    }
	  else if (command = global_command)
	    {
	      struct fd_bitmap *bitmap;

	      bitmap = new_fd_bitmap (FD_BITMAP_SIZE);
	      begin_unwind_frame ("pe_dispose");
	      add_unwind_protect (dispose_fd_bitmap, bitmap);
	      add_unwind_protect (dispose_command, command);	/* XXX */

	      global_command = (COMMAND *)NULL;

	      if ((subshell_environment & SUBSHELL_COMSUB) && comsub_ignore_return)
		command->flags |= CMD_IGNORE_RETURN;

#if defined (ONESHOT)
	      /*
	       * IF
	       *   we were invoked as `bash -c' (startup_state == 2) AND
	       *   parse_and_execute has not been called recursively AND
	       *   we're not running a trap AND
	       *   we have parsed the full command (string == '\0') AND
	       *   we're not going to run the exit trap AND
	       *   we have a simple command without redirections AND
	       *   the command is not being timed AND
	       *   the command's return status is not being inverted
	       * THEN
	       *   tell the execution code that we don't need to fork
	       */
	      if (startup_state == 2 && parse_and_execute_level == 1 &&
		  running_trap == 0 &&
		  *bash_input.location.string == '\0' &&
		  command->type == cm_simple &&
		  signal_is_trapped (EXIT_TRAP) == 0 &&
		  command->redirects == 0 && command->value.Simple->redirects == 0 &&
		  ((command->flags & CMD_TIME_PIPELINE) == 0) &&
		  ((command->flags & CMD_INVERT_RETURN) == 0))
		{
		  command->flags |= CMD_NO_FORK;
		  command->value.Simple->flags |= CMD_NO_FORK;
		}
#endif /* ONESHOT */

	      /* See if this is a candidate for $( <file ). */
	      if (startup_state == 2 &&
		  (subshell_environment & SUBSHELL_COMSUB) &&
		  *bash_input.location.string == '\0' &&
		  command->type == cm_simple && !command->redirects &&
		  (command->flags & CMD_TIME_PIPELINE) == 0 &&
		  command->value.Simple->words == 0 &&
		  command->value.Simple->redirects &&
		  command->value.Simple->redirects->next == 0 &&
		  command->value.Simple->redirects->instruction == r_input_direction)
		{
		  int r;
		  r = cat_file (command->value.Simple->redirects);
		  last_result = (r < 0) ? EXECUTION_FAILURE : EXECUTION_SUCCESS;
		}
	      else
		last_result = execute_command_internal
				(command, 0, NO_PIPE, NO_PIPE, bitmap);

	      dispose_command (command);
	      dispose_fd_bitmap (bitmap);
	      discard_unwind_frame ("pe_dispose");
	    }
	}
      else
	{
	  last_result = EXECUTION_FAILURE;

	  if (interactive_shell == 0 && this_shell_builtin &&
	      (this_shell_builtin == source_builtin || this_shell_builtin == eval_builtin) &&
	      last_command_exit_value == EX_BADSYNTAX && posixly_correct)
	    {
	      should_jump_to_top_level = 1;
	      code = ERREXIT;
	      last_command_exit_value = EX_BADUSAGE;
	    }

	  /* Since we are shell compatible, syntax errors in a script
	     abort the execution of the script.  Right? */
	  break;
	}
    }

 out:

  run_unwind_frame (PE_TAG);

  if (interrupt_state && parse_and_execute_level == 0)
    {
      /* An interrupt during non-interactive execution in an
	 interactive shell (e.g. via $PROMPT_COMMAND) should
	 not cause the shell to exit. */
      interactive = interactive_shell;
      throw_to_top_level ();
    }

  if (should_jump_to_top_level)
    jump_to_top_level (code);

  return (last_result);
}
warning: parse error {
  int code, lreset;
  volatile int should_jump_to_top_level, last_result;
  COMMAND *volatile command;

  parse_prologue (string, flags, PE_TAG);

  parse_and_execute_level++;

  lreset = flags & SEVAL_RESETLINE;

  /* Reset the line number if the caller wants us to.  If we don't reset the
     line number, we have to subtract one, because we will add one just
     before executing the next command (resetting the line number sets it to
     0; the first line number is 1). */
  push_stream (lreset);
  if (lreset == 0)
    line_number--;
    
  indirection_level++;

  code = should_jump_to_top_level = 0;
  last_result = EXECUTION_SUCCESS;

  with_input_from_string (string, from_file);
  while (*(bash_input.location.string))
    {
      command = (COMMAND *)NULL;

      if (interrupt_state)
	{
	  last_result = EXECUTION_FAILURE;
	  break;
	}

      /* Provide a location for functions which `longjmp (top_level)' to
	 jump to.  This prevents errors in substitution from restarting
	 the reader loop directly, for example. */
      code = setjmp (top_level);

      if (code)
	{
	  should_jump_to_top_level = 0;
	  switch (code)
	    {
	    case FORCE_EOF:
	    case ERREXIT:
	    case EXITPROG:
	      if (command)
		run_unwind_frame ("pe_dispose");
	      /* Remember to call longjmp (top_level) after the old
		 value for it is restored. */
	      should_jump_to_top_level = 1;
	      goto out;

	    case DISCARD:
	      if (command)
		run_unwind_frame ("pe_dispose");
	      last_result = last_command_exit_value = EXECUTION_FAILURE; /* XXX */
	      if (subshell_environment)
		{
		  should_jump_to_top_level = 1;
		  goto out;
		}
	      else
		{
#if 0
		  dispose_command (command);	/* pe_dispose does this */
#endif
		  continue;
		}

	    default:
	      command_error ("parse_and_execute", CMDERR_BADJUMP, code, 0);
	      break;
	    }
	}
	  
      if (parse_command () == 0)
	{
	  if ((flags & SEVAL_PARSEONLY) || (interactive_shell == 0 && read_but_dont_execute))
	    {
	      last_result = EXECUTION_SUCCESS;
	      dispose_command (global_command);
	      global_command = (COMMAND *)NULL;
	    }
	  else if (command = global_command)
	    {
	      struct fd_bitmap *bitmap;

	      bitmap = new_fd_bitmap (FD_BITMAP_SIZE);
	      begin_unwind_frame ("pe_dispose");
	      add_unwind_protect (dispose_fd_bitmap, bitmap);
	      add_unwind_protect (dispose_command, command);	/* XXX */

	      global_command = (COMMAND *)NULL;

	      if ((subshell_environment & SUBSHELL_COMSUB) && comsub_ignore_return)
		command->flags |= CMD_IGNORE_RETURN;

#if defined (ONESHOT)
	      /*
	       * IF
	       *   we were invoked as `bash -c' (startup_state == 2) AND
	       *   parse_and_execute has not been called recursively AND
	       *   we're not running a trap AND
	       *   we have parsed the full command (string == '\0') AND
	       *   we're not going to run the exit trap AND
	       *   we have a simple command without redirections AND
	       *   the command is not being timed AND
	       *   the command's return status is not being inverted
	       * THEN
	       *   tell the execution code that we don't need to fork
	       */
	      if (startup_state == 2 && parse_and_execute_level == 1 &&
		  running_trap == 0 &&
		  *bash_input.location.string == '\0' &&
		  command->type == cm_simple &&
		  signal_is_trapped (EXIT_TRAP) == 0 &&
		  command->redirects == 0 && command->value.Simple->redirects == 0 &&
		  ((command->flags & CMD_TIME_PIPELINE) == 0) &&
		  ((command->flags & CMD_INVERT_RETURN) == 0))
		{
		  command->flags |= CMD_NO_FORK;
		  command->value.Simple->flags |= CMD_NO_FORK;
		}
#endif /* ONESHOT */

	      /* See if this is a candidate for $( <file ). */
	      if (startup_state == 2 &&
		  (subshell_environment & SUBSHELL_COMSUB) &&
		  *bash_input.location.string == '\0' &&
		  command->type == cm_simple && !command->redirects &&
		  (command->flags & CMD_TIME_PIPELINE) == 0 &&
		  command->value.Simple->words == 0 &&
		  command->value.Simple->redirects &&
		  command->value.Simple->redirects->next == 0 &&
		  command->value.Simple->redirects->instruction == r_input_direction)
		{
		  int r;
		  r = cat_file (command->value.Simple->redirects);
		  last_result = (r < 0) ? EXECUTION_FAILURE : EXECUTION_SUCCESS;
		}
	      else
		last_result = execute_command_internal
				(command, 0, NO_PIPE, NO_PIPE, bitmap);

	      dispose_command (command);
	      dispose_fd_bitmap (bitmap);
	      discard_unwind_frame ("pe_dispose");
	    }
	}
      else
	{
	  last_result = EXECUTION_FAILURE;

	  if (interactive_shell == 0 && this_shell_builtin &&
	      (this_shell_builtin == source_builtin || this_shell_builtin == eval_builtin) &&
	      last_command_exit_value == EX_BADSYNTAX && posixly_correct)
	    {
	      should_jump_to_top_level = 1;
	      code = ERREXIT;
	      last_command_exit_value = EX_BADUSAGE;
	    }

	  /* Since we are shell compatible, syntax errors in a script
	     abort the execution of the script.  Right? */
	  break;
	}
    }

 out:

  run_unwind_frame (PE_TAG);

  if (interrupt_state && parse_and_execute_level == 0)
    {
      /* An interrupt during non-interactive execution in an
	 interactive shell (e.g. via $PROMPT_COMMAND) should
	 not cause the shell to exit. */
      interactive = interactive_shell;
      throw_to_top_level ();
    }

  if (should_jump_to_top_level)
    jump_to_top_level (code);

  return (last_result);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\evalstring.c:174
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\evalstring.c:370
parsing error 
{
  int code, nc;
  volatile int should_jump_to_top_level;
  COMMAND *volatile command, *oglobal;
  char *ostring;

  parse_prologue (string, flags, PS_TAG);

  /* Reset the line number if the caller wants us to.  If we don't reset the
     line number, we have to subtract one, because we will add one just
     before executing the next command (resetting the line number sets it to
     0; the first line number is 1). */
  push_stream (0);
    
  code = should_jump_to_top_level = 0;
  oglobal = global_command;
  ostring = string;

  with_input_from_string (string, from_file);
  while (*(bash_input.location.string))
    {
      command = (COMMAND *)NULL;

#if 0
      if (interrupt_state)
	break;
#endif

      /* Provide a location for functions which `longjmp (top_level)' to
	 jump to. */
      code = setjmp (top_level);

      if (code)
	{
#if defined (DEBUG)
itrace("parse_string: longjmp executed: code = %d", code);
#endif
	  should_jump_to_top_level = 0;
	  switch (code)
	    {
	    case FORCE_EOF:
	    case ERREXIT:
	    case EXITPROG:
	    case DISCARD:		/* XXX */
	      if (command)
		dispose_command (command);
	      /* Remember to call longjmp (top_level) after the old
		 value for it is restored. */
	      should_jump_to_top_level = 1;
	      goto out;

	    default:
	      command_error ("parse_string", CMDERR_BADJUMP, code, 0);
	      break;
	    }
	}
	  
      if (parse_command () == 0)
	{
	  dispose_command (global_command);
	  global_command = (COMMAND *)NULL;
	}
      else
	{
	  if ((flags & SEVAL_NOLONGJMP) == 0)
	    {
	      should_jump_to_top_level = 1;
	      code = DISCARD;
	    }
	  else
	    reset_parser ();	/* XXX - sets token_to_read */
	  break;
	}

      if (current_token == yacc_EOF || current_token == shell_eof_token)
	  break;
    }

 out:

  global_command = oglobal;
  nc = bash_input.location.string - ostring;
  if (endp)
    *endp = bash_input.location.string;

  run_unwind_frame (PS_TAG);

  if (should_jump_to_top_level)
    jump_to_top_level (code);

  return (nc);
}
warning: parse error {
  int code, nc;
  volatile int should_jump_to_top_level;
  COMMAND *volatile command, *oglobal;
  char *ostring;

  parse_prologue (string, flags, PS_TAG);

  /* Reset the line number if the caller wants us to.  If we don't reset the
     line number, we have to subtract one, because we will add one just
     before executing the next command (resetting the line number sets it to
     0; the first line number is 1). */
  push_stream (0);
    
  code = should_jump_to_top_level = 0;
  oglobal = global_command;
  ostring = string;

  with_input_from_string (string, from_file);
  while (*(bash_input.location.string))
    {
      command = (COMMAND *)NULL;

#if 0
      if (interrupt_state)
	break;
#endif

      /* Provide a location for functions which `longjmp (top_level)' to
	 jump to. */
      code = setjmp (top_level);

      if (code)
	{
#if defined (DEBUG)
itrace("parse_string: longjmp executed: code = %d", code);
#endif
	  should_jump_to_top_level = 0;
	  switch (code)
	    {
	    case FORCE_EOF:
	    case ERREXIT:
	    case EXITPROG:
	    case DISCARD:		/* XXX */
	      if (command)
		dispose_command (command);
	      /* Remember to call longjmp (top_level) after the old
		 value for it is restored. */
	      should_jump_to_top_level = 1;
	      goto out;

	    default:
	      command_error ("parse_string", CMDERR_BADJUMP, code, 0);
	      break;
	    }
	}
	  
      if (parse_command () == 0)
	{
	  dispose_command (global_command);
	  global_command = (COMMAND *)NULL;
	}
      else
	{
	  if ((flags & SEVAL_NOLONGJMP) == 0)
	    {
	      should_jump_to_top_level = 1;
	      code = DISCARD;
	    }
	  else
	    reset_parser ();	/* XXX - sets token_to_read */
	  break;
	}

      if (current_token == yacc_EOF || current_token == shell_eof_token)
	  break;
    }

 out:

  global_command = oglobal;
  nc = bash_input.location.string - ostring;
  if (endp)
    *endp = bash_input.location.string;

  run_unwind_frame (PS_TAG);

  if (should_jump_to_top_level)
    jump_to_top_level (code);

  return (nc);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\evalstring.c:375
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\evalstring.c:472
parsing error 
{
  char *fn;
  int fd, rval;

  if (r->instruction != r_input_direction)
    return -1;

  /* Get the filename. */
  if (posixly_correct && !interactive_shell)
    disallow_filename_globbing++;
  fn = redirection_expand (r->redirectee.filename);
  if (posixly_correct && !interactive_shell)
    disallow_filename_globbing--;

  if (fn == 0)
    {
      redirection_error (r, AMBIGUOUS_REDIRECT);
      return -1;
    }

  fd = open(fn, O_RDONLY);
  if (fd < 0)
    {
      file_error (fn);
      free (fn);
      return -1;
    }

  rval = zcatfd (fd, 1, fn);

  free (fn);
  close (fd);

  return (rval);
}
warning: parse error {
  char *fn;
  int fd, rval;

  if (r->instruction != r_input_direction)
    return -1;

  /* Get the filename. */
  if (posixly_correct && !interactive_shell)
    disallow_filename_globbing++;
  fn = redirection_expand (r->redirectee.filename);
  if (posixly_correct && !interactive_shell)
    disallow_filename_globbing--;

  if (fn == 0)
    {
      redirection_error (r, AMBIGUOUS_REDIRECT);
      return -1;
    }

  fd = open(fn, O_RDONLY);
  if (fd < 0)
    {
      file_error (fn);
      free (fn);
      return -1;
    }

  rval = zcatfd (fd, 1, fn);

  free (fn);
  close (fd);

  return (rval);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\evalstring.c:474
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\getopt.c...
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\memalloc.h...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\bashintl.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\shell.h...skip
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\getopt.h...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\stdc.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\getopt.c:114
parsing error 
{
  char c, *temp;

  sh_optarg = 0;

  if (sh_optind >= argc || sh_optind < 0)	/* XXX was sh_optind > argc */
    {
      sh_optind = argc;
      return (EOF);
    }

  /* Initialize the internal data when the first call is made.
     Start processing options with ARGV-element 1 (since ARGV-element 0
     is the program name); the sequence of previously skipped
     non-option ARGV-elements is empty.  */

  if (sh_optind == 0)
    {
      sh_optind = 1;
      nextchar = (char *)NULL;
    }

  if (nextchar == 0 || *nextchar == '\0')
    {
      /* If we have done all the ARGV-elements, stop the scan. */
      if (sh_optind >= argc)
	return EOF;

      temp = argv[sh_optind];

      /* Special ARGV-element `--' means premature end of options.
	 Skip it like a null option, and return EOF. */
      if (temp[0] == '-' && temp[1] == '-' && temp[2] == '\0')
	{
	  sh_optind++;
	  return EOF;
	}

      /* If we have come to a non-option, either stop the scan or describe
	 it to the caller and pass it by.  This makes the pseudo-option
	 `-' mean the end of options, but does not skip over it. */
      if (temp[0] != '-' || temp[1] == '\0')
	return EOF;

      /* We have found another option-ARGV-element.
	 Start decoding its characters.  */
      nextchar = argv[sh_curopt = sh_optind] + 1;
      sh_charindex = 1;
    }

  /* Look at and handle the next option-character.  */

  c = *nextchar++; sh_charindex++;
  temp = strchr (optstring, c);

  sh_optopt = c;

  /* Increment `sh_optind' when we start to process its last character.  */
  if (nextchar == 0 || *nextchar == '\0')
    {
      sh_optind++;
      nextchar = (char *)NULL;
    }

  if (sh_badopt = (temp == NULL || c == ':'))
    {
      if (sh_opterr)
	BADOPT (c);

      return '?';
    }

  if (temp[1] == ':')
    {
      if (nextchar && *nextchar)
	{
	  /* This is an option that requires an argument.  */
	  sh_optarg = nextchar;
	  /* If we end this ARGV-element by taking the rest as an arg,
	     we must advance to the next element now.  */
	  sh_optind++;
	}
      else if (sh_optind == argc)
	{
	  if (sh_opterr)
	    NEEDARG (c);

	  sh_optopt = c;
	  sh_optarg = "";	/* Needed by getopts. */
	  c = (optstring[0] == ':') ? ':' : '?';
	}
      else
	/* We already incremented `sh_optind' once;
	   increment it again when taking next ARGV-elt as argument.  */
	sh_optarg = argv[sh_optind++];
      nextchar = (char *)NULL;
    }
  return c;
}
warning: parse error {
  char c, *temp;

  sh_optarg = 0;

  if (sh_optind >= argc || sh_optind < 0)	/* XXX was sh_optind > argc */
    {
      sh_optind = argc;
      return (EOF);
    }

  /* Initialize the internal data when the first call is made.
     Start processing options with ARGV-element 1 (since ARGV-element 0
     is the program name); the sequence of previously skipped
     non-option ARGV-elements is empty.  */

  if (sh_optind == 0)
    {
      sh_optind = 1;
      nextchar = (char *)NULL;
    }

  if (nextchar == 0 || *nextchar == '\0')
    {
      /* If we have done all the ARGV-elements, stop the scan. */
      if (sh_optind >= argc)
	return EOF;

      temp = argv[sh_optind];

      /* Special ARGV-element `--' means premature end of options.
	 Skip it like a null option, and return EOF. */
      if (temp[0] == '-' && temp[1] == '-' && temp[2] == '\0')
	{
	  sh_optind++;
	  return EOF;
	}

      /* If we have come to a non-option, either stop the scan or describe
	 it to the caller and pass it by.  This makes the pseudo-option
	 `-' mean the end of options, but does not skip over it. */
      if (temp[0] != '-' || temp[1] == '\0')
	return EOF;

      /* We have found another option-ARGV-element.
	 Start decoding its characters.  */
      nextchar = argv[sh_curopt = sh_optind] + 1;
      sh_charindex = 1;
    }

  /* Look at and handle the next option-character.  */

  c = *nextchar++; sh_charindex++;
  temp = strchr (optstring, c);

  sh_optopt = c;

  /* Increment `sh_optind' when we start to process its last character.  */
  if (nextchar == 0 || *nextchar == '\0')
    {
      sh_optind++;
      nextchar = (char *)NULL;
    }

  if (sh_badopt = (temp == NULL || c == ':'))
    {
      if (sh_opterr)
	BADOPT (c);

      return '?';
    }

  if (temp[1] == ':')
    {
      if (nextchar && *nextchar)
	{
	  /* This is an option that requires an argument.  */
	  sh_optarg = nextchar;
	  /* If we end this ARGV-element by taking the rest as an arg,
	     we must advance to the next element now.  */
	  sh_optind++;
	}
      else if (sh_optind == argc)
	{
	  if (sh_opterr)
	    NEEDARG (c);

	  sh_optopt = c;
	  sh_optarg = "";	/* Needed by getopts. */
	  c = (optstring[0] == ':') ? ':' : '?';
	}
      else
	/* We already incremented `sh_optind' once;
	   increment it again when taking next ARGV-elt as argument.  */
	sh_optarg = argv[sh_optind++];
      nextchar = (char *)NULL;
    }
  return c;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\getopt.c:118
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\getopt.c:219
parsing error 
{
  if (nextchar)
    nextchar = argv[sh_curopt] + sh_charindex;
}
warning: parse error {
  if (nextchar)
    nextchar = argv[sh_curopt] + sh_charindex;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\getopt.c:221
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\mkbuiltins.c...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\posixstat.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\filecntl.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\bashansi.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\stdc.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\mkbuiltins.c:203
parsing error 
{
  int arg_index = 1;
  FILE *structfile, *externfile;
  char *documentation_filename, *temp_struct_filename;

  structfile = externfile = (FILE *)NULL;
  documentation_filename = DOCFILE;
  temp_struct_filename = (char *)NULL;

  while (arg_index < argc && argv[arg_index][0] == '-')
    {
      char *arg = argv[arg_index++];

      if (strcmp (arg, "-externfile") == 0)
	extern_filename = argv[arg_index++];
      else if (strcmp (arg, "-structfile") == 0)
	struct_filename = argv[arg_index++];
      else if (strcmp (arg, "-noproduction") == 0)
	inhibit_production = 1;
      else if (strcmp (arg, "-document") == 0)
	documentation_file = fopen (documentation_filename, "w");
      else if (strcmp (arg, "-D") == 0)
	{
	  int len;

	  if (error_directory)
	    free (error_directory);

	  error_directory = xmalloc (2 + strlen (argv[arg_index]));
	  strcpy (error_directory, argv[arg_index]);
	  len = strlen (error_directory);

	  if (len && error_directory[len - 1] != '/')
	    strcat (error_directory, "/");

	  arg_index++;
	}
      else if (strcmp (arg, "-documentonly") == 0)
	{
	  only_documentation = 1;
	  documentation_file = fopen (documentation_filename, "w");
	}
      else if (strcmp (arg, "-H") == 0)
        {
	  separate_helpfiles = 1;
	  helpfile_directory = argv[arg_index++];
        }
      else if (strcmp (arg, "-S") == 0)
	single_longdoc_strings = 0;
      else
	{
	  fprintf (stderr, "%s: Unknown flag %s.\n", argv[0], arg);
	  exit (2);
	}
    }

  /* If there are no files to process, just quit now. */
  if (arg_index == argc)
    exit (0);

  if (!only_documentation)
    {
      /* Open the files. */
      if (struct_filename)
	{
	  temp_struct_filename = xmalloc (15);
	  sprintf (temp_struct_filename, "mk-%ld", (long) getpid ());
	  structfile = fopen (temp_struct_filename, "w");

	  if (!structfile)
	    file_error (temp_struct_filename);
	}

      if (extern_filename)
	{
	  externfile = fopen (extern_filename, "w");

	  if (!externfile)
	    file_error (extern_filename);
	}

      /* Write out the headers. */
      write_file_headers (structfile, externfile);
    }

  if (documentation_file)
    {
      fprintf (documentation_file, "@c Table of builtins created with %s.\n",
	       argv[0]);
      fprintf (documentation_file, "@ftable @asis\n");
    }

  /* Process the .def files. */
  while (arg_index < argc)
    {
      register char *arg;

      arg = argv[arg_index++];

      extract_info (arg, structfile, externfile);
    }

  /* Close the files. */
  if (!only_documentation)
    {
      /* Write the footers. */
      write_file_footers (structfile, externfile);

      if (structfile)
	{
	  write_longdocs (structfile, saved_builtins);
	  fclose (structfile);
	  rename (temp_struct_filename, struct_filename);
	}

      if (externfile)
	fclose (externfile);
    }

  if (separate_helpfiles)
    {
      write_helpfiles (saved_builtins);
    }

  if (documentation_file)
    {
      fprintf (documentation_file, "@end ftable\n");
      fclose (documentation_file);
    }

  exit (0);
}
warning: parse error {
  int arg_index = 1;
  FILE *structfile, *externfile;
  char *documentation_filename, *temp_struct_filename;

  structfile = externfile = (FILE *)NULL;
  documentation_filename = DOCFILE;
  temp_struct_filename = (char *)NULL;

  while (arg_index < argc && argv[arg_index][0] == '-')
    {
      char *arg = argv[arg_index++];

      if (strcmp (arg, "-externfile") == 0)
	extern_filename = argv[arg_index++];
      else if (strcmp (arg, "-structfile") == 0)
	struct_filename = argv[arg_index++];
      else if (strcmp (arg, "-noproduction") == 0)
	inhibit_production = 1;
      else if (strcmp (arg, "-document") == 0)
	documentation_file = fopen (documentation_filename, "w");
      else if (strcmp (arg, "-D") == 0)
	{
	  int len;

	  if (error_directory)
	    free (error_directory);

	  error_directory = xmalloc (2 + strlen (argv[arg_index]));
	  strcpy (error_directory, argv[arg_index]);
	  len = strlen (error_directory);

	  if (len && error_directory[len - 1] != '/')
	    strcat (error_directory, "/");

	  arg_index++;
	}
      else if (strcmp (arg, "-documentonly") == 0)
	{
	  only_documentation = 1;
	  documentation_file = fopen (documentation_filename, "w");
	}
      else if (strcmp (arg, "-H") == 0)
        {
	  separate_helpfiles = 1;
	  helpfile_directory = argv[arg_index++];
        }
      else if (strcmp (arg, "-S") == 0)
	single_longdoc_strings = 0;
      else
	{
	  fprintf (stderr, "%s: Unknown flag %s.\n", argv[0], arg);
	  exit (2);
	}
    }

  /* If there are no files to process, just quit now. */
  if (arg_index == argc)
    exit (0);

  if (!only_documentation)
    {
      /* Open the files. */
      if (struct_filename)
	{
	  temp_struct_filename = xmalloc (15);
	  sprintf (temp_struct_filename, "mk-%ld", (long) getpid ());
	  structfile = fopen (temp_struct_filename, "w");

	  if (!structfile)
	    file_error (temp_struct_filename);
	}

      if (extern_filename)
	{
	  externfile = fopen (extern_filename, "w");

	  if (!externfile)
	    file_error (extern_filename);
	}

      /* Write out the headers. */
      write_file_headers (structfile, externfile);
    }

  if (documentation_file)
    {
      fprintf (documentation_file, "@c Table of builtins created with %s.\n",
	       argv[0]);
      fprintf (documentation_file, "@ftable @asis\n");
    }

  /* Process the .def files. */
  while (arg_index < argc)
    {
      register char *arg;

      arg = argv[arg_index++];

      extract_info (arg, structfile, externfile);
    }

  /* Close the files. */
  if (!only_documentation)
    {
      /* Write the footers. */
      write_file_footers (structfile, externfile);

      if (structfile)
	{
	  write_longdocs (structfile, saved_builtins);
	  fclose (structfile);
	  rename (temp_struct_filename, struct_filename);
	}

      if (externfile)
	fclose (externfile);
    }

  if (separate_helpfiles)
    {
      write_helpfiles (saved_builtins);
    }

  if (documentation_file)
    {
      fprintf (documentation_file, "@end ftable\n");
      fclose (documentation_file);
    }

  exit (0);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\mkbuiltins.c:206
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\mkbuiltins.c:348
parsing error 
{
  ARRAY *array;

  array = (ARRAY *)xmalloc (sizeof (ARRAY));
  array->size = 0;
  array->sindex = 0;
  array->width = width;

  /* Default to increasing size in units of 20. */
  array->growth_rate = 20;

  array->array = (char **)NULL;

  return (array);
}
warning: parse error {
  ARRAY *array;

  array = (ARRAY *)xmalloc (sizeof (ARRAY));
  array->size = 0;
  array->sindex = 0;
  array->width = width;

  /* Default to increasing size in units of 20. */
  array->growth_rate = 20;

  array->array = (char **)NULL;

  return (array);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\mkbuiltins.c:350
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\mkbuiltins.c:368
parsing error 
{
  register int i;
  ARRAY *copy;

  if (!array)
    return (ARRAY *)NULL;

  copy = array_create (sizeof (char *));

  copy->size = array->size;
  copy->sindex = array->sindex;
  copy->width = array->width;

  copy->array = (char **)xmalloc ((1 + array->sindex) * sizeof (char *));
  
  for (i = 0; i < array->sindex; i++)
    copy->array[i] = savestring (array->array[i]);

  copy->array[i] = (char *)NULL;

  return (copy);
}
warning: parse error {
  register int i;
  ARRAY *copy;

  if (!array)
    return (ARRAY *)NULL;

  copy = array_create (sizeof (char *));

  copy->size = array->size;
  copy->sindex = array->sindex;
  copy->width = array->width;

  copy->array = (char **)xmalloc ((1 + array->sindex) * sizeof (char *));
  
  for (i = 0; i < array->sindex; i++)
    copy->array[i] = savestring (array->array[i]);

  copy->array[i] = (char *)NULL;

  return (copy);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\mkbuiltins.c:370
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\mkbuiltins.c:395
parsing error 
{
  if (array->sindex + 2 > array->size)
    array->array = (char **)xrealloc
      (array->array, (array->size += array->growth_rate) * array->width);

  array->array[array->sindex++] = element;
  array->array[array->sindex] = (char *)NULL;
}
warning: parse error {
  if (array->sindex + 2 > array->size)
    array->array = (char **)xrealloc
      (array->array, (array->size += array->growth_rate) * array->width);

  array->array[array->sindex++] = element;
  array->array[array->sindex] = (char *)NULL;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\mkbuiltins.c:398
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\mkbuiltins.c:409
parsing error 
{
  if (array->array)
    free (array->array);

  free (array);
}
warning: parse error {
  if (array->array)
    free (array->array);

  free (array);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\mkbuiltins.c:411
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\mkbuiltins.c:458
parsing error 
{
  register int i;

  for (i = 0; handlers[i].directive; i++)
    if (strcmp (handlers[i].directive, directive) == 0)
      return (&handlers[i]);

  return ((HANDLER_ENTRY *)NULL);
}
warning: parse error {
  register int i;

  for (i = 0; handlers[i].directive; i++)
    if (strcmp (handlers[i].directive, directive) == 0)
      return (&handlers[i]);

  return ((HANDLER_ENTRY *)NULL);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\mkbuiltins.c:460
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\mkbuiltins.c:488
parsing error 
{
  register int i;
  DEF_FILE *defs;
  struct stat finfo;
  size_t file_size;
  char *buffer, *line;
  int fd, nr;

  if (stat (filename, &finfo) == -1)
    file_error (filename);

  fd = open (filename, O_RDONLY, 0666);

  if (fd == -1)
    file_error (filename);

  file_size = (size_t)finfo.st_size;
  buffer = xmalloc (1 + file_size);

  if ((nr = read (fd, buffer, file_size)) < 0)
    file_error (filename);

  /* This is needed on WIN32, and does not hurt on Unix. */
  if (nr < file_size)
    file_size = nr;

  close (fd);

  if (nr == 0)
    {
      fprintf (stderr, "mkbuiltins: %s: skipping zero-length file\n", filename);
      return;
    }

  /* Create and fill in the initial structure describing this file. */
  defs = (DEF_FILE *)xmalloc (sizeof (DEF_FILE));
  defs->filename = filename;
  defs->lines = array_create (sizeof (char *));
  defs->line_number = 0;
  defs->production = (char *)NULL;
  defs->output = (FILE *)NULL;
  defs->builtins = (ARRAY *)NULL;

  /* Build the array of lines. */
  i = 0;
  while (i < file_size)
    {
      array_add (&buffer[i], defs->lines);

      while (buffer[i] != '\n' && i < file_size)
	i++;
      buffer[i++] = '\0';
    }

  /* Begin processing the input file.  We don't write any output
     until we have a file to write output to. */
  output_cpp_line_info = 1;

  /* Process each line in the array. */
  for (i = 0; line = defs->lines->array[i]; i++)
    {
      defs->line_number = i;

      if (*line == '$')
	{
	  register int j;
	  char *directive;
	  HANDLER_ENTRY *handler;

	  /* Isolate the directive. */
	  for (j = 0; line[j] && !whitespace (line[j]); j++);

	  directive = xmalloc (j);
	  strncpy (directive, line + 1, j - 1);
	  directive[j -1] = '\0';

	  /* Get the function handler and call it. */
	  handler = find_directive (directive);

	  if (!handler)
	    {
	      line_error (defs, "Unknown directive `%s'", directive);
	      free (directive);
	      continue;
	    }
	  else
	    {
	      /* Advance to the first non-whitespace character. */
	      while (whitespace (line[j]))
		j++;

	      /* Call the directive handler with the FILE, and ARGS. */
	      (*(handler->function)) (directive, defs, line + j);
	    }
	  free (directive);
	}
      else
	{
	  if (building_builtin)
	    add_documentation (defs, line);
	  else if (defs->output)
	    {
	      if (output_cpp_line_info)
		{
		  /* If we're handed an absolute pathname, don't prepend
		     the directory name. */
		  if (defs->filename[0] == '/')
		    fprintf (defs->output, "#line %d \"%s\"\n",
			     defs->line_number + 1, defs->filename);
		  else
		    fprintf (defs->output, "#line %d \"%s%s\"\n",
			     defs->line_number + 1,
			     error_directory ? error_directory : "./",
			     defs->filename);
		  output_cpp_line_info = 0;
		}

	      fprintf (defs->output, "%s\n", line);
	    }
	}
    }

  /* Close the production file. */
  if (defs->output)
    fclose (defs->output);

  /* The file has been processed.  Write the accumulated builtins to
     the builtins.c file, and write the extern definitions to the
     builtext.h file. */
  write_builtins (defs, structfile, externfile);

  free (buffer);
  free_defs (defs);
}
warning: parse error {
  register int i;
  DEF_FILE *defs;
  struct stat finfo;
  size_t file_size;
  char *buffer, *line;
  int fd, nr;

  if (stat (filename, &finfo) == -1)
    file_error (filename);

  fd = open (filename, O_RDONLY, 0666);

  if (fd == -1)
    file_error (filename);

  file_size = (size_t)finfo.st_size;
  buffer = xmalloc (1 + file_size);

  if ((nr = read (fd, buffer, file_size)) < 0)
    file_error (filename);

  /* This is needed on WIN32, and does not hurt on Unix. */
  if (nr < file_size)
    file_size = nr;

  close (fd);

  if (nr == 0)
    {
      fprintf (stderr, "mkbuiltins: %s: skipping zero-length file\n", filename);
      return;
    }

  /* Create and fill in the initial structure describing this file. */
  defs = (DEF_FILE *)xmalloc (sizeof (DEF_FILE));
  defs->filename = filename;
  defs->lines = array_create (sizeof (char *));
  defs->line_number = 0;
  defs->production = (char *)NULL;
  defs->output = (FILE *)NULL;
  defs->builtins = (ARRAY *)NULL;

  /* Build the array of lines. */
  i = 0;
  while (i < file_size)
    {
      array_add (&buffer[i], defs->lines);

      while (buffer[i] != '\n' && i < file_size)
	i++;
      buffer[i++] = '\0';
    }

  /* Begin processing the input file.  We don't write any output
     until we have a file to write output to. */
  output_cpp_line_info = 1;

  /* Process each line in the array. */
  for (i = 0; line = defs->lines->array[i]; i++)
    {
      defs->line_number = i;

      if (*line == '$')
	{
	  register int j;
	  char *directive;
	  HANDLER_ENTRY *handler;

	  /* Isolate the directive. */
	  for (j = 0; line[j] && !whitespace (line[j]); j++);

	  directive = xmalloc (j);
	  strncpy (directive, line + 1, j - 1);
	  directive[j -1] = '\0';

	  /* Get the function handler and call it. */
	  handler = find_directive (directive);

	  if (!handler)
	    {
	      line_error (defs, "Unknown directive `%s'", directive);
	      free (directive);
	      continue;
	    }
	  else
	    {
	      /* Advance to the first non-whitespace character. */
	      while (whitespace (line[j]))
		j++;

	      /* Call the directive handler with the FILE, and ARGS. */
	      (*(handler->function)) (directive, defs, line + j);
	    }
	  free (directive);
	}
      else
	{
	  if (building_builtin)
	    add_documentation (defs, line);
	  else if (defs->output)
	    {
	      if (output_cpp_line_info)
		{
		  /* If we're handed an absolute pathname, don't prepend
		     the directory name. */
		  if (defs->filename[0] == '/')
		    fprintf (defs->output, "#line %d \"%s\"\n",
			     defs->line_number + 1, defs->filename);
		  else
		    fprintf (defs->output, "#line %d \"%s%s\"\n",
			     defs->line_number + 1,
			     error_directory ? error_directory : "./",
			     defs->filename);
		  output_cpp_line_info = 0;
		}

	      fprintf (defs->output, "%s\n", line);
	    }
	}
    }

  /* Close the production file. */
  if (defs->output)
    fclose (defs->output);

  /* The file has been processed.  Write the accumulated builtins to
     the builtins.c file, and write the extern definitions to the
     builtext.h file. */
  write_builtins (defs, structfile, externfile);

  free (buffer);
  free_defs (defs);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\mkbuiltins.c:491
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\mkbuiltins.c:629
parsing error 
{
  register int i;

  free_safely (builtin->name);
  free_safely (builtin->function);
  free_safely (builtin->shortdoc);
  free_safely (builtin->docname);

  if (builtin->longdoc)
    array_free (builtin->longdoc);

  if (builtin->dependencies)
    {
      for (i = 0; builtin->dependencies->array[i]; i++)
	free (builtin->dependencies->array[i]);
      array_free (builtin->dependencies);
    }
}
warning: parse error {
  register int i;

  free_safely (builtin->name);
  free_safely (builtin->function);
  free_safely (builtin->shortdoc);
  free_safely (builtin->docname);

  if (builtin->longdoc)
    array_free (builtin->longdoc);

  if (builtin->dependencies)
    {
      for (i = 0; builtin->dependencies->array[i]; i++)
	free (builtin->dependencies->array[i]);
      array_free (builtin->dependencies);
    }
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\mkbuiltins.c:631
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\mkbuiltins.c:652
parsing error 
{
  register int i;
  register BUILTIN_DESC *builtin;

  if (defs->production)
    free (defs->production);

  if (defs->lines)
    array_free (defs->lines);

  if (defs->builtins)
    {
      for (i = 0; builtin = (BUILTIN_DESC *)defs->builtins->array[i]; i++)
	{
	  free_builtin (builtin);
	  free (builtin);
	}
      array_free (defs->builtins);
    }
  free (defs);
}
warning: parse error {
  register int i;
  register BUILTIN_DESC *builtin;

  if (defs->production)
    free (defs->production);

  if (defs->lines)
    array_free (defs->lines);

  if (defs->builtins)
    {
      for (i = 0; builtin = (BUILTIN_DESC *)defs->builtins->array[i]; i++)
	{
	  free_builtin (builtin);
	  free (builtin);
	}
      array_free (defs->builtins);
    }
  free (defs);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\mkbuiltins.c:654
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\mkbuiltins.c:685
parsing error 
{
  while (whitespace (*string))
      string++;

  remove_trailing_whitespace (string);
  return (string);
}
warning: parse error {
  while (whitespace (*string))
      string++;

  remove_trailing_whitespace (string);
  return (string);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\mkbuiltins.c:687
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\mkbuiltins.c:697
parsing error 
{
  register int i;

  i = strlen (string) - 1;

  while (i > 0 && whitespace (string[i]))
    i--;

  string[++i] = '\0';
}
warning: parse error {
  register int i;

  i = strlen (string) - 1;

  while (i > 0 && whitespace (string[i]))
    i--;

  string[++i] = '\0';
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\mkbuiltins.c:699
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\mkbuiltins.c:715
parsing error 
{
  char *new;

  new = strip_whitespace (string);

  if (!*new)
    line_error (defs, "%s requires an argument", for_whom);

  return (savestring (new));
}
warning: parse error {
  char *new;

  new = strip_whitespace (string);

  if (!*new)
    line_error (defs, "%s requires an argument", for_whom);

  return (savestring (new));
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\mkbuiltins.c:718
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\mkbuiltins.c:731
parsing error 
{
  if (!building_builtin)
    line_error (defs, "%s must be inside of a $BUILTIN block", directive);
}
warning: parse error {
  if (!building_builtin)
    line_error (defs, "%s must be inside of a $BUILTIN block", directive);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\mkbuiltins.c:734
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\mkbuiltins.c:741
parsing error 
{
  must_be_building (directive, defs);
  if (defs->builtins)
    return ((BUILTIN_DESC *)defs->builtins->array[defs->builtins->sindex - 1]);
  else
    return ((BUILTIN_DESC *)NULL);
}
warning: parse error {
  must_be_building (directive, defs);
  if (defs->builtins)
    return ((BUILTIN_DESC *)defs->builtins->array[defs->builtins->sindex - 1]);
  else
    return ((BUILTIN_DESC *)NULL);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\mkbuiltins.c:744
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\mkbuiltins.c:755
parsing error 
{
  register BUILTIN_DESC *builtin;

  builtin = current_builtin ("(implied LONGDOC)", defs);

  remove_trailing_whitespace (line);

  if (!*line && !builtin->longdoc)
    return;

  if (!builtin->longdoc)
    builtin->longdoc = array_create (sizeof (char *));

  array_add (line, builtin->longdoc);
}
warning: parse error {
  register BUILTIN_DESC *builtin;

  builtin = current_builtin ("(implied LONGDOC)", defs);

  remove_trailing_whitespace (line);

  if (!*line && !builtin->longdoc)
    return;

  if (!builtin->longdoc)
    builtin->longdoc = array_create (sizeof (char *));

  array_add (line, builtin->longdoc);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\mkbuiltins.c:758
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\mkbuiltins.c:776
parsing error 
{
  BUILTIN_DESC *new;
  char *name;

  /* If we are already building a builtin, we cannot start a new one. */
  if (building_builtin)
    {
      line_error (defs, "%s found before $END", self);
      return (-1);
    }

  output_cpp_line_info++;

  /* Get the name of this builtin, and stick it in the array. */
  name = get_arg (self, defs, arg);

  /* If this is the first builtin, create the array to hold them. */
  if (!defs->builtins)
    defs->builtins = array_create (sizeof (BUILTIN_DESC *));

  new = (BUILTIN_DESC *)xmalloc (sizeof (BUILTIN_DESC));
  new->name = name;
  new->function = (char *)NULL;
  new->shortdoc = (char *)NULL;
  new->docname = (char *)NULL;
  new->longdoc = (ARRAY *)NULL;
  new->dependencies = (ARRAY *)NULL;
  new->flags = 0;

  if (is_special_builtin (name))
    new->flags |= BUILTIN_FLAG_SPECIAL;
  if (is_assignment_builtin (name))
    new->flags |= BUILTIN_FLAG_ASSIGNMENT;
  if (is_posix_builtin (name))
    new->flags |= BUILTIN_FLAG_POSIX_BUILTIN;

  array_add ((char *)new, defs->builtins);
  building_builtin = 1;

  return (0);
}
warning: parse error {
  BUILTIN_DESC *new;
  char *name;

  /* If we are already building a builtin, we cannot start a new one. */
  if (building_builtin)
    {
      line_error (defs, "%s found before $END", self);
      return (-1);
    }

  output_cpp_line_info++;

  /* Get the name of this builtin, and stick it in the array. */
  name = get_arg (self, defs, arg);

  /* If this is the first builtin, create the array to hold them. */
  if (!defs->builtins)
    defs->builtins = array_create (sizeof (BUILTIN_DESC *));

  new = (BUILTIN_DESC *)xmalloc (sizeof (BUILTIN_DESC));
  new->name = name;
  new->function = (char *)NULL;
  new->shortdoc = (char *)NULL;
  new->docname = (char *)NULL;
  new->longdoc = (ARRAY *)NULL;
  new->dependencies = (ARRAY *)NULL;
  new->flags = 0;

  if (is_special_builtin (name))
    new->flags |= BUILTIN_FLAG_SPECIAL;
  if (is_assignment_builtin (name))
    new->flags |= BUILTIN_FLAG_ASSIGNMENT;
  if (is_posix_builtin (name))
    new->flags |= BUILTIN_FLAG_POSIX_BUILTIN;

  array_add ((char *)new, defs->builtins);
  building_builtin = 1;

  return (0);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\mkbuiltins.c:780
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\mkbuiltins.c:824
parsing error 
{
  register BUILTIN_DESC *builtin;

  builtin = current_builtin (self, defs);

  if (builtin == 0)
    {
      line_error (defs, "syntax error: no current builtin for $FUNCTION directive");
      exit (1);
    }
  if (builtin->function)
    line_error (defs, "%s already has a function (%s)",
		builtin->name, builtin->function);
  else
    builtin->function = get_arg (self, defs, arg);

  return (0);
}
warning: parse error {
  register BUILTIN_DESC *builtin;

  builtin = current_builtin (self, defs);

  if (builtin == 0)
    {
      line_error (defs, "syntax error: no current builtin for $FUNCTION directive");
      exit (1);
    }
  if (builtin->function)
    line_error (defs, "%s already has a function (%s)",
		builtin->name, builtin->function);
  else
    builtin->function = get_arg (self, defs, arg);

  return (0);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\mkbuiltins.c:828
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\mkbuiltins.c:849
parsing error 
{
  register BUILTIN_DESC *builtin;

  builtin = current_builtin (self, defs);

  if (builtin->docname)
    line_error (defs, "%s already had a docname (%s)",
		builtin->name, builtin->docname);
  else
    builtin->docname = get_arg (self, defs, arg);

  return (0);
}
warning: parse error {
  register BUILTIN_DESC *builtin;

  builtin = current_builtin (self, defs);

  if (builtin->docname)
    line_error (defs, "%s already had a docname (%s)",
		builtin->name, builtin->docname);
  else
    builtin->docname = get_arg (self, defs, arg);

  return (0);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\mkbuiltins.c:853
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\mkbuiltins.c:869
parsing error 
{
  register BUILTIN_DESC *builtin;

  builtin = current_builtin (self, defs);

  if (builtin->shortdoc)
    line_error (defs, "%s already has short documentation (%s)",
		builtin->name, builtin->shortdoc);
  else
    builtin->shortdoc = get_arg (self, defs, arg);

  return (0);
}
warning: parse error {
  register BUILTIN_DESC *builtin;

  builtin = current_builtin (self, defs);

  if (builtin->shortdoc)
    line_error (defs, "%s already has short documentation (%s)",
		builtin->name, builtin->shortdoc);
  else
    builtin->shortdoc = get_arg (self, defs, arg);

  return (0);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\mkbuiltins.c:873
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\mkbuiltins.c:889
parsing error 
{
  return (0);
}
warning: parse error {
  return (0);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\mkbuiltins.c:893
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\mkbuiltins.c:899
parsing error 
{
  register BUILTIN_DESC *builtin;
  char *dependent;

  builtin = current_builtin (self, defs);
  dependent = get_arg (self, defs, arg);

  if (!builtin->dependencies)
    builtin->dependencies = array_create (sizeof (char *));

  array_add (dependent, builtin->dependencies);

  return (0);
}
warning: parse error {
  register BUILTIN_DESC *builtin;
  char *dependent;

  builtin = current_builtin (self, defs);
  dependent = get_arg (self, defs, arg);

  if (!builtin->dependencies)
    builtin->dependencies = array_create (sizeof (char *));

  array_add (dependent, builtin->dependencies);

  return (0);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\mkbuiltins.c:903
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\mkbuiltins.c:920
parsing error 
{
  /* If just hacking documentation, don't change any of the production
     files. */
  if (only_documentation)
    return (0);

  output_cpp_line_info++;

  if (defs->production)
    line_error (defs, "%s already has a %s definition", defs->filename, self);
  else
    {
      defs->production = get_arg (self, defs, arg);

      if (inhibit_production)
	return (0);

      defs->output = fopen (defs->production, "w");

      if (!defs->output)
	file_error (defs->production);

      fprintf (defs->output, "/* %s, created from %s. */\n",
	       defs->production, defs->filename);
    }
  return (0);
}
warning: parse error {
  /* If just hacking documentation, don't change any of the production
     files. */
  if (only_documentation)
    return (0);

  output_cpp_line_info++;

  if (defs->production)
    line_error (defs, "%s already has a %s definition", defs->filename, self);
  else
    {
      defs->production = get_arg (self, defs, arg);

      if (inhibit_production)
	return (0);

      defs->output = fopen (defs->production, "w");

      if (!defs->output)
	file_error (defs->production);

      fprintf (defs->output, "/* %s, created from %s. */\n",
	       defs->production, defs->filename);
    }
  return (0);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\mkbuiltins.c:924
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\mkbuiltins.c:954
parsing error 
{
  must_be_building (self, defs);
  building_builtin = 0;
  return (0);
}
warning: parse error {
  must_be_building (self, defs);
  building_builtin = 0;
  return (0);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\mkbuiltins.c:958
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\mkbuiltins.c:972
parsing error 
{
  if (defs->filename[0] != '/')
    fprintf (stderr, "%s", error_directory ? error_directory : "./");
  fprintf (stderr, "%s:%d:", defs->filename, defs->line_number + 1);
  fprintf (stderr, format, arg1, arg2);
  fprintf (stderr, "\n");
  fflush (stderr);
}
warning: parse error {
  if (defs->filename[0] != '/')
    fprintf (stderr, "%s", error_directory ? error_directory : "./");
  fprintf (stderr, "%s:%d:", defs->filename, defs->line_number + 1);
  fprintf (stderr, format, arg1, arg2);
  fprintf (stderr, "\n");
  fflush (stderr);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\mkbuiltins.c:975
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\mkbuiltins.c:986
parsing error 
{
  perror (filename);
  exit (2);
}
warning: parse error {
  perror (filename);
  exit (2);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\mkbuiltins.c:988
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\mkbuiltins.c:1,002
parsing error 
{
  char *temp = (char *)malloc (bytes);

  if (!temp)
    memory_error_and_abort ();
  return (temp);
}
warning: parse error {
  char *temp = (char *)malloc (bytes);

  if (!temp)
    memory_error_and_abort ();
  return (temp);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\mkbuiltins.c:1,004
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\mkbuiltins.c:1,013
parsing error 
{
  char *temp;

  if (!pointer)
    temp = (char *)malloc (bytes);
  else
    temp = (char *)realloc (pointer, bytes);

  if (!temp)
    memory_error_and_abort ();

  return (temp);
}
warning: parse error {
  char *temp;

  if (!pointer)
    temp = (char *)malloc (bytes);
  else
    temp = (char *)realloc (pointer, bytes);

  if (!temp)
    memory_error_and_abort ();

  return (temp);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\mkbuiltins.c:1,016
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\mkbuiltins.c:1,046
parsing error 
{
  BUILTIN_DESC *new;

  new = (BUILTIN_DESC *)xmalloc (sizeof (BUILTIN_DESC));

  new->name = savestring (builtin->name);
  new->shortdoc = savestring (builtin->shortdoc);
  new->longdoc = copy_string_array (builtin->longdoc);
  new->dependencies = copy_string_array (builtin->dependencies);

  new->function =
    builtin->function ? savestring (builtin->function) : (char *)NULL;
  new->docname =
    builtin->docname  ? savestring (builtin->docname)  : (char *)NULL;

  return (new);
}
warning: parse error {
  BUILTIN_DESC *new;

  new = (BUILTIN_DESC *)xmalloc (sizeof (BUILTIN_DESC));

  new->name = savestring (builtin->name);
  new->shortdoc = savestring (builtin->shortdoc);
  new->longdoc = copy_string_array (builtin->longdoc);
  new->dependencies = copy_string_array (builtin->dependencies);

  new->function =
    builtin->function ? savestring (builtin->function) : (char *)NULL;
  new->docname =
    builtin->docname  ? savestring (builtin->docname)  : (char *)NULL;

  return (new);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\mkbuiltins.c:1,048
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\mkbuiltins.c:1,068
parsing error 
{
  BUILTIN_DESC *newbuiltin;

  newbuiltin = copy_builtin (builtin);

  /* If this is the first builtin to be saved, create the array
     to hold it. */
  if (!saved_builtins)
      saved_builtins = array_create (sizeof (BUILTIN_DESC *));

  array_add ((char *)newbuiltin, saved_builtins);
}
warning: parse error {
  BUILTIN_DESC *newbuiltin;

  newbuiltin = copy_builtin (builtin);

  /* If this is the first builtin to be saved, create the array
     to hold it. */
  if (!saved_builtins)
      saved_builtins = array_create (sizeof (BUILTIN_DESC *));

  array_add ((char *)newbuiltin, saved_builtins);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\mkbuiltins.c:1,070
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\mkbuiltins.c:1,144
parsing error 
{
  register int i;

  if (structfile)
    {
      for (i = 0; structfile_header[i]; i++)
	fprintf (structfile, "%s\n", structfile_header[i]);

      fprintf (structfile, "#include \"%s\"\n",
	       extern_filename ? extern_filename : "builtext.h");

      fprintf (structfile, "#include \"bashintl.h\"\n");

      fprintf (structfile, "\nstruct builtin static_shell_builtins[] = {\n");
    }

  if (externfile)
    fprintf (externfile,
	     "/* %s - The list of builtins found in libbuiltins.a. */\n",
	     extern_filename ? extern_filename : "builtext.h");
}
warning: parse error {
  register int i;

  if (structfile)
    {
      for (i = 0; structfile_header[i]; i++)
	fprintf (structfile, "%s\n", structfile_header[i]);

      fprintf (structfile, "#include \"%s\"\n",
	       extern_filename ? extern_filename : "builtext.h");

      fprintf (structfile, "#include \"bashintl.h\"\n");

      fprintf (structfile, "\nstruct builtin static_shell_builtins[] = {\n");
    }

  if (externfile)
    fprintf (externfile,
	     "/* %s - The list of builtins found in libbuiltins.a. */\n",
	     extern_filename ? extern_filename : "builtext.h");
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\mkbuiltins.c:1,146
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\mkbuiltins.c:1,171
parsing error 
{
  register int i;

  /* Write out the footers. */
  if (structfile)
    {
      for (i = 0; structfile_footer[i]; i++)
	fprintf (structfile, "%s\n", structfile_footer[i]);
    }
}
warning: parse error {
  register int i;

  /* Write out the footers. */
  if (structfile)
    {
      for (i = 0; structfile_footer[i]; i++)
	fprintf (structfile, "%s\n", structfile_footer[i]);
    }
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\mkbuiltins.c:1,173
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\mkbuiltins.c:1,187
parsing error 
{
  register int i;

  /* Write out the information. */
  if (defs->builtins)
    {
      register BUILTIN_DESC *builtin;

      for (i = 0; i < defs->builtins->sindex; i++)
	{
	  builtin = (BUILTIN_DESC *)defs->builtins->array[i];

	  /* Write out any #ifdefs that may be there. */
	  if (!only_documentation)
	    {
	      if (builtin->dependencies)
		{
		  write_ifdefs (externfile, builtin->dependencies->array);
		  write_ifdefs (structfile, builtin->dependencies->array);
		}

	      /* Write the extern definition. */
	      if (externfile)
		{
		  if (builtin->function)
		    fprintf (externfile, "extern int %s __P((WORD_LIST *));\n",
			     builtin->function);

		  fprintf (externfile, "extern char * const %s_doc[];\n",
			   document_name (builtin));
		}

	      /* Write the structure definition. */
	      if (structfile)
		{
		  fprintf (structfile, "  { \"%s\", ", builtin->name);

		  if (builtin->function)
		    fprintf (structfile, "%s, ", builtin->function);
		  else
		    fprintf (structfile, "(sh_builtin_func_t *)0x0, ");

		  fprintf (structfile, "%s%s%s%s, %s_doc,\n",
		    "BUILTIN_ENABLED | STATIC_BUILTIN",
		    (builtin->flags & BUILTIN_FLAG_SPECIAL) ? " | SPECIAL_BUILTIN" : "",
		    (builtin->flags & BUILTIN_FLAG_ASSIGNMENT) ? " | ASSIGNMENT_BUILTIN" : "",
		    (builtin->flags & BUILTIN_FLAG_POSIX_BUILTIN) ? " | POSIX_BUILTIN" : "",
		    document_name (builtin));

		  fprintf
		    (structfile, "     N_(\"%s\"), (char *)NULL },\n",
		     builtin->shortdoc ? builtin->shortdoc : builtin->name);

		}

	      if (structfile || separate_helpfiles)
		/* Save away this builtin for later writing of the
		   long documentation strings. */
		save_builtin (builtin);

	      /* Write out the matching #endif, if neccessary. */
	      if (builtin->dependencies)
		{
		  if (externfile)
		    write_endifs (externfile, builtin->dependencies->array);

		  if (structfile)
		    write_endifs (structfile, builtin->dependencies->array);
		}
	    }

	  if (documentation_file)
	    {
	      fprintf (documentation_file, "@item %s\n", builtin->name);
	      write_documentation
		(documentation_file, builtin->longdoc->array, 0, TEXINFO);
	    }
	}
    }
}
warning: parse error {
  register int i;

  /* Write out the information. */
  if (defs->builtins)
    {
      register BUILTIN_DESC *builtin;

      for (i = 0; i < defs->builtins->sindex; i++)
	{
	  builtin = (BUILTIN_DESC *)defs->builtins->array[i];

	  /* Write out any #ifdefs that may be there. */
	  if (!only_documentation)
	    {
	      if (builtin->dependencies)
		{
		  write_ifdefs (externfile, builtin->dependencies->array);
		  write_ifdefs (structfile, builtin->dependencies->array);
		}

	      /* Write the extern definition. */
	      if (externfile)
		{
		  if (builtin->function)
		    fprintf (externfile, "extern int %s __P((WORD_LIST *));\n",
			     builtin->function);

		  fprintf (externfile, "extern char * const %s_doc[];\n",
			   document_name (builtin));
		}

	      /* Write the structure definition. */
	      if (structfile)
		{
		  fprintf (structfile, "  { \"%s\", ", builtin->name);

		  if (builtin->function)
		    fprintf (structfile, "%s, ", builtin->function);
		  else
		    fprintf (structfile, "(sh_builtin_func_t *)0x0, ");

		  fprintf (structfile, "%s%s%s%s, %s_doc,\n",
		    "BUILTIN_ENABLED | STATIC_BUILTIN",
		    (builtin->flags & BUILTIN_FLAG_SPECIAL) ? " | SPECIAL_BUILTIN" : "",
		    (builtin->flags & BUILTIN_FLAG_ASSIGNMENT) ? " | ASSIGNMENT_BUILTIN" : "",
		    (builtin->flags & BUILTIN_FLAG_POSIX_BUILTIN) ? " | POSIX_BUILTIN" : "",
		    document_name (builtin));

		  fprintf
		    (structfile, "     N_(\"%s\"), (char *)NULL },\n",
		     builtin->shortdoc ? builtin->shortdoc : builtin->name);

		}

	      if (structfile || separate_helpfiles)
		/* Save away this builtin for later writing of the
		   long documentation strings. */
		save_builtin (builtin);

	      /* Write out the matching #endif, if neccessary. */
	      if (builtin->dependencies)
		{
		  if (externfile)
		    write_endifs (externfile, builtin->dependencies->array);

		  if (structfile)
		    write_endifs (structfile, builtin->dependencies->array);
		}
	    }

	  if (documentation_file)
	    {
	      fprintf (documentation_file, "@item %s\n", builtin->name);
	      write_documentation
		(documentation_file, builtin->longdoc->array, 0, TEXINFO);
	    }
	}
    }
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\mkbuiltins.c:1,190
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\mkbuiltins.c:1,273
parsing error 
{
  register int i;
  register BUILTIN_DESC *builtin;
  char *dname;
  char *sarray[2];

  for (i = 0; i < builtins->sindex; i++)
    {
      builtin = (BUILTIN_DESC *)builtins->array[i];

      if (builtin->dependencies)
	write_ifdefs (stream, builtin->dependencies->array);

      /* Write the long documentation strings. */
      dname = document_name (builtin);
      fprintf (stream, "char * const %s_doc[] =", dname);

      if (separate_helpfiles)
	{
	  int l = strlen (helpfile_directory) + strlen (dname) + 1;
	  sarray[0] = (char *)xmalloc (l + 1);
	  sprintf (sarray[0], "%s/%s", helpfile_directory, dname);
	  sarray[1] = (char *)NULL;
	  write_documentation (stream, sarray, 0, STRING_ARRAY|HELPFILE);
	  free (sarray[0]);
	}
      else
	write_documentation (stream, builtin->longdoc->array, 0, STRING_ARRAY);

      if (builtin->dependencies)
	write_endifs (stream, builtin->dependencies->array);

    }
}
warning: parse error {
  register int i;
  register BUILTIN_DESC *builtin;
  char *dname;
  char *sarray[2];

  for (i = 0; i < builtins->sindex; i++)
    {
      builtin = (BUILTIN_DESC *)builtins->array[i];

      if (builtin->dependencies)
	write_ifdefs (stream, builtin->dependencies->array);

      /* Write the long documentation strings. */
      dname = document_name (builtin);
      fprintf (stream, "char * const %s_doc[] =", dname);

      if (separate_helpfiles)
	{
	  int l = strlen (helpfile_directory) + strlen (dname) + 1;
	  sarray[0] = (char *)xmalloc (l + 1);
	  sprintf (sarray[0], "%s/%s", helpfile_directory, dname);
	  sarray[1] = (char *)NULL;
	  write_documentation (stream, sarray, 0, STRING_ARRAY|HELPFILE);
	  free (sarray[0]);
	}
      else
	write_documentation (stream, builtin->longdoc->array, 0, STRING_ARRAY);

      if (builtin->dependencies)
	write_endifs (stream, builtin->dependencies->array);

    }
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\mkbuiltins.c:1,276
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\mkbuiltins.c:1,318
parsing error 
{
  register int i;

  if (!stream)
    return;

  fprintf (stream, "#if ");

  for (i = 0; defines[i]; i++)
    {
      char *def = defines[i];

      if (*def == '!')
	fprintf (stream, "!defined (%s)", def + 1);
      else
	fprintf (stream, "defined (%s)", def);

      if (defines[i + 1])
	fprintf (stream, " && ");
    }
  fprintf (stream, "\n");
}
warning: parse error {
  register int i;

  if (!stream)
    return;

  fprintf (stream, "#if ");

  for (i = 0; defines[i]; i++)
    {
      char *def = defines[i];

      if (*def == '!')
	fprintf (stream, "!defined (%s)", def + 1);
      else
	fprintf (stream, "defined (%s)", def);

      if (defines[i + 1])
	fprintf (stream, " && ");
    }
  fprintf (stream, "\n");
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\mkbuiltins.c:1,321
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\mkbuiltins.c:1,349
parsing error 
{
  register int i;

  if (!stream)
    return;

  fprintf (stream, "#endif /* ");

  for (i = 0; defines[i]; i++)
    {
      fprintf (stream, "%s", defines[i]);

      if (defines[i + 1])
	fprintf (stream, " && ");
    }

  fprintf (stream, " */\n");
}
warning: parse error {
  register int i;

  if (!stream)
    return;

  fprintf (stream, "#endif /* ");

  for (i = 0; defines[i]; i++)
    {
      fprintf (stream, "%s", defines[i]);

      if (defines[i + 1])
	fprintf (stream, " && ");
    }

  fprintf (stream, " */\n");
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\mkbuiltins.c:1,352
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\mkbuiltins.c:1,376
parsing error 
{
  register int i, j;
  register char *line;
  int string_array, texinfo, base_indent, filename_p;

  if (stream == 0)
    return;

  string_array = flags & STRING_ARRAY;
  filename_p = flags & HELPFILE;

  if (string_array)
    {
      fprintf (stream, " {\n#if defined (HELP_BUILTIN)\n");	/* } */
      if (single_longdoc_strings)
	{
	  if (filename_p == 0)
	    {
	      if (documentation && documentation[0] && documentation[0][0])
		fprintf (stream,  "N_(\"");
	      else
		fprintf (stream, "N_(\" ");		/* the empty string translates specially. */
	    }
	  else
	    fprintf (stream, "\"");
	}
    }

  base_indent = (string_array && single_longdoc_strings && filename_p == 0) ? BASE_INDENT : 0;

  for (i = 0, texinfo = (flags & TEXINFO); line = documentation[i]; i++)
    {
      /* Allow #ifdef's to be written out verbatim, but don't put them into
	 separate help files. */
      if (*line == '#')
	{
	  if (string_array && filename_p == 0 && single_longdoc_strings == 0)
	    fprintf (stream, "%s\n", line);
	  continue;
	}

      /* prefix with N_( for gettext */
      if (string_array && single_longdoc_strings == 0)
	{
	  if (filename_p == 0)
	    {
	      if (line[0])	      
		fprintf (stream, "  N_(\"");
	      else
		fprintf (stream, "  N_(\" ");		/* the empty string translates specially. */
	    }
	  else
	    fprintf (stream, "  \"");
	}

      if (indentation)
	for (j = 0; j < indentation; j++)
	  fprintf (stream, " ");

      /* Don't indent the first line, because of how the help builtin works. */
      if (i == 0)
	indentation += base_indent;

      if (string_array)
	{
	  for (j = 0; line[j]; j++)
	    {
	      switch (line[j])
		{
		case '\\':
		case '"':
		  fprintf (stream, "\\%c", line[j]);
		  break;

		default:
		  fprintf (stream, "%c", line[j]);
		}
	    }

	  /* closing right paren for gettext */
	  if (single_longdoc_strings == 0)
	    {
	      if (filename_p == 0)
		fprintf (stream, "\"),\n");
	      else
		fprintf (stream, "\",\n");
	    }
	  else if (documentation[i+1])
	    /* don't add extra newline after last line */
	    fprintf (stream, "\\n\\\n");
	}
      else if (texinfo)
	{
	  for (j = 0; line[j]; j++)
	    {
	      switch (line[j])
		{
		case '@':
		case '{':
		case '}':
		  fprintf (stream, "@%c", line[j]);
		  break;

		default:
		  fprintf (stream, "%c", line[j]);
		}
	    }
	  fprintf (stream, "\n");
	}
      else
	fprintf (stream, "%s\n", line);
    }

  /* closing right paren for gettext */
  if (string_array && single_longdoc_strings)
    {
      if (filename_p == 0)
	fprintf (stream, "\"),\n");
      else
	fprintf (stream, "\",\n");
    }

  if (string_array)
    fprintf (stream, "#endif /* HELP_BUILTIN */\n  (char *)NULL\n};\n");
}
warning: parse error {
  register int i, j;
  register char *line;
  int string_array, texinfo, base_indent, filename_p;

  if (stream == 0)
    return;

  string_array = flags & STRING_ARRAY;
  filename_p = flags & HELPFILE;

  if (string_array)
    {
      fprintf (stream, " {\n#if defined (HELP_BUILTIN)\n");	/* } */
      if (single_longdoc_strings)
	{
	  if (filename_p == 0)
	    {
	      if (documentation && documentation[0] && documentation[0][0])
		fprintf (stream,  "N_(\"");
	      else
		fprintf (stream, "N_(\" ");		/* the empty string translates specially. */
	    }
	  else
	    fprintf (stream, "\"");
	}
    }

  base_indent = (string_array && single_longdoc_strings && filename_p == 0) ? BASE_INDENT : 0;

  for (i = 0, texinfo = (flags & TEXINFO); line = documentation[i]; i++)
    {
      /* Allow #ifdef's to be written out verbatim, but don't put them into
	 separate help files. */
      if (*line == '#')
	{
	  if (string_array && filename_p == 0 && single_longdoc_strings == 0)
	    fprintf (stream, "%s\n", line);
	  continue;
	}

      /* prefix with N_( for gettext */
      if (string_array && single_longdoc_strings == 0)
	{
	  if (filename_p == 0)
	    {
	      if (line[0])	      
		fprintf (stream, "  N_(\"");
	      else
		fprintf (stream, "  N_(\" ");		/* the empty string translates specially. */
	    }
	  else
	    fprintf (stream, "  \"");
	}

      if (indentation)
	for (j = 0; j < indentation; j++)
	  fprintf (stream, " ");

      /* Don't indent the first line, because of how the help builtin works. */
      if (i == 0)
	indentation += base_indent;

      if (string_array)
	{
	  for (j = 0; line[j]; j++)
	    {
	      switch (line[j])
		{
		case '\\':
		case '"':
		  fprintf (stream, "\\%c", line[j]);
		  break;

		default:
		  fprintf (stream, "%c", line[j]);
		}
	    }

	  /* closing right paren for gettext */
	  if (single_longdoc_strings == 0)
	    {
	      if (filename_p == 0)
		fprintf (stream, "\"),\n");
	      else
		fprintf (stream, "\",\n");
	    }
	  else if (documentation[i+1])
	    /* don't add extra newline after last line */
	    fprintf (stream, "\\n\\\n");
	}
      else if (texinfo)
	{
	  for (j = 0; line[j]; j++)
	    {
	      switch (line[j])
		{
		case '@':
		case '{':
		case '}':
		  fprintf (stream, "@%c", line[j]);
		  break;

		default:
		  fprintf (stream, "%c", line[j]);
		}
	    }
	  fprintf (stream, "\n");
	}
      else
	fprintf (stream, "%s\n", line);
    }

  /* closing right paren for gettext */
  if (string_array && single_longdoc_strings)
    {
      if (filename_p == 0)
	fprintf (stream, "\"),\n");
      else
	fprintf (stream, "\",\n");
    }

  if (string_array)
    fprintf (stream, "#endif /* HELP_BUILTIN */\n  (char *)NULL\n};\n");
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\mkbuiltins.c:1,380
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\mkbuiltins.c:1,507
parsing error 
{
  char *helpfile, *bname;
  FILE *helpfp;
  int i, hdlen;
  BUILTIN_DESC *builtin;	

  i = mkdir ("helpfiles", 0777);
  if (i < 0 && errno != EEXIST)
    {
      fprintf (stderr, "write_helpfiles: helpfiles: cannot create directory\n");
      return -1;
    }

  hdlen = strlen ("helpfiles/");
  for (i = 0; i < builtins->sindex; i++)
    {
      builtin = (BUILTIN_DESC *)builtins->array[i];

      bname = document_name (builtin);
      helpfile = (char *)xmalloc (hdlen + strlen (bname) + 1);
      sprintf (helpfile, "helpfiles/%s", bname);

      helpfp = fopen (helpfile, "w");
      if (helpfp == 0)
	{
	  fprintf (stderr, "write_helpfiles: cannot open %s\n", helpfile);
	  free (helpfile);
	  continue;
	}

      write_documentation (helpfp, builtin->longdoc->array, 4, PLAINTEXT);

      fflush (helpfp);
      fclose (helpfp);
      free (helpfile);
    }
  return 0;
}
warning: parse error {
  char *helpfile, *bname;
  FILE *helpfp;
  int i, hdlen;
  BUILTIN_DESC *builtin;	

  i = mkdir ("helpfiles", 0777);
  if (i < 0 && errno != EEXIST)
    {
      fprintf (stderr, "write_helpfiles: helpfiles: cannot create directory\n");
      return -1;
    }

  hdlen = strlen ("helpfiles/");
  for (i = 0; i < builtins->sindex; i++)
    {
      builtin = (BUILTIN_DESC *)builtins->array[i];

      bname = document_name (builtin);
      helpfile = (char *)xmalloc (hdlen + strlen (bname) + 1);
      sprintf (helpfile, "helpfiles/%s", bname);

      helpfp = fopen (helpfile, "w");
      if (helpfp == 0)
	{
	  fprintf (stderr, "write_helpfiles: cannot open %s\n", helpfile);
	  free (helpfile);
	  continue;
	}

      write_documentation (helpfp, builtin->longdoc->array, 4, PLAINTEXT);

      fflush (helpfp);
      fclose (helpfp);
      free (helpfile);
    }
  return 0;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\mkbuiltins.c:1,509
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\mkbuiltins.c:1,549
parsing error 
{
  register int i;

  for (i = 0; name_table[i]; i++)
    if (strcmp (name, name_table[i]) == 0)
      return 1;
  return 0;
}
warning: parse error {
  register int i;

  for (i = 0; name_table[i]; i++)
    if (strcmp (name, name_table[i]) == 0)
      return 1;
  return 0;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\mkbuiltins.c:1,551
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\mkbuiltins.c:1,561
parsing error 
{
  return (_find_in_table (name, special_builtins));
}
warning: parse error {
  return (_find_in_table (name, special_builtins));
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\mkbuiltins.c:1,563
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\mkbuiltins.c:1,568
parsing error 
{
  return (_find_in_table (name, assignment_builtins));
}
warning: parse error {
  return (_find_in_table (name, assignment_builtins));
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\mkbuiltins.c:1,570
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\mkbuiltins.c:1,575
parsing error 
{
  return (_find_in_table (name, posix_builtins));
}
warning: parse error {
  return (_find_in_table (name, posix_builtins));
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\mkbuiltins.c:1,577
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\mkbuiltins.c:1,583
parsing error 
{
  unlink (to);
  if (link (from, to) < 0)
    return (-1);
  unlink (from);
  return (0);
}
warning: parse error {
  unlink (to);
  if (link (from, to) < 0)
    return (-1);
  unlink (from);
  return (0);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\mkbuiltins.c:1,585
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\psize.c...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\bashtypes.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\command.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\general.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\sig.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\psize.c:51
parsing error 
{
  fprintf (stderr, "%d\n", nw);
  exit (0);
}
warning: parse error {
  fprintf (stderr, "%d\n", nw);
  exit (0);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\psize.c:53
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\psize.c:59
parsing error 
{
  char buf[128];
  register int i;

  for (i = 0; i < 128; i++)
    buf[i] = ' ';

  signal (SIGPIPE, sigpipe);

  nw = 0;
  for (;;)
    {
      int n;
      n = write (1, buf, 128);
      nw += n;
    }
  return (0);
}
warning: parse error {
  char buf[128];
  register int i;

  for (i = 0; i < 128; i++)
    buf[i] = ' ';

  signal (SIGPIPE, sigpipe);

  nw = 0;
  for (;;)
    {
      int n;
      n = write (1, buf, 128);
      nw += n;
    }
  return (0);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\psize.c:62
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\copy_cmd.c...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\bashtypes.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\shell.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\copy_cmd.c:56
parsing error 
{
  WORD_DESC *new_word;

  new_word = make_bare_word (w->word);
  new_word->flags = w->flags;
  return (new_word);
}
warning: parse error {
  WORD_DESC *new_word;

  new_word = make_bare_word (w->word);
  new_word->flags = w->flags;
  return (new_word);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\copy_cmd.c:58
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\copy_cmd.c:69
parsing error 
{
  WORD_LIST *new_list;

  for (new_list = (WORD_LIST *)NULL; list; list = list->next)
    new_list = make_word_list (copy_word (list->word), new_list);

  return (REVERSE_LIST (new_list, WORD_LIST *));
}
warning: parse error {
  WORD_LIST *new_list;

  for (new_list = (WORD_LIST *)NULL; list; list = list->next)
    new_list = make_word_list (copy_word (list->word), new_list);

  return (REVERSE_LIST (new_list, WORD_LIST *));
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\copy_cmd.c:71
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\copy_cmd.c:81
parsing error 
{
  PATTERN_LIST *new_clause;

  new_clause = (PATTERN_LIST *)xmalloc (sizeof (PATTERN_LIST));
  new_clause->patterns = copy_word_list (clause->patterns);
  new_clause->action = copy_command (clause->action);
  new_clause->flags = clause->flags;
  return (new_clause);
}
warning: parse error {
  PATTERN_LIST *new_clause;

  new_clause = (PATTERN_LIST *)xmalloc (sizeof (PATTERN_LIST));
  new_clause->patterns = copy_word_list (clause->patterns);
  new_clause->action = copy_command (clause->action);
  new_clause->flags = clause->flags;
  return (new_clause);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\copy_cmd.c:83
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\copy_cmd.c:94
parsing error 
{
  PATTERN_LIST *new_list, *new_clause;

  for (new_list = (PATTERN_LIST *)NULL; clauses; clauses = clauses->next)
    {
      new_clause = copy_case_clause (clauses);
      new_clause->next = new_list;
      new_list = new_clause;
    }
  return (REVERSE_LIST (new_list, PATTERN_LIST *));
}
warning: parse error {
  PATTERN_LIST *new_list, *new_clause;

  for (new_list = (PATTERN_LIST *)NULL; clauses; clauses = clauses->next)
    {
      new_clause = copy_case_clause (clauses);
      new_clause->next = new_list;
      new_list = new_clause;
    }
  return (REVERSE_LIST (new_list, PATTERN_LIST *));
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\copy_cmd.c:96
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\copy_cmd.c:110
parsing error 
{
  REDIRECT *new_redirect;

  new_redirect = (REDIRECT *)xmalloc (sizeof (REDIRECT));
#if 0
  FASTCOPY ((char *)redirect, (char *)new_redirect, (sizeof (REDIRECT)));
#else
  *new_redirect = *redirect;	/* let the compiler do the fast structure copy */
#endif

  if (redirect->rflags & REDIR_VARASSIGN)
    new_redirect->redirector.filename = copy_word (redirect->redirector.filename);

  switch (redirect->instruction)
    {
    case r_reading_until:
    case r_deblank_reading_until:
      new_redirect->here_doc_eof = savestring (redirect->here_doc_eof);
      /*FALLTHROUGH*/
    case r_reading_string:
    case r_appending_to:
    case r_output_direction:
    case r_input_direction:
    case r_inputa_direction:
    case r_err_and_out:
    case r_append_err_and_out:
    case r_input_output:
    case r_output_force:
    case r_duplicating_input_word:
    case r_duplicating_output_word:
    case r_move_input_word:
    case r_move_output_word:
      new_redirect->redirectee.filename = copy_word (redirect->redirectee.filename);
      break;
    case r_duplicating_input:
    case r_duplicating_output:
    case r_move_input:
    case r_move_output:
    case r_close_this:
      break;
    }
  return (new_redirect);
}
warning: parse error {
  REDIRECT *new_redirect;

  new_redirect = (REDIRECT *)xmalloc (sizeof (REDIRECT));
#if 0
  FASTCOPY ((char *)redirect, (char *)new_redirect, (sizeof (REDIRECT)));
#else
  *new_redirect = *redirect;	/* let the compiler do the fast structure copy */
#endif

  if (redirect->rflags & REDIR_VARASSIGN)
    new_redirect->redirector.filename = copy_word (redirect->redirector.filename);

  switch (redirect->instruction)
    {
    case r_reading_until:
    case r_deblank_reading_until:
      new_redirect->here_doc_eof = savestring (redirect->here_doc_eof);
      /*FALLTHROUGH*/
    case r_reading_string:
    case r_appending_to:
    case r_output_direction:
    case r_input_direction:
    case r_inputa_direction:
    case r_err_and_out:
    case r_append_err_and_out:
    case r_input_output:
    case r_output_force:
    case r_duplicating_input_word:
    case r_duplicating_output_word:
    case r_move_input_word:
    case r_move_output_word:
      new_redirect->redirectee.filename = copy_word (redirect->redirectee.filename);
      break;
    case r_duplicating_input:
    case r_duplicating_output:
    case r_move_input:
    case r_move_output:
    case r_close_this:
      break;
    }
  return (new_redirect);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\copy_cmd.c:112
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\copy_cmd.c:157
parsing error 
{
  REDIRECT *new_list, *temp;

  for (new_list = (REDIRECT *)NULL; list; list = list->next)
    {
      temp = copy_redirect (list);
      temp->next = new_list;
      new_list = temp;
    }
  return (REVERSE_LIST (new_list, REDIRECT *));
}
warning: parse error {
  REDIRECT *new_list, *temp;

  for (new_list = (REDIRECT *)NULL; list; list = list->next)
    {
      temp = copy_redirect (list);
      temp->next = new_list;
      new_list = temp;
    }
  return (REVERSE_LIST (new_list, REDIRECT *));
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\copy_cmd.c:159
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\copy_cmd.c:172
parsing error 
{
  FOR_COM *new_for;

  new_for = (FOR_COM *)xmalloc (sizeof (FOR_COM));
  new_for->flags = com->flags;
  new_for->line = com->line;
  new_for->name = copy_word (com->name);
  new_for->map_list = copy_word_list (com->map_list);
  new_for->action = copy_command (com->action);
  return (new_for);
}
warning: parse error {
  FOR_COM *new_for;

  new_for = (FOR_COM *)xmalloc (sizeof (FOR_COM));
  new_for->flags = com->flags;
  new_for->line = com->line;
  new_for->name = copy_word (com->name);
  new_for->map_list = copy_word_list (com->map_list);
  new_for->action = copy_command (com->action);
  return (new_for);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\copy_cmd.c:174
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\copy_cmd.c:205
parsing error 
{
  GROUP_COM *new_group;

  new_group = (GROUP_COM *)xmalloc (sizeof (GROUP_COM));
  new_group->command = copy_command (com->command);
  return (new_group);
}
warning: parse error {
  GROUP_COM *new_group;

  new_group = (GROUP_COM *)xmalloc (sizeof (GROUP_COM));
  new_group->command = copy_command (com->command);
  return (new_group);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\copy_cmd.c:207
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\copy_cmd.c:216
parsing error 
{
  SUBSHELL_COM *new_subshell;

  new_subshell = (SUBSHELL_COM *)xmalloc (sizeof (SUBSHELL_COM));
  new_subshell->command = copy_command (com->command);
  new_subshell->flags = com->flags;
  return (new_subshell);
}
warning: parse error {
  SUBSHELL_COM *new_subshell;

  new_subshell = (SUBSHELL_COM *)xmalloc (sizeof (SUBSHELL_COM));
  new_subshell->command = copy_command (com->command);
  new_subshell->flags = com->flags;
  return (new_subshell);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\copy_cmd.c:218
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\copy_cmd.c:228
parsing error 
{
  COPROC_COM *new_coproc;

  new_coproc = (COPROC_COM *)xmalloc (sizeof (COPROC_COM));
  new_coproc->name = savestring (com->name);
  new_coproc->command = copy_command (com->command);
  new_coproc->flags = com->flags;
  return (new_coproc);
}
warning: parse error {
  COPROC_COM *new_coproc;

  new_coproc = (COPROC_COM *)xmalloc (sizeof (COPROC_COM));
  new_coproc->name = savestring (com->name);
  new_coproc->command = copy_command (com->command);
  new_coproc->flags = com->flags;
  return (new_coproc);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\copy_cmd.c:230
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\copy_cmd.c:241
parsing error 
{
  CASE_COM *new_case;

  new_case = (CASE_COM *)xmalloc (sizeof (CASE_COM));
  new_case->flags = com->flags;
  new_case->line = com->line;
  new_case->word = copy_word (com->word);
  new_case->clauses = copy_case_clauses (com->clauses);
  return (new_case);
}
warning: parse error {
  CASE_COM *new_case;

  new_case = (CASE_COM *)xmalloc (sizeof (CASE_COM));
  new_case->flags = com->flags;
  new_case->line = com->line;
  new_case->word = copy_word (com->word);
  new_case->clauses = copy_case_clauses (com->clauses);
  return (new_case);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\copy_cmd.c:243
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\copy_cmd.c:255
parsing error 
{
  WHILE_COM *new_while;

  new_while = (WHILE_COM *)xmalloc (sizeof (WHILE_COM));
  new_while->flags = com->flags;
  new_while->test = copy_command (com->test);
  new_while->action = copy_command (com->action);
  return (new_while);
}
warning: parse error {
  WHILE_COM *new_while;

  new_while = (WHILE_COM *)xmalloc (sizeof (WHILE_COM));
  new_while->flags = com->flags;
  new_while->test = copy_command (com->test);
  new_while->action = copy_command (com->action);
  return (new_while);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\copy_cmd.c:257
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\copy_cmd.c:268
parsing error 
{
  IF_COM *new_if;

  new_if = (IF_COM *)xmalloc (sizeof (IF_COM));
  new_if->flags = com->flags;
  new_if->test = copy_command (com->test);
  new_if->true_case = copy_command (com->true_case);
  new_if->false_case = com->false_case ? copy_command (com->false_case) : com->false_case;
  return (new_if);
}
warning: parse error {
  IF_COM *new_if;

  new_if = (IF_COM *)xmalloc (sizeof (IF_COM));
  new_if->flags = com->flags;
  new_if->test = copy_command (com->test);
  new_if->true_case = copy_command (com->true_case);
  new_if->false_case = com->false_case ? copy_command (com->false_case) : com->false_case;
  return (new_if);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\copy_cmd.c:270
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\copy_cmd.c:317
parsing error 
{
  SIMPLE_COM *new_simple;

  new_simple = (SIMPLE_COM *)xmalloc (sizeof (SIMPLE_COM));
  new_simple->flags = com->flags;
  new_simple->words = copy_word_list (com->words);
  new_simple->redirects = com->redirects ? copy_redirects (com->redirects) : (REDIRECT *)NULL;
  new_simple->line = com->line;
  return (new_simple);
}
warning: parse error {
  SIMPLE_COM *new_simple;

  new_simple = (SIMPLE_COM *)xmalloc (sizeof (SIMPLE_COM));
  new_simple->flags = com->flags;
  new_simple->words = copy_word_list (com->words);
  new_simple->redirects = com->redirects ? copy_redirects (com->redirects) : (REDIRECT *)NULL;
  new_simple->line = com->line;
  return (new_simple);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\copy_cmd.c:319
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\copy_cmd.c:331
parsing error 
{
  new_def->name = copy_word (old->name);
  new_def->command = old->command ? copy_command (old->command) : old->command;
  new_def->flags = old->flags;
  new_def->line = old->line;
  new_def->source_file = old->source_file ? savestring (old->source_file) : old->source_file;
  return (new_def);
}
warning: parse error {
  new_def->name = copy_word (old->name);
  new_def->command = old->command ? copy_command (old->command) : old->command;
  new_def->flags = old->flags;
  new_def->line = old->line;
  new_def->source_file = old->source_file ? savestring (old->source_file) : old->source_file;
  return (new_def);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\copy_cmd.c:333
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\copy_cmd.c:343
parsing error 
{
  FUNCTION_DEF *new_def;

  new_def = (FUNCTION_DEF *)xmalloc (sizeof (FUNCTION_DEF));
  new_def = copy_function_def_contents (com, new_def);
  return (new_def);
}
warning: parse error {
  FUNCTION_DEF *new_def;

  new_def = (FUNCTION_DEF *)xmalloc (sizeof (FUNCTION_DEF));
  new_def = copy_function_def_contents (com, new_def);
  return (new_def);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\copy_cmd.c:345
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\copy_cmd.c:357
parsing error 
{
  COMMAND *new_command;

  if (command == NULL)
    return (command);

  new_command = (COMMAND *)xmalloc (sizeof (COMMAND));
  FASTCOPY ((char *)command, (char *)new_command, sizeof (COMMAND));
  new_command->flags = command->flags;
  new_command->line = command->line;

  if (command->redirects)
    new_command->redirects = copy_redirects (command->redirects);

  switch (command->type)
    {
      case cm_for:
	new_command->value.For = copy_for_command (command->value.For);
	break;

#if defined (ARITH_FOR_COMMAND)
      case cm_arith_for:
	new_command->value.ArithFor = copy_arith_for_command (command->value.ArithFor);
	break;
#endif

#if defined (SELECT_COMMAND)
      case cm_select:
	new_command->value.Select =
	  (SELECT_COM *)copy_for_command ((FOR_COM *)command->value.Select);
	break;
#endif

      case cm_group:
	new_command->value.Group = copy_group_command (command->value.Group);
	break;

      case cm_subshell:
	new_command->value.Subshell = copy_subshell_command (command->value.Subshell);
	break;

      case cm_coproc:
	new_command->value.Coproc = copy_coproc_command (command->value.Coproc);
	break;

      case cm_case:
	new_command->value.Case = copy_case_command (command->value.Case);
	break;

      case cm_until:
      case cm_while:
	new_command->value.While = copy_while_command (command->value.While);
	break;

      case cm_if:
	new_command->value.If = copy_if_command (command->value.If);
	break;

#if defined (DPAREN_ARITHMETIC)
      case cm_arith:
	new_command->value.Arith = copy_arith_command (command->value.Arith);
	break;
#endif

#if defined (COND_COMMAND)
      case cm_cond:
	new_command->value.Cond = copy_cond_command (command->value.Cond);
	break;
#endif

      case cm_simple:
	new_command->value.Simple = copy_simple_command (command->value.Simple);
	break;

      case cm_connection:
	{
	  CONNECTION *new_connection;

	  new_connection = (CONNECTION *)xmalloc (sizeof (CONNECTION));
	  new_connection->connector = command->value.Connection->connector;
	  new_connection->first = copy_command (command->value.Connection->first);
	  new_connection->second = copy_command (command->value.Connection->second);
	  new_command->value.Connection = new_connection;
	  break;
	}

      case cm_function_def:
	new_command->value.Function_def = copy_function_def (command->value.Function_def);
	break;
    }
  return (new_command);
}
warning: parse error {
  COMMAND *new_command;

  if (command == NULL)
    return (command);

  new_command = (COMMAND *)xmalloc (sizeof (COMMAND));
  FASTCOPY ((char *)command, (char *)new_command, sizeof (COMMAND));
  new_command->flags = command->flags;
  new_command->line = command->line;

  if (command->redirects)
    new_command->redirects = copy_redirects (command->redirects);

  switch (command->type)
    {
      case cm_for:
	new_command->value.For = copy_for_command (command->value.For);
	break;

#if defined (ARITH_FOR_COMMAND)
      case cm_arith_for:
	new_command->value.ArithFor = copy_arith_for_command (command->value.ArithFor);
	break;
#endif

#if defined (SELECT_COMMAND)
      case cm_select:
	new_command->value.Select =
	  (SELECT_COM *)copy_for_command ((FOR_COM *)command->value.Select);
	break;
#endif

      case cm_group:
	new_command->value.Group = copy_group_command (command->value.Group);
	break;

      case cm_subshell:
	new_command->value.Subshell = copy_subshell_command (command->value.Subshell);
	break;

      case cm_coproc:
	new_command->value.Coproc = copy_coproc_command (command->value.Coproc);
	break;

      case cm_case:
	new_command->value.Case = copy_case_command (command->value.Case);
	break;

      case cm_until:
      case cm_while:
	new_command->value.While = copy_while_command (command->value.While);
	break;

      case cm_if:
	new_command->value.If = copy_if_command (command->value.If);
	break;

#if defined (DPAREN_ARITHMETIC)
      case cm_arith:
	new_command->value.Arith = copy_arith_command (command->value.Arith);
	break;
#endif

#if defined (COND_COMMAND)
      case cm_cond:
	new_command->value.Cond = copy_cond_command (command->value.Cond);
	break;
#endif

      case cm_simple:
	new_command->value.Simple = copy_simple_command (command->value.Simple);
	break;

      case cm_connection:
	{
	  CONNECTION *new_connection;

	  new_connection = (CONNECTION *)xmalloc (sizeof (CONNECTION));
	  new_connection->connector = command->value.Connection->connector;
	  new_connection->first = copy_command (command->value.Connection->first);
	  new_connection->second = copy_command (command->value.Connection->second);
	  new_command->value.Connection = new_connection;
	  break;
	}

      case cm_function_def:
	new_command->value.Function_def = copy_function_def (command->value.Function_def);
	break;
    }
  return (new_command);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\copy_cmd.c:359
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\CWRU\misc\errlist.c...
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\CWRU\misc\errlist.c:31
parsing error 
{
	int	i, n;

	if (c == 1) {
		for (i = 1; i < sys_nerr; i++)
			printf("%d --> %s\n", i, strerror(i));
	} else {
		for (i = 1; i < c; i++) {
			n = atoi(v[i]);
			printf("%d --> %s\n", n, strerror(n));
		}
	}
	exit (0);
}
warning: parse error {
	int	i, n;

	if (c == 1) {
		for (i = 1; i < sys_nerr; i++)
			printf("%d --> %s\n", i, strerror(i));
	} else {
		for (i = 1; i < c; i++) {
			n = atoi(v[i]);
			printf("%d --> %s\n", n, strerror(n));
		}
	}
	exit (0);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\CWRU\misc\errlist.c:34
parsing error 
programming_error(a, b)
char	*a;
warning: parse error programming_error(a, b)
char	*a;Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\CWRU\misc\errlist.c:49
parsing error 
{
}
warning: parse error {
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\CWRU\misc\errlist.c:52
parsing error 
fatal_error()
{
}
warning: parse error fatal_error()
{
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\CWRU\misc\errlist.c:55
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\CWRU\misc\open-files.c...
parsing error 
main()
{
	register int	i;

	for (i = 0; i < getdtablesize(); i++) {
		if (fcntl(i, F_GETFD, 0) != -1)
			fprintf(stderr, "fd %d: open\n", i);
	}
	exit(0);
}
warning: parse error main()
{
	register int	i;

	for (i = 0; i < getdtablesize(); i++) {
		if (fcntl(i, F_GETFD, 0) != -1)
			fprintf(stderr, "fd %d: open\n", i);
	}
	exit(0);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\CWRU\misc\open-files.c:30
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\CWRU\misc\sigs.c...
parsing error 
main(argc, argv)
int	argc;
warning: parse error main(argc, argv)
int	argc;Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\CWRU\misc\sigs.c:28
parsing error 
{
	register int	i;
	sighandler	*h;

	for (i = 1; i < NSIG; i++) {
		h = signal(i, SIG_DFL);
		if (h != SIG_DFL) {
			if (h == SIG_IGN)
				fprintf(stderr, "%d: ignored (%s)\n", i, sys_siglist[i]);
			else
				fprintf(stderr, "%d: caught (%s)\n", i, sys_siglist[i]);
		}
	}
	exit(0);
}
warning: parse error {
	register int	i;
	sighandler	*h;

	for (i = 1; i < NSIG; i++) {
		h = signal(i, SIG_DFL);
		if (h != SIG_DFL) {
			if (h == SIG_IGN)
				fprintf(stderr, "%d: ignored (%s)\n", i, sys_siglist[i]);
			else
				fprintf(stderr, "%d: caught (%s)\n", i, sys_siglist[i]);
		}
	}
	exit(0);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\CWRU\misc\sigs.c:31
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\CWRU\misc\sigstat.c...
parsing error 
main(argc, argv)
int	argc;
warning: parse error main(argc, argv)
int	argc;Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\CWRU\misc\sigstat.c:37
parsing error 
{
	register int	i;
	char	*t;

	if (t = strrchr(argv[0], '/'))
		progname = ++t;
	else
		progname = argv[0];
	init_signames();
	if (argc == 1) {
		for (i = 1; i < NSIG; i++)
			sigstat(i);
		exit(0);
	}
	for (i = 1; i < argc; i++)
		sigstat(atoi(argv[i]));
	exit(0);
}
warning: parse error {
	register int	i;
	char	*t;

	if (t = strrchr(argv[0], '/'))
		progname = ++t;
	else
		progname = argv[0];
	init_signames();
	if (argc == 1) {
		for (i = 1; i < NSIG; i++)
			sigstat(i);
		exit(0);
	}
	for (i = 1; i < argc; i++)
		sigstat(atoi(argv[i]));
	exit(0);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\CWRU\misc\sigstat.c:40
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\CWRU\misc\sigstat.c:60
parsing error 
{
	struct sigaction oact;
	char *signame;
	sigset_t set, oset;
	int blocked;

	if (sig < 0 || sig >= NSIG) {
		fprintf(stderr, "%s: %d: signal out of range\n", progname, sig);
		return;
	}
	signame = signames[sig];
	sigemptyset(&oset);
	sigprocmask(SIG_BLOCK, (sigset_t *)NULL, &oset);
	if (sigismember(&oset, sig))
		printf("%s: signal is blocked\n", signame);
	sigaction(sig, (struct sigaction *)NULL, &oact);
	if (oact.sa_handler == SIG_IGN)
		printf("%s: signal is ignored\n", signame);
	else if (oact.sa_handler == SIG_DFL)
		printf("%s: signal is defaulted\n", signame);
	else
		printf("%s: signal is trapped (?)\n", signame);
}
warning: parse error {
	struct sigaction oact;
	char *signame;
	sigset_t set, oset;
	int blocked;

	if (sig < 0 || sig >= NSIG) {
		fprintf(stderr, "%s: %d: signal out of range\n", progname, sig);
		return;
	}
	signame = signames[sig];
	sigemptyset(&oset);
	sigprocmask(SIG_BLOCK, (sigset_t *)NULL, &oset);
	if (sigismember(&oset, sig))
		printf("%s: signal is blocked\n", signame);
	sigaction(sig, (struct sigaction *)NULL, &oact);
	if (oact.sa_handler == SIG_IGN)
		printf("%s: signal is ignored\n", signame);
	else if (oact.sa_handler == SIG_DFL)
		printf("%s: signal is defaulted\n", signame);
	else
		printf("%s: signal is trapped (?)\n", signame);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\CWRU\misc\sigstat.c:62
parsing error 
init_signames()
{
	register int i;
	bzero(signames, sizeof(signames));

#if defined (SIGHUP)		/* hangup */
  	signames[SIGHUP] = "SIGHUP";
#endif
#if defined (SIGINT)		/* interrupt */
  	signames[SIGINT] = "SIGINT";
#endif
#if defined (SIGQUIT)		/* quit */
  	signames[SIGQUIT] = "SIGQUIT";
#endif
#if defined (SIGILL)		/* illegal instruction (not reset when caught) */
  	signames[SIGILL] = "SIGILL";
#endif
#if defined (SIGTRAP)		/* trace trap (not reset when caught) */
  	signames[SIGTRAP] = "SIGTRAP";
#endif
#if defined (SIGABRT)		/*  */
  	signames[SIGABRT] = "SIGABRT";
#endif
#if defined (SIGIOT)		/* IOT instruction */
  	signames[SIGIOT] = "SIGIOT";
#endif
#if defined (SIGEMT)		/* EMT instruction */
  	signames[SIGEMT] = "SIGEMT";
#endif
#if defined (SIGFPE)		/* floating point exception */
  	signames[SIGFPE] = "SIGFPE";
#endif
#if defined (SIGKILL)		/* kill (cannot be caught or ignored) */
  	signames[SIGKILL] = "SIGKILL";
#endif
#if defined (SIGBUS)		/* bus error */
  	signames[SIGBUS] = "SIGBUS";
#endif
#if defined (SIGSEGV)		/* segmentation violation */
  	signames[SIGSEGV] = "SIGSEGV";
#endif
#if defined (SIGSYS)		/* bad argument to system call */
  	signames[SIGSYS] = "SIGSYS";
#endif
#if defined (SIGPIPE)		/* write on a pipe with no one to read it */
  	signames[SIGPIPE] = "SIGPIPE";
#endif
#if defined (SIGALRM)		/* alarm clock */
  	signames[SIGALRM] = "SIGALRM";
#endif
#if defined (SIGTERM)		/* software termination signal from kill */
  	signames[SIGTERM] = "SIGTERM";
#endif
#if defined (SIGCLD)		/* Like SIGCHLD.  */
  	signames[SIGCLD] = "SIGCLD";
#endif
#if defined (SIGPWR)		/* Magic thing for some machines. */
  	signames[SIGPWR] = "SIGPWR";
#endif
#if defined (SIGPOLL)		/* For keyboard input?  */
  	signames[SIGPOLL] = "SIGPOLL";
#endif
#if defined (SIGURG)		/* urgent condition on IO channel */
  	signames[SIGURG] = "SIGURG";
#endif
#if defined (SIGSTOP)		/* sendable stop signal not from tty */
  	signames[SIGSTOP] = "SIGSTOP";
#endif
#if defined (SIGTSTP)		/* stop signal from tty */
  	signames[SIGTSTP] = "SIGTSTP";
#endif
#if defined (SIGCONT)		/* continue a stopped process */
  	signames[SIGCONT] = "SIGCONT";
#endif
#if defined (SIGCHLD)		/* to parent on child stop or exit */
  	signames[SIGCHLD] = "SIGCHLD";
#endif
#if defined (SIGTTIN)		/* to readers pgrp upon background tty read */
  	signames[SIGTTIN] = "SIGTTIN";
#endif
#if defined (SIGTTOU)		/* like TTIN for output if (tp->t_local&LTOSTOP) */
  	signames[SIGTTOU] = "SIGTTOU";
#endif
#if defined (SIGIO)		/* input/output possible signal */
  	signames[SIGIO] = "SIGIO";
#endif
#if defined (SIGXCPU)		/* exceeded CPU time limit */
  	signames[SIGXCPU] = "SIGXCPU";
#endif
#if defined (SIGXFSZ)		/* exceeded file size limit */
  	signames[SIGXFSZ] = "SIGXFSZ";
#endif
#if defined (SIGVTALRM)		/* virtual time alarm */
  	signames[SIGVTALRM] = "SIGVTALRM";
#endif
#if defined (SIGPROF)		/* profiling time alarm */
  	signames[SIGPROF] = "SIGPROF";
#endif
#if defined (SIGWINCH)		/* window changed */
  	signames[SIGWINCH] = "SIGWINCH";
#endif
#if defined (SIGLOST)		/* resource lost (eg, record-lock lost) */
  	signames[SIGLOST] = "SIGLOST";
#endif
#if defined (SIGUSR1)		/* user defined signal 1 */
  	signames[SIGUSR1] = "SIGUSR1";
#endif
#if defined (SIGUSR2)		/* user defined signal 2 */
  	signames[SIGUSR2] = "SIGUSR2";
#endif
#if defined (SIGMSG)	/* HFT input data pending */
  	signames[SIGMSG] = "SIGMSG";
#endif
#if defined (SIGPWR)	/* power failure imminent (save your data) */
  	signames[SIGPWR] = "SIGPWR";
#endif
#if defined (SIGDANGER)	/* system crash imminent */
  	signames[SIGDANGER] = "SIGDANGER";
#endif
#if defined (SIGMIGRATE)	/* migrate process to another CPU */
  	signames[SIGMIGRATE] = "SIGMIGRATE";
#endif
#if defined (SIGPRE)	/* programming error */
  	signames[SIGPRE] = "SIGPRE";
#endif
#if defined (SIGGRANT)	/* HFT monitor mode granted */
  	signames[SIGGRANT] = "SIGGRANT";
#endif
#if defined (SIGRETRACT)	/* HFT monitor mode retracted */
  	signames[SIGRETRACT] = "SIGRETRACT";
#endif
#if defined (SIGSOUND)	/* HFT sound sequence has completed */
  	signames[SIGSOUND] = "SIGSOUND";
#endif

	for (i = 0; i < NSIG; i++)
		if (signames[i] == (char *)NULL) {
			signames[i] = (char *)malloc (16);;
			sprintf (signames[i], "signal %d", i);
	  	}
}
warning: parse error init_signames()
{
	register int i;
	bzero(signames, sizeof(signames));

#if defined (SIGHUP)		/* hangup */
  	signames[SIGHUP] = "SIGHUP";
#endif
#if defined (SIGINT)		/* interrupt */
  	signames[SIGINT] = "SIGINT";
#endif
#if defined (SIGQUIT)		/* quit */
  	signames[SIGQUIT] = "SIGQUIT";
#endif
#if defined (SIGILL)		/* illegal instruction (not reset when caught) */
  	signames[SIGILL] = "SIGILL";
#endif
#if defined (SIGTRAP)		/* trace trap (not reset when caught) */
  	signames[SIGTRAP] = "SIGTRAP";
#endif
#if defined (SIGABRT)		/*  */
  	signames[SIGABRT] = "SIGABRT";
#endif
#if defined (SIGIOT)		/* IOT instruction */
  	signames[SIGIOT] = "SIGIOT";
#endif
#if defined (SIGEMT)		/* EMT instruction */
  	signames[SIGEMT] = "SIGEMT";
#endif
#if defined (SIGFPE)		/* floating point exception */
  	signames[SIGFPE] = "SIGFPE";
#endif
#if defined (SIGKILL)		/* kill (cannot be caught or ignored) */
  	signames[SIGKILL] = "SIGKILL";
#endif
#if defined (SIGBUS)		/* bus error */
  	signames[SIGBUS] = "SIGBUS";
#endif
#if defined (SIGSEGV)		/* segmentation violation */
  	signames[SIGSEGV] = "SIGSEGV";
#endif
#if defined (SIGSYS)		/* bad argument to system call */
  	signames[SIGSYS] = "SIGSYS";
#endif
#if defined (SIGPIPE)		/* write on a pipe with no one to read it */
  	signames[SIGPIPE] = "SIGPIPE";
#endif
#if defined (SIGALRM)		/* alarm clock */
  	signames[SIGALRM] = "SIGALRM";
#endif
#if defined (SIGTERM)		/* software termination signal from kill */
  	signames[SIGTERM] = "SIGTERM";
#endif
#if defined (SIGCLD)		/* Like SIGCHLD.  */
  	signames[SIGCLD] = "SIGCLD";
#endif
#if defined (SIGPWR)		/* Magic thing for some machines. */
  	signames[SIGPWR] = "SIGPWR";
#endif
#if defined (SIGPOLL)		/* For keyboard input?  */
  	signames[SIGPOLL] = "SIGPOLL";
#endif
#if defined (SIGURG)		/* urgent condition on IO channel */
  	signames[SIGURG] = "SIGURG";
#endif
#if defined (SIGSTOP)		/* sendable stop signal not from tty */
  	signames[SIGSTOP] = "SIGSTOP";
#endif
#if defined (SIGTSTP)		/* stop signal from tty */
  	signames[SIGTSTP] = "SIGTSTP";
#endif
#if defined (SIGCONT)		/* continue a stopped process */
  	signames[SIGCONT] = "SIGCONT";
#endif
#if defined (SIGCHLD)		/* to parent on child stop or exit */
  	signames[SIGCHLD] = "SIGCHLD";
#endif
#if defined (SIGTTIN)		/* to readers pgrp upon background tty read */
  	signames[SIGTTIN] = "SIGTTIN";
#endif
#if defined (SIGTTOU)		/* like TTIN for output if (tp->t_local&LTOSTOP) */
  	signames[SIGTTOU] = "SIGTTOU";
#endif
#if defined (SIGIO)		/* input/output possible signal */
  	signames[SIGIO] = "SIGIO";
#endif
#if defined (SIGXCPU)		/* exceeded CPU time limit */
  	signames[SIGXCPU] = "SIGXCPU";
#endif
#if defined (SIGXFSZ)		/* exceeded file size limit */
  	signames[SIGXFSZ] = "SIGXFSZ";
#endif
#if defined (SIGVTALRM)		/* virtual time alarm */
  	signames[SIGVTALRM] = "SIGVTALRM";
#endif
#if defined (SIGPROF)		/* profiling time alarm */
  	signames[SIGPROF] = "SIGPROF";
#endif
#if defined (SIGWINCH)		/* window changed */
  	signames[SIGWINCH] = "SIGWINCH";
#endif
#if defined (SIGLOST)		/* resource lost (eg, record-lock lost) */
  	signames[SIGLOST] = "SIGLOST";
#endif
#if defined (SIGUSR1)		/* user defined signal 1 */
  	signames[SIGUSR1] = "SIGUSR1";
#endif
#if defined (SIGUSR2)		/* user defined signal 2 */
  	signames[SIGUSR2] = "SIGUSR2";
#endif
#if defined (SIGMSG)	/* HFT input data pending */
  	signames[SIGMSG] = "SIGMSG";
#endif
#if defined (SIGPWR)	/* power failure imminent (save your data) */
  	signames[SIGPWR] = "SIGPWR";
#endif
#if defined (SIGDANGER)	/* system crash imminent */
  	signames[SIGDANGER] = "SIGDANGER";
#endif
#if defined (SIGMIGRATE)	/* migrate process to another CPU */
  	signames[SIGMIGRATE] = "SIGMIGRATE";
#endif
#if defined (SIGPRE)	/* programming error */
  	signames[SIGPRE] = "SIGPRE";
#endif
#if defined (SIGGRANT)	/* HFT monitor mode granted */
  	signames[SIGGRANT] = "SIGGRANT";
#endif
#if defined (SIGRETRACT)	/* HFT monitor mode retracted */
  	signames[SIGRETRACT] = "SIGRETRACT";
#endif
#if defined (SIGSOUND)	/* HFT sound sequence has completed */
  	signames[SIGSOUND] = "SIGSOUND";
#endif

	for (i = 0; i < NSIG; i++)
		if (signames[i] == (char *)NULL) {
			signames[i] = (char *)malloc (16);;
			sprintf (signames[i], "signal %d", i);
	  	}
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\CWRU\misc\sigstat.c:86
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\dispose_cmd.c...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\bashtypes.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\bashansi.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\shell.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\dispose_cmd.c:36
parsing error 
{
  if (command == 0)
    return;

  if (command->redirects)
    dispose_redirects (command->redirects);

  switch (command->type)
    {
    case cm_for:
#if defined (SELECT_COMMAND)
    case cm_select:
#endif
      {
	register FOR_COM *c;
#if defined (SELECT_COMMAND)
	if (command->type == cm_select)
	  c = (FOR_COM *)command->value.Select;
	else
#endif
	c = command->value.For;
	dispose_word (c->name);
	dispose_words (c->map_list);
	dispose_command (c->action);
	free (c);
	break;
      }

#if defined (ARITH_FOR_COMMAND)
    case cm_arith_for:
      {
	register ARITH_FOR_COM *c;

	c = command->value.ArithFor;
	dispose_words (c->init);
	dispose_words (c->test);
	dispose_words (c->step);
	dispose_command (c->action);
	free (c);
	break;
      }
#endif /* ARITH_FOR_COMMAND */

    case cm_group:
      {
	dispose_command (command->value.Group->command);
	free (command->value.Group);
	break;
      }

    case cm_subshell:
      {
	dispose_command (command->value.Subshell->command);
	free (command->value.Subshell);
	break;
      }

    case cm_coproc:
      {
	free (command->value.Coproc->name);
	dispose_command (command->value.Coproc->command);
	free (command->value.Coproc);
	break;
      }

    case cm_case:
      {
	register CASE_COM *c;
	PATTERN_LIST *t, *p;

	c = command->value.Case;
	dispose_word (c->word);

	for (p = c->clauses; p; )
	  {
	    dispose_words (p->patterns);
	    dispose_command (p->action);
	    t = p;
	    p = p->next;
	    free (t);
	  }
	free (c);
	break;
      }

    case cm_until:
    case cm_while:
      {
	register WHILE_COM *c;

	c = command->value.While;
	dispose_command (c->test);
	dispose_command (c->action);
	free (c);
	break;
      }

    case cm_if:
      {
	register IF_COM *c;

	c = command->value.If;
	dispose_command (c->test);
	dispose_command (c->true_case);
	dispose_command (c->false_case);
	free (c);
	break;
      }

    case cm_simple:
      {
	register SIMPLE_COM *c;

	c = command->value.Simple;
	dispose_words (c->words);
	dispose_redirects (c->redirects);
	free (c);
	break;
      }

    case cm_connection:
      {
	register CONNECTION *c;

	c = command->value.Connection;
	dispose_command (c->first);
	dispose_command (c->second);
	free (c);
	break;
      }

#if defined (DPAREN_ARITHMETIC)
    case cm_arith:
      {
	register ARITH_COM *c;

	c = command->value.Arith;
	dispose_words (c->exp);
	free (c);
	break;
      }
#endif /* DPAREN_ARITHMETIC */

#if defined (COND_COMMAND)
    case cm_cond:
      {
	register COND_COM *c;

	c = command->value.Cond;
	dispose_cond_node (c);
	break;
      }
#endif /* COND_COMMAND */

    case cm_function_def:
      {
	register FUNCTION_DEF *c;

	c = command->value.Function_def;
	dispose_function_def (c);
	break;
      }

    default:
      command_error ("dispose_command", CMDERR_BADTYPE, command->type, 0);
      break;
    }
  free (command);
}
warning: parse error {
  if (command == 0)
    return;

  if (command->redirects)
    dispose_redirects (command->redirects);

  switch (command->type)
    {
    case cm_for:
#if defined (SELECT_COMMAND)
    case cm_select:
#endif
      {
	register FOR_COM *c;
#if defined (SELECT_COMMAND)
	if (command->type == cm_select)
	  c = (FOR_COM *)command->value.Select;
	else
#endif
	c = command->value.For;
	dispose_word (c->name);
	dispose_words (c->map_list);
	dispose_command (c->action);
	free (c);
	break;
      }

#if defined (ARITH_FOR_COMMAND)
    case cm_arith_for:
      {
	register ARITH_FOR_COM *c;

	c = command->value.ArithFor;
	dispose_words (c->init);
	dispose_words (c->test);
	dispose_words (c->step);
	dispose_command (c->action);
	free (c);
	break;
      }
#endif /* ARITH_FOR_COMMAND */

    case cm_group:
      {
	dispose_command (command->value.Group->command);
	free (command->value.Group);
	break;
      }

    case cm_subshell:
      {
	dispose_command (command->value.Subshell->command);
	free (command->value.Subshell);
	break;
      }

    case cm_coproc:
      {
	free (command->value.Coproc->name);
	dispose_command (command->value.Coproc->command);
	free (command->value.Coproc);
	break;
      }

    case cm_case:
      {
	register CASE_COM *c;
	PATTERN_LIST *t, *p;

	c = command->value.Case;
	dispose_word (c->word);

	for (p = c->clauses; p; )
	  {
	    dispose_words (p->patterns);
	    dispose_command (p->action);
	    t = p;
	    p = p->next;
	    free (t);
	  }
	free (c);
	break;
      }

    case cm_until:
    case cm_while:
      {
	register WHILE_COM *c;

	c = command->value.While;
	dispose_command (c->test);
	dispose_command (c->action);
	free (c);
	break;
      }

    case cm_if:
      {
	register IF_COM *c;

	c = command->value.If;
	dispose_command (c->test);
	dispose_command (c->true_case);
	dispose_command (c->false_case);
	free (c);
	break;
      }

    case cm_simple:
      {
	register SIMPLE_COM *c;

	c = command->value.Simple;
	dispose_words (c->words);
	dispose_redirects (c->redirects);
	free (c);
	break;
      }

    case cm_connection:
      {
	register CONNECTION *c;

	c = command->value.Connection;
	dispose_command (c->first);
	dispose_command (c->second);
	free (c);
	break;
      }

#if defined (DPAREN_ARITHMETIC)
    case cm_arith:
      {
	register ARITH_COM *c;

	c = command->value.Arith;
	dispose_words (c->exp);
	free (c);
	break;
      }
#endif /* DPAREN_ARITHMETIC */

#if defined (COND_COMMAND)
    case cm_cond:
      {
	register COND_COM *c;

	c = command->value.Cond;
	dispose_cond_node (c);
	break;
      }
#endif /* COND_COMMAND */

    case cm_function_def:
      {
	register FUNCTION_DEF *c;

	c = command->value.Function_def;
	dispose_function_def (c);
	break;
      }

    default:
      command_error ("dispose_command", CMDERR_BADTYPE, command->type, 0);
      break;
    }
  free (command);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\dispose_cmd.c:38
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\dispose_cmd.c:228
parsing error 
{
  dispose_word (c->name);
  dispose_command (c->command);
  FREE (c->source_file);
}
warning: parse error {
  dispose_word (c->name);
  dispose_command (c->command);
  FREE (c->source_file);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\dispose_cmd.c:230
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\dispose_cmd.c:237
parsing error 
{
  dispose_function_def_contents (c);
  free (c);
}
warning: parse error {
  dispose_function_def_contents (c);
  free (c);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\dispose_cmd.c:239
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\dispose_cmd.c:246
parsing error 
{
  FREE (w->word);
  ocache_free (wdcache, WORD_DESC, w);
}
warning: parse error {
  FREE (w->word);
  ocache_free (wdcache, WORD_DESC, w);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\dispose_cmd.c:248
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\dispose_cmd.c:255
parsing error 
{
  w->word = 0;
  ocache_free (wdcache, WORD_DESC, w);
}
warning: parse error {
  w->word = 0;
  ocache_free (wdcache, WORD_DESC, w);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\dispose_cmd.c:257
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\dispose_cmd.c:264
parsing error 
{
  WORD_LIST *t;

  while (list)
    {
      t = list;
      list = list->next;
      dispose_word (t->word);
#if 0
      free (t);
#else
      ocache_free (wlcache, WORD_LIST, t);
#endif
    }
}
warning: parse error {
  WORD_LIST *t;

  while (list)
    {
      t = list;
      list = list->next;
      dispose_word (t->word);
#if 0
      free (t);
#else
      ocache_free (wlcache, WORD_LIST, t);
#endif
    }
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\dispose_cmd.c:266
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\dispose_cmd.c:303
parsing error 
{
  register REDIRECT *t;

  while (list)
    {
      t = list;
      list = list->next;

      if (t->rflags & REDIR_VARASSIGN)
	dispose_word (t->redirector.filename);

      switch (t->instruction)
	{
	case r_reading_until:
	case r_deblank_reading_until:
	  free (t->here_doc_eof);
	/*FALLTHROUGH*/
	case r_reading_string:
	case r_output_direction:
	case r_input_direction:
	case r_inputa_direction:
	case r_appending_to:
	case r_err_and_out:
	case r_append_err_and_out:
	case r_input_output:
	case r_output_force:
	case r_duplicating_input_word:
	case r_duplicating_output_word:
	case r_move_input_word:
	case r_move_output_word:
	  dispose_word (t->redirectee.filename);
	  /* FALLTHROUGH */
	default:
	  break;
	}
      free (t);
    }
}
warning: parse error {
  register REDIRECT *t;

  while (list)
    {
      t = list;
      list = list->next;

      if (t->rflags & REDIR_VARASSIGN)
	dispose_word (t->redirector.filename);

      switch (t->instruction)
	{
	case r_reading_until:
	case r_deblank_reading_until:
	  free (t->here_doc_eof);
	/*FALLTHROUGH*/
	case r_reading_string:
	case r_output_direction:
	case r_input_direction:
	case r_inputa_direction:
	case r_appending_to:
	case r_err_and_out:
	case r_append_err_and_out:
	case r_input_output:
	case r_output_force:
	case r_duplicating_input_word:
	case r_duplicating_output_word:
	case r_move_input_word:
	case r_move_output_word:
	  dispose_word (t->redirectee.filename);
	  /* FALLTHROUGH */
	default:
	  break;
	}
      free (t);
    }
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\dispose_cmd.c:305
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\error.c...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\bashtypes.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\bashansi.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\bashintl.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\shell.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\flags.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\input.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\error.c:80
parsing error 
{
  char *ename;
  int line;

  ename = get_name_for_error ();
  line = (print_lineno && interactive_shell == 0) ? executing_line_number () : -1;

  if (line > 0)
    fprintf (stderr, "%s:%s%d: ", ename, gnu_error_format ? "" : _(" line "), line);
  else
    fprintf (stderr, "%s: ", ename);
}
warning: parse error {
  char *ename;
  int line;

  ename = get_name_for_error ();
  line = (print_lineno && interactive_shell == 0) ? executing_line_number () : -1;

  if (line > 0)
    fprintf (stderr, "%s:%s%d: ", ename, gnu_error_format ? "" : _(" line "), line);
  else
    fprintf (stderr, "%s: ", ename);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\error.c:82
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\error.c:134
parsing error 
{
  report_error ("%s: %s", filename, strerror (errno));
}
warning: parse error {
  report_error ("%s: %s", filename, strerror (errno));
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\error.c:135
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\error.c:144
parsing error 
va_dcl
#endif
{
  va_list args;
  char *h;

#if defined (JOB_CONTROL)
  give_terminal_to (shell_pgrp, 0);
#endif /* JOB_CONTROL */

  SH_VA_START (args, format);

  vfprintf (stderr, format, args);
  fprintf (stderr, "\n");
  va_end (args);

#if defined (HISTORY)
  if (remember_on_history)
    {
      h = last_history_line ();
      fprintf (stderr, _("last command: %s\n"), h ? h : "(null)");
    }
#endif

#if 0
  fprintf (stderr, "Report this to %s\n", the_current_maintainer);
#endif

  fprintf (stderr, _("Aborting..."));
  fflush (stderr);

  abort ();
}
warning: parse error va_dcl
#endif
{
  va_list args;
  char *h;

#if defined (JOB_CONTROL)
  give_terminal_to (shell_pgrp, 0);
#endif /* JOB_CONTROL */

  SH_VA_START (args, format);

  vfprintf (stderr, format, args);
  fprintf (stderr, "\n");
  va_end (args);

#if defined (HISTORY)
  if (remember_on_history)
    {
      h = last_history_line ();
      fprintf (stderr, _("last command: %s\n"), h ? h : "(null)");
    }
#endif

#if 0
  fprintf (stderr, "Report this to %s\n", the_current_maintainer);
#endif

  fprintf (stderr, _("Aborting..."));
  fflush (stderr);

  abort ();
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\error.c:145
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\error.c:188
parsing error 
va_dcl
#endif
{
  va_list args;

  error_prolog (1);

  SH_VA_START (args, format);

  vfprintf (stderr, format, args);
  fprintf (stderr, "\n");

  va_end (args);
  if (exit_immediately_on_error)
    exit_shell (1);
}
warning: parse error va_dcl
#endif
{
  va_list args;

  error_prolog (1);

  SH_VA_START (args, format);

  vfprintf (stderr, format, args);
  fprintf (stderr, "\n");

  va_end (args);
  if (exit_immediately_on_error)
    exit_shell (1);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\error.c:189
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\error.c:211
parsing error 
va_dcl
#endif
{
  va_list args;

  error_prolog (0);

  SH_VA_START (args, format);

  vfprintf (stderr, format, args);
  fprintf (stderr, "\n");

  va_end (args);
  sh_exit (2);
}
warning: parse error va_dcl
#endif
{
  va_list args;

  error_prolog (0);

  SH_VA_START (args, format);

  vfprintf (stderr, format, args);
  fprintf (stderr, "\n");

  va_end (args);
  sh_exit (2);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\error.c:212
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\error.c:233
parsing error 
va_dcl
#endif
{
  va_list args;

  error_prolog (1);

  SH_VA_START (args, format);

  vfprintf (stderr, format, args);
  fprintf (stderr, "\n");

  va_end (args);
}
warning: parse error va_dcl
#endif
{
  va_list args;

  error_prolog (1);

  SH_VA_START (args, format);

  vfprintf (stderr, format, args);
  fprintf (stderr, "\n");

  va_end (args);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\error.c:234
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\error.c:254
parsing error 
va_dcl
#endif
{
  va_list args;

  error_prolog (1);
  fprintf (stderr, _("warning: "));

  SH_VA_START (args, format);

  vfprintf (stderr, format, args);
  fprintf (stderr, "\n");

  va_end (args);
}
warning: parse error va_dcl
#endif
{
  va_list args;

  error_prolog (1);
  fprintf (stderr, _("warning: "));

  SH_VA_START (args, format);

  vfprintf (stderr, format, args);
  fprintf (stderr, "\n");

  va_end (args);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\error.c:255
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\error.c:276
parsing error 
va_dcl
#endif
{
  int e;
  va_list args;

  e = errno;
  error_prolog (0);

  SH_VA_START (args, format);

  vfprintf (stderr, format, args);
  fprintf (stderr, ": %s\n", strerror (e));

  va_end (args);
}
warning: parse error va_dcl
#endif
{
  int e;
  va_list args;

  e = errno;
  error_prolog (0);

  SH_VA_START (args, format);

  vfprintf (stderr, format, args);
  fprintf (stderr, ": %s\n", strerror (e));

  va_end (args);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\error.c:277
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\error.c:306
parsing error 
va_dcl
#endif
{
  va_list args;
  char *ename, *iname;

  ename = get_name_for_error ();
  iname = yy_input_name ();

  if (interactive)
    fprintf (stderr, "%s: ", ename);
  else if (interactive_shell)
    fprintf (stderr, "%s: %s:%s%d: ", ename, iname, gnu_error_format ? "" : _(" line "), lineno);
  else if (STREQ (ename, iname))
    fprintf (stderr, "%s:%s%d: ", ename, gnu_error_format ? "" : _(" line "), lineno);
  else
    fprintf (stderr, "%s: %s:%s%d: ", ename, iname, gnu_error_format ? "" : _(" line "), lineno);

  SH_VA_START (args, format);

  vfprintf (stderr, format, args);
  fprintf (stderr, "\n");

  va_end (args);

  if (exit_immediately_on_error)
    exit_shell (last_command_exit_value = 2);
}
warning: parse error va_dcl
#endif
{
  va_list args;
  char *ename, *iname;

  ename = get_name_for_error ();
  iname = yy_input_name ();

  if (interactive)
    fprintf (stderr, "%s: ", ename);
  else if (interactive_shell)
    fprintf (stderr, "%s: %s:%s%d: ", ename, iname, gnu_error_format ? "" : _(" line "), lineno);
  else if (STREQ (ename, iname))
    fprintf (stderr, "%s:%s%d: ", ename, gnu_error_format ? "" : _(" line "), lineno);
  else
    fprintf (stderr, "%s: %s:%s%d: ", ename, iname, gnu_error_format ? "" : _(" line "), lineno);

  SH_VA_START (args, format);

  vfprintf (stderr, format, args);
  fprintf (stderr, "\n");

  va_end (args);

  if (exit_immediately_on_error)
    exit_shell (last_command_exit_value = 2);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\error.c:309
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\error.c:415
parsing error 
{
  if (code > CMDERR_LAST)
    code = CMDERR_DEFAULT;

  programming_error ("%s: %s: %d", func, _(cmd_error_table[code]), e);
}
warning: parse error {
  if (code > CMDERR_LAST)
    code = CMDERR_DEFAULT;

  programming_error ("%s: %s: %d", func, _(cmd_error_table[code]), e);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\error.c:417
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\error.c:425
parsing error 
{
  if (code > CMDERR_LAST)
    code = CMDERR_DEFAULT;

  return (_(cmd_error_table[code]));
}
warning: parse error {
  if (code > CMDERR_LAST)
    code = CMDERR_DEFAULT;

  return (_(cmd_error_table[code]));
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\error.c:427
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\error.c:445
parsing error 
{
  report_error (_("%s: unbound variable"), s);
}
warning: parse error {
  report_error (_("%s: unbound variable"), s);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\error.c:446
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\error.c:452
parsing error 
{
  report_error (_("%s: readonly variable"), s);
}
warning: parse error {
  report_error (_("%s: readonly variable"), s);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\error.c:453
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\eval.c...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\bashansi.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\bashintl.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\shell.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\flags.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\trap.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\common.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\input.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\execute_cmd.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\eval.c:178
parsing error 
{
  printf (_("\007timed out waiting for input: auto-logout\n"));
  fflush (stdout);
  bash_logout ();	/* run ~/.bash_logout if this is a login shell */
  jump_to_top_level (EXITPROG);
  SIGRETURN (0);
}
warning: parse error {
  printf (_("\007timed out waiting for input: auto-logout\n"));
  fflush (stdout);
  bash_logout ();	/* run ~/.bash_logout if this is a login shell */
  jump_to_top_level (EXITPROG);
  SIGRETURN (0);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\eval.c:180
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\examples\loadables\basename.c...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\shell.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\common.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\examples\loadables\basename.c:16
parsing error 
{
  int slen, sufflen, off;
  char *string, *suffix, *fn;

  if (list == 0)
    {
      builtin_usage ();
      return (EX_USAGE);
    }

  if (no_options (list))
    return (EX_USAGE);

  string = list->word->word;
  suffix = (char *)NULL;
  if (list->next)
    {
      list = list->next;
      suffix = list->word->word;
    }

  if (list->next)
    {
      builtin_usage ();
      return (EX_USAGE);
    }

  slen = strlen (string);

  /* Strip trailing slashes */
  while (slen > 0 && string[slen - 1] == '/')
    slen--;

  /* (2) If string consists entirely of slash characters, string shall be
	 set to a single slash character.  In this case, skip steps (3)
	 through (5). */
  if (slen == 0)
    {
      fputs ("/\n", stdout);
      return (EXECUTION_SUCCESS);
    }

  /* (3) If there are any trailing slash characters in string, they
	 shall be removed. */
  string[slen] = '\0';

  /* (4) If there are any slash characters remaining in string, the prefix
	 of string up to an including the last slash character in string
	 shall be removed. */
  while (--slen >= 0)
    if (string[slen] == '/')
      break;

  fn = string + slen + 1;

  /* (5) If the suffix operand is present, is not identical to the
	 characters remaining in string, and is identical to a suffix
	 of the characters remaining in string, the suffix suffix
	 shall be removed from string.  Otherwise, string shall not be
	 modified by this step. */
  if (suffix)
    {
      sufflen = strlen (suffix);
      slen = strlen (fn);
      if (sufflen < slen)
        {
          off = slen - sufflen;
          if (strcmp (fn + off, suffix) == 0)
            fn[off] = '\0';
        }
    }
  printf ("%s\n", fn);
  return (EXECUTION_SUCCESS);
}
warning: parse error {
  int slen, sufflen, off;
  char *string, *suffix, *fn;

  if (list == 0)
    {
      builtin_usage ();
      return (EX_USAGE);
    }

  if (no_options (list))
    return (EX_USAGE);

  string = list->word->word;
  suffix = (char *)NULL;
  if (list->next)
    {
      list = list->next;
      suffix = list->word->word;
    }

  if (list->next)
    {
      builtin_usage ();
      return (EX_USAGE);
    }

  slen = strlen (string);

  /* Strip trailing slashes */
  while (slen > 0 && string[slen - 1] == '/')
    slen--;

  /* (2) If string consists entirely of slash characters, string shall be
	 set to a single slash character.  In this case, skip steps (3)
	 through (5). */
  if (slen == 0)
    {
      fputs ("/\n", stdout);
      return (EXECUTION_SUCCESS);
    }

  /* (3) If there are any trailing slash characters in string, they
	 shall be removed. */
  string[slen] = '\0';

  /* (4) If there are any slash characters remaining in string, the prefix
	 of string up to an including the last slash character in string
	 shall be removed. */
  while (--slen >= 0)
    if (string[slen] == '/')
      break;

  fn = string + slen + 1;

  /* (5) If the suffix operand is present, is not identical to the
	 characters remaining in string, and is identical to a suffix
	 of the characters remaining in string, the suffix suffix
	 shall be removed from string.  Otherwise, string shall not be
	 modified by this step. */
  if (suffix)
    {
      sufflen = strlen (suffix);
      slen = strlen (fn);
      if (sufflen < slen)
        {
          off = slen - sufflen;
          if (strcmp (fn + off, suffix) == 0)
            fn[off] = '\0';
        }
    }
  printf ("%s\n", fn);
  return (EXECUTION_SUCCESS);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\examples\loadables\basename.c:18
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\examples\loadables\cat.c...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\shell.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\examples\loadables\cat.c:39
parsing error 
{
	char	buf[1024], *s;
	int	n, w, e;

	while (n = read(fd, buf, sizeof (buf))) {
		w = write(1, buf, n);
		if (w != n) {
			e = errno;
			write(2, "cat: write error: ", 18);
			s = strerror(e);
			write(2, s, strlen(s));
			write(2, "\n", 1);
			return 1;
		}
	}
	return 0;
}
warning: parse error {
	char	buf[1024], *s;
	int	n, w, e;

	while (n = read(fd, buf, sizeof (buf))) {
		w = write(1, buf, n);
		if (w != n) {
			e = errno;
			write(2, "cat: write error: ", 18);
			s = strerror(e);
			write(2, s, strlen(s));
			write(2, "\n", 1);
			return 1;
		}
	}
	return 0;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\examples\loadables\cat.c:41
parsing error 
cat_main (argc, argv)
int	argc;
warning: parse error cat_main (argc, argv)
int	argc;Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\examples\loadables\cat.c:59
parsing error 
{
	int	i, fd, r;
	char	*s;

	if (argc == 1)
		return (fcopy(0));

	for (i = r = 1; i < argc; i++) {
		if (argv[i][0] == '-' && argv[i][1] == '\0')
			fd = 0;
		else {
			fd = open(argv[i], O_RDONLY, 0666);
			if (fd < 0) {
				s = strerror(errno);
				write(2, "cat: cannot open ", 17);
				write(2, argv[i], strlen(argv[i]));
				write(2, ": ", 2);
				write(2, s, strlen(s));
				write(2, "\n", 1);
				continue;
			}
		}
		r = fcopy(fd);
		if (fd != 0)
			close(fd);
	}
	return (r);
}
warning: parse error {
	int	i, fd, r;
	char	*s;

	if (argc == 1)
		return (fcopy(0));

	for (i = r = 1; i < argc; i++) {
		if (argv[i][0] == '-' && argv[i][1] == '\0')
			fd = 0;
		else {
			fd = open(argv[i], O_RDONLY, 0666);
			if (fd < 0) {
				s = strerror(errno);
				write(2, "cat: cannot open ", 17);
				write(2, argv[i], strlen(argv[i]));
				write(2, ": ", 2);
				write(2, s, strlen(s));
				write(2, "\n", 1);
				continue;
			}
		}
		r = fcopy(fd);
		if (fd != 0)
			close(fd);
	}
	return (r);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\examples\loadables\cat.c:62
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\examples\loadables\cat.c:91
parsing error 
{
	char	**v;
	int	c, r;

	v = make_builtin_argv(list, &c);
	r = cat_main(c, v);
	free(v);

	return r;
}
warning: parse error {
	char	**v;
	int	c, r;

	v = make_builtin_argv(list, &c);
	r = cat_main(c, v);
	free(v);

	return r;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\examples\loadables\cat.c:93
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\examples\loadables\cut.c...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\bashansi.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\shell.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\bashgetopt.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\common.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\examples\loadables\cut.c:91
parsing error 
{
	FILE *fp;
	int (*fcn) __P((FILE *, char *)) = NULL;
	int ch;

	fcn = NULL;
	dchar = '\t';			/* default delimiter is \t */

	/* Since we don't support multi-byte characters, the -c and -b 
	   options are equivalent, and the -n option is meaningless. */
	reset_internal_getopt ();
	while ((ch = internal_getopt (list, "b:c:d:f:sn")) != -1)
		switch(ch) {
		case 'b':
		case 'c':
			fcn = c_cut;
			if (get_list(list_optarg) < 0)
				return (EXECUTION_FAILURE);
			cflag = 1;
			break;
		case 'd':
			dchar = *list_optarg;
			dflag = 1;
			break;
		case 'f':
			fcn = f_cut;
			if (get_list(list_optarg) < 0)
				return (EXECUTION_FAILURE);
			fflag = 1;
			break;
		case 's':
			sflag = 1;
			break;
		case 'n':
			break;
		case '?':
		default:
			builtin_usage();
			return (EX_USAGE);
		}

	list = loptend;

	if (fflag) {
		if (cflag) {
			builtin_usage();
			return (EX_USAGE);
		}
	} else if (!cflag || dflag || sflag) {
		builtin_usage();
		return (EX_USAGE);
	}

	if (list) {
		while (list) {
			fp = fopen(list->word->word, "r");
			if (fp == 0) {
				builtin_error("%s", list->word->word);
				return (EXECUTION_FAILURE);
			}
			ch = (*fcn)(fp, list->word->word);
			(void)fclose(fp);
			if (ch < 0)
				return (EXECUTION_FAILURE);
			list = list->next;
		}
	} else {
		ch = (*fcn)(stdin, "stdin");
		if (ch < 0)
			return (EXECUTION_FAILURE);
	}

	return (EXECUTION_SUCCESS);
}
warning: parse error {
	FILE *fp;
	int (*fcn) __P((FILE *, char *)) = NULL;
	int ch;

	fcn = NULL;
	dchar = '\t';			/* default delimiter is \t */

	/* Since we don't support multi-byte characters, the -c and -b 
	   options are equivalent, and the -n option is meaningless. */
	reset_internal_getopt ();
	while ((ch = internal_getopt (list, "b:c:d:f:sn")) != -1)
		switch(ch) {
		case 'b':
		case 'c':
			fcn = c_cut;
			if (get_list(list_optarg) < 0)
				return (EXECUTION_FAILURE);
			cflag = 1;
			break;
		case 'd':
			dchar = *list_optarg;
			dflag = 1;
			break;
		case 'f':
			fcn = f_cut;
			if (get_list(list_optarg) < 0)
				return (EXECUTION_FAILURE);
			fflag = 1;
			break;
		case 's':
			sflag = 1;
			break;
		case 'n':
			break;
		case '?':
		default:
			builtin_usage();
			return (EX_USAGE);
		}

	list = loptend;

	if (fflag) {
		if (cflag) {
			builtin_usage();
			return (EX_USAGE);
		}
	} else if (!cflag || dflag || sflag) {
		builtin_usage();
		return (EX_USAGE);
	}

	if (list) {
		while (list) {
			fp = fopen(list->word->word, "r");
			if (fp == 0) {
				builtin_error("%s", list->word->word);
				return (EXECUTION_FAILURE);
			}
			ch = (*fcn)(fp, list->word->word);
			(void)fclose(fp);
			if (ch < 0)
				return (EXECUTION_FAILURE);
			list = list->next;
		}
	} else {
		ch = (*fcn)(stdin, "stdin");
		if (ch < 0)
			return (EXECUTION_FAILURE);
	}

	return (EXECUTION_SUCCESS);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\examples\loadables\cut.c:93
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\examples\loadables\cut.c:169
parsing error 
{
	int setautostart, start, stop;
	char *pos;
	char *p;

	/*
	 * set a byte in the positions array to indicate if a field or
	 * column is to be selected; use +1, it's 1-based, not 0-based.
	 * This parser is less restrictive than the Draft 9 POSIX spec.
	 * POSIX doesn't allow lists that aren't in increasing order or
	 * overlapping lists.  We also handle "-3-5" although there's no
	 * real reason too.
	 */
	for (; (p = _cut_strsep(&list, ", \t")) != NULL;) {
		setautostart = start = stop = 0;
		if (*p == '-') {
			++p;
			setautostart = 1;
		}
		if (isdigit((unsigned char)*p)) {
			start = stop = strtol(p, &p, 10);
			if (setautostart && start > autostart)
				autostart = start;
		}
		if (*p == '-') {
			if (isdigit((unsigned char)p[1]))
				stop = strtol(p + 1, &p, 10);
			if (*p == '-') {
				++p;
				if (!autostop || autostop > stop)
					autostop = stop;
			}
		}
		if (*p) {
			builtin_error("[-cf] list: illegal list value");
			return -1;
		}
		if (!stop || !start) {
			builtin_error("[-cf] list: values may not include zero");
			return -1;
		}
		if (stop > _POSIX2_LINE_MAX) {
			builtin_error("[-cf] list: %d too large (max %d)",
				       stop, _POSIX2_LINE_MAX);
			return -1;
		}
		if (maxval < stop)
			maxval = stop;
		for (pos = positions + start; start++ <= stop; *pos++ = 1);
	}

	/* overlapping ranges */
	if (autostop && maxval > autostop)
		maxval = autostop;

	/* set autostart */
	if (autostart)
		memset(positions + 1, '1', autostart);

	return 0;
}
warning: parse error {
	int setautostart, start, stop;
	char *pos;
	char *p;

	/*
	 * set a byte in the positions array to indicate if a field or
	 * column is to be selected; use +1, it's 1-based, not 0-based.
	 * This parser is less restrictive than the Draft 9 POSIX spec.
	 * POSIX doesn't allow lists that aren't in increasing order or
	 * overlapping lists.  We also handle "-3-5" although there's no
	 * real reason too.
	 */
	for (; (p = _cut_strsep(&list, ", \t")) != NULL;) {
		setautostart = start = stop = 0;
		if (*p == '-') {
			++p;
			setautostart = 1;
		}
		if (isdigit((unsigned char)*p)) {
			start = stop = strtol(p, &p, 10);
			if (setautostart && start > autostart)
				autostart = start;
		}
		if (*p == '-') {
			if (isdigit((unsigned char)p[1]))
				stop = strtol(p + 1, &p, 10);
			if (*p == '-') {
				++p;
				if (!autostop || autostop > stop)
					autostop = stop;
			}
		}
		if (*p) {
			builtin_error("[-cf] list: illegal list value");
			return -1;
		}
		if (!stop || !start) {
			builtin_error("[-cf] list: values may not include zero");
			return -1;
		}
		if (stop > _POSIX2_LINE_MAX) {
			builtin_error("[-cf] list: %d too large (max %d)",
				       stop, _POSIX2_LINE_MAX);
			return -1;
		}
		if (maxval < stop)
			maxval = stop;
		for (pos = positions + start; start++ <= stop; *pos++ = 1);
	}

	/* overlapping ranges */
	if (autostop && maxval > autostop)
		maxval = autostop;

	/* set autostart */
	if (autostart)
		memset(positions + 1, '1', autostart);

	return 0;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\examples\loadables\cut.c:171
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\examples\loadables\cut.c:235
parsing error 
{
	int ch, col;
	char *pos;

	ch = 0;
	for (;;) {
		pos = positions + 1;
		for (col = maxval; col; --col) {
			if ((ch = getc(fp)) == EOF)
				return;
			if (ch == '\n')
				break;
			if (*pos++)
				(void)putchar(ch);
		}
		if (ch != '\n') {
			if (autostop)
				while ((ch = getc(fp)) != EOF && ch != '\n')
					(void)putchar(ch);
			else
				while ((ch = getc(fp)) != EOF && ch != '\n');
		}
		(void)putchar('\n');
	}
	return (0);
}
warning: parse error {
	int ch, col;
	char *pos;

	ch = 0;
	for (;;) {
		pos = positions + 1;
		for (col = maxval; col; --col) {
			if ((ch = getc(fp)) == EOF)
				return;
			if (ch == '\n')
				break;
			if (*pos++)
				(void)putchar(ch);
		}
		if (ch != '\n') {
			if (autostop)
				while ((ch = getc(fp)) != EOF && ch != '\n')
					(void)putchar(ch);
			else
				while ((ch = getc(fp)) != EOF && ch != '\n');
		}
		(void)putchar('\n');
	}
	return (0);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\examples\loadables\cut.c:238
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\examples\loadables\cut.c:266
parsing error 
{
	int ch, field, isdelim;
	char *pos, *p, sep;
	int output;
	char lbuf[_POSIX2_LINE_MAX + 1];

	for (sep = dchar; fgets(lbuf, sizeof(lbuf), fp);) {
		output = 0;
		for (isdelim = 0, p = lbuf;; ++p) {
			if (!(ch = *p)) {
				builtin_error("%s: line too long.", fname);
				return -1;
			}
			/* this should work if newline is delimiter */
			if (ch == sep)
				isdelim = 1;
			if (ch == '\n') {
				if (!isdelim && !sflag)
					(void)printf("%s", lbuf);
				break;
			}
		}
		if (!isdelim)
			continue;

		pos = positions + 1;
		for (field = maxval, p = lbuf; field; --field, ++pos) {
			if (*pos) {
				if (output++)
					(void)putchar(sep);
				while ((ch = *p++) != '\n' && ch != sep)
					(void)putchar(ch);
			} else {
				while ((ch = *p++) != '\n' && ch != sep)
					continue;
			}
			if (ch == '\n')
				break;
		}
		if (ch != '\n') {
			if (autostop) {
				if (output)
					(void)putchar(sep);
				for (; (ch = *p) != '\n'; ++p)
					(void)putchar(ch);
			} else
				for (; (ch = *p) != '\n'; ++p);
		}
		(void)putchar('\n');
	}
	return (0);
}
warning: parse error {
	int ch, field, isdelim;
	char *pos, *p, sep;
	int output;
	char lbuf[_POSIX2_LINE_MAX + 1];

	for (sep = dchar; fgets(lbuf, sizeof(lbuf), fp);) {
		output = 0;
		for (isdelim = 0, p = lbuf;; ++p) {
			if (!(ch = *p)) {
				builtin_error("%s: line too long.", fname);
				return -1;
			}
			/* this should work if newline is delimiter */
			if (ch == sep)
				isdelim = 1;
			if (ch == '\n') {
				if (!isdelim && !sflag)
					(void)printf("%s", lbuf);
				break;
			}
		}
		if (!isdelim)
			continue;

		pos = positions + 1;
		for (field = maxval, p = lbuf; field; --field, ++pos) {
			if (*pos) {
				if (output++)
					(void)putchar(sep);
				while ((ch = *p++) != '\n' && ch != sep)
					(void)putchar(ch);
			} else {
				while ((ch = *p++) != '\n' && ch != sep)
					continue;
			}
			if (ch == '\n')
				break;
		}
		if (ch != '\n') {
			if (autostop) {
				if (output)
					(void)putchar(sep);
				for (; (ch = *p) != '\n'; ++p)
					(void)putchar(ch);
			} else
				for (; (ch = *p) != '\n'; ++p);
		}
		(void)putchar('\n');
	}
	return (0);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\examples\loadables\cut.c:269
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\examples\loadables\cut.c:334
parsing error 
{
	register char *s;
	register const char *spanp;
	register int c, sc;
	char *tok;

	if ((s = *stringp) == NULL)
		return (NULL);
	for (tok = s;;) {
		c = *s++;
		spanp = delim;
		do {
			if ((sc = *spanp++) == c) {
				if (c == 0)
					s = NULL;
				else
					s[-1] = 0;
				*stringp = s;
				return (tok);
			}
		} while (sc != 0);
	}
	/* NOTREACHED */
}
warning: parse error {
	register char *s;
	register const char *spanp;
	register int c, sc;
	char *tok;

	if ((s = *stringp) == NULL)
		return (NULL);
	for (tok = s;;) {
		c = *s++;
		spanp = delim;
		do {
			if ((sc = *spanp++) == c) {
				if (c == 0)
					s = NULL;
				else
					s[-1] = 0;
				*stringp = s;
				return (tok);
			}
		} while (sc != 0);
	}
	/* NOTREACHED */
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\examples\loadables\cut.c:337
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\examples\loadables\dirname.c...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\shell.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\common.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\examples\loadables\dirname.c:34
parsing error 
{
  int slen;
  char *string;

  if (list == 0 || list->next)
    {
      builtin_usage ();
      return (EX_USAGE);
    }

  if (no_options (list))
    return (EX_USAGE);

  string = list->word->word;
  slen = strlen (string);

  /* Strip trailing slashes */
  while (slen > 0 && string[slen - 1] == '/')
    slen--;

  /* (2) If string consists entirely of slash characters, string shall be
	 set to a single slash character.  In this case, skip steps (3)
	 through (8). */
  if (slen == 0)
    {
      fputs ("/\n", stdout);
      return (EXECUTION_SUCCESS);
    }

  /* (3) If there are any trailing slash characters in string, they
	 shall be removed. */
  string[slen] = '\0';

  /* (4) If there are no slash characters remaining in string, string
	 shall be set to a single period character.  In this case, skip
	 steps (5) through (8).

     (5) If there are any trailing nonslash characters in string,
	 they shall be removed. */

  while (--slen >= 0)
    if (string[slen] == '/')
      break;

  if (slen < 0)
    {
      fputs (".\n", stdout);
      return (EXECUTION_SUCCESS);
    }

  /* (7) If there are any trailing slash characters in string, they
	 shall be removed. */
  while (--slen >= 0)
    if (string[slen] != '/')
      break;
  string[++slen] = '\0';

  /* (8) If the remaining string is empty, string shall be set to a single
	 slash character. */
  printf ("%s\n", (slen == 0) ? "/" : string);
  return (EXECUTION_SUCCESS);
}
warning: parse error {
  int slen;
  char *string;

  if (list == 0 || list->next)
    {
      builtin_usage ();
      return (EX_USAGE);
    }

  if (no_options (list))
    return (EX_USAGE);

  string = list->word->word;
  slen = strlen (string);

  /* Strip trailing slashes */
  while (slen > 0 && string[slen - 1] == '/')
    slen--;

  /* (2) If string consists entirely of slash characters, string shall be
	 set to a single slash character.  In this case, skip steps (3)
	 through (8). */
  if (slen == 0)
    {
      fputs ("/\n", stdout);
      return (EXECUTION_SUCCESS);
    }

  /* (3) If there are any trailing slash characters in string, they
	 shall be removed. */
  string[slen] = '\0';

  /* (4) If there are no slash characters remaining in string, string
	 shall be set to a single period character.  In this case, skip
	 steps (5) through (8).

     (5) If there are any trailing nonslash characters in string,
	 they shall be removed. */

  while (--slen >= 0)
    if (string[slen] == '/')
      break;

  if (slen < 0)
    {
      fputs (".\n", stdout);
      return (EXECUTION_SUCCESS);
    }

  /* (7) If there are any trailing slash characters in string, they
	 shall be removed. */
  while (--slen >= 0)
    if (string[slen] != '/')
      break;
  string[++slen] = '\0';

  /* (8) If the remaining string is empty, string shall be set to a single
	 slash character. */
  printf ("%s\n", (slen == 0) ? "/" : string);
  return (EXECUTION_SUCCESS);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\examples\loadables\dirname.c:36
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\examples\loadables\finfo.c...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\posixstat.h...skip
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\posixtime.h...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\bashansi.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\shell.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\common.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\examples\loadables\finfo.c:67
parsing error 
{
	int	r;

	r = *s - '0';
	while (*++s >= '0' && *s <= '7')
		r = (r * 8) + (*s - '0');
	return r;
}
warning: parse error {
	int	r;

	r = *s - '0';
	while (*++s >= '0' && *s <= '7')
		r = (r * 8) + (*s - '0');
	return r;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\examples\loadables\finfo.c:69
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\examples\loadables\finfo.c:79
parsing error 
{
	register int	i;
	int	mode, flags, opt;

	sh_optind = 0;	/* XXX */
	prog = base_pathname(argv[0]);
	if (argc == 1) {
		builtin_usage();
		return(1);
	}
	flags = 0;
	while ((opt = sh_getopt(argc, argv, OPTIONS)) != EOF) {
		switch(opt) {
		case 'a': flags |= OPT_ATIME; break;
		case 'A': flags |= OPT_ATIME|OPT_ASCII; break;
		case 'c': flags |= OPT_CTIME; break;
		case 'C': flags |= OPT_CTIME|OPT_ASCII; break;
		case 'd': flags |= OPT_DEV; break;
		case 'i': flags |= OPT_INO; break;
		case 'f': flags |= OPT_FID; break;
		case 'g': flags |= OPT_GID; break;
		case 'G': flags |= OPT_GID|OPT_ASCII; break;
		case 'l': flags |= OPT_LNKNAM; break;
		case 'm': flags |= OPT_MTIME; break;
		case 'M': flags |= OPT_MTIME|OPT_ASCII; break;
		case 'n': flags |= OPT_NLINK; break;
		case 'o': flags |= OPT_OPERM; break;
		case 'p': flags |= OPT_PERM; break;
		case 'P': flags |= OPT_PMASK; pmask = octal(sh_optarg); break;
		case 's': flags |= OPT_SIZE; break;
		case 'u': flags |= OPT_UID; break;
		case 'U': flags |= OPT_UID|OPT_ASCII; break;
		default: builtin_usage (); return(1);
		}
	}

	argc -= sh_optind;
	argv += sh_optind;

	if (argc == 0) {
		builtin_usage();
		return(1);
	}

	for (i = 0; i < argc; i++)
		opt = flags ? printsome (argv[i], flags) : printfinfo(argv[i]);

	return(opt);
}
warning: parse error {
	register int	i;
	int	mode, flags, opt;

	sh_optind = 0;	/* XXX */
	prog = base_pathname(argv[0]);
	if (argc == 1) {
		builtin_usage();
		return(1);
	}
	flags = 0;
	while ((opt = sh_getopt(argc, argv, OPTIONS)) != EOF) {
		switch(opt) {
		case 'a': flags |= OPT_ATIME; break;
		case 'A': flags |= OPT_ATIME|OPT_ASCII; break;
		case 'c': flags |= OPT_CTIME; break;
		case 'C': flags |= OPT_CTIME|OPT_ASCII; break;
		case 'd': flags |= OPT_DEV; break;
		case 'i': flags |= OPT_INO; break;
		case 'f': flags |= OPT_FID; break;
		case 'g': flags |= OPT_GID; break;
		case 'G': flags |= OPT_GID|OPT_ASCII; break;
		case 'l': flags |= OPT_LNKNAM; break;
		case 'm': flags |= OPT_MTIME; break;
		case 'M': flags |= OPT_MTIME|OPT_ASCII; break;
		case 'n': flags |= OPT_NLINK; break;
		case 'o': flags |= OPT_OPERM; break;
		case 'p': flags |= OPT_PERM; break;
		case 'P': flags |= OPT_PMASK; pmask = octal(sh_optarg); break;
		case 's': flags |= OPT_SIZE; break;
		case 'u': flags |= OPT_UID; break;
		case 'U': flags |= OPT_UID|OPT_ASCII; break;
		default: builtin_usage (); return(1);
		}
	}

	argc -= sh_optind;
	argv += sh_optind;

	if (argc == 0) {
		builtin_usage();
		return(1);
	}

	for (i = 0; i < argc; i++)
		opt = flags ? printsome (argv[i], flags) : printfinfo(argv[i]);

	return(opt);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\examples\loadables\finfo.c:82
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\examples\loadables\finfo.c:133
parsing error 
{
	static struct stat st;
	int	fd, r;
	intmax_t lfd;

	if (strncmp(f, "/dev/fd/", 8) == 0) {
		if ((legal_number(f + 8, &lfd) == 0) || (int)lfd != lfd) {
			builtin_error("%s: invalid fd", f + 8);
			return ((struct stat *)0);
		}
		fd = lfd;
		r = fstat(fd, &st);
	} else
#ifdef HAVE_LSTAT
		r = lstat(f, &st);
#else
		r = stat(f, &st);
#endif
	if (r < 0) {
		builtin_error("%s: cannot stat: %s", f, strerror(errno));
		return ((struct stat *)0);
	}
	return (&st);
}
warning: parse error {
	static struct stat st;
	int	fd, r;
	intmax_t lfd;

	if (strncmp(f, "/dev/fd/", 8) == 0) {
		if ((legal_number(f + 8, &lfd) == 0) || (int)lfd != lfd) {
			builtin_error("%s: invalid fd", f + 8);
			return ((struct stat *)0);
		}
		fd = lfd;
		r = fstat(fd, &st);
	} else
#ifdef HAVE_LSTAT
		r = lstat(f, &st);
#else
		r = stat(f, &st);
#endif
	if (r < 0) {
		builtin_error("%s: cannot stat: %s", f, strerror(errno));
		return ((struct stat *)0);
	}
	return (&st);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\examples\loadables\finfo.c:135
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\examples\loadables\finfo.c:161
parsing error 
{
	struct stat *st;

	st = getstat(f);
	return (st ? printst(st) : 1);
}
warning: parse error {
	struct stat *st;

	st = getstat(f);
	return (st ? printst(st) : 1);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\examples\loadables\finfo.c:163
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\examples\loadables\finfo.c:171
parsing error 
{
	return (m & (S_IRWXU|S_IRWXG|S_IRWXO|S_ISUID|S_ISGID));
}
warning: parse error {
	return (m & (S_IRWXU|S_IRWXG|S_IRWXO|S_ISUID|S_ISGID));
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\examples\loadables\finfo.c:173
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\examples\loadables\finfo.c:178
parsing error 
{
	char ubits[4], gbits[4], obits[4];	/* u=rwx,g=rwx,o=rwx */
	int i;

	i = 0;
	if (m & S_IRUSR)
		ubits[i++] = 'r';
	if (m & S_IWUSR)
		ubits[i++] = 'w';
	if (m & S_IXUSR)
		ubits[i++] = 'x';
	ubits[i] = '\0';

	i = 0;
	if (m & S_IRGRP)
		gbits[i++] = 'r';
	if (m & S_IWGRP)
		gbits[i++] = 'w';
	if (m & S_IXGRP)
		gbits[i++] = 'x';
	gbits[i] = '\0';

	i = 0;
	if (m & S_IROTH)
		obits[i++] = 'r';
	if (m & S_IWOTH)
		obits[i++] = 'w';
	if (m & S_IXOTH)
		obits[i++] = 'x';
	obits[i] = '\0';

	if (m & S_ISUID)
		ubits[2] = (m & S_IXUSR) ? 's' : 'S';
	if (m & S_ISGID)
		gbits[2] = (m & S_IXGRP) ? 's' : 'S';
	if (m & S_ISVTX)
		obits[2] = (m & S_IXOTH) ? 't' : 'T';

	printf ("u=%s,g=%s,o=%s", ubits, gbits, obits);
}
warning: parse error {
	char ubits[4], gbits[4], obits[4];	/* u=rwx,g=rwx,o=rwx */
	int i;

	i = 0;
	if (m & S_IRUSR)
		ubits[i++] = 'r';
	if (m & S_IWUSR)
		ubits[i++] = 'w';
	if (m & S_IXUSR)
		ubits[i++] = 'x';
	ubits[i] = '\0';

	i = 0;
	if (m & S_IRGRP)
		gbits[i++] = 'r';
	if (m & S_IWGRP)
		gbits[i++] = 'w';
	if (m & S_IXGRP)
		gbits[i++] = 'x';
	gbits[i] = '\0';

	i = 0;
	if (m & S_IROTH)
		obits[i++] = 'r';
	if (m & S_IWOTH)
		obits[i++] = 'w';
	if (m & S_IXOTH)
		obits[i++] = 'x';
	obits[i] = '\0';

	if (m & S_ISUID)
		ubits[2] = (m & S_IXUSR) ? 's' : 'S';
	if (m & S_ISGID)
		gbits[2] = (m & S_IXGRP) ? 's' : 'S';
	if (m & S_ISVTX)
		obits[2] = (m & S_IXOTH) ? 't' : 'T';

	printf ("u=%s,g=%s,o=%s", ubits, gbits, obits);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\examples\loadables\finfo.c:180
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\examples\loadables\finfo.c:222
parsing error 
{
	if (S_ISBLK(mode))
		printf("S_IFBLK ");
	if (S_ISCHR(mode))
		printf("S_IFCHR ");
	if (S_ISDIR(mode))
		printf("S_IFDIR ");
	if (S_ISREG(mode))
		printf("S_IFREG ");
	if (S_ISFIFO(mode))
		printf("S_IFIFO ");
	if (S_ISLNK(mode))
		printf("S_IFLNK ");
	if (S_ISSOCK(mode))
		printf("S_IFSOCK ");
#ifdef S_ISWHT
	if (S_ISWHT(mode))
		printf("S_ISWHT ");
#endif
	perms(getperm(mode));
	printf("\n");
}
warning: parse error {
	if (S_ISBLK(mode))
		printf("S_IFBLK ");
	if (S_ISCHR(mode))
		printf("S_IFCHR ");
	if (S_ISDIR(mode))
		printf("S_IFDIR ");
	if (S_ISREG(mode))
		printf("S_IFREG ");
	if (S_ISFIFO(mode))
		printf("S_IFIFO ");
	if (S_ISLNK(mode))
		printf("S_IFLNK ");
	if (S_ISSOCK(mode))
		printf("S_IFSOCK ");
#ifdef S_ISWHT
	if (S_ISWHT(mode))
		printf("S_ISWHT ");
#endif
	perms(getperm(mode));
	printf("\n");
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\examples\loadables\finfo.c:224
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\examples\loadables\finfo.c:248
parsing error 
{
	struct passwd	*pw;
	struct group	*gr;
	char	*owner;
	int	ma, mi, d;

	ma = major (st->st_rdev);
	mi = minor (st->st_rdev);
#if defined (makedev)
	d = makedev (ma, mi);
#else
	d = st->st_rdev & 0xFF;
#endif
	printf("Device (major/minor): %d (%d/%d)\n", d, ma, mi);

	printf("Inode: %d\n", (int) st->st_ino);
	printf("Mode: (%o) ", (int) st->st_mode);
	printmode((int) st->st_mode);
	printf("Link count: %d\n", (int) st->st_nlink);
	pw = getpwuid(st->st_uid);
	owner = pw ? pw->pw_name : "unknown";
	printf("Uid of owner: %d (%s)\n", (int) st->st_uid, owner);
	gr = getgrgid(st->st_gid);
	owner = gr ? gr->gr_name : "unknown";
	printf("Gid of owner: %d (%s)\n", (int) st->st_gid, owner);
	printf("Device type: %d\n", (int) st->st_rdev);
	printf("File size: %ld\n", (long) st->st_size);
	printf("File last access time: %s", ctime (&st->st_atime));
	printf("File last modify time: %s", ctime (&st->st_mtime));
	printf("File last status change time: %s", ctime (&st->st_ctime));
	fflush(stdout);
	return(0);
}
warning: parse error {
	struct passwd	*pw;
	struct group	*gr;
	char	*owner;
	int	ma, mi, d;

	ma = major (st->st_rdev);
	mi = minor (st->st_rdev);
#if defined (makedev)
	d = makedev (ma, mi);
#else
	d = st->st_rdev & 0xFF;
#endif
	printf("Device (major/minor): %d (%d/%d)\n", d, ma, mi);

	printf("Inode: %d\n", (int) st->st_ino);
	printf("Mode: (%o) ", (int) st->st_mode);
	printmode((int) st->st_mode);
	printf("Link count: %d\n", (int) st->st_nlink);
	pw = getpwuid(st->st_uid);
	owner = pw ? pw->pw_name : "unknown";
	printf("Uid of owner: %d (%s)\n", (int) st->st_uid, owner);
	gr = getgrgid(st->st_gid);
	owner = gr ? gr->gr_name : "unknown";
	printf("Gid of owner: %d (%s)\n", (int) st->st_gid, owner);
	printf("Device type: %d\n", (int) st->st_rdev);
	printf("File size: %ld\n", (long) st->st_size);
	printf("File last access time: %s", ctime (&st->st_atime));
	printf("File last modify time: %s", ctime (&st->st_mtime));
	printf("File last status change time: %s", ctime (&st->st_ctime));
	fflush(stdout);
	return(0);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\examples\loadables\finfo.c:250
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\examples\loadables\finfo.c:285
parsing error 
{
	struct stat *st;
	struct passwd *pw;
	struct group *gr;
	int	p;
	char	*b;

	st = getstat(f);
	if (st == NULL)
		return (1);

	/* Print requested info */
	if (flags & OPT_ATIME) {
		if (flags & OPT_ASCII)
			printf("%s", ctime(&st->st_atime));
		else
			printf("%ld\n", st->st_atime);
	} else if (flags & OPT_MTIME) {
		if (flags & OPT_ASCII)
			printf("%s", ctime(&st->st_mtime));
		else
			printf("%ld\n", st->st_mtime);
	} else if (flags & OPT_CTIME) {
		if (flags & OPT_ASCII)
			printf("%s", ctime(&st->st_ctime));
		else
			printf("%ld\n", st->st_ctime);
	} else if (flags & OPT_DEV)
		printf("%d\n", st->st_dev);
	else if (flags & OPT_INO)
		printf("%d\n", st->st_ino);
	else if (flags & OPT_FID)
		printf("%d:%ld\n", st->st_dev, st->st_ino);
	else if (flags & OPT_NLINK)
		printf("%d\n", st->st_nlink);
	else if (flags & OPT_LNKNAM) {
#ifdef S_ISLNK
		b = xmalloc(4096);
		p = readlink(f, b, 4096);
		if (p >= 0 && p < 4096)
			b[p] = '\0';
		else {
			p = errno;
			strcpy(b, prog);
			strcat(b, ": ");
			strcat(b, strerror(p));
		}
		printf("%s\n", b);
		free(b);
#else
		printf("%s\n", f);
#endif
	} else if (flags & OPT_PERM) {
		perms(st->st_mode);
		printf("\n");
	} else if (flags & OPT_OPERM)
		printf("%o\n", getperm(st->st_mode));
	else if (flags & OPT_PMASK)
		printf("%o\n", getperm(st->st_mode) & pmask);
	else if (flags & OPT_UID) {
		pw = getpwuid(st->st_uid);
		if (flags & OPT_ASCII)
			printf("%s\n", pw ? pw->pw_name : "unknown");
		else
			printf("%d\n", st->st_uid);
	} else if (flags & OPT_GID) {
		gr = getgrgid(st->st_gid);
		if (flags & OPT_ASCII)
			printf("%s\n", gr ? gr->gr_name : "unknown");
		else
			printf("%d\n", st->st_gid);
	} else if (flags & OPT_SIZE)
		printf("%ld\n", (long) st->st_size);

	return (0);
}
warning: parse error {
	struct stat *st;
	struct passwd *pw;
	struct group *gr;
	int	p;
	char	*b;

	st = getstat(f);
	if (st == NULL)
		return (1);

	/* Print requested info */
	if (flags & OPT_ATIME) {
		if (flags & OPT_ASCII)
			printf("%s", ctime(&st->st_atime));
		else
			printf("%ld\n", st->st_atime);
	} else if (flags & OPT_MTIME) {
		if (flags & OPT_ASCII)
			printf("%s", ctime(&st->st_mtime));
		else
			printf("%ld\n", st->st_mtime);
	} else if (flags & OPT_CTIME) {
		if (flags & OPT_ASCII)
			printf("%s", ctime(&st->st_ctime));
		else
			printf("%ld\n", st->st_ctime);
	} else if (flags & OPT_DEV)
		printf("%d\n", st->st_dev);
	else if (flags & OPT_INO)
		printf("%d\n", st->st_ino);
	else if (flags & OPT_FID)
		printf("%d:%ld\n", st->st_dev, st->st_ino);
	else if (flags & OPT_NLINK)
		printf("%d\n", st->st_nlink);
	else if (flags & OPT_LNKNAM) {
#ifdef S_ISLNK
		b = xmalloc(4096);
		p = readlink(f, b, 4096);
		if (p >= 0 && p < 4096)
			b[p] = '\0';
		else {
			p = errno;
			strcpy(b, prog);
			strcat(b, ": ");
			strcat(b, strerror(p));
		}
		printf("%s\n", b);
		free(b);
#else
		printf("%s\n", f);
#endif
	} else if (flags & OPT_PERM) {
		perms(st->st_mode);
		printf("\n");
	} else if (flags & OPT_OPERM)
		printf("%o\n", getperm(st->st_mode));
	else if (flags & OPT_PMASK)
		printf("%o\n", getperm(st->st_mode) & pmask);
	else if (flags & OPT_UID) {
		pw = getpwuid(st->st_uid);
		if (flags & OPT_ASCII)
			printf("%s\n", pw ? pw->pw_name : "unknown");
		else
			printf("%d\n", st->st_uid);
	} else if (flags & OPT_GID) {
		gr = getgrgid(st->st_gid);
		if (flags & OPT_ASCII)
			printf("%s\n", gr ? gr->gr_name : "unknown");
		else
			printf("%d\n", st->st_gid);
	} else if (flags & OPT_SIZE)
		printf("%ld\n", (long) st->st_size);

	return (0);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\examples\loadables\finfo.c:288
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\examples\loadables\finfo.c:367
parsing error 
{
  int c, r;
  char **v;
  WORD_LIST *l;

  v = make_builtin_argv (list, &c);
  r = finfo_main (c, v);
  free (v);

  return r;
}
warning: parse error {
  int c, r;
  char **v;
  WORD_LIST *l;

  v = make_builtin_argv (list, &c);
  r = finfo_main (c, v);
  free (v);

  return r;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\examples\loadables\finfo.c:369
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\examples\loadables\getconf.c...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\typemax.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\bashansi.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\shell.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\stdc.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\common.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\bashgetopt.h...skip
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\examples\loadables\getconf.h...
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\examples\loadables\getconf.c:1,133
parsing error 
{
  int c, r, opt, aflag;
  char **v;

  aflag = 0;
  reset_internal_getopt();
  while ((opt = internal_getopt (list, "ahv:")) != -1) {
  	switch (opt) {
  	case 'a':
  		aflag = 1;
  		break;
  	case 'h':
  		getconf_help();
  		return(EXECUTION_SUCCESS);
  	case 'v':
  		break;		/* ignored */
  	default:
  		builtin_usage();
  		return(EX_USAGE);
  	}
  }
 
  list = loptend;
  if ((aflag == 0 && list == 0) || (aflag && list) || list_length(list) > 2) {
  	builtin_usage();
  	return(EX_USAGE);
  }

  r = aflag ? getconf_all() : getconf_one(list);

  return r;
}
warning: parse error {
  int c, r, opt, aflag;
  char **v;

  aflag = 0;
  reset_internal_getopt();
  while ((opt = internal_getopt (list, "ahv:")) != -1) {
  	switch (opt) {
  	case 'a':
  		aflag = 1;
  		break;
  	case 'h':
  		getconf_help();
  		return(EXECUTION_SUCCESS);
  	case 'v':
  		break;		/* ignored */
  	default:
  		builtin_usage();
  		return(EX_USAGE);
  	}
  }
 
  list = loptend;
  if ((aflag == 0 && list == 0) || (aflag && list) || list_length(list) > 2) {
  	builtin_usage();
  	return(EX_USAGE);
  }

  r = aflag ? getconf_all() : getconf_one(list);

  return r;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\examples\loadables\getconf.c:1,135
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\examples\loadables\getconf.c:1,185
parsing error 
{
	long val;
	char *sval;
	size_t slen;

	switch (cp->type) {
	case G_UNDEF:
		printf("undefined\n");
		break;

#ifdef LLONG_MAX
	case LLCONST:
		switch (cp->value) {
			default:
			case VAL_LLONG_MIN:
				printf ("%lld\n", LLONG_MIN);
				break;
			case VAL_LLONG_MAX:
				printf ("%lld\n", LLONG_MAX);
				break;
#  if (ULLONG_MAX != LLONG_MAX)
			case VAL_ULLONG_MAX:
				printf ("%llu\n", ULLONG_MAX);
				break;
#  endif
		}
		break;
#endif
	case CONSTANT:
		switch (cp->value) {
			case UCHAR_MAX:
			case USHRT_MAX:
			case UINT_MAX:
#if (ULONG_MAX != UINT_MAX)			
			case ULONG_MAX:
#endif
#if (SIZE_MAX != UINT_MAX) && (SIZE_MAX != ULONG_MAX)
			case SIZE_MAX:
#endif

				printf("%lu\n", cp->value);
				break;
			default:
				printf("%ld\n", cp->value);
				break;
		}
		break;

	case CONFSTR:
		errno = 0;
		slen = confstr (cp->value, (char *) 0, (size_t) 0);
		if (slen == 0) {
			if (errno != 0) {
				if (all)
					printf ("getconf: %s\n", strerror(errno));
				else
					builtin_error ("%s", strerror(errno));
			} else
				printf ("undefined\n");
			return (EXECUTION_FAILURE);
		}
		sval = xmalloc(slen);

		confstr(cp->value, sval, slen);
		printf("%s\n", sval);
		free(sval);
		break;

	case SYSCONF:
		errno = 0;
		if ((val = sysconf(cp->value)) == -1) {
			if (errno != 0) {
				if (all)
					printf("getconf: %s\n", strerror (errno));
				else
					builtin_error ("%s", strerror (errno));
				return (EXECUTION_FAILURE);
			}

			printf ("undefined\n");
		} else {
			printf("%ld\n", val);
		}
		break;

	case PATHCONF:
		errno = 0;
		if ((val = pathconf(vpath, cp->value)) == -1) {
			if (errno != 0) {
				if (all)
					printf("getconf: %s: %s\n", vpath, strerror (errno));
				else
					builtin_error ("%s: %s", vpath, strerror (errno));
				return (EXECUTION_FAILURE);
			}

			printf ("undefined\n");
		} else {
			printf ("%ld\n", val);
		}
		break;
	}

	return (ferror(stdout) ? EXECUTION_FAILURE : EXECUTION_SUCCESS);
}
warning: parse error {
	long val;
	char *sval;
	size_t slen;

	switch (cp->type) {
	case G_UNDEF:
		printf("undefined\n");
		break;

#ifdef LLONG_MAX
	case LLCONST:
		switch (cp->value) {
			default:
			case VAL_LLONG_MIN:
				printf ("%lld\n", LLONG_MIN);
				break;
			case VAL_LLONG_MAX:
				printf ("%lld\n", LLONG_MAX);
				break;
#  if (ULLONG_MAX != LLONG_MAX)
			case VAL_ULLONG_MAX:
				printf ("%llu\n", ULLONG_MAX);
				break;
#  endif
		}
		break;
#endif
	case CONSTANT:
		switch (cp->value) {
			case UCHAR_MAX:
			case USHRT_MAX:
			case UINT_MAX:
#if (ULONG_MAX != UINT_MAX)			
			case ULONG_MAX:
#endif
#if (SIZE_MAX != UINT_MAX) && (SIZE_MAX != ULONG_MAX)
			case SIZE_MAX:
#endif

				printf("%lu\n", cp->value);
				break;
			default:
				printf("%ld\n", cp->value);
				break;
		}
		break;

	case CONFSTR:
		errno = 0;
		slen = confstr (cp->value, (char *) 0, (size_t) 0);
		if (slen == 0) {
			if (errno != 0) {
				if (all)
					printf ("getconf: %s\n", strerror(errno));
				else
					builtin_error ("%s", strerror(errno));
			} else
				printf ("undefined\n");
			return (EXECUTION_FAILURE);
		}
		sval = xmalloc(slen);

		confstr(cp->value, sval, slen);
		printf("%s\n", sval);
		free(sval);
		break;

	case SYSCONF:
		errno = 0;
		if ((val = sysconf(cp->value)) == -1) {
			if (errno != 0) {
				if (all)
					printf("getconf: %s\n", strerror (errno));
				else
					builtin_error ("%s", strerror (errno));
				return (EXECUTION_FAILURE);
			}

			printf ("undefined\n");
		} else {
			printf("%ld\n", val);
		}
		break;

	case PATHCONF:
		errno = 0;
		if ((val = pathconf(vpath, cp->value)) == -1) {
			if (errno != 0) {
				if (all)
					printf("getconf: %s: %s\n", vpath, strerror (errno));
				else
					builtin_error ("%s: %s", vpath, strerror (errno));
				return (EXECUTION_FAILURE);
			}

			printf ("undefined\n");
		} else {
			printf ("%ld\n", val);
		}
		break;
	}

	return (ferror(stdout) ? EXECUTION_FAILURE : EXECUTION_SUCCESS);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\examples\loadables\getconf.c:1,189
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\examples\loadables\getconf.c:1,311
parsing error 
{
	const struct conf_variable *cp;
	char *vname, *vpath;

	vname = list->word->word;
	vpath = (list->next && list->next->word) ? list->next->word->word
						 : (char *)NULL;

	for (cp = conf_table; cp->name != NULL; cp++) {
		if (strcmp(vname, cp->name) == 0)
			break;
	}
	if (cp->name == NULL) {
		builtin_error ("%s: unknown variable", vname);
		return (EXECUTION_FAILURE);
	}

	if (cp->type == PATHCONF) {
		if (list->next == 0) {
			builtin_usage();
			return(EX_USAGE);
		}
	} else {
		if (list->next) {
			builtin_usage();
			return(EX_USAGE);
		}
	}

	return (getconf_print(cp, vpath, 0));
}
warning: parse error {
	const struct conf_variable *cp;
	char *vname, *vpath;

	vname = list->word->word;
	vpath = (list->next && list->next->word) ? list->next->word->word
						 : (char *)NULL;

	for (cp = conf_table; cp->name != NULL; cp++) {
		if (strcmp(vname, cp->name) == 0)
			break;
	}
	if (cp->name == NULL) {
		builtin_error ("%s: unknown variable", vname);
		return (EXECUTION_FAILURE);
	}

	if (cp->type == PATHCONF) {
		if (list->next == 0) {
			builtin_usage();
			return(EX_USAGE);
		}
	} else {
		if (list->next) {
			builtin_usage();
			return(EX_USAGE);
		}
	}

	return (getconf_print(cp, vpath, 0));
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\examples\loadables\getconf.c:1,313
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\examples\loadables\getconf.c:1,364
parsing error 
{
  switch (name)
    {
    case _CS_PATH:
      if (len > 0 && buf)
	{
          strncpy (buf, STANDARD_UTILS_PATH, len - 1);
          buf[len - 1] = '\0';
	}
      return (sizeof (STANDARD_UTILS_PATH) + 1);
    default:
      errno = EINVAL;
      return 0;
    }
}
warning: parse error {
  switch (name)
    {
    case _CS_PATH:
      if (len > 0 && buf)
	{
          strncpy (buf, STANDARD_UTILS_PATH, len - 1);
          buf[len - 1] = '\0';
	}
      return (sizeof (STANDARD_UTILS_PATH) + 1);
    default:
      errno = EINVAL;
      return 0;
    }
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\examples\loadables\getconf.c:1,368
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\examples\loadables\getconf.c:1,389
parsing error 
{
#  if defined (_POSIX_VERSION)
  switch (name)
    {
    case _SC_ARG_MAX:
      return _POSIX_ARG_MAX;
    case _SC_CHILD_MAX:
      return _POSIX_CHILD_MAX;
    case _SC_CLK_TCK:
      return get_clk_tck();
    case _SC_NGROUPS_MAX:
      return _POSIX_NGROUPS_MAX;
    case _SC_OPEN_MAX:
      return _POSIX_OPEN_MAX;
    case _SC_JOB_CONTROL:
      return _POSIX_JOB_CONTROL;
    case _SC_SAVED_IDS:
      return _POSIX_SAVED_IDS;
    case _SC_VERSION:
      return _POSIX_VERSION;
    case _SC_BC_BASE_MAX:
      return _POSIX2_BC_BASE_MAX;
    case _SC_BC_DIM_MAX:
      return _POSIX2_BC_DIM_MAX;
    case _SC_BC_SCALE_MAX:
      return  _POSIX2_BC_SCALE_MAX;
    case _SC_BC_STRING_MAX:
      return _POSIX2_BC_STRING_MAX;
    case _SC_COLL_WEIGHTS_MAX:
      return  -1;
    case _SC_EXPR_NEST_MAX:
      return _POSIX2_EXPR_NEST_MAX;
    case _SC_LINE_MAX:
      return _POSIX2_LINE_MAX;
    case _SC_RE_DUP_MAX:
      return _POSIX2_RE_DUP_MAX;
    case _SC_STREAM_MAX:
      return _POSIX_STREAM_MAX;
    case _SC_TZNAME_MAX:
      return _POSIX_TZNAME_MAX;
    default:
      errno = EINVAL;
      return -1;
    }
#else
  errno = EINVAL;
  return -1;
#endif
}
warning: parse error {
#  if defined (_POSIX_VERSION)
  switch (name)
    {
    case _SC_ARG_MAX:
      return _POSIX_ARG_MAX;
    case _SC_CHILD_MAX:
      return _POSIX_CHILD_MAX;
    case _SC_CLK_TCK:
      return get_clk_tck();
    case _SC_NGROUPS_MAX:
      return _POSIX_NGROUPS_MAX;
    case _SC_OPEN_MAX:
      return _POSIX_OPEN_MAX;
    case _SC_JOB_CONTROL:
      return _POSIX_JOB_CONTROL;
    case _SC_SAVED_IDS:
      return _POSIX_SAVED_IDS;
    case _SC_VERSION:
      return _POSIX_VERSION;
    case _SC_BC_BASE_MAX:
      return _POSIX2_BC_BASE_MAX;
    case _SC_BC_DIM_MAX:
      return _POSIX2_BC_DIM_MAX;
    case _SC_BC_SCALE_MAX:
      return  _POSIX2_BC_SCALE_MAX;
    case _SC_BC_STRING_MAX:
      return _POSIX2_BC_STRING_MAX;
    case _SC_COLL_WEIGHTS_MAX:
      return  -1;
    case _SC_EXPR_NEST_MAX:
      return _POSIX2_EXPR_NEST_MAX;
    case _SC_LINE_MAX:
      return _POSIX2_LINE_MAX;
    case _SC_RE_DUP_MAX:
      return _POSIX2_RE_DUP_MAX;
    case _SC_STREAM_MAX:
      return _POSIX_STREAM_MAX;
    case _SC_TZNAME_MAX:
      return _POSIX_TZNAME_MAX;
    default:
      errno = EINVAL;
      return -1;
    }
#else
  errno = EINVAL;
  return -1;
#endif
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\examples\loadables\getconf.c:1,391
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\examples\loadables\getconf.c:1,445
parsing error 
{
#if defined (_POSIX_VERSION)
  switch (name)
    {
    case _PC_LINK_MAX:
      return _POSIX_LINK_MAX;
    case _PC_MAX_CANON:
      return _POSIX_MAX_CANON;
    case _PC_MAX_INPUT:
      return _POSIX_MAX_INPUT;
    case _PC_NAME_MAX:
      return _POSIX_NAME_MAX;
    case _PC_PATH_MAX:
      return _POSIX_PATH_MAX;
    case _PC_PIPE_BUF:
      return _POSIX_PIPE_BUF;
    case _PC_CHOWN_RESTRICTED:
#ifdef _POSIX_CHOWN_RESTRICTED
      return _POSIX_CHOWN_RESTRICTED;
#else
      return -1;
#endif
    case _PC_NO_TRUNC:
#ifdef _POSIX_NO_TRUNC
      return _POSIX_NO_TRUNC;
#else
      return -1;
#endif
    case _PC_VDISABLE:
#ifdef _POSIX_VDISABLE
      return _POSIX_VDISABLE;
#else
      return -1;
#endif
    default:
      errno = EINVAL;
      return -1;
    }
#else
  errno = EINVAL;
  return -1;
#endif
}
warning: parse error {
#if defined (_POSIX_VERSION)
  switch (name)
    {
    case _PC_LINK_MAX:
      return _POSIX_LINK_MAX;
    case _PC_MAX_CANON:
      return _POSIX_MAX_CANON;
    case _PC_MAX_INPUT:
      return _POSIX_MAX_INPUT;
    case _PC_NAME_MAX:
      return _POSIX_NAME_MAX;
    case _PC_PATH_MAX:
      return _POSIX_PATH_MAX;
    case _PC_PIPE_BUF:
      return _POSIX_PIPE_BUF;
    case _PC_CHOWN_RESTRICTED:
#ifdef _POSIX_CHOWN_RESTRICTED
      return _POSIX_CHOWN_RESTRICTED;
#else
      return -1;
#endif
    case _PC_NO_TRUNC:
#ifdef _POSIX_NO_TRUNC
      return _POSIX_NO_TRUNC;
#else
      return -1;
#endif
    case _PC_VDISABLE:
#ifdef _POSIX_VDISABLE
      return _POSIX_VDISABLE;
#else
      return -1;
#endif
    default:
      errno = EINVAL;
      return -1;
    }
#else
  errno = EINVAL;
  return -1;
#endif
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\examples\loadables\getconf.c:1,447
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\examples\loadables\head.c...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\bashtypes.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\posixstat.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\filecntl.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\bashansi.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\chartypes.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\shell.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\bashgetopt.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\common.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\examples\loadables\head.c:49
parsing error 
{
  WORD_LIST *l, *nl;
  WORD_DESC *wd;
  char *arg;

  for (l = list; l; l = l->next)
    {
      arg = l->word->word;
      if (arg[0] != '-' || arg[1] == '-' || (DIGIT(arg[1]) == 0))
        return;
      /* We have -[0-9]* */
      wd = make_bare_word (arg+1);
      nl = make_word_list (wd, l->next);
      l->word->word[1] = 'n';
      l->word->word[2] = '\0';
      l->next = nl;
      l = nl;	/* skip over new argument */
    }
}
warning: parse error {
  WORD_LIST *l, *nl;
  WORD_DESC *wd;
  char *arg;

  for (l = list; l; l = l->next)
    {
      arg = l->word->word;
      if (arg[0] != '-' || arg[1] == '-' || (DIGIT(arg[1]) == 0))
        return;
      /* We have -[0-9]* */
      wd = make_bare_word (arg+1);
      nl = make_word_list (wd, l->next);
      l->word->word[1] = 'n';
      l->word->word[2] = '\0';
      l->next = nl;
      l = nl;	/* skip over new argument */
    }
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\examples\loadables\head.c:51
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\examples\loadables\head.c:72
parsing error 
{
  int ch;

  while (cnt--)
    {
      while ((ch = getc (fp)) != EOF)
	{
	  if (putchar (ch) == EOF)
	    {
	      builtin_error ("write error: %s", strerror (errno));
	      return EXECUTION_FAILURE;
	    }
	  if (ch == '\n')
	    break;
	}
    }
}
warning: parse error {
  int ch;

  while (cnt--)
    {
      while ((ch = getc (fp)) != EOF)
	{
	  if (putchar (ch) == EOF)
	    {
	      builtin_error ("write error: %s", strerror (errno));
	      return EXECUTION_FAILURE;
	    }
	  if (ch == '\n')
	    break;
	}
    }
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\examples\loadables\head.c:75
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\examples\loadables\head.c:93
parsing error 
{
  int nline, opt, rval;
  WORD_LIST *l;
  FILE *fp;

  char *t;

  munge_list (list);	/* change -num into -n num */

  reset_internal_getopt ();
  nline = 10;
  while ((opt = internal_getopt (list, "n:")) != -1)
    {
      switch (opt)
	{
	case 'n':
	  nline = atoi (list_optarg);
	  if (nline <= 0)
	    {
	      builtin_error ("bad line count: %s", list_optarg);
	      return (EX_USAGE);
	    }
	  break;
	default:
	  builtin_usage ();
	  return (EX_USAGE);
	}
    }
  list = loptend;

  if (list == 0)
    return (file_head (stdin, nline));

  for (rval = EXECUTION_SUCCESS, opt = 1, l = list; l; l = l->next)
    {
      fp = fopen (l->word->word, "r");
      if (fp == NULL)
	{
	  builtin_error ("%s: %s", l->word->word, strerror (errno));
	  continue;
	}
      if (list->next)	/* more than one file */
	{
	  printf ("%s==> %s <==\n", opt ? "" : "\n", l->word->word);
	  opt = 0;
	}
      rval = file_head (fp, nline);
      fclose (fp);
    }
   
  return (rval);
}
warning: parse error {
  int nline, opt, rval;
  WORD_LIST *l;
  FILE *fp;

  char *t;

  munge_list (list);	/* change -num into -n num */

  reset_internal_getopt ();
  nline = 10;
  while ((opt = internal_getopt (list, "n:")) != -1)
    {
      switch (opt)
	{
	case 'n':
	  nline = atoi (list_optarg);
	  if (nline <= 0)
	    {
	      builtin_error ("bad line count: %s", list_optarg);
	      return (EX_USAGE);
	    }
	  break;
	default:
	  builtin_usage ();
	  return (EX_USAGE);
	}
    }
  list = loptend;

  if (list == 0)
    return (file_head (stdin, nline));

  for (rval = EXECUTION_SUCCESS, opt = 1, l = list; l; l = l->next)
    {
      fp = fopen (l->word->word, "r");
      if (fp == NULL)
	{
	  builtin_error ("%s: %s", l->word->word, strerror (errno));
	  continue;
	}
      if (list->next)	/* more than one file */
	{
	  printf ("%s==> %s <==\n", opt ? "" : "\n", l->word->word);
	  opt = 0;
	}
      rval = file_head (fp, nline);
      fclose (fp);
    }
   
  return (rval);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\examples\loadables\head.c:95
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\examples\loadables\hello.c...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\shell.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\bashgetopt.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\examples\loadables\hello.c:35
parsing error 
{
  printf("hello world\n");
  fflush (stdout);
  return (EXECUTION_SUCCESS);
}
warning: parse error {
  printf("hello world\n");
  fflush (stdout);
  return (EXECUTION_SUCCESS);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\examples\loadables\hello.c:37
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\examples\loadables\id.c...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\bashtypes.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\bashansi.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\shell.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\stdc.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\common.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\bashgetopt.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\examples\loadables\id.c:77
parsing error 
{
  int opt;
  char *user;

  id_flags = 0;
  reset_internal_getopt ();
  while ((opt = internal_getopt (list, "Ggnru")) != -1)
    {
      switch (opt)
	{
	case 'G': id_flags |= ID_ALLGROUPS; break;
	case 'g': id_flags |= ID_GIDONLY; break;
	case 'n': id_flags |= ID_USENAME; break;
	case 'r': id_flags |= ID_USEREAL; break;
	case 'u': id_flags |= ID_USERONLY; break;
	default:
	  builtin_usage ();
	  return (EX_USAGE);
	}
    }
  list = loptend;

  user = list ? list->word->word : (char *)NULL;

  /* Check for some invalid option combinations */
  opt = ID_FLAGSET (ID_ALLGROUPS) + ID_FLAGSET (ID_GIDONLY) + ID_FLAGSET (ID_USERONLY);
  if (opt > 1 || (opt == 0 && ((id_flags & (ID_USEREAL|ID_USENAME)) != 0)))
    {
      builtin_usage ();
      return (EX_USAGE);
    }

  if (list && list->next)
    {
      builtin_usage ();
      return (EX_USAGE);
    }

  if (inituser (user) < 0)
    return (EXECUTION_FAILURE);

  opt = 0;
  if (id_flags & ID_USERONLY)
    opt += id_pruser ((id_flags & ID_USEREAL) ? ruid : euid);
  else if (id_flags & ID_GIDONLY)
    opt += id_prgrp ((id_flags & ID_USEREAL) ? rgid : egid);
  else if (id_flags & ID_ALLGROUPS)
    opt += id_prgroups (user);
  else
    opt += id_prall (user);
  putchar ('\n');
  fflush (stdout);

  return (opt == 0 ? EXECUTION_SUCCESS : EXECUTION_FAILURE);
}
warning: parse error {
  int opt;
  char *user;

  id_flags = 0;
  reset_internal_getopt ();
  while ((opt = internal_getopt (list, "Ggnru")) != -1)
    {
      switch (opt)
	{
	case 'G': id_flags |= ID_ALLGROUPS; break;
	case 'g': id_flags |= ID_GIDONLY; break;
	case 'n': id_flags |= ID_USENAME; break;
	case 'r': id_flags |= ID_USEREAL; break;
	case 'u': id_flags |= ID_USERONLY; break;
	default:
	  builtin_usage ();
	  return (EX_USAGE);
	}
    }
  list = loptend;

  user = list ? list->word->word : (char *)NULL;

  /* Check for some invalid option combinations */
  opt = ID_FLAGSET (ID_ALLGROUPS) + ID_FLAGSET (ID_GIDONLY) + ID_FLAGSET (ID_USERONLY);
  if (opt > 1 || (opt == 0 && ((id_flags & (ID_USEREAL|ID_USENAME)) != 0)))
    {
      builtin_usage ();
      return (EX_USAGE);
    }

  if (list && list->next)
    {
      builtin_usage ();
      return (EX_USAGE);
    }

  if (inituser (user) < 0)
    return (EXECUTION_FAILURE);

  opt = 0;
  if (id_flags & ID_USERONLY)
    opt += id_pruser ((id_flags & ID_USEREAL) ? ruid : euid);
  else if (id_flags & ID_GIDONLY)
    opt += id_prgrp ((id_flags & ID_USEREAL) ? rgid : egid);
  else if (id_flags & ID_ALLGROUPS)
    opt += id_prgroups (user);
  else
    opt += id_prall (user);
  putchar ('\n');
  fflush (stdout);

  return (opt == 0 ? EXECUTION_SUCCESS : EXECUTION_FAILURE);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\examples\loadables\id.c:79
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\examples\loadables\id.c:136
parsing error 
{
  struct passwd *pwd;

  if (uname)
    {
      pwd = getpwnam (uname);
      if (pwd == 0)
	{
	  builtin_error ("%s: no such user", uname);
	  return -1;
	}
      ruid = euid = pwd->pw_uid;
      rgid = egid = pwd->pw_gid;
    }
  else
    {
      ruid = current_user.uid;
      euid = current_user.euid;
      rgid = current_user.gid;
      egid = current_user.egid;
    }
  return 0;
}
warning: parse error {
  struct passwd *pwd;

  if (uname)
    {
      pwd = getpwnam (uname);
      if (pwd == 0)
	{
	  builtin_error ("%s: no such user", uname);
	  return -1;
	}
      ruid = euid = pwd->pw_uid;
      rgid = egid = pwd->pw_gid;
    }
  else
    {
      ruid = current_user.uid;
      euid = current_user.euid;
      rgid = current_user.gid;
      egid = current_user.egid;
    }
  return 0;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\examples\loadables\id.c:138
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\examples\loadables\id.c:164
parsing error 
{
  struct passwd *pwd = NULL;
  int r;

  r = 0;
  if (id_flags & ID_USENAME)
    {
      pwd = getpwuid (uid);
      if (pwd == NULL)
        r = 1;
    }
  if (pwd)
    printf ("%s", pwd->pw_name);
  else
    printf ("%u", (unsigned) uid);
      
  return r;
}
warning: parse error {
  struct passwd *pwd = NULL;
  int r;

  r = 0;
  if (id_flags & ID_USENAME)
    {
      pwd = getpwuid (uid);
      if (pwd == NULL)
        r = 1;
    }
  if (pwd)
    printf ("%s", pwd->pw_name);
  else
    printf ("%u", (unsigned) uid);
      
  return r;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\examples\loadables\id.c:166
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\examples\loadables\id.c:188
parsing error 
{
  struct group *grp = NULL;
  int r;

  r = 0;
  if (id_flags & ID_USENAME)
    {
      grp = getgrgid (gid);
      if (grp == NULL)
	r = 1;
    }

  if (grp)
    printf ("%s", grp->gr_name);
  else
    printf ("%u", (unsigned) gid);

  return r;
}
warning: parse error {
  struct group *grp = NULL;
  int r;

  r = 0;
  if (id_flags & ID_USENAME)
    {
      grp = getgrgid (gid);
      if (grp == NULL)
	r = 1;
    }

  if (grp)
    printf ("%s", grp->gr_name);
  else
    printf ("%u", (unsigned) gid);

  return r;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\examples\loadables\id.c:190
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\examples\loadables\id.c:211
parsing error 
{
  int *glist, ng, i, r;

  r = 0;
  id_prgrp (rgid);
  if (egid != rgid)
    {
      putchar (' ');
      id_prgrp (egid);
    }

  if (uname)
    {
      builtin_error ("supplementary groups for other users not yet implemented");
      glist = (int *)NULL;
      ng = 0;
      r = 1;
    }
  else
    glist = get_group_array (&ng);

  for (i = 0; i < ng; i++)
    if (glist[i] != rgid && glist[i] != egid)
      {
	putchar (' ');
	id_prgrp (glist[i]);
      }
  
  return r;
}
warning: parse error {
  int *glist, ng, i, r;

  r = 0;
  id_prgrp (rgid);
  if (egid != rgid)
    {
      putchar (' ');
      id_prgrp (egid);
    }

  if (uname)
    {
      builtin_error ("supplementary groups for other users not yet implemented");
      glist = (int *)NULL;
      ng = 0;
      r = 1;
    }
  else
    glist = get_group_array (&ng);

  for (i = 0; i < ng; i++)
    if (glist[i] != rgid && glist[i] != egid)
      {
	putchar (' ');
	id_prgrp (glist[i]);
      }
  
  return r;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\examples\loadables\id.c:213
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\examples\loadables\id.c:245
parsing error 
{
  int r, i, ng, *glist;
  struct passwd *pwd;
  struct group *grp;

  r = 0;
  printf ("uid=%u", (unsigned) ruid);
  pwd = getpwuid (ruid);
  if (pwd == NULL)
    r = 1;
  else
    printf ("(%s)", pwd->pw_name);

  printf (" gid=%u", (unsigned) rgid);
  grp = getgrgid (rgid);
  if (grp == NULL)
    r = 1;
  else
    printf ("(%s)", grp->gr_name);

  if (euid != ruid)
    { 
      printf (" euid=%u", (unsigned) euid);
      pwd = getpwuid (euid);
      if (pwd == NULL)
	r = 1;
      else 
	printf ("(%s)", pwd->pw_name);
    }

  if (egid != rgid) 
    {
      printf (" egid=%u", (unsigned) egid);
      grp = getgrgid (egid);
      if (grp == NULL)
	r = 1;
      else
	printf ("(%s)", grp->gr_name);
    }

  if (uname)
    {
      builtin_error ("supplementary groups for other users not yet implemented");
      glist = (int *)NULL;
      ng = 0;
      r = 1;
    }
  else
    glist = get_group_array (&ng);

  if (ng > 0)
    printf (" groups=");
  for (i = 0; i < ng; i++)
    {
      if (i > 0)
	printf (", ");
      printf ("%u", (unsigned) glist[i]);
      grp = getgrgid (glist[i]);
      if (grp == NULL)
	r = 1;
      else
	printf ("(%s)", grp->gr_name);
    }

  return r;
}
warning: parse error {
  int r, i, ng, *glist;
  struct passwd *pwd;
  struct group *grp;

  r = 0;
  printf ("uid=%u", (unsigned) ruid);
  pwd = getpwuid (ruid);
  if (pwd == NULL)
    r = 1;
  else
    printf ("(%s)", pwd->pw_name);

  printf (" gid=%u", (unsigned) rgid);
  grp = getgrgid (rgid);
  if (grp == NULL)
    r = 1;
  else
    printf ("(%s)", grp->gr_name);

  if (euid != ruid)
    { 
      printf (" euid=%u", (unsigned) euid);
      pwd = getpwuid (euid);
      if (pwd == NULL)
	r = 1;
      else 
	printf ("(%s)", pwd->pw_name);
    }

  if (egid != rgid) 
    {
      printf (" egid=%u", (unsigned) egid);
      grp = getgrgid (egid);
      if (grp == NULL)
	r = 1;
      else
	printf ("(%s)", grp->gr_name);
    }

  if (uname)
    {
      builtin_error ("supplementary groups for other users not yet implemented");
      glist = (int *)NULL;
      ng = 0;
      r = 1;
    }
  else
    glist = get_group_array (&ng);

  if (ng > 0)
    printf (" groups=");
  for (i = 0; i < ng; i++)
    {
      if (i > 0)
	printf (", ");
      printf ("%u", (unsigned) glist[i]);
      grp = getgrgid (glist[i]);
      if (grp == NULL)
	r = 1;
      else
	printf ("(%s)", grp->gr_name);
    }

  return r;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\examples\loadables\id.c:247
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\examples\loadables\ln.c...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\bashtypes.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\posixstat.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\shell.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\bashgetopt.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\common.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\examples\loadables\ln.c:53
parsing error 
{
  int rval, opt, flags;
  WORD_LIST *l;
  char *sdir;
  struct stat sb;

  flags = 0;
  reset_internal_getopt ();
  while ((opt = internal_getopt (list, "fs")) != -1)
    {
      switch (opt)
	{
	case 'f':
	  flags |= LN_UNLINK;
	  break;
	case 's':
	  flags |= LN_SYMLINK;
	  break;
	default:
	  builtin_usage ();
	  return (EX_USAGE);
	}
    }
  list = loptend;

  if (list == 0)
    {
      builtin_usage ();
      return (EX_USAGE);
    }
    
  linkfn = (flags & LN_SYMLINK) ? symlink : link;  

  if (list->next == 0)			/* ln target, equivalent to ln target . */
    return (dolink (list->word->word, ".", flags));

  if (list->next->next == 0)		/* ln target source */
    return (dolink (list->word->word, list->next->word->word, flags));

  /* ln target1 target2 ... directory */

  /* find last argument: target directory, and make sure it's an existing
     directory. */
  for (l = list; l->next; l = l->next)  
    ;
  sdir = l->word->word;

  if (stat(sdir, &sb) < 0)
    {
      builtin_error ("%s", sdir);
      return (EXECUTION_FAILURE);
    }

  if (S_ISDIR (sb.st_mode) == 0)
    {
      builtin_usage ();
      return (EX_USAGE);
    }

  for (rval = EXECUTION_SUCCESS; list != l; list = list->next)
    rval += dolink (list->word->word, sdir, flags);
  
  return rval;
}
warning: parse error {
  int rval, opt, flags;
  WORD_LIST *l;
  char *sdir;
  struct stat sb;

  flags = 0;
  reset_internal_getopt ();
  while ((opt = internal_getopt (list, "fs")) != -1)
    {
      switch (opt)
	{
	case 'f':
	  flags |= LN_UNLINK;
	  break;
	case 's':
	  flags |= LN_SYMLINK;
	  break;
	default:
	  builtin_usage ();
	  return (EX_USAGE);
	}
    }
  list = loptend;

  if (list == 0)
    {
      builtin_usage ();
      return (EX_USAGE);
    }
    
  linkfn = (flags & LN_SYMLINK) ? symlink : link;  

  if (list->next == 0)			/* ln target, equivalent to ln target . */
    return (dolink (list->word->word, ".", flags));

  if (list->next->next == 0)		/* ln target source */
    return (dolink (list->word->word, list->next->word->word, flags));

  /* ln target1 target2 ... directory */

  /* find last argument: target directory, and make sure it's an existing
     directory. */
  for (l = list; l->next; l = l->next)  
    ;
  sdir = l->word->word;

  if (stat(sdir, &sb) < 0)
    {
      builtin_error ("%s", sdir);
      return (EXECUTION_FAILURE);
    }

  if (S_ISDIR (sb.st_mode) == 0)
    {
      builtin_usage ();
      return (EX_USAGE);
    }

  for (rval = EXECUTION_SUCCESS; list != l; list = list->next)
    rval += dolink (list->word->word, sdir, flags);
  
  return rval;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\examples\loadables\ln.c:55
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\examples\loadables\ln.c:121
parsing error 
{
  int dlen, flen;
  char *ret;

  dlen = strlen (dir);
  flen = strlen (file);

  ret = xmalloc (2 + dlen + flen);

  strcpy (ret, dir);
  if (ret[dlen - 1] != '/')
    ret[dlen++] = '/';
  strcpy (ret + dlen, file);
  return ret;
}
warning: parse error {
  int dlen, flen;
  char *ret;

  dlen = strlen (dir);
  flen = strlen (file);

  ret = xmalloc (2 + dlen + flen);

  strcpy (ret, dir);
  if (ret[dlen - 1] != '/')
    ret[dlen++] = '/';
  strcpy (ret + dlen, file);
  return ret;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\examples\loadables\ln.c:123
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\examples\loadables\ln.c:146
parsing error 
{
  struct stat ssb, dsb;
  int exists;
  char *dst_path, *p;

  /* If we're not doing symlinks, the source must exist and not be a 
     directory. */
  if ((flags & LN_SYMLINK) == 0)
    {
      if (stat (src, &ssb) != 0)
	{
	  builtin_error ("%s: %s", src, strerror (errno));
	  return (EXECUTION_FAILURE);
	}
      if (S_ISDIR (ssb.st_mode))
	{
	  errno = EISDIR;
	  builtin_error ("%s: %s", src, strerror (errno));
	  return (EXECUTION_FAILURE);
	}
    }

  /* If the destination is a directory, create the final filename by appending
     the basename of the source to the destination. */
  dst_path = 0;
  if ((stat (dst, &dsb) == 0) && S_ISDIR (dsb.st_mode))
    {
      if ((p = strrchr (src, '/')) == 0)
	p = src;
      else
	p++;

      dst_path = mkdirpath (dst, p);
      dst = dst_path;
    }

  exists = LSTAT (dst, &dsb) == 0;

  /* If -f was specified, and the destination exists, unlink it. */
  if ((flags & LN_UNLINK) && exists && unlink (dst) != 0)
    {
      builtin_error ("%s: cannot unlink: %s", dst, strerror (errno));
      FREE (dst_path);
      return (EXECUTION_FAILURE);
    }

  /* Perform the link. */
  if ((*linkfn) (src, dst) != 0)
    {
      builtin_error ("cannot link %s to %s: %s", dst, src, strerror (errno));
      FREE (dst_path);
      return (EXECUTION_FAILURE);
    }

  FREE (dst_path);
  return (EXECUTION_SUCCESS);
}
warning: parse error {
  struct stat ssb, dsb;
  int exists;
  char *dst_path, *p;

  /* If we're not doing symlinks, the source must exist and not be a 
     directory. */
  if ((flags & LN_SYMLINK) == 0)
    {
      if (stat (src, &ssb) != 0)
	{
	  builtin_error ("%s: %s", src, strerror (errno));
	  return (EXECUTION_FAILURE);
	}
      if (S_ISDIR (ssb.st_mode))
	{
	  errno = EISDIR;
	  builtin_error ("%s: %s", src, strerror (errno));
	  return (EXECUTION_FAILURE);
	}
    }

  /* If the destination is a directory, create the final filename by appending
     the basename of the source to the destination. */
  dst_path = 0;
  if ((stat (dst, &dsb) == 0) && S_ISDIR (dsb.st_mode))
    {
      if ((p = strrchr (src, '/')) == 0)
	p = src;
      else
	p++;

      dst_path = mkdirpath (dst, p);
      dst = dst_path;
    }

  exists = LSTAT (dst, &dsb) == 0;

  /* If -f was specified, and the destination exists, unlink it. */
  if ((flags & LN_UNLINK) && exists && unlink (dst) != 0)
    {
      builtin_error ("%s: cannot unlink: %s", dst, strerror (errno));
      FREE (dst_path);
      return (EXECUTION_FAILURE);
    }

  /* Perform the link. */
  if ((*linkfn) (src, dst) != 0)
    {
      builtin_error ("cannot link %s to %s: %s", dst, src, strerror (errno));
      FREE (dst_path);
      return (EXECUTION_FAILURE);
    }

  FREE (dst_path);
  return (EXECUTION_SUCCESS);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\examples\loadables\ln.c:149
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\examples\loadables\logname.c...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\shell.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\common.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\examples\loadables\logname.c:38
parsing error 
{
  char *np;

  if (no_options (list))
    return (EX_USAGE);

  np = getlogin ();
  if (np == 0)
    {
      builtin_error ("cannot find username: %s", strerror (errno));
      return (EXECUTION_FAILURE);
    }
  printf ("%s\n", np);
  return (EXECUTION_SUCCESS);
}
warning: parse error {
  char *np;

  if (no_options (list))
    return (EX_USAGE);

  np = getlogin ();
  if (np == 0)
    {
      builtin_error ("cannot find username: %s", strerror (errno));
      return (EXECUTION_FAILURE);
    }
  printf ("%s\n", np);
  return (EXECUTION_SUCCESS);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\examples\loadables\logname.c:40
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\examples\loadables\mkdir.c...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\bashtypes.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\posixstat.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\bashansi.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\shell.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\bashgetopt.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\common.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\examples\loadables\mkdir.c:52
parsing error 
{
  int opt, pflag, omode, rval, octal, nmode, parent_mode, um;
  char *mode;
  WORD_LIST *l;

  reset_internal_getopt ();
  pflag = 0;
  mode = (char *)NULL;
  while ((opt = internal_getopt(list, "m:p")) != -1)
    switch (opt)
      {
	case 'p':
	  pflag = 1;
	  break;
	case 'm':
	  mode = list_optarg;
	  break;
	default:
	  builtin_usage();
	  return (EX_USAGE);
      }
  list = loptend;

  if (list == 0)
    {
      builtin_usage ();
      return (EX_USAGE);
    }

  if (mode == NULL)
    omode = S_IRWXU | S_IRWXG | S_IRWXO;	/* a=rwx */
  else if (ISOCTAL (*mode))	/* octal number */
    {
      omode = read_octal (mode);
      if (omode < 0)
	{
	  builtin_error ("invalid file mode: %s", mode);
	  return (EXECUTION_FAILURE);
	}
      octal = 1;
    }
  else if (mode)
    {
      /* initial bits are a=rwx; the mode argument modifies them */
      omode = parse_symbolic_mode (mode, S_IRWXU | S_IRWXG | S_IRWXO);
      if (omode < 0)
	{
	  builtin_error ("invalid file mode: %s", mode);
	  return (EXECUTION_FAILURE);
	}
      octal = 0;
    }

  /* Make the new mode */
  original_umask = umask (0);
  umask (original_umask);

  nmode = (S_IRWXU | S_IRWXG | S_IRWXO) & ~original_umask;
  parent_mode = nmode | (S_IWRITE|S_IEXEC);	/* u+wx */

  /* Adjust new mode based on mode argument */
  nmode &= omode;

  for (rval = EXECUTION_SUCCESS, l = list; l; l = l->next)
    {
      if (pflag && make_path (l->word->word, nmode, parent_mode))
	{
	  rval = EXECUTION_FAILURE;
	  continue;
	}
      else if (pflag == 0 && mkdir (l->word->word, nmode) < 0)
        {
          builtin_error ("cannot create directory `%s': %s", l->word->word, strerror (errno));
          rval = EXECUTION_FAILURE;
        }
    }
  return rval;
}
warning: parse error {
  int opt, pflag, omode, rval, octal, nmode, parent_mode, um;
  char *mode;
  WORD_LIST *l;

  reset_internal_getopt ();
  pflag = 0;
  mode = (char *)NULL;
  while ((opt = internal_getopt(list, "m:p")) != -1)
    switch (opt)
      {
	case 'p':
	  pflag = 1;
	  break;
	case 'm':
	  mode = list_optarg;
	  break;
	default:
	  builtin_usage();
	  return (EX_USAGE);
      }
  list = loptend;

  if (list == 0)
    {
      builtin_usage ();
      return (EX_USAGE);
    }

  if (mode == NULL)
    omode = S_IRWXU | S_IRWXG | S_IRWXO;	/* a=rwx */
  else if (ISOCTAL (*mode))	/* octal number */
    {
      omode = read_octal (mode);
      if (omode < 0)
	{
	  builtin_error ("invalid file mode: %s", mode);
	  return (EXECUTION_FAILURE);
	}
      octal = 1;
    }
  else if (mode)
    {
      /* initial bits are a=rwx; the mode argument modifies them */
      omode = parse_symbolic_mode (mode, S_IRWXU | S_IRWXG | S_IRWXO);
      if (omode < 0)
	{
	  builtin_error ("invalid file mode: %s", mode);
	  return (EXECUTION_FAILURE);
	}
      octal = 0;
    }

  /* Make the new mode */
  original_umask = umask (0);
  umask (original_umask);

  nmode = (S_IRWXU | S_IRWXG | S_IRWXO) & ~original_umask;
  parent_mode = nmode | (S_IWRITE|S_IEXEC);	/* u+wx */

  /* Adjust new mode based on mode argument */
  nmode &= omode;

  for (rval = EXECUTION_SUCCESS, l = list; l; l = l->next)
    {
      if (pflag && make_path (l->word->word, nmode, parent_mode))
	{
	  rval = EXECUTION_FAILURE;
	  continue;
	}
      else if (pflag == 0 && mkdir (l->word->word, nmode) < 0)
        {
          builtin_error ("cannot create directory `%s': %s", l->word->word, strerror (errno));
          rval = EXECUTION_FAILURE;
        }
    }
  return rval;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\examples\loadables\mkdir.c:54
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\examples\loadables\mkdir.c:137
parsing error 
{
  int oumask;
  struct stat sb;
  char *p, *npath;

  if (stat (path, &sb) == 0)
    {
      if (S_ISDIR (sb.st_mode) == 0)
	{
	  builtin_error ("`%s': file exists but is not a directory", path);
	  return 1;
	}
	
      if (chmod (path, nmode))
        {
          builtin_error ("%s: %s", path, strerror (errno));
          return 1;
        }

      return 0;
    }

  oumask = umask (0);
  npath = savestring (path);	/* So we can write to it. */
    
  /* Check whether or not we need to do anything with intermediate dirs. */

  /* Skip leading slashes. */
  p = npath;
  while (*p == '/')
    p++;

  while (p = strchr (p, '/'))
    {
      *p = '\0';
      if (stat (npath, &sb) != 0)
	{
	  if (mkdir (npath, parent_mode))
	    {
	      builtin_error ("cannot create directory `%s': %s", npath, strerror (errno));
	      umask (original_umask);
	      free (npath);
	      return 1;
	    }
	}
      else if (S_ISDIR (sb.st_mode) == 0)
        {
          builtin_error ("`%s': file exists but is not a directory", npath);
          umask (original_umask);
          free (npath);
          return 1;
        }

      *p++ = '/';	/* restore slash */
      while (*p == '/')
	p++;
    }

  /* Create the final directory component. */
  if (stat (npath, &sb) && mkdir (npath, nmode))
    {
      builtin_error ("cannot create directory `%s': %s", npath, strerror (errno));
      umask (original_umask);
      free (npath);
      return 1;
    }

  umask (original_umask);
  free (npath);
  return 0;
}
warning: parse error {
  int oumask;
  struct stat sb;
  char *p, *npath;

  if (stat (path, &sb) == 0)
    {
      if (S_ISDIR (sb.st_mode) == 0)
	{
	  builtin_error ("`%s': file exists but is not a directory", path);
	  return 1;
	}
	
      if (chmod (path, nmode))
        {
          builtin_error ("%s: %s", path, strerror (errno));
          return 1;
        }

      return 0;
    }

  oumask = umask (0);
  npath = savestring (path);	/* So we can write to it. */
    
  /* Check whether or not we need to do anything with intermediate dirs. */

  /* Skip leading slashes. */
  p = npath;
  while (*p == '/')
    p++;

  while (p = strchr (p, '/'))
    {
      *p = '\0';
      if (stat (npath, &sb) != 0)
	{
	  if (mkdir (npath, parent_mode))
	    {
	      builtin_error ("cannot create directory `%s': %s", npath, strerror (errno));
	      umask (original_umask);
	      free (npath);
	      return 1;
	    }
	}
      else if (S_ISDIR (sb.st_mode) == 0)
        {
          builtin_error ("`%s': file exists but is not a directory", npath);
          umask (original_umask);
          free (npath);
          return 1;
        }

      *p++ = '/';	/* restore slash */
      while (*p == '/')
	p++;
    }

  /* Create the final directory component. */
  if (stat (npath, &sb) && mkdir (npath, nmode))
    {
      builtin_error ("cannot create directory `%s': %s", npath, strerror (errno));
      umask (original_umask);
      free (npath);
      return 1;
    }

  umask (original_umask);
  free (npath);
  return 0;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\examples\loadables\mkdir.c:140
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\examples\loadables\mypid.c...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\shell.h...skip
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\examples\loadables\necho.c...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\shell.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\examples\loadables\necho.c:28
parsing error 
{
	print_word_list (list, " ");
	printf("\n");
	fflush (stdout);
	return (EXECUTION_SUCCESS);
}
warning: parse error {
	print_word_list (list, " ");
	printf("\n");
	fflush (stdout);
	return (EXECUTION_SUCCESS);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\examples\loadables\necho.c:30
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\examples\loadables\pathchk.c...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\posixstat.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\bashansi.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\shell.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\stdc.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\bashgetopt.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\maxpath.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\common.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\examples\loadables\pathchk.c:101
parsing error 
{
  int retval, pflag, opt;

  reset_internal_getopt ();
  while ((opt = internal_getopt (list, "p")) != -1)
    {
      switch (opt)
	{
	case 'p':
	  pflag = 1;
	  break;
	default:
	  builtin_usage ();
	  return (EX_USAGE);
	}
    }
  list = loptend;

  if (list == 0)
    {
      builtin_usage ();
      return (EX_USAGE);
    }

  for (retval = 0; list; list = list->next)
    retval |= validate_path (list->word->word, pflag);

  return (retval ? EXECUTION_FAILURE : EXECUTION_SUCCESS);
}
warning: parse error {
  int retval, pflag, opt;

  reset_internal_getopt ();
  while ((opt = internal_getopt (list, "p")) != -1)
    {
      switch (opt)
	{
	case 'p':
	  pflag = 1;
	  break;
	default:
	  builtin_usage ();
	  return (EX_USAGE);
	}
    }
  list = loptend;

  if (list == 0)
    {
      builtin_usage ();
      return (EX_USAGE);
    }

  for (retval = 0; list; list = list->next)
    retval |= validate_path (list->word->word, pflag);

  return (retval ? EXECUTION_FAILURE : EXECUTION_SUCCESS);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\examples\loadables\pathchk.c:103
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\examples\loadables\pathchk.c:187
parsing error 
{
  const char *p;

  for (p = path; *p; ++p)
    if (portable_chars[(const unsigned char) *p] == 0)
      {
	builtin_error ("path `%s' contains nonportable character `%c'", path, *p);
	return 0;
      }
  return 1;
}
warning: parse error {
  const char *p;

  for (p = path; *p; ++p)
    if (portable_chars[(const unsigned char) *p] == 0)
      {
	builtin_error ("path `%s' contains nonportable character `%c'", path, *p);
	return 0;
      }
  return 1;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\examples\loadables\pathchk.c:188
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\examples\loadables\pathchk.c:226
parsing error 
{
  struct stat stats;

  if (SAFE_STAT (path, &stats))
    return 2;

  if (!S_ISDIR (stats.st_mode))
    {
      builtin_error ("`%s' is not a directory", path);
      return 0;
    }

  /* Use access to test for search permission because
     testing permission bits of st_mode can lose with new
     access control mechanisms.  Of course, access loses if you're
     running setuid. */
  if (access (path, X_OK) != 0)
    {
      if (errno == EACCES)
	builtin_error ("directory `%s' is not searchable", path);
      else
	builtin_error ("%s: %s", path, strerror (errno));
      return 0;
    }

  return 1;
}
warning: parse error {
  struct stat stats;

  if (SAFE_STAT (path, &stats))
    return 2;

  if (!S_ISDIR (stats.st_mode))
    {
      builtin_error ("`%s' is not a directory", path);
      return 0;
    }

  /* Use access to test for search permission because
     testing permission bits of st_mode can lose with new
     access control mechanisms.  Of course, access loses if you're
     running setuid. */
  if (access (path, X_OK) != 0)
    {
      if (errno == EACCES)
	builtin_error ("directory `%s' is not searchable", path);
      else
	builtin_error ("%s: %s", path, strerror (errno));
      return 0;
    }

  return 1;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\examples\loadables\pathchk.c:227
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\examples\loadables\pathchk.c:256
parsing error 
{
  return (savestring (s));
}
warning: parse error {
  return (savestring (s));
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\examples\loadables\pathchk.c:258
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\examples\loadables\pathchk.c:277
parsing error 
{
  int path_max;
  int last_elem;		/* Nonzero if checking last element of path. */
  int exists;			/* 2 if the path element exists.  */
  char *slash;
  char *parent;			/* Last existing leading directory so far.  */

  if (portability && !portable_chars_only (path))
    return 1;

  if (*path == '\0')
    return 0;

#ifdef lint
  /* Suppress `used before initialized' warning.  */
  exists = 0;
#endif

  /* Figure out the parent of the first element in PATH.  */
  parent = xstrdup (*path == '/' ? "/" : ".");

  slash = path;
  last_elem = 0;
  while (1)
    {
      int name_max;
      int length;		/* Length of partial path being checked. */
      char *start;		/* Start of path element being checked. */

      /* Find the end of this element of the path.
	 Then chop off the rest of the path after this element. */
      while (*slash == '/')
	slash++;
      start = slash;
      slash = strchr (slash, '/');
      if (slash != NULL)
	*slash = '\0';
      else
	{
	  last_elem = 1;
	  slash = strchr (start, '\0');
	}

      if (!last_elem)
	{
	  exists = dir_ok (path);
	  if (dir_ok == 0)
	    {
	      free (parent);
	      return 1;
	    }
	}

      length = slash - start;
      /* Since we know that `parent' is a directory, it's ok to call
	 pathconf with it as the argument.  (If `parent' isn't a directory
	 or doesn't exist, the behavior of pathconf is undefined.)
	 But if `parent' is a directory and is on a remote file system,
	 it's likely that pathconf can't give us a reasonable value
	 and will return -1.  (NFS and tempfs are not POSIX . . .)
	 In that case, we have no choice but to assume the pessimal
	 POSIX minimums.  */
      name_max = portability ? _POSIX_NAME_MAX : NAME_MAX_FOR (parent);
      if (name_max < 0)
	name_max = _POSIX_NAME_MAX;
      if (length > name_max)
	{
	  builtin_error ("name `%s' has length %d; exceeds limit of %d",
		 start, length, name_max);
	  free (parent);
	  return 1;
	}

      if (last_elem)
	break;

      if (exists == 1)
	{
	  free (parent);
	  parent = xstrdup (path);
	}

      *slash++ = '/';
    }

  /* `parent' is now the last existing leading directory in the whole path,
     so it's ok to call pathconf with it as the argument.  */
  path_max = portability ? _POSIX_PATH_MAX : PATH_MAX_FOR (parent);
  if (path_max < 0)
    path_max = _POSIX_PATH_MAX;
  free (parent);
  if (strlen (path) > path_max)
    {
      builtin_error ("path `%s' has length %d; exceeds limit of %d",
	     path, strlen (path), path_max);
      return 1;
    }

  return 0;
}
warning: parse error {
  int path_max;
  int last_elem;		/* Nonzero if checking last element of path. */
  int exists;			/* 2 if the path element exists.  */
  char *slash;
  char *parent;			/* Last existing leading directory so far.  */

  if (portability && !portable_chars_only (path))
    return 1;

  if (*path == '\0')
    return 0;

#ifdef lint
  /* Suppress `used before initialized' warning.  */
  exists = 0;
#endif

  /* Figure out the parent of the first element in PATH.  */
  parent = xstrdup (*path == '/' ? "/" : ".");

  slash = path;
  last_elem = 0;
  while (1)
    {
      int name_max;
      int length;		/* Length of partial path being checked. */
      char *start;		/* Start of path element being checked. */

      /* Find the end of this element of the path.
	 Then chop off the rest of the path after this element. */
      while (*slash == '/')
	slash++;
      start = slash;
      slash = strchr (slash, '/');
      if (slash != NULL)
	*slash = '\0';
      else
	{
	  last_elem = 1;
	  slash = strchr (start, '\0');
	}

      if (!last_elem)
	{
	  exists = dir_ok (path);
	  if (dir_ok == 0)
	    {
	      free (parent);
	      return 1;
	    }
	}

      length = slash - start;
      /* Since we know that `parent' is a directory, it's ok to call
	 pathconf with it as the argument.  (If `parent' isn't a directory
	 or doesn't exist, the behavior of pathconf is undefined.)
	 But if `parent' is a directory and is on a remote file system,
	 it's likely that pathconf can't give us a reasonable value
	 and will return -1.  (NFS and tempfs are not POSIX . . .)
	 In that case, we have no choice but to assume the pessimal
	 POSIX minimums.  */
      name_max = portability ? _POSIX_NAME_MAX : NAME_MAX_FOR (parent);
      if (name_max < 0)
	name_max = _POSIX_NAME_MAX;
      if (length > name_max)
	{
	  builtin_error ("name `%s' has length %d; exceeds limit of %d",
		 start, length, name_max);
	  free (parent);
	  return 1;
	}

      if (last_elem)
	break;

      if (exists == 1)
	{
	  free (parent);
	  parent = xstrdup (path);
	}

      *slash++ = '/';
    }

  /* `parent' is now the last existing leading directory in the whole path,
     so it's ok to call pathconf with it as the argument.  */
  path_max = portability ? _POSIX_PATH_MAX : PATH_MAX_FOR (parent);
  if (path_max < 0)
    path_max = _POSIX_PATH_MAX;
  free (parent);
  if (strlen (path) > path_max)
    {
      builtin_error ("path `%s' has length %d; exceeds limit of %d",
	     path, strlen (path), path_max);
      return 1;
    }

  return 0;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\examples\loadables\pathchk.c:280
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\examples\loadables\perl\bperl.c...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\shell.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\examples\loadables\perl\bperl.c:21
parsing error 
{
	char	**v;
	int	c, r;

	v = make_builtin_argv(list, &c);
	r = perl_main(c, v, export_env);
	free(v);

	return r;
}
warning: parse error {
	char	**v;
	int	c, r;

	v = make_builtin_argv(list, &c);
	r = perl_main(c, v, export_env);
	free(v);

	return r;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\examples\loadables\perl\bperl.c:23
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\examples\loadables\perl\iperl.c...
parsing error 
extern void xs_init _((void));
warning: parse error extern void xs_init _((void));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\examples\loadables\perl\iperl.c:4
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\examples\loadables\print.c...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\bashtypes.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\bashansi.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\shell.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\stdc.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\bashgetopt.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\common.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\examples\loadables\print.c:75
parsing error 
{
  int c, r, nflag, raw, ofd, sflag;
  intmax_t lfd;
  char **v, *pfmt, *arg;
  WORD_LIST *l;

  nflag = raw = sflag = 0;
  ofd = 1;
  pfmt = 0;

  reset_internal_getopt ();
  while ((c = internal_getopt (list, "Rnprsu:f:")) != -1)
    {
      switch (c)
	{
	case 'R':
	  raw = 2;
	  loptend = lcurrent;
	  if (loptend && ISOPTION (loptend->word->word, 'n'))
	    {
	      loptend = loptend->next;
	      nflag = 1;
	    }
	  goto opt_end;
	case 'r':
	  raw = 1;
	  break;
	case 'n':
	  nflag = 1;
	  break;
	case 's':
	  sflag = 1;
	  break;
	case 'p':
	  break;	/* NOP */
	case 'u':
	  if (all_digits (list_optarg) && legal_number (list_optarg, &lfd) && lfd == (int)lfd)
	    ofd = lfd;
	  else
	    {
	      for (l = list; l->next && l->next != lcurrent; l = l->next);
	      lcurrent = loptend = l;
	      goto opt_end;
	    }
	  break;
	case 'f':
	  pfmt = list_optarg;
	  break;
	default:
	  builtin_usage ();
	  return (EX_USAGE);
	}
    }

opt_end:
  list = loptend;

  ofp = (ofd == 1) ? stdout : fdopen (dup (ofd), "w");

  if (pfmt)
    {
      WORD_DESC *w;
      WORD_LIST *nlist;

      w = make_word (pfmt);
      nlist = make_word_list (w, list);
      r = printf_builtin (nlist);
      nlist->next = (WORD_LIST *)NULL;
      dispose_words (nlist);
      return (r);
    }

  if (raw)
    {
      for (l = list; l; l = l->next)
	{
	  fprintf (ofp, "%s", l->word->word);
	  if (l->next)
	    fprintf (ofp, " ");
	}
      if (nflag == 0)
	fprintf (ofp, "\n");
      fflush (ofp);
      return (0);	
    }
        
  r = printargs (list, ofp);
  if (r && nflag == 0)
    fprintf (ofp, "\n");
  if (ofd != 1)
    fclose (ofp);
  return 0;
}
warning: parse error {
  int c, r, nflag, raw, ofd, sflag;
  intmax_t lfd;
  char **v, *pfmt, *arg;
  WORD_LIST *l;

  nflag = raw = sflag = 0;
  ofd = 1;
  pfmt = 0;

  reset_internal_getopt ();
  while ((c = internal_getopt (list, "Rnprsu:f:")) != -1)
    {
      switch (c)
	{
	case 'R':
	  raw = 2;
	  loptend = lcurrent;
	  if (loptend && ISOPTION (loptend->word->word, 'n'))
	    {
	      loptend = loptend->next;
	      nflag = 1;
	    }
	  goto opt_end;
	case 'r':
	  raw = 1;
	  break;
	case 'n':
	  nflag = 1;
	  break;
	case 's':
	  sflag = 1;
	  break;
	case 'p':
	  break;	/* NOP */
	case 'u':
	  if (all_digits (list_optarg) && legal_number (list_optarg, &lfd) && lfd == (int)lfd)
	    ofd = lfd;
	  else
	    {
	      for (l = list; l->next && l->next != lcurrent; l = l->next);
	      lcurrent = loptend = l;
	      goto opt_end;
	    }
	  break;
	case 'f':
	  pfmt = list_optarg;
	  break;
	default:
	  builtin_usage ();
	  return (EX_USAGE);
	}
    }

opt_end:
  list = loptend;

  ofp = (ofd == 1) ? stdout : fdopen (dup (ofd), "w");

  if (pfmt)
    {
      WORD_DESC *w;
      WORD_LIST *nlist;

      w = make_word (pfmt);
      nlist = make_word_list (w, list);
      r = printf_builtin (nlist);
      nlist->next = (WORD_LIST *)NULL;
      dispose_words (nlist);
      return (r);
    }

  if (raw)
    {
      for (l = list; l; l = l->next)
	{
	  fprintf (ofp, "%s", l->word->word);
	  if (l->next)
	    fprintf (ofp, " ");
	}
      if (nflag == 0)
	fprintf (ofp, "\n");
      fflush (ofp);
      return (0);	
    }
        
  r = printargs (list, ofp);
  if (r && nflag == 0)
    fprintf (ofp, "\n");
  if (ofd != 1)
    fclose (ofp);
  return 0;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\examples\loadables\print.c:77
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\examples\loadables\print.c:172
parsing error 
{
  WORD_LIST *l;
  char *ostr;
  int sawc;

  for (sawc = 0, l = list; l; l = l->next)
    {
      ostr = ansicstr (l->word->word, strlen (l->word->word), 0, &sawc, (int *)0);
      fprintf (ofp, "%s", ostr);
      free (ostr);
      if (sawc)
        return (0);
      if (l->next)
        fprintf (ofp, " ");
    }
  return (1);
}
warning: parse error {
  WORD_LIST *l;
  char *ostr;
  int sawc;

  for (sawc = 0, l = list; l; l = l->next)
    {
      ostr = ansicstr (l->word->word, strlen (l->word->word), 0, &sawc, (int *)0);
      fprintf (ofp, "%s", ostr);
      free (ostr);
      if (sawc)
        return (0);
      if (l->next)
        fprintf (ofp, " ");
    }
  return (1);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\examples\loadables\print.c:175
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\examples\loadables\printenv.c...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\shell.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\bashgetopt.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\common.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\examples\loadables\printenv.c:37
parsing error 
{
  register char **envp;
  int opt;
  SHELL_VAR *var;

  reset_internal_getopt ();
  while ((opt = internal_getopt (list, "")) != -1)
    {
      switch (opt)
	{
	default:
	  builtin_usage ();
	  return (EX_USAGE);
	}
    }
  list = loptend;

  /* printenv */
  if (list == 0)
    {
      maybe_make_export_env ();		/* this allows minimal code */
      for (envp = export_env; *envp; envp++)
	printf ("%s\n", *envp);
      return (EXECUTION_SUCCESS);
    }

  /* printenv varname */
  var = find_variable (list->word->word);
  if (var == 0 || (exported_p (var) == 0))
    return (EXECUTION_FAILURE);

  if (function_p (var))
    print_var_function (var);
  else
    print_var_value (var, 0);

  printf("\n");
  return (EXECUTION_SUCCESS);
}
warning: parse error {
  register char **envp;
  int opt;
  SHELL_VAR *var;

  reset_internal_getopt ();
  while ((opt = internal_getopt (list, "")) != -1)
    {
      switch (opt)
	{
	default:
	  builtin_usage ();
	  return (EX_USAGE);
	}
    }
  list = loptend;

  /* printenv */
  if (list == 0)
    {
      maybe_make_export_env ();		/* this allows minimal code */
      for (envp = export_env; *envp; envp++)
	printf ("%s\n", *envp);
      return (EXECUTION_SUCCESS);
    }

  /* printenv varname */
  var = find_variable (list->word->word);
  if (var == 0 || (exported_p (var) == 0))
    return (EXECUTION_FAILURE);

  if (function_p (var))
    print_var_function (var);
  else
    print_var_value (var, 0);

  printf("\n");
  return (EXECUTION_SUCCESS);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\examples\loadables\printenv.c:39
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\examples\loadables\push.c...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\shell.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\jobs.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\bashgetopt.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\common.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\examples\loadables\push.c:42
parsing error 
{
  pid_t pid;
  int xstatus, opt;

  xstatus = EXECUTION_SUCCESS;
  reset_internal_getopt ();
  while ((opt = internal_getopt (list, "")) != -1)
    {
      switch (opt)
	{
	default:
	  builtin_usage ();
	  return (EX_USAGE);
	}
    }
  list = loptend;  

  pid = make_child (savestring ("push"), 0);
  if (pid == -1)
    {
      builtin_error ("cannot fork: %s", strerror (errno));
      return (EXECUTION_FAILURE);
    }
  else if (pid == 0)
    {
      /* Shell variable adjustments: $SHLVL, $$, $PPID, $! */
      adjust_shell_level (1);
      dollar_dollar_pid = getpid ();
      set_ppid ();

      /* Clean up job control stuff. */
      stop_making_children ();
      cleanup_the_pipeline ();
      delete_all_jobs (0);

      last_asynchronous_pid = NO_PID;

      /* Make sure the job control code has the right values for
	 the shell's process group and tty process group, and that
	 the signals are set correctly for job control. */
      initialize_job_control (0);
      initialize_job_signals ();

      /* And read commands until exit. */
      reader_loop ();
      exit_shell (last_command_exit_value);
    }
  else
    {
      stop_pipeline (0, (COMMAND *)NULL);
      xstatus = wait_for (pid);
      return (xstatus);
    }   
}
warning: parse error {
  pid_t pid;
  int xstatus, opt;

  xstatus = EXECUTION_SUCCESS;
  reset_internal_getopt ();
  while ((opt = internal_getopt (list, "")) != -1)
    {
      switch (opt)
	{
	default:
	  builtin_usage ();
	  return (EX_USAGE);
	}
    }
  list = loptend;  

  pid = make_child (savestring ("push"), 0);
  if (pid == -1)
    {
      builtin_error ("cannot fork: %s", strerror (errno));
      return (EXECUTION_FAILURE);
    }
  else if (pid == 0)
    {
      /* Shell variable adjustments: $SHLVL, $$, $PPID, $! */
      adjust_shell_level (1);
      dollar_dollar_pid = getpid ();
      set_ppid ();

      /* Clean up job control stuff. */
      stop_making_children ();
      cleanup_the_pipeline ();
      delete_all_jobs (0);

      last_asynchronous_pid = NO_PID;

      /* Make sure the job control code has the right values for
	 the shell's process group and tty process group, and that
	 the signals are set correctly for job control. */
      initialize_job_control (0);
      initialize_job_signals ();

      /* And read commands until exit. */
      reader_loop ();
      exit_shell (last_command_exit_value);
    }
  else
    {
      stop_pipeline (0, (COMMAND *)NULL);
      xstatus = wait_for (pid);
      return (xstatus);
    }   
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\examples\loadables\push.c:44
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\examples\loadables\realpath.c...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\bashansi.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\maxpath.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\shell.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\bashgetopt.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\common.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\examples\loadables\realpath.c:63
parsing error 
{
	int	opt, cflag, vflag, sflag, es;
	char	*r, realbuf[PATH_MAX], *p;
	struct stat sb;

	if (list == 0) {
		builtin_usage();
		return (EX_USAGE);
	}

	vflag = cflag = sflag = 0;
	reset_internal_getopt();
	while ((opt = internal_getopt (list, "csv")) != -1) {
		switch (opt) {
		case 'c':
			cflag = 1;
			break;
		case 's':
			sflag = 1;
			break;
		case 'v':
			vflag = 1;
			break;
		default:
			builtin_usage();
		}
	}

	list = loptend;

	if (list == 0)
		builtin_usage();

	for (es = EXECUTION_SUCCESS; list; list = list->next) {
		p = list->word->word;
		r = sh_realpath(p, realbuf);
		if (r == 0) {
			es = EXECUTION_FAILURE;
			if (sflag == 0)
				builtin_error("%s: cannot resolve: %s", p, strerror(errno));
			continue;
		}
		if (cflag && (stat(realbuf, &sb) < 0)) {
			es = EXECUTION_FAILURE;
			if (sflag == 0)
				builtin_error("%s: %s", p, strerror(errno));
			continue;
		}
		if (sflag == 0) {
			if (vflag)
				printf ("%s -> ", p);
			printf("%s\n", realbuf);
		}
	}
	return es;
}
warning: parse error {
	int	opt, cflag, vflag, sflag, es;
	char	*r, realbuf[PATH_MAX], *p;
	struct stat sb;

	if (list == 0) {
		builtin_usage();
		return (EX_USAGE);
	}

	vflag = cflag = sflag = 0;
	reset_internal_getopt();
	while ((opt = internal_getopt (list, "csv")) != -1) {
		switch (opt) {
		case 'c':
			cflag = 1;
			break;
		case 's':
			sflag = 1;
			break;
		case 'v':
			vflag = 1;
			break;
		default:
			builtin_usage();
		}
	}

	list = loptend;

	if (list == 0)
		builtin_usage();

	for (es = EXECUTION_SUCCESS; list; list = list->next) {
		p = list->word->word;
		r = sh_realpath(p, realbuf);
		if (r == 0) {
			es = EXECUTION_FAILURE;
			if (sflag == 0)
				builtin_error("%s: cannot resolve: %s", p, strerror(errno));
			continue;
		}
		if (cflag && (stat(realbuf, &sb) < 0)) {
			es = EXECUTION_FAILURE;
			if (sflag == 0)
				builtin_error("%s: %s", p, strerror(errno));
			continue;
		}
		if (sflag == 0) {
			if (vflag)
				printf ("%s -> ", p);
			printf("%s\n", realbuf);
		}
	}
	return es;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\examples\loadables\realpath.c:65
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\examples\loadables\rmdir.c...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\shell.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\common.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\examples\loadables\rmdir.c:35
parsing error 
{
  int rval;
  WORD_LIST *l;

  if (no_options (list))
    return (EX_USAGE);

  for (rval = EXECUTION_SUCCESS, l = list; l; l = l->next)
    if (rmdir (l->word->word) < 0)
      {
	builtin_error ("%s: %s", l->word->word, strerror (errno));
	rval = EXECUTION_FAILURE;
      }

  return rval;
}
warning: parse error {
  int rval;
  WORD_LIST *l;

  if (no_options (list))
    return (EX_USAGE);

  for (rval = EXECUTION_SUCCESS, l = list; l; l = l->next)
    if (rmdir (l->word->word) < 0)
      {
	builtin_error ("%s: %s", l->word->word, strerror (errno));
	rval = EXECUTION_FAILURE;
      }

  return rval;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\examples\loadables\rmdir.c:37
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\examples\loadables\sleep.c...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\bashtypes.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\chartypes.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\shell.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\common.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\examples\loadables\sleep.c:59
parsing error 
{
	long	sec, usec;

	if (list == 0) {
		builtin_usage();
		return(EX_USAGE);
	}

	if (*list->word->word == '-' || list->next) {
		builtin_usage ();
		return (EX_USAGE);
	}

    	if (uconvert(list->word->word, &sec, &usec)) {
		fsleep(sec, usec);
		return(EXECUTION_SUCCESS);
    	}

	builtin_error("%s: bad sleep interval", list->word->word);
	return (EXECUTION_FAILURE);
}
warning: parse error {
	long	sec, usec;

	if (list == 0) {
		builtin_usage();
		return(EX_USAGE);
	}

	if (*list->word->word == '-' || list->next) {
		builtin_usage ();
		return (EX_USAGE);
	}

    	if (uconvert(list->word->word, &sec, &usec)) {
		fsleep(sec, usec);
		return(EXECUTION_SUCCESS);
    	}

	builtin_error("%s: bad sleep interval", list->word->word);
	return (EXECUTION_FAILURE);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\examples\loadables\sleep.c:61
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\examples\loadables\strftime.c...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\bashtypes.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\posixtime.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\shell.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\common.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\examples\loadables\strftime.c:39
parsing error 
{
  char *format, *tbuf;
  size_t tbsize, tsize;
  time_t secs;
  struct tm *t;
  int n;
  intmax_t i;

  if (list == 0)
    {
      builtin_usage ();
      return (EX_USAGE);
    }

  if (no_options (list))
    return (EX_USAGE);

  format = list->word->word;
  if (format == 0 || *format == 0)
    {
      printf ("\n");
      return (EXECUTION_SUCCESS);
    }

  list = list->next;

  if (list && list->word->word)
    {
      n = legal_number (list->word->word, &i);
      if (n == 0 || i < 0 || i != (time_t)i)
	{
	  sh_invalidnum (list->word->word);
	  return (EXECUTION_FAILURE);
	}
      else
        secs = i;
    }
  else
    secs = NOW;

  t = localtime (&secs);

  tbsize = strlen (format) * 4;
  tbuf = 0;

  /* Now try to figure out how big the buffer should really be.  strftime(3)
     will return the number of bytes placed in the buffer unless it's greater
     than MAXSIZE, in which case it returns 0. */
  for (n = 1; n < 4; n++)
    {
      tbuf = xrealloc (tbuf, tbsize * n);
      tsize = strftime (tbuf, tbsize * n, format, t);
      if (tsize)
        break;
    }

  printf ("%s\n", tbuf);
  free (tbuf);

  return (EXECUTION_SUCCESS);
}
warning: parse error {
  char *format, *tbuf;
  size_t tbsize, tsize;
  time_t secs;
  struct tm *t;
  int n;
  intmax_t i;

  if (list == 0)
    {
      builtin_usage ();
      return (EX_USAGE);
    }

  if (no_options (list))
    return (EX_USAGE);

  format = list->word->word;
  if (format == 0 || *format == 0)
    {
      printf ("\n");
      return (EXECUTION_SUCCESS);
    }

  list = list->next;

  if (list && list->word->word)
    {
      n = legal_number (list->word->word, &i);
      if (n == 0 || i < 0 || i != (time_t)i)
	{
	  sh_invalidnum (list->word->word);
	  return (EXECUTION_FAILURE);
	}
      else
        secs = i;
    }
  else
    secs = NOW;

  t = localtime (&secs);

  tbsize = strlen (format) * 4;
  tbuf = 0;

  /* Now try to figure out how big the buffer should really be.  strftime(3)
     will return the number of bytes placed in the buffer unless it's greater
     than MAXSIZE, in which case it returns 0. */
  for (n = 1; n < 4; n++)
    {
      tbuf = xrealloc (tbuf, tbsize * n);
      tsize = strftime (tbuf, tbsize * n, format, t);
      if (tsize)
        break;
    }

  printf ("%s\n", tbuf);
  free (tbuf);

  return (EXECUTION_SUCCESS);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\examples\loadables\strftime.c:41
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\examples\loadables\sync.c...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\shell.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\bashgetopt.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\examples\loadables\sync.c:31
parsing error 
{
  sync();
  return (EXECUTION_SUCCESS);
}
warning: parse error {
  sync();
  return (EXECUTION_SUCCESS);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\examples\loadables\sync.c:33
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\examples\loadables\tee.c...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\bashtypes.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\posixstat.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\filecntl.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\bashansi.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\shell.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\bashgetopt.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\common.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\examples\loadables\tee.c:63
parsing error 
{
  int opt, append, nointr, rval, fd, fflags;
  int n, nr, nw;
  FLIST *fl;
  char *buf, *bp;

  char *t;

  reset_internal_getopt ();
  append = nointr = 0;
  tee_flist = (FLIST *)NULL;
  while ((opt = internal_getopt (list, "ai")) != -1)
    {
      switch (opt)
	{
	case 'a':
	  append = 1;
	  break;
	case 'i':
	  nointr = 1;
	  break;
	default:
	  builtin_usage ();
	  return (EX_USAGE);
	}
    }
  list = loptend;

  if (nointr == 0)
    interrupt_immediately++;

  buf = xmalloc (TEE_BUFSIZE);

  /* Initialize output file list. */
  fl = tee_flist = (FLIST *)xmalloc (sizeof(FLIST));
  tee_flist->fd = 1;
  tee_flist->fname = "stdout";
  tee_flist->next = (FLIST *)NULL;

  /* Add file arguments to list of output files. */
  fflags = append ? O_WRONLY|O_CREAT|O_APPEND : O_WRONLY|O_CREAT|O_TRUNC;
  for (rval = EXECUTION_SUCCESS; list; list = list->next)
    {
      fd = open (list->word->word, fflags, 0666);
      if (fd < 0)
        {
          builtin_error ("%s: cannot open: %s", list->word->word, strerror (errno));
          rval = EXECUTION_FAILURE;
        }
      else
        {
          fl->next = (FLIST *)xmalloc (sizeof(FLIST));
          fl->next->fd = fd;
          fl->next->fname = list->word->word;
          fl = fl->next;
          fl->next = (FLIST *)NULL;
        }
    }

  while ((nr = read(0, buf, TEE_BUFSIZE)) > 0)
    for (fl = tee_flist; fl; fl = fl->next)
      {
	n = nr;
	bp = buf;
	do
	  {
	    if ((nw = write (fl->fd, bp, n)) == -1)
	      {
		builtin_error ("%s: write error: %s", fl->fname, strerror (errno));
		rval = EXECUTION_FAILURE;
		break;
	      }
            bp += nw;
	  }
	while (n -= nw);
      }
  if (nr < 0)
    builtin_error ("read error: %s", strerror (errno));

  /* Deallocate resources -- this is a builtin command. */
  tee_flist = tee_flist->next;		/* skip bogus close of stdout */
  while (tee_flist)
    {
      fl = tee_flist;
      if (close (fl->fd) < 0)
	{
	  builtin_error ("%s: close_error: %s", fl->fname, strerror (errno));
	  rval = EXECUTION_FAILURE;
	}
      tee_flist = tee_flist->next;
      free (fl);
    }
  
  return (rval);
}
warning: parse error {
  int opt, append, nointr, rval, fd, fflags;
  int n, nr, nw;
  FLIST *fl;
  char *buf, *bp;

  char *t;

  reset_internal_getopt ();
  append = nointr = 0;
  tee_flist = (FLIST *)NULL;
  while ((opt = internal_getopt (list, "ai")) != -1)
    {
      switch (opt)
	{
	case 'a':
	  append = 1;
	  break;
	case 'i':
	  nointr = 1;
	  break;
	default:
	  builtin_usage ();
	  return (EX_USAGE);
	}
    }
  list = loptend;

  if (nointr == 0)
    interrupt_immediately++;

  buf = xmalloc (TEE_BUFSIZE);

  /* Initialize output file list. */
  fl = tee_flist = (FLIST *)xmalloc (sizeof(FLIST));
  tee_flist->fd = 1;
  tee_flist->fname = "stdout";
  tee_flist->next = (FLIST *)NULL;

  /* Add file arguments to list of output files. */
  fflags = append ? O_WRONLY|O_CREAT|O_APPEND : O_WRONLY|O_CREAT|O_TRUNC;
  for (rval = EXECUTION_SUCCESS; list; list = list->next)
    {
      fd = open (list->word->word, fflags, 0666);
      if (fd < 0)
        {
          builtin_error ("%s: cannot open: %s", list->word->word, strerror (errno));
          rval = EXECUTION_FAILURE;
        }
      else
        {
          fl->next = (FLIST *)xmalloc (sizeof(FLIST));
          fl->next->fd = fd;
          fl->next->fname = list->word->word;
          fl = fl->next;
          fl->next = (FLIST *)NULL;
        }
    }

  while ((nr = read(0, buf, TEE_BUFSIZE)) > 0)
    for (fl = tee_flist; fl; fl = fl->next)
      {
	n = nr;
	bp = buf;
	do
	  {
	    if ((nw = write (fl->fd, bp, n)) == -1)
	      {
		builtin_error ("%s: write error: %s", fl->fname, strerror (errno));
		rval = EXECUTION_FAILURE;
		break;
	      }
            bp += nw;
	  }
	while (n -= nw);
      }
  if (nr < 0)
    builtin_error ("read error: %s", strerror (errno));

  /* Deallocate resources -- this is a builtin command. */
  tee_flist = tee_flist->next;		/* skip bogus close of stdout */
  while (tee_flist)
    {
      fl = tee_flist;
      if (close (fl->fd) < 0)
	{
	  builtin_error ("%s: close_error: %s", fl->fname, strerror (errno));
	  rval = EXECUTION_FAILURE;
	}
      tee_flist = tee_flist->next;
      free (fl);
    }
  
  return (rval);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\examples\loadables\tee.c:65
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\examples\loadables\template.c...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\bashansi.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\shell.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\bashgetopt.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\examples\loadables\template.c:24
parsing error 
{
  int opt, rval;

  rval = EXECUTION_SUCCESS;
  reset_internal_getopt ();
  while ((opt = internal_getopt (list, "")) != -1)
    {
      switch (opt)
	{
	default:
	  builtin_usage ();
	  return (EX_USAGE);
	}
    }
  list = loptend;

  return (rval);
}
warning: parse error {
  int opt, rval;

  rval = EXECUTION_SUCCESS;
  reset_internal_getopt ();
  while ((opt = internal_getopt (list, "")) != -1)
    {
      switch (opt)
	{
	default:
	  builtin_usage ();
	  return (EX_USAGE);
	}
    }
  list = loptend;

  return (rval);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\examples\loadables\template.c:26
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\examples\loadables\truefalse.c...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\bashtypes.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\shell.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\common.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\examples\loadables\truefalse.c:28
parsing error 
{
  return EXECUTION_SUCCESS;
}
warning: parse error {
  return EXECUTION_SUCCESS;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\examples\loadables\truefalse.c:30
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\examples\loadables\truefalse.c:34
parsing error 
{
  return EXECUTION_FAILURE;
}
warning: parse error {
  return EXECUTION_FAILURE;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\examples\loadables\truefalse.c:36
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\examples\loadables\tty.c...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\shell.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\bashgetopt.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\common.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\examples\loadables\tty.c:33
parsing error 
{
  int opt, sflag;
  char *t;

  reset_internal_getopt ();
  sflag = 0;
  while ((opt = internal_getopt (list, "s")) != -1)
    {
      switch (opt)
	{
	case 's':
	  sflag = 1;
	  break;
	default:
	  builtin_usage ();
	  return (EX_USAGE);
	}
    }
  list = loptend;

  t = ttyname (0);
  if (sflag == 0)
    puts (t ? t : "not a tty");
  return (t ? EXECUTION_SUCCESS : EXECUTION_FAILURE);
}
warning: parse error {
  int opt, sflag;
  char *t;

  reset_internal_getopt ();
  sflag = 0;
  while ((opt = internal_getopt (list, "s")) != -1)
    {
      switch (opt)
	{
	case 's':
	  sflag = 1;
	  break;
	default:
	  builtin_usage ();
	  return (EX_USAGE);
	}
    }
  list = loptend;

  t = ttyname (0);
  if (sflag == 0)
    puts (t ? t : "not a tty");
  return (t ? EXECUTION_SUCCESS : EXECUTION_FAILURE);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\examples\loadables\tty.c:35
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\examples\loadables\uname.c...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\bashtypes.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\shell.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\bashgetopt.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\common.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\examples\loadables\uname.c:66
parsing error 
{
  int opt, r;
  struct utsname uninfo;

  uname_flags = 0;
  reset_internal_getopt ();
  while ((opt = internal_getopt (list, "amnprsv")) != -1)
    {
      switch (opt)
	{
	case 'a':
	  uname_flags |= FLAG_ALL;
	  break;
	case 'm':
	case 'p':
	  uname_flags |= FLAG_MACHINE;
	  break;
	case 'n':
	  uname_flags |= FLAG_NODENAME;
	  break;
	case 'r':
	  uname_flags |= FLAG_RELEASE;
	  break;
	case 's':
	  uname_flags |= FLAG_SYSNAME;
	  break;
	case 'v':
	  uname_flags |= FLAG_VERSION;
	  break;
	default:
	  builtin_usage ();
	  return (EX_USAGE);
	}
    }
  list = loptend;

  if (list)
    {
      builtin_usage ();
      return (EX_USAGE);
    }

  if (uname_flags == 0)
    uname_flags = FLAG_SYSNAME;

  /* Only ancient systems will not have uname(2). */
#ifdef HAVE_UNAME
  if (uname (&uninfo) < 0)
    {
      builtin_error ("cannot get system name: %s", strerror (errno));
      return (EXECUTION_FAILURE);
    }
#else
  builtin_error ("cannot get system information: uname(2) not available");
  return (EXECUTION_FAILURE);
#endif

  uprint (FLAG_SYSNAME, uninfo.sysname);
  uprint (FLAG_NODENAME, uninfo.nodename);
  uprint (FLAG_RELEASE, uninfo.release);
  uprint (FLAG_VERSION, uninfo.version);
  uprint (FLAG_MACHINE, uninfo.machine);

  return (EXECUTION_SUCCESS);
}
warning: parse error {
  int opt, r;
  struct utsname uninfo;

  uname_flags = 0;
  reset_internal_getopt ();
  while ((opt = internal_getopt (list, "amnprsv")) != -1)
    {
      switch (opt)
	{
	case 'a':
	  uname_flags |= FLAG_ALL;
	  break;
	case 'm':
	case 'p':
	  uname_flags |= FLAG_MACHINE;
	  break;
	case 'n':
	  uname_flags |= FLAG_NODENAME;
	  break;
	case 'r':
	  uname_flags |= FLAG_RELEASE;
	  break;
	case 's':
	  uname_flags |= FLAG_SYSNAME;
	  break;
	case 'v':
	  uname_flags |= FLAG_VERSION;
	  break;
	default:
	  builtin_usage ();
	  return (EX_USAGE);
	}
    }
  list = loptend;

  if (list)
    {
      builtin_usage ();
      return (EX_USAGE);
    }

  if (uname_flags == 0)
    uname_flags = FLAG_SYSNAME;

  /* Only ancient systems will not have uname(2). */
#ifdef HAVE_UNAME
  if (uname (&uninfo) < 0)
    {
      builtin_error ("cannot get system name: %s", strerror (errno));
      return (EXECUTION_FAILURE);
    }
#else
  builtin_error ("cannot get system information: uname(2) not available");
  return (EXECUTION_FAILURE);
#endif

  uprint (FLAG_SYSNAME, uninfo.sysname);
  uprint (FLAG_NODENAME, uninfo.nodename);
  uprint (FLAG_RELEASE, uninfo.release);
  uprint (FLAG_VERSION, uninfo.version);
  uprint (FLAG_MACHINE, uninfo.machine);

  return (EXECUTION_SUCCESS);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\examples\loadables\uname.c:68
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\examples\loadables\uname.c:135
parsing error 
{
  if (uname_flags & flag)
    {
      uname_flags &= ~flag;
      printf ("%s%c", info, uname_flags ? ' ' : '\n');
    }
}
warning: parse error {
  if (uname_flags & flag)
    {
      uname_flags &= ~flag;
      printf ("%s%c", info, uname_flags ? ' ' : '\n');
    }
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\examples\loadables\uname.c:138
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\examples\loadables\unlink.c...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\shell.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\common.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\examples\loadables\unlink.c:41
parsing error 
{
  if (list == 0)
    {
      builtin_usage ();
      return (EX_USAGE);
    }

  if (unlink (list->word->word) != 0)
    {
      builtin_error ("%s: cannot unlink: %s", list->word->word, strerror (errno));
      return (EXECUTION_FAILURE);
    }

  return (EXECUTION_SUCCESS);
}
warning: parse error {
  if (list == 0)
    {
      builtin_usage ();
      return (EX_USAGE);
    }

  if (unlink (list->word->word) != 0)
    {
      builtin_error ("%s: cannot unlink: %s", list->word->word, strerror (errno));
      return (EXECUTION_FAILURE);
    }

  return (EXECUTION_SUCCESS);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\examples\loadables\unlink.c:43
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\examples\loadables\whoami.c...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\shell.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\bashgetopt.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\common.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\examples\loadables\whoami.c:31
parsing error 
{
  int opt;

  reset_internal_getopt ();
  while ((opt = internal_getopt (list, "")) != -1)
    {
      switch (opt)
	{
	default:
	  builtin_usage ();
	  return (EX_USAGE);
	}
    }
  list = loptend;
  if (list)
    {
      builtin_usage ();
      return (EX_USAGE);
    }

  if (current_user.user_name == 0)
    get_current_user_info ();
  printf ("%s\n", current_user.user_name);
  return (EXECUTION_SUCCESS);
}
warning: parse error {
  int opt;

  reset_internal_getopt ();
  while ((opt = internal_getopt (list, "")) != -1)
    {
      switch (opt)
	{
	default:
	  builtin_usage ();
	  return (EX_USAGE);
	}
    }
  list = loptend;
  if (list)
    {
      builtin_usage ();
      return (EX_USAGE);
    }

  if (current_user.user_name == 0)
    get_current_user_info ();
  printf ("%s\n", current_user.user_name);
  return (EXECUTION_SUCCESS);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\examples\loadables\whoami.c:33
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\execute_cmd.c...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\chartypes.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\bashtypes.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\filecntl.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\posixstat.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\posixtime.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\bashansi.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\bashintl.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\memalloc.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\shell.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\y.tab.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\flags.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\hashlib.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\jobs.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\execute_cmd.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\findcmd.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\redir.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\trap.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\pathexp.h...skip
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\hashcmd.h...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\stdc.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\hashlib.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\common.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\glob\strmatch.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\tilde\tilde.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\execute_cmd.c:291
parsing error 
{
  struct fd_bitmap *ret;

  ret = (struct fd_bitmap *)xmalloc (sizeof (struct fd_bitmap));

  ret->size = size;

  if (size)
    {
      ret->bitmap = (char *)xmalloc (size);
      memset (ret->bitmap, '\0', size);
    }
  else
    ret->bitmap = (char *)NULL;
  return (ret);
}
warning: parse error {
  struct fd_bitmap *ret;

  ret = (struct fd_bitmap *)xmalloc (sizeof (struct fd_bitmap));

  ret->size = size;

  if (size)
    {
      ret->bitmap = (char *)xmalloc (size);
      memset (ret->bitmap, '\0', size);
    }
  else
    ret->bitmap = (char *)NULL;
  return (ret);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\execute_cmd.c:293
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\execute_cmd.c:311
parsing error 
{
  FREE (fdbp->bitmap);
  free (fdbp);
}
warning: parse error {
  FREE (fdbp->bitmap);
  free (fdbp);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\execute_cmd.c:313
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\execute_cmd.c:319
parsing error 
{
  register int i;

  if (fdbp)
    {
      for (i = 0; i < fdbp->size; i++)
	if (fdbp->bitmap[i])
	  {
	    close (i);
	    fdbp->bitmap[i] = 0;
	  }
    }
}
warning: parse error {
  register int i;

  if (fdbp)
    {
      for (i = 0; i < fdbp->size; i++)
	if (fdbp->bitmap[i])
	  {
	    close (i);
	    fdbp->bitmap[i] = 0;
	  }
    }
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\execute_cmd.c:321
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\execute_cmd.c:370
parsing error 
{
  struct fd_bitmap *bitmap;
  int result;

  current_fds_to_close = (struct fd_bitmap *)NULL;
  bitmap = new_fd_bitmap (FD_BITMAP_DEFAULT_SIZE);
  begin_unwind_frame ("execute-command");
  add_unwind_protect (dispose_fd_bitmap, (char *)bitmap);

  /* Just do the command, but not asynchronously. */
  result = execute_command_internal (command, 0, NO_PIPE, NO_PIPE, bitmap);

  dispose_fd_bitmap (bitmap);
  discard_unwind_frame ("execute-command");

#if defined (PROCESS_SUBSTITUTION)
  /* don't unlink fifos if we're in a shell function; wait until the function
     returns. */
  if (variable_context == 0)
    unlink_fifo_list ();
#endif /* PROCESS_SUBSTITUTION */

  QUIT;
  return (result);
}
warning: parse error {
  struct fd_bitmap *bitmap;
  int result;

  current_fds_to_close = (struct fd_bitmap *)NULL;
  bitmap = new_fd_bitmap (FD_BITMAP_DEFAULT_SIZE);
  begin_unwind_frame ("execute-command");
  add_unwind_protect (dispose_fd_bitmap, (char *)bitmap);

  /* Just do the command, but not asynchronously. */
  result = execute_command_internal (command, 0, NO_PIPE, NO_PIPE, bitmap);

  dispose_fd_bitmap (bitmap);
  discard_unwind_frame ("execute-command");

#if defined (PROCESS_SUBSTITUTION)
  /* don't unlink fifos if we're in a shell function; wait until the function
     returns. */
  if (variable_context == 0)
    unlink_fifo_list ();
#endif /* PROCESS_SUBSTITUTION */

  QUIT;
  return (result);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\execute_cmd.c:372
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\execute_cmd.c:400
parsing error 
{
  switch (type)
    {
#if defined (ARITH_FOR_COMMAND)
    case cm_arith_for:
#endif
#if defined (SELECT_COMMAND)
    case cm_select:
#endif
#if defined (DPAREN_ARITHMETIC)
    case cm_arith:
#endif
#if defined (COND_COMMAND)
    case cm_cond:
#endif
    case cm_case:
    case cm_while:
    case cm_until:
    case cm_if:
    case cm_for:
    case cm_group:
    case cm_function_def:
      return (1);

    default:
      return (0);
    }
}
warning: parse error {
  switch (type)
    {
#if defined (ARITH_FOR_COMMAND)
    case cm_arith_for:
#endif
#if defined (SELECT_COMMAND)
    case cm_select:
#endif
#if defined (DPAREN_ARITHMETIC)
    case cm_arith:
#endif
#if defined (COND_COMMAND)
    case cm_cond:
#endif
    case cm_case:
    case cm_while:
    case cm_until:
    case cm_if:
    case cm_for:
    case cm_group:
    case cm_function_def:
      return (1);

    default:
      return (0);
    }
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\execute_cmd.c:402
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\execute_cmd.c:434
parsing error 
{
  do_redirections (list, RX_ACTIVE);
  dispose_redirects (list);
}
warning: parse error {
  do_redirections (list, RX_ACTIVE);
  dispose_redirects (list);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\execute_cmd.c:436
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\execute_cmd.c:523
parsing error 
{
  int exec_result, user_subshell, invert, ignore_return, was_error_trap;
  REDIRECT *my_undo_list, *exec_undo_list;
  volatile int last_pid;
  volatile int save_line_number;

#if 0
  if (command == 0 || breaking || continuing || read_but_dont_execute)
    return (EXECUTION_SUCCESS);
#else
  if (breaking || continuing)
    return (last_command_exit_value);
  if (command == 0 || read_but_dont_execute)
    return (EXECUTION_SUCCESS);
#endif

  QUIT;
  run_pending_traps ();

#if 0
  if (running_trap == 0)
#endif
    currently_executing_command = command;

  invert = (command->flags & CMD_INVERT_RETURN) != 0;

  /* If we're inverting the return value and `set -e' has been executed,
     we don't want a failing command to inadvertently cause the shell
     to exit. */
  if (exit_immediately_on_error && invert)	/* XXX */
    command->flags |= CMD_IGNORE_RETURN;	/* XXX */

  exec_result = EXECUTION_SUCCESS;

  /* If a command was being explicitly run in a subshell, or if it is
     a shell control-structure, and it has a pipe, then we do the command
     in a subshell. */
  if (command->type == cm_subshell && (command->flags & CMD_NO_FORK))
    return (execute_in_subshell (command, asynchronous, pipe_in, pipe_out, fds_to_close));

#if defined (COPROCESS_SUPPORT)
  if (command->type == cm_coproc)
    return (execute_coproc (command, pipe_in, pipe_out, fds_to_close));
#endif

  user_subshell = command->type == cm_subshell || ((command->flags & CMD_WANT_SUBSHELL) != 0);

  if (command->type == cm_subshell ||
      (command->flags & (CMD_WANT_SUBSHELL|CMD_FORCE_SUBSHELL)) ||
      (shell_control_structure (command->type) &&
       (pipe_out != NO_PIPE || pipe_in != NO_PIPE || asynchronous)))
    {
      pid_t paren_pid;

      /* Fork a subshell, turn off the subshell bit, turn off job
	 control and call execute_command () on the command again. */
      line_number_for_err_trap = line_number;
      paren_pid = make_child (savestring (make_command_string (command)),
			      asynchronous);
      if (paren_pid == 0)
	exit (execute_in_subshell (command, asynchronous, pipe_in, pipe_out, fds_to_close));
	/* NOTREACHED */
      else
	{
	  close_pipes (pipe_in, pipe_out);

#if defined (PROCESS_SUBSTITUTION) && defined (HAVE_DEV_FD)
	  unlink_fifo_list ();
#endif
	  /* If we are part of a pipeline, and not the end of the pipeline,
	     then we should simply return and let the last command in the
	     pipe be waited for.  If we are not in a pipeline, or are the
	     last command in the pipeline, then we wait for the subshell
	     and return its exit status as usual. */
	  if (pipe_out != NO_PIPE)
	    return (EXECUTION_SUCCESS);

	  stop_pipeline (asynchronous, (COMMAND *)NULL);

	  if (asynchronous == 0)
	    {
	      was_error_trap = signal_is_trapped (ERROR_TRAP) && signal_is_ignored (ERROR_TRAP) == 0;
	      invert = (command->flags & CMD_INVERT_RETURN) != 0;
	      ignore_return = (command->flags & CMD_IGNORE_RETURN) != 0;

	      exec_result = wait_for (paren_pid);

	      /* If we have to, invert the return value. */
	      if (invert)
		exec_result = ((exec_result == EXECUTION_SUCCESS)
				? EXECUTION_FAILURE
				: EXECUTION_SUCCESS);

	      last_command_exit_value = exec_result;
	      if (user_subshell && was_error_trap && ignore_return == 0 && invert == 0 && exec_result != EXECUTION_SUCCESS)
		{
		  save_line_number = line_number;
		  line_number = line_number_for_err_trap;
		  run_error_trap ();
		  line_number = save_line_number;
		}

	      if (user_subshell && ignore_return == 0 && invert == 0 && exit_immediately_on_error && exec_result != EXECUTION_SUCCESS)
		{
		  run_pending_traps ();
		  jump_to_top_level (ERREXIT);
		}

	      return (last_command_exit_value);
	    }
	  else
	    {
	      DESCRIBE_PID (paren_pid);

	      run_pending_traps ();

	      return (EXECUTION_SUCCESS);
	    }
	}
    }

#if defined (COMMAND_TIMING)
  if (command->flags & CMD_TIME_PIPELINE)
    {
      if (asynchronous)
	{
	  command->flags |= CMD_FORCE_SUBSHELL;
	  exec_result = execute_command_internal (command, 1, pipe_in, pipe_out, fds_to_close);
	}
      else
	{
	  exec_result = time_command (command, asynchronous, pipe_in, pipe_out, fds_to_close);
#if 0
	  if (running_trap == 0)
#endif
	    currently_executing_command = (COMMAND *)NULL;
	}
      return (exec_result);
    }
#endif /* COMMAND_TIMING */

  if (shell_control_structure (command->type) && command->redirects)
    stdin_redir = stdin_redirects (command->redirects);

  /* Handle WHILE FOR CASE etc. with redirections.  (Also '&' input
     redirection.)  */
  if (do_redirections (command->redirects, RX_ACTIVE|RX_UNDOABLE) != 0)
    {
      cleanup_redirects (redirection_undo_list);
      redirection_undo_list = (REDIRECT *)NULL;
      dispose_exec_redirects ();
      return (last_command_exit_value = EXECUTION_FAILURE);
    }

  if (redirection_undo_list)
    {
      /* XXX - why copy here? */
      my_undo_list = (REDIRECT *)copy_redirects (redirection_undo_list);
      dispose_redirects (redirection_undo_list);
      redirection_undo_list = (REDIRECT *)NULL;
    }
  else
    my_undo_list = (REDIRECT *)NULL;

  if (exec_redirection_undo_list)
    {
      /* XXX - why copy here? */
      exec_undo_list = (REDIRECT *)copy_redirects (exec_redirection_undo_list);
      dispose_redirects (exec_redirection_undo_list);
      exec_redirection_undo_list = (REDIRECT *)NULL;
    }
  else
    exec_undo_list = (REDIRECT *)NULL;

  if (my_undo_list || exec_undo_list)
    begin_unwind_frame ("loop_redirections");

  if (my_undo_list)
    add_unwind_protect ((Function *)cleanup_redirects, my_undo_list);

  if (exec_undo_list)
    add_unwind_protect ((Function *)dispose_redirects, exec_undo_list);

  ignore_return = (command->flags & CMD_IGNORE_RETURN) != 0;

  QUIT;

  switch (command->type)
    {
    case cm_simple:
      {
	save_line_number = line_number;
	/* We can't rely on variables retaining their values across a
	   call to execute_simple_command if a longjmp occurs as the
	   result of a `return' builtin.  This is true for sure with gcc. */
#if defined (RECYCLES_PIDS)
	last_made_pid = NO_PID;
#endif
	last_pid = last_made_pid;
	was_error_trap = signal_is_trapped (ERROR_TRAP) && signal_is_ignored (ERROR_TRAP) == 0;

	if (ignore_return && command->value.Simple)
	  command->value.Simple->flags |= CMD_IGNORE_RETURN;
	if (command->flags & CMD_STDIN_REDIR)
	  command->value.Simple->flags |= CMD_STDIN_REDIR;

	line_number_for_err_trap = line_number = command->value.Simple->line;
	exec_result =
	  execute_simple_command (command->value.Simple, pipe_in, pipe_out,
				  asynchronous, fds_to_close);
	line_number = save_line_number;

	/* The temporary environment should be used for only the simple
	   command immediately following its definition. */
	dispose_used_env_vars ();

#if (defined (ultrix) && defined (mips)) || defined (C_ALLOCA)
	/* Reclaim memory allocated with alloca () on machines which
	   may be using the alloca emulation code. */
	(void) alloca (0);
#endif /* (ultrix && mips) || C_ALLOCA */

	/* If we forked to do the command, then we must wait_for ()
	   the child. */

	/* XXX - this is something to watch out for if there are problems
	   when the shell is compiled without job control. */
	if (already_making_children && pipe_out == NO_PIPE &&
	    last_made_pid != last_pid)
	  {
	    stop_pipeline (asynchronous, (COMMAND *)NULL);

	    if (asynchronous)
	      {
		DESCRIBE_PID (last_made_pid);
	      }
	    else
#if !defined (JOB_CONTROL)
	      /* Do not wait for asynchronous processes started from
		 startup files. */
	    if (last_made_pid != last_asynchronous_pid)
#endif
	    /* When executing a shell function that executes other
	       commands, this causes the last simple command in
	       the function to be waited for twice.  This also causes
	       subshells forked to execute builtin commands (e.g., in
	       pipelines) to be waited for twice. */
	      exec_result = wait_for (last_made_pid);
	  }
      }

      /* 2009/02/13 -- pipeline failure is processed elsewhere.  This handles
	 only the failure of a simple command. */
      if (was_error_trap && ignore_return == 0 && invert == 0 && pipe_in == NO_PIPE && pipe_out == NO_PIPE && exec_result != EXECUTION_SUCCESS)
	{
	  last_command_exit_value = exec_result;
	  line_number = line_number_for_err_trap;
	  run_error_trap ();
	  line_number = save_line_number;
	}

      if (ignore_return == 0 && invert == 0 &&
	  ((posixly_correct && interactive == 0 && special_builtin_failed) ||
	   (exit_immediately_on_error && pipe_in == NO_PIPE && pipe_out == NO_PIPE && exec_result != EXECUTION_SUCCESS)))
	{
	  last_command_exit_value = exec_result;
	  run_pending_traps ();
	  jump_to_top_level (ERREXIT);
	}

      break;

    case cm_for:
      if (ignore_return)
	command->value.For->flags |= CMD_IGNORE_RETURN;
      exec_result = execute_for_command (command->value.For);
      break;

#if defined (ARITH_FOR_COMMAND)
    case cm_arith_for:
      if (ignore_return)
	command->value.ArithFor->flags |= CMD_IGNORE_RETURN;
      exec_result = execute_arith_for_command (command->value.ArithFor);
      break;
#endif

#if defined (SELECT_COMMAND)
    case cm_select:
      if (ignore_return)
	command->value.Select->flags |= CMD_IGNORE_RETURN;
      exec_result = execute_select_command (command->value.Select);
      break;
#endif

    case cm_case:
      if (ignore_return)
	command->value.Case->flags |= CMD_IGNORE_RETURN;
      exec_result = execute_case_command (command->value.Case);
      break;

    case cm_while:
      if (ignore_return)
	command->value.While->flags |= CMD_IGNORE_RETURN;
      exec_result = execute_while_command (command->value.While);
      break;

    case cm_until:
      if (ignore_return)
	command->value.While->flags |= CMD_IGNORE_RETURN;
      exec_result = execute_until_command (command->value.While);
      break;

    case cm_if:
      if (ignore_return)
	command->value.If->flags |= CMD_IGNORE_RETURN;
      exec_result = execute_if_command (command->value.If);
      break;

    case cm_group:

      /* This code can be executed from either of two paths: an explicit
	 '{}' command, or via a function call.  If we are executed via a
	 function call, we have already taken care of the function being
	 executed in the background (down there in execute_simple_command ()),
	 and this command should *not* be marked as asynchronous.  If we
	 are executing a regular '{}' group command, and asynchronous == 1,
	 we must want to execute the whole command in the background, so we
	 need a subshell, and we want the stuff executed in that subshell
	 (this group command) to be executed in the foreground of that
	 subshell (i.e. there will not be *another* subshell forked).

	 What we do is to force a subshell if asynchronous, and then call
	 execute_command_internal again with asynchronous still set to 1,
	 but with the original group command, so the printed command will
	 look right.

	 The code above that handles forking off subshells will note that
	 both subshell and async are on, and turn off async in the child
	 after forking the subshell (but leave async set in the parent, so
	 the normal call to describe_pid is made).  This turning off
	 async is *crucial*; if it is not done, this will fall into an
	 infinite loop of executions through this spot in subshell after
	 subshell until the process limit is exhausted. */

      if (asynchronous)
	{
	  command->flags |= CMD_FORCE_SUBSHELL;
	  exec_result =
	    execute_command_internal (command, 1, pipe_in, pipe_out,
				      fds_to_close);
	}
      else
	{
	  if (ignore_return && command->value.Group->command)
	    command->value.Group->command->flags |= CMD_IGNORE_RETURN;
	  exec_result =
	    execute_command_internal (command->value.Group->command,
				      asynchronous, pipe_in, pipe_out,
				      fds_to_close);
	}
      break;

    case cm_connection:
      exec_result = execute_connection (command, asynchronous,
					pipe_in, pipe_out, fds_to_close);
      break;

#if defined (DPAREN_ARITHMETIC)
    case cm_arith:
      was_error_trap = signal_is_trapped (ERROR_TRAP) && signal_is_ignored (ERROR_TRAP) == 0;
      if (ignore_return)
	command->value.Arith->flags |= CMD_IGNORE_RETURN;
      line_number_for_err_trap = save_line_number = line_number;
      exec_result = execute_arith_command (command->value.Arith);
      line_number = save_line_number;

      if (was_error_trap && ignore_return == 0 && invert == 0 && exec_result != EXECUTION_SUCCESS)
	{
	  last_command_exit_value = exec_result;
	  save_line_number = line_number;
	  line_number = line_number_for_err_trap;
	  run_error_trap ();
	  line_number = save_line_number;
	}

      if (ignore_return == 0 && invert == 0 && exit_immediately_on_error && exec_result != EXECUTION_SUCCESS)
	{
	  last_command_exit_value = exec_result;
	  run_pending_traps ();
	  jump_to_top_level (ERREXIT);
	}

      break;
#endif

#if defined (COND_COMMAND)
    case cm_cond:
      was_error_trap = signal_is_trapped (ERROR_TRAP) && signal_is_ignored (ERROR_TRAP) == 0;
      if (ignore_return)
	command->value.Cond->flags |= CMD_IGNORE_RETURN;

      line_number_for_err_trap = save_line_number = line_number;
      exec_result = execute_cond_command (command->value.Cond);
      line_number = save_line_number;

      if (was_error_trap && ignore_return == 0 && invert == 0 && exec_result != EXECUTION_SUCCESS)
	{
	  last_command_exit_value = exec_result;
	  save_line_number = line_number;
	  line_number = line_number_for_err_trap;
	  run_error_trap ();
	  line_number = save_line_number;
	}

      if (ignore_return == 0 && invert == 0 && exit_immediately_on_error && exec_result != EXECUTION_SUCCESS)
	{
	  last_command_exit_value = exec_result;
	  run_pending_traps ();
	  jump_to_top_level (ERREXIT);
	}

      break;
#endif
    
    case cm_function_def:
      exec_result = execute_intern_function (command->value.Function_def->name,
					     command->value.Function_def->command);
      break;

    default:
      command_error ("execute_command", CMDERR_BADTYPE, command->type, 0);
    }

  if (my_undo_list)
    {
      do_redirections (my_undo_list, RX_ACTIVE);
      dispose_redirects (my_undo_list);
    }

  if (exec_undo_list)
    dispose_redirects (exec_undo_list);

  if (my_undo_list || exec_undo_list)
    discard_unwind_frame ("loop_redirections");

  /* Invert the return value if we have to */
  if (invert)
    exec_result = (exec_result == EXECUTION_SUCCESS)
		    ? EXECUTION_FAILURE
		    : EXECUTION_SUCCESS;

#if defined (DPAREN_ARITHMETIC) || defined (COND_COMMAND)
  /* This is where we set PIPESTATUS from the exit status of the appropriate
     compound commands (the ones that look enough like simple commands to
     cause confusion).  We might be able to optimize by not doing this if
     subshell_environment != 0. */
  switch (command->type)
    {
#  if defined (DPAREN_ARITHMETIC)
    case cm_arith:
#  endif
#  if defined (COND_COMMAND)
    case cm_cond:
#  endif
      set_pipestatus_from_exit (exec_result);
      break;
    }
#endif

  last_command_exit_value = exec_result;
  run_pending_traps ();
#if 0
  if (running_trap == 0)
#endif
    currently_executing_command = (COMMAND *)NULL;
  return (last_command_exit_value);
}
warning: parse error {
  int exec_result, user_subshell, invert, ignore_return, was_error_trap;
  REDIRECT *my_undo_list, *exec_undo_list;
  volatile int last_pid;
  volatile int save_line_number;

#if 0
  if (command == 0 || breaking || continuing || read_but_dont_execute)
    return (EXECUTION_SUCCESS);
#else
  if (breaking || continuing)
    return (last_command_exit_value);
  if (command == 0 || read_but_dont_execute)
    return (EXECUTION_SUCCESS);
#endif

  QUIT;
  run_pending_traps ();

#if 0
  if (running_trap == 0)
#endif
    currently_executing_command = command;

  invert = (command->flags & CMD_INVERT_RETURN) != 0;

  /* If we're inverting the return value and `set -e' has been executed,
     we don't want a failing command to inadvertently cause the shell
     to exit. */
  if (exit_immediately_on_error && invert)	/* XXX */
    command->flags |= CMD_IGNORE_RETURN;	/* XXX */

  exec_result = EXECUTION_SUCCESS;

  /* If a command was being explicitly run in a subshell, or if it is
     a shell control-structure, and it has a pipe, then we do the command
     in a subshell. */
  if (command->type == cm_subshell && (command->flags & CMD_NO_FORK))
    return (execute_in_subshell (command, asynchronous, pipe_in, pipe_out, fds_to_close));

#if defined (COPROCESS_SUPPORT)
  if (command->type == cm_coproc)
    return (execute_coproc (command, pipe_in, pipe_out, fds_to_close));
#endif

  user_subshell = command->type == cm_subshell || ((command->flags & CMD_WANT_SUBSHELL) != 0);

  if (command->type == cm_subshell ||
      (command->flags & (CMD_WANT_SUBSHELL|CMD_FORCE_SUBSHELL)) ||
      (shell_control_structure (command->type) &&
       (pipe_out != NO_PIPE || pipe_in != NO_PIPE || asynchronous)))
    {
      pid_t paren_pid;

      /* Fork a subshell, turn off the subshell bit, turn off job
	 control and call execute_command () on the command again. */
      line_number_for_err_trap = line_number;
      paren_pid = make_child (savestring (make_command_string (command)),
			      asynchronous);
      if (paren_pid == 0)
	exit (execute_in_subshell (command, asynchronous, pipe_in, pipe_out, fds_to_close));
	/* NOTREACHED */
      else
	{
	  close_pipes (pipe_in, pipe_out);

#if defined (PROCESS_SUBSTITUTION) && defined (HAVE_DEV_FD)
	  unlink_fifo_list ();
#endif
	  /* If we are part of a pipeline, and not the end of the pipeline,
	     then we should simply return and let the last command in the
	     pipe be waited for.  If we are not in a pipeline, or are the
	     last command in the pipeline, then we wait for the subshell
	     and return its exit status as usual. */
	  if (pipe_out != NO_PIPE)
	    return (EXECUTION_SUCCESS);

	  stop_pipeline (asynchronous, (COMMAND *)NULL);

	  if (asynchronous == 0)
	    {
	      was_error_trap = signal_is_trapped (ERROR_TRAP) && signal_is_ignored (ERROR_TRAP) == 0;
	      invert = (command->flags & CMD_INVERT_RETURN) != 0;
	      ignore_return = (command->flags & CMD_IGNORE_RETURN) != 0;

	      exec_result = wait_for (paren_pid);

	      /* If we have to, invert the return value. */
	      if (invert)
		exec_result = ((exec_result == EXECUTION_SUCCESS)
				? EXECUTION_FAILURE
				: EXECUTION_SUCCESS);

	      last_command_exit_value = exec_result;
	      if (user_subshell && was_error_trap && ignore_return == 0 && invert == 0 && exec_result != EXECUTION_SUCCESS)
		{
		  save_line_number = line_number;
		  line_number = line_number_for_err_trap;
		  run_error_trap ();
		  line_number = save_line_number;
		}

	      if (user_subshell && ignore_return == 0 && invert == 0 && exit_immediately_on_error && exec_result != EXECUTION_SUCCESS)
		{
		  run_pending_traps ();
		  jump_to_top_level (ERREXIT);
		}

	      return (last_command_exit_value);
	    }
	  else
	    {
	      DESCRIBE_PID (paren_pid);

	      run_pending_traps ();

	      return (EXECUTION_SUCCESS);
	    }
	}
    }

#if defined (COMMAND_TIMING)
  if (command->flags & CMD_TIME_PIPELINE)
    {
      if (asynchronous)
	{
	  command->flags |= CMD_FORCE_SUBSHELL;
	  exec_result = execute_command_internal (command, 1, pipe_in, pipe_out, fds_to_close);
	}
      else
	{
	  exec_result = time_command (command, asynchronous, pipe_in, pipe_out, fds_to_close);
#if 0
	  if (running_trap == 0)
#endif
	    currently_executing_command = (COMMAND *)NULL;
	}
      return (exec_result);
    }
#endif /* COMMAND_TIMING */

  if (shell_control_structure (command->type) && command->redirects)
    stdin_redir = stdin_redirects (command->redirects);

  /* Handle WHILE FOR CASE etc. with redirections.  (Also '&' input
     redirection.)  */
  if (do_redirections (command->redirects, RX_ACTIVE|RX_UNDOABLE) != 0)
    {
      cleanup_redirects (redirection_undo_list);
      redirection_undo_list = (REDIRECT *)NULL;
      dispose_exec_redirects ();
      return (last_command_exit_value = EXECUTION_FAILURE);
    }

  if (redirection_undo_list)
    {
      /* XXX - why copy here? */
      my_undo_list = (REDIRECT *)copy_redirects (redirection_undo_list);
      dispose_redirects (redirection_undo_list);
      redirection_undo_list = (REDIRECT *)NULL;
    }
  else
    my_undo_list = (REDIRECT *)NULL;

  if (exec_redirection_undo_list)
    {
      /* XXX - why copy here? */
      exec_undo_list = (REDIRECT *)copy_redirects (exec_redirection_undo_list);
      dispose_redirects (exec_redirection_undo_list);
      exec_redirection_undo_list = (REDIRECT *)NULL;
    }
  else
    exec_undo_list = (REDIRECT *)NULL;

  if (my_undo_list || exec_undo_list)
    begin_unwind_frame ("loop_redirections");

  if (my_undo_list)
    add_unwind_protect ((Function *)cleanup_redirects, my_undo_list);

  if (exec_undo_list)
    add_unwind_protect ((Function *)dispose_redirects, exec_undo_list);

  ignore_return = (command->flags & CMD_IGNORE_RETURN) != 0;

  QUIT;

  switch (command->type)
    {
    case cm_simple:
      {
	save_line_number = line_number;
	/* We can't rely on variables retaining their values across a
	   call to execute_simple_command if a longjmp occurs as the
	   result of a `return' builtin.  This is true for sure with gcc. */
#if defined (RECYCLES_PIDS)
	last_made_pid = NO_PID;
#endif
	last_pid = last_made_pid;
	was_error_trap = signal_is_trapped (ERROR_TRAP) && signal_is_ignored (ERROR_TRAP) == 0;

	if (ignore_return && command->value.Simple)
	  command->value.Simple->flags |= CMD_IGNORE_RETURN;
	if (command->flags & CMD_STDIN_REDIR)
	  command->value.Simple->flags |= CMD_STDIN_REDIR;

	line_number_for_err_trap = line_number = command->value.Simple->line;
	exec_result =
	  execute_simple_command (command->value.Simple, pipe_in, pipe_out,
				  asynchronous, fds_to_close);
	line_number = save_line_number;

	/* The temporary environment should be used for only the simple
	   command immediately following its definition. */
	dispose_used_env_vars ();

#if (defined (ultrix) && defined (mips)) || defined (C_ALLOCA)
	/* Reclaim memory allocated with alloca () on machines which
	   may be using the alloca emulation code. */
	(void) alloca (0);
#endif /* (ultrix && mips) || C_ALLOCA */

	/* If we forked to do the command, then we must wait_for ()
	   the child. */

	/* XXX - this is something to watch out for if there are problems
	   when the shell is compiled without job control. */
	if (already_making_children && pipe_out == NO_PIPE &&
	    last_made_pid != last_pid)
	  {
	    stop_pipeline (asynchronous, (COMMAND *)NULL);

	    if (asynchronous)
	      {
		DESCRIBE_PID (last_made_pid);
	      }
	    else
#if !defined (JOB_CONTROL)
	      /* Do not wait for asynchronous processes started from
		 startup files. */
	    if (last_made_pid != last_asynchronous_pid)
#endif
	    /* When executing a shell function that executes other
	       commands, this causes the last simple command in
	       the function to be waited for twice.  This also causes
	       subshells forked to execute builtin commands (e.g., in
	       pipelines) to be waited for twice. */
	      exec_result = wait_for (last_made_pid);
	  }
      }

      /* 2009/02/13 -- pipeline failure is processed elsewhere.  This handles
	 only the failure of a simple command. */
      if (was_error_trap && ignore_return == 0 && invert == 0 && pipe_in == NO_PIPE && pipe_out == NO_PIPE && exec_result != EXECUTION_SUCCESS)
	{
	  last_command_exit_value = exec_result;
	  line_number = line_number_for_err_trap;
	  run_error_trap ();
	  line_number = save_line_number;
	}

      if (ignore_return == 0 && invert == 0 &&
	  ((posixly_correct && interactive == 0 && special_builtin_failed) ||
	   (exit_immediately_on_error && pipe_in == NO_PIPE && pipe_out == NO_PIPE && exec_result != EXECUTION_SUCCESS)))
	{
	  last_command_exit_value = exec_result;
	  run_pending_traps ();
	  jump_to_top_level (ERREXIT);
	}

      break;

    case cm_for:
      if (ignore_return)
	command->value.For->flags |= CMD_IGNORE_RETURN;
      exec_result = execute_for_command (command->value.For);
      break;

#if defined (ARITH_FOR_COMMAND)
    case cm_arith_for:
      if (ignore_return)
	command->value.ArithFor->flags |= CMD_IGNORE_RETURN;
      exec_result = execute_arith_for_command (command->value.ArithFor);
      break;
#endif

#if defined (SELECT_COMMAND)
    case cm_select:
      if (ignore_return)
	command->value.Select->flags |= CMD_IGNORE_RETURN;
      exec_result = execute_select_command (command->value.Select);
      break;
#endif

    case cm_case:
      if (ignore_return)
	command->value.Case->flags |= CMD_IGNORE_RETURN;
      exec_result = execute_case_command (command->value.Case);
      break;

    case cm_while:
      if (ignore_return)
	command->value.While->flags |= CMD_IGNORE_RETURN;
      exec_result = execute_while_command (command->value.While);
      break;

    case cm_until:
      if (ignore_return)
	command->value.While->flags |= CMD_IGNORE_RETURN;
      exec_result = execute_until_command (command->value.While);
      break;

    case cm_if:
      if (ignore_return)
	command->value.If->flags |= CMD_IGNORE_RETURN;
      exec_result = execute_if_command (command->value.If);
      break;

    case cm_group:

      /* This code can be executed from either of two paths: an explicit
	 '{}' command, or via a function call.  If we are executed via a
	 function call, we have already taken care of the function being
	 executed in the background (down there in execute_simple_command ()),
	 and this command should *not* be marked as asynchronous.  If we
	 are executing a regular '{}' group command, and asynchronous == 1,
	 we must want to execute the whole command in the background, so we
	 need a subshell, and we want the stuff executed in that subshell
	 (this group command) to be executed in the foreground of that
	 subshell (i.e. there will not be *another* subshell forked).

	 What we do is to force a subshell if asynchronous, and then call
	 execute_command_internal again with asynchronous still set to 1,
	 but with the original group command, so the printed command will
	 look right.

	 The code above that handles forking off subshells will note that
	 both subshell and async are on, and turn off async in the child
	 after forking the subshell (but leave async set in the parent, so
	 the normal call to describe_pid is made).  This turning off
	 async is *crucial*; if it is not done, this will fall into an
	 infinite loop of executions through this spot in subshell after
	 subshell until the process limit is exhausted. */

      if (asynchronous)
	{
	  command->flags |= CMD_FORCE_SUBSHELL;
	  exec_result =
	    execute_command_internal (command, 1, pipe_in, pipe_out,
				      fds_to_close);
	}
      else
	{
	  if (ignore_return && command->value.Group->command)
	    command->value.Group->command->flags |= CMD_IGNORE_RETURN;
	  exec_result =
	    execute_command_internal (command->value.Group->command,
				      asynchronous, pipe_in, pipe_out,
				      fds_to_close);
	}
      break;

    case cm_connection:
      exec_result = execute_connection (command, asynchronous,
					pipe_in, pipe_out, fds_to_close);
      break;

#if defined (DPAREN_ARITHMETIC)
    case cm_arith:
      was_error_trap = signal_is_trapped (ERROR_TRAP) && signal_is_ignored (ERROR_TRAP) == 0;
      if (ignore_return)
	command->value.Arith->flags |= CMD_IGNORE_RETURN;
      line_number_for_err_trap = save_line_number = line_number;
      exec_result = execute_arith_command (command->value.Arith);
      line_number = save_line_number;

      if (was_error_trap && ignore_return == 0 && invert == 0 && exec_result != EXECUTION_SUCCESS)
	{
	  last_command_exit_value = exec_result;
	  save_line_number = line_number;
	  line_number = line_number_for_err_trap;
	  run_error_trap ();
	  line_number = save_line_number;
	}

      if (ignore_return == 0 && invert == 0 && exit_immediately_on_error && exec_result != EXECUTION_SUCCESS)
	{
	  last_command_exit_value = exec_result;
	  run_pending_traps ();
	  jump_to_top_level (ERREXIT);
	}

      break;
#endif

#if defined (COND_COMMAND)
    case cm_cond:
      was_error_trap = signal_is_trapped (ERROR_TRAP) && signal_is_ignored (ERROR_TRAP) == 0;
      if (ignore_return)
	command->value.Cond->flags |= CMD_IGNORE_RETURN;

      line_number_for_err_trap = save_line_number = line_number;
      exec_result = execute_cond_command (command->value.Cond);
      line_number = save_line_number;

      if (was_error_trap && ignore_return == 0 && invert == 0 && exec_result != EXECUTION_SUCCESS)
	{
	  last_command_exit_value = exec_result;
	  save_line_number = line_number;
	  line_number = line_number_for_err_trap;
	  run_error_trap ();
	  line_number = save_line_number;
	}

      if (ignore_return == 0 && invert == 0 && exit_immediately_on_error && exec_result != EXECUTION_SUCCESS)
	{
	  last_command_exit_value = exec_result;
	  run_pending_traps ();
	  jump_to_top_level (ERREXIT);
	}

      break;
#endif
    
    case cm_function_def:
      exec_result = execute_intern_function (command->value.Function_def->name,
					     command->value.Function_def->command);
      break;

    default:
      command_error ("execute_command", CMDERR_BADTYPE, command->type, 0);
    }

  if (my_undo_list)
    {
      do_redirections (my_undo_list, RX_ACTIVE);
      dispose_redirects (my_undo_list);
    }

  if (exec_undo_list)
    dispose_redirects (exec_undo_list);

  if (my_undo_list || exec_undo_list)
    discard_unwind_frame ("loop_redirections");

  /* Invert the return value if we have to */
  if (invert)
    exec_result = (exec_result == EXECUTION_SUCCESS)
		    ? EXECUTION_FAILURE
		    : EXECUTION_SUCCESS;

#if defined (DPAREN_ARITHMETIC) || defined (COND_COMMAND)
  /* This is where we set PIPESTATUS from the exit status of the appropriate
     compound commands (the ones that look enough like simple commands to
     cause confusion).  We might be able to optimize by not doing this if
     subshell_environment != 0. */
  switch (command->type)
    {
#  if defined (DPAREN_ARITHMETIC)
    case cm_arith:
#  endif
#  if defined (COND_COMMAND)
    case cm_cond:
#  endif
      set_pipestatus_from_exit (exec_result);
      break;
    }
#endif

  last_command_exit_value = exec_result;
  run_pending_traps ();
#if 0
  if (running_trap == 0)
#endif
    currently_executing_command = (COMMAND *)NULL;
  return (last_command_exit_value);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\execute_cmd.c:528
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\execute_cmd.c:1,311
parsing error 
{
  int user_subshell, return_code, function_value, should_redir_stdin, invert;
  int ois, user_coproc;
  int result;
  volatile COMMAND *tcom;

  USE_VAR(user_subshell);
  USE_VAR(user_coproc);
  USE_VAR(invert);
  USE_VAR(tcom);
  USE_VAR(asynchronous);

  subshell_level++;
  should_redir_stdin = (asynchronous && (command->flags & CMD_STDIN_REDIR) &&
			  pipe_in == NO_PIPE &&
			  stdin_redirects (command->redirects) == 0);

  invert = (command->flags & CMD_INVERT_RETURN) != 0;
  user_subshell = command->type == cm_subshell || ((command->flags & CMD_WANT_SUBSHELL) != 0);
  user_coproc = command->type == cm_coproc;

  command->flags &= ~(CMD_FORCE_SUBSHELL | CMD_WANT_SUBSHELL | CMD_INVERT_RETURN);

  /* If a command is asynchronous in a subshell (like ( foo ) & or
     the special case of an asynchronous GROUP command where the
     the subshell bit is turned on down in case cm_group: below),
     turn off `asynchronous', so that two subshells aren't spawned.
     XXX - asynchronous used to be set to 0 in this block, but that
     means that setup_async_signals was never run.  Now it's set to
     0 after subshell_environment is set appropriately and setup_async_signals
     is run.

     This seems semantically correct to me.  For example,
     ( foo ) & seems to say ``do the command `foo' in a subshell
     environment, but don't wait for that subshell to finish'',
     and "{ foo ; bar ; } &" seems to me to be like functions or
     builtins in the background, which executed in a subshell
     environment.  I just don't see the need to fork two subshells. */

  /* Don't fork again, we are already in a subshell.  A `doubly
     async' shell is not interactive, however. */
  if (asynchronous)
    {
#if defined (JOB_CONTROL)
      /* If a construct like ( exec xxx yyy ) & is given while job
	 control is active, we want to prevent exec from putting the
	 subshell back into the original process group, carefully
	 undoing all the work we just did in make_child. */
      original_pgrp = -1;
#endif /* JOB_CONTROL */
      ois = interactive_shell;
      interactive_shell = 0;
      /* This test is to prevent alias expansion by interactive shells that
	 run `(command) &' but to allow scripts that have enabled alias
	 expansion with `shopt -s expand_alias' to continue to expand
	 aliases. */
      if (ois != interactive_shell)
	expand_aliases = 0;
    }

  /* Subshells are neither login nor interactive. */
  login_shell = interactive = 0;

  if (user_subshell)
    subshell_environment = SUBSHELL_PAREN;
  else
    {
      subshell_environment = 0;			/* XXX */
      if (asynchronous)
	subshell_environment |= SUBSHELL_ASYNC;
      if (pipe_in != NO_PIPE || pipe_out != NO_PIPE)
	subshell_environment |= SUBSHELL_PIPE;
      if (user_coproc)
	subshell_environment |= SUBSHELL_COPROC;
    }

  reset_terminating_signals ();		/* in sig.c */
  /* Cancel traps, in trap.c. */
  /* Reset the signal handlers in the child, but don't free the
     trap strings.  Set a flag noting that we have to free the
     trap strings if we run trap to change a signal disposition. */
  reset_signal_handlers ();
  subshell_environment |= SUBSHELL_RESETTRAP;

  /* Make sure restore_original_signals doesn't undo the work done by
     make_child to ensure that asynchronous children are immune to SIGINT
     and SIGQUIT.  Turn off asynchronous to make sure more subshells are
     not spawned. */
  if (asynchronous)
    {
      setup_async_signals ();
      asynchronous = 0;
    }

#if defined (JOB_CONTROL)
  set_sigchld_handler ();
#endif /* JOB_CONTROL */

  set_sigint_handler ();

#if defined (JOB_CONTROL)
  /* Delete all traces that there were any jobs running.  This is
     only for subshells. */
  without_job_control ();
#endif /* JOB_CONTROL */

  if (fds_to_close)
    close_fd_bitmap (fds_to_close);

  do_piping (pipe_in, pipe_out);

#if defined (COPROCESS_SUPPORT)
  coproc_closeall ();
#endif

  /* If this is a user subshell, set a flag if stdin was redirected.
     This is used later to decide whether to redirect fd 0 to
     /dev/null for async commands in the subshell.  This adds more
     sh compatibility, but I'm not sure it's the right thing to do. */
  if (user_subshell)
    {
      stdin_redir = stdin_redirects (command->redirects);
      restore_default_signal (0);
    }

  /* If this is an asynchronous command (command &), we want to
     redirect the standard input from /dev/null in the absence of
     any specific redirection involving stdin. */
  if (should_redir_stdin && stdin_redir == 0)
    async_redirect_stdin ();

  /* Do redirections, then dispose of them before recursive call. */
  if (command->redirects)
    {
      if (do_redirections (command->redirects, RX_ACTIVE) != 0)
	exit (invert ? EXECUTION_SUCCESS : EXECUTION_FAILURE);

      dispose_redirects (command->redirects);
      command->redirects = (REDIRECT *)NULL;
    }

  if (command->type == cm_subshell)
    tcom = command->value.Subshell->command;
  else if (user_coproc)
    tcom = command->value.Coproc->command;
  else
    tcom = command;

  if (command->flags & CMD_TIME_PIPELINE)
    tcom->flags |= CMD_TIME_PIPELINE;
  if (command->flags & CMD_TIME_POSIX)
    tcom->flags |= CMD_TIME_POSIX;
  
  /* Make sure the subshell inherits any CMD_IGNORE_RETURN flag. */
  if ((command->flags & CMD_IGNORE_RETURN) && tcom != command)
    tcom->flags |= CMD_IGNORE_RETURN;

  /* If this is a simple command, tell execute_disk_command that it
     might be able to get away without forking and simply exec.
     This means things like ( sleep 10 ) will only cause one fork.
     If we're timing the command or inverting its return value, however,
     we cannot do this optimization. */
  if ((user_subshell || user_coproc) && (tcom->type == cm_simple || tcom->type == cm_subshell) &&
      ((tcom->flags & CMD_TIME_PIPELINE) == 0) &&
      ((tcom->flags & CMD_INVERT_RETURN) == 0))
    {
      tcom->flags |= CMD_NO_FORK;
      if (tcom->type == cm_simple)
	tcom->value.Simple->flags |= CMD_NO_FORK;
    }

  invert = (tcom->flags & CMD_INVERT_RETURN) != 0;
  tcom->flags &= ~CMD_INVERT_RETURN;

  result = setjmp (top_level);

  /* If we're inside a function while executing this subshell, we
     need to handle a possible `return'. */
  function_value = 0;
  if (return_catch_flag)
    function_value = setjmp (return_catch);

  /* If we're going to exit the shell, we don't want to invert the return
     status. */
  if (result == EXITPROG)
    invert = 0, return_code = last_command_exit_value;
  else if (result)
    return_code = EXECUTION_FAILURE;
  else if (function_value)
    return_code = return_catch_value;
  else
    return_code = execute_command_internal (tcom, asynchronous, NO_PIPE, NO_PIPE, fds_to_close);

  /* If we are asked to, invert the return value. */
  if (invert)
    return_code = (return_code == EXECUTION_SUCCESS) ? EXECUTION_FAILURE
						     : EXECUTION_SUCCESS;

  /* If we were explicitly placed in a subshell with (), we need
     to do the `shell cleanup' things, such as running traps[0]. */
  if (user_subshell && signal_is_trapped (0))
    {
      last_command_exit_value = return_code;
      return_code = run_exit_trap ();
    }

  subshell_level--;
  return (return_code);
  /* NOTREACHED */
}
warning: parse error {
  int user_subshell, return_code, function_value, should_redir_stdin, invert;
  int ois, user_coproc;
  int result;
  volatile COMMAND *tcom;

  USE_VAR(user_subshell);
  USE_VAR(user_coproc);
  USE_VAR(invert);
  USE_VAR(tcom);
  USE_VAR(asynchronous);

  subshell_level++;
  should_redir_stdin = (asynchronous && (command->flags & CMD_STDIN_REDIR) &&
			  pipe_in == NO_PIPE &&
			  stdin_redirects (command->redirects) == 0);

  invert = (command->flags & CMD_INVERT_RETURN) != 0;
  user_subshell = command->type == cm_subshell || ((command->flags & CMD_WANT_SUBSHELL) != 0);
  user_coproc = command->type == cm_coproc;

  command->flags &= ~(CMD_FORCE_SUBSHELL | CMD_WANT_SUBSHELL | CMD_INVERT_RETURN);

  /* If a command is asynchronous in a subshell (like ( foo ) & or
     the special case of an asynchronous GROUP command where the
     the subshell bit is turned on down in case cm_group: below),
     turn off `asynchronous', so that two subshells aren't spawned.
     XXX - asynchronous used to be set to 0 in this block, but that
     means that setup_async_signals was never run.  Now it's set to
     0 after subshell_environment is set appropriately and setup_async_signals
     is run.

     This seems semantically correct to me.  For example,
     ( foo ) & seems to say ``do the command `foo' in a subshell
     environment, but don't wait for that subshell to finish'',
     and "{ foo ; bar ; } &" seems to me to be like functions or
     builtins in the background, which executed in a subshell
     environment.  I just don't see the need to fork two subshells. */

  /* Don't fork again, we are already in a subshell.  A `doubly
     async' shell is not interactive, however. */
  if (asynchronous)
    {
#if defined (JOB_CONTROL)
      /* If a construct like ( exec xxx yyy ) & is given while job
	 control is active, we want to prevent exec from putting the
	 subshell back into the original process group, carefully
	 undoing all the work we just did in make_child. */
      original_pgrp = -1;
#endif /* JOB_CONTROL */
      ois = interactive_shell;
      interactive_shell = 0;
      /* This test is to prevent alias expansion by interactive shells that
	 run `(command) &' but to allow scripts that have enabled alias
	 expansion with `shopt -s expand_alias' to continue to expand
	 aliases. */
      if (ois != interactive_shell)
	expand_aliases = 0;
    }

  /* Subshells are neither login nor interactive. */
  login_shell = interactive = 0;

  if (user_subshell)
    subshell_environment = SUBSHELL_PAREN;
  else
    {
      subshell_environment = 0;			/* XXX */
      if (asynchronous)
	subshell_environment |= SUBSHELL_ASYNC;
      if (pipe_in != NO_PIPE || pipe_out != NO_PIPE)
	subshell_environment |= SUBSHELL_PIPE;
      if (user_coproc)
	subshell_environment |= SUBSHELL_COPROC;
    }

  reset_terminating_signals ();		/* in sig.c */
  /* Cancel traps, in trap.c. */
  /* Reset the signal handlers in the child, but don't free the
     trap strings.  Set a flag noting that we have to free the
     trap strings if we run trap to change a signal disposition. */
  reset_signal_handlers ();
  subshell_environment |= SUBSHELL_RESETTRAP;

  /* Make sure restore_original_signals doesn't undo the work done by
     make_child to ensure that asynchronous children are immune to SIGINT
     and SIGQUIT.  Turn off asynchronous to make sure more subshells are
     not spawned. */
  if (asynchronous)
    {
      setup_async_signals ();
      asynchronous = 0;
    }

#if defined (JOB_CONTROL)
  set_sigchld_handler ();
#endif /* JOB_CONTROL */

  set_sigint_handler ();

#if defined (JOB_CONTROL)
  /* Delete all traces that there were any jobs running.  This is
     only for subshells. */
  without_job_control ();
#endif /* JOB_CONTROL */

  if (fds_to_close)
    close_fd_bitmap (fds_to_close);

  do_piping (pipe_in, pipe_out);

#if defined (COPROCESS_SUPPORT)
  coproc_closeall ();
#endif

  /* If this is a user subshell, set a flag if stdin was redirected.
     This is used later to decide whether to redirect fd 0 to
     /dev/null for async commands in the subshell.  This adds more
     sh compatibility, but I'm not sure it's the right thing to do. */
  if (user_subshell)
    {
      stdin_redir = stdin_redirects (command->redirects);
      restore_default_signal (0);
    }

  /* If this is an asynchronous command (command &), we want to
     redirect the standard input from /dev/null in the absence of
     any specific redirection involving stdin. */
  if (should_redir_stdin && stdin_redir == 0)
    async_redirect_stdin ();

  /* Do redirections, then dispose of them before recursive call. */
  if (command->redirects)
    {
      if (do_redirections (command->redirects, RX_ACTIVE) != 0)
	exit (invert ? EXECUTION_SUCCESS : EXECUTION_FAILURE);

      dispose_redirects (command->redirects);
      command->redirects = (REDIRECT *)NULL;
    }

  if (command->type == cm_subshell)
    tcom = command->value.Subshell->command;
  else if (user_coproc)
    tcom = command->value.Coproc->command;
  else
    tcom = command;

  if (command->flags & CMD_TIME_PIPELINE)
    tcom->flags |= CMD_TIME_PIPELINE;
  if (command->flags & CMD_TIME_POSIX)
    tcom->flags |= CMD_TIME_POSIX;
  
  /* Make sure the subshell inherits any CMD_IGNORE_RETURN flag. */
  if ((command->flags & CMD_IGNORE_RETURN) && tcom != command)
    tcom->flags |= CMD_IGNORE_RETURN;

  /* If this is a simple command, tell execute_disk_command that it
     might be able to get away without forking and simply exec.
     This means things like ( sleep 10 ) will only cause one fork.
     If we're timing the command or inverting its return value, however,
     we cannot do this optimization. */
  if ((user_subshell || user_coproc) && (tcom->type == cm_simple || tcom->type == cm_subshell) &&
      ((tcom->flags & CMD_TIME_PIPELINE) == 0) &&
      ((tcom->flags & CMD_INVERT_RETURN) == 0))
    {
      tcom->flags |= CMD_NO_FORK;
      if (tcom->type == cm_simple)
	tcom->value.Simple->flags |= CMD_NO_FORK;
    }

  invert = (tcom->flags & CMD_INVERT_RETURN) != 0;
  tcom->flags &= ~CMD_INVERT_RETURN;

  result = setjmp (top_level);

  /* If we're inside a function while executing this subshell, we
     need to handle a possible `return'. */
  function_value = 0;
  if (return_catch_flag)
    function_value = setjmp (return_catch);

  /* If we're going to exit the shell, we don't want to invert the return
     status. */
  if (result == EXITPROG)
    invert = 0, return_code = last_command_exit_value;
  else if (result)
    return_code = EXECUTION_FAILURE;
  else if (function_value)
    return_code = return_catch_value;
  else
    return_code = execute_command_internal (tcom, asynchronous, NO_PIPE, NO_PIPE, fds_to_close);

  /* If we are asked to, invert the return value. */
  if (invert)
    return_code = (return_code == EXECUTION_SUCCESS) ? EXECUTION_FAILURE
						     : EXECUTION_SUCCESS;

  /* If we were explicitly placed in a subshell with (), we need
     to do the `shell cleanup' things, such as running traps[0]. */
  if (user_subshell && signal_is_trapped (0))
    {
      last_command_exit_value = return_code;
      return_code = run_exit_trap ();
    }

  subshell_level--;
  return (return_code);
  /* NOTREACHED */
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\execute_cmd.c:1,316
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\execute_cmd.c:2,078
parsing error 
{
  dup2 (s, 0);
  close (s);
}
warning: parse error {
  dup2 (s, 0);
  close (s);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\execute_cmd.c:2,080
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\execute_cmd.c:2,087
parsing error 
{
  unfreeze_jobs_list ();
}
warning: parse error {
  unfreeze_jobs_list ();
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\execute_cmd.c:2,089
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\execute_cmd.c:2,094
parsing error 
{
  int prev, fildes[2], new_bitmap_size, dummyfd, ignore_return, exec_result;
  int lstdin, lastpipe_flag, lastpipe_jid;
  COMMAND *cmd;
  struct fd_bitmap *fd_bitmap;
  pid_t lastpid;

#if defined (JOB_CONTROL)
  sigset_t set, oset;
  BLOCK_CHILD (set, oset);
#endif /* JOB_CONTROL */

  ignore_return = (command->flags & CMD_IGNORE_RETURN) != 0;

  prev = pipe_in;
  cmd = command;

  while (cmd && cmd->type == cm_connection &&
	 cmd->value.Connection && cmd->value.Connection->connector == '|')
    {
      /* Make a pipeline between the two commands. */
      if (pipe (fildes) < 0)
	{
	  sys_error (_("pipe error"));
#if defined (JOB_CONTROL)
	  terminate_current_pipeline ();
	  kill_current_pipeline ();
	  UNBLOCK_CHILD (oset);
#endif /* JOB_CONTROL */
	  last_command_exit_value = EXECUTION_FAILURE;
	  /* The unwind-protects installed below will take care
	     of closing all of the open file descriptors. */
	  throw_to_top_level ();
	  return (EXECUTION_FAILURE);	/* XXX */
	}

      /* Here is a problem: with the new file close-on-exec
	 code, the read end of the pipe (fildes[0]) stays open
	 in the first process, so that process will never get a
	 SIGPIPE.  There is no way to signal the first process
	 that it should close fildes[0] after forking, so it
	 remains open.  No SIGPIPE is ever sent because there
	 is still a file descriptor open for reading connected
	 to the pipe.  We take care of that here.  This passes
	 around a bitmap of file descriptors that must be
	 closed after making a child process in execute_simple_command. */

      /* We need fd_bitmap to be at least as big as fildes[0].
	 If fildes[0] is less than fds_to_close->size, then
	 use fds_to_close->size. */
      new_bitmap_size = (fildes[0] < fds_to_close->size)
				? fds_to_close->size
				: fildes[0] + 8;

      fd_bitmap = new_fd_bitmap (new_bitmap_size);

      /* Now copy the old information into the new bitmap. */
      xbcopy ((char *)fds_to_close->bitmap, (char *)fd_bitmap->bitmap, fds_to_close->size);

      /* And mark the pipe file descriptors to be closed. */
      fd_bitmap->bitmap[fildes[0]] = 1;

      /* In case there are pipe or out-of-processes errors, we
	 want all these file descriptors to be closed when
	 unwind-protects are run, and the storage used for the
	 bitmaps freed up. */
      begin_unwind_frame ("pipe-file-descriptors");
      add_unwind_protect (dispose_fd_bitmap, fd_bitmap);
      add_unwind_protect (close_fd_bitmap, fd_bitmap);
      if (prev >= 0)
	add_unwind_protect (close, prev);
      dummyfd = fildes[1];
      add_unwind_protect (close, dummyfd);

#if defined (JOB_CONTROL)
      add_unwind_protect (restore_signal_mask, &oset);
#endif /* JOB_CONTROL */

      if (ignore_return && cmd->value.Connection->first)
	cmd->value.Connection->first->flags |= CMD_IGNORE_RETURN;
      execute_command_internal (cmd->value.Connection->first, asynchronous,
				prev, fildes[1], fd_bitmap);

      if (prev >= 0)
	close (prev);

      prev = fildes[0];
      close (fildes[1]);

      dispose_fd_bitmap (fd_bitmap);
      discard_unwind_frame ("pipe-file-descriptors");

      cmd = cmd->value.Connection->second;
    }

  lastpid = last_made_pid;

  /* Now execute the rightmost command in the pipeline.  */
  if (ignore_return && cmd)
    cmd->flags |= CMD_IGNORE_RETURN;

  lastpipe_flag = 0;
  begin_unwind_frame ("lastpipe-exec");
  lstdin = -1;
  /* If the `lastpipe' option is set with shopt, and job control is not
     enabled, execute the last element of non-async pipelines in the
     current shell environment. */
  if (lastpipe_opt && job_control == 0 && asynchronous == 0 && pipe_out == NO_PIPE && prev > 0)
    {
      lstdin = move_to_high_fd (0, 0, 255);
      if (lstdin > 0)
	{
	  do_piping (prev, pipe_out);
	  prev = NO_PIPE;
	  add_unwind_protect (restore_stdin, lstdin);
	  lastpipe_flag = 1;
	  freeze_jobs_list ();
	  lastpipe_jid = stop_pipeline (0, (COMMAND *)NULL);	/* XXX */
	  add_unwind_protect (lastpipe_cleanup, lastpipe_jid);
	}
      cmd->flags |= CMD_LASTPIPE;
    }	  
  if (prev >= 0)
    add_unwind_protect (close, prev);

  exec_result = execute_command_internal (cmd, asynchronous, prev, pipe_out, fds_to_close);

  if (lstdin > 0)
    restore_stdin (lstdin);

  if (prev >= 0)
    close (prev);

#if defined (JOB_CONTROL)
  UNBLOCK_CHILD (oset);
#endif

  QUIT;

  if (lastpipe_flag)
    {
#if defined (JOB_CONTROL)
      append_process (savestring (the_printed_command), dollar_dollar_pid, exec_result, lastpipe_jid);
#endif
      lstdin = wait_for (lastpid);
#if defined (JOB_CONTROL)
      exec_result = job_exit_status (lastpipe_jid);
#endif
      unfreeze_jobs_list ();
    }

  discard_unwind_frame ("lastpipe-exec");

  return (exec_result);
}
warning: parse error {
  int prev, fildes[2], new_bitmap_size, dummyfd, ignore_return, exec_result;
  int lstdin, lastpipe_flag, lastpipe_jid;
  COMMAND *cmd;
  struct fd_bitmap *fd_bitmap;
  pid_t lastpid;

#if defined (JOB_CONTROL)
  sigset_t set, oset;
  BLOCK_CHILD (set, oset);
#endif /* JOB_CONTROL */

  ignore_return = (command->flags & CMD_IGNORE_RETURN) != 0;

  prev = pipe_in;
  cmd = command;

  while (cmd && cmd->type == cm_connection &&
	 cmd->value.Connection && cmd->value.Connection->connector == '|')
    {
      /* Make a pipeline between the two commands. */
      if (pipe (fildes) < 0)
	{
	  sys_error (_("pipe error"));
#if defined (JOB_CONTROL)
	  terminate_current_pipeline ();
	  kill_current_pipeline ();
	  UNBLOCK_CHILD (oset);
#endif /* JOB_CONTROL */
	  last_command_exit_value = EXECUTION_FAILURE;
	  /* The unwind-protects installed below will take care
	     of closing all of the open file descriptors. */
	  throw_to_top_level ();
	  return (EXECUTION_FAILURE);	/* XXX */
	}

      /* Here is a problem: with the new file close-on-exec
	 code, the read end of the pipe (fildes[0]) stays open
	 in the first process, so that process will never get a
	 SIGPIPE.  There is no way to signal the first process
	 that it should close fildes[0] after forking, so it
	 remains open.  No SIGPIPE is ever sent because there
	 is still a file descriptor open for reading connected
	 to the pipe.  We take care of that here.  This passes
	 around a bitmap of file descriptors that must be
	 closed after making a child process in execute_simple_command. */

      /* We need fd_bitmap to be at least as big as fildes[0].
	 If fildes[0] is less than fds_to_close->size, then
	 use fds_to_close->size. */
      new_bitmap_size = (fildes[0] < fds_to_close->size)
				? fds_to_close->size
				: fildes[0] + 8;

      fd_bitmap = new_fd_bitmap (new_bitmap_size);

      /* Now copy the old information into the new bitmap. */
      xbcopy ((char *)fds_to_close->bitmap, (char *)fd_bitmap->bitmap, fds_to_close->size);

      /* And mark the pipe file descriptors to be closed. */
      fd_bitmap->bitmap[fildes[0]] = 1;

      /* In case there are pipe or out-of-processes errors, we
	 want all these file descriptors to be closed when
	 unwind-protects are run, and the storage used for the
	 bitmaps freed up. */
      begin_unwind_frame ("pipe-file-descriptors");
      add_unwind_protect (dispose_fd_bitmap, fd_bitmap);
      add_unwind_protect (close_fd_bitmap, fd_bitmap);
      if (prev >= 0)
	add_unwind_protect (close, prev);
      dummyfd = fildes[1];
      add_unwind_protect (close, dummyfd);

#if defined (JOB_CONTROL)
      add_unwind_protect (restore_signal_mask, &oset);
#endif /* JOB_CONTROL */

      if (ignore_return && cmd->value.Connection->first)
	cmd->value.Connection->first->flags |= CMD_IGNORE_RETURN;
      execute_command_internal (cmd->value.Connection->first, asynchronous,
				prev, fildes[1], fd_bitmap);

      if (prev >= 0)
	close (prev);

      prev = fildes[0];
      close (fildes[1]);

      dispose_fd_bitmap (fd_bitmap);
      discard_unwind_frame ("pipe-file-descriptors");

      cmd = cmd->value.Connection->second;
    }

  lastpid = last_made_pid;

  /* Now execute the rightmost command in the pipeline.  */
  if (ignore_return && cmd)
    cmd->flags |= CMD_IGNORE_RETURN;

  lastpipe_flag = 0;
  begin_unwind_frame ("lastpipe-exec");
  lstdin = -1;
  /* If the `lastpipe' option is set with shopt, and job control is not
     enabled, execute the last element of non-async pipelines in the
     current shell environment. */
  if (lastpipe_opt && job_control == 0 && asynchronous == 0 && pipe_out == NO_PIPE && prev > 0)
    {
      lstdin = move_to_high_fd (0, 0, 255);
      if (lstdin > 0)
	{
	  do_piping (prev, pipe_out);
	  prev = NO_PIPE;
	  add_unwind_protect (restore_stdin, lstdin);
	  lastpipe_flag = 1;
	  freeze_jobs_list ();
	  lastpipe_jid = stop_pipeline (0, (COMMAND *)NULL);	/* XXX */
	  add_unwind_protect (lastpipe_cleanup, lastpipe_jid);
	}
      cmd->flags |= CMD_LASTPIPE;
    }	  
  if (prev >= 0)
    add_unwind_protect (close, prev);

  exec_result = execute_command_internal (cmd, asynchronous, prev, pipe_out, fds_to_close);

  if (lstdin > 0)
    restore_stdin (lstdin);

  if (prev >= 0)
    close (prev);

#if defined (JOB_CONTROL)
  UNBLOCK_CHILD (oset);
#endif

  QUIT;

  if (lastpipe_flag)
    {
#if defined (JOB_CONTROL)
      append_process (savestring (the_printed_command), dollar_dollar_pid, exec_result, lastpipe_jid);
#endif
      lstdin = wait_for (lastpid);
#if defined (JOB_CONTROL)
      exec_result = job_exit_status (lastpipe_jid);
#endif
      unfreeze_jobs_list ();
    }

  discard_unwind_frame ("lastpipe-exec");

  return (exec_result);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\execute_cmd.c:2,098
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\execute_cmd.c:2,255
parsing error 
{
  COMMAND *tc, *second;
  int ignore_return, exec_result, was_error_trap, invert;
  volatile int save_line_number;

  ignore_return = (command->flags & CMD_IGNORE_RETURN) != 0;

  switch (command->value.Connection->connector)
    {
    /* Do the first command asynchronously. */
    case '&':
      tc = command->value.Connection->first;
      if (tc == 0)
	return (EXECUTION_SUCCESS);

      if (ignore_return)
	tc->flags |= CMD_IGNORE_RETURN;
      tc->flags |= CMD_AMPERSAND;

      /* If this shell was compiled without job control support,
	 if we are currently in a subshell via `( xxx )', or if job
	 control is not active then the standard input for an
	 asynchronous command is forced to /dev/null. */
#if defined (JOB_CONTROL)
      if ((subshell_environment || !job_control) && !stdin_redir)
#else
      if (!stdin_redir)
#endif /* JOB_CONTROL */
	tc->flags |= CMD_STDIN_REDIR;

      exec_result = execute_command_internal (tc, 1, pipe_in, pipe_out, fds_to_close);
      QUIT;

      if (tc->flags & CMD_STDIN_REDIR)
	tc->flags &= ~CMD_STDIN_REDIR;

      second = command->value.Connection->second;
      if (second)
	{
	  if (ignore_return)
	    second->flags |= CMD_IGNORE_RETURN;

	  exec_result = execute_command_internal (second, asynchronous, pipe_in, pipe_out, fds_to_close);
	}

      break;

    /* Just call execute command on both sides. */
    case ';':
      if (ignore_return)
	{
	  if (command->value.Connection->first)
	    command->value.Connection->first->flags |= CMD_IGNORE_RETURN;
	  if (command->value.Connection->second)
	    command->value.Connection->second->flags |= CMD_IGNORE_RETURN;
	}
      executing_list++;
      QUIT;
      execute_command (command->value.Connection->first);
      QUIT;
      exec_result = execute_command_internal (command->value.Connection->second,
				      asynchronous, pipe_in, pipe_out,
				      fds_to_close);
      executing_list--;
      break;

    case '|':
      was_error_trap = signal_is_trapped (ERROR_TRAP) && signal_is_ignored (ERROR_TRAP) == 0;
      invert = (command->flags & CMD_INVERT_RETURN) != 0;
      ignore_return = (command->flags & CMD_IGNORE_RETURN) != 0;

      line_number_for_err_trap = line_number;
      exec_result = execute_pipeline (command, asynchronous, pipe_in, pipe_out, fds_to_close);

      if (was_error_trap && ignore_return == 0 && invert == 0 && exec_result != EXECUTION_SUCCESS)
	{
	  last_command_exit_value = exec_result;
	  save_line_number = line_number;
	  line_number = line_number_for_err_trap;
	  run_error_trap ();
	  line_number = save_line_number;
	}

      if (ignore_return == 0 && invert == 0 && exit_immediately_on_error && exec_result != EXECUTION_SUCCESS)
	{
	  last_command_exit_value = exec_result;
	  run_pending_traps ();
	  jump_to_top_level (ERREXIT);
	}

      break;

    case AND_AND:
    case OR_OR:
      if (asynchronous)
	{
	  /* If we have something like `a && b &' or `a || b &', run the
	     && or || stuff in a subshell.  Force a subshell and just call
	     execute_command_internal again.  Leave asynchronous on
	     so that we get a report from the parent shell about the
	     background job. */
	  command->flags |= CMD_FORCE_SUBSHELL;
	  exec_result = execute_command_internal (command, 1, pipe_in, pipe_out, fds_to_close);
	  break;
	}

      /* Execute the first command.  If the result of that is successful
	 and the connector is AND_AND, or the result is not successful
	 and the connector is OR_OR, then execute the second command,
	 otherwise return. */

      executing_list++;
      if (command->value.Connection->first)
	command->value.Connection->first->flags |= CMD_IGNORE_RETURN;

      exec_result = execute_command (command->value.Connection->first);
      QUIT;
      if (((command->value.Connection->connector == AND_AND) &&
	   (exec_result == EXECUTION_SUCCESS)) ||
	  ((command->value.Connection->connector == OR_OR) &&
	   (exec_result != EXECUTION_SUCCESS)))
	{
	  if (ignore_return && command->value.Connection->second)
	    command->value.Connection->second->flags |= CMD_IGNORE_RETURN;

	  exec_result = execute_command (command->value.Connection->second);
	}
      executing_list--;
      break;

    default:
      command_error ("execute_connection", CMDERR_BADCONN, command->value.Connection->connector, 0);
      jump_to_top_level (DISCARD);
      exec_result = EXECUTION_FAILURE;
    }

  return exec_result;
}
warning: parse error {
  COMMAND *tc, *second;
  int ignore_return, exec_result, was_error_trap, invert;
  volatile int save_line_number;

  ignore_return = (command->flags & CMD_IGNORE_RETURN) != 0;

  switch (command->value.Connection->connector)
    {
    /* Do the first command asynchronously. */
    case '&':
      tc = command->value.Connection->first;
      if (tc == 0)
	return (EXECUTION_SUCCESS);

      if (ignore_return)
	tc->flags |= CMD_IGNORE_RETURN;
      tc->flags |= CMD_AMPERSAND;

      /* If this shell was compiled without job control support,
	 if we are currently in a subshell via `( xxx )', or if job
	 control is not active then the standard input for an
	 asynchronous command is forced to /dev/null. */
#if defined (JOB_CONTROL)
      if ((subshell_environment || !job_control) && !stdin_redir)
#else
      if (!stdin_redir)
#endif /* JOB_CONTROL */
	tc->flags |= CMD_STDIN_REDIR;

      exec_result = execute_command_internal (tc, 1, pipe_in, pipe_out, fds_to_close);
      QUIT;

      if (tc->flags & CMD_STDIN_REDIR)
	tc->flags &= ~CMD_STDIN_REDIR;

      second = command->value.Connection->second;
      if (second)
	{
	  if (ignore_return)
	    second->flags |= CMD_IGNORE_RETURN;

	  exec_result = execute_command_internal (second, asynchronous, pipe_in, pipe_out, fds_to_close);
	}

      break;

    /* Just call execute command on both sides. */
    case ';':
      if (ignore_return)
	{
	  if (command->value.Connection->first)
	    command->value.Connection->first->flags |= CMD_IGNORE_RETURN;
	  if (command->value.Connection->second)
	    command->value.Connection->second->flags |= CMD_IGNORE_RETURN;
	}
      executing_list++;
      QUIT;
      execute_command (command->value.Connection->first);
      QUIT;
      exec_result = execute_command_internal (command->value.Connection->second,
				      asynchronous, pipe_in, pipe_out,
				      fds_to_close);
      executing_list--;
      break;

    case '|':
      was_error_trap = signal_is_trapped (ERROR_TRAP) && signal_is_ignored (ERROR_TRAP) == 0;
      invert = (command->flags & CMD_INVERT_RETURN) != 0;
      ignore_return = (command->flags & CMD_IGNORE_RETURN) != 0;

      line_number_for_err_trap = line_number;
      exec_result = execute_pipeline (command, asynchronous, pipe_in, pipe_out, fds_to_close);

      if (was_error_trap && ignore_return == 0 && invert == 0 && exec_result != EXECUTION_SUCCESS)
	{
	  last_command_exit_value = exec_result;
	  save_line_number = line_number;
	  line_number = line_number_for_err_trap;
	  run_error_trap ();
	  line_number = save_line_number;
	}

      if (ignore_return == 0 && invert == 0 && exit_immediately_on_error && exec_result != EXECUTION_SUCCESS)
	{
	  last_command_exit_value = exec_result;
	  run_pending_traps ();
	  jump_to_top_level (ERREXIT);
	}

      break;

    case AND_AND:
    case OR_OR:
      if (asynchronous)
	{
	  /* If we have something like `a && b &' or `a || b &', run the
	     && or || stuff in a subshell.  Force a subshell and just call
	     execute_command_internal again.  Leave asynchronous on
	     so that we get a report from the parent shell about the
	     background job. */
	  command->flags |= CMD_FORCE_SUBSHELL;
	  exec_result = execute_command_internal (command, 1, pipe_in, pipe_out, fds_to_close);
	  break;
	}

      /* Execute the first command.  If the result of that is successful
	 and the connector is AND_AND, or the result is not successful
	 and the connector is OR_OR, then execute the second command,
	 otherwise return. */

      executing_list++;
      if (command->value.Connection->first)
	command->value.Connection->first->flags |= CMD_IGNORE_RETURN;

      exec_result = execute_command (command->value.Connection->first);
      QUIT;
      if (((command->value.Connection->connector == AND_AND) &&
	   (exec_result == EXECUTION_SUCCESS)) ||
	  ((command->value.Connection->connector == OR_OR) &&
	   (exec_result != EXECUTION_SUCCESS)))
	{
	  if (ignore_return && command->value.Connection->second)
	    command->value.Connection->second->flags |= CMD_IGNORE_RETURN;

	  exec_result = execute_command (command->value.Connection->second);
	}
      executing_list--;
      break;

    default:
      command_error ("execute_connection", CMDERR_BADCONN, command->value.Connection->connector, 0);
      jump_to_top_level (DISCARD);
      exec_result = EXECUTION_FAILURE;
    }

  return exec_result;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\execute_cmd.c:2,259
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\execute_cmd.c:2,409
parsing error 
{
  register WORD_LIST *releaser, *list;
  SHELL_VAR *v;
  char *identifier;
  int retval, save_line_number;
#if 0
  SHELL_VAR *old_value = (SHELL_VAR *)NULL; /* Remember the old value of x. */
#endif

  save_line_number = line_number;
  if (check_identifier (for_command->name, 1) == 0)
    {
      if (posixly_correct && interactive_shell == 0)
	{
	  last_command_exit_value = EX_BADUSAGE;
	  jump_to_top_level (ERREXIT);
	}
      return (EXECUTION_FAILURE);
    }

  loop_level++;
  identifier = for_command->name->word;

  list = releaser = expand_words_no_vars (for_command->map_list);

  begin_unwind_frame ("for");
  add_unwind_protect (dispose_words, releaser);

#if 0
  if (lexical_scoping)
    {
      old_value = copy_variable (find_variable (identifier));
      if (old_value)
	add_unwind_protect (dispose_variable, old_value);
    }
#endif

  if (for_command->flags & CMD_IGNORE_RETURN)
    for_command->action->flags |= CMD_IGNORE_RETURN;

  for (retval = EXECUTION_SUCCESS; list; list = list->next)
    {
      QUIT;

      line_number = for_command->line;

      /* Remember what this command looks like, for debugger. */
      command_string_index = 0;
      print_for_command_head (for_command);

      if (echo_command_at_execute)
	xtrace_print_for_command_head (for_command);

      /* Save this command unless it's a trap command and we're not running
	 a debug trap. */
#if 0
      if (signal_in_progress (DEBUG_TRAP) == 0 && (this_command_name == 0 || (STREQ (this_command_name, "trap") == 0)))
#else
      if (signal_in_progress (DEBUG_TRAP) == 0 && running_trap == 0)
#endif
	{
	  FREE (the_printed_command_except_trap);
	  the_printed_command_except_trap = savestring (the_printed_command);
	}

      retval = run_debug_trap ();
#if defined (DEBUGGER)
      /* In debugging mode, if the DEBUG trap returns a non-zero status, we
	 skip the command. */
      if (debugging_mode && retval != EXECUTION_SUCCESS)
        continue;
#endif

      this_command_name = (char *)NULL;
      v = bind_variable (identifier, list->word->word, 0);
      if (readonly_p (v) || noassign_p (v))
	{
	  line_number = save_line_number;
	  if (readonly_p (v) && interactive_shell == 0 && posixly_correct)
	    {
	      last_command_exit_value = EXECUTION_FAILURE;
	      jump_to_top_level (FORCE_EOF);
	    }
	  else
	    {
	      dispose_words (releaser);
	      discard_unwind_frame ("for");
	      loop_level--;
	      return (EXECUTION_FAILURE);
	    }
	}
      retval = execute_command (for_command->action);
      REAP ();
      QUIT;

      if (breaking)
	{
	  breaking--;
	  break;
	}

      if (continuing)
	{
	  continuing--;
	  if (continuing)
	    break;
	}
    }

  loop_level--;
  line_number = save_line_number;

#if 0
  if (lexical_scoping)
    {
      if (!old_value)
        unbind_variable (identifier);
      else
	{
	  SHELL_VAR *new_value;

	  new_value = bind_variable (identifier, value_cell(old_value), 0);
	  new_value->attributes = old_value->attributes;
	  dispose_variable (old_value);
	}
    }
#endif

  dispose_words (releaser);
  discard_unwind_frame ("for");
  return (retval);
}
warning: parse error {
  register WORD_LIST *releaser, *list;
  SHELL_VAR *v;
  char *identifier;
  int retval, save_line_number;
#if 0
  SHELL_VAR *old_value = (SHELL_VAR *)NULL; /* Remember the old value of x. */
#endif

  save_line_number = line_number;
  if (check_identifier (for_command->name, 1) == 0)
    {
      if (posixly_correct && interactive_shell == 0)
	{
	  last_command_exit_value = EX_BADUSAGE;
	  jump_to_top_level (ERREXIT);
	}
      return (EXECUTION_FAILURE);
    }

  loop_level++;
  identifier = for_command->name->word;

  list = releaser = expand_words_no_vars (for_command->map_list);

  begin_unwind_frame ("for");
  add_unwind_protect (dispose_words, releaser);

#if 0
  if (lexical_scoping)
    {
      old_value = copy_variable (find_variable (identifier));
      if (old_value)
	add_unwind_protect (dispose_variable, old_value);
    }
#endif

  if (for_command->flags & CMD_IGNORE_RETURN)
    for_command->action->flags |= CMD_IGNORE_RETURN;

  for (retval = EXECUTION_SUCCESS; list; list = list->next)
    {
      QUIT;

      line_number = for_command->line;

      /* Remember what this command looks like, for debugger. */
      command_string_index = 0;
      print_for_command_head (for_command);

      if (echo_command_at_execute)
	xtrace_print_for_command_head (for_command);

      /* Save this command unless it's a trap command and we're not running
	 a debug trap. */
#if 0
      if (signal_in_progress (DEBUG_TRAP) == 0 && (this_command_name == 0 || (STREQ (this_command_name, "trap") == 0)))
#else
      if (signal_in_progress (DEBUG_TRAP) == 0 && running_trap == 0)
#endif
	{
	  FREE (the_printed_command_except_trap);
	  the_printed_command_except_trap = savestring (the_printed_command);
	}

      retval = run_debug_trap ();
#if defined (DEBUGGER)
      /* In debugging mode, if the DEBUG trap returns a non-zero status, we
	 skip the command. */
      if (debugging_mode && retval != EXECUTION_SUCCESS)
        continue;
#endif

      this_command_name = (char *)NULL;
      v = bind_variable (identifier, list->word->word, 0);
      if (readonly_p (v) || noassign_p (v))
	{
	  line_number = save_line_number;
	  if (readonly_p (v) && interactive_shell == 0 && posixly_correct)
	    {
	      last_command_exit_value = EXECUTION_FAILURE;
	      jump_to_top_level (FORCE_EOF);
	    }
	  else
	    {
	      dispose_words (releaser);
	      discard_unwind_frame ("for");
	      loop_level--;
	      return (EXECUTION_FAILURE);
	    }
	}
      retval = execute_command (for_command->action);
      REAP ();
      QUIT;

      if (breaking)
	{
	  breaking--;
	  break;
	}

      if (continuing)
	{
	  continuing--;
	  if (continuing)
	    break;
	}
    }

  loop_level--;
  line_number = save_line_number;

#if 0
  if (lexical_scoping)
    {
      if (!old_value)
        unbind_variable (identifier);
      else
	{
	  SHELL_VAR *new_value;

	  new_value = bind_variable (identifier, value_cell(old_value), 0);
	  new_value->attributes = old_value->attributes;
	  dispose_variable (old_value);
	}
    }
#endif

  dispose_words (releaser);
  discard_unwind_frame ("for");
  return (retval);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\execute_cmd.c:2,411
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\execute_cmd.c:3,031
parsing error 
{
  register WORD_LIST *list;
  WORD_LIST *wlist, *es;
  PATTERN_LIST *clauses;
  char *word, *pattern;
  int retval, match, ignore_return, save_line_number;

  save_line_number = line_number;
  line_number = case_command->line;

  command_string_index = 0;
  print_case_command_head (case_command);

  if (echo_command_at_execute)
    xtrace_print_case_command_head (case_command);

#if 0
  if (signal_in_progress (DEBUG_TRAP) == 0 && (this_command_name == 0 || (STREQ (this_command_name, "trap") == 0)))
#else
  if (signal_in_progress (DEBUG_TRAP) == 0 && running_trap == 0)
#endif
    {
      FREE (the_printed_command_except_trap);
      the_printed_command_except_trap = savestring (the_printed_command);
    }

  retval = run_debug_trap();
#if defined (DEBUGGER)
  /* In debugging mode, if the DEBUG trap returns a non-zero status, we
     skip the command. */
  if (debugging_mode && retval != EXECUTION_SUCCESS)
    {
      line_number = save_line_number;
      return (EXECUTION_SUCCESS);
    }
#endif

  wlist = expand_word_unsplit (case_command->word, 0);
  word = wlist ? string_list (wlist) : savestring ("");
  dispose_words (wlist);

  retval = EXECUTION_SUCCESS;
  ignore_return = case_command->flags & CMD_IGNORE_RETURN;

  begin_unwind_frame ("case");
  add_unwind_protect ((Function *)xfree, word);

#define EXIT_CASE()  goto exit_case_command

  for (clauses = case_command->clauses; clauses; clauses = clauses->next)
    {
      QUIT;
      for (list = clauses->patterns; list; list = list->next)
	{
	  es = expand_word_leave_quoted (list->word, 0);

	  if (es && es->word && es->word->word && *(es->word->word))
	    pattern = quote_string_for_globbing (es->word->word, QGLOB_CVTNULL);
	  else
	    {
	      pattern = (char *)xmalloc (1);
	      pattern[0] = '\0';
	    }

	  /* Since the pattern does not undergo quote removal (as per
	     Posix.2, section 3.9.4.3), the strmatch () call must be able
	     to recognize backslashes as escape characters. */
	  match = strmatch (pattern, word, FNMATCH_EXTFLAG|FNMATCH_IGNCASE) != FNM_NOMATCH;
	  free (pattern);

	  dispose_words (es);

	  if (match)
	    {
	      do
		{
		  if (clauses->action && ignore_return)
		    clauses->action->flags |= CMD_IGNORE_RETURN;
		  retval = execute_command (clauses->action);
		}
	      while ((clauses->flags & CASEPAT_FALLTHROUGH) && (clauses = clauses->next));
	      if (clauses == 0 || (clauses->flags & CASEPAT_TESTNEXT) == 0)
		EXIT_CASE ();
	      else
		break;
	    }

	  QUIT;
	}
    }

exit_case_command:
  free (word);
  discard_unwind_frame ("case");
  line_number = save_line_number;
  return (retval);
}
warning: parse error {
  register WORD_LIST *list;
  WORD_LIST *wlist, *es;
  PATTERN_LIST *clauses;
  char *word, *pattern;
  int retval, match, ignore_return, save_line_number;

  save_line_number = line_number;
  line_number = case_command->line;

  command_string_index = 0;
  print_case_command_head (case_command);

  if (echo_command_at_execute)
    xtrace_print_case_command_head (case_command);

#if 0
  if (signal_in_progress (DEBUG_TRAP) == 0 && (this_command_name == 0 || (STREQ (this_command_name, "trap") == 0)))
#else
  if (signal_in_progress (DEBUG_TRAP) == 0 && running_trap == 0)
#endif
    {
      FREE (the_printed_command_except_trap);
      the_printed_command_except_trap = savestring (the_printed_command);
    }

  retval = run_debug_trap();
#if defined (DEBUGGER)
  /* In debugging mode, if the DEBUG trap returns a non-zero status, we
     skip the command. */
  if (debugging_mode && retval != EXECUTION_SUCCESS)
    {
      line_number = save_line_number;
      return (EXECUTION_SUCCESS);
    }
#endif

  wlist = expand_word_unsplit (case_command->word, 0);
  word = wlist ? string_list (wlist) : savestring ("");
  dispose_words (wlist);

  retval = EXECUTION_SUCCESS;
  ignore_return = case_command->flags & CMD_IGNORE_RETURN;

  begin_unwind_frame ("case");
  add_unwind_protect ((Function *)xfree, word);

#define EXIT_CASE()  goto exit_case_command

  for (clauses = case_command->clauses; clauses; clauses = clauses->next)
    {
      QUIT;
      for (list = clauses->patterns; list; list = list->next)
	{
	  es = expand_word_leave_quoted (list->word, 0);

	  if (es && es->word && es->word->word && *(es->word->word))
	    pattern = quote_string_for_globbing (es->word->word, QGLOB_CVTNULL);
	  else
	    {
	      pattern = (char *)xmalloc (1);
	      pattern[0] = '\0';
	    }

	  /* Since the pattern does not undergo quote removal (as per
	     Posix.2, section 3.9.4.3), the strmatch () call must be able
	     to recognize backslashes as escape characters. */
	  match = strmatch (pattern, word, FNMATCH_EXTFLAG|FNMATCH_IGNCASE) != FNM_NOMATCH;
	  free (pattern);

	  dispose_words (es);

	  if (match)
	    {
	      do
		{
		  if (clauses->action && ignore_return)
		    clauses->action->flags |= CMD_IGNORE_RETURN;
		  retval = execute_command (clauses->action);
		}
	      while ((clauses->flags & CASEPAT_FALLTHROUGH) && (clauses = clauses->next));
	      if (clauses == 0 || (clauses->flags & CASEPAT_TESTNEXT) == 0)
		EXIT_CASE ();
	      else
		break;
	    }

	  QUIT;
	}
    }

exit_case_command:
  free (word);
  discard_unwind_frame ("case");
  line_number = save_line_number;
  return (retval);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\execute_cmd.c:3,033
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\execute_cmd.c:3,138
parsing error 
{
  return (execute_while_or_until (while_command, CMD_WHILE));
}
warning: parse error {
  return (execute_while_or_until (while_command, CMD_WHILE));
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\execute_cmd.c:3,140
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\execute_cmd.c:3,146
parsing error 
{
  return (execute_while_or_until (while_command, CMD_UNTIL));
}
warning: parse error {
  return (execute_while_or_until (while_command, CMD_UNTIL));
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\execute_cmd.c:3,148
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\execute_cmd.c:3,158
parsing error 
{
  int return_value, body_status;

  body_status = EXECUTION_SUCCESS;
  loop_level++;

  while_command->test->flags |= CMD_IGNORE_RETURN;
  if (while_command->flags & CMD_IGNORE_RETURN)
    while_command->action->flags |= CMD_IGNORE_RETURN;

  while (1)
    {
      return_value = execute_command (while_command->test);
      REAP ();

      /* Need to handle `break' in the test when we would break out of the
         loop.  The job control code will set `breaking' to loop_level
         when a job in a loop is stopped with SIGTSTP.  If the stopped job
         is in the loop test, `breaking' will not be reset unless we do
         this, and the shell will cease to execute commands. */
      if (type == CMD_WHILE && return_value != EXECUTION_SUCCESS)
	{
	  if (breaking)
	    breaking--;
	  break;
	}
      if (type == CMD_UNTIL && return_value == EXECUTION_SUCCESS)
	{
	  if (breaking)
	    breaking--;
	  break;
	}

      QUIT;
      body_status = execute_command (while_command->action);
      QUIT;

      if (breaking)
	{
	  breaking--;
	  break;
	}

      if (continuing)
	{
	  continuing--;
	  if (continuing)
	    break;
	}
    }
  loop_level--;

  return (body_status);
}
warning: parse error {
  int return_value, body_status;

  body_status = EXECUTION_SUCCESS;
  loop_level++;

  while_command->test->flags |= CMD_IGNORE_RETURN;
  if (while_command->flags & CMD_IGNORE_RETURN)
    while_command->action->flags |= CMD_IGNORE_RETURN;

  while (1)
    {
      return_value = execute_command (while_command->test);
      REAP ();

      /* Need to handle `break' in the test when we would break out of the
         loop.  The job control code will set `breaking' to loop_level
         when a job in a loop is stopped with SIGTSTP.  If the stopped job
         is in the loop test, `breaking' will not be reset unless we do
         this, and the shell will cease to execute commands. */
      if (type == CMD_WHILE && return_value != EXECUTION_SUCCESS)
	{
	  if (breaking)
	    breaking--;
	  break;
	}
      if (type == CMD_UNTIL && return_value == EXECUTION_SUCCESS)
	{
	  if (breaking)
	    breaking--;
	  break;
	}

      QUIT;
      body_status = execute_command (while_command->action);
      QUIT;

      if (breaking)
	{
	  breaking--;
	  break;
	}

      if (continuing)
	{
	  continuing--;
	  if (continuing)
	    break;
	}
    }
  loop_level--;

  return (body_status);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\execute_cmd.c:3,161
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\execute_cmd.c:3,220
parsing error 
{
  int return_value, save_line_number;

  save_line_number = line_number;
  if_command->test->flags |= CMD_IGNORE_RETURN;
  return_value = execute_command (if_command->test);
  line_number = save_line_number;

  if (return_value == EXECUTION_SUCCESS)
    {
      QUIT;

      if (if_command->true_case && (if_command->flags & CMD_IGNORE_RETURN))
	if_command->true_case->flags |= CMD_IGNORE_RETURN;

      return (execute_command (if_command->true_case));
    }
  else
    {
      QUIT;

      if (if_command->false_case && (if_command->flags & CMD_IGNORE_RETURN))
	if_command->false_case->flags |= CMD_IGNORE_RETURN;

      return (execute_command (if_command->false_case));
    }
}
warning: parse error {
  int return_value, save_line_number;

  save_line_number = line_number;
  if_command->test->flags |= CMD_IGNORE_RETURN;
  return_value = execute_command (if_command->test);
  line_number = save_line_number;

  if (return_value == EXECUTION_SUCCESS)
    {
      QUIT;

      if (if_command->true_case && (if_command->flags & CMD_IGNORE_RETURN))
	if_command->true_case->flags |= CMD_IGNORE_RETURN;

      return (execute_command (if_command->true_case));
    }
  else
    {
      QUIT;

      if (if_command->false_case && (if_command->flags & CMD_IGNORE_RETURN))
	if_command->false_case->flags |= CMD_IGNORE_RETURN;

      return (execute_command (if_command->false_case));
    }
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\execute_cmd.c:3,222
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\execute_cmd.c:3,487
parsing error 
{
  SHELL_VAR *var;

  if (arg == 0)
    arg = "";
  var = bind_variable ("_", arg, 0);
  VUNSETATTR (var, att_exported);
}
warning: parse error {
  SHELL_VAR *var;

  if (arg == 0)
    arg = "";
  var = bind_variable ("_", arg, 0);
  VUNSETATTR (var, att_exported);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\execute_cmd.c:3,489
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\execute_cmd.c:3,502
parsing error 
{
  int r;
  int forcefork;
  REDIRECT *rd;

  for (forcefork = 0, rd = redirects; rd; rd = rd->next)
    forcefork += rd->rflags & REDIR_VARASSIGN;

  if (forcefork || pipe_in != NO_PIPE || pipe_out != NO_PIPE || async)
    {
      /* We have a null command, but we really want a subshell to take
	 care of it.  Just fork, do piping and redirections, and exit. */
      if (make_child ((char *)NULL, async) == 0)
	{
	  /* Cancel traps, in trap.c. */
	  restore_original_signals ();		/* XXX */

	  do_piping (pipe_in, pipe_out);

#if defined (COPROCESS_SUPPORT)
	  coproc_closeall ();
#endif

	  subshell_environment = 0;
	  if (async)
	    subshell_environment |= SUBSHELL_ASYNC;
	  if (pipe_in != NO_PIPE || pipe_out != NO_PIPE)
	    subshell_environment |= SUBSHELL_PIPE;

	  if (do_redirections (redirects, RX_ACTIVE) == 0)
	    exit (EXECUTION_SUCCESS);
	  else
	    exit (EXECUTION_FAILURE);
	}
      else
	{
	  close_pipes (pipe_in, pipe_out);
#if defined (PROCESS_SUBSTITUTION) && defined (HAVE_DEV_FD)
	  unlink_fifo_list ();
#endif
	  return (EXECUTION_SUCCESS);
	}
    }
  else
    {
      /* Even if there aren't any command names, pretend to do the
	 redirections that are specified.  The user expects the side
	 effects to take place.  If the redirections fail, then return
	 failure.  Otherwise, if a command substitution took place while
	 expanding the command or a redirection, return the value of that
	 substitution.  Otherwise, return EXECUTION_SUCCESS. */

      r = do_redirections (redirects, RX_ACTIVE|RX_UNDOABLE);
      cleanup_redirects (redirection_undo_list);
      redirection_undo_list = (REDIRECT *)NULL;

      if (r != 0)
	return (EXECUTION_FAILURE);
      else if (last_command_subst_pid != NO_PID)
	return (last_command_exit_value);
      else
	return (EXECUTION_SUCCESS);
    }
}
warning: parse error {
  int r;
  int forcefork;
  REDIRECT *rd;

  for (forcefork = 0, rd = redirects; rd; rd = rd->next)
    forcefork += rd->rflags & REDIR_VARASSIGN;

  if (forcefork || pipe_in != NO_PIPE || pipe_out != NO_PIPE || async)
    {
      /* We have a null command, but we really want a subshell to take
	 care of it.  Just fork, do piping and redirections, and exit. */
      if (make_child ((char *)NULL, async) == 0)
	{
	  /* Cancel traps, in trap.c. */
	  restore_original_signals ();		/* XXX */

	  do_piping (pipe_in, pipe_out);

#if defined (COPROCESS_SUPPORT)
	  coproc_closeall ();
#endif

	  subshell_environment = 0;
	  if (async)
	    subshell_environment |= SUBSHELL_ASYNC;
	  if (pipe_in != NO_PIPE || pipe_out != NO_PIPE)
	    subshell_environment |= SUBSHELL_PIPE;

	  if (do_redirections (redirects, RX_ACTIVE) == 0)
	    exit (EXECUTION_SUCCESS);
	  else
	    exit (EXECUTION_FAILURE);
	}
      else
	{
	  close_pipes (pipe_in, pipe_out);
#if defined (PROCESS_SUBSTITUTION) && defined (HAVE_DEV_FD)
	  unlink_fifo_list ();
#endif
	  return (EXECUTION_SUCCESS);
	}
    }
  else
    {
      /* Even if there aren't any command names, pretend to do the
	 redirections that are specified.  The user expects the side
	 effects to take place.  If the redirections fail, then return
	 failure.  Otherwise, if a command substitution took place while
	 expanding the command or a redirection, return the value of that
	 substitution.  Otherwise, return EXECUTION_SUCCESS. */

      r = do_redirections (redirects, RX_ACTIVE|RX_UNDOABLE);
      cleanup_redirects (redirection_undo_list);
      redirection_undo_list = (REDIRECT *)NULL;

      if (r != 0)
	return (EXECUTION_FAILURE);
      else if (last_command_subst_pid != NO_PID)
	return (last_command_exit_value);
      else
	return (EXECUTION_SUCCESS);
    }
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\execute_cmd.c:3,505
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\execute_cmd.c:3,573
parsing error 
{
  WORD_LIST *w;
  struct builtin *b;
  int assoc;

  if (words == 0)
    return;

  b = 0;
  assoc = 0;

  for (w = words; w; w = w->next)
    if (w->word->flags & W_ASSIGNMENT)
      {
	if (b == 0)
	  {
	    b = builtin_address_internal (words->word->word, 0);
	    if (b == 0 || (b->flags & ASSIGNMENT_BUILTIN) == 0)
	      return;
	    else if (b && (b->flags & ASSIGNMENT_BUILTIN))
	      words->word->flags |= W_ASSNBLTIN;
	  }
	w->word->flags |= (W_NOSPLIT|W_NOGLOB|W_TILDEEXP|W_ASSIGNARG);
#if defined (ARRAY_VARS)
	if (assoc)
	  w->word->flags |= W_ASSIGNASSOC;
#endif
      }
#if defined (ARRAY_VARS)
    /* Note that we saw an associative array option to a builtin that takes
       assignment statements.  This is a bit of a kludge. */
    else if (w->word->word[0] == '-' && strchr (w->word->word, 'A'))
      {
	if (b == 0)
	  {
	    b = builtin_address_internal (words->word->word, 0);
	    if (b == 0 || (b->flags & ASSIGNMENT_BUILTIN) == 0)
	      return;
	    else if (b && (b->flags & ASSIGNMENT_BUILTIN))
	      words->word->flags |= W_ASSNBLTIN;
	  }
	if (words->word->flags & W_ASSNBLTIN)
	  assoc = 1;
      }
#endif
}
warning: parse error {
  WORD_LIST *w;
  struct builtin *b;
  int assoc;

  if (words == 0)
    return;

  b = 0;
  assoc = 0;

  for (w = words; w; w = w->next)
    if (w->word->flags & W_ASSIGNMENT)
      {
	if (b == 0)
	  {
	    b = builtin_address_internal (words->word->word, 0);
	    if (b == 0 || (b->flags & ASSIGNMENT_BUILTIN) == 0)
	      return;
	    else if (b && (b->flags & ASSIGNMENT_BUILTIN))
	      words->word->flags |= W_ASSNBLTIN;
	  }
	w->word->flags |= (W_NOSPLIT|W_NOGLOB|W_TILDEEXP|W_ASSIGNARG);
#if defined (ARRAY_VARS)
	if (assoc)
	  w->word->flags |= W_ASSIGNASSOC;
#endif
      }
#if defined (ARRAY_VARS)
    /* Note that we saw an associative array option to a builtin that takes
       assignment statements.  This is a bit of a kludge. */
    else if (w->word->word[0] == '-' && strchr (w->word->word, 'A'))
      {
	if (b == 0)
	  {
	    b = builtin_address_internal (words->word->word, 0);
	    if (b == 0 || (b->flags & ASSIGNMENT_BUILTIN) == 0)
	      return;
	    else if (b && (b->flags & ASSIGNMENT_BUILTIN))
	      words->word->flags |= W_ASSNBLTIN;
	  }
	if (words->word->flags & W_ASSNBLTIN)
	  assoc = 1;
      }
#endif
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\execute_cmd.c:3,575
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\execute_cmd.c:3,625
parsing error 
{
  char *temp;
  temp = search_for_command (pathname);
  return (temp ? file_isdir (temp) : file_isdir (pathname));
}
warning: parse error {
  char *temp;
  temp = search_for_command (pathname);
  return (temp ? file_isdir (temp) : file_isdir (pathname));
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\execute_cmd.c:3,627
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\execute_cmd.c:3,637
parsing error 
{
  WORD_LIST *words, *lastword;
  char *command_line, *lastarg, *temp;
  int first_word_quoted, result, builtin_is_special, already_forked, dofork;
  pid_t old_last_async_pid;
  sh_builtin_func_t *builtin;
  SHELL_VAR *func;
  volatile int old_builtin, old_command_builtin;

  result = EXECUTION_SUCCESS;
  special_builtin_failed = builtin_is_special = 0;
  command_line = (char *)0;

  /* If we're in a function, update the line number information. */
  if (variable_context && interactive_shell && sourcelevel == 0)
    line_number -= function_line_number;

  /* Remember what this command line looks like at invocation. */
  command_string_index = 0;
  print_simple_command (simple_command);

#if 0
  if (signal_in_progress (DEBUG_TRAP) == 0 && (this_command_name == 0 || (STREQ (this_command_name, "trap") == 0)))
#else
  if (signal_in_progress (DEBUG_TRAP) == 0 && running_trap == 0)
#endif
    {
      FREE (the_printed_command_except_trap);
      the_printed_command_except_trap = the_printed_command ? savestring (the_printed_command) : (char *)0;
    }

  /* Run the debug trap before each simple command, but do it after we
     update the line number information. */
  result = run_debug_trap ();
#if defined (DEBUGGER)
  /* In debugging mode, if the DEBUG trap returns a non-zero status, we
     skip the command. */
  if (debugging_mode && result != EXECUTION_SUCCESS)
    return (EXECUTION_SUCCESS);
#endif

  first_word_quoted =
    simple_command->words ? (simple_command->words->word->flags & W_QUOTED) : 0;

  last_command_subst_pid = NO_PID;
  old_last_async_pid = last_asynchronous_pid;

  already_forked = dofork = 0;

  /* If we're in a pipeline or run in the background, set DOFORK so we
     make the child early, before word expansion.  This keeps assignment
     statements from affecting the parent shell's environment when they
     should not. */
  dofork = pipe_in != NO_PIPE || pipe_out != NO_PIPE || async;

  /* Something like `%2 &' should restart job 2 in the background, not cause
     the shell to fork here. */
  if (dofork && pipe_in == NO_PIPE && pipe_out == NO_PIPE &&
	simple_command->words && simple_command->words->word &&
	simple_command->words->word->word &&
	(simple_command->words->word->word[0] == '%'))
    dofork = 0;

  if (dofork)
    {
      /* Do this now, because execute_disk_command will do it anyway in the
	 vast majority of cases. */
      maybe_make_export_env ();

      /* Don't let a DEBUG trap overwrite the command string to be saved with
	 the process/job associated with this child. */
      if (make_child (savestring (the_printed_command_except_trap), async) == 0)
	{
	  already_forked = 1;
	  simple_command->flags |= CMD_NO_FORK;

	  subshell_environment = SUBSHELL_FORK;
	  if (pipe_in != NO_PIPE || pipe_out != NO_PIPE)
	    subshell_environment |= SUBSHELL_PIPE;
	  if (async)
	    subshell_environment |= SUBSHELL_ASYNC;

	  /* We need to do this before piping to handle some really
	     pathological cases where one of the pipe file descriptors
	     is < 2. */
	  if (fds_to_close)
	    close_fd_bitmap (fds_to_close);

	  do_piping (pipe_in, pipe_out);
	  pipe_in = pipe_out = NO_PIPE;
#if defined (COPROCESS_SUPPORT)
	  coproc_closeall ();
#endif

	  last_asynchronous_pid = old_last_async_pid;
	}
      else
	{
	  /* Don't let simple commands that aren't the last command in a
	     pipeline change $? for the rest of the pipeline (or at all). */
	  if (pipe_out != NO_PIPE)
	    result = last_command_exit_value;
	  close_pipes (pipe_in, pipe_out);
#if defined (PROCESS_SUBSTITUTION) && defined (HAVE_DEV_FD)
	  unlink_fifo_list ();
#endif
	  command_line = (char *)NULL;      /* don't free this. */
	  bind_lastarg ((char *)NULL);
	  return (result);
	}
    }

  /* If we are re-running this as the result of executing the `command'
     builtin, do not expand the command words a second time. */
  if ((simple_command->flags & CMD_INHIBIT_EXPANSION) == 0)
    {
      current_fds_to_close = fds_to_close;
      fix_assignment_words (simple_command->words);
      /* Pass the ignore return flag down to command substitutions */
      if (simple_command->flags & CMD_IGNORE_RETURN)	/* XXX */
	comsub_ignore_return++;
      words = expand_words (simple_command->words);
      if (simple_command->flags & CMD_IGNORE_RETURN)
	comsub_ignore_return--;
      current_fds_to_close = (struct fd_bitmap *)NULL;
    }
  else
    words = copy_word_list (simple_command->words);

  /* It is possible for WORDS not to have anything left in it.
     Perhaps all the words consisted of `$foo', and there was
     no variable `$foo'. */
  if (words == 0)
    {
      this_command_name = 0;
      result = execute_null_command (simple_command->redirects,
				     pipe_in, pipe_out,
				     already_forked ? 0 : async);
      if (already_forked)
	exit (result);
      else
	{
	  bind_lastarg ((char *)NULL);
	  set_pipestatus_from_exit (result);
	  return (result);
	}
    }

  lastarg = (char *)NULL;

  begin_unwind_frame ("simple-command");

  if (echo_command_at_execute)
    xtrace_print_word_list (words, 1);

  builtin = (sh_builtin_func_t *)NULL;
  func = (SHELL_VAR *)NULL;
  if ((simple_command->flags & CMD_NO_FUNCTIONS) == 0)
    {
      /* Posix.2 says special builtins are found before functions.  We
	 don't set builtin_is_special anywhere other than here, because
	 this path is followed only when the `command' builtin is *not*
	 being used, and we don't want to exit the shell if a special
	 builtin executed with `command builtin' fails.  `command' is not
	 a special builtin. */
      if (posixly_correct)
	{
	  builtin = find_special_builtin (words->word->word);
	  if (builtin)
	    builtin_is_special = 1;
	}
      if (builtin == 0)
	func = find_function (words->word->word);
    }

  /* In POSIX mode, assignment errors in the temporary environment cause a
     non-interactive shell to exit. */
  if (builtin_is_special && interactive_shell == 0 && tempenv_assign_error)
    {
      last_command_exit_value = EXECUTION_FAILURE;
      jump_to_top_level (ERREXIT);
    }

  add_unwind_protect (dispose_words, words);
  QUIT;

  /* Bind the last word in this command to "$_" after execution. */
  for (lastword = words; lastword->next; lastword = lastword->next)
    ;
  lastarg = lastword->word->word;

#if defined (JOB_CONTROL)
  /* Is this command a job control related thing? */
  if (words->word->word[0] == '%' && already_forked == 0)
    {
      this_command_name = async ? "bg" : "fg";
      last_shell_builtin = this_shell_builtin;
      this_shell_builtin = builtin_address (this_command_name);
      result = (*this_shell_builtin) (words);
      goto return_result;
    }

  /* One other possiblilty.  The user may want to resume an existing job.
     If they do, find out whether this word is a candidate for a running
     job. */
  if (job_control && already_forked == 0 && async == 0 &&
	!first_word_quoted &&
	!words->next &&
	words->word->word[0] &&
	!simple_command->redirects &&
	pipe_in == NO_PIPE &&
	pipe_out == NO_PIPE &&
	(temp = get_string_value ("auto_resume")))
    {
      int job, jflags, started_status;

      jflags = JM_STOPPED|JM_FIRSTMATCH;
      if (STREQ (temp, "exact"))
	jflags |= JM_EXACT;
      else if (STREQ (temp, "substring"))
	jflags |= JM_SUBSTRING;
      else
	jflags |= JM_PREFIX;
      job = get_job_by_name (words->word->word, jflags);
      if (job != NO_JOB)
	{
	  run_unwind_frame ("simple-command");
	  this_command_name = "fg";
	  last_shell_builtin = this_shell_builtin;
	  this_shell_builtin = builtin_address ("fg");

	  started_status = start_job (job, 1);
	  return ((started_status < 0) ? EXECUTION_FAILURE : started_status);
	}
    }
#endif /* JOB_CONTROL */

run_builtin:
  /* Remember the name of this command globally. */
  this_command_name = words->word->word;

  QUIT;

  /* This command could be a shell builtin or a user-defined function.
     We have already found special builtins by this time, so we do not
     set builtin_is_special.  If this is a function or builtin, and we
     have pipes, then fork a subshell in here.  Otherwise, just execute
     the command directly. */
  if (func == 0 && builtin == 0)
    builtin = find_shell_builtin (this_command_name);

  last_shell_builtin = this_shell_builtin;
  this_shell_builtin = builtin;

  if (builtin || func)
    {
      if (builtin)
        {
	  old_builtin = executing_builtin;
	  old_command_builtin = executing_command_builtin;
	  unwind_protect_int (executing_builtin);	/* modified in execute_builtin */
	  unwind_protect_int (executing_command_builtin);	/* ditto */
        }
      if (already_forked)
	{
	  /* reset_terminating_signals (); */	/* XXX */
	  /* Reset the signal handlers in the child, but don't free the
	     trap strings.  Set a flag noting that we have to free the
	     trap strings if we run trap to change a signal disposition. */
	  reset_signal_handlers ();
	  subshell_environment |= SUBSHELL_RESETTRAP;

	  if (async)
	    {
	      if ((simple_command->flags & CMD_STDIN_REDIR) &&
		    pipe_in == NO_PIPE &&
		    (stdin_redirects (simple_command->redirects) == 0))
		async_redirect_stdin ();
	      setup_async_signals ();
	    }

	  subshell_level++;
	  execute_subshell_builtin_or_function
	    (words, simple_command->redirects, builtin, func,
	     pipe_in, pipe_out, async, fds_to_close,
	     simple_command->flags);
	  subshell_level--;
	}
      else
	{
	  result = execute_builtin_or_function
	    (words, builtin, func, simple_command->redirects, fds_to_close,
	     simple_command->flags);
	  if (builtin)
	    {
	      if (result > EX_SHERRBASE)
		{
		  result = builtin_status (result);
		  if (builtin_is_special)
		    special_builtin_failed = 1;
		}
	      /* In POSIX mode, if there are assignment statements preceding
		 a special builtin, they persist after the builtin
		 completes. */
	      if (posixly_correct && builtin_is_special && temporary_env)
		merge_temporary_env ();
	    }
	  else		/* function */
	    {
	      if (result == EX_USAGE)
		result = EX_BADUSAGE;
	      else if (result > EX_SHERRBASE)
		result = EXECUTION_FAILURE;
	    }

	  set_pipestatus_from_exit (result);

	  goto return_result;
	}
    }

  if (autocd && interactive && words->word && is_dirname (words->word->word))
    {
      words = make_word_list (make_word ("cd"), words);
      xtrace_print_word_list (words, 0);
      goto run_builtin;
    }

  if (command_line == 0)
    command_line = savestring (the_printed_command_except_trap);

#if defined (PROCESS_SUBSTITUTION)
  if ((subshell_environment & SUBSHELL_COMSUB) && (simple_command->flags & CMD_NO_FORK) && fifos_pending() > 0)
    simple_command->flags &= ~CMD_NO_FORK;
#endif

  result = execute_disk_command (words, simple_command->redirects, command_line,
			pipe_in, pipe_out, async, fds_to_close,
			simple_command->flags);

 return_result:
  bind_lastarg (lastarg);
  FREE (command_line);
  dispose_words (words);
  if (builtin)
    {
      executing_builtin = old_builtin;
      executing_command_builtin = old_command_builtin;
    }
  discard_unwind_frame ("simple-command");
  this_command_name = (char *)NULL;	/* points to freed memory now */
  return (result);
}
warning: parse error {
  WORD_LIST *words, *lastword;
  char *command_line, *lastarg, *temp;
  int first_word_quoted, result, builtin_is_special, already_forked, dofork;
  pid_t old_last_async_pid;
  sh_builtin_func_t *builtin;
  SHELL_VAR *func;
  volatile int old_builtin, old_command_builtin;

  result = EXECUTION_SUCCESS;
  special_builtin_failed = builtin_is_special = 0;
  command_line = (char *)0;

  /* If we're in a function, update the line number information. */
  if (variable_context && interactive_shell && sourcelevel == 0)
    line_number -= function_line_number;

  /* Remember what this command line looks like at invocation. */
  command_string_index = 0;
  print_simple_command (simple_command);

#if 0
  if (signal_in_progress (DEBUG_TRAP) == 0 && (this_command_name == 0 || (STREQ (this_command_name, "trap") == 0)))
#else
  if (signal_in_progress (DEBUG_TRAP) == 0 && running_trap == 0)
#endif
    {
      FREE (the_printed_command_except_trap);
      the_printed_command_except_trap = the_printed_command ? savestring (the_printed_command) : (char *)0;
    }

  /* Run the debug trap before each simple command, but do it after we
     update the line number information. */
  result = run_debug_trap ();
#if defined (DEBUGGER)
  /* In debugging mode, if the DEBUG trap returns a non-zero status, we
     skip the command. */
  if (debugging_mode && result != EXECUTION_SUCCESS)
    return (EXECUTION_SUCCESS);
#endif

  first_word_quoted =
    simple_command->words ? (simple_command->words->word->flags & W_QUOTED) : 0;

  last_command_subst_pid = NO_PID;
  old_last_async_pid = last_asynchronous_pid;

  already_forked = dofork = 0;

  /* If we're in a pipeline or run in the background, set DOFORK so we
     make the child early, before word expansion.  This keeps assignment
     statements from affecting the parent shell's environment when they
     should not. */
  dofork = pipe_in != NO_PIPE || pipe_out != NO_PIPE || async;

  /* Something like `%2 &' should restart job 2 in the background, not cause
     the shell to fork here. */
  if (dofork && pipe_in == NO_PIPE && pipe_out == NO_PIPE &&
	simple_command->words && simple_command->words->word &&
	simple_command->words->word->word &&
	(simple_command->words->word->word[0] == '%'))
    dofork = 0;

  if (dofork)
    {
      /* Do this now, because execute_disk_command will do it anyway in the
	 vast majority of cases. */
      maybe_make_export_env ();

      /* Don't let a DEBUG trap overwrite the command string to be saved with
	 the process/job associated with this child. */
      if (make_child (savestring (the_printed_command_except_trap), async) == 0)
	{
	  already_forked = 1;
	  simple_command->flags |= CMD_NO_FORK;

	  subshell_environment = SUBSHELL_FORK;
	  if (pipe_in != NO_PIPE || pipe_out != NO_PIPE)
	    subshell_environment |= SUBSHELL_PIPE;
	  if (async)
	    subshell_environment |= SUBSHELL_ASYNC;

	  /* We need to do this before piping to handle some really
	     pathological cases where one of the pipe file descriptors
	     is < 2. */
	  if (fds_to_close)
	    close_fd_bitmap (fds_to_close);

	  do_piping (pipe_in, pipe_out);
	  pipe_in = pipe_out = NO_PIPE;
#if defined (COPROCESS_SUPPORT)
	  coproc_closeall ();
#endif

	  last_asynchronous_pid = old_last_async_pid;
	}
      else
	{
	  /* Don't let simple commands that aren't the last command in a
	     pipeline change $? for the rest of the pipeline (or at all). */
	  if (pipe_out != NO_PIPE)
	    result = last_command_exit_value;
	  close_pipes (pipe_in, pipe_out);
#if defined (PROCESS_SUBSTITUTION) && defined (HAVE_DEV_FD)
	  unlink_fifo_list ();
#endif
	  command_line = (char *)NULL;      /* don't free this. */
	  bind_lastarg ((char *)NULL);
	  return (result);
	}
    }

  /* If we are re-running this as the result of executing the `command'
     builtin, do not expand the command words a second time. */
  if ((simple_command->flags & CMD_INHIBIT_EXPANSION) == 0)
    {
      current_fds_to_close = fds_to_close;
      fix_assignment_words (simple_command->words);
      /* Pass the ignore return flag down to command substitutions */
      if (simple_command->flags & CMD_IGNORE_RETURN)	/* XXX */
	comsub_ignore_return++;
      words = expand_words (simple_command->words);
      if (simple_command->flags & CMD_IGNORE_RETURN)
	comsub_ignore_return--;
      current_fds_to_close = (struct fd_bitmap *)NULL;
    }
  else
    words = copy_word_list (simple_command->words);

  /* It is possible for WORDS not to have anything left in it.
     Perhaps all the words consisted of `$foo', and there was
     no variable `$foo'. */
  if (words == 0)
    {
      this_command_name = 0;
      result = execute_null_command (simple_command->redirects,
				     pipe_in, pipe_out,
				     already_forked ? 0 : async);
      if (already_forked)
	exit (result);
      else
	{
	  bind_lastarg ((char *)NULL);
	  set_pipestatus_from_exit (result);
	  return (result);
	}
    }

  lastarg = (char *)NULL;

  begin_unwind_frame ("simple-command");

  if (echo_command_at_execute)
    xtrace_print_word_list (words, 1);

  builtin = (sh_builtin_func_t *)NULL;
  func = (SHELL_VAR *)NULL;
  if ((simple_command->flags & CMD_NO_FUNCTIONS) == 0)
    {
      /* Posix.2 says special builtins are found before functions.  We
	 don't set builtin_is_special anywhere other than here, because
	 this path is followed only when the `command' builtin is *not*
	 being used, and we don't want to exit the shell if a special
	 builtin executed with `command builtin' fails.  `command' is not
	 a special builtin. */
      if (posixly_correct)
	{
	  builtin = find_special_builtin (words->word->word);
	  if (builtin)
	    builtin_is_special = 1;
	}
      if (builtin == 0)
	func = find_function (words->word->word);
    }

  /* In POSIX mode, assignment errors in the temporary environment cause a
     non-interactive shell to exit. */
  if (builtin_is_special && interactive_shell == 0 && tempenv_assign_error)
    {
      last_command_exit_value = EXECUTION_FAILURE;
      jump_to_top_level (ERREXIT);
    }

  add_unwind_protect (dispose_words, words);
  QUIT;

  /* Bind the last word in this command to "$_" after execution. */
  for (lastword = words; lastword->next; lastword = lastword->next)
    ;
  lastarg = lastword->word->word;

#if defined (JOB_CONTROL)
  /* Is this command a job control related thing? */
  if (words->word->word[0] == '%' && already_forked == 0)
    {
      this_command_name = async ? "bg" : "fg";
      last_shell_builtin = this_shell_builtin;
      this_shell_builtin = builtin_address (this_command_name);
      result = (*this_shell_builtin) (words);
      goto return_result;
    }

  /* One other possiblilty.  The user may want to resume an existing job.
     If they do, find out whether this word is a candidate for a running
     job. */
  if (job_control && already_forked == 0 && async == 0 &&
	!first_word_quoted &&
	!words->next &&
	words->word->word[0] &&
	!simple_command->redirects &&
	pipe_in == NO_PIPE &&
	pipe_out == NO_PIPE &&
	(temp = get_string_value ("auto_resume")))
    {
      int job, jflags, started_status;

      jflags = JM_STOPPED|JM_FIRSTMATCH;
      if (STREQ (temp, "exact"))
	jflags |= JM_EXACT;
      else if (STREQ (temp, "substring"))
	jflags |= JM_SUBSTRING;
      else
	jflags |= JM_PREFIX;
      job = get_job_by_name (words->word->word, jflags);
      if (job != NO_JOB)
	{
	  run_unwind_frame ("simple-command");
	  this_command_name = "fg";
	  last_shell_builtin = this_shell_builtin;
	  this_shell_builtin = builtin_address ("fg");

	  started_status = start_job (job, 1);
	  return ((started_status < 0) ? EXECUTION_FAILURE : started_status);
	}
    }
#endif /* JOB_CONTROL */

run_builtin:
  /* Remember the name of this command globally. */
  this_command_name = words->word->word;

  QUIT;

  /* This command could be a shell builtin or a user-defined function.
     We have already found special builtins by this time, so we do not
     set builtin_is_special.  If this is a function or builtin, and we
     have pipes, then fork a subshell in here.  Otherwise, just execute
     the command directly. */
  if (func == 0 && builtin == 0)
    builtin = find_shell_builtin (this_command_name);

  last_shell_builtin = this_shell_builtin;
  this_shell_builtin = builtin;

  if (builtin || func)
    {
      if (builtin)
        {
	  old_builtin = executing_builtin;
	  old_command_builtin = executing_command_builtin;
	  unwind_protect_int (executing_builtin);	/* modified in execute_builtin */
	  unwind_protect_int (executing_command_builtin);	/* ditto */
        }
      if (already_forked)
	{
	  /* reset_terminating_signals (); */	/* XXX */
	  /* Reset the signal handlers in the child, but don't free the
	     trap strings.  Set a flag noting that we have to free the
	     trap strings if we run trap to change a signal disposition. */
	  reset_signal_handlers ();
	  subshell_environment |= SUBSHELL_RESETTRAP;

	  if (async)
	    {
	      if ((simple_command->flags & CMD_STDIN_REDIR) &&
		    pipe_in == NO_PIPE &&
		    (stdin_redirects (simple_command->redirects) == 0))
		async_redirect_stdin ();
	      setup_async_signals ();
	    }

	  subshell_level++;
	  execute_subshell_builtin_or_function
	    (words, simple_command->redirects, builtin, func,
	     pipe_in, pipe_out, async, fds_to_close,
	     simple_command->flags);
	  subshell_level--;
	}
      else
	{
	  result = execute_builtin_or_function
	    (words, builtin, func, simple_command->redirects, fds_to_close,
	     simple_command->flags);
	  if (builtin)
	    {
	      if (result > EX_SHERRBASE)
		{
		  result = builtin_status (result);
		  if (builtin_is_special)
		    special_builtin_failed = 1;
		}
	      /* In POSIX mode, if there are assignment statements preceding
		 a special builtin, they persist after the builtin
		 completes. */
	      if (posixly_correct && builtin_is_special && temporary_env)
		merge_temporary_env ();
	    }
	  else		/* function */
	    {
	      if (result == EX_USAGE)
		result = EX_BADUSAGE;
	      else if (result > EX_SHERRBASE)
		result = EXECUTION_FAILURE;
	    }

	  set_pipestatus_from_exit (result);

	  goto return_result;
	}
    }

  if (autocd && interactive && words->word && is_dirname (words->word->word))
    {
      words = make_word_list (make_word ("cd"), words);
      xtrace_print_word_list (words, 0);
      goto run_builtin;
    }

  if (command_line == 0)
    command_line = savestring (the_printed_command_except_trap);

#if defined (PROCESS_SUBSTITUTION)
  if ((subshell_environment & SUBSHELL_COMSUB) && (simple_command->flags & CMD_NO_FORK) && fifos_pending() > 0)
    simple_command->flags &= ~CMD_NO_FORK;
#endif

  result = execute_disk_command (words, simple_command->redirects, command_line,
			pipe_in, pipe_out, async, fds_to_close,
			simple_command->flags);

 return_result:
  bind_lastarg (lastarg);
  FREE (command_line);
  dispose_words (words);
  if (builtin)
    {
      executing_builtin = old_builtin;
      executing_command_builtin = old_command_builtin;
    }
  discard_unwind_frame ("simple-command");
  this_command_name = (char *)NULL;	/* points to freed memory now */
  return (result);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\execute_cmd.c:3,641
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\execute_cmd.c:3,998
parsing error 
{
  int r;

  switch (result)
    {
    case EX_USAGE:
      r = EX_BADUSAGE;
      break;
    case EX_REDIRFAIL:
    case EX_BADSYNTAX:
    case EX_BADASSIGN:
    case EX_EXPFAIL:
      r = EXECUTION_FAILURE;
      break;
    default:
      r = EXECUTION_SUCCESS;
      break;
    }
  return (r);
}
warning: parse error {
  int r;

  switch (result)
    {
    case EX_USAGE:
      r = EX_BADUSAGE;
      break;
    case EX_REDIRFAIL:
    case EX_BADSYNTAX:
    case EX_BADASSIGN:
    case EX_EXPFAIL:
      r = EXECUTION_FAILURE;
      break;
    default:
      r = EXECUTION_SUCCESS;
      break;
    }
  return (r);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\execute_cmd.c:4,000
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\execute_cmd.c:4,022
parsing error 
{
  int old_e_flag, result, eval_unwind;
  int isbltinenv;
  char *error_trap;

#if 0
  /* XXX -- added 12/11 */
  terminate_immediately++;
#endif

  error_trap = 0;
  old_e_flag = exit_immediately_on_error;
  /* The eval builtin calls parse_and_execute, which does not know about
     the setting of flags, and always calls the execution functions with
     flags that will exit the shell on an error if -e is set.  If the
     eval builtin is being called, and we're supposed to ignore the exit
     value of the command, we turn the -e flag off ourselves and disable
     the ERR trap, then restore them when the command completes.  This is
     also a problem (as below) for the command and source/. builtins. */
  if (subshell == 0 && (flags & CMD_IGNORE_RETURN) &&
	(builtin == eval_builtin || builtin == command_builtin || builtin == source_builtin))
    {
      begin_unwind_frame ("eval_builtin");
      unwind_protect_int (exit_immediately_on_error);
      error_trap = TRAP_STRING (ERROR_TRAP);
      if (error_trap)
	{
	  error_trap = savestring (error_trap);
	  add_unwind_protect (xfree, error_trap);
	  add_unwind_protect (set_error_trap, error_trap);
	  restore_default_signal (ERROR_TRAP);
	}
      exit_immediately_on_error = 0;
      eval_unwind = 1;
    }
  else
    eval_unwind = 0;

  /* The temporary environment for a builtin is supposed to apply to
     all commands executed by that builtin.  Currently, this is a
     problem only with the `unset', `source' and `eval' builtins. */

  isbltinenv = (builtin == source_builtin || builtin == eval_builtin || builtin == unset_builtin);

  if (isbltinenv)
    {
      if (subshell == 0)
	begin_unwind_frame ("builtin_env");

      if (temporary_env)
	{
	  push_scope (VC_BLTNENV, temporary_env);
	  if (subshell == 0)
	    add_unwind_protect (pop_scope, (flags & CMD_COMMAND_BUILTIN) ? 0 : "1");
          temporary_env = (HASH_TABLE *)NULL;	  
	}
    }

  /* `return' does a longjmp() back to a saved environment in execute_function.
     If a variable assignment list preceded the command, and the shell is
     running in POSIX mode, we need to merge that into the shell_variables
     table, since `return' is a POSIX special builtin. */
  if (posixly_correct && subshell == 0 && builtin == return_builtin && temporary_env)
    {
      begin_unwind_frame ("return_temp_env");
      add_unwind_protect (merge_temporary_env, (char *)NULL);
    }

  executing_builtin++;
  executing_command_builtin |= builtin == command_builtin;
  result = ((*builtin) (words->next));

  /* This shouldn't happen, but in case `return' comes back instead of
     longjmp'ing, we need to unwind. */
  if (posixly_correct && subshell == 0 && builtin == return_builtin && temporary_env)
    discard_unwind_frame ("return_temp_env");

  if (subshell == 0 && isbltinenv)
    run_unwind_frame ("builtin_env");

  if (eval_unwind)
    {
      exit_immediately_on_error += old_e_flag;
      if (error_trap)
	{
	  set_error_trap (error_trap);
	  xfree (error_trap);
	}
      discard_unwind_frame ("eval_builtin");
    }

#if 0
  /* XXX -- added 12/11 */
  terminate_immediately--;
#endif

  return (result);
}
warning: parse error {
  int old_e_flag, result, eval_unwind;
  int isbltinenv;
  char *error_trap;

#if 0
  /* XXX -- added 12/11 */
  terminate_immediately++;
#endif

  error_trap = 0;
  old_e_flag = exit_immediately_on_error;
  /* The eval builtin calls parse_and_execute, which does not know about
     the setting of flags, and always calls the execution functions with
     flags that will exit the shell on an error if -e is set.  If the
     eval builtin is being called, and we're supposed to ignore the exit
     value of the command, we turn the -e flag off ourselves and disable
     the ERR trap, then restore them when the command completes.  This is
     also a problem (as below) for the command and source/. builtins. */
  if (subshell == 0 && (flags & CMD_IGNORE_RETURN) &&
	(builtin == eval_builtin || builtin == command_builtin || builtin == source_builtin))
    {
      begin_unwind_frame ("eval_builtin");
      unwind_protect_int (exit_immediately_on_error);
      error_trap = TRAP_STRING (ERROR_TRAP);
      if (error_trap)
	{
	  error_trap = savestring (error_trap);
	  add_unwind_protect (xfree, error_trap);
	  add_unwind_protect (set_error_trap, error_trap);
	  restore_default_signal (ERROR_TRAP);
	}
      exit_immediately_on_error = 0;
      eval_unwind = 1;
    }
  else
    eval_unwind = 0;

  /* The temporary environment for a builtin is supposed to apply to
     all commands executed by that builtin.  Currently, this is a
     problem only with the `unset', `source' and `eval' builtins. */

  isbltinenv = (builtin == source_builtin || builtin == eval_builtin || builtin == unset_builtin);

  if (isbltinenv)
    {
      if (subshell == 0)
	begin_unwind_frame ("builtin_env");

      if (temporary_env)
	{
	  push_scope (VC_BLTNENV, temporary_env);
	  if (subshell == 0)
	    add_unwind_protect (pop_scope, (flags & CMD_COMMAND_BUILTIN) ? 0 : "1");
          temporary_env = (HASH_TABLE *)NULL;	  
	}
    }

  /* `return' does a longjmp() back to a saved environment in execute_function.
     If a variable assignment list preceded the command, and the shell is
     running in POSIX mode, we need to merge that into the shell_variables
     table, since `return' is a POSIX special builtin. */
  if (posixly_correct && subshell == 0 && builtin == return_builtin && temporary_env)
    {
      begin_unwind_frame ("return_temp_env");
      add_unwind_protect (merge_temporary_env, (char *)NULL);
    }

  executing_builtin++;
  executing_command_builtin |= builtin == command_builtin;
  result = ((*builtin) (words->next));

  /* This shouldn't happen, but in case `return' comes back instead of
     longjmp'ing, we need to unwind. */
  if (posixly_correct && subshell == 0 && builtin == return_builtin && temporary_env)
    discard_unwind_frame ("return_temp_env");

  if (subshell == 0 && isbltinenv)
    run_unwind_frame ("builtin_env");

  if (eval_unwind)
    {
      exit_immediately_on_error += old_e_flag;
      if (error_trap)
	{
	  set_error_trap (error_trap);
	  xfree (error_trap);
	}
      discard_unwind_frame ("eval_builtin");
    }

#if 0
  /* XXX -- added 12/11 */
  terminate_immediately--;
#endif

  return (result);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\execute_cmd.c:4,026
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\execute_cmd.c:4,126
parsing error 
{
  int return_val, result;
  COMMAND *tc, *fc, *save_current;
  char *debug_trap, *error_trap, *return_trap;
#if defined (ARRAY_VARS)
  SHELL_VAR *funcname_v, *nfv, *bash_source_v, *bash_lineno_v;
  ARRAY *funcname_a;
  volatile ARRAY *bash_source_a;
  volatile ARRAY *bash_lineno_a;
#endif
  FUNCTION_DEF *shell_fn;
  char *sfile, *t;

  USE_VAR(fc);

  if (funcnest_max > 0 && funcnest >= funcnest_max)
    {
      internal_error ("%s: maximum function nesting level exceeded (%d)", var->name, funcnest);
      funcnest = 0;	/* XXX - should we reset it somewhere else? */
      jump_to_top_level (DISCARD);
    }

#if defined (ARRAY_VARS)
  GET_ARRAY_FROM_VAR ("FUNCNAME", funcname_v, funcname_a);
  GET_ARRAY_FROM_VAR ("BASH_SOURCE", bash_source_v, bash_source_a);
  GET_ARRAY_FROM_VAR ("BASH_LINENO", bash_lineno_v, bash_lineno_a);
#endif

  tc = (COMMAND *)copy_command (function_cell (var));
  if (tc && (flags & CMD_IGNORE_RETURN))
    tc->flags |= CMD_IGNORE_RETURN;

  if (subshell == 0)
    {
      begin_unwind_frame ("function_calling");
      push_context (var->name, subshell, temporary_env);
      add_unwind_protect (pop_context, (char *)NULL);
      unwind_protect_int (line_number);
      unwind_protect_int (return_catch_flag);
      unwind_protect_jmp_buf (return_catch);
      add_unwind_protect (dispose_command, (char *)tc);
      unwind_protect_pointer (this_shell_function);
      unwind_protect_int (loop_level);
      unwind_protect_int (funcnest);
    }
  else
    push_context (var->name, subshell, temporary_env);	/* don't unwind-protect for subshells */

  temporary_env = (HASH_TABLE *)NULL;

  this_shell_function = var;
  make_funcname_visible (1);

  debug_trap = TRAP_STRING(DEBUG_TRAP);
  error_trap = TRAP_STRING(ERROR_TRAP);
  return_trap = TRAP_STRING(RETURN_TRAP);
  
  /* The order of the unwind protects for debug_trap, error_trap and
     return_trap is important here!  unwind-protect commands are run
     in reverse order of registration.  If this causes problems, take
     out the xfree unwind-protect calls and live with the small memory leak. */

  /* function_trace_mode != 0 means that all functions inherit the DEBUG trap.
     if the function has the trace attribute set, it inherits the DEBUG trap */
  if (debug_trap && ((trace_p (var) == 0) && function_trace_mode == 0))
    {
      if (subshell == 0)
	{
	  debug_trap = savestring (debug_trap);
	  add_unwind_protect (xfree, debug_trap);
	  add_unwind_protect (set_debug_trap, debug_trap);
	}
      restore_default_signal (DEBUG_TRAP);
    }

  /* error_trace_mode != 0 means that functions inherit the ERR trap. */
  if (error_trap && error_trace_mode == 0)
    {
      if (subshell == 0)
	{
	  error_trap = savestring (error_trap);
	  add_unwind_protect (xfree, error_trap);
	  add_unwind_protect (set_error_trap, error_trap);
	}
      restore_default_signal (ERROR_TRAP);
    }

  /* Shell functions inherit the RETURN trap if function tracing is on
     globally or on individually for this function. */
#if 0
  if (return_trap && ((trace_p (var) == 0) && function_trace_mode == 0))
#else
  if (return_trap && (signal_in_progress (DEBUG_TRAP) || ((trace_p (var) == 0) && function_trace_mode == 0)))
#endif
    {
      if (subshell == 0)
	{
	  return_trap = savestring (return_trap);
	  add_unwind_protect (xfree, return_trap);
	  add_unwind_protect (set_return_trap, return_trap);
	}
      restore_default_signal (RETURN_TRAP);
    }
  
  funcnest++;
#if defined (ARRAY_VARS)
  /* This is quite similar to the code in shell.c and elsewhere. */
  shell_fn = find_function_def (this_shell_function->name);
  sfile = shell_fn ? shell_fn->source_file : "";
  array_push (funcname_a, this_shell_function->name);

  array_push (bash_source_a, sfile);
  t = itos (executing_line_number ());
  array_push (bash_lineno_a, t);
  free (t);
#endif

  /* The temporary environment for a function is supposed to apply to
     all commands executed within the function body. */

  remember_args (words->next, 1);

  /* Update BASH_ARGV and BASH_ARGC */
  if (debugging_mode)
    push_args (words->next);

  /* Number of the line on which the function body starts. */
  line_number = function_line_number = tc->line;

#if defined (JOB_CONTROL)
  if (subshell)
    stop_pipeline (async, (COMMAND *)NULL);
#endif

  fc = tc;

  return_catch_flag++;
  return_val = setjmp (return_catch);

  if (return_val)
    {
      result = return_catch_value;
      /* Run the RETURN trap in the function's context. */
      save_current = currently_executing_command;
      run_return_trap ();
      currently_executing_command = save_current;
    }
  else
    {
      /* Run the debug trap here so we can trap at the start of a function's
	 execution rather than the execution of the body's first command. */
      showing_function_line = 1;
      save_current = currently_executing_command;
      result = run_debug_trap ();
#if defined (DEBUGGER)
      /* In debugging mode, if the DEBUG trap returns a non-zero status, we
	 skip the command. */
      if (debugging_mode == 0 || result == EXECUTION_SUCCESS)
	{
	  showing_function_line = 0;
	  currently_executing_command = save_current;
	  result = execute_command_internal (fc, 0, NO_PIPE, NO_PIPE, fds_to_close);

	  /* Run the RETURN trap in the function's context */
	  save_current = currently_executing_command;
	  run_return_trap ();
	  currently_executing_command = save_current;
	}
#else
      result = execute_command_internal (fc, 0, NO_PIPE, NO_PIPE, fds_to_close);

      save_current = currently_executing_command;
      run_return_trap ();
      currently_executing_command = save_current;
#endif
      showing_function_line = 0;
    }

  /* Restore BASH_ARGC and BASH_ARGV */
  if (debugging_mode)
    pop_args ();

  if (subshell == 0)
    run_unwind_frame ("function_calling");

#if defined (ARRAY_VARS)
  /* These two variables cannot be unset, and cannot be affected by the
     function. */
  array_pop (bash_source_a);
  array_pop (bash_lineno_a);

  /* FUNCNAME can be unset, and so can potentially be changed by the
     function. */
  GET_ARRAY_FROM_VAR ("FUNCNAME", nfv, funcname_a);
  if (nfv == funcname_v)
    array_pop (funcname_a);
#endif
  
  if (variable_context == 0 || this_shell_function == 0)
    {
      make_funcname_visible (0);
#if defined (PROCESS_SUBSTITUTION)
      unlink_fifo_list ();
#endif
    }
  
  return (result);
}
warning: parse error {
  int return_val, result;
  COMMAND *tc, *fc, *save_current;
  char *debug_trap, *error_trap, *return_trap;
#if defined (ARRAY_VARS)
  SHELL_VAR *funcname_v, *nfv, *bash_source_v, *bash_lineno_v;
  ARRAY *funcname_a;
  volatile ARRAY *bash_source_a;
  volatile ARRAY *bash_lineno_a;
#endif
  FUNCTION_DEF *shell_fn;
  char *sfile, *t;

  USE_VAR(fc);

  if (funcnest_max > 0 && funcnest >= funcnest_max)
    {
      internal_error ("%s: maximum function nesting level exceeded (%d)", var->name, funcnest);
      funcnest = 0;	/* XXX - should we reset it somewhere else? */
      jump_to_top_level (DISCARD);
    }

#if defined (ARRAY_VARS)
  GET_ARRAY_FROM_VAR ("FUNCNAME", funcname_v, funcname_a);
  GET_ARRAY_FROM_VAR ("BASH_SOURCE", bash_source_v, bash_source_a);
  GET_ARRAY_FROM_VAR ("BASH_LINENO", bash_lineno_v, bash_lineno_a);
#endif

  tc = (COMMAND *)copy_command (function_cell (var));
  if (tc && (flags & CMD_IGNORE_RETURN))
    tc->flags |= CMD_IGNORE_RETURN;

  if (subshell == 0)
    {
      begin_unwind_frame ("function_calling");
      push_context (var->name, subshell, temporary_env);
      add_unwind_protect (pop_context, (char *)NULL);
      unwind_protect_int (line_number);
      unwind_protect_int (return_catch_flag);
      unwind_protect_jmp_buf (return_catch);
      add_unwind_protect (dispose_command, (char *)tc);
      unwind_protect_pointer (this_shell_function);
      unwind_protect_int (loop_level);
      unwind_protect_int (funcnest);
    }
  else
    push_context (var->name, subshell, temporary_env);	/* don't unwind-protect for subshells */

  temporary_env = (HASH_TABLE *)NULL;

  this_shell_function = var;
  make_funcname_visible (1);

  debug_trap = TRAP_STRING(DEBUG_TRAP);
  error_trap = TRAP_STRING(ERROR_TRAP);
  return_trap = TRAP_STRING(RETURN_TRAP);
  
  /* The order of the unwind protects for debug_trap, error_trap and
     return_trap is important here!  unwind-protect commands are run
     in reverse order of registration.  If this causes problems, take
     out the xfree unwind-protect calls and live with the small memory leak. */

  /* function_trace_mode != 0 means that all functions inherit the DEBUG trap.
     if the function has the trace attribute set, it inherits the DEBUG trap */
  if (debug_trap && ((trace_p (var) == 0) && function_trace_mode == 0))
    {
      if (subshell == 0)
	{
	  debug_trap = savestring (debug_trap);
	  add_unwind_protect (xfree, debug_trap);
	  add_unwind_protect (set_debug_trap, debug_trap);
	}
      restore_default_signal (DEBUG_TRAP);
    }

  /* error_trace_mode != 0 means that functions inherit the ERR trap. */
  if (error_trap && error_trace_mode == 0)
    {
      if (subshell == 0)
	{
	  error_trap = savestring (error_trap);
	  add_unwind_protect (xfree, error_trap);
	  add_unwind_protect (set_error_trap, error_trap);
	}
      restore_default_signal (ERROR_TRAP);
    }

  /* Shell functions inherit the RETURN trap if function tracing is on
     globally or on individually for this function. */
#if 0
  if (return_trap && ((trace_p (var) == 0) && function_trace_mode == 0))
#else
  if (return_trap && (signal_in_progress (DEBUG_TRAP) || ((trace_p (var) == 0) && function_trace_mode == 0)))
#endif
    {
      if (subshell == 0)
	{
	  return_trap = savestring (return_trap);
	  add_unwind_protect (xfree, return_trap);
	  add_unwind_protect (set_return_trap, return_trap);
	}
      restore_default_signal (RETURN_TRAP);
    }
  
  funcnest++;
#if defined (ARRAY_VARS)
  /* This is quite similar to the code in shell.c and elsewhere. */
  shell_fn = find_function_def (this_shell_function->name);
  sfile = shell_fn ? shell_fn->source_file : "";
  array_push (funcname_a, this_shell_function->name);

  array_push (bash_source_a, sfile);
  t = itos (executing_line_number ());
  array_push (bash_lineno_a, t);
  free (t);
#endif

  /* The temporary environment for a function is supposed to apply to
     all commands executed within the function body. */

  remember_args (words->next, 1);

  /* Update BASH_ARGV and BASH_ARGC */
  if (debugging_mode)
    push_args (words->next);

  /* Number of the line on which the function body starts. */
  line_number = function_line_number = tc->line;

#if defined (JOB_CONTROL)
  if (subshell)
    stop_pipeline (async, (COMMAND *)NULL);
#endif

  fc = tc;

  return_catch_flag++;
  return_val = setjmp (return_catch);

  if (return_val)
    {
      result = return_catch_value;
      /* Run the RETURN trap in the function's context. */
      save_current = currently_executing_command;
      run_return_trap ();
      currently_executing_command = save_current;
    }
  else
    {
      /* Run the debug trap here so we can trap at the start of a function's
	 execution rather than the execution of the body's first command. */
      showing_function_line = 1;
      save_current = currently_executing_command;
      result = run_debug_trap ();
#if defined (DEBUGGER)
      /* In debugging mode, if the DEBUG trap returns a non-zero status, we
	 skip the command. */
      if (debugging_mode == 0 || result == EXECUTION_SUCCESS)
	{
	  showing_function_line = 0;
	  currently_executing_command = save_current;
	  result = execute_command_internal (fc, 0, NO_PIPE, NO_PIPE, fds_to_close);

	  /* Run the RETURN trap in the function's context */
	  save_current = currently_executing_command;
	  run_return_trap ();
	  currently_executing_command = save_current;
	}
#else
      result = execute_command_internal (fc, 0, NO_PIPE, NO_PIPE, fds_to_close);

      save_current = currently_executing_command;
      run_return_trap ();
      currently_executing_command = save_current;
#endif
      showing_function_line = 0;
    }

  /* Restore BASH_ARGC and BASH_ARGV */
  if (debugging_mode)
    pop_args ();

  if (subshell == 0)
    run_unwind_frame ("function_calling");

#if defined (ARRAY_VARS)
  /* These two variables cannot be unset, and cannot be affected by the
     function. */
  array_pop (bash_source_a);
  array_pop (bash_lineno_a);

  /* FUNCNAME can be unset, and so can potentially be changed by the
     function. */
  GET_ARRAY_FROM_VAR ("FUNCNAME", nfv, funcname_a);
  if (nfv == funcname_v)
    array_pop (funcname_a);
#endif
  
  if (variable_context == 0 || this_shell_function == 0)
    {
      make_funcname_visible (0);
#if defined (PROCESS_SUBSTITUTION)
      unlink_fifo_list ();
#endif
    }
  
  return (result);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\execute_cmd.c:4,132
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\execute_cmd.c:4,344
parsing error 
{
  int ret;
  struct fd_bitmap *bitmap;

  bitmap = new_fd_bitmap (FD_BITMAP_DEFAULT_SIZE);
  begin_unwind_frame ("execute-shell-function");
  add_unwind_protect (dispose_fd_bitmap, (char *)bitmap);
      
  ret = execute_function (var, words, 0, bitmap, 0, 0);

  dispose_fd_bitmap (bitmap);
  discard_unwind_frame ("execute-shell-function");

  return ret;
}
warning: parse error {
  int ret;
  struct fd_bitmap *bitmap;

  bitmap = new_fd_bitmap (FD_BITMAP_DEFAULT_SIZE);
  begin_unwind_frame ("execute-shell-function");
  add_unwind_protect (dispose_fd_bitmap, (char *)bitmap);
      
  ret = execute_function (var, words, 0, bitmap, 0, 0);

  dispose_fd_bitmap (bitmap);
  discard_unwind_frame ("execute-shell-function");

  return ret;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\execute_cmd.c:4,347
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\execute_cmd.c:4,372
parsing error 
{
  int result, r, funcvalue;
#if defined (JOB_CONTROL)
  int jobs_hack;

  jobs_hack = (builtin == jobs_builtin) &&
		((subshell_environment & SUBSHELL_ASYNC) == 0 || pipe_out != NO_PIPE);
#endif

  /* A subshell is neither a login shell nor interactive. */
  login_shell = interactive = 0;

  if (async)
    subshell_environment |= SUBSHELL_ASYNC;
  if (pipe_in != NO_PIPE || pipe_out != NO_PIPE)
    subshell_environment |= SUBSHELL_PIPE;

  maybe_make_export_env ();	/* XXX - is this needed? */

#if defined (JOB_CONTROL)
  /* Eradicate all traces of job control after we fork the subshell, so
     all jobs begun by this subshell are in the same process group as
     the shell itself. */

  /* Allow the output of `jobs' to be piped. */
  if (jobs_hack)
    kill_current_pipeline ();
  else
    without_job_control ();

  set_sigchld_handler ();
#endif /* JOB_CONTROL */

  set_sigint_handler ();

  if (fds_to_close)
    close_fd_bitmap (fds_to_close);

  do_piping (pipe_in, pipe_out);

  if (do_redirections (redirects, RX_ACTIVE) != 0)
    exit (EXECUTION_FAILURE);

  if (builtin)
    {
      /* Give builtins a place to jump back to on failure,
	 so we don't go back up to main(). */
      result = setjmp (top_level);

      /* Give the return builtin a place to jump to when executed in a subshell
         or pipeline */
      funcvalue = 0;
      if (return_catch_flag && builtin == return_builtin)
        funcvalue = setjmp (return_catch);

      if (result == EXITPROG)
	exit (last_command_exit_value);
      else if (result)
	exit (EXECUTION_FAILURE);
      else if (funcvalue)
	exit (return_catch_value);
      else
	{
	  r = execute_builtin (builtin, words, flags, 1);
	  fflush (stdout);
	  if (r == EX_USAGE)
	    r = EX_BADUSAGE;
	  exit (r);
	}
    }
  else
    {
      r = execute_function (var, words, flags, fds_to_close, async, 1);
      fflush (stdout);
      exit (r);
    }
}
warning: parse error {
  int result, r, funcvalue;
#if defined (JOB_CONTROL)
  int jobs_hack;

  jobs_hack = (builtin == jobs_builtin) &&
		((subshell_environment & SUBSHELL_ASYNC) == 0 || pipe_out != NO_PIPE);
#endif

  /* A subshell is neither a login shell nor interactive. */
  login_shell = interactive = 0;

  if (async)
    subshell_environment |= SUBSHELL_ASYNC;
  if (pipe_in != NO_PIPE || pipe_out != NO_PIPE)
    subshell_environment |= SUBSHELL_PIPE;

  maybe_make_export_env ();	/* XXX - is this needed? */

#if defined (JOB_CONTROL)
  /* Eradicate all traces of job control after we fork the subshell, so
     all jobs begun by this subshell are in the same process group as
     the shell itself. */

  /* Allow the output of `jobs' to be piped. */
  if (jobs_hack)
    kill_current_pipeline ();
  else
    without_job_control ();

  set_sigchld_handler ();
#endif /* JOB_CONTROL */

  set_sigint_handler ();

  if (fds_to_close)
    close_fd_bitmap (fds_to_close);

  do_piping (pipe_in, pipe_out);

  if (do_redirections (redirects, RX_ACTIVE) != 0)
    exit (EXECUTION_FAILURE);

  if (builtin)
    {
      /* Give builtins a place to jump back to on failure,
	 so we don't go back up to main(). */
      result = setjmp (top_level);

      /* Give the return builtin a place to jump to when executed in a subshell
         or pipeline */
      funcvalue = 0;
      if (return_catch_flag && builtin == return_builtin)
        funcvalue = setjmp (return_catch);

      if (result == EXITPROG)
	exit (last_command_exit_value);
      else if (result)
	exit (EXECUTION_FAILURE);
      else if (funcvalue)
	exit (return_catch_value);
      else
	{
	  r = execute_builtin (builtin, words, flags, 1);
	  fflush (stdout);
	  if (r == EX_USAGE)
	    r = EX_BADUSAGE;
	  exit (r);
	}
    }
  else
    {
      r = execute_function (var, words, flags, fds_to_close, async, 1);
      fflush (stdout);
      exit (r);
    }
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\execute_cmd.c:4,380
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\execute_cmd.c:4,468
parsing error 
{
  int result;
  REDIRECT *saved_undo_list;
#if defined (PROCESS_SUBSTITUTION)
  int ofifo, nfifo, osize;
  char *ofifo_list;
#endif


#if defined (PROCESS_SUBSTITUTION)  
  ofifo = num_fifos ();
  ofifo_list = copy_fifo_list (&osize);
#endif

  if (do_redirections (redirects, RX_ACTIVE|RX_UNDOABLE) != 0)
    {
      cleanup_redirects (redirection_undo_list);
      redirection_undo_list = (REDIRECT *)NULL;
      dispose_exec_redirects ();
#if defined (PROCESS_SUBSTITUTION)
      free (ofifo_list);
#endif
      return (EX_REDIRFAIL);	/* was EXECUTION_FAILURE */
    }

  saved_undo_list = redirection_undo_list;

  /* Calling the "exec" builtin changes redirections forever. */
  if (builtin == exec_builtin)
    {
      dispose_redirects (saved_undo_list);
      saved_undo_list = exec_redirection_undo_list;
      exec_redirection_undo_list = (REDIRECT *)NULL;
    }
  else
    dispose_exec_redirects ();

  if (saved_undo_list)
    {
      begin_unwind_frame ("saved redirects");
      add_unwind_protect (cleanup_redirects, (char *)saved_undo_list);
    }

  redirection_undo_list = (REDIRECT *)NULL;

  if (builtin)
    result = execute_builtin (builtin, words, flags, 0);
  else
    result = execute_function (var, words, flags, fds_to_close, 0, 0);

  /* We do this before undoing the effects of any redirections. */
  fflush (stdout);
  fpurge (stdout);
  if (ferror (stdout))
    clearerr (stdout);  

  /* If we are executing the `command' builtin, but this_shell_builtin is
     set to `exec_builtin', we know that we have something like
     `command exec [redirection]', since otherwise `exec' would have
     overwritten the shell and we wouldn't get here.  In this case, we
     want to behave as if the `command' builtin had not been specified
     and preserve the redirections. */
  if (builtin == command_builtin && this_shell_builtin == exec_builtin)
    {
      int discard;

      discard = 0;
      if (saved_undo_list)
	{
	  dispose_redirects (saved_undo_list);
	  discard = 1;
	}
      redirection_undo_list = exec_redirection_undo_list;
      saved_undo_list = exec_redirection_undo_list = (REDIRECT *)NULL;      
      if (discard)
	discard_unwind_frame ("saved redirects");
    }

  if (saved_undo_list)
    {
      redirection_undo_list = saved_undo_list;
      discard_unwind_frame ("saved redirects");
    }

  if (redirection_undo_list)
    {
      cleanup_redirects (redirection_undo_list);
      redirection_undo_list = (REDIRECT *)NULL;
    }

#if defined (PROCESS_SUBSTITUTION)
  /* Close any FIFOs created by this builtin or function. */
  nfifo = num_fifos ();
  if (nfifo > ofifo)
    close_new_fifos (ofifo_list, osize);
  free (ofifo_list);
#endif

  return (result);
}
warning: parse error {
  int result;
  REDIRECT *saved_undo_list;
#if defined (PROCESS_SUBSTITUTION)
  int ofifo, nfifo, osize;
  char *ofifo_list;
#endif


#if defined (PROCESS_SUBSTITUTION)  
  ofifo = num_fifos ();
  ofifo_list = copy_fifo_list (&osize);
#endif

  if (do_redirections (redirects, RX_ACTIVE|RX_UNDOABLE) != 0)
    {
      cleanup_redirects (redirection_undo_list);
      redirection_undo_list = (REDIRECT *)NULL;
      dispose_exec_redirects ();
#if defined (PROCESS_SUBSTITUTION)
      free (ofifo_list);
#endif
      return (EX_REDIRFAIL);	/* was EXECUTION_FAILURE */
    }

  saved_undo_list = redirection_undo_list;

  /* Calling the "exec" builtin changes redirections forever. */
  if (builtin == exec_builtin)
    {
      dispose_redirects (saved_undo_list);
      saved_undo_list = exec_redirection_undo_list;
      exec_redirection_undo_list = (REDIRECT *)NULL;
    }
  else
    dispose_exec_redirects ();

  if (saved_undo_list)
    {
      begin_unwind_frame ("saved redirects");
      add_unwind_protect (cleanup_redirects, (char *)saved_undo_list);
    }

  redirection_undo_list = (REDIRECT *)NULL;

  if (builtin)
    result = execute_builtin (builtin, words, flags, 0);
  else
    result = execute_function (var, words, flags, fds_to_close, 0, 0);

  /* We do this before undoing the effects of any redirections. */
  fflush (stdout);
  fpurge (stdout);
  if (ferror (stdout))
    clearerr (stdout);  

  /* If we are executing the `command' builtin, but this_shell_builtin is
     set to `exec_builtin', we know that we have something like
     `command exec [redirection]', since otherwise `exec' would have
     overwritten the shell and we wouldn't get here.  In this case, we
     want to behave as if the `command' builtin had not been specified
     and preserve the redirections. */
  if (builtin == command_builtin && this_shell_builtin == exec_builtin)
    {
      int discard;

      discard = 0;
      if (saved_undo_list)
	{
	  dispose_redirects (saved_undo_list);
	  discard = 1;
	}
      redirection_undo_list = exec_redirection_undo_list;
      saved_undo_list = exec_redirection_undo_list = (REDIRECT *)NULL;      
      if (discard)
	discard_unwind_frame ("saved redirects");
    }

  if (saved_undo_list)
    {
      redirection_undo_list = saved_undo_list;
      discard_unwind_frame ("saved redirects");
    }

  if (redirection_undo_list)
    {
      cleanup_redirects (redirection_undo_list);
      redirection_undo_list = (REDIRECT *)NULL;
    }

#if defined (PROCESS_SUBSTITUTION)
  /* Close any FIFOs created by this builtin or function. */
  nfifo = num_fifos ();
  if (nfifo > ofifo)
    close_new_fifos (ofifo_list, osize);
  free (ofifo_list);
#endif

  return (result);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\execute_cmd.c:4,475
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\execute_cmd.c:4,620
parsing error 
{
  char *pathname, *command, **args;
  int nofork, result;
  pid_t pid;
  SHELL_VAR *hookf;
  WORD_LIST *wl;

  nofork = (cmdflags & CMD_NO_FORK);  /* Don't fork, just exec, if no pipes */
  pathname = words->word->word;

  result = EXECUTION_SUCCESS;
#if defined (RESTRICTED_SHELL)
  command = (char *)NULL;
  if (restricted && mbschr (pathname, '/'))
    {
      internal_error (_("%s: restricted: cannot specify `/' in command names"),
		    pathname);
      result = last_command_exit_value = EXECUTION_FAILURE;

      /* If we're not going to fork below, we must already be in a child
         process or a context in which it's safe to call exit(2).  */
      if (nofork && pipe_in == NO_PIPE && pipe_out == NO_PIPE)
	exit (last_command_exit_value);
      else
	goto parent_return;
    }
#endif /* RESTRICTED_SHELL */

  command = search_for_command (pathname);

  if (command)
    {
      maybe_make_export_env ();
      put_command_name_into_env (command);
    }

  /* We have to make the child before we check for the non-existence
     of COMMAND, since we want the error messages to be redirected. */
  /* If we can get away without forking and there are no pipes to deal with,
     don't bother to fork, just directly exec the command. */
  if (nofork && pipe_in == NO_PIPE && pipe_out == NO_PIPE)
    pid = 0;
  else
    pid = make_child (savestring (command_line), async);

  if (pid == 0)
    {
      int old_interactive;

#if 0
      /* This has been disabled for the time being. */
#if !defined (ARG_MAX) || ARG_MAX >= 10240
      if (posixly_correct == 0)
	put_gnu_argv_flags_into_env ((long)getpid (), glob_argv_flags);
#endif
#endif

      reset_terminating_signals ();	/* XXX */
      /* Cancel traps, in trap.c. */
      restore_original_signals ();

      /* restore_original_signals may have undone the work done
	 by make_child to ensure that SIGINT and SIGQUIT are ignored
	 in asynchronous children. */
      if (async)
	{
	  if ((cmdflags & CMD_STDIN_REDIR) &&
		pipe_in == NO_PIPE &&
		(stdin_redirects (redirects) == 0))
	    async_redirect_stdin ();
	  setup_async_signals ();
	}

      /* This functionality is now provided by close-on-exec of the
	 file descriptors manipulated by redirection and piping.
	 Some file descriptors still need to be closed in all children
	 because of the way bash does pipes; fds_to_close is a
	 bitmap of all such file descriptors. */
      if (fds_to_close)
	close_fd_bitmap (fds_to_close);

      do_piping (pipe_in, pipe_out);

      old_interactive = interactive;
      if (async)
	interactive = 0;

      subshell_environment = SUBSHELL_FORK;

      if (redirects && (do_redirections (redirects, RX_ACTIVE) != 0))
	{
#if defined (PROCESS_SUBSTITUTION)
	  /* Try to remove named pipes that may have been created as the
	     result of redirections. */
	  unlink_fifo_list ();
#endif /* PROCESS_SUBSTITUTION */
	  exit (EXECUTION_FAILURE);
	}

      if (async)
	interactive = old_interactive;

      if (command == 0)
	{
	  hookf = find_function (NOTFOUND_HOOK);
	  if (hookf == 0)
	    {
	      /* Make sure filenames are displayed using printable characters */
	      if (ansic_shouldquote (pathname))
		pathname = ansic_quote (pathname, 0, NULL);
	      internal_error (_("%s: command not found"), pathname);
	      exit (EX_NOTFOUND);	/* Posix.2 says the exit status is 127 */
	    }

	  wl = make_word_list (make_word (NOTFOUND_HOOK), words);
	  exit (execute_shell_function (hookf, wl));
	}

      /* Execve expects the command name to be in args[0].  So we
	 leave it there, in the same format that the user used to
	 type it in. */
      args = strvec_from_word_list (words, 0, 0, (int *)NULL);
      exit (shell_execve (command, args, export_env));
    }
  else
    {
parent_return:
      /* Make sure that the pipes are closed in the parent. */
      close_pipes (pipe_in, pipe_out);
#if defined (PROCESS_SUBSTITUTION) && defined (HAVE_DEV_FD)
      if (variable_context == 0)
        unlink_fifo_list ();
#endif
      FREE (command);
      return (result);
    }
}
warning: parse error {
  char *pathname, *command, **args;
  int nofork, result;
  pid_t pid;
  SHELL_VAR *hookf;
  WORD_LIST *wl;

  nofork = (cmdflags & CMD_NO_FORK);  /* Don't fork, just exec, if no pipes */
  pathname = words->word->word;

  result = EXECUTION_SUCCESS;
#if defined (RESTRICTED_SHELL)
  command = (char *)NULL;
  if (restricted && mbschr (pathname, '/'))
    {
      internal_error (_("%s: restricted: cannot specify `/' in command names"),
		    pathname);
      result = last_command_exit_value = EXECUTION_FAILURE;

      /* If we're not going to fork below, we must already be in a child
         process or a context in which it's safe to call exit(2).  */
      if (nofork && pipe_in == NO_PIPE && pipe_out == NO_PIPE)
	exit (last_command_exit_value);
      else
	goto parent_return;
    }
#endif /* RESTRICTED_SHELL */

  command = search_for_command (pathname);

  if (command)
    {
      maybe_make_export_env ();
      put_command_name_into_env (command);
    }

  /* We have to make the child before we check for the non-existence
     of COMMAND, since we want the error messages to be redirected. */
  /* If we can get away without forking and there are no pipes to deal with,
     don't bother to fork, just directly exec the command. */
  if (nofork && pipe_in == NO_PIPE && pipe_out == NO_PIPE)
    pid = 0;
  else
    pid = make_child (savestring (command_line), async);

  if (pid == 0)
    {
      int old_interactive;

#if 0
      /* This has been disabled for the time being. */
#if !defined (ARG_MAX) || ARG_MAX >= 10240
      if (posixly_correct == 0)
	put_gnu_argv_flags_into_env ((long)getpid (), glob_argv_flags);
#endif
#endif

      reset_terminating_signals ();	/* XXX */
      /* Cancel traps, in trap.c. */
      restore_original_signals ();

      /* restore_original_signals may have undone the work done
	 by make_child to ensure that SIGINT and SIGQUIT are ignored
	 in asynchronous children. */
      if (async)
	{
	  if ((cmdflags & CMD_STDIN_REDIR) &&
		pipe_in == NO_PIPE &&
		(stdin_redirects (redirects) == 0))
	    async_redirect_stdin ();
	  setup_async_signals ();
	}

      /* This functionality is now provided by close-on-exec of the
	 file descriptors manipulated by redirection and piping.
	 Some file descriptors still need to be closed in all children
	 because of the way bash does pipes; fds_to_close is a
	 bitmap of all such file descriptors. */
      if (fds_to_close)
	close_fd_bitmap (fds_to_close);

      do_piping (pipe_in, pipe_out);

      old_interactive = interactive;
      if (async)
	interactive = 0;

      subshell_environment = SUBSHELL_FORK;

      if (redirects && (do_redirections (redirects, RX_ACTIVE) != 0))
	{
#if defined (PROCESS_SUBSTITUTION)
	  /* Try to remove named pipes that may have been created as the
	     result of redirections. */
	  unlink_fifo_list ();
#endif /* PROCESS_SUBSTITUTION */
	  exit (EXECUTION_FAILURE);
	}

      if (async)
	interactive = old_interactive;

      if (command == 0)
	{
	  hookf = find_function (NOTFOUND_HOOK);
	  if (hookf == 0)
	    {
	      /* Make sure filenames are displayed using printable characters */
	      if (ansic_shouldquote (pathname))
		pathname = ansic_quote (pathname, 0, NULL);
	      internal_error (_("%s: command not found"), pathname);
	      exit (EX_NOTFOUND);	/* Posix.2 says the exit status is 127 */
	    }

	  wl = make_word_list (make_word (NOTFOUND_HOOK), words);
	  exit (execute_shell_function (hookf, wl));
	}

      /* Execve expects the command name to be in args[0].  So we
	 leave it there, in the same format that the user used to
	 type it in. */
      args = strvec_from_word_list (words, 0, 0, (int *)NULL);
      exit (shell_execve (command, args, export_env));
    }
  else
    {
parent_return:
      /* Make sure that the pipes are closed in the parent. */
      close_pipes (pipe_in, pipe_out);
#if defined (PROCESS_SUBSTITUTION) && defined (HAVE_DEV_FD)
      if (variable_context == 0)
        unlink_fifo_list ();
#endif
      FREE (command);
      return (result);
    }
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\execute_cmd.c:4,627
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\execute_cmd.c:4,783
parsing error 
{
  register int i;
  char *execname;
  int start;

  /* Find the name of the interpreter to exec. */
  for (i = 2; i < sample_len && whitespace (sample[i]); i++)
    ;

  for (start = i; STRINGCHAR(i); i++)
    ;

  execname = substring (sample, start, i);

  if (endp)
    *endp = i;
  return execname;
}
warning: parse error {
  register int i;
  char *execname;
  int start;

  /* Find the name of the interpreter to exec. */
  for (i = 2; i < sample_len && whitespace (sample[i]); i++)
    ;

  for (start = i; STRINGCHAR(i); i++)
    ;

  execname = substring (sample, start, i);

  if (endp)
    *endp = i;
  return execname;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\execute_cmd.c:4,786
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\execute_cmd.c:4,817
parsing error 
{
  char *execname, *firstarg;
  int i, start, size_increment, larry;

  /* Find the name of the interpreter to exec. */
  execname = getinterp (sample, sample_len, &i);
  size_increment = 1;

  /* Now the argument, if any. */
  for (firstarg = (char *)NULL, start = i; WHITECHAR(i); i++)
    ;

  /* If there is more text on the line, then it is an argument for the
     interpreter. */

  if (STRINGCHAR(i))  
    {
      for (start = i; STRINGCHAR(i); i++)
	;
      firstarg = substring ((char *)sample, start, i);
      size_increment = 2;
    }

  larry = strvec_len (args) + size_increment;
  args = strvec_resize (args, larry + 1);

  for (i = larry - 1; i; i--)
    args[i] = args[i - size_increment];

  args[0] = execname;
  if (firstarg)
    {
      args[1] = firstarg;
      args[2] = command;
    }
  else
    args[1] = command;

  args[larry] = (char *)NULL;

  return (shell_execve (execname, args, env));
}
warning: parse error {
  char *execname, *firstarg;
  int i, start, size_increment, larry;

  /* Find the name of the interpreter to exec. */
  execname = getinterp (sample, sample_len, &i);
  size_increment = 1;

  /* Now the argument, if any. */
  for (firstarg = (char *)NULL, start = i; WHITECHAR(i); i++)
    ;

  /* If there is more text on the line, then it is an argument for the
     interpreter. */

  if (STRINGCHAR(i))  
    {
      for (start = i; STRINGCHAR(i); i++)
	;
      firstarg = substring ((char *)sample, start, i);
      size_increment = 2;
    }

  larry = strvec_len (args) + size_increment;
  args = strvec_resize (args, larry + 1);

  for (i = larry - 1; i; i--)
    args[i] = args[i - size_increment];

  args[0] = execname;
  if (firstarg)
    {
      args[1] = firstarg;
      args[2] = command;
    }
  else
    args[1] = command;

  args[larry] = (char *)NULL;

  return (shell_execve (execname, args, env));
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\execute_cmd.c:4,822
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\execute_cmd.c:4,941
parsing error 
{
  int larray, i, fd;
  char sample[80];
  int sample_len;

  SETOSTYPE (0);		/* Some systems use for USG/POSIX semantics */
  execve (command, args, env);
  i = errno;			/* error from execve() */
  CHECK_TERMSIG;
  SETOSTYPE (1);

  /* If we get to this point, then start checking out the file.
     Maybe it is something we can hack ourselves. */
  if (i != ENOEXEC)
    {
      if (file_isdir (command))
#if defined (EISDIR)
	internal_error (_("%s: %s"), command, strerror (EISDIR));
#else
	internal_error (_("%s: is a directory"), command);
#endif
      else if (executable_file (command) == 0)
	{
	  errno = i;
	  file_error (command);
	}
      /* errors not involving the path argument to execve. */
      else if (i == E2BIG || i == ENOMEM)
	{
	  errno = i;
	  file_error (command);
	}
      else
	{
	  /* The file has the execute bits set, but the kernel refuses to
	     run it for some reason.  See why. */
#if defined (HAVE_HASH_BANG_EXEC)
	  READ_SAMPLE_BUF (command, sample, sample_len);
	  if (sample_len > 2 && sample[0] == '#' && sample[1] == '!')
	    {
	      char *interp;
	      int ilen;

	      interp = getinterp (sample, sample_len, (int *)NULL);
	      ilen = strlen (interp);
	      errno = i;
	      if (interp[ilen - 1] == '\r')
		{
		  interp = xrealloc (interp, ilen + 2);
		  interp[ilen - 1] = '^';
		  interp[ilen] = 'M';
		  interp[ilen + 1] = '\0';
		}
	      sys_error (_("%s: %s: bad interpreter"), command, interp ? interp : "");
	      FREE (interp);
	      return (EX_NOEXEC);
	    }
#endif
	  errno = i;
	  file_error (command);
	}
      return ((i == ENOENT) ? EX_NOTFOUND : EX_NOEXEC);	/* XXX Posix.2 says that exit status is 126 */
    }

  /* This file is executable.
     If it begins with #!, then help out people with losing operating
     systems.  Otherwise, check to see if it is a binary file by seeing
     if the contents of the first line (or up to 80 characters) are in the
     ASCII set.  If it's a text file, execute the contents as shell commands,
     otherwise return 126 (EX_BINARY_FILE). */
  READ_SAMPLE_BUF (command, sample, sample_len);

  if (sample_len == 0)
    return (EXECUTION_SUCCESS);

  /* Is this supposed to be an executable script?
     If so, the format of the line is "#! interpreter [argument]".
     A single argument is allowed.  The BSD kernel restricts
     the length of the entire line to 32 characters (32 bytes
     being the size of the BSD exec header), but we allow 80
     characters. */
  if (sample_len > 0)
    {
#if !defined (HAVE_HASH_BANG_EXEC)
      if (sample_len > 2 && sample[0] == '#' && sample[1] == '!')
	return (execute_shell_script (sample, sample_len, command, args, env));
      else
#endif
      if (check_binary_file (sample, sample_len))
	{
	  internal_error (_("%s: cannot execute binary file"), command);
	  return (EX_BINARY_FILE);
	}
    }

  /* We have committed to attempting to execute the contents of this file
     as shell commands. */

  initialize_subshell ();

  set_sigint_handler ();

  /* Insert the name of this shell into the argument list. */
  larray = strvec_len (args) + 1;
  args = strvec_resize (args, larray + 1);

  for (i = larray - 1; i; i--)
    args[i] = args[i - 1];

  args[0] = shell_name;
  args[1] = command;
  args[larray] = (char *)NULL;

  if (args[0][0] == '-')
    args[0]++;

#if defined (RESTRICTED_SHELL)
  if (restricted)
    change_flag ('r', FLAG_OFF);
#endif

  if (subshell_argv)
    {
      /* Can't free subshell_argv[0]; that is shell_name. */
      for (i = 1; i < subshell_argc; i++)
	free (subshell_argv[i]);
      free (subshell_argv);
    }

  dispose_command (currently_executing_command);	/* XXX */
  currently_executing_command = (COMMAND *)NULL;

  subshell_argc = larray;
  subshell_argv = args;
  subshell_envp = env;

  unbind_args ();	/* remove the positional parameters */

  longjmp (subshell_top_level, 1);
  /*NOTREACHED*/
}
warning: parse error {
  int larray, i, fd;
  char sample[80];
  int sample_len;

  SETOSTYPE (0);		/* Some systems use for USG/POSIX semantics */
  execve (command, args, env);
  i = errno;			/* error from execve() */
  CHECK_TERMSIG;
  SETOSTYPE (1);

  /* If we get to this point, then start checking out the file.
     Maybe it is something we can hack ourselves. */
  if (i != ENOEXEC)
    {
      if (file_isdir (command))
#if defined (EISDIR)
	internal_error (_("%s: %s"), command, strerror (EISDIR));
#else
	internal_error (_("%s: is a directory"), command);
#endif
      else if (executable_file (command) == 0)
	{
	  errno = i;
	  file_error (command);
	}
      /* errors not involving the path argument to execve. */
      else if (i == E2BIG || i == ENOMEM)
	{
	  errno = i;
	  file_error (command);
	}
      else
	{
	  /* The file has the execute bits set, but the kernel refuses to
	     run it for some reason.  See why. */
#if defined (HAVE_HASH_BANG_EXEC)
	  READ_SAMPLE_BUF (command, sample, sample_len);
	  if (sample_len > 2 && sample[0] == '#' && sample[1] == '!')
	    {
	      char *interp;
	      int ilen;

	      interp = getinterp (sample, sample_len, (int *)NULL);
	      ilen = strlen (interp);
	      errno = i;
	      if (interp[ilen - 1] == '\r')
		{
		  interp = xrealloc (interp, ilen + 2);
		  interp[ilen - 1] = '^';
		  interp[ilen] = 'M';
		  interp[ilen + 1] = '\0';
		}
	      sys_error (_("%s: %s: bad interpreter"), command, interp ? interp : "");
	      FREE (interp);
	      return (EX_NOEXEC);
	    }
#endif
	  errno = i;
	  file_error (command);
	}
      return ((i == ENOENT) ? EX_NOTFOUND : EX_NOEXEC);	/* XXX Posix.2 says that exit status is 126 */
    }

  /* This file is executable.
     If it begins with #!, then help out people with losing operating
     systems.  Otherwise, check to see if it is a binary file by seeing
     if the contents of the first line (or up to 80 characters) are in the
     ASCII set.  If it's a text file, execute the contents as shell commands,
     otherwise return 126 (EX_BINARY_FILE). */
  READ_SAMPLE_BUF (command, sample, sample_len);

  if (sample_len == 0)
    return (EXECUTION_SUCCESS);

  /* Is this supposed to be an executable script?
     If so, the format of the line is "#! interpreter [argument]".
     A single argument is allowed.  The BSD kernel restricts
     the length of the entire line to 32 characters (32 bytes
     being the size of the BSD exec header), but we allow 80
     characters. */
  if (sample_len > 0)
    {
#if !defined (HAVE_HASH_BANG_EXEC)
      if (sample_len > 2 && sample[0] == '#' && sample[1] == '!')
	return (execute_shell_script (sample, sample_len, command, args, env));
      else
#endif
      if (check_binary_file (sample, sample_len))
	{
	  internal_error (_("%s: cannot execute binary file"), command);
	  return (EX_BINARY_FILE);
	}
    }

  /* We have committed to attempting to execute the contents of this file
     as shell commands. */

  initialize_subshell ();

  set_sigint_handler ();

  /* Insert the name of this shell into the argument list. */
  larray = strvec_len (args) + 1;
  args = strvec_resize (args, larray + 1);

  for (i = larray - 1; i; i--)
    args[i] = args[i - 1];

  args[0] = shell_name;
  args[1] = command;
  args[larray] = (char *)NULL;

  if (args[0][0] == '-')
    args[0]++;

#if defined (RESTRICTED_SHELL)
  if (restricted)
    change_flag ('r', FLAG_OFF);
#endif

  if (subshell_argv)
    {
      /* Can't free subshell_argv[0]; that is shell_name. */
      for (i = 1; i < subshell_argc; i++)
	free (subshell_argv[i]);
      free (subshell_argv);
    }

  dispose_command (currently_executing_command);	/* XXX */
  currently_executing_command = (COMMAND *)NULL;

  subshell_argc = larray;
  subshell_argv = args;
  subshell_envp = env;

  unbind_args ();	/* remove the positional parameters */

  longjmp (subshell_top_level, 1);
  /*NOTREACHED*/
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\execute_cmd.c:4,944
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\execute_cmd.c:5,087
parsing error 
{
  SHELL_VAR *var;

  if (check_identifier (name, posixly_correct) == 0)
    {
      if (posixly_correct && interactive_shell == 0)
	{
	  last_command_exit_value = EX_BADUSAGE;
	  jump_to_top_level (ERREXIT);
	}
      return (EXECUTION_FAILURE);
    }

  var = find_function (name->word);
  if (var && (readonly_p (var) || noassign_p (var)))
    {
      if (readonly_p (var))
	internal_error (_("%s: readonly function"), var->name);
      return (EXECUTION_FAILURE);
    }

  bind_function (name->word, function);
  return (EXECUTION_SUCCESS);
}
warning: parse error {
  SHELL_VAR *var;

  if (check_identifier (name, posixly_correct) == 0)
    {
      if (posixly_correct && interactive_shell == 0)
	{
	  last_command_exit_value = EX_BADUSAGE;
	  jump_to_top_level (ERREXIT);
	}
      return (EXECUTION_FAILURE);
    }

  var = find_function (name->word);
  if (var && (readonly_p (var) || noassign_p (var)))
    {
      if (readonly_p (var))
	internal_error (_("%s: readonly function"), var->name);
      return (EXECUTION_FAILURE);
    }

  bind_function (name->word, function);
  return (EXECUTION_SUCCESS);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\execute_cmd.c:5,090
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\execute_cmd.c:5,133
parsing error 
{
  if (in >= 0)
    close (in);
  if (out >= 0)
    close (out);
}
warning: parse error {
  if (in >= 0)
    close (in);
  if (out >= 0)
    close (out);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\execute_cmd.c:5,135
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\execute_cmd.c:5,143
parsing error 
{
  sys_error (_("cannot duplicate fd %d to fd %d"), oldd, newd);
}
warning: parse error {
  sys_error (_("cannot duplicate fd %d to fd %d"), oldd, newd);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\execute_cmd.c:5,145
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\execute_cmd.c:5,152
parsing error 
{
  if (pipe_in != NO_PIPE)
    {
      if (dup2 (pipe_in, 0) < 0)
	dup_error (pipe_in, 0);
      if (pipe_in > 0)
	close (pipe_in);
#ifdef __CYGWIN__
      /* Let stdio know the fd may have changed from text to binary mode. */
      freopen (NULL, "r", stdin);
#endif /* __CYGWIN__ */
    }
  if (pipe_out != NO_PIPE)
    {
      if (pipe_out != REDIRECT_BOTH)
	{
	  if (dup2 (pipe_out, 1) < 0)
	    dup_error (pipe_out, 1);
	  if (pipe_out == 0 || pipe_out > 1)
	    close (pipe_out);
	}
      else
	{
	  if (dup2 (1, 2) < 0)
	    dup_error (1, 2);
	}
#ifdef __CYGWIN__
      /* Let stdio know the fd may have changed from text to binary mode, and
	 make sure to preserve stdout line buffering. */
      freopen (NULL, "w", stdout);
      sh_setlinebuf (stdout);
#endif /* __CYGWIN__ */
    }
}
warning: parse error {
  if (pipe_in != NO_PIPE)
    {
      if (dup2 (pipe_in, 0) < 0)
	dup_error (pipe_in, 0);
      if (pipe_in > 0)
	close (pipe_in);
#ifdef __CYGWIN__
      /* Let stdio know the fd may have changed from text to binary mode. */
      freopen (NULL, "r", stdin);
#endif /* __CYGWIN__ */
    }
  if (pipe_out != NO_PIPE)
    {
      if (pipe_out != REDIRECT_BOTH)
	{
	  if (dup2 (pipe_out, 1) < 0)
	    dup_error (pipe_out, 1);
	  if (pipe_out == 0 || pipe_out > 1)
	    close (pipe_out);
	}
      else
	{
	  if (dup2 (1, 2) < 0)
	    dup_error (1, 2);
	}
#ifdef __CYGWIN__
      /* Let stdio know the fd may have changed from text to binary mode, and
	 make sure to preserve stdout line buffering. */
      freopen (NULL, "w", stdout);
      sh_setlinebuf (stdout);
#endif /* __CYGWIN__ */
    }
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\execute_cmd.c:5,154
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\expr.c...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\bashansi.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\chartypes.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\bashintl.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\shell.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\expr.c:309
parsing error 
{
  (void)bind_int_variable (lhs, rhs);
  stupidly_hack_special_variables (lhs);
}
warning: parse error {
  (void)bind_int_variable (lhs, rhs);
  stupidly_hack_special_variables (lhs);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\expr.c:311
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\expr.c:319
parsing error 
{
  char *lhs, *vname;
  size_t llen;
  char ibuf[INT_STRLEN_BOUND (arrayind_t) + 1], *istr;

  istr = fmtumax (ind, 10, ibuf, sizeof (ibuf), 0);
  vname = array_variable_name (tok, (char **)NULL, (int *)NULL);

  llen = strlen (vname) + sizeof (ibuf) + 3;
  lhs = xmalloc (llen);

  sprintf (lhs, "%s[%s]", vname, istr);		/* XXX */
  
  expr_bind_variable (lhs, rhs);
/*itrace("expr_bind_array_element: %s=%s", lhs, rhs);*/
  free (vname);
  free (lhs);
}
warning: parse error {
  char *lhs, *vname;
  size_t llen;
  char ibuf[INT_STRLEN_BOUND (arrayind_t) + 1], *istr;

  istr = fmtumax (ind, 10, ibuf, sizeof (ibuf), 0);
  vname = array_variable_name (tok, (char **)NULL, (int *)NULL);

  llen = strlen (vname) + sizeof (ibuf) + 3;
  lhs = xmalloc (llen);

  sprintf (lhs, "%s[%s]", vname, istr);		/* XXX */
  
  expr_bind_variable (lhs, rhs);
/*itrace("expr_bind_array_element: %s=%s", lhs, rhs);*/
  free (vname);
  free (lhs);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\expr.c:323
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\expr.c:356
parsing error 
{
  intmax_t val;
  int c;
  procenv_t oevalbuf;

  val = 0;
  noeval = 0;

  FASTCOPY (evalbuf, oevalbuf, sizeof (evalbuf));

  c = setjmp (evalbuf);

  if (c)
    {
      FREE (tokstr);
      FREE (expression);
      tokstr = expression = (char *)NULL;

      expr_unwind ();

      if (validp)
	*validp = 0;
      return (0);
    }

  val = subexpr (expr);

  if (validp)
    *validp = 1;

  FASTCOPY (oevalbuf, evalbuf, sizeof (evalbuf));

  return (val);
}
warning: parse error {
  intmax_t val;
  int c;
  procenv_t oevalbuf;

  val = 0;
  noeval = 0;

  FASTCOPY (evalbuf, oevalbuf, sizeof (evalbuf));

  c = setjmp (evalbuf);

  if (c)
    {
      FREE (tokstr);
      FREE (expression);
      tokstr = expression = (char *)NULL;

      expr_unwind ();

      if (validp)
	*validp = 0;
      return (0);
    }

  val = subexpr (expr);

  if (validp)
    *validp = 1;

  FASTCOPY (oevalbuf, evalbuf, sizeof (evalbuf));

  return (val);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\expr.c:359
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\expr.c:395
parsing error 
{
  intmax_t val;
  char *p;

  for (p = expr; p && *p && cr_whitespace (*p); p++)
    ;

  if (p == NULL || *p == '\0')
    return (0);

  pushexp ();
  expression = savestring (expr);
  tp = expression;

  curtok = lasttok = 0;
  tokstr = (char *)NULL;
  tokval = 0;
  init_lvalue (&curlval);
  lastlval = curlval;

  readtok ();

  val = EXP_HIGHEST ();

  if (curtok != 0)
    evalerror (_("syntax error in expression"));

  FREE (tokstr);
  FREE (expression);

  popexp ();

  return val;
}
warning: parse error {
  intmax_t val;
  char *p;

  for (p = expr; p && *p && cr_whitespace (*p); p++)
    ;

  if (p == NULL || *p == '\0')
    return (0);

  pushexp ();
  expression = savestring (expr);
  tp = expression;

  curtok = lasttok = 0;
  tokstr = (char *)NULL;
  tokval = 0;
  init_lvalue (&curlval);
  lastlval = curlval;

  readtok ();

  val = EXP_HIGHEST ();

  if (curtok != 0)
    evalerror (_("syntax error in expression"));

  FREE (tokstr);
  FREE (expression);

  popexp ();

  return val;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\expr.c:397
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\expr.c:965
parsing error 
{
  lv->tokstr = 0;
  lv->tokvar = 0;
  lv->tokval = lv->ind = -1;
}
warning: parse error {
  lv->tokstr = 0;
  lv->tokvar = 0;
  lv->tokval = lv->ind = -1;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\expr.c:967
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\expr.c:984
parsing error 
{
  free (lv);		/* should be inlined */
}
warning: parse error {
  free (lv);		/* should be inlined */
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\expr.c:986
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\expr.c:991
parsing error 
{
  SHELL_VAR *v;
  char *value;
  intmax_t tval;
#if defined (ARRAY_VARS)
  arrayind_t ind;
#endif

  /* [[[[[ */
#if defined (ARRAY_VARS)
  v = (e == ']') ? array_variable_part (tok, (char **)0, (int *)0) : find_variable (tok);
#else
  v = find_variable (tok);
#endif

  if ((v == 0 || invisible_p (v)) && unbound_vars_is_error)
    {
#if defined (ARRAY_VARS)
      value = (e == ']') ? array_variable_name (tok, (char **)0, (int *)0) : tok;
#else
      value = tok;
#endif

      last_command_exit_value = EXECUTION_FAILURE;
      err_unboundvar (value);

#if defined (ARRAY_VARS)
      if (e == ']')
	FREE (value);	/* array_variable_name returns new memory */
#endif

      if (interactive_shell)
	{
	  expr_unwind ();
	  top_level_cleanup ();
	  jump_to_top_level (DISCARD);
	}
      else
	jump_to_top_level (FORCE_EOF);
    }

  ind = -1;
#if defined (ARRAY_VARS)
  /* Second argument of 0 to get_array_value means that we don't allow
     references like array[@].  In this case, get_array_value is just
     like get_variable_value in that it does not return newly-allocated
     memory or quote the results. */
  value = (e == ']') ? get_array_value (tok, 0, (int *)NULL, &ind) : get_variable_value (v);
#else
  value = get_variable_value (v);
#endif

  tval = (value && *value) ? subexpr (value) : 0;

  if (lvalue)
    {
      lvalue->tokstr = tok;	/* XXX */
      lvalue->tokval = tval;
      lvalue->tokvar = v;	/* XXX */
      lvalue->ind = ind;
    }
	  
  return (tval);
}
warning: parse error {
  SHELL_VAR *v;
  char *value;
  intmax_t tval;
#if defined (ARRAY_VARS)
  arrayind_t ind;
#endif

  /* [[[[[ */
#if defined (ARRAY_VARS)
  v = (e == ']') ? array_variable_part (tok, (char **)0, (int *)0) : find_variable (tok);
#else
  v = find_variable (tok);
#endif

  if ((v == 0 || invisible_p (v)) && unbound_vars_is_error)
    {
#if defined (ARRAY_VARS)
      value = (e == ']') ? array_variable_name (tok, (char **)0, (int *)0) : tok;
#else
      value = tok;
#endif

      last_command_exit_value = EXECUTION_FAILURE;
      err_unboundvar (value);

#if defined (ARRAY_VARS)
      if (e == ']')
	FREE (value);	/* array_variable_name returns new memory */
#endif

      if (interactive_shell)
	{
	  expr_unwind ();
	  top_level_cleanup ();
	  jump_to_top_level (DISCARD);
	}
      else
	jump_to_top_level (FORCE_EOF);
    }

  ind = -1;
#if defined (ARRAY_VARS)
  /* Second argument of 0 to get_array_value means that we don't allow
     references like array[@].  In this case, get_array_value is just
     like get_variable_value in that it does not return newly-allocated
     memory or quote the results. */
  value = (e == ']') ? get_array_value (tok, 0, (int *)NULL, &ind) : get_variable_value (v);
#else
  value = get_variable_value (v);
#endif

  tval = (value && *value) ? subexpr (value) : 0;

  if (lvalue)
    {
      lvalue->tokstr = tok;	/* XXX */
      lvalue->tokval = tval;
      lvalue->tokvar = v;	/* XXX */
      lvalue->ind = ind;
    }
	  
  return (tval);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\expr.c:995
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\expr.c:1,061
parsing error 
{
  switch (c)
    {
    case EQEQ:
    case NEQ:
    case LEQ:
    case GEQ:
    case LAND:
    case LOR:
    case LSH:
    case RSH:
    case OP_ASSIGN:
    case COND:
    case POWER:
    case PREINC:
    case PREDEC:
    case POSTINC:
    case POSTDEC:
      return 1;
    default:
      return 0;
    }
}
warning: parse error {
  switch (c)
    {
    case EQEQ:
    case NEQ:
    case LEQ:
    case GEQ:
    case LAND:
    case LOR:
    case LSH:
    case RSH:
    case OP_ASSIGN:
    case COND:
    case POWER:
    case PREINC:
    case PREDEC:
    case POSTINC:
    case POSTDEC:
      return 1;
    default:
      return 0;
    }
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\expr.c:1,063
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\expr.c:1,088
parsing error 
{
  switch (c)
    {
    case EQ:
    case GT:
    case LT:
    case PLUS:
    case MINUS:
    case MUL:
    case DIV:
    case MOD:
    case NOT:
    case LPAR:
    case RPAR:
    case BAND:
    case BOR:
    case BXOR:
    case BNOT:
      return 1;		/* operator tokens */
    case QUES:
    case COL:
    case COMMA:
      return 1;		/* questionable */
    default:
      return 0;		/* anything else is invalid */
    }
}
warning: parse error {
  switch (c)
    {
    case EQ:
    case GT:
    case LT:
    case PLUS:
    case MINUS:
    case MUL:
    case DIV:
    case MOD:
    case NOT:
    case LPAR:
    case RPAR:
    case BAND:
    case BOR:
    case BXOR:
    case BNOT:
      return 1;		/* operator tokens */
    case QUES:
    case COL:
    case COMMA:
      return 1;		/* questionable */
    default:
      return 0;		/* anything else is invalid */
    }
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\expr.c:1,090
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\expr.c:1,301
parsing error 
{
  char *name, *t;

  name = this_command_name;
  for (t = expression; whitespace (*t); t++)
    ;
  internal_error (_("%s%s%s: %s (error token is \"%s\")"),
		   name ? name : "", name ? ": " : "", t,
		   msg, (lasttp && *lasttp) ? lasttp : "");
  longjmp (evalbuf, 1);
}
warning: parse error {
  char *name, *t;

  name = this_command_name;
  for (t = expression; whitespace (*t); t++)
    ;
  internal_error (_("%s%s%s: %s (error token is \"%s\")"),
		   name ? name : "", name ? ": " : "", t,
		   msg, (lasttp && *lasttp) ? lasttp : "");
  longjmp (evalbuf, 1);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\expr.c:1,302
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\expr.c:1,326
parsing error 
{
  register char *s;
  register unsigned char c;
  int base, foundbase;
  intmax_t val;

  s = num;

  base = 10;
  foundbase = 0;
  if (*s == '0')
    {
      s++;

      if (*s == '\0')
	return 0;

       /* Base 16? */
      if (*s == 'x' || *s == 'X')
	{
	  base = 16;
	  s++;
	}
      else
	base = 8;
      foundbase++;
    }

  val = 0;
  for (c = *s++; c; c = *s++)
    {
      if (c == '#')
	{
	  if (foundbase)
	    evalerror (_("invalid number"));

	  /* Illegal base specifications raise an evaluation error. */
	  if (val < 2 || val > 64)
	    evalerror (_("invalid arithmetic base"));

	  base = val;
	  val = 0;
	  foundbase++;
	}
      else if (ISALNUM(c) || (c == '_') || (c == '@'))
	{
	  if (DIGIT(c))
	    c = TODIGIT(c);
	  else if (c >= 'a' && c <= 'z')
	    c -= 'a' - 10;
	  else if (c >= 'A' && c <= 'Z')
	    c -= 'A' - ((base <= 36) ? 10 : 36);
	  else if (c == '@')
	    c = 62;
	  else if (c == '_')
	    c = 63;

	  if (c >= base)
	    evalerror (_("value too great for base"));

	  val = (val * base) + c;
	}
      else
	break;
    }

  return (val);
}
warning: parse error {
  register char *s;
  register unsigned char c;
  int base, foundbase;
  intmax_t val;

  s = num;

  base = 10;
  foundbase = 0;
  if (*s == '0')
    {
      s++;

      if (*s == '\0')
	return 0;

       /* Base 16? */
      if (*s == 'x' || *s == 'X')
	{
	  base = 16;
	  s++;
	}
      else
	base = 8;
      foundbase++;
    }

  val = 0;
  for (c = *s++; c; c = *s++)
    {
      if (c == '#')
	{
	  if (foundbase)
	    evalerror (_("invalid number"));

	  /* Illegal base specifications raise an evaluation error. */
	  if (val < 2 || val > 64)
	    evalerror (_("invalid arithmetic base"));

	  base = val;
	  val = 0;
	  foundbase++;
	}
      else if (ISALNUM(c) || (c == '_') || (c == '@'))
	{
	  if (DIGIT(c))
	    c = TODIGIT(c);
	  else if (c >= 'a' && c <= 'z')
	    c -= 'a' - 10;
	  else if (c >= 'A' && c <= 'Z')
	    c -= 'A' - ((base <= 36) ? 10 : 36);
	  else if (c == '@')
	    c = 62;
	  else if (c == '_')
	    c = 63;

	  if (c >= base)
	    evalerror (_("value too great for base"));

	  val = (val * base) + c;
	}
      else
	break;
    }

  return (val);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\expr.c:1,328
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\findcmd.c...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\chartypes.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\bashtypes.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\filecntl.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\posixstat.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\bashansi.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\memalloc.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\shell.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\flags.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\hashlib.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\pathexp.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\hashcmd.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\findcmd.h...skip
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\findcmd.c:85
parsing error 
{
  struct stat finfo;
  int r;

  /* Determine whether this file exists or not. */
  if (stat (name, &finfo) < 0)
    return (0);

  /* If the file is a directory, then it is not "executable" in the
     sense of the shell. */
  if (S_ISDIR (finfo.st_mode))
    return (FS_EXISTS|FS_DIRECTORY);

  r = FS_EXISTS;

#if defined (HAVE_EACCESS)
  /* Use eaccess(2) if we have it to take things like ACLs and other
     file access mechanisms into account.  eaccess uses the effective
     user and group IDs, not the real ones.  We could use sh_eaccess,
     but we don't want any special treatment for /dev/fd. */
  if (eaccess (name, X_OK) == 0)
    r |= FS_EXECABLE;
  if (eaccess (name, R_OK) == 0)
    r |= FS_READABLE;

  return r;
#elif defined (AFS)
  /* We have to use access(2) to determine access because AFS does not
     support Unix file system semantics.  This may produce wrong
     answers for non-AFS files when ruid != euid.  I hate AFS. */
  if (access (name, X_OK) == 0)
    r |= FS_EXECABLE;
  if (access (name, R_OK) == 0)
    r |= FS_READABLE;

  return r;
#else /* !HAVE_EACCESS && !AFS */

  /* Find out if the file is actually executable.  By definition, the
     only other criteria is that the file has an execute bit set that
     we can use.  The same with whether or not a file is readable. */

  /* Root only requires execute permission for any of owner, group or
     others to be able to exec a file, and can read any file. */
  if (current_user.euid == (uid_t)0)
    {
      r |= FS_READABLE;
      if (finfo.st_mode & S_IXUGO)
	r |= FS_EXECABLE;
      return r;
    }

  /* If we are the owner of the file, the owner bits apply. */
  if (current_user.euid == finfo.st_uid)
    {
      if (finfo.st_mode & S_IXUSR)
	r |= FS_EXECABLE;
      if (finfo.st_mode & S_IRUSR)
	r |= FS_READABLE;
    }

  /* If we are in the owning group, the group permissions apply. */
  else if (group_member (finfo.st_gid))
    {
      if (finfo.st_mode & S_IXGRP)
	r |= FS_EXECABLE;
      if (finfo.st_mode & S_IRGRP)
	r |= FS_READABLE;
    }

  /* Else we check whether `others' have permission to execute the file */
  else
    {
      if (finfo.st_mode & S_IXOTH)
	r |= FS_EXECABLE;
      if (finfo.st_mode & S_IROTH)
	r |= FS_READABLE;
    }

  return r;
#endif /* !AFS */
}
warning: parse error {
  struct stat finfo;
  int r;

  /* Determine whether this file exists or not. */
  if (stat (name, &finfo) < 0)
    return (0);

  /* If the file is a directory, then it is not "executable" in the
     sense of the shell. */
  if (S_ISDIR (finfo.st_mode))
    return (FS_EXISTS|FS_DIRECTORY);

  r = FS_EXISTS;

#if defined (HAVE_EACCESS)
  /* Use eaccess(2) if we have it to take things like ACLs and other
     file access mechanisms into account.  eaccess uses the effective
     user and group IDs, not the real ones.  We could use sh_eaccess,
     but we don't want any special treatment for /dev/fd. */
  if (eaccess (name, X_OK) == 0)
    r |= FS_EXECABLE;
  if (eaccess (name, R_OK) == 0)
    r |= FS_READABLE;

  return r;
#elif defined (AFS)
  /* We have to use access(2) to determine access because AFS does not
     support Unix file system semantics.  This may produce wrong
     answers for non-AFS files when ruid != euid.  I hate AFS. */
  if (access (name, X_OK) == 0)
    r |= FS_EXECABLE;
  if (access (name, R_OK) == 0)
    r |= FS_READABLE;

  return r;
#else /* !HAVE_EACCESS && !AFS */

  /* Find out if the file is actually executable.  By definition, the
     only other criteria is that the file has an execute bit set that
     we can use.  The same with whether or not a file is readable. */

  /* Root only requires execute permission for any of owner, group or
     others to be able to exec a file, and can read any file. */
  if (current_user.euid == (uid_t)0)
    {
      r |= FS_READABLE;
      if (finfo.st_mode & S_IXUGO)
	r |= FS_EXECABLE;
      return r;
    }

  /* If we are the owner of the file, the owner bits apply. */
  if (current_user.euid == finfo.st_uid)
    {
      if (finfo.st_mode & S_IXUSR)
	r |= FS_EXECABLE;
      if (finfo.st_mode & S_IRUSR)
	r |= FS_READABLE;
    }

  /* If we are in the owning group, the group permissions apply. */
  else if (group_member (finfo.st_gid))
    {
      if (finfo.st_mode & S_IXGRP)
	r |= FS_EXECABLE;
      if (finfo.st_mode & S_IRGRP)
	r |= FS_READABLE;
    }

  /* Else we check whether `others' have permission to execute the file */
  else
    {
      if (finfo.st_mode & S_IXOTH)
	r |= FS_EXECABLE;
      if (finfo.st_mode & S_IROTH)
	r |= FS_READABLE;
    }

  return r;
#endif /* !AFS */
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\findcmd.c:86
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\findcmd.c:175
parsing error 
{
  int s;

  s = file_status (file);
#if defined EISDIR
  if (s & FS_DIRECTORY)
    errno = EISDIR;	/* let's see if we can improve error messages */
#endif
  return ((s & FS_EXECABLE) && ((s & FS_DIRECTORY) == 0));
}
warning: parse error {
  int s;

  s = file_status (file);
#if defined EISDIR
  if (s & FS_DIRECTORY)
    errno = EISDIR;	/* let's see if we can improve error messages */
#endif
  return ((s & FS_EXECABLE) && ((s & FS_DIRECTORY) == 0));
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\findcmd.c:176
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\findcmd.c:189
parsing error 
{
  return (file_status (file) & FS_DIRECTORY);
}
warning: parse error {
  return (file_status (file) & FS_DIRECTORY);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\findcmd.c:190
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\findcmd.c:196
parsing error 
{
  int s;

  s = file_status (file);
  return ((s & FS_EXECABLE) || (s & FS_DIRECTORY));
}
warning: parse error {
  int s;

  s = file_status (file);
  return ((s & FS_EXECABLE) || (s & FS_DIRECTORY));
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\findcmd.c:197
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\findcmd.c:211
parsing error 
{
  return (find_user_command_internal (name, FS_EXEC_PREFERRED|FS_NODIRS));
}
warning: parse error {
  return (find_user_command_internal (name, FS_EXEC_PREFERRED|FS_NODIRS));
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\findcmd.c:212
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\findcmd.c:223
parsing error 
{
  return (find_user_command_internal (name, FS_READABLE));
}
warning: parse error {
  return (find_user_command_internal (name, FS_READABLE));
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\findcmd.c:224
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\findcmd.c:230
parsing error 
{
  char *path_list, *cmd;
  SHELL_VAR *var;

  /* Search for the value of PATH in both the temporary environments and
     in the regular list of variables. */
  if (var = find_variable_internal ("PATH", 1))	/* XXX could be array? */
    path_list = value_cell (var);
  else
    path_list = (char *)NULL;

  if (path_list == 0 || *path_list == '\0')
    return (savestring (name));

  cmd = find_user_command_in_path (name, path_list, flags);

  return (cmd);
}
warning: parse error {
  char *path_list, *cmd;
  SHELL_VAR *var;

  /* Search for the value of PATH in both the temporary environments and
     in the regular list of variables. */
  if (var = find_variable_internal ("PATH", 1))	/* XXX could be array? */
    path_list = value_cell (var);
  else
    path_list = (char *)NULL;

  if (path_list == 0 || *path_list == '\0')
    return (savestring (name));

  cmd = find_user_command_in_path (name, path_list, flags);

  return (cmd);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\findcmd.c:232
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\findcmd.c:253
parsing error 
{
#ifdef __WIN32__
  char *res, *dotexe;

  dotexe = (char *)xmalloc (strlen (name) + 5);
  strcpy (dotexe, name);
  strcat (dotexe, ".exe");
  res = _find_user_command_internal (dotexe, flags);
  free (dotexe);
  if (res == 0)
    res = _find_user_command_internal (name, flags);
  return res;
#else
  return (_find_user_command_internal (name, flags));
#endif
}
warning: parse error {
#ifdef __WIN32__
  char *res, *dotexe;

  dotexe = (char *)xmalloc (strlen (name) + 5);
  strcpy (dotexe, name);
  strcat (dotexe, ".exe");
  res = _find_user_command_internal (dotexe, flags);
  free (dotexe);
  if (res == 0)
    res = _find_user_command_internal (name, flags);
  return res;
#else
  return (_find_user_command_internal (name, flags));
#endif
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\findcmd.c:255
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\findcmd.c:277
parsing error 
{
  char *path;

  path = extract_colon_unit (path_list, path_index_pointer);

  if (path == 0)
    return (path);

  if (*path == '\0')
    {
      free (path);
      path = savestring (".");
    }

  return (path);
}
warning: parse error {
  char *path;

  path = extract_colon_unit (path_list, path_index_pointer);

  if (path == 0)
    return (path);

  if (*path == '\0')
    {
      free (path);
      path = savestring (".");
    }

  return (path);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\findcmd.c:280
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\findcmd.c:302
parsing error 
{
  char *hashed_file, *command;
  int temp_path, st;
  SHELL_VAR *path;

  hashed_file = command = (char *)NULL;

  /* If PATH is in the temporary environment for this command, don't use the
     hash table to search for the full pathname. */
  path = find_variable_internal ("PATH", 1);
  temp_path = path && tempvar_p (path);
  if (temp_path == 0 && path)
    path = (SHELL_VAR *)NULL;

  /* Don't waste time trying to find hashed data for a pathname
     that is already completely specified or if we're using a command-
     specific value for PATH. */
  if (path == 0 && absolute_program (pathname) == 0)
    hashed_file = phash_search (pathname);

  /* If a command found in the hash table no longer exists, we need to
     look for it in $PATH.  Thank you Posix.2.  This forces us to stat
     every command found in the hash table. */

  if (hashed_file && (posixly_correct || check_hashed_filenames))
    {
      st = file_status (hashed_file);
      if ((st & (FS_EXISTS|FS_EXECABLE)) != (FS_EXISTS|FS_EXECABLE))
	{
	  phash_remove (pathname);
	  free (hashed_file);
	  hashed_file = (char *)NULL;
	}
    }

  if (hashed_file)
    command = hashed_file;
  else if (absolute_program (pathname))
    /* A command containing a slash is not looked up in PATH or saved in
       the hash table. */
    command = savestring (pathname);
  else
    {
      /* If $PATH is in the temporary environment, we've already retrieved
	 it, so don't bother trying again. */
      if (temp_path)
	{
	  command = find_user_command_in_path (pathname, value_cell (path),
					       FS_EXEC_PREFERRED|FS_NODIRS);
	}
      else
	command = find_user_command (pathname);
      if (command && hashing_enabled && temp_path == 0)
	phash_insert ((char *)pathname, command, dot_found_in_search, 1);	/* XXX fix const later */
    }
  return (command);
}
warning: parse error {
  char *hashed_file, *command;
  int temp_path, st;
  SHELL_VAR *path;

  hashed_file = command = (char *)NULL;

  /* If PATH is in the temporary environment for this command, don't use the
     hash table to search for the full pathname. */
  path = find_variable_internal ("PATH", 1);
  temp_path = path && tempvar_p (path);
  if (temp_path == 0 && path)
    path = (SHELL_VAR *)NULL;

  /* Don't waste time trying to find hashed data for a pathname
     that is already completely specified or if we're using a command-
     specific value for PATH. */
  if (path == 0 && absolute_program (pathname) == 0)
    hashed_file = phash_search (pathname);

  /* If a command found in the hash table no longer exists, we need to
     look for it in $PATH.  Thank you Posix.2.  This forces us to stat
     every command found in the hash table. */

  if (hashed_file && (posixly_correct || check_hashed_filenames))
    {
      st = file_status (hashed_file);
      if ((st & (FS_EXISTS|FS_EXECABLE)) != (FS_EXISTS|FS_EXECABLE))
	{
	  phash_remove (pathname);
	  free (hashed_file);
	  hashed_file = (char *)NULL;
	}
    }

  if (hashed_file)
    command = hashed_file;
  else if (absolute_program (pathname))
    /* A command containing a slash is not looked up in PATH or saved in
       the hash table. */
    command = savestring (pathname);
  else
    {
      /* If $PATH is in the temporary environment, we've already retrieved
	 it, so don't bother trying again. */
      if (temp_path)
	{
	  command = find_user_command_in_path (pathname, value_cell (path),
					       FS_EXEC_PREFERRED|FS_NODIRS);
	}
      else
	command = find_user_command (pathname);
      if (command && hashing_enabled && temp_path == 0)
	phash_insert ((char *)pathname, command, dot_found_in_search, 1);	/* XXX fix const later */
    }
  return (command);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\findcmd.c:303
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\findcmd.c:363
parsing error 
{
  register int i;
  int  path_index, name_len;
  char *path_list, *path_element, *match;
  struct stat dotinfo;
  static char **match_list = NULL;
  static int match_list_size = 0;
  static int match_index = 0;

  if (state == 0)
    {
      /* Create the list of matches. */
      if (match_list == 0)
	{
	  match_list_size = 5;
	  match_list = strvec_create (match_list_size);
	}

      /* Clear out the old match list. */
      for (i = 0; i < match_list_size; i++)
	match_list[i] = 0;

      /* We haven't found any files yet. */
      match_index = 0;

      if (absolute_program (name))
	{
	  match_list[0] = find_absolute_program (name, flags);
	  match_list[1] = (char *)NULL;
	  path_list = (char *)NULL;
	}
      else
	{
	  name_len = strlen (name);
	  file_to_lose_on = (char *)NULL;
	  dot_found_in_search = 0;
      	  stat (".", &dotinfo);
	  path_list = get_string_value ("PATH");
      	  path_index = 0;
	}

      while (path_list && path_list[path_index])
	{
	  path_element = get_next_path_element (path_list, &path_index);

	  if (path_element == 0)
	    break;

	  match = find_in_path_element (name, path_element, flags, name_len, &dotinfo);

	  free (path_element);

	  if (match == 0)
	    continue;

	  if (match_index + 1 == match_list_size)
	    {
	      match_list_size += 10;
	      match_list = strvec_resize (match_list, (match_list_size + 1));
	    }

	  match_list[match_index++] = match;
	  match_list[match_index] = (char *)NULL;
	  FREE (file_to_lose_on);
	  file_to_lose_on = (char *)NULL;
	}

      /* We haven't returned any strings yet. */
      match_index = 0;
    }

  match = match_list[match_index];

  if (match)
    match_index++;

  return (match);
}
warning: parse error {
  register int i;
  int  path_index, name_len;
  char *path_list, *path_element, *match;
  struct stat dotinfo;
  static char **match_list = NULL;
  static int match_list_size = 0;
  static int match_index = 0;

  if (state == 0)
    {
      /* Create the list of matches. */
      if (match_list == 0)
	{
	  match_list_size = 5;
	  match_list = strvec_create (match_list_size);
	}

      /* Clear out the old match list. */
      for (i = 0; i < match_list_size; i++)
	match_list[i] = 0;

      /* We haven't found any files yet. */
      match_index = 0;

      if (absolute_program (name))
	{
	  match_list[0] = find_absolute_program (name, flags);
	  match_list[1] = (char *)NULL;
	  path_list = (char *)NULL;
	}
      else
	{
	  name_len = strlen (name);
	  file_to_lose_on = (char *)NULL;
	  dot_found_in_search = 0;
      	  stat (".", &dotinfo);
	  path_list = get_string_value ("PATH");
      	  path_index = 0;
	}

      while (path_list && path_list[path_index])
	{
	  path_element = get_next_path_element (path_list, &path_index);

	  if (path_element == 0)
	    break;

	  match = find_in_path_element (name, path_element, flags, name_len, &dotinfo);

	  free (path_element);

	  if (match == 0)
	    continue;

	  if (match_index + 1 == match_list_size)
	    {
	      match_list_size += 10;
	      match_list = strvec_resize (match_list, (match_list_size + 1));
	    }

	  match_list[match_index++] = match;
	  match_list[match_index] = (char *)NULL;
	  FREE (file_to_lose_on);
	  file_to_lose_on = (char *)NULL;
	}

      /* We haven't returned any strings yet. */
      match_index = 0;
    }

  match = match_list[match_index];

  if (match)
    match_index++;

  return (match);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\findcmd.c:365
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\findcmd.c:446
parsing error 
{
  int st;

  st = file_status (name);

  /* If the file doesn't exist, quit now. */
  if ((st & FS_EXISTS) == 0)
    return ((char *)NULL);

  /* If we only care about whether the file exists or not, return
     this filename.  Otherwise, maybe we care about whether this
     file is executable.  If it is, and that is what we want, return it. */
  if ((flags & FS_EXISTS) || ((flags & FS_EXEC_ONLY) && (st & FS_EXECABLE)))
    return (savestring (name));

  return (NULL);
}
warning: parse error {
  int st;

  st = file_status (name);

  /* If the file doesn't exist, quit now. */
  if ((st & FS_EXISTS) == 0)
    return ((char *)NULL);

  /* If we only care about whether the file exists or not, return
     this filename.  Otherwise, maybe we care about whether this
     file is executable.  If it is, and that is what we want, return it. */
  if ((flags & FS_EXISTS) || ((flags & FS_EXEC_ONLY) && (st & FS_EXECABLE)))
    return (savestring (name));

  return (NULL);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\findcmd.c:448
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\findcmd.c:468
parsing error 
{
  int status;
  char *full_path, *xpath;

  xpath = (*path == '~') ? bash_tilde_expand (path, 0) : path;

  /* Remember the location of "." in the path, in all its forms
     (as long as they begin with a `.', e.g. `./.') */
  if (dot_found_in_search == 0 && *xpath == '.')
    dot_found_in_search = same_file (".", xpath, dotinfop, (struct stat *)NULL);

  full_path = sh_makepath (xpath, name, 0);

  status = file_status (full_path);

  if (xpath != path)
    free (xpath);

  if ((status & FS_EXISTS) == 0)
    {
      free (full_path);
      return ((char *)NULL);
    }

  /* The file exists.  If the caller simply wants the first file, here it is. */
  if (flags & FS_EXISTS)
    return (full_path);

  /* If we have a readable file, and the caller wants a readable file, this
     is it. */
  if ((flags & FS_READABLE) && (status & FS_READABLE))
    return (full_path);

  /* If the file is executable, then it satisfies the cases of
      EXEC_ONLY and EXEC_PREFERRED.  Return this file unconditionally. */
  if ((status & FS_EXECABLE) && (flags & (FS_EXEC_ONLY|FS_EXEC_PREFERRED)) &&
      (((flags & FS_NODIRS) == 0) || ((status & FS_DIRECTORY) == 0)))
    {
      FREE (file_to_lose_on);
      file_to_lose_on = (char *)NULL;
      return (full_path);
    }

  /* The file is not executable, but it does exist.  If we prefer
     an executable, then remember this one if it is the first one
     we have found. */
  if ((flags & FS_EXEC_PREFERRED) && file_to_lose_on == 0)
    file_to_lose_on = savestring (full_path);

  /* If we want only executable files, or we don't want directories and
     this file is a directory, or we want a readable file and this file
     isn't readable, fail. */
  if ((flags & (FS_EXEC_ONLY|FS_EXEC_PREFERRED)) ||
      ((flags & FS_NODIRS) && (status & FS_DIRECTORY)) ||
      ((flags & FS_READABLE) && (status & FS_READABLE) == 0))
    {
      free (full_path);
      return ((char *)NULL);
    }
  else
    return (full_path);
}
warning: parse error {
  int status;
  char *full_path, *xpath;

  xpath = (*path == '~') ? bash_tilde_expand (path, 0) : path;

  /* Remember the location of "." in the path, in all its forms
     (as long as they begin with a `.', e.g. `./.') */
  if (dot_found_in_search == 0 && *xpath == '.')
    dot_found_in_search = same_file (".", xpath, dotinfop, (struct stat *)NULL);

  full_path = sh_makepath (xpath, name, 0);

  status = file_status (full_path);

  if (xpath != path)
    free (xpath);

  if ((status & FS_EXISTS) == 0)
    {
      free (full_path);
      return ((char *)NULL);
    }

  /* The file exists.  If the caller simply wants the first file, here it is. */
  if (flags & FS_EXISTS)
    return (full_path);

  /* If we have a readable file, and the caller wants a readable file, this
     is it. */
  if ((flags & FS_READABLE) && (status & FS_READABLE))
    return (full_path);

  /* If the file is executable, then it satisfies the cases of
      EXEC_ONLY and EXEC_PREFERRED.  Return this file unconditionally. */
  if ((status & FS_EXECABLE) && (flags & (FS_EXEC_ONLY|FS_EXEC_PREFERRED)) &&
      (((flags & FS_NODIRS) == 0) || ((status & FS_DIRECTORY) == 0)))
    {
      FREE (file_to_lose_on);
      file_to_lose_on = (char *)NULL;
      return (full_path);
    }

  /* The file is not executable, but it does exist.  If we prefer
     an executable, then remember this one if it is the first one
     we have found. */
  if ((flags & FS_EXEC_PREFERRED) && file_to_lose_on == 0)
    file_to_lose_on = savestring (full_path);

  /* If we want only executable files, or we don't want directories and
     this file is a directory, or we want a readable file and this file
     isn't readable, fail. */
  if ((flags & (FS_EXEC_ONLY|FS_EXEC_PREFERRED)) ||
      ((flags & FS_NODIRS) && (status & FS_DIRECTORY)) ||
      ((flags & FS_READABLE) && (status & FS_READABLE) == 0))
    {
      free (full_path);
      return ((char *)NULL);
    }
  else
    return (full_path);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\findcmd.c:472
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\findcmd.c:549
parsing error 
{
  char *full_path, *path;
  int path_index, name_len;
  struct stat dotinfo;

  /* We haven't started looking, so we certainly haven't seen
     a `.' as the directory path yet. */
  dot_found_in_search = 0;

  if (absolute_program (name))
    {
      full_path = find_absolute_program (name, flags);
      return (full_path);
    }

  if (path_list == 0 || *path_list == '\0')
    return (savestring (name));		/* XXX */

  file_to_lose_on = (char *)NULL;
  name_len = strlen (name);
  stat (".", &dotinfo);
  path_index = 0;

  while (path_list[path_index])
    {
      /* Allow the user to interrupt out of a lengthy path search. */
      QUIT;

      path = get_next_path_element (path_list, &path_index);
      if (path == 0)
	break;

      /* Side effects: sets dot_found_in_search, possibly sets
	 file_to_lose_on. */
      full_path = find_in_path_element (name, path, flags, name_len, &dotinfo);
      free (path);

      /* This should really be in find_in_path_element, but there isn't the
	 right combination of flags. */
      if (full_path && is_directory (full_path))
	{
	  free (full_path);
	  continue;
	}

      if (full_path)
	{
	  FREE (file_to_lose_on);
	  return (full_path);
	}
    }

  /* We didn't find exactly what the user was looking for.  Return
     the contents of FILE_TO_LOSE_ON which is NULL when the search
     required an executable, or non-NULL if a file was found and the
     search would accept a non-executable as a last resort.  If the
     caller specified FS_NODIRS, and file_to_lose_on is a directory,
     return NULL. */
  if (file_to_lose_on && (flags & FS_NODIRS) && is_directory (file_to_lose_on))
    {
      free (file_to_lose_on);
      file_to_lose_on = (char *)NULL;
    }

  return (file_to_lose_on);
}
warning: parse error {
  char *full_path, *path;
  int path_index, name_len;
  struct stat dotinfo;

  /* We haven't started looking, so we certainly haven't seen
     a `.' as the directory path yet. */
  dot_found_in_search = 0;

  if (absolute_program (name))
    {
      full_path = find_absolute_program (name, flags);
      return (full_path);
    }

  if (path_list == 0 || *path_list == '\0')
    return (savestring (name));		/* XXX */

  file_to_lose_on = (char *)NULL;
  name_len = strlen (name);
  stat (".", &dotinfo);
  path_index = 0;

  while (path_list[path_index])
    {
      /* Allow the user to interrupt out of a lengthy path search. */
      QUIT;

      path = get_next_path_element (path_list, &path_index);
      if (path == 0)
	break;

      /* Side effects: sets dot_found_in_search, possibly sets
	 file_to_lose_on. */
      full_path = find_in_path_element (name, path, flags, name_len, &dotinfo);
      free (path);

      /* This should really be in find_in_path_element, but there isn't the
	 right combination of flags. */
      if (full_path && is_directory (full_path))
	{
	  free (full_path);
	  continue;
	}

      if (full_path)
	{
	  FREE (file_to_lose_on);
	  return (full_path);
	}
    }

  /* We didn't find exactly what the user was looking for.  Return
     the contents of FILE_TO_LOSE_ON which is NULL when the search
     required an executable, or non-NULL if a file was found and the
     search would accept a non-executable as a last resort.  If the
     caller specified FS_NODIRS, and file_to_lose_on is a directory,
     return NULL. */
  if (file_to_lose_on && (flags & FS_NODIRS) && is_directory (file_to_lose_on))
    {
      free (file_to_lose_on);
      file_to_lose_on = (char *)NULL;
    }

  return (file_to_lose_on);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\findcmd.c:552
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\flags.c...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\shell.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\flags.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\flags.c:219
parsing error 
{
  int i;
  for (i = 0; shell_flags[i].name; i++)
    {
      if (shell_flags[i].name == name)
	return (shell_flags[i].value);
    }
  return (FLAG_UNKNOWN);
}
warning: parse error {
  int i;
  for (i = 0; shell_flags[i].name; i++)
    {
      if (shell_flags[i].name == name)
	return (shell_flags[i].value);
    }
  return (FLAG_UNKNOWN);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\flags.c:221
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\flags.c:235
parsing error 
{
  int *value, old_value;

#if defined (RESTRICTED_SHELL)
  /* Don't allow "set +r" in a shell which is `restricted'. */
  if (restricted && flag == 'r' && on_or_off == FLAG_OFF)
    return (FLAG_ERROR);
#endif /* RESTRICTED_SHELL */

  value = find_flag (flag);

  if ((value == (int *)FLAG_UNKNOWN) || (on_or_off != FLAG_ON && on_or_off != FLAG_OFF))
    return (FLAG_ERROR);

  old_value = *value;

  *value = (on_or_off == FLAG_ON) ? 1 : 0;

  /* Special cases for a few flags. */
  switch (flag)
    {
#if defined (BANG_HISTORY)
    case 'H':
      if (on_or_off == FLAG_ON)
	bash_initialize_history ();
      break;
#endif

#if defined (JOB_CONTROL)
    case 'm':
      set_job_control (on_or_off == FLAG_ON);
      break;
#endif /* JOB_CONTROL */

    case 'n':
      if (interactive_shell)
	read_but_dont_execute = 0;
      break;

    case 'p':
      if (on_or_off == FLAG_OFF)
	disable_priv_mode ();
      break;

#if defined (RESTRICTED_SHELL)
    case 'r':
      if (on_or_off == FLAG_ON && shell_initialized)
	maybe_make_restricted (shell_name);
      break;
#endif

    }

  return (old_value);
}
warning: parse error {
  int *value, old_value;

#if defined (RESTRICTED_SHELL)
  /* Don't allow "set +r" in a shell which is `restricted'. */
  if (restricted && flag == 'r' && on_or_off == FLAG_OFF)
    return (FLAG_ERROR);
#endif /* RESTRICTED_SHELL */

  value = find_flag (flag);

  if ((value == (int *)FLAG_UNKNOWN) || (on_or_off != FLAG_ON && on_or_off != FLAG_OFF))
    return (FLAG_ERROR);

  old_value = *value;

  *value = (on_or_off == FLAG_ON) ? 1 : 0;

  /* Special cases for a few flags. */
  switch (flag)
    {
#if defined (BANG_HISTORY)
    case 'H':
      if (on_or_off == FLAG_ON)
	bash_initialize_history ();
      break;
#endif

#if defined (JOB_CONTROL)
    case 'm':
      set_job_control (on_or_off == FLAG_ON);
      break;
#endif /* JOB_CONTROL */

    case 'n':
      if (interactive_shell)
	read_but_dont_execute = 0;
      break;

    case 'p':
      if (on_or_off == FLAG_OFF)
	disable_priv_mode ();
      break;

#if defined (RESTRICTED_SHELL)
    case 'r':
      if (on_or_off == FLAG_ON && shell_initialized)
	maybe_make_restricted (shell_name);
      break;
#endif

    }

  return (old_value);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\flags.c:238
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\general.c...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\bashtypes.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\posixstat.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\filecntl.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\bashansi.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\chartypes.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\bashintl.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\shell.h...skip
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\test.h...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\stdc.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\tilde\tilde.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\general.c:65
parsing error 
{
  /* Things that should be turned on when posix mode is enabled. */
  if (on != 0)
    {
      interactive_comments = source_uses_path = expand_aliases = 1;
      source_searches_cwd = 0;
    }

  /* Things that should be turned on when posix mode is disabled. */
  if (on == 0)
    {
      source_searches_cwd = 1;
      expand_aliases = interactive_shell;
    }
}
warning: parse error {
  /* Things that should be turned on when posix mode is enabled. */
  if (on != 0)
    {
      interactive_comments = source_uses_path = expand_aliases = 1;
      source_searches_cwd = 0;
    }

  /* Things that should be turned on when posix mode is disabled. */
  if (on == 0)
    {
      source_searches_cwd = 1;
      expand_aliases = interactive_shell;
    }
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\general.c:67
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\general.c:148
parsing error 
{
  register char *s;

  for (s = string; *s; s++)
    if (DIGIT (*s) == 0)
      return (0);

  return (1);
}
warning: parse error {
  register char *s;

  for (s = string; *s; s++)
    if (DIGIT (*s) == 0)
      return (0);

  return (1);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\general.c:150
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\general.c:165
parsing error 
{
  intmax_t value;
  char *ep;

  if (result)
    *result = 0;

  errno = 0;
  value = strtoimax (string, &ep, 10);
  if (errno || ep == string)
    return 0;	/* errno is set on overflow or underflow */

  /* Skip any trailing whitespace, since strtoimax does not. */
  while (whitespace (*ep))
    ep++;

  /* If *string is not '\0' but *ep is '\0' on return, the entire string
     is valid. */
  if (string && *string && *ep == '\0')
    {
      if (result)
	*result = value;
      /* The SunOS4 implementation of strtol() will happily ignore
	 overflow conditions, so this cannot do overflow correctly
	 on those systems. */
      return 1;
    }
    
  return (0);
}
warning: parse error {
  intmax_t value;
  char *ep;

  if (result)
    *result = 0;

  errno = 0;
  value = strtoimax (string, &ep, 10);
  if (errno || ep == string)
    return 0;	/* errno is set on overflow or underflow */

  /* Skip any trailing whitespace, since strtoimax does not. */
  while (whitespace (*ep))
    ep++;

  /* If *string is not '\0' but *ep is '\0' on return, the entire string
     is valid. */
  if (string && *string && *ep == '\0')
    {
      if (result)
	*result = value;
      /* The SunOS4 implementation of strtol() will happily ignore
	 overflow conditions, so this cannot do overflow correctly
	 on those systems. */
      return 1;
    }
    
  return (0);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\general.c:167
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\general.c:202
parsing error 
{
  register char *s;
  unsigned char c;

  if (!name || !(c = *name) || (legal_variable_starter (c) == 0))
    return (0);

  for (s = name + 1; (c = *s) != 0; s++)
    {
      if (legal_variable_char (c) == 0)
	return (0);
    }
  return (1);
}
warning: parse error {
  register char *s;
  unsigned char c;

  if (!name || !(c = *name) || (legal_variable_starter (c) == 0))
    return (0);

  for (s = name + 1; (c = *s) != 0; s++)
    {
      if (legal_variable_char (c) == 0)
	return (0);
    }
  return (1);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\general.c:204
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\general.c:225
parsing error 
{
  if ((word->flags & (W_HASDOLLAR|W_QUOTED)) || all_digits (word->word))
    {
      internal_error (_("`%s': not a valid identifier"), word->word);
      return (0);
    }
  else if (check_word && legal_identifier (word->word) == 0)
    {
      internal_error (_("`%s': not a valid identifier"), word->word);
      return (0);
    }
  else
    return (1);
}
warning: parse error {
  if ((word->flags & (W_HASDOLLAR|W_QUOTED)) || all_digits (word->word))
    {
      internal_error (_("`%s': not a valid identifier"), word->word);
      return (0);
    }
  else if (check_word && legal_identifier (word->word) == 0)
    {
      internal_error (_("`%s': not a valid identifier"), word->word);
      return (0);
    }
  else
    return (1);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\general.c:228
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\general.c:247
parsing error 
{
  register char *s;

  for (s = string; *s; s++)
    if (shellbreak (*s) || shellxquote (*s) || shellexp (*s) || (*s == '/'))
      return 0;
  return 1;
}
warning: parse error {
  register char *s;

  for (s = string; *s; s++)
    if (shellbreak (*s) || shellxquote (*s) || shellexp (*s) || (*s == '/'))
      return 0;
  return 1;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\general.c:250
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\general.c:263
parsing error 
{
  register unsigned char c;
  register int newi, indx;

  c = string[indx = 0];

#if defined (ARRAY_VARS)
  if ((legal_variable_starter (c) == 0) && (flags == 0 || c != '[')) /* ] */
#else
  if (legal_variable_starter (c) == 0)
#endif
    return (0);

  while (c = string[indx])
    {
      /* The following is safe.  Note that '=' at the start of a word
	 is not an assignment statement. */
      if (c == '=')
	return (indx);

#if defined (ARRAY_VARS)
      if (c == '[')
	{
	  newi = skipsubscript (string, indx, 0);
	  if (string[newi++] != ']')
	    return (0);
	  if (string[newi] == '+' && string[newi+1] == '=')
	    return (newi + 1);
	  return ((string[newi] == '=') ? newi : 0);
	}
#endif /* ARRAY_VARS */

      /* Check for `+=' */
      if (c == '+' && string[indx+1] == '=')
	return (indx + 1);

      /* Variable names in assignment statements may contain only letters,
	 digits, and `_'. */
      if (legal_variable_char (c) == 0)
	return (0);

      indx++;
    }
  return (0);
}
warning: parse error {
  register unsigned char c;
  register int newi, indx;

  c = string[indx = 0];

#if defined (ARRAY_VARS)
  if ((legal_variable_starter (c) == 0) && (flags == 0 || c != '[')) /* ] */
#else
  if (legal_variable_starter (c) == 0)
#endif
    return (0);

  while (c = string[indx])
    {
      /* The following is safe.  Note that '=' at the start of a word
	 is not an assignment statement. */
      if (c == '=')
	return (indx);

#if defined (ARRAY_VARS)
      if (c == '[')
	{
	  newi = skipsubscript (string, indx, 0);
	  if (string[newi++] != ']')
	    return (0);
	  if (string[newi] == '+' && string[newi+1] == '=')
	    return (newi + 1);
	  return ((string[newi] == '=') ? newi : 0);
	}
#endif /* ARRAY_VARS */

      /* Check for `+=' */
      if (c == '+' && string[indx+1] == '=')
	return (indx + 1);

      /* Variable names in assignment statements may contain only letters,
	 digits, and `_'. */
      if (legal_variable_char (c) == 0)
	return (0);

      indx++;
    }
  return (0);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\general.c:265
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\general.c:329
parsing error 
{
  int flags, bflags;

  if ((flags = fcntl (fd, F_GETFL, 0)) < 0)
    return -1;

  bflags = 0;

  /* This is defined to O_NDELAY in filecntl.h if O_NONBLOCK is not present
     and O_NDELAY is defined. */
#ifdef O_NONBLOCK
  bflags |= O_NONBLOCK;
#endif

#ifdef O_NDELAY
  bflags |= O_NDELAY;
#endif

  if (flags & bflags)
    {
      flags &= ~bflags;
      return (fcntl (fd, F_SETFL, flags));
    }

  return 0;
}
warning: parse error {
  int flags, bflags;

  if ((flags = fcntl (fd, F_GETFL, 0)) < 0)
    return -1;

  bflags = 0;

  /* This is defined to O_NDELAY in filecntl.h if O_NONBLOCK is not present
     and O_NDELAY is defined. */
#ifdef O_NONBLOCK
  bflags |= O_NONBLOCK;
#endif

#ifdef O_NDELAY
  bflags |= O_NDELAY;
#endif

  if (flags & bflags)
    {
      flags &= ~bflags;
      return (fcntl (fd, F_SETFL, flags));
    }

  return 0;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\general.c:331
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\general.c:360
parsing error 
{
  return (fcntl (fd, F_GETFD, 0) >= 0);
}
warning: parse error {
  return (fcntl (fd, F_GETFD, 0) >= 0);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\general.c:362
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\general.c:367
parsing error 
{
  errno = 0;
  if (lseek ((fd), 0L, SEEK_CUR) < 0)
    return (errno == ESPIPE);
  return 0;
}
warning: parse error {
  errno = 0;
  if (lseek ((fd), 0L, SEEK_CUR) < 0)
    return (errno == ESPIPE);
  return 0;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\general.c:369
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\general.c:408
parsing error 
{
  struct stat st1, st2;

  if (stp1 == NULL)
    {
      if (stat (path1, &st1) != 0)
	return (0);
      stp1 = &st1;
    }

  if (stp2 == NULL)
    {
      if (stat (path2, &st2) != 0)
	return (0);
      stp2 = &st2;
    }

  return ((stp1->st_dev == stp2->st_dev) && (stp1->st_ino == stp2->st_ino));
}
warning: parse error {
  struct stat st1, st2;

  if (stp1 == NULL)
    {
      if (stat (path1, &st1) != 0)
	return (0);
      stp1 = &st1;
    }

  if (stp2 == NULL)
    {
      if (stat (path2, &st2) != 0)
	return (0);
      stp2 = &st2;
    }

  return ((stp1->st_dev == stp2->st_dev) && (stp1->st_ino == stp2->st_ino));
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\general.c:411
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\general.c:439
parsing error 
{
  int script_fd, nfds, ignore;

  if (maxfd < 20)
    {
      nfds = getdtablesize ();
      if (nfds <= 0)
	nfds = 20;
      if (nfds > HIGH_FD_MAX)
	nfds = HIGH_FD_MAX;		/* reasonable maximum */
    }
  else
    nfds = maxfd;

  for (nfds--; check_new && nfds > 3; nfds--)
    if (fcntl (nfds, F_GETFD, &ignore) == -1)
      break;

  if (nfds > 3 && fd != nfds && (script_fd = dup2 (fd, nfds)) != -1)
    {
      if (check_new == 0 || fd != fileno (stderr))	/* don't close stderr */
	close (fd);
      return (script_fd);
    }

  /* OK, we didn't find one less than our artificial maximum; return the
     original file descriptor. */
  return (fd);
}
warning: parse error {
  int script_fd, nfds, ignore;

  if (maxfd < 20)
    {
      nfds = getdtablesize ();
      if (nfds <= 0)
	nfds = 20;
      if (nfds > HIGH_FD_MAX)
	nfds = HIGH_FD_MAX;		/* reasonable maximum */
    }
  else
    nfds = maxfd;

  for (nfds--; check_new && nfds > 3; nfds--)
    if (fcntl (nfds, F_GETFD, &ignore) == -1)
      break;

  if (nfds > 3 && fd != nfds && (script_fd = dup2 (fd, nfds)) != -1)
    {
      if (check_new == 0 || fd != fileno (stderr))	/* don't close stderr */
	close (fd);
      return (script_fd);
    }

  /* OK, we didn't find one less than our artificial maximum; return the
     original file descriptor. */
  return (fd);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\general.c:441
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\general.c:477
parsing error 
{
  register int i;
  unsigned char c;

  for (i = 0; i < sample_len; i++)
    {
      c = sample[i];
      if (c == '\n')
	return (0);
      if (c == '\0')
	return (1);
    }

  return (0);
}
warning: parse error {
  register int i;
  unsigned char c;

  for (i = 0; i < sample_len; i++)
    {
      c = sample[i];
      if (c == '\n')
	return (0);
      if (c == '\0')
	return (1);
    }

  return (0);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\general.c:480
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\general.c:503
parsing error 
{
  int r;

  if ((r = pipe (pv)) < 0)
    return r;

  pv[0] = move_to_high_fd (pv[0], 1, 64);
  pv[1] = move_to_high_fd (pv[1], 1, 64);

  return 0;  
}
warning: parse error {
  int r;

  if ((r = pipe (pv)) < 0)
    return r;

  pv[0] = move_to_high_fd (pv[0], 1, 64);
  pv[1] = move_to_high_fd (pv[1], 1, 64);

  return 0;  
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\general.c:505
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\general.c:518
parsing error 
{
  if (pv[0] >= 0)
    close (pv[0]);

  if (pv[1] >= 0)
    close (pv[1]);

  pv[0] = pv[1] = -1;
  return 0;
}
warning: parse error {
  if (pv[0] >= 0)
    close (pv[0]);

  if (pv[1] >= 0)
    close (pv[1]);

  pv[0] = pv[1] = -1;
  return 0;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\general.c:520
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\general.c:538
parsing error 
{
  struct stat sb;

  return (stat (fn, &sb) == 0);
}
warning: parse error {
  struct stat sb;

  return (stat (fn, &sb) == 0);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\general.c:540
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\general.c:547
parsing error 
{
  struct stat sb;

  return ((stat (fn, &sb) == 0) && S_ISDIR (sb.st_mode));
}
warning: parse error {
  struct stat sb;

  return ((stat (fn, &sb) == 0) && S_ISDIR (sb.st_mode));
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\general.c:549
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\general.c:556
parsing error 
{
  return (file_isdir (fn) && sh_eaccess (fn, W_OK) == 0);
}
warning: parse error {
  return (file_isdir (fn) && sh_eaccess (fn, W_OK) == 0);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\general.c:558
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\general.c:566
parsing error 
{
  if (string == 0 || *string == '\0' || *string != '.')
    return (0);

  /* string[0] == '.' */
  if (PATHSEP(string[1]) || (string[1] == '.' && PATHSEP(string[2])))
    return (1);

  return (0);
}
warning: parse error {
  if (string == 0 || *string == '\0' || *string != '.')
    return (0);

  /* string[0] == '.' */
  if (PATHSEP(string[1]) || (string[1] == '.' && PATHSEP(string[2])))
    return (1);

  return (0);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\general.c:567
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\general.c:582
parsing error 
{
  if (string == 0 || *string == '\0')
    return (0);

  if (ABSPATH(string))
    return (1);

  if (string[0] == '.' && PATHSEP(string[1]))	/* . and ./ */
    return (1);

  if (string[0] == '.' && string[1] == '.' && PATHSEP(string[2]))	/* .. and ../ */
    return (1);

  return (0);
}
warning: parse error {
  if (string == 0 || *string == '\0')
    return (0);

  if (ABSPATH(string))
    return (1);

  if (string[0] == '.' && PATHSEP(string[1]))	/* . and ./ */
    return (1);

  if (string[0] == '.' && string[1] == '.' && PATHSEP(string[2]))	/* .. and ../ */
    return (1);

  return (0);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\general.c:583
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\general.c:604
parsing error 
{
  return ((char *)mbschr (string, '/') != (char *)NULL);
}
warning: parse error {
  return ((char *)mbschr (string, '/') != (char *)NULL);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\general.c:605
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\general.c:620
parsing error 
{
  char *result;

  if (dot_path == 0 || ABSPATH(string))
#ifdef __CYGWIN__
    {
      char pathbuf[PATH_MAX + 1];

      cygwin_conv_to_full_posix_path (string, pathbuf);
      result = savestring (pathbuf);
    }
#else
    result = savestring (string);
#endif
  else
    result = sh_makepath (dot_path, string, 0);

  return (result);
}
warning: parse error {
  char *result;

  if (dot_path == 0 || ABSPATH(string))
#ifdef __CYGWIN__
    {
      char pathbuf[PATH_MAX + 1];

      cygwin_conv_to_full_posix_path (string, pathbuf);
      result = savestring (pathbuf);
    }
#else
    result = savestring (string);
#endif
  else
    result = sh_makepath (dot_path, string, 0);

  return (result);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\general.c:622
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\general.c:645
parsing error 
{
  char *p;

#if 0
  if (absolute_pathname (string) == 0)
    return (string);
#endif

  if (string[0] == '/' && string[1] == 0)
    return (string);

  p = (char *)strrchr (string, '/');
  return (p ? ++p : string);
}
warning: parse error {
  char *p;

#if 0
  if (absolute_pathname (string) == 0)
    return (string);
#endif

  if (string[0] == '/' && string[1] == 0)
    return (string);

  p = (char *)strrchr (string, '/');
  return (p ? ++p : string);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\general.c:647
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\general.c:667
parsing error 
{
  char *ret;

  file = (*file == '~') ? bash_tilde_expand (file, 0) : savestring (file);

  if (ABSPATH(file))
    return (file);

  ret = sh_makepath ((char *)NULL, file, (MP_DOCWD|MP_RMDOT));
  free (file);

  return (ret);
}
warning: parse error {
  char *ret;

  file = (*file == '~') ? bash_tilde_expand (file, 0) : savestring (file);

  if (ABSPATH(file))
    return (file);

  ret = sh_makepath ((char *)NULL, file, (MP_DOCWD|MP_RMDOT));
  free (file);

  return (ret);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\general.c:669
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\general.c:690
parsing error 
{
  char *home;
  int l;

  home = get_string_value ("HOME");
  l = home ? strlen (home) : 0;
  if (l > 1 && strncmp (home, name, l) == 0 && (!name[l] || name[l] == '/'))
    {
      strncpy (tdir + 1, name + l, sizeof(tdir) - 2);
      tdir[0] = '~';
      tdir[sizeof(tdir) - 1] = '\0';
      return (tdir);
    }
  else
    return (name);
}
warning: parse error {
  char *home;
  int l;

  home = get_string_value ("HOME");
  l = home ? strlen (home) : 0;
  if (l > 1 && strncmp (home, name, l) == 0 && (!name[l] || name[l] == '/'))
    {
      strncpy (tdir + 1, name + l, sizeof(tdir) - 2);
      tdir[0] = '~';
      tdir[sizeof(tdir) - 1] = '\0';
      return (tdir);
    }
  else
    return (name);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\general.c:692
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\general.c:713
parsing error 
{
  int nlen, ndirs;
  intmax_t nskip;
  char *nbeg, *nend, *ntail, *v;

  if (name == 0 || (nlen = strlen (name)) == 0)
    return name;
  nend = name + nlen;

  v = get_string_value ("PROMPT_DIRTRIM");
  if (v == 0 || *v == 0)
    return name;
  if (legal_number (v, &nskip) == 0 || nskip <= 0)
    return name;

  /* Skip over tilde prefix */
  nbeg = name;
  if (name[0] == '~')
    for (nbeg = name; *nbeg; nbeg++)
      if (*nbeg == '/')
	{
	  nbeg++;
	  break;
	}
  if (*nbeg == 0)
    return name;

  for (ndirs = 0, ntail = nbeg; *ntail; ntail++)
    if (*ntail == '/')
      ndirs++;
  if (ndirs < nskip)
    return name;

  for (ntail = (*nend == '/') ? nend : nend - 1; ntail > nbeg; ntail--)
    {
      if (*ntail == '/')
	nskip--;
      if (nskip == 0)
	break;
    }
  if (ntail == nbeg)
    return name;

  /* Now we want to return name[0..nbeg]+"..."+ntail, modifying name in place */
  nlen = ntail - nbeg;
  if (nlen <= 3)
    return name;

  *nbeg++ = '.';
  *nbeg++ = '.';
  *nbeg++ = '.';

  nlen = nend - ntail;
  memcpy (nbeg, ntail, nlen);
  nbeg[nlen] = '\0';

  return name;
}
warning: parse error {
  int nlen, ndirs;
  intmax_t nskip;
  char *nbeg, *nend, *ntail, *v;

  if (name == 0 || (nlen = strlen (name)) == 0)
    return name;
  nend = name + nlen;

  v = get_string_value ("PROMPT_DIRTRIM");
  if (v == 0 || *v == 0)
    return name;
  if (legal_number (v, &nskip) == 0 || nskip <= 0)
    return name;

  /* Skip over tilde prefix */
  nbeg = name;
  if (name[0] == '~')
    for (nbeg = name; *nbeg; nbeg++)
      if (*nbeg == '/')
	{
	  nbeg++;
	  break;
	}
  if (*nbeg == 0)
    return name;

  for (ndirs = 0, ntail = nbeg; *ntail; ntail++)
    if (*ntail == '/')
      ndirs++;
  if (ndirs < nskip)
    return name;

  for (ntail = (*nend == '/') ? nend : nend - 1; ntail > nbeg; ntail--)
    {
      if (*ntail == '/')
	nskip--;
      if (nskip == 0)
	break;
    }
  if (ntail == nbeg)
    return name;

  /* Now we want to return name[0..nbeg]+"..."+ntail, modifying name in place */
  nlen = ntail - nbeg;
  if (nlen <= 3)
    return name;

  *nbeg++ = '.';
  *nbeg++ = '.';
  *nbeg++ = '.';

  nlen = nend - ntail;
  memcpy (nbeg, ntail, nlen);
  nbeg[nlen] = '\0';

  return name;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\general.c:716
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\general.c:779
parsing error 
{
  int i, start, len;
  char *value;

  if (string == 0)
    return (string);

  len = strlen (string);
  if (*p_index >= len)
    return ((char *)NULL);

  i = *p_index;

  /* Each call to this routine leaves the index pointing at a colon if
     there is more to the path.  If I is > 0, then increment past the
     `:'.  If I is 0, then the path has a leading colon.  Trailing colons
     are handled OK by the `else' part of the if statement; an empty
     string is returned in that case. */
  if (i && string[i] == ':')
    i++;

  for (start = i; string[i] && string[i] != ':'; i++)
    ;

  *p_index = i;

  if (i == start)
    {
      if (string[i])
	(*p_index)++;
      /* Return "" in the case of a trailing `:'. */
      value = (char *)xmalloc (1);
      value[0] = '\0';
    }
  else
    value = substring (string, start, i);

  return (value);
}
warning: parse error {
  int i, start, len;
  char *value;

  if (string == 0)
    return (string);

  len = strlen (string);
  if (*p_index >= len)
    return ((char *)NULL);

  i = *p_index;

  /* Each call to this routine leaves the index pointing at a colon if
     there is more to the path.  If I is > 0, then increment past the
     `:'.  If I is 0, then the path has a leading colon.  Trailing colons
     are handled OK by the `else' part of the if statement; an empty
     string is returned in that case. */
  if (i && string[i] == ':')
    i++;

  for (start = i; string[i] && string[i] != ':'; i++)
    ;

  *p_index = i;

  if (i == start)
    {
      if (string[i])
	(*p_index)++;
      /* Return "" in the case of a trailing `:'. */
      value = (char *)xmalloc (1);
      value[0] = '\0';
    }
  else
    value = substring (string, start, i);

  return (value);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\general.c:782
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\general.c:843
parsing error 
{
  char *result;

  result = (char *)NULL;

  if (text[0] == '+' && text[1] == '\0')
    result = get_string_value ("PWD");
  else if (text[0] == '-' && text[1] == '\0')
    result = get_string_value ("OLDPWD");
#if defined (PUSHD_AND_POPD)
  else if (DIGIT (*text) || ((*text == '+' || *text == '-') && DIGIT (text[1])))
    result = get_dirstack_from_string (text);
#endif

  return (result ? savestring (result) : (char *)NULL);
}
warning: parse error {
  char *result;

  result = (char *)NULL;

  if (text[0] == '+' && text[1] == '\0')
    result = get_string_value ("PWD");
  else if (text[0] == '-' && text[1] == '\0')
    result = get_string_value ("OLDPWD");
#if defined (PUSHD_AND_POPD)
  else if (DIGIT (*text) || ((*text == '+' || *text == '-') && DIGIT (text[1])))
    result = get_dirstack_from_string (text);
#endif

  return (result ? savestring (result) : (char *)NULL);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\general.c:845
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\general.c:913
parsing error 
{
  const char *r;

  for (r = s; TILDE_END(*r) == 0; r++)
    {
      switch (*r)
	{
	case '\\':
	case '\'':
	case '"':
	  return 0;
	}
    }
  return 1;
}
warning: parse error {
  const char *r;

  for (r = s; TILDE_END(*r) == 0; r++)
    {
      switch (*r)
	{
	case '\\':
	case '\'':
	case '"':
	  return 0;
	}
    }
  return 1;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\general.c:914
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\general.c:936
parsing error 
{
  const char *r;
  char *ret;
  int l;

  for (r = s; *r && *r != '/'; r++)
    {
      /* Short-circuit immediately if we see a quote character.  Even though
	 POSIX says that `the first unquoted slash' (or `:') terminates the
	 tilde-prefix, in practice, any quoted portion of the tilde prefix
	 will cause it to not be expanded. */
      if (*r == '\\' || *r == '\'' || *r == '"')  
	{
	  ret = savestring (s);
	  if (lenp)
	    *lenp = 0;
	  return ret;
	}
      else if (flags && *r == ':')
	break;
    }
  l = r - s;
  ret = xmalloc (l + 1);
  strncpy (ret, s, l);
  ret[l] = '\0';
  if (lenp)
    *lenp = l;
  return ret;
}
warning: parse error {
  const char *r;
  char *ret;
  int l;

  for (r = s; *r && *r != '/'; r++)
    {
      /* Short-circuit immediately if we see a quote character.  Even though
	 POSIX says that `the first unquoted slash' (or `:') terminates the
	 tilde-prefix, in practice, any quoted portion of the tilde prefix
	 will cause it to not be expanded. */
      if (*r == '\\' || *r == '\'' || *r == '"')  
	{
	  ret = savestring (s);
	  if (lenp)
	    *lenp = 0;
	  return ret;
	}
      else if (flags && *r == ':')
	break;
    }
  l = r - s;
  ret = xmalloc (l + 1);
  strncpy (ret, s, l);
  ret[l] = '\0';
  if (lenp)
    *lenp = l;
  return ret;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\general.c:938
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\general.c:975
parsing error 
{
  int old_immed, old_term, r;
  char *ret;

  old_immed = interrupt_immediately;
  old_term = terminate_immediately;
  interrupt_immediately = terminate_immediately = 1;

  tilde_additional_prefixes = assign_p == 0 ? (char **)0
  					    : (assign_p == 2 ? bash_tilde_prefixes2 : bash_tilde_prefixes);
  if (assign_p == 2)
    tilde_additional_suffixes = bash_tilde_suffixes2;

  r = (*s == '~') ? unquoted_tilde_word (s) : 1;
  ret = r ? tilde_expand (s) : savestring (s);
  interrupt_immediately = old_immed;
  terminate_immediately = old_term;
  return (ret);
}
warning: parse error {
  int old_immed, old_term, r;
  char *ret;

  old_immed = interrupt_immediately;
  old_term = terminate_immediately;
  interrupt_immediately = terminate_immediately = 1;

  tilde_additional_prefixes = assign_p == 0 ? (char **)0
  					    : (assign_p == 2 ? bash_tilde_prefixes2 : bash_tilde_prefixes);
  if (assign_p == 2)
    tilde_additional_suffixes = bash_tilde_suffixes2;

  r = (*s == '~') ? unquoted_tilde_word (s) : 1;
  ret = r ? tilde_expand (s) : savestring (s);
  interrupt_immediately = old_immed;
  terminate_immediately = old_term;
  return (ret);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\general.c:977
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\general.c:1,099
parsing error 
{
  static char **group_vector = (char **)NULL;
  register int i;

  if (group_vector)
    {
      if (ngp)
	*ngp = ngroups;
      return group_vector;
    }

  if (ngroups == 0)
    initialize_group_array ();

  if (ngroups <= 0)
    {
      if (ngp)
	*ngp = 0;
      return (char **)NULL;
    }

  group_vector = strvec_create (ngroups);
  for (i = 0; i < ngroups; i++)
    group_vector[i] = itos (group_array[i]);

  if (ngp)
    *ngp = ngroups;
  return group_vector;
}
warning: parse error {
  static char **group_vector = (char **)NULL;
  register int i;

  if (group_vector)
    {
      if (ngp)
	*ngp = ngroups;
      return group_vector;
    }

  if (ngroups == 0)
    initialize_group_array ();

  if (ngroups <= 0)
    {
      if (ngp)
	*ngp = 0;
      return (char **)NULL;
    }

  group_vector = strvec_create (ngroups);
  for (i = 0; i < ngroups; i++)
    group_vector[i] = itos (group_array[i]);

  if (ngp)
    *ngp = ngroups;
  return group_vector;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\general.c:1,101
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\general.c:1,132
parsing error 
{
  int i;
  static int *group_iarray = (int *)NULL;

  if (group_iarray)
    {
      if (ngp)
	*ngp = ngroups;
      return (group_iarray);
    }

  if (ngroups == 0)
    initialize_group_array ();    

  if (ngroups <= 0)
    {
      if (ngp)
	*ngp = 0;
      return (int *)NULL;
    }

  group_iarray = (int *)xmalloc (ngroups * sizeof (int));
  for (i = 0; i < ngroups; i++)
    group_iarray[i] = (int)group_array[i];

  if (ngp)
    *ngp = ngroups;
  return group_iarray;
}
warning: parse error {
  int i;
  static int *group_iarray = (int *)NULL;

  if (group_iarray)
    {
      if (ngp)
	*ngp = ngroups;
      return (group_iarray);
    }

  if (ngroups == 0)
    initialize_group_array ();    

  if (ngroups <= 0)
    {
      if (ngp)
	*ngp = 0;
      return (int *)NULL;
    }

  group_iarray = (int *)xmalloc (ngroups * sizeof (int));
  for (i = 0; i < ngroups; i++)
    group_iarray[i] = (int)group_array[i];

  if (ngp)
    *ngp = ngroups;
  return group_iarray;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\general.c:1,134
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\hashcmd.c...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\bashtypes.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\posixstat.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\bashansi.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\shell.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\findcmd.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\hashcmd.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\hashcmd.c:51
parsing error 
{
  free (((PATH_DATA *)data)->path);
  free (data);
}
warning: parse error {
  free (((PATH_DATA *)data)->path);
  free (data);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\hashcmd.c:53
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\hashcmd.c:68
parsing error 
{
  register BUCKET_CONTENTS *item;

  if (hashing_enabled == 0 || hashed_filenames == 0)
    return 0;

  item = hash_remove (filename, hashed_filenames, 0);
  if (item)
    {
      if (item->data)
	phash_freedata (item->data);
      free (item->key);
      free (item);
      return 0;
    }
  return 1;
}
warning: parse error {
  register BUCKET_CONTENTS *item;

  if (hashing_enabled == 0 || hashed_filenames == 0)
    return 0;

  item = hash_remove (filename, hashed_filenames, 0);
  if (item)
    {
      if (item->data)
	phash_freedata (item->data);
      free (item->key);
      free (item);
      return 0;
    }
  return 1;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\hashcmd.c:69
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\hashcmd.c:93
parsing error 
{
  register BUCKET_CONTENTS *item;

  if (hashing_enabled == 0)
    return;

  if (hashed_filenames == 0)
    phash_create ();

  item = hash_insert (filename, hashed_filenames, 0);
  if (item->data)
    free (pathdata(item)->path);
  else
    {
      item->key = savestring (filename);
      item->data = xmalloc (sizeof (PATH_DATA));
    }
  pathdata(item)->path = savestring (full_path);
  pathdata(item)->flags = 0;
  if (check_dot)
    pathdata(item)->flags |= HASH_CHKDOT;
  if (*full_path != '/')
    pathdata(item)->flags |= HASH_RELPATH;
  item->times_found = found;
}
warning: parse error {
  register BUCKET_CONTENTS *item;

  if (hashing_enabled == 0)
    return;

  if (hashed_filenames == 0)
    phash_create ();

  item = hash_insert (filename, hashed_filenames, 0);
  if (item->data)
    free (pathdata(item)->path);
  else
    {
      item->key = savestring (filename);
      item->data = xmalloc (sizeof (PATH_DATA));
    }
  pathdata(item)->path = savestring (full_path);
  pathdata(item)->flags = 0;
  if (check_dot)
    pathdata(item)->flags |= HASH_CHKDOT;
  if (*full_path != '/')
    pathdata(item)->flags |= HASH_RELPATH;
  item->times_found = found;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\hashcmd.c:96
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\hashcmd.c:129
parsing error 
{
  register BUCKET_CONTENTS *item;
  char *path, *dotted_filename, *tail;
  int same;

  if (hashing_enabled == 0 || hashed_filenames == 0)
    return ((char *)NULL);

  item = hash_search (filename, hashed_filenames, 0);

  if (item == NULL)
    return ((char *)NULL);

  /* If this filename is hashed, but `.' comes before it in the path,
     see if ./filename is executable.  If the hashed value is not an
     absolute pathname, see if ./`hashed-value' exists. */
  path = pathdata(item)->path;
  if (pathdata(item)->flags & (HASH_CHKDOT|HASH_RELPATH))
    {
      tail = (pathdata(item)->flags & HASH_RELPATH) ? path : (char *)filename;	/* XXX - fix const later */
      /* If the pathname does not start with a `./', add a `./' to it. */
      if (tail[0] != '.' || tail[1] != '/')
	{
	  dotted_filename = (char *)xmalloc (3 + strlen (tail));
	  dotted_filename[0] = '.'; dotted_filename[1] = '/';
	  strcpy (dotted_filename + 2, tail);
	}
      else
	dotted_filename = savestring (tail);

      if (executable_file (dotted_filename))
	return (dotted_filename);

      free (dotted_filename);

#if 0
      if (pathdata(item)->flags & HASH_RELPATH)
	return ((char *)NULL);
#endif

      /* Watch out.  If this file was hashed to "./filename", and
	 "./filename" is not executable, then return NULL. */

      /* Since we already know "./filename" is not executable, what
	 we're really interested in is whether or not the `path'
	 portion of the hashed filename is equivalent to the current
	 directory, but only if it starts with a `.'.  (This catches
	 ./. and so on.)  same_file () tests general Unix file
	 equivalence -- same device and inode. */
      if (*path == '.')
	{
	  same = 0;
	  tail = (char *)strrchr (path, '/');

	  if (tail)
	    {
	      *tail = '\0';
	      same = same_file (".", path, (struct stat *)NULL, (struct stat *)NULL);
	      *tail = '/';
	    }

	  return same ? (char *)NULL : savestring (path);
	}
    }

  return (savestring (path));
}
warning: parse error {
  register BUCKET_CONTENTS *item;
  char *path, *dotted_filename, *tail;
  int same;

  if (hashing_enabled == 0 || hashed_filenames == 0)
    return ((char *)NULL);

  item = hash_search (filename, hashed_filenames, 0);

  if (item == NULL)
    return ((char *)NULL);

  /* If this filename is hashed, but `.' comes before it in the path,
     see if ./filename is executable.  If the hashed value is not an
     absolute pathname, see if ./`hashed-value' exists. */
  path = pathdata(item)->path;
  if (pathdata(item)->flags & (HASH_CHKDOT|HASH_RELPATH))
    {
      tail = (pathdata(item)->flags & HASH_RELPATH) ? path : (char *)filename;	/* XXX - fix const later */
      /* If the pathname does not start with a `./', add a `./' to it. */
      if (tail[0] != '.' || tail[1] != '/')
	{
	  dotted_filename = (char *)xmalloc (3 + strlen (tail));
	  dotted_filename[0] = '.'; dotted_filename[1] = '/';
	  strcpy (dotted_filename + 2, tail);
	}
      else
	dotted_filename = savestring (tail);

      if (executable_file (dotted_filename))
	return (dotted_filename);

      free (dotted_filename);

#if 0
      if (pathdata(item)->flags & HASH_RELPATH)
	return ((char *)NULL);
#endif

      /* Watch out.  If this file was hashed to "./filename", and
	 "./filename" is not executable, then return NULL. */

      /* Since we already know "./filename" is not executable, what
	 we're really interested in is whether or not the `path'
	 portion of the hashed filename is equivalent to the current
	 directory, but only if it starts with a `.'.  (This catches
	 ./. and so on.)  same_file () tests general Unix file
	 equivalence -- same device and inode. */
      if (*path == '.')
	{
	  same = 0;
	  tail = (char *)strrchr (path, '/');

	  if (tail)
	    {
	      *tail = '\0';
	      same = same_file (".", path, (struct stat *)NULL, (struct stat *)NULL);
	      *tail = '/';
	    }

	  return same ? (char *)NULL : savestring (path);
	}
    }

  return (savestring (path));
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\hashcmd.c:130
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\hashlib.c...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\bashansi.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\shell.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\hashlib.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\hashlib.c:46
parsing error 
{
  HASH_TABLE *new_table;
  register int i;

  new_table = (HASH_TABLE *)xmalloc (sizeof (HASH_TABLE));
  if (buckets == 0)
    buckets = DEFAULT_HASH_BUCKETS;

  new_table->bucket_array =
    (BUCKET_CONTENTS **)xmalloc (buckets * sizeof (BUCKET_CONTENTS *));
  new_table->nbuckets = buckets;
  new_table->nentries = 0;

  for (i = 0; i < buckets; i++)
    new_table->bucket_array[i] = (BUCKET_CONTENTS *)NULL;

  return (new_table);
}
warning: parse error {
  HASH_TABLE *new_table;
  register int i;

  new_table = (HASH_TABLE *)xmalloc (sizeof (HASH_TABLE));
  if (buckets == 0)
    buckets = DEFAULT_HASH_BUCKETS;

  new_table->bucket_array =
    (BUCKET_CONTENTS **)xmalloc (buckets * sizeof (BUCKET_CONTENTS *));
  new_table->nbuckets = buckets;
  new_table->nentries = 0;

  for (i = 0; i < buckets; i++)
    new_table->bucket_array[i] = (BUCKET_CONTENTS *)NULL;

  return (new_table);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\hashlib.c:48
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\hashlib.c:68
parsing error 
{
  return (HASH_ENTRIES(table));
}
warning: parse error {
  return (HASH_ENTRIES(table));
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\hashlib.c:70
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\hashlib.c:75
parsing error 
{
  BUCKET_CONTENTS *new_bucket, *n, *e;

  if (ba == 0)
    return ((BUCKET_CONTENTS *)0);

  for (n = (BUCKET_CONTENTS *)0, e = ba; e; e = e->next)
    {
      if (n == 0)
        {
          new_bucket = (BUCKET_CONTENTS *)xmalloc (sizeof (BUCKET_CONTENTS));
          n = new_bucket;
        }
      else
        {
          n->next = (BUCKET_CONTENTS *)xmalloc (sizeof (BUCKET_CONTENTS));
          n = n->next;
        }

      n->key = savestring (e->key);
      n->data = e->data ? (cpdata ? (*cpdata) (e->data) : savestring (e->data))
			: NULL;
      n->khash = e->khash;
      n->times_found = e->times_found;
      n->next = (BUCKET_CONTENTS *)NULL;
    }

  return new_bucket;  
}
warning: parse error {
  BUCKET_CONTENTS *new_bucket, *n, *e;

  if (ba == 0)
    return ((BUCKET_CONTENTS *)0);

  for (n = (BUCKET_CONTENTS *)0, e = ba; e; e = e->next)
    {
      if (n == 0)
        {
          new_bucket = (BUCKET_CONTENTS *)xmalloc (sizeof (BUCKET_CONTENTS));
          n = new_bucket;
        }
      else
        {
          n->next = (BUCKET_CONTENTS *)xmalloc (sizeof (BUCKET_CONTENTS));
          n = n->next;
        }

      n->key = savestring (e->key);
      n->data = e->data ? (cpdata ? (*cpdata) (e->data) : savestring (e->data))
			: NULL;
      n->khash = e->khash;
      n->times_found = e->times_found;
      n->next = (BUCKET_CONTENTS *)NULL;
    }

  return new_bucket;  
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\hashlib.c:78
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\hashlib.c:109
parsing error 
{
  HASH_TABLE *new_table;
  int i;

  if (table == 0)
    return ((HASH_TABLE *)NULL);

  new_table = hash_create (table->nbuckets);

  for (i = 0; i < table->nbuckets; i++)
    new_table->bucket_array[i] = copy_bucket_array (table->bucket_array[i], cpdata);

  new_table->nentries = table->nentries;
  return new_table;
}
warning: parse error {
  HASH_TABLE *new_table;
  int i;

  if (table == 0)
    return ((HASH_TABLE *)NULL);

  new_table = hash_create (table->nbuckets);

  for (i = 0; i < table->nbuckets; i++)
    new_table->bucket_array[i] = copy_bucket_array (table->bucket_array[i], cpdata);

  new_table->nentries = table->nentries;
  return new_table;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\hashlib.c:112
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\hashlib.c:132
parsing error 
{
  register unsigned int i;

  /* This is the best string hash function I found.

     The magic is in the interesting relationship between the special prime
     16777619 (2^24 + 403) and 2^32 and 2^8. */
 
  for (i = 0; *s; s++)
    {
      i *= 16777619;
      i ^= *s;
    }

  return i;
}
warning: parse error {
  register unsigned int i;

  /* This is the best string hash function I found.

     The magic is in the interesting relationship between the special prime
     16777619 (2^24 + 403) and 2^32 and 2^8. */
 
  for (i = 0; *s; s++)
    {
      i *= 16777619;
      i ^= *s;
    }

  return i;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\hashlib.c:133
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\hashlib.c:155
parsing error 
{
  unsigned int h;

  return (HASH_BUCKET (string, table, h));
}
warning: parse error {
  unsigned int h;

  return (HASH_BUCKET (string, table, h));
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\hashlib.c:157
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\hashlib.c:167
parsing error 
{
  BUCKET_CONTENTS *list;
  int bucket;
  unsigned int hv;

  if (table == 0 || ((flags & HASH_CREATE) == 0 && HASH_ENTRIES (table) == 0))
    return (BUCKET_CONTENTS *)NULL;

  bucket = HASH_BUCKET (string, table, hv);

  for (list = table->bucket_array ? table->bucket_array[bucket] : 0; list; list = list->next)
    {
      if (hv == list->khash && STREQ (list->key, string))
	{
	  list->times_found++;
	  return (list);
	}
    }

  if (flags & HASH_CREATE)
    {
      list = (BUCKET_CONTENTS *)xmalloc (sizeof (BUCKET_CONTENTS));
      list->next = table->bucket_array[bucket];
      table->bucket_array[bucket] = list;

      list->data = NULL;
      list->key = (char *)string;	/* XXX fix later */
      list->khash = hv;
      list->times_found = 0;

      table->nentries++;
      return (list);
    }
      
  return (BUCKET_CONTENTS *)NULL;
}
warning: parse error {
  BUCKET_CONTENTS *list;
  int bucket;
  unsigned int hv;

  if (table == 0 || ((flags & HASH_CREATE) == 0 && HASH_ENTRIES (table) == 0))
    return (BUCKET_CONTENTS *)NULL;

  bucket = HASH_BUCKET (string, table, hv);

  for (list = table->bucket_array ? table->bucket_array[bucket] : 0; list; list = list->next)
    {
      if (hv == list->khash && STREQ (list->key, string))
	{
	  list->times_found++;
	  return (list);
	}
    }

  if (flags & HASH_CREATE)
    {
      list = (BUCKET_CONTENTS *)xmalloc (sizeof (BUCKET_CONTENTS));
      list->next = table->bucket_array[bucket];
      table->bucket_array[bucket] = list;

      list->data = NULL;
      list->key = (char *)string;	/* XXX fix later */
      list->khash = hv;
      list->times_found = 0;

      table->nentries++;
      return (list);
    }
      
  return (BUCKET_CONTENTS *)NULL;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\hashlib.c:170
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\hashlib.c:212
parsing error 
{
  int bucket;
  BUCKET_CONTENTS *prev, *temp;
  unsigned int hv;

  if (table == 0 || HASH_ENTRIES (table) == 0)
    return (BUCKET_CONTENTS *)NULL;

  bucket = HASH_BUCKET (string, table, hv);
  prev = (BUCKET_CONTENTS *)NULL;
  for (temp = table->bucket_array[bucket]; temp; temp = temp->next)
    {
      if (hv == temp->khash && STREQ (temp->key, string))
	{
	  if (prev)
	    prev->next = temp->next;
	  else
	    table->bucket_array[bucket] = temp->next;

	  table->nentries--;
	  return (temp);
	}
      prev = temp;
    }
  return ((BUCKET_CONTENTS *) NULL);
}
warning: parse error {
  int bucket;
  BUCKET_CONTENTS *prev, *temp;
  unsigned int hv;

  if (table == 0 || HASH_ENTRIES (table) == 0)
    return (BUCKET_CONTENTS *)NULL;

  bucket = HASH_BUCKET (string, table, hv);
  prev = (BUCKET_CONTENTS *)NULL;
  for (temp = table->bucket_array[bucket]; temp; temp = temp->next)
    {
      if (hv == temp->khash && STREQ (temp->key, string))
	{
	  if (prev)
	    prev->next = temp->next;
	  else
	    table->bucket_array[bucket] = temp->next;

	  table->nentries--;
	  return (temp);
	}
      prev = temp;
    }
  return ((BUCKET_CONTENTS *) NULL);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\hashlib.c:215
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\hashlib.c:245
parsing error 
{
  BUCKET_CONTENTS *item;
  int bucket;
  unsigned int hv;

  if (table == 0)
    table = hash_create (0);

  item = (flags & HASH_NOSRCH) ? (BUCKET_CONTENTS *)NULL
  			       : hash_search (string, table, 0);

  if (item == 0)
    {
      bucket = HASH_BUCKET (string, table, hv);

      item = (BUCKET_CONTENTS *)xmalloc (sizeof (BUCKET_CONTENTS));
      item->next = table->bucket_array[bucket];
      table->bucket_array[bucket] = item;

      item->data = NULL;
      item->key = string;
      item->khash = hv;
      item->times_found = 0;

      table->nentries++;
    }

  return (item);
}
warning: parse error {
  BUCKET_CONTENTS *item;
  int bucket;
  unsigned int hv;

  if (table == 0)
    table = hash_create (0);

  item = (flags & HASH_NOSRCH) ? (BUCKET_CONTENTS *)NULL
  			       : hash_search (string, table, 0);

  if (item == 0)
    {
      bucket = HASH_BUCKET (string, table, hv);

      item = (BUCKET_CONTENTS *)xmalloc (sizeof (BUCKET_CONTENTS));
      item->next = table->bucket_array[bucket];
      table->bucket_array[bucket] = item;

      item->data = NULL;
      item->key = string;
      item->khash = hv;
      item->times_found = 0;

      table->nentries++;
    }

  return (item);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\hashlib.c:249
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\hashlib.c:283
parsing error 
{
  int i;
  register BUCKET_CONTENTS *bucket, *item;

  if (table == 0 || HASH_ENTRIES (table) == 0)
    return;

  for (i = 0; i < table->nbuckets; i++)
    {
      bucket = table->bucket_array[i];

      while (bucket)
	{
	  item = bucket;
	  bucket = bucket->next;

	  if (free_data)
	    (*free_data) (item->data);
	  else
	    free (item->data);
	  free (item->key);
	  free (item);
	}
      table->bucket_array[i] = (BUCKET_CONTENTS *)NULL;
    }

  table->nentries = 0;
}
warning: parse error {
  int i;
  register BUCKET_CONTENTS *bucket, *item;

  if (table == 0 || HASH_ENTRIES (table) == 0)
    return;

  for (i = 0; i < table->nbuckets; i++)
    {
      bucket = table->bucket_array[i];

      while (bucket)
	{
	  item = bucket;
	  bucket = bucket->next;

	  if (free_data)
	    (*free_data) (item->data);
	  else
	    free (item->data);
	  free (item->key);
	  free (item);
	}
      table->bucket_array[i] = (BUCKET_CONTENTS *)NULL;
    }

  table->nentries = 0;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\hashlib.c:286
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\hashlib.c:317
parsing error 
{
  free (table->bucket_array);
  free (table);
}
warning: parse error {
  free (table->bucket_array);
  free (table);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\hashlib.c:319
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\hashlib.c:325
parsing error 
{
  register int i;
  BUCKET_CONTENTS *item;

  if (table == 0 || HASH_ENTRIES (table) == 0)
    return;

  for (i = 0; i < table->nbuckets; i++)
    {
      for (item = hash_items (i, table); item; item = item->next)
	if ((*func) (item) < 0)
	  return;
    }
}
warning: parse error {
  register int i;
  BUCKET_CONTENTS *item;

  if (table == 0 || HASH_ENTRIES (table) == 0)
    return;

  for (i = 0; i < table->nbuckets; i++)
    {
      for (item = hash_items (i, table); item; item = item->next)
	if ((*func) (item) < 0)
	  return;
    }
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\hashlib.c:328
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\input.c...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\bashtypes.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\filecntl.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\posixstat.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\bashansi.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\bashintl.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\command.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\general.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\input.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\error.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\externs.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\quit.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\input.c:74
parsing error 
{
  unsigned char uc;

  CHECK_TERMSIG;

  /* Try local buffering to reduce the number of read(2) calls. */
  if (local_index == local_bufused || local_bufused == 0)
    {
      while (1)
	{
	  CHECK_TERMSIG;
	  local_bufused = read (fileno (stream), localbuf, sizeof(localbuf));
	  if (local_bufused > 0)
	    break;
	  else if (errno == X_EAGAIN || errno == X_EWOULDBLOCK)
	    {
	      if (sh_unset_nodelay_mode (fileno (stream)) < 0)
		{
		  sys_error (_("cannot reset nodelay mode for fd %d"), fileno (stream));
		  return EOF;
		}
	      continue;
	    }
	  else if (local_bufused == 0 || errno != EINTR)
	    {
	      local_index = 0;
	      return EOF;
	    }
	}
      local_index = 0;
    }
  uc = localbuf[local_index++];
  return uc;
}
warning: parse error {
  unsigned char uc;

  CHECK_TERMSIG;

  /* Try local buffering to reduce the number of read(2) calls. */
  if (local_index == local_bufused || local_bufused == 0)
    {
      while (1)
	{
	  CHECK_TERMSIG;
	  local_bufused = read (fileno (stream), localbuf, sizeof(localbuf));
	  if (local_bufused > 0)
	    break;
	  else if (errno == X_EAGAIN || errno == X_EWOULDBLOCK)
	    {
	      if (sh_unset_nodelay_mode (fileno (stream)) < 0)
		{
		  sys_error (_("cannot reset nodelay mode for fd %d"), fileno (stream));
		  return EOF;
		}
	      continue;
	    }
	  else if (local_bufused == 0 || errno != EINTR)
	    {
	      local_index = 0;
	      return EOF;
	    }
	}
      local_index = 0;
    }
  uc = localbuf[local_index++];
  return uc;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\input.c:76
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\input.c:112
parsing error 
{
  if (local_index == 0 || c == EOF)
    return EOF;
  localbuf[--local_index] = c;
  return c;
}
warning: parse error {
  if (local_index == 0 || c == EOF)
    return EOF;
  localbuf[--local_index] = c;
  return c;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\input.c:115
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\jobs.c...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\bashtypes.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\trap.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\posixtime.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\filecntl.h...skip
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\shtty.h...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\stdc.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\bashansi.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\bashintl.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\shell.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\jobs.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\execute_cmd.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\flags.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\common.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\jobs.c:333
parsing error 
{
  pid_t pgrp;

  /* ioctl will handle setting errno correctly. */
  if (ioctl (fd, TIOCGPGRP, &pgrp) < 0)
    return (-1);
  return (pgrp);
}
warning: parse error {
  pid_t pgrp;

  /* ioctl will handle setting errno correctly. */
  if (ioctl (fd, TIOCGPGRP, &pgrp) < 0)
    return (-1);
  return (pgrp);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\jobs.c:335
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\jobs.c:429
parsing error 
{
  saved_pipeline = the_pipeline;
  if (clear)
    the_pipeline = (PROCESS *)NULL;
  saved_already_making_children = already_making_children;
}
warning: parse error {
  saved_pipeline = the_pipeline;
  if (clear)
    the_pipeline = (PROCESS *)NULL;
  saved_already_making_children = already_making_children;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\jobs.c:431
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\jobs.c:439
parsing error 
{
  PROCESS *old_pipeline;

  old_pipeline = the_pipeline;
  the_pipeline = saved_pipeline;
  already_making_children = saved_already_making_children;
  if (discard && old_pipeline)
    discard_pipeline (old_pipeline);
}
warning: parse error {
  PROCESS *old_pipeline;

  old_pipeline = the_pipeline;
  the_pipeline = saved_pipeline;
  already_making_children = saved_already_making_children;
  if (discard && old_pipeline)
    discard_pipeline (old_pipeline);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\jobs.c:441
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\jobs.c:478
parsing error 
{
  register int i, j;
  JOB *newjob;
  sigset_t set, oset;

  BLOCK_CHILD (set, oset);

#if defined (PGRP_PIPE)
  /* The parent closes the process group synchronization pipe. */
  sh_closepipe (pgrp_pipe);
#endif

  cleanup_dead_jobs ();

  if (js.j_jobslots == 0)
    {
      js.j_jobslots = JOB_SLOTS;
      jobs = (JOB **)xmalloc (js.j_jobslots * sizeof (JOB *));

      /* Now blank out these new entries. */
      for (i = 0; i < js.j_jobslots; i++)
	jobs[i] = (JOB *)NULL;

      js.j_firstj = js.j_lastj = js.j_njobs = 0;
    }

  /* Scan from the last slot backward, looking for the next free one. */
  /* XXX - revisit this interactive assumption */
  /* XXX - this way for now */
  if (interactive)
    {
      for (i = js.j_jobslots; i; i--)
	if (jobs[i - 1])
	  break;
    }
  else
    {
#if 0
      /* This wraps around, but makes it inconvenient to extend the array */
      for (i = js.j_lastj+1; i != js.j_lastj; i++)
	{
	  if (i >= js.j_jobslots)
	    i = 0;
	  if (jobs[i] == 0)
	    break;
	}	
      if (i == js.j_lastj)
        i = js.j_jobslots;
#else
      /* This doesn't wrap around yet. */
      for (i = js.j_lastj ? js.j_lastj + 1 : js.j_lastj; i < js.j_jobslots; i++)
	if (jobs[i] == 0)
	  break;
#endif
    }

  /* Do we need more room? */

  /* First try compaction */
  if ((interactive_shell == 0 || subshell_environment) && i == js.j_jobslots && js.j_jobslots >= MAX_JOBS_IN_ARRAY)
    i = compact_jobs_list (0);

  /* If we can't compact, reallocate */
  if (i == js.j_jobslots)
    {
      js.j_jobslots += JOB_SLOTS;
      jobs = (JOB **)xrealloc (jobs, (js.j_jobslots * sizeof (JOB *)));

      for (j = i; j < js.j_jobslots; j++)
	jobs[j] = (JOB *)NULL;
    }

  /* Add the current pipeline to the job list. */
  if (the_pipeline)
    {
      register PROCESS *p;
      int any_running, any_stopped, n;

      newjob = (JOB *)xmalloc (sizeof (JOB));

      for (n = 1, p = the_pipeline; p->next != the_pipeline; n++, p = p->next)
	;
      p->next = (PROCESS *)NULL;
      newjob->pipe = REVERSE_LIST (the_pipeline, PROCESS *);
      for (p = newjob->pipe; p->next; p = p->next)
	;
      p->next = newjob->pipe;

      the_pipeline = (PROCESS *)NULL;
      newjob->pgrp = pipeline_pgrp;
      pipeline_pgrp = 0;

      newjob->flags = 0;

      /* Flag to see if in another pgrp. */
      if (job_control)
	newjob->flags |= J_JOBCONTROL;

      /* Set the state of this pipeline. */
      p = newjob->pipe;
      any_running = any_stopped = 0;
      do
	{
	  any_running |= PRUNNING (p);
	  any_stopped |= PSTOPPED (p);
	  p = p->next;
	}
      while (p != newjob->pipe);

      newjob->state = any_running ? JRUNNING : (any_stopped ? JSTOPPED : JDEAD);
      newjob->wd = job_working_directory ();
      newjob->deferred = deferred;

      newjob->j_cleanup = (sh_vptrfunc_t *)NULL;
      newjob->cleanarg = (PTR_T) NULL;

      jobs[i] = newjob;
      if (newjob->state == JDEAD && (newjob->flags & J_FOREGROUND))
	setjstatus (i);
      if (newjob->state == JDEAD)
	{
	  js.c_reaped += n;	/* wouldn't have been done since this was not part of a job */
	  js.j_ndead++;
	}
      js.c_injobs += n;

      js.j_lastj = i;
      js.j_njobs++;
    }
  else
    newjob = (JOB *)NULL;

  if (newjob)
    js.j_lastmade = newjob;

  if (async)
    {
      if (newjob)
	{
	  newjob->flags &= ~J_FOREGROUND;
	  newjob->flags |= J_ASYNC;
	  js.j_lastasync = newjob;
	}
      reset_current ();
    }
  else
    {
      if (newjob)
	{
	  newjob->flags |= J_FOREGROUND;
	  /*
	   *		!!!!! NOTE !!!!!  (chet@ins.cwru.edu)
	   *
	   * The currently-accepted job control wisdom says to set the
	   * terminal's process group n+1 times in an n-step pipeline:
	   * once in the parent and once in each child.  This is where
	   * the parent gives it away.
	   *
	   * Don't give the terminal away if this shell is an asynchronous
	   * subshell.
	   *
	   */
	  if (job_control && newjob->pgrp && (subshell_environment&SUBSHELL_ASYNC) == 0)
	    maybe_give_terminal_to (shell_pgrp, newjob->pgrp, 0);
	}
    }

  stop_making_children ();
  UNBLOCK_CHILD (oset);
  return (newjob ? i : js.j_current);
}
warning: parse error {
  register int i, j;
  JOB *newjob;
  sigset_t set, oset;

  BLOCK_CHILD (set, oset);

#if defined (PGRP_PIPE)
  /* The parent closes the process group synchronization pipe. */
  sh_closepipe (pgrp_pipe);
#endif

  cleanup_dead_jobs ();

  if (js.j_jobslots == 0)
    {
      js.j_jobslots = JOB_SLOTS;
      jobs = (JOB **)xmalloc (js.j_jobslots * sizeof (JOB *));

      /* Now blank out these new entries. */
      for (i = 0; i < js.j_jobslots; i++)
	jobs[i] = (JOB *)NULL;

      js.j_firstj = js.j_lastj = js.j_njobs = 0;
    }

  /* Scan from the last slot backward, looking for the next free one. */
  /* XXX - revisit this interactive assumption */
  /* XXX - this way for now */
  if (interactive)
    {
      for (i = js.j_jobslots; i; i--)
	if (jobs[i - 1])
	  break;
    }
  else
    {
#if 0
      /* This wraps around, but makes it inconvenient to extend the array */
      for (i = js.j_lastj+1; i != js.j_lastj; i++)
	{
	  if (i >= js.j_jobslots)
	    i = 0;
	  if (jobs[i] == 0)
	    break;
	}	
      if (i == js.j_lastj)
        i = js.j_jobslots;
#else
      /* This doesn't wrap around yet. */
      for (i = js.j_lastj ? js.j_lastj + 1 : js.j_lastj; i < js.j_jobslots; i++)
	if (jobs[i] == 0)
	  break;
#endif
    }

  /* Do we need more room? */

  /* First try compaction */
  if ((interactive_shell == 0 || subshell_environment) && i == js.j_jobslots && js.j_jobslots >= MAX_JOBS_IN_ARRAY)
    i = compact_jobs_list (0);

  /* If we can't compact, reallocate */
  if (i == js.j_jobslots)
    {
      js.j_jobslots += JOB_SLOTS;
      jobs = (JOB **)xrealloc (jobs, (js.j_jobslots * sizeof (JOB *)));

      for (j = i; j < js.j_jobslots; j++)
	jobs[j] = (JOB *)NULL;
    }

  /* Add the current pipeline to the job list. */
  if (the_pipeline)
    {
      register PROCESS *p;
      int any_running, any_stopped, n;

      newjob = (JOB *)xmalloc (sizeof (JOB));

      for (n = 1, p = the_pipeline; p->next != the_pipeline; n++, p = p->next)
	;
      p->next = (PROCESS *)NULL;
      newjob->pipe = REVERSE_LIST (the_pipeline, PROCESS *);
      for (p = newjob->pipe; p->next; p = p->next)
	;
      p->next = newjob->pipe;

      the_pipeline = (PROCESS *)NULL;
      newjob->pgrp = pipeline_pgrp;
      pipeline_pgrp = 0;

      newjob->flags = 0;

      /* Flag to see if in another pgrp. */
      if (job_control)
	newjob->flags |= J_JOBCONTROL;

      /* Set the state of this pipeline. */
      p = newjob->pipe;
      any_running = any_stopped = 0;
      do
	{
	  any_running |= PRUNNING (p);
	  any_stopped |= PSTOPPED (p);
	  p = p->next;
	}
      while (p != newjob->pipe);

      newjob->state = any_running ? JRUNNING : (any_stopped ? JSTOPPED : JDEAD);
      newjob->wd = job_working_directory ();
      newjob->deferred = deferred;

      newjob->j_cleanup = (sh_vptrfunc_t *)NULL;
      newjob->cleanarg = (PTR_T) NULL;

      jobs[i] = newjob;
      if (newjob->state == JDEAD && (newjob->flags & J_FOREGROUND))
	setjstatus (i);
      if (newjob->state == JDEAD)
	{
	  js.c_reaped += n;	/* wouldn't have been done since this was not part of a job */
	  js.j_ndead++;
	}
      js.c_injobs += n;

      js.j_lastj = i;
      js.j_njobs++;
    }
  else
    newjob = (JOB *)NULL;

  if (newjob)
    js.j_lastmade = newjob;

  if (async)
    {
      if (newjob)
	{
	  newjob->flags &= ~J_FOREGROUND;
	  newjob->flags |= J_ASYNC;
	  js.j_lastasync = newjob;
	}
      reset_current ();
    }
  else
    {
      if (newjob)
	{
	  newjob->flags |= J_FOREGROUND;
	  /*
	   *		!!!!! NOTE !!!!!  (chet@ins.cwru.edu)
	   *
	   * The currently-accepted job control wisdom says to set the
	   * terminal's process group n+1 times in an n-step pipeline:
	   * once in the parent and once in each child.  This is where
	   * the parent gives it away.
	   *
	   * Don't give the terminal away if this shell is an asynchronous
	   * subshell.
	   *
	   */
	  if (job_control && newjob->pgrp && (subshell_environment&SUBSHELL_ASYNC) == 0)
	    maybe_give_terminal_to (shell_pgrp, newjob->pgrp, 0);
	}
    }

  stop_making_children ();
  UNBLOCK_CHILD (oset);
  return (newjob ? i : js.j_current);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\jobs.c:481
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\jobs.c:657
parsing error 
{
  struct pidstat *ps;

  ps = (struct pidstat *)xmalloc (sizeof (struct pidstat));
  ps->pid = pid;
  ps->status = status;
  ps->next = (struct pidstat *)0;
  return ps;
}
warning: parse error {
  struct pidstat *ps;

  ps = (struct pidstat *)xmalloc (sizeof (struct pidstat));
  ps->pid = pid;
  ps->status = status;
  ps->next = (struct pidstat *)0;
  return ps;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\jobs.c:660
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\jobs.c:671
parsing error 
{
  struct pidstat *ps;

  ps = bgp_alloc (pid, status);

  if (bgpids.list == 0)
    {
      bgpids.list = bgpids.end = ps;
      bgpids.npid = 0;			/* just to make sure */
    }
  else
    {
      bgpids.end->next = ps;
      bgpids.end = ps;
    }
  bgpids.npid++;

  if (bgpids.npid > js.c_childmax)
    bgp_prune ();

  return ps;
}
warning: parse error {
  struct pidstat *ps;

  ps = bgp_alloc (pid, status);

  if (bgpids.list == 0)
    {
      bgpids.list = bgpids.end = ps;
      bgpids.npid = 0;			/* just to make sure */
    }
  else
    {
      bgpids.end->next = ps;
      bgpids.end = ps;
    }
  bgpids.npid++;

  if (bgpids.npid > js.c_childmax)
    bgp_prune ();

  return ps;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\jobs.c:674
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\jobs.c:698
parsing error 
{
  struct pidstat *prev, *p;

  for (prev = p = bgpids.list; p; prev = p, p = p->next)
    if (p->pid == pid)
      {
	prev->next = p->next;	/* remove from list */
	break;
      }

  if (p == 0)
    return 0;		/* not found */

#if defined (DEBUG)
  itrace("bgp_delete: deleting %d", pid);
#endif

  /* Housekeeping in the border cases. */
  if (p == bgpids.list)
    bgpids.list = bgpids.list->next;
  else if (p == bgpids.end)
    bgpids.end = prev;

  bgpids.npid--;
  if (bgpids.npid == 0)
    bgpids.list = bgpids.end = 0;
  else if (bgpids.npid == 1)
    bgpids.end = bgpids.list;		/* just to make sure */

  free (p);
  return 1;
}
warning: parse error {
  struct pidstat *prev, *p;

  for (prev = p = bgpids.list; p; prev = p, p = p->next)
    if (p->pid == pid)
      {
	prev->next = p->next;	/* remove from list */
	break;
      }

  if (p == 0)
    return 0;		/* not found */

#if defined (DEBUG)
  itrace("bgp_delete: deleting %d", pid);
#endif

  /* Housekeeping in the border cases. */
  if (p == bgpids.list)
    bgpids.list = bgpids.list->next;
  else if (p == bgpids.end)
    bgpids.end = prev;

  bgpids.npid--;
  if (bgpids.npid == 0)
    bgpids.list = bgpids.end = 0;
  else if (bgpids.npid == 1)
    bgpids.end = bgpids.list;		/* just to make sure */

  free (p);
  return 1;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\jobs.c:700
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\jobs.c:752
parsing error 
{
  struct pidstat *ps;

  for (ps = bgpids.list ; ps; ps = ps->next)
    if (ps->pid == pid)
      return ps->status;
  return -1;
}
warning: parse error {
  struct pidstat *ps;

  for (ps = bgpids.list ; ps; ps = ps->next)
    if (ps->pid == pid)
      return ps->status;
  return -1;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\jobs.c:754
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\jobs.c:854
parsing error 
{
  int nproc;
  register PROCESS *p;

  nproc = 0;
  p = jobs[job]->pipe;
  do
    {
      p = p->next;
      nproc++;
    }
  while (p != jobs[job]->pipe);

  return nproc;
}
warning: parse error {
  int nproc;
  register PROCESS *p;

  nproc = 0;
  p = jobs[job]->pipe;
  do
    {
      p = p->next;
      nproc++;
    }
  while (p != jobs[job]->pipe);

  return nproc;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\jobs.c:856
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\jobs.c:873
parsing error 
{
  PROCESS *p;
  int job;

  job = find_job (pid, 0, &p);
  if (job != NO_JOB)
    {
#ifdef DEBUG
      itrace ("delete_old_job: found pid %d in job %d with state %d", pid, job, jobs[job]->state);
#endif
      if (JOBSTATE (job) == JDEAD)
	delete_job (job, DEL_NOBGPID);
      else
	{
	  internal_warning (_("forked pid %d appears in running job %d"), pid, job);
	  if (p)
	    p->pid = 0;
	}
    }
}
warning: parse error {
  PROCESS *p;
  int job;

  job = find_job (pid, 0, &p);
  if (job != NO_JOB)
    {
#ifdef DEBUG
      itrace ("delete_old_job: found pid %d in job %d with state %d", pid, job, jobs[job]->state);
#endif
      if (JOBSTATE (job) == JDEAD)
	delete_job (job, DEL_NOBGPID);
      else
	{
	  internal_warning (_("forked pid %d appears in running job %d"), pid, job);
	  if (p)
	    p->pid = 0;
	}
    }
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\jobs.c:875
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\jobs.c:977
parsing error 
{
  if (js.j_jobslots == 0 || jobs_list_frozen)
    return js.j_jobslots;

  reap_dead_jobs ();
  realloc_jobs_list ();

#ifdef DEBUG
  itrace("compact_jobs_list: returning %d", (js.j_lastj || jobs[js.j_lastj]) ? js.j_lastj + 1 : 0);
#endif

  return ((js.j_lastj || jobs[js.j_lastj]) ? js.j_lastj + 1 : 0);
}
warning: parse error {
  if (js.j_jobslots == 0 || jobs_list_frozen)
    return js.j_jobslots;

  reap_dead_jobs ();
  realloc_jobs_list ();

#ifdef DEBUG
  itrace("compact_jobs_list: returning %d", (js.j_lastj || jobs[js.j_lastj]) ? js.j_lastj + 1 : 0);
#endif

  return ((js.j_lastj || jobs[js.j_lastj]) ? js.j_lastj + 1 : 0);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\jobs.c:979
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\jobs.c:996
parsing error 
{
  register JOB *temp;
  PROCESS *proc;
  int ndel;

  if (js.j_jobslots == 0 || jobs_list_frozen)
    return;

  if ((dflags & DEL_WARNSTOPPED) && subshell_environment == 0 && STOPPED (job_index))
    internal_warning (_("deleting stopped job %d with process group %ld"), job_index+1, (long)jobs[job_index]->pgrp);
  temp = jobs[job_index];
  if (temp == 0)
    return;

  if ((dflags & DEL_NOBGPID) == 0)
    {
      proc = find_last_proc (job_index, 0);
      /* Could do this just for J_ASYNC jobs, but we save all. */
      if (proc)
	bgp_add (proc->pid, process_exit_status (proc->status));
    }

  jobs[job_index] = (JOB *)NULL;
  if (temp == js.j_lastmade)
    js.j_lastmade = 0;
  else if (temp == js.j_lastasync)
    js.j_lastasync = 0;

  free (temp->wd);
  ndel = discard_pipeline (temp->pipe);

  js.c_injobs -= ndel;
  if (temp->state == JDEAD)
    {
      js.c_reaped -= ndel;
      js.j_ndead--;
      if (js.c_reaped < 0)
	{
#ifdef DEBUG
	  itrace("delete_job (%d pgrp %d): js.c_reaped (%d) < 0 ndel = %d js.j_ndead = %d", job_index, temp->pgrp, js.c_reaped, ndel, js.j_ndead);
#endif
	  js.c_reaped = 0;
	}
    }

  if (temp->deferred)
    dispose_command (temp->deferred);

  free (temp);

  js.j_njobs--;
  if (js.j_njobs == 0)
    js.j_firstj = js.j_lastj = 0;
  else if (jobs[js.j_firstj] == 0 || jobs[js.j_lastj] == 0)
    reset_job_indices ();

  if (job_index == js.j_current || job_index == js.j_previous)
    reset_current ();
}
warning: parse error {
  register JOB *temp;
  PROCESS *proc;
  int ndel;

  if (js.j_jobslots == 0 || jobs_list_frozen)
    return;

  if ((dflags & DEL_WARNSTOPPED) && subshell_environment == 0 && STOPPED (job_index))
    internal_warning (_("deleting stopped job %d with process group %ld"), job_index+1, (long)jobs[job_index]->pgrp);
  temp = jobs[job_index];
  if (temp == 0)
    return;

  if ((dflags & DEL_NOBGPID) == 0)
    {
      proc = find_last_proc (job_index, 0);
      /* Could do this just for J_ASYNC jobs, but we save all. */
      if (proc)
	bgp_add (proc->pid, process_exit_status (proc->status));
    }

  jobs[job_index] = (JOB *)NULL;
  if (temp == js.j_lastmade)
    js.j_lastmade = 0;
  else if (temp == js.j_lastasync)
    js.j_lastasync = 0;

  free (temp->wd);
  ndel = discard_pipeline (temp->pipe);

  js.c_injobs -= ndel;
  if (temp->state == JDEAD)
    {
      js.c_reaped -= ndel;
      js.j_ndead--;
      if (js.c_reaped < 0)
	{
#ifdef DEBUG
	  itrace("delete_job (%d pgrp %d): js.c_reaped (%d) < 0 ndel = %d js.j_ndead = %d", job_index, temp->pgrp, js.c_reaped, ndel, js.j_ndead);
#endif
	  js.c_reaped = 0;
	}
    }

  if (temp->deferred)
    dispose_command (temp->deferred);

  free (temp);

  js.j_njobs--;
  if (js.j_njobs == 0)
    js.j_firstj = js.j_lastj = 0;
  else if (jobs[js.j_firstj] == 0 || jobs[js.j_lastj] == 0)
    reset_job_indices ();

  if (job_index == js.j_current || job_index == js.j_previous)
    reset_current ();
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\jobs.c:998
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\jobs.c:1,060
parsing error 
{
  register JOB *temp;

  if (js.j_jobslots == 0)
    return;

  if (temp = jobs[job_index])
    temp->flags |= J_NOHUP;
}
warning: parse error {
  register JOB *temp;

  if (js.j_jobslots == 0)
    return;

  if (temp = jobs[job_index])
    temp->flags |= J_NOHUP;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\jobs.c:1,062
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\jobs.c:1,074
parsing error 
{
  register PROCESS *this, *next;
  int n;

  this = chain;
  n = 0;
  do
    {
      next = this->next;
      FREE (this->command);
      free (this);
      n++;
      this = next;
    }
  while (this != chain);

  return n;
}
warning: parse error {
  register PROCESS *this, *next;
  int n;

  this = chain;
  n = 0;
  do
    {
      next = this->next;
      FREE (this->command);
      free (this);
      n++;
      this = next;
    }
  while (this != chain);

  return n;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\jobs.c:1,076
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\jobs.c:1,099
parsing error 
{
  PROCESS *t, *p;

#if defined (RECYCLES_PIDS)
  int j;
  p = find_process (pid, 0, &j);
  if (p)
    {
#  ifdef DEBUG
      if (j == NO_JOB)
	internal_warning (_("add_process: process %5ld (%s) in the_pipeline"), (long)p->pid, p->command);
#  endif
      if (PALIVE (p))
        internal_warning (_("add_process: pid %5ld (%s) marked as still alive"), (long)p->pid, p->command);
      p->running = PS_RECYCLED;		/* mark as recycled */
    }
#endif

  t = (PROCESS *)xmalloc (sizeof (PROCESS));
  t->next = the_pipeline;
  t->pid = pid;
  WSTATUS (t->status) = 0;
  t->running = PS_RUNNING;
  t->command = name;
  the_pipeline = t;

  if (t->next == 0)
    t->next = t;
  else
    {
      p = t->next;
      while (p->next != t->next)
	p = p->next;
      p->next = t;
    }
}
warning: parse error {
  PROCESS *t, *p;

#if defined (RECYCLES_PIDS)
  int j;
  p = find_process (pid, 0, &j);
  if (p)
    {
#  ifdef DEBUG
      if (j == NO_JOB)
	internal_warning (_("add_process: process %5ld (%s) in the_pipeline"), (long)p->pid, p->command);
#  endif
      if (PALIVE (p))
        internal_warning (_("add_process: pid %5ld (%s) marked as still alive"), (long)p->pid, p->command);
      p->running = PS_RECYCLED;		/* mark as recycled */
    }
#endif

  t = (PROCESS *)xmalloc (sizeof (PROCESS));
  t->next = the_pipeline;
  t->pid = pid;
  WSTATUS (t->status) = 0;
  t->running = PS_RUNNING;
  t->command = name;
  the_pipeline = t;

  if (t->next == 0)
    t->next = t;
  else
    {
      p = t->next;
      while (p->next != t->next)
	p = p->next;
      p->next = t;
    }
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\jobs.c:1,102
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\jobs.c:1,142
parsing error 
{
  PROCESS *t, *p;

  t = (PROCESS *)xmalloc (sizeof (PROCESS));
  t->next = (PROCESS *)NULL;
  t->pid = pid;
  /* set process exit status using offset discovered by configure */
  t->status = (status & 0xff) << WEXITSTATUS_OFFSET;
  t->running = PS_DONE;
  t->command = name;

  js.c_reaped++;	/* XXX */

  for (p = jobs[jid]->pipe; p->next != jobs[jid]->pipe; p = p->next)
    ;
  p->next = t;
  t->next = jobs[jid]->pipe;
}
warning: parse error {
  PROCESS *t, *p;

  t = (PROCESS *)xmalloc (sizeof (PROCESS));
  t->next = (PROCESS *)NULL;
  t->pid = pid;
  /* set process exit status using offset discovered by configure */
  t->status = (status & 0xff) << WEXITSTATUS_OFFSET;
  t->running = PS_DONE;
  t->command = name;

  js.c_reaped++;	/* XXX */

  for (p = jobs[jid]->pipe; p->next != jobs[jid]->pipe; p = p->next)
    ;
  p->next = t;
  t->next = jobs[jid]->pipe;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\jobs.c:1,147
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\jobs.c:1,209
parsing error 
{
  register int i;
  int result;
  sigset_t set, oset;

  if (js.j_jobslots == 0)
    return 0;

  BLOCK_CHILD (set, oset);

  /* XXX could use js.j_firstj here */
  for (i = result = 0; i < js.j_jobslots; i++)
    {
#if defined (DEBUG)
      if (i < js.j_firstj && jobs[i])
	itrace("map_over_jobs: job %d non-null before js.j_firstj (%d)", i, js.j_firstj);
      if (i > js.j_lastj && jobs[i])
	itrace("map_over_jobs: job %d non-null after js.j_lastj (%d)", i, js.j_lastj);
#endif
      if (jobs[i])
	{
	  result = (*func)(jobs[i], arg1, arg2, i);
	  if (result)
	    break;
	}
    }

  UNBLOCK_CHILD (oset);

  return (result);
}
warning: parse error {
  register int i;
  int result;
  sigset_t set, oset;

  if (js.j_jobslots == 0)
    return 0;

  BLOCK_CHILD (set, oset);

  /* XXX could use js.j_firstj here */
  for (i = result = 0; i < js.j_jobslots; i++)
    {
#if defined (DEBUG)
      if (i < js.j_firstj && jobs[i])
	itrace("map_over_jobs: job %d non-null before js.j_firstj (%d)", i, js.j_firstj);
      if (i > js.j_lastj && jobs[i])
	itrace("map_over_jobs: job %d non-null after js.j_lastj (%d)", i, js.j_lastj);
#endif
      if (jobs[i])
	{
	  result = (*func)(jobs[i], arg1, arg2, i);
	  if (result)
	    break;
	}
    }

  UNBLOCK_CHILD (oset);

  return (result);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\jobs.c:1,212
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\jobs.c:1,304
parsing error 
{
  int job;
  PROCESS *p;

  /* See if this process is in the pipeline that we are building. */
  if (jobp)
    *jobp = NO_JOB;
  if (the_pipeline)
    {
      p = the_pipeline;
      do
	{
	  /* Return it if we found it.  Don't ever return a recycled pid. */
	  if (p->pid == pid && ((alive_only == 0 && PRECYCLED(p) == 0) || PALIVE(p)))
	    return (p);

	  p = p->next;
	}
      while (p != the_pipeline);
    }

  job = find_job (pid, alive_only, &p);
  if (jobp)
    *jobp = job;
  return (job == NO_JOB) ? (PROCESS *)NULL : jobs[job]->pipe;
}
warning: parse error {
  int job;
  PROCESS *p;

  /* See if this process is in the pipeline that we are building. */
  if (jobp)
    *jobp = NO_JOB;
  if (the_pipeline)
    {
      p = the_pipeline;
      do
	{
	  /* Return it if we found it.  Don't ever return a recycled pid. */
	  if (p->pid == pid && ((alive_only == 0 && PRECYCLED(p) == 0) || PALIVE(p)))
	    return (p);

	  p = p->next;
	}
      while (p != the_pipeline);
    }

  job = find_job (pid, alive_only, &p);
  if (jobp)
    *jobp = job;
  return (job == NO_JOB) ? (PROCESS *)NULL : jobs[job]->pipe;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\jobs.c:1,308
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\jobs.c:1,339
parsing error 
{
  PROCESS *p;

  p = find_pipeline (pid, alive_only, jobp);
  while (p && p->pid != pid)
    p = p->next;
  return p;
}
warning: parse error {
  PROCESS *p;

  p = find_pipeline (pid, alive_only, jobp);
  while (p && p->pid != pid)
    p = p->next;
  return p;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\jobs.c:1,343
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\jobs.c:1,355
parsing error 
{
  register int i;
  PROCESS *p;

  /* XXX could use js.j_firstj here, and should check js.j_lastj */
  for (i = 0; i < js.j_jobslots; i++)
    {
#if defined (DEBUG)
      if (i < js.j_firstj && jobs[i])
	itrace("find_job: job %d non-null before js.j_firstj (%d)", i, js.j_firstj);
      if (i > js.j_lastj && jobs[i])
	itrace("find_job: job %d non-null after js.j_lastj (%d)", i, js.j_lastj);
#endif
      if (jobs[i])
	{
	  p = jobs[i]->pipe;

	  do
	    {
	      if (p->pid == pid && ((alive_only == 0 && PRECYCLED(p) == 0) || PALIVE(p)))
		{
		  if (procp)
		    *procp = p;
		  return (i);
		}

	      p = p->next;
	    }
	  while (p != jobs[i]->pipe);
	}
    }

  return (NO_JOB);
}
warning: parse error {
  register int i;
  PROCESS *p;

  /* XXX could use js.j_firstj here, and should check js.j_lastj */
  for (i = 0; i < js.j_jobslots; i++)
    {
#if defined (DEBUG)
      if (i < js.j_firstj && jobs[i])
	itrace("find_job: job %d non-null before js.j_firstj (%d)", i, js.j_firstj);
      if (i > js.j_lastj && jobs[i])
	itrace("find_job: job %d non-null after js.j_lastj (%d)", i, js.j_lastj);
#endif
      if (jobs[i])
	{
	  p = jobs[i]->pipe;

	  do
	    {
	      if (p->pid == pid && ((alive_only == 0 && PRECYCLED(p) == 0) || PALIVE(p)))
		{
		  if (procp)
		    *procp = p;
		  return (i);
		}

	      p = p->next;
	    }
	  while (p != jobs[i]->pipe);
	}
    }

  return (NO_JOB);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\jobs.c:1,359
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\jobs.c:1,397
parsing error 
{
  int job;
  sigset_t set, oset;

  if (block)
    BLOCK_CHILD (set, oset);

  job = find_job (pid, 0, NULL);

  if (block)
    UNBLOCK_CHILD (oset);

  return job;
}
warning: parse error {
  int job;
  sigset_t set, oset;

  if (block)
    BLOCK_CHILD (set, oset);

  job = find_job (pid, 0, NULL);

  if (block)
    UNBLOCK_CHILD (oset);

  return job;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\jobs.c:1,400
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\jobs.c:1,417
parsing error 
{
  int job;
  sigset_t set, oset;

  BLOCK_CHILD (set, oset);

  job = find_job (pid, 0, NULL);

  if (job != NO_JOB)
    fprintf (stderr, "[%d] %ld\n", job + 1, (long)pid);
  else
    programming_error (_("describe_pid: %ld: no such pid"), (long)pid);

  UNBLOCK_CHILD (oset);
}
warning: parse error {
  int job;
  sigset_t set, oset;

  BLOCK_CHILD (set, oset);

  job = find_job (pid, 0, NULL);

  if (job != NO_JOB)
    fprintf (stderr, "[%d] %ld\n", job + 1, (long)pid);
  else
    programming_error (_("describe_pid: %ld: no such pid"), (long)pid);

  UNBLOCK_CHILD (oset);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\jobs.c:1,419
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\jobs.c:1,436
parsing error 
{
  char *x;

  x = strsignal (s);
  if (x == 0)
    {
      x = retcode_name_buffer;
      sprintf (x, _("Signal %d"), s);
    }
  return x;
}
warning: parse error {
  char *x;

  x = strsignal (s);
  if (x == 0)
    {
      x = retcode_name_buffer;
      sprintf (x, _("Signal %d"), s);
    }
  return x;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\jobs.c:1,438
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\jobs.c:1,451
parsing error 
{
  static char *temp;
  int es;

  temp = _("Done");

  if (STOPPED (j) && format == 0)
    {
      if (posixly_correct == 0 || p == 0 || (WIFSTOPPED (p->status) == 0))
	temp = _("Stopped");
      else
	{
	  temp = retcode_name_buffer;
	  sprintf (temp, _("Stopped(%s)"), signal_name (WSTOPSIG (p->status)));
	}
    }
  else if (RUNNING (j))
    temp = _("Running");
  else
    {
      if (WIFSTOPPED (p->status))
	temp = j_strsignal (WSTOPSIG (p->status));
      else if (WIFSIGNALED (p->status))
	temp = j_strsignal (WTERMSIG (p->status));
      else if (WIFEXITED (p->status))
	{
	  temp = retcode_name_buffer;
	  es = WEXITSTATUS (p->status);
	  if (es == 0)
	    strcpy (temp, _("Done"));
	  else if (posixly_correct)
	    sprintf (temp, _("Done(%d)"), es);
	  else
	    sprintf (temp, _("Exit %d"), es);
	}
      else
	temp = _("Unknown status");
    }

  return temp;
}
warning: parse error {
  static char *temp;
  int es;

  temp = _("Done");

  if (STOPPED (j) && format == 0)
    {
      if (posixly_correct == 0 || p == 0 || (WIFSTOPPED (p->status) == 0))
	temp = _("Stopped");
      else
	{
	  temp = retcode_name_buffer;
	  sprintf (temp, _("Stopped(%s)"), signal_name (WSTOPSIG (p->status)));
	}
    }
  else if (RUNNING (j))
    temp = _("Running");
  else
    {
      if (WIFSTOPPED (p->status))
	temp = j_strsignal (WSTOPSIG (p->status));
      else if (WIFSIGNALED (p->status))
	temp = j_strsignal (WTERMSIG (p->status));
      else if (WIFEXITED (p->status))
	{
	  temp = retcode_name_buffer;
	  es = WEXITSTATUS (p->status);
	  if (es == 0)
	    strcpy (temp, _("Done"));
	  else if (posixly_correct)
	    sprintf (temp, _("Done(%d)"), es);
	  else
	    sprintf (temp, _("Exit %d"), es);
	}
      else
	temp = _("Unknown status");
    }

  return temp;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\jobs.c:1,455
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\jobs.c:1,521
parsing error 
{
  PROCESS *first, *last, *show;
  int es, name_padding;
  char *temp;

  if (p == 0)
    return;

  first = last = p;
  while (last->next != first)
    last = last->next;

  for (;;)
    {
      if (p != first)
	fprintf (stream, format ? "     " : " |");

      if (format != JLIST_STANDARD)
	fprintf (stream, "%5ld", (long)p->pid);

      fprintf (stream, " ");

      if (format > -1 && job_index >= 0)
	{
	  show = format ? p : last;
	  temp = printable_job_status (job_index, show, format);

	  if (p != first)
	    {
	      if (format)
		{
		  if (show->running == first->running &&
		      WSTATUS (show->status) == WSTATUS (first->status))
		    temp = "";
		}
	      else
		temp = (char *)NULL;
	    }

	  if (temp)
	    {
	      fprintf (stream, "%s", temp);

	      es = STRLEN (temp);
	      if (es == 0)
		es = 2;	/* strlen ("| ") */
	      name_padding = LONGEST_SIGNAL_DESC - es;

	      fprintf (stream, "%*s", name_padding, "");

	      if ((WIFSTOPPED (show->status) == 0) &&
		  (WIFCONTINUED (show->status) == 0) &&
		  WIFCORED (show->status))
		fprintf (stream, _("(core dumped) "));
	    }
	}

      if (p != first && format)
	fprintf (stream, "| ");

      if (p->command)
	fprintf (stream, "%s", p->command);

      if (p == last && job_index >= 0)
	{
	  temp = current_working_directory ();

	  if (RUNNING (job_index) && (IS_FOREGROUND (job_index) == 0))
	    fprintf (stream, " &");

	  if (strcmp (temp, jobs[job_index]->wd) != 0)
	    fprintf (stream,
	      _("  (wd: %s)"), polite_directory_format (jobs[job_index]->wd));
	}

      if (format || (p == last))
	{
	  /* We need to add a CR only if this is an interactive shell, and
	     we're reporting the status of a completed job asynchronously.
	     We can't really check whether this particular job is being
	     reported asynchronously, so just add the CR if the shell is
	     currently interactive and asynchronous notification is enabled. */
	  if (asynchronous_notification && interactive)
	    fprintf (stream, "\r\n");
	  else
	    fprintf (stream, "\n");
	}

      if (p == last)
	break;
      p = p->next;
    }
  fflush (stream);
}
warning: parse error {
  PROCESS *first, *last, *show;
  int es, name_padding;
  char *temp;

  if (p == 0)
    return;

  first = last = p;
  while (last->next != first)
    last = last->next;

  for (;;)
    {
      if (p != first)
	fprintf (stream, format ? "     " : " |");

      if (format != JLIST_STANDARD)
	fprintf (stream, "%5ld", (long)p->pid);

      fprintf (stream, " ");

      if (format > -1 && job_index >= 0)
	{
	  show = format ? p : last;
	  temp = printable_job_status (job_index, show, format);

	  if (p != first)
	    {
	      if (format)
		{
		  if (show->running == first->running &&
		      WSTATUS (show->status) == WSTATUS (first->status))
		    temp = "";
		}
	      else
		temp = (char *)NULL;
	    }

	  if (temp)
	    {
	      fprintf (stream, "%s", temp);

	      es = STRLEN (temp);
	      if (es == 0)
		es = 2;	/* strlen ("| ") */
	      name_padding = LONGEST_SIGNAL_DESC - es;

	      fprintf (stream, "%*s", name_padding, "");

	      if ((WIFSTOPPED (show->status) == 0) &&
		  (WIFCONTINUED (show->status) == 0) &&
		  WIFCORED (show->status))
		fprintf (stream, _("(core dumped) "));
	    }
	}

      if (p != first && format)
	fprintf (stream, "| ");

      if (p->command)
	fprintf (stream, "%s", p->command);

      if (p == last && job_index >= 0)
	{
	  temp = current_working_directory ();

	  if (RUNNING (job_index) && (IS_FOREGROUND (job_index) == 0))
	    fprintf (stream, " &");

	  if (strcmp (temp, jobs[job_index]->wd) != 0)
	    fprintf (stream,
	      _("  (wd: %s)"), polite_directory_format (jobs[job_index]->wd));
	}

      if (format || (p == last))
	{
	  /* We need to add a CR only if this is an interactive shell, and
	     we're reporting the status of a completed job asynchronously.
	     We can't really check whether this particular job is being
	     reported asynchronously, so just add the CR if the shell is
	     currently interactive and asynchronous notification is enabled. */
	  if (asynchronous_notification && interactive)
	    fprintf (stream, "\r\n");
	  else
	    fprintf (stream, "\n");
	}

      if (p == last)
	break;
      p = p->next;
    }
  fflush (stream);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\jobs.c:1,525
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\jobs.c:1,623
parsing error 
{
  register PROCESS *p;

  /* Format only pid information about the process group leader? */
  if (format == JLIST_PID_ONLY)
    {
      fprintf (stream, "%ld\n", (long)jobs[job_index]->pipe->pid);
      return;
    }

  if (format == JLIST_CHANGED_ONLY)
    {
      if (IS_NOTIFIED (job_index))
	return;
      format = JLIST_STANDARD;
    }

  if (format != JLIST_NONINTERACTIVE)
    fprintf (stream, "[%d]%c ", job_index + 1,
	      (job_index == js.j_current) ? '+':
		(job_index == js.j_previous) ? '-' : ' ');

  if (format == JLIST_NONINTERACTIVE)
    format = JLIST_LONG;

  p = jobs[job_index]->pipe;

  print_pipeline (p, job_index, format, stream);

  /* We have printed information about this job.  When the job's
     status changes, waitchld () sets the notification flag to 0. */
  jobs[job_index]->flags |= J_NOTIFIED;
}
warning: parse error {
  register PROCESS *p;

  /* Format only pid information about the process group leader? */
  if (format == JLIST_PID_ONLY)
    {
      fprintf (stream, "%ld\n", (long)jobs[job_index]->pipe->pid);
      return;
    }

  if (format == JLIST_CHANGED_ONLY)
    {
      if (IS_NOTIFIED (job_index))
	return;
      format = JLIST_STANDARD;
    }

  if (format != JLIST_NONINTERACTIVE)
    fprintf (stream, "[%d]%c ", job_index + 1,
	      (job_index == js.j_current) ? '+':
		(job_index == js.j_previous) ? '-' : ' ');

  if (format == JLIST_NONINTERACTIVE)
    format = JLIST_LONG;

  p = jobs[job_index]->pipe;

  print_pipeline (p, job_index, format, stream);

  /* We have printed information about this job.  When the job's
     status changes, waitchld () sets the notification flag to 0. */
  jobs[job_index]->flags |= J_NOTIFIED;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\jobs.c:1,626
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\jobs.c:1,661
parsing error 
{
  if (state == -1 || (JOB_STATE)state == job->state)
    pretty_print_job (job_index, format, stdout);
  return (0);
}
warning: parse error {
  if (state == -1 || (JOB_STATE)state == job->state)
    pretty_print_job (job_index, format, stdout);
  return (0);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\jobs.c:1,664
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\jobs.c:1,671
parsing error 
{
  pretty_print_job (job_index, format, stdout);
}
warning: parse error {
  pretty_print_job (job_index, format, stdout);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\jobs.c:1,674
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\jobs.c:1,679
parsing error 
{
  cleanup_dead_jobs ();
  map_over_jobs (print_job, format, (int)JSTOPPED);
}
warning: parse error {
  cleanup_dead_jobs ();
  map_over_jobs (print_job, format, (int)JSTOPPED);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\jobs.c:1,681
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\jobs.c:1,687
parsing error 
{
  cleanup_dead_jobs ();
  map_over_jobs (print_job, format, (int)JRUNNING);
}
warning: parse error {
  cleanup_dead_jobs ();
  map_over_jobs (print_job, format, (int)JRUNNING);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\jobs.c:1,689
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\jobs.c:1,697
parsing error 
{
  cleanup_dead_jobs ();
  map_over_jobs (print_job, format, -1);
}
warning: parse error {
  cleanup_dead_jobs ();
  map_over_jobs (print_job, format, -1);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\jobs.c:1,699
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\jobs.c:1,709
parsing error 
{
  int forksleep;
  sigset_t set, oset;
  pid_t pid;

  sigemptyset (&set);
  sigaddset (&set, SIGCHLD);
  sigaddset (&set, SIGINT);
  sigemptyset (&oset);
  sigprocmask (SIG_BLOCK, &set, &oset);

  making_children ();

  forksleep = 1;

#if defined (BUFFERED_INPUT)
  /* If default_buffered_input is active, we are reading a script.  If
     the command is asynchronous, we have already duplicated /dev/null
     as fd 0, but have not changed the buffered stream corresponding to
     the old fd 0.  We don't want to sync the stream in this case. */
  if (default_buffered_input != -1 &&
      (!async_p || default_buffered_input > 0))
    sync_buffered_stream (default_buffered_input);
#endif /* BUFFERED_INPUT */

  /* Create the child, handle severe errors.  Retry on EAGAIN. */
  while ((pid = fork ()) < 0 && errno == EAGAIN && forksleep < FORKSLEEP_MAX)
    {
      /* bash-4.2 */
      /* If we can't create any children, try to reap some dead ones. */
      waitchld (-1, 0);

      sys_error ("fork: retry");
      if (sleep (forksleep) != 0)
	break;
      forksleep <<= 1;
    }

  if (pid < 0)
    {
      sys_error ("fork");

      /* Kill all of the processes in the current pipeline. */
      terminate_current_pipeline ();

      /* Discard the current pipeline, if any. */
      if (the_pipeline)
	kill_current_pipeline ();

      last_command_exit_value = EX_NOEXEC;
      throw_to_top_level ();	/* Reset signals, etc. */
    }

  if (pid == 0)
    {
      /* In the child.  Give this child the right process group, set the
	 signals to the default state for a new process. */
      pid_t mypid;

      mypid = getpid ();
#if defined (BUFFERED_INPUT)
      /* Close default_buffered_input if it's > 0.  We don't close it if it's
	 0 because that's the file descriptor used when redirecting input,
	 and it's wrong to close the file in that case. */
      unset_bash_input (0);
#endif /* BUFFERED_INPUT */

      /* Restore top-level signal mask. */
      sigprocmask (SIG_SETMASK, &top_level_mask, (sigset_t *)NULL);

      if (job_control)
	{
	  /* All processes in this pipeline belong in the same
	     process group. */

	  if (pipeline_pgrp == 0)	/* This is the first child. */
	    pipeline_pgrp = mypid;

	  /* Check for running command in backquotes. */
	  if (pipeline_pgrp == shell_pgrp)
	    ignore_tty_job_signals ();
	  else
	    default_tty_job_signals ();

	  /* Set the process group before trying to mess with the terminal's
	     process group.  This is mandated by POSIX. */
	  /* This is in accordance with the Posix 1003.1 standard,
	     section B.7.2.4, which says that trying to set the terminal
	     process group with tcsetpgrp() to an unused pgrp value (like
	     this would have for the first child) is an error.  Section
	     B.4.3.3, p. 237 also covers this, in the context of job control
	     shells. */
	  if (setpgid (mypid, pipeline_pgrp) < 0)
	    sys_error (_("child setpgid (%ld to %ld)"), (long)mypid, (long)pipeline_pgrp);

	  /* By convention (and assumption above), if
	     pipeline_pgrp == shell_pgrp, we are making a child for
	     command substitution.
	     In this case, we don't want to give the terminal to the
	     shell's process group (we could be in the middle of a
	     pipeline, for example). */
	  if (async_p == 0 && pipeline_pgrp != shell_pgrp && ((subshell_environment&SUBSHELL_ASYNC) == 0))
	    give_terminal_to (pipeline_pgrp, 0);

#if defined (PGRP_PIPE)
	  if (pipeline_pgrp == mypid)
	    pipe_read (pgrp_pipe);
#endif
	}
      else			/* Without job control... */
	{
	  if (pipeline_pgrp == 0)
	    pipeline_pgrp = shell_pgrp;

	  /* If these signals are set to SIG_DFL, we encounter the curious
	     situation of an interactive ^Z to a running process *working*
	     and stopping the process, but being unable to do anything with
	     that process to change its state.  On the other hand, if they
	     are set to SIG_IGN, jobs started from scripts do not stop when
	     the shell running the script gets a SIGTSTP and stops. */

	  default_tty_job_signals ();
	}

#if defined (PGRP_PIPE)
      /* Release the process group pipe, since our call to setpgid ()
	 is done.  The last call to sh_closepipe is done in stop_pipeline. */
      sh_closepipe (pgrp_pipe);
#endif /* PGRP_PIPE */

#if 0
      /* Don't set last_asynchronous_pid in the child */
      if (async_p)
	last_asynchronous_pid = mypid;		/* XXX */
      else
#endif
#if defined (RECYCLES_PIDS)
      if (last_asynchronous_pid == mypid)
        /* Avoid pid aliasing.  1 seems like a safe, unusual pid value. */
	last_asynchronous_pid = 1;
#endif
    }
  else
    {
      /* In the parent.  Remember the pid of the child just created
	 as the proper pgrp if this is the first child. */

      if (first_pid == NO_PID)
	first_pid = pid;
      else if (pid_wrap == -1 && pid < first_pid)
	pid_wrap = 0;
      else if (pid_wrap == 0 && pid >= first_pid)
	pid_wrap = 1;

      if (job_control)
	{
	  if (pipeline_pgrp == 0)
	    {
	      pipeline_pgrp = pid;
	      /* Don't twiddle terminal pgrps in the parent!  This is the bug,
		 not the good thing of twiddling them in the child! */
	      /* give_terminal_to (pipeline_pgrp, 0); */
	    }
	  /* This is done on the recommendation of the Rationale section of
	     the POSIX 1003.1 standard, where it discusses job control and
	     shells.  It is done to avoid possible race conditions. (Ref.
	     1003.1 Rationale, section B.4.3.3, page 236). */
	  setpgid (pid, pipeline_pgrp);
	}
      else
	{
	  if (pipeline_pgrp == 0)
	    pipeline_pgrp = shell_pgrp;
	}

      /* Place all processes into the jobs array regardless of the
	 state of job_control. */
      add_process (command, pid);

      if (async_p)
	last_asynchronous_pid = pid;
#if defined (RECYCLES_PIDS)
      else if (last_asynchronous_pid == pid)
        /* Avoid pid aliasing.  1 seems like a safe, unusual pid value. */
	last_asynchronous_pid = 1;
#endif

      if (pid_wrap > 0)
	delete_old_job (pid);

#if !defined (RECYCLES_PIDS)
      /* Only check for saved status if we've saved more than CHILD_MAX
	 statuses, unless the system recycles pids. */
      if ((js.c_reaped + bgpids.npid) >= js.c_childmax)
#endif
	bgp_delete (pid);		/* new process, discard any saved status */

      last_made_pid = pid;

      /* keep stats */
      js.c_totforked++;
      js.c_living++;

      /* Unblock SIGINT and SIGCHLD unless creating a pipeline, in which case
	 SIGCHLD remains blocked until all commands in the pipeline have been
	 created. */
      sigprocmask (SIG_SETMASK, &oset, (sigset_t *)NULL);
    }

  return (pid);
}
warning: parse error {
  int forksleep;
  sigset_t set, oset;
  pid_t pid;

  sigemptyset (&set);
  sigaddset (&set, SIGCHLD);
  sigaddset (&set, SIGINT);
  sigemptyset (&oset);
  sigprocmask (SIG_BLOCK, &set, &oset);

  making_children ();

  forksleep = 1;

#if defined (BUFFERED_INPUT)
  /* If default_buffered_input is active, we are reading a script.  If
     the command is asynchronous, we have already duplicated /dev/null
     as fd 0, but have not changed the buffered stream corresponding to
     the old fd 0.  We don't want to sync the stream in this case. */
  if (default_buffered_input != -1 &&
      (!async_p || default_buffered_input > 0))
    sync_buffered_stream (default_buffered_input);
#endif /* BUFFERED_INPUT */

  /* Create the child, handle severe errors.  Retry on EAGAIN. */
  while ((pid = fork ()) < 0 && errno == EAGAIN && forksleep < FORKSLEEP_MAX)
    {
      /* bash-4.2 */
      /* If we can't create any children, try to reap some dead ones. */
      waitchld (-1, 0);

      sys_error ("fork: retry");
      if (sleep (forksleep) != 0)
	break;
      forksleep <<= 1;
    }

  if (pid < 0)
    {
      sys_error ("fork");

      /* Kill all of the processes in the current pipeline. */
      terminate_current_pipeline ();

      /* Discard the current pipeline, if any. */
      if (the_pipeline)
	kill_current_pipeline ();

      last_command_exit_value = EX_NOEXEC;
      throw_to_top_level ();	/* Reset signals, etc. */
    }

  if (pid == 0)
    {
      /* In the child.  Give this child the right process group, set the
	 signals to the default state for a new process. */
      pid_t mypid;

      mypid = getpid ();
#if defined (BUFFERED_INPUT)
      /* Close default_buffered_input if it's > 0.  We don't close it if it's
	 0 because that's the file descriptor used when redirecting input,
	 and it's wrong to close the file in that case. */
      unset_bash_input (0);
#endif /* BUFFERED_INPUT */

      /* Restore top-level signal mask. */
      sigprocmask (SIG_SETMASK, &top_level_mask, (sigset_t *)NULL);

      if (job_control)
	{
	  /* All processes in this pipeline belong in the same
	     process group. */

	  if (pipeline_pgrp == 0)	/* This is the first child. */
	    pipeline_pgrp = mypid;

	  /* Check for running command in backquotes. */
	  if (pipeline_pgrp == shell_pgrp)
	    ignore_tty_job_signals ();
	  else
	    default_tty_job_signals ();

	  /* Set the process group before trying to mess with the terminal's
	     process group.  This is mandated by POSIX. */
	  /* This is in accordance with the Posix 1003.1 standard,
	     section B.7.2.4, which says that trying to set the terminal
	     process group with tcsetpgrp() to an unused pgrp value (like
	     this would have for the first child) is an error.  Section
	     B.4.3.3, p. 237 also covers this, in the context of job control
	     shells. */
	  if (setpgid (mypid, pipeline_pgrp) < 0)
	    sys_error (_("child setpgid (%ld to %ld)"), (long)mypid, (long)pipeline_pgrp);

	  /* By convention (and assumption above), if
	     pipeline_pgrp == shell_pgrp, we are making a child for
	     command substitution.
	     In this case, we don't want to give the terminal to the
	     shell's process group (we could be in the middle of a
	     pipeline, for example). */
	  if (async_p == 0 && pipeline_pgrp != shell_pgrp && ((subshell_environment&SUBSHELL_ASYNC) == 0))
	    give_terminal_to (pipeline_pgrp, 0);

#if defined (PGRP_PIPE)
	  if (pipeline_pgrp == mypid)
	    pipe_read (pgrp_pipe);
#endif
	}
      else			/* Without job control... */
	{
	  if (pipeline_pgrp == 0)
	    pipeline_pgrp = shell_pgrp;

	  /* If these signals are set to SIG_DFL, we encounter the curious
	     situation of an interactive ^Z to a running process *working*
	     and stopping the process, but being unable to do anything with
	     that process to change its state.  On the other hand, if they
	     are set to SIG_IGN, jobs started from scripts do not stop when
	     the shell running the script gets a SIGTSTP and stops. */

	  default_tty_job_signals ();
	}

#if defined (PGRP_PIPE)
      /* Release the process group pipe, since our call to setpgid ()
	 is done.  The last call to sh_closepipe is done in stop_pipeline. */
      sh_closepipe (pgrp_pipe);
#endif /* PGRP_PIPE */

#if 0
      /* Don't set last_asynchronous_pid in the child */
      if (async_p)
	last_asynchronous_pid = mypid;		/* XXX */
      else
#endif
#if defined (RECYCLES_PIDS)
      if (last_asynchronous_pid == mypid)
        /* Avoid pid aliasing.  1 seems like a safe, unusual pid value. */
	last_asynchronous_pid = 1;
#endif
    }
  else
    {
      /* In the parent.  Remember the pid of the child just created
	 as the proper pgrp if this is the first child. */

      if (first_pid == NO_PID)
	first_pid = pid;
      else if (pid_wrap == -1 && pid < first_pid)
	pid_wrap = 0;
      else if (pid_wrap == 0 && pid >= first_pid)
	pid_wrap = 1;

      if (job_control)
	{
	  if (pipeline_pgrp == 0)
	    {
	      pipeline_pgrp = pid;
	      /* Don't twiddle terminal pgrps in the parent!  This is the bug,
		 not the good thing of twiddling them in the child! */
	      /* give_terminal_to (pipeline_pgrp, 0); */
	    }
	  /* This is done on the recommendation of the Rationale section of
	     the POSIX 1003.1 standard, where it discusses job control and
	     shells.  It is done to avoid possible race conditions. (Ref.
	     1003.1 Rationale, section B.4.3.3, page 236). */
	  setpgid (pid, pipeline_pgrp);
	}
      else
	{
	  if (pipeline_pgrp == 0)
	    pipeline_pgrp = shell_pgrp;
	}

      /* Place all processes into the jobs array regardless of the
	 state of job_control. */
      add_process (command, pid);

      if (async_p)
	last_asynchronous_pid = pid;
#if defined (RECYCLES_PIDS)
      else if (last_asynchronous_pid == pid)
        /* Avoid pid aliasing.  1 seems like a safe, unusual pid value. */
	last_asynchronous_pid = 1;
#endif

      if (pid_wrap > 0)
	delete_old_job (pid);

#if !defined (RECYCLES_PIDS)
      /* Only check for saved status if we've saved more than CHILD_MAX
	 statuses, unless the system recycles pids. */
      if ((js.c_reaped + bgpids.npid) >= js.c_childmax)
#endif
	bgp_delete (pid);		/* new process, discard any saved status */

      last_made_pid = pid;

      /* keep stats */
      js.c_totforked++;
      js.c_living++;

      /* Unblock SIGINT and SIGCHLD unless creating a pipeline, in which case
	 SIGCHLD remains blocked until all commands in the pipeline have been
	 created. */
      sigprocmask (SIG_SETMASK, &oset, (sigset_t *)NULL);
    }

  return (pid);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\jobs.c:1,712
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\jobs.c:2,075
parsing error 
{
  register PROCESS *p;
  sigset_t set, oset;

  if (block)
    BLOCK_CHILD (set, oset);

  p = jobs[job]->pipe;
  while (p && p->next != jobs[job]->pipe)
    p = p->next;

  if (block)
    UNBLOCK_CHILD (oset);

  return (p);
}
warning: parse error {
  register PROCESS *p;
  sigset_t set, oset;

  if (block)
    BLOCK_CHILD (set, oset);

  p = jobs[job]->pipe;
  while (p && p->next != jobs[job]->pipe)
    p = p->next;

  if (block)
    UNBLOCK_CHILD (oset);

  return (p);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\jobs.c:2,078
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\jobs.c:2,096
parsing error 
{
  PROCESS *p;

  p = find_last_proc (job, block);
  /* Possible race condition here. */
  return p->pid;
}
warning: parse error {
  PROCESS *p;

  p = find_last_proc (job, block);
  /* Possible race condition here. */
  return p->pid;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\jobs.c:2,099
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\jobs.c:2,113
parsing error 
{
  register PROCESS *child;
  sigset_t set, oset;
  int r, job;

  BLOCK_CHILD (set, oset);
  child = find_pipeline (pid, 0, (int *)NULL);
  UNBLOCK_CHILD (oset);

  if (child == 0)
    {
      r = bgp_search (pid);
      if (r >= 0)
	return r;
    }

  if (child == 0)
    {
      internal_error (_("wait: pid %ld is not a child of this shell"), (long)pid);
      return (127);
    }

  r = wait_for (pid);

  /* POSIX.2: if we just waited for a job, we can remove it from the jobs
     table. */
  BLOCK_CHILD (set, oset);
  job = find_job (pid, 0, NULL);
  if (job != NO_JOB && jobs[job] && DEADJOB (job))
    jobs[job]->flags |= J_NOTIFIED;
  UNBLOCK_CHILD (oset);

  /* If running in posix mode, remove the job from the jobs table immediately */
  if (posixly_correct)
    {
      cleanup_dead_jobs ();
      bgp_delete (pid);
    }

  return r;
}
warning: parse error {
  register PROCESS *child;
  sigset_t set, oset;
  int r, job;

  BLOCK_CHILD (set, oset);
  child = find_pipeline (pid, 0, (int *)NULL);
  UNBLOCK_CHILD (oset);

  if (child == 0)
    {
      r = bgp_search (pid);
      if (r >= 0)
	return r;
    }

  if (child == 0)
    {
      internal_error (_("wait: pid %ld is not a child of this shell"), (long)pid);
      return (127);
    }

  r = wait_for (pid);

  /* POSIX.2: if we just waited for a job, we can remove it from the jobs
     table. */
  BLOCK_CHILD (set, oset);
  job = find_job (pid, 0, NULL);
  if (job != NO_JOB && jobs[job] && DEADJOB (job))
    jobs[job]->flags |= J_NOTIFIED;
  UNBLOCK_CHILD (oset);

  /* If running in posix mode, remove the job from the jobs table immediately */
  if (posixly_correct)
    {
      cleanup_dead_jobs ();
      bgp_delete (pid);
    }

  return r;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\jobs.c:2,115
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\jobs.c:2,231
parsing error 
{
  SigHandler *sigint_handler;

  if (interrupt_immediately ||
      (this_shell_builtin && this_shell_builtin == wait_builtin))
    {
      last_command_exit_value = EXECUTION_FAILURE;
      restore_sigint_handler ();
      /* If we got a SIGINT while in `wait', and SIGINT is trapped, do
	 what POSIX.2 says (see builtins/wait.def for more info). */
      if (this_shell_builtin && this_shell_builtin == wait_builtin &&
	  signal_is_trapped (SIGINT) &&
	  ((sigint_handler = trap_to_sighandler (SIGINT)) == trap_handler))
	{
	  interrupt_immediately = 0;
	  trap_handler (SIGINT);	/* set pending_traps[SIGINT] */
	  wait_signal_received = SIGINT;
	  longjmp (wait_intr_buf, 1);
	}
      
      ADDINTERRUPT;
      QUIT;
    }

  /* XXX - should this be interrupt_state?  If it is, the shell will act
     as if it got the SIGINT interrupt. */
  wait_sigint_received = 1;

  /* Otherwise effectively ignore the SIGINT and allow the running job to
     be killed. */
  SIGRETURN (0);
}
warning: parse error {
  SigHandler *sigint_handler;

  if (interrupt_immediately ||
      (this_shell_builtin && this_shell_builtin == wait_builtin))
    {
      last_command_exit_value = EXECUTION_FAILURE;
      restore_sigint_handler ();
      /* If we got a SIGINT while in `wait', and SIGINT is trapped, do
	 what POSIX.2 says (see builtins/wait.def for more info). */
      if (this_shell_builtin && this_shell_builtin == wait_builtin &&
	  signal_is_trapped (SIGINT) &&
	  ((sigint_handler = trap_to_sighandler (SIGINT)) == trap_handler))
	{
	  interrupt_immediately = 0;
	  trap_handler (SIGINT);	/* set pending_traps[SIGINT] */
	  wait_signal_received = SIGINT;
	  longjmp (wait_intr_buf, 1);
	}
      
      ADDINTERRUPT;
      QUIT;
    }

  /* XXX - should this be interrupt_state?  If it is, the shell will act
     as if it got the SIGINT interrupt. */
  wait_sigint_received = 1;

  /* Otherwise effectively ignore the SIGINT and allow the running job to
     be killed. */
  SIGRETURN (0);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\jobs.c:2,233
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\jobs.c:2,267
parsing error 
{
  return (WIFSIGNALED (status) ? WTERMSIG (status) : 0);
}
warning: parse error {
  return (WIFSIGNALED (status) ? WTERMSIG (status) : 0);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\jobs.c:2,269
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\jobs.c:2,274
parsing error 
{
  if (WIFSIGNALED (status))
    return (128 + WTERMSIG (status));
  else if (WIFSTOPPED (status) == 0)
    return (WEXITSTATUS (status));
  else
    return (EXECUTION_SUCCESS);
}
warning: parse error {
  if (WIFSIGNALED (status))
    return (128 + WTERMSIG (status));
  else if (WIFSTOPPED (status) == 0)
    return (WEXITSTATUS (status));
  else
    return (EXECUTION_SUCCESS);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\jobs.c:2,276
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\jobs.c:2,286
parsing error 
{
  register PROCESS *p;
  WAIT s;

  p = jobs[job]->pipe;
  do
    {
      s = p->status;
      if (WIFSIGNALED(s) || WIFSTOPPED(s))
	break;
      p = p->next;
    }
  while (p != jobs[job]->pipe);

  return s;
}
warning: parse error {
  register PROCESS *p;
  WAIT s;

  p = jobs[job]->pipe;
  do
    {
      s = p->status;
      if (WIFSIGNALED(s) || WIFSTOPPED(s))
	break;
      p = p->next;
    }
  while (p != jobs[job]->pipe);

  return s;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\jobs.c:2,288
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\jobs.c:2,308
parsing error 
{
  register PROCESS *p;
  int fail;
  WAIT ret;

  if (pipefail_opt)
    {
      fail = 0;
      p = jobs[job]->pipe;
      do
	{
	  if (WSTATUS (p->status) != EXECUTION_SUCCESS)
	    fail = WSTATUS(p->status);
	  p = p->next;
	}
      while (p != jobs[job]->pipe);
      WSTATUS (ret) = fail;
      return ret;
    }

  for (p = jobs[job]->pipe; p->next != jobs[job]->pipe; p = p->next)
    ;
  return (p->status);
}
warning: parse error {
  register PROCESS *p;
  int fail;
  WAIT ret;

  if (pipefail_opt)
    {
      fail = 0;
      p = jobs[job]->pipe;
      do
	{
	  if (WSTATUS (p->status) != EXECUTION_SUCCESS)
	    fail = WSTATUS(p->status);
	  p = p->next;
	}
      while (p != jobs[job]->pipe);
      WSTATUS (ret) = fail;
      return ret;
    }

  for (p = jobs[job]->pipe; p->next != jobs[job]->pipe; p = p->next)
    ;
  return (p->status);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\jobs.c:2,310
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\jobs.c:2,339
parsing error 
{
  return (process_exit_status (raw_job_exit_status (job)));
}
warning: parse error {
  return (process_exit_status (raw_job_exit_status (job)));
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\jobs.c:2,341
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\jobs.c:2,346
parsing error 
{
  return (process_exit_signal (raw_job_exit_status (job)));
}
warning: parse error {
  return (process_exit_signal (raw_job_exit_status (job)));
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\jobs.c:2,348
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\jobs.c:2,372
parsing error 
{
  int job, termination_state, r;
  WAIT s;
  register PROCESS *child;
  sigset_t set, oset;

  /* In the case that this code is interrupted, and we longjmp () out of it,
     we are relying on the code in throw_to_top_level () to restore the
     top-level signal mask. */
  BLOCK_CHILD (set, oset);

  /* Ignore interrupts while waiting for a job run without job control
     to finish.  We don't want the shell to exit if an interrupt is
     received, only if one of the jobs run is killed via SIGINT.  If
     job control is not set, the job will be run in the same pgrp as
     the shell, and the shell will see any signals the job gets.  In
     fact, we want this set every time the waiting shell and the waited-
     for process are in the same process group, including command
     substitution. */

  /* This is possibly a race condition -- should it go in stop_pipeline? */
  wait_sigint_received = 0;
  if (job_control == 0 || (subshell_environment&SUBSHELL_COMSUB))
    {
      old_sigint_handler = set_signal_handler (SIGINT, wait_sigint_handler);
      if (old_sigint_handler == SIG_IGN)
	set_signal_handler (SIGINT, old_sigint_handler);
    }

  termination_state = last_command_exit_value;

  if (interactive && job_control == 0)
    QUIT;
  /* Check for terminating signals and exit the shell if we receive one */
  CHECK_TERMSIG;

  /* If we say wait_for (), then we have a record of this child somewhere.
     If it and none of its peers are running, don't call waitchld(). */

  job = NO_JOB;
  do
    {
      FIND_CHILD (pid, child);

      /* If this child is part of a job, then we are really waiting for the
	 job to finish.  Otherwise, we are waiting for the child to finish.
	 We check for JDEAD in case the job state has been set by waitchld
	 after receipt of a SIGCHLD. */
      if (job == NO_JOB)
	job = find_job (pid, 0, NULL);

      /* waitchld() takes care of setting the state of the job.  If the job
	 has already exited before this is called, sigchld_handler will have
	 called waitchld and the state will be set to JDEAD. */

      if (PRUNNING(child) || (job != NO_JOB && RUNNING (job)))
	{
#if defined (WAITPID_BROKEN)    /* SCOv4 */
	  sigset_t suspend_set;
	  sigemptyset (&suspend_set);
	  sigsuspend (&suspend_set);
#else /* !WAITPID_BROKEN */
#  if defined (MUST_UNBLOCK_CHLD)
	  struct sigaction act, oact;
	  sigset_t nullset, chldset;

	  sigemptyset (&nullset);
	  sigemptyset (&chldset);
	  sigprocmask (SIG_SETMASK, &nullset, &chldset);
	  act.sa_handler = SIG_DFL;
	  sigemptyset (&act.sa_mask);
	  sigemptyset (&oact.sa_mask);
	  act.sa_flags = 0;
	  sigaction (SIGCHLD, &act, &oact);
#  endif
	  queue_sigchld = 1;
	  r = waitchld (pid, 1);
#  if defined (MUST_UNBLOCK_CHLD)
	  sigaction (SIGCHLD, &oact, (struct sigaction *)NULL);
	  sigprocmask (SIG_SETMASK, &chldset, (sigset_t *)NULL);
#  endif
	  queue_sigchld = 0;
	  if (r == -1 && errno == ECHILD && this_shell_builtin == wait_builtin)
	    {
	      termination_state = -1;
	      goto wait_for_return;
	    }

	  /* If child is marked as running, but waitpid() returns -1/ECHILD,
	     there is something wrong.  Somewhere, wait should have returned
	     that child's pid.  Mark the child as not running and the job,
	     if it exists, as JDEAD. */
	  if (r == -1 && errno == ECHILD)
	    {
	      child->running = PS_DONE;
	      WSTATUS (child->status) = 0;	/* XXX -- can't find true status */
	      js.c_living = 0;		/* no living child processes */
	      if (job != NO_JOB)
		{
		  jobs[job]->state = JDEAD;
		  js.c_reaped++;
		  js.j_ndead++;
		}
	    }
#endif /* WAITPID_BROKEN */
	}

      /* If the shell is interactive, and job control is disabled, see
	 if the foreground process has died due to SIGINT and jump out
	 of the wait loop if it has.  waitchld has already restored the
	 old SIGINT signal handler. */
      if (interactive && job_control == 0)
	QUIT;
      /* Check for terminating signals and exit the shell if we receive one */
      CHECK_TERMSIG;
    }
  while (PRUNNING (child) || (job != NO_JOB && RUNNING (job)));

  /* The exit state of the command is either the termination state of the
     child, or the termination state of the job.  If a job, the status
     of the last child in the pipeline is the significant one.  If the command
     or job was terminated by a signal, note that value also. */
  termination_state = (job != NO_JOB) ? job_exit_status (job)
				      : process_exit_status (child->status);
  last_command_exit_signal = (job != NO_JOB) ? job_exit_signal (job)
					     : process_exit_signal (child->status);

  /* XXX */
  if ((job != NO_JOB && JOBSTATE (job) == JSTOPPED) || WIFSTOPPED (child->status))
    termination_state = 128 + WSTOPSIG (child->status);

  if (job == NO_JOB || IS_JOBCONTROL (job))
    {
      /* XXX - under what circumstances is a job not present in the jobs
	 table (job == NO_JOB)?
	 	1.  command substitution

	 In the case of command substitution, at least, it's probably not
	 the right thing to give the terminal to the shell's process group,
	 even though there is code in subst.c:command_substitute to work
	 around it.

	 Things that don't:
		$PROMPT_COMMAND execution
		process substitution
       */
#if 0
if (job == NO_JOB)
  itrace("wait_for: job == NO_JOB, giving the terminal to shell_pgrp (%ld)", (long)shell_pgrp);
#endif
      give_terminal_to (shell_pgrp, 0);
    }

  /* If the command did not exit cleanly, or the job is just
     being stopped, then reset the tty state back to what it
     was before this command.  Reset the tty state and notify
     the user of the job termination only if the shell is
     interactive.  Clean up any dead jobs in either case. */
  if (job != NO_JOB)
    {
      if (interactive_shell && subshell_environment == 0)
	{
	  /* This used to use `child->status'.  That's wrong, however, for
	     pipelines.  `child' is the first process in the pipeline.  It's
	     likely that the process we want to check for abnormal termination
	     or stopping is the last process in the pipeline, especially if
	     it's long-lived and the first process is short-lived.  Since we
	     know we have a job here, we can check all the processes in this
	     job's pipeline and see if one of them stopped or terminated due
	     to a signal.  We might want to change this later to just check
	     the last process in the pipeline.  If no process exits due to a
	     signal, S is left as the status of the last job in the pipeline. */
	  s = job_signal_status (job);

	  if (WIFSIGNALED (s) || WIFSTOPPED (s))
	    {
	      set_tty_state ();

	      /* If the current job was stopped or killed by a signal, and
		 the user has requested it, get a possibly new window size */
	      if (check_window_size && (job == js.j_current || IS_FOREGROUND (job)))
		get_new_window_size (0, (int *)0, (int *)0);
	    }
	  else
	    get_tty_state ();

	  /* If job control is enabled, the job was started with job
	     control, the job was the foreground job, and it was killed
	     by SIGINT, then print a newline to compensate for the kernel
	     printing the ^C without a trailing newline. */
	  if (job_control && IS_JOBCONTROL (job) && IS_FOREGROUND (job) &&
		WIFSIGNALED (s) && WTERMSIG (s) == SIGINT)
	    {
	      /* If SIGINT is not trapped and the shell is in a for, while,
		 or until loop, act as if the shell received SIGINT as
		 well, so the loop can be broken.  This doesn't call the
		 SIGINT signal handler; maybe it should. */
	      if (signal_is_trapped (SIGINT) == 0 && (loop_level || (shell_compatibility_level > 32 && executing_list)))
		ADDINTERRUPT;
	      else
		{
		  putchar ('\n');
		  fflush (stdout);
		}
	    }
	}
      else if ((subshell_environment & (SUBSHELL_COMSUB|SUBSHELL_PIPE)) && wait_sigint_received)
	{
	  /* If waiting for a job in a subshell started to do command
	     substitution or to run a pipeline element that consists of
	     something like a while loop or a for loop, simulate getting
	     and being killed by the SIGINT to pass the status back to our
	     parent. */
	  s = job_signal_status (job);
	
	  if (WIFSIGNALED (s) && WTERMSIG (s) == SIGINT && signal_is_trapped (SIGINT) == 0)
	    {
	      UNBLOCK_CHILD (oset);
	      restore_sigint_handler ();
	      old_sigint_handler = set_signal_handler (SIGINT, SIG_DFL);
	      if (old_sigint_handler == SIG_IGN)
		restore_sigint_handler ();
	      else
		kill (getpid (), SIGINT);
	    }
	}

      /* Moved here from set_job_status_and_cleanup, which is in the SIGCHLD
         signal handler path */
      if (DEADJOB (job) && IS_FOREGROUND (job) /*&& subshell_environment == 0*/)
	setjstatus (job);

      /* If this job is dead, notify the user of the status.  If the shell
	 is interactive, this will display a message on the terminal.  If
	 the shell is not interactive, make sure we turn on the notify bit
	 so we don't get an unwanted message about the job's termination,
	 and so delete_job really clears the slot in the jobs table. */
      notify_and_cleanup ();
    }

wait_for_return:

  UNBLOCK_CHILD (oset);

  /* Restore the original SIGINT signal handler before we return. */
  restore_sigint_handler ();

  return (termination_state);
}
warning: parse error {
  int job, termination_state, r;
  WAIT s;
  register PROCESS *child;
  sigset_t set, oset;

  /* In the case that this code is interrupted, and we longjmp () out of it,
     we are relying on the code in throw_to_top_level () to restore the
     top-level signal mask. */
  BLOCK_CHILD (set, oset);

  /* Ignore interrupts while waiting for a job run without job control
     to finish.  We don't want the shell to exit if an interrupt is
     received, only if one of the jobs run is killed via SIGINT.  If
     job control is not set, the job will be run in the same pgrp as
     the shell, and the shell will see any signals the job gets.  In
     fact, we want this set every time the waiting shell and the waited-
     for process are in the same process group, including command
     substitution. */

  /* This is possibly a race condition -- should it go in stop_pipeline? */
  wait_sigint_received = 0;
  if (job_control == 0 || (subshell_environment&SUBSHELL_COMSUB))
    {
      old_sigint_handler = set_signal_handler (SIGINT, wait_sigint_handler);
      if (old_sigint_handler == SIG_IGN)
	set_signal_handler (SIGINT, old_sigint_handler);
    }

  termination_state = last_command_exit_value;

  if (interactive && job_control == 0)
    QUIT;
  /* Check for terminating signals and exit the shell if we receive one */
  CHECK_TERMSIG;

  /* If we say wait_for (), then we have a record of this child somewhere.
     If it and none of its peers are running, don't call waitchld(). */

  job = NO_JOB;
  do
    {
      FIND_CHILD (pid, child);

      /* If this child is part of a job, then we are really waiting for the
	 job to finish.  Otherwise, we are waiting for the child to finish.
	 We check for JDEAD in case the job state has been set by waitchld
	 after receipt of a SIGCHLD. */
      if (job == NO_JOB)
	job = find_job (pid, 0, NULL);

      /* waitchld() takes care of setting the state of the job.  If the job
	 has already exited before this is called, sigchld_handler will have
	 called waitchld and the state will be set to JDEAD. */

      if (PRUNNING(child) || (job != NO_JOB && RUNNING (job)))
	{
#if defined (WAITPID_BROKEN)    /* SCOv4 */
	  sigset_t suspend_set;
	  sigemptyset (&suspend_set);
	  sigsuspend (&suspend_set);
#else /* !WAITPID_BROKEN */
#  if defined (MUST_UNBLOCK_CHLD)
	  struct sigaction act, oact;
	  sigset_t nullset, chldset;

	  sigemptyset (&nullset);
	  sigemptyset (&chldset);
	  sigprocmask (SIG_SETMASK, &nullset, &chldset);
	  act.sa_handler = SIG_DFL;
	  sigemptyset (&act.sa_mask);
	  sigemptyset (&oact.sa_mask);
	  act.sa_flags = 0;
	  sigaction (SIGCHLD, &act, &oact);
#  endif
	  queue_sigchld = 1;
	  r = waitchld (pid, 1);
#  if defined (MUST_UNBLOCK_CHLD)
	  sigaction (SIGCHLD, &oact, (struct sigaction *)NULL);
	  sigprocmask (SIG_SETMASK, &chldset, (sigset_t *)NULL);
#  endif
	  queue_sigchld = 0;
	  if (r == -1 && errno == ECHILD && this_shell_builtin == wait_builtin)
	    {
	      termination_state = -1;
	      goto wait_for_return;
	    }

	  /* If child is marked as running, but waitpid() returns -1/ECHILD,
	     there is something wrong.  Somewhere, wait should have returned
	     that child's pid.  Mark the child as not running and the job,
	     if it exists, as JDEAD. */
	  if (r == -1 && errno == ECHILD)
	    {
	      child->running = PS_DONE;
	      WSTATUS (child->status) = 0;	/* XXX -- can't find true status */
	      js.c_living = 0;		/* no living child processes */
	      if (job != NO_JOB)
		{
		  jobs[job]->state = JDEAD;
		  js.c_reaped++;
		  js.j_ndead++;
		}
	    }
#endif /* WAITPID_BROKEN */
	}

      /* If the shell is interactive, and job control is disabled, see
	 if the foreground process has died due to SIGINT and jump out
	 of the wait loop if it has.  waitchld has already restored the
	 old SIGINT signal handler. */
      if (interactive && job_control == 0)
	QUIT;
      /* Check for terminating signals and exit the shell if we receive one */
      CHECK_TERMSIG;
    }
  while (PRUNNING (child) || (job != NO_JOB && RUNNING (job)));

  /* The exit state of the command is either the termination state of the
     child, or the termination state of the job.  If a job, the status
     of the last child in the pipeline is the significant one.  If the command
     or job was terminated by a signal, note that value also. */
  termination_state = (job != NO_JOB) ? job_exit_status (job)
				      : process_exit_status (child->status);
  last_command_exit_signal = (job != NO_JOB) ? job_exit_signal (job)
					     : process_exit_signal (child->status);

  /* XXX */
  if ((job != NO_JOB && JOBSTATE (job) == JSTOPPED) || WIFSTOPPED (child->status))
    termination_state = 128 + WSTOPSIG (child->status);

  if (job == NO_JOB || IS_JOBCONTROL (job))
    {
      /* XXX - under what circumstances is a job not present in the jobs
	 table (job == NO_JOB)?
	 	1.  command substitution

	 In the case of command substitution, at least, it's probably not
	 the right thing to give the terminal to the shell's process group,
	 even though there is code in subst.c:command_substitute to work
	 around it.

	 Things that don't:
		$PROMPT_COMMAND execution
		process substitution
       */
#if 0
if (job == NO_JOB)
  itrace("wait_for: job == NO_JOB, giving the terminal to shell_pgrp (%ld)", (long)shell_pgrp);
#endif
      give_terminal_to (shell_pgrp, 0);
    }

  /* If the command did not exit cleanly, or the job is just
     being stopped, then reset the tty state back to what it
     was before this command.  Reset the tty state and notify
     the user of the job termination only if the shell is
     interactive.  Clean up any dead jobs in either case. */
  if (job != NO_JOB)
    {
      if (interactive_shell && subshell_environment == 0)
	{
	  /* This used to use `child->status'.  That's wrong, however, for
	     pipelines.  `child' is the first process in the pipeline.  It's
	     likely that the process we want to check for abnormal termination
	     or stopping is the last process in the pipeline, especially if
	     it's long-lived and the first process is short-lived.  Since we
	     know we have a job here, we can check all the processes in this
	     job's pipeline and see if one of them stopped or terminated due
	     to a signal.  We might want to change this later to just check
	     the last process in the pipeline.  If no process exits due to a
	     signal, S is left as the status of the last job in the pipeline. */
	  s = job_signal_status (job);

	  if (WIFSIGNALED (s) || WIFSTOPPED (s))
	    {
	      set_tty_state ();

	      /* If the current job was stopped or killed by a signal, and
		 the user has requested it, get a possibly new window size */
	      if (check_window_size && (job == js.j_current || IS_FOREGROUND (job)))
		get_new_window_size (0, (int *)0, (int *)0);
	    }
	  else
	    get_tty_state ();

	  /* If job control is enabled, the job was started with job
	     control, the job was the foreground job, and it was killed
	     by SIGINT, then print a newline to compensate for the kernel
	     printing the ^C without a trailing newline. */
	  if (job_control && IS_JOBCONTROL (job) && IS_FOREGROUND (job) &&
		WIFSIGNALED (s) && WTERMSIG (s) == SIGINT)
	    {
	      /* If SIGINT is not trapped and the shell is in a for, while,
		 or until loop, act as if the shell received SIGINT as
		 well, so the loop can be broken.  This doesn't call the
		 SIGINT signal handler; maybe it should. */
	      if (signal_is_trapped (SIGINT) == 0 && (loop_level || (shell_compatibility_level > 32 && executing_list)))
		ADDINTERRUPT;
	      else
		{
		  putchar ('\n');
		  fflush (stdout);
		}
	    }
	}
      else if ((subshell_environment & (SUBSHELL_COMSUB|SUBSHELL_PIPE)) && wait_sigint_received)
	{
	  /* If waiting for a job in a subshell started to do command
	     substitution or to run a pipeline element that consists of
	     something like a while loop or a for loop, simulate getting
	     and being killed by the SIGINT to pass the status back to our
	     parent. */
	  s = job_signal_status (job);
	
	  if (WIFSIGNALED (s) && WTERMSIG (s) == SIGINT && signal_is_trapped (SIGINT) == 0)
	    {
	      UNBLOCK_CHILD (oset);
	      restore_sigint_handler ();
	      old_sigint_handler = set_signal_handler (SIGINT, SIG_DFL);
	      if (old_sigint_handler == SIG_IGN)
		restore_sigint_handler ();
	      else
		kill (getpid (), SIGINT);
	    }
	}

      /* Moved here from set_job_status_and_cleanup, which is in the SIGCHLD
         signal handler path */
      if (DEADJOB (job) && IS_FOREGROUND (job) /*&& subshell_environment == 0*/)
	setjstatus (job);

      /* If this job is dead, notify the user of the status.  If the shell
	 is interactive, this will display a message on the terminal.  If
	 the shell is not interactive, make sure we turn on the notify bit
	 so we don't get an unwanted message about the job's termination,
	 and so delete_job really clears the slot in the jobs table. */
      notify_and_cleanup ();
    }

wait_for_return:

  UNBLOCK_CHILD (oset);

  /* Restore the original SIGINT signal handler before we return. */
  restore_sigint_handler ();

  return (termination_state);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\jobs.c:2,374
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\jobs.c:2,628
parsing error 
{
  pid_t pid;
  int r;
  sigset_t set, oset;

  BLOCK_CHILD(set, oset);
  if (JOBSTATE (job) == JSTOPPED)
    internal_warning (_("wait_for_job: job %d is stopped"), job+1);

  pid = find_last_pid (job, 0);
  UNBLOCK_CHILD(oset);
  r = wait_for (pid);

  /* POSIX.2: we can remove the job from the jobs table if we just waited
     for it. */
  BLOCK_CHILD (set, oset);
  if (job != NO_JOB && jobs[job] && DEADJOB (job))
    jobs[job]->flags |= J_NOTIFIED;
  UNBLOCK_CHILD (oset);

  return r;
}
warning: parse error {
  pid_t pid;
  int r;
  sigset_t set, oset;

  BLOCK_CHILD(set, oset);
  if (JOBSTATE (job) == JSTOPPED)
    internal_warning (_("wait_for_job: job %d is stopped"), job+1);

  pid = find_last_pid (job, 0);
  UNBLOCK_CHILD(oset);
  r = wait_for (pid);

  /* POSIX.2: we can remove the job from the jobs table if we just waited
     for it. */
  BLOCK_CHILD (set, oset);
  if (job != NO_JOB && jobs[job] && DEADJOB (job))
    jobs[job]->flags |= J_NOTIFIED;
  UNBLOCK_CHILD (oset);

  return r;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\jobs.c:2,630
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\jobs.c:2,682
parsing error 
{
  register int i, result;
  sigset_t set, oset;

  BLOCK_CHILD (set, oset);

  for (result = NO_JOB, i = job - 1; i >= 0; i--)
    {
      if (jobs[i] && (JOBSTATE (i) == state))
	{
	  result = i;
	  break;
	}
    }

  UNBLOCK_CHILD (oset);

  return (result);
}
warning: parse error {
  register int i, result;
  sigset_t set, oset;

  BLOCK_CHILD (set, oset);

  for (result = NO_JOB, i = job - 1; i >= 0; i--)
    {
      if (jobs[i] && (JOBSTATE (i) == state))
	{
	  result = i;
	  break;
	}
    }

  UNBLOCK_CHILD (oset);

  return (result);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\jobs.c:2,685
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\jobs.c:2,708
parsing error 
{
  return (most_recent_job_in_state (job, JSTOPPED));
}
warning: parse error {
  return (most_recent_job_in_state (job, JSTOPPED));
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\jobs.c:2,710
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\jobs.c:2,717
parsing error 
{
  return (most_recent_job_in_state (job, JRUNNING));
}
warning: parse error {
  return (most_recent_job_in_state (job, JRUNNING));
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\jobs.c:2,719
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\jobs.c:2,726
parsing error 
{
  int candidate;

  if (js.j_current != job)
    {
      js.j_previous = js.j_current;
      js.j_current = job;
    }

  /* First choice for previous job is the old current job. */
  if (js.j_previous != js.j_current &&
      js.j_previous != NO_JOB &&
      jobs[js.j_previous] &&
      STOPPED (js.j_previous))
    return;

  /* Second choice:  Newest stopped job that is older than
     the current job. */
  candidate = NO_JOB;
  if (STOPPED (js.j_current))
    {
      candidate = job_last_stopped (js.j_current);

      if (candidate != NO_JOB)
	{
	  js.j_previous = candidate;
	  return;
	}
    }

  /* If we get here, there is either only one stopped job, in which case it is
     the current job and the previous job should be set to the newest running
     job, or there are only running jobs and the previous job should be set to
     the newest running job older than the current job.  We decide on which
     alternative to use based on whether or not JOBSTATE(js.j_current) is
     JSTOPPED. */

  candidate = RUNNING (js.j_current) ? job_last_running (js.j_current)
				    : job_last_running (js.j_jobslots);

  if (candidate != NO_JOB)
    {
      js.j_previous = candidate;
      return;
    }

  /* There is only a single job, and it is both `+' and `-'. */
  js.j_previous = js.j_current;
}
warning: parse error {
  int candidate;

  if (js.j_current != job)
    {
      js.j_previous = js.j_current;
      js.j_current = job;
    }

  /* First choice for previous job is the old current job. */
  if (js.j_previous != js.j_current &&
      js.j_previous != NO_JOB &&
      jobs[js.j_previous] &&
      STOPPED (js.j_previous))
    return;

  /* Second choice:  Newest stopped job that is older than
     the current job. */
  candidate = NO_JOB;
  if (STOPPED (js.j_current))
    {
      candidate = job_last_stopped (js.j_current);

      if (candidate != NO_JOB)
	{
	  js.j_previous = candidate;
	  return;
	}
    }

  /* If we get here, there is either only one stopped job, in which case it is
     the current job and the previous job should be set to the newest running
     job, or there are only running jobs and the previous job should be set to
     the newest running job older than the current job.  We decide on which
     alternative to use based on whether or not JOBSTATE(js.j_current) is
     JSTOPPED. */

  candidate = RUNNING (js.j_current) ? job_last_running (js.j_current)
				    : job_last_running (js.j_jobslots);

  if (candidate != NO_JOB)
    {
      js.j_previous = candidate;
      return;
    }

  /* There is only a single job, and it is both `+' and `-'. */
  js.j_previous = js.j_current;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\jobs.c:2,728
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\jobs.c:2,821
parsing error 
{
  register PROCESS *p;

  /* Each member of the pipeline is now running. */
  p = jobs[job]->pipe;

  do
    {
      if (WIFSTOPPED (p->status))
	p->running = PS_RUNNING;	/* XXX - could be PS_STOPPED */
      p = p->next;
    }
  while (p != jobs[job]->pipe);

  /* This means that the job is running. */
  JOBSTATE (job) = JRUNNING;
}
warning: parse error {
  register PROCESS *p;

  /* Each member of the pipeline is now running. */
  p = jobs[job]->pipe;

  do
    {
      if (WIFSTOPPED (p->status))
	p->running = PS_RUNNING;	/* XXX - could be PS_STOPPED */
      p = p->next;
    }
  while (p != jobs[job]->pipe);

  /* This means that the job is running. */
  JOBSTATE (job) = JRUNNING;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\jobs.c:2,823
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\jobs.c:2,846
parsing error 
{
  register PROCESS *p;
  int already_running;
  sigset_t set, oset;
  char *wd, *s;
  static TTYSTRUCT save_stty;

  BLOCK_CHILD (set, oset);

  if (DEADJOB (job))
    {
      internal_error (_("%s: job has terminated"), this_command_name);
      UNBLOCK_CHILD (oset);
      return (-1);
    }

  already_running = RUNNING (job);

  if (foreground == 0 && already_running)
    {
      internal_error (_("%s: job %d already in background"), this_command_name, job + 1);
      UNBLOCK_CHILD (oset);
      return (0);		/* XPG6/SUSv3 says this is not an error */
    }

  wd = current_working_directory ();

  /* You don't know about the state of this job.  Do you? */
  jobs[job]->flags &= ~J_NOTIFIED;

  if (foreground)
    {
      set_current_job (job);
      jobs[job]->flags |= J_FOREGROUND;
    }

  /* Tell the outside world what we're doing. */
  p = jobs[job]->pipe;

  if (foreground == 0)
    {
      /* POSIX.2 says `bg' doesn't give any indication about current or
	 previous job. */
      if (posixly_correct == 0)
	s = (job == js.j_current) ? "+ ": ((job == js.j_previous) ? "- " : " ");       
      else
	s = " ";
      printf ("[%d]%s", job + 1, s);
    }

  do
    {
      printf ("%s%s",
	       p->command ? p->command : "",
	       p->next != jobs[job]->pipe? " | " : "");
      p = p->next;
    }
  while (p != jobs[job]->pipe);

  if (foreground == 0)
    printf (" &");

  if (strcmp (wd, jobs[job]->wd) != 0)
    printf ("	(wd: %s)", polite_directory_format (jobs[job]->wd));

  printf ("\n");

  /* Run the job. */
  if (already_running == 0)
    set_job_running (job);

  /* Save the tty settings before we start the job in the foreground. */
  if (foreground)
    {
      get_tty_state ();
      save_stty = shell_tty_info;
      /* Give the terminal to this job. */
      if (IS_JOBCONTROL (job))
	give_terminal_to (jobs[job]->pgrp, 0);
    }
  else
    jobs[job]->flags &= ~J_FOREGROUND;

  /* If the job is already running, then don't bother jump-starting it. */
  if (already_running == 0)
    {
      jobs[job]->flags |= J_NOTIFIED;
      killpg (jobs[job]->pgrp, SIGCONT);
    }

  if (foreground)
    {
      pid_t pid;
      int st;

      pid = find_last_pid (job, 0);
      UNBLOCK_CHILD (oset);
      st = wait_for (pid);
      shell_tty_info = save_stty;
      set_tty_state ();
      return (st);
    }
  else
    {
      reset_current ();
      UNBLOCK_CHILD (oset);
      return (0);
    }
}
warning: parse error {
  register PROCESS *p;
  int already_running;
  sigset_t set, oset;
  char *wd, *s;
  static TTYSTRUCT save_stty;

  BLOCK_CHILD (set, oset);

  if (DEADJOB (job))
    {
      internal_error (_("%s: job has terminated"), this_command_name);
      UNBLOCK_CHILD (oset);
      return (-1);
    }

  already_running = RUNNING (job);

  if (foreground == 0 && already_running)
    {
      internal_error (_("%s: job %d already in background"), this_command_name, job + 1);
      UNBLOCK_CHILD (oset);
      return (0);		/* XPG6/SUSv3 says this is not an error */
    }

  wd = current_working_directory ();

  /* You don't know about the state of this job.  Do you? */
  jobs[job]->flags &= ~J_NOTIFIED;

  if (foreground)
    {
      set_current_job (job);
      jobs[job]->flags |= J_FOREGROUND;
    }

  /* Tell the outside world what we're doing. */
  p = jobs[job]->pipe;

  if (foreground == 0)
    {
      /* POSIX.2 says `bg' doesn't give any indication about current or
	 previous job. */
      if (posixly_correct == 0)
	s = (job == js.j_current) ? "+ ": ((job == js.j_previous) ? "- " : " ");       
      else
	s = " ";
      printf ("[%d]%s", job + 1, s);
    }

  do
    {
      printf ("%s%s",
	       p->command ? p->command : "",
	       p->next != jobs[job]->pipe? " | " : "");
      p = p->next;
    }
  while (p != jobs[job]->pipe);

  if (foreground == 0)
    printf (" &");

  if (strcmp (wd, jobs[job]->wd) != 0)
    printf ("	(wd: %s)", polite_directory_format (jobs[job]->wd));

  printf ("\n");

  /* Run the job. */
  if (already_running == 0)
    set_job_running (job);

  /* Save the tty settings before we start the job in the foreground. */
  if (foreground)
    {
      get_tty_state ();
      save_stty = shell_tty_info;
      /* Give the terminal to this job. */
      if (IS_JOBCONTROL (job))
	give_terminal_to (jobs[job]->pgrp, 0);
    }
  else
    jobs[job]->flags &= ~J_FOREGROUND;

  /* If the job is already running, then don't bother jump-starting it. */
  if (already_running == 0)
    {
      jobs[job]->flags |= J_NOTIFIED;
      killpg (jobs[job]->pgrp, SIGCONT);
    }

  if (foreground)
    {
      pid_t pid;
      int st;

      pid = find_last_pid (job, 0);
      UNBLOCK_CHILD (oset);
      st = wait_for (pid);
      shell_tty_info = save_stty;
      set_tty_state ();
      return (st);
    }
  else
    {
      reset_current ();
      UNBLOCK_CHILD (oset);
      return (0);
    }
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\jobs.c:2,848
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\jobs.c:2,963
parsing error 
{
  register PROCESS *p;
  int job, result, negative;
  sigset_t set, oset;

  if (pid < -1)
    {
      pid = -pid;
      group = negative = 1;
    }
  else
    negative = 0;

  result = EXECUTION_SUCCESS;
  if (group)
    {
      BLOCK_CHILD (set, oset);
      p = find_pipeline (pid, 0, &job);

      if (job != NO_JOB)
	{
	  jobs[job]->flags &= ~J_NOTIFIED;

	  /* Kill process in backquotes or one started without job control? */

	  /* If we're passed a pid < -1, just call killpg and see what happens  */
	  if (negative && jobs[job]->pgrp == shell_pgrp)
	    result = killpg (pid, sig);
	  /* If we're killing using job control notification, for example,
	     without job control active, we have to do things ourselves. */
	  else if (jobs[job]->pgrp == shell_pgrp)
	    {
	      p = jobs[job]->pipe;
	      do
		{
		  if (PALIVE (p) == 0)
		    continue;		/* avoid pid recycling problem */
		  kill (p->pid, sig);
		  if (PEXITED (p) && (sig == SIGTERM || sig == SIGHUP))
		    kill (p->pid, SIGCONT);
		  p = p->next;
		}
	      while  (p != jobs[job]->pipe);
	    }
	  else
	    {
	      result = killpg (jobs[job]->pgrp, sig);
	      if (p && STOPPED (job) && (sig == SIGTERM || sig == SIGHUP))
		killpg (jobs[job]->pgrp, SIGCONT);
	      /* If we're continuing a stopped job via kill rather than bg or
		 fg, emulate the `bg' behavior. */
	      if (p && STOPPED (job) && (sig == SIGCONT))
		{
		  set_job_running (job);
		  jobs[job]->flags &= ~J_FOREGROUND;
		  jobs[job]->flags |= J_NOTIFIED;
		}
	    }
	}
      else
	result = killpg (pid, sig);

      UNBLOCK_CHILD (oset);
    }
  else
    result = kill (pid, sig);

  return (result);
}
warning: parse error {
  register PROCESS *p;
  int job, result, negative;
  sigset_t set, oset;

  if (pid < -1)
    {
      pid = -pid;
      group = negative = 1;
    }
  else
    negative = 0;

  result = EXECUTION_SUCCESS;
  if (group)
    {
      BLOCK_CHILD (set, oset);
      p = find_pipeline (pid, 0, &job);

      if (job != NO_JOB)
	{
	  jobs[job]->flags &= ~J_NOTIFIED;

	  /* Kill process in backquotes or one started without job control? */

	  /* If we're passed a pid < -1, just call killpg and see what happens  */
	  if (negative && jobs[job]->pgrp == shell_pgrp)
	    result = killpg (pid, sig);
	  /* If we're killing using job control notification, for example,
	     without job control active, we have to do things ourselves. */
	  else if (jobs[job]->pgrp == shell_pgrp)
	    {
	      p = jobs[job]->pipe;
	      do
		{
		  if (PALIVE (p) == 0)
		    continue;		/* avoid pid recycling problem */
		  kill (p->pid, sig);
		  if (PEXITED (p) && (sig == SIGTERM || sig == SIGHUP))
		    kill (p->pid, SIGCONT);
		  p = p->next;
		}
	      while  (p != jobs[job]->pipe);
	    }
	  else
	    {
	      result = killpg (jobs[job]->pgrp, sig);
	      if (p && STOPPED (job) && (sig == SIGTERM || sig == SIGHUP))
		killpg (jobs[job]->pgrp, SIGCONT);
	      /* If we're continuing a stopped job via kill rather than bg or
		 fg, emulate the `bg' behavior. */
	      if (p && STOPPED (job) && (sig == SIGCONT))
		{
		  set_job_running (job);
		  jobs[job]->flags &= ~J_FOREGROUND;
		  jobs[job]->flags |= J_NOTIFIED;
		}
	    }
	}
      else
	result = killpg (pid, sig);

      UNBLOCK_CHILD (oset);
    }
  else
    result = kill (pid, sig);

  return (result);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\jobs.c:2,966
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\jobs.c:3,039
parsing error 
{
  int n, oerrno;

  oerrno = errno;
  REINSTALL_SIGCHLD_HANDLER;
  sigchld++;
  n = 0;
  if (queue_sigchld == 0)
    n = waitchld (-1, 0);
  errno = oerrno;
  SIGRETURN (n);
}
warning: parse error {
  int n, oerrno;

  oerrno = errno;
  REINSTALL_SIGCHLD_HANDLER;
  sigchld++;
  n = 0;
  if (queue_sigchld == 0)
    n = waitchld (-1, 0);
  errno = oerrno;
  SIGRETURN (n);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\jobs.c:3,041
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\jobs.c:3,062
parsing error 
{
  WAIT status;
  PROCESS *child;
  pid_t pid;
  int call_set_current, last_stopped_job, job, children_exited, waitpid_flags;
  static int wcontinued = WCONTINUED;	/* run-time fix for glibc problem */

  call_set_current = children_exited = 0;
  last_stopped_job = NO_JOB;

  do
    {
      /* We don't want to be notified about jobs stopping if job control
	 is not active.  XXX - was interactive_shell instead of job_control */
      waitpid_flags = (job_control && subshell_environment == 0)
			? (WUNTRACED|wcontinued)
			: 0;
      if (sigchld || block == 0)
	waitpid_flags |= WNOHANG;
      /* Check for terminating signals and exit the shell if we receive one */
      CHECK_TERMSIG;

      if (block == 1 && queue_sigchld == 0 && (waitpid_flags & WNOHANG) == 0)
	{
	  internal_warning (_("waitchld: turning on WNOHANG to avoid indefinite block"));
	  waitpid_flags |= WNOHANG;
	}

      pid = WAITPID (-1, &status, waitpid_flags);

      /* WCONTINUED may be rejected by waitpid as invalid even when defined */
      if (wcontinued && pid < 0 && errno == EINVAL)
	{
	  wcontinued = 0;
	  continue;	/* jump back to the test and retry without WCONTINUED */
	}

      /* The check for WNOHANG is to make sure we decrement sigchld only
	 if it was non-zero before we called waitpid. */
      if (sigchld > 0 && (waitpid_flags & WNOHANG))
	sigchld--;
  
      /* If waitpid returns -1 with errno == ECHILD, there are no more
	 unwaited-for child processes of this shell. */
      if (pid < 0 && errno == ECHILD)
	{
	  if (children_exited == 0)
	    return -1;
	  else
	    break;
	}

      /* If waitpid returns 0, there are running children.  If it returns -1,
	 the only other error POSIX says it can return is EINTR. */
      CHECK_TERMSIG;
      if (pid <= 0)
	continue;	/* jumps right to the test */

      /* children_exited is used to run traps on SIGCHLD.  We don't want to
         run the trap if a process is just being continued. */
      if (WIFCONTINUED(status) == 0)
	{
	  children_exited++;
	  js.c_living--;
	}

      /* Locate our PROCESS for this pid. */
      child = find_process (pid, 1, &job);	/* want living procs only */

#if defined (COPROCESS_SUPPORT)
      coproc_pidchk (pid, status);
#endif

      /* It is not an error to have a child terminate that we did
	 not have a record of.  This child could have been part of
	 a pipeline in backquote substitution.  Even so, I'm not
	 sure child is ever non-zero. */
      if (child == 0)
	{
	  if (WIFEXITED (status) || WIFSIGNALED (status))
	    js.c_reaped++;
	  continue;
	}

      /* Remember status, and whether or not the process is running. */
      child->status = status;
      child->running = WIFCONTINUED(status) ? PS_RUNNING : PS_DONE;

      if (PEXITED (child))
	{
	  js.c_totreaped++;
	  if (job != NO_JOB)
	    js.c_reaped++;
	}
        
      if (job == NO_JOB)
	continue;

      call_set_current += set_job_status_and_cleanup (job);

      if (STOPPED (job))
	last_stopped_job = job;
      else if (DEADJOB (job) && last_stopped_job == job)
	last_stopped_job = NO_JOB;
    }
  while ((sigchld || block == 0) && pid > (pid_t)0);

  /* If a job was running and became stopped, then set the current
     job.  Otherwise, don't change a thing. */
  if (call_set_current)
    {
      if (last_stopped_job != NO_JOB)
	set_current_job (last_stopped_job);
      else
	reset_current ();
    }

  /* Call a SIGCHLD trap handler for each child that exits, if one is set. */
  if (job_control && signal_is_trapped (SIGCHLD) && children_exited &&
      trap_list[SIGCHLD] != (char *)IGNORE_SIG)
    {
      if (posixly_correct && this_shell_builtin && this_shell_builtin == wait_builtin)
	{
	  interrupt_immediately = 0;
	  trap_handler (SIGCHLD);	/* set pending_traps[SIGCHLD] */
	  wait_signal_received = SIGCHLD;
	  longjmp (wait_intr_buf, 1);
	}

      run_sigchld_trap (children_exited);
    }

  /* We have successfully recorded the useful information about this process
     that has just changed state.  If we notify asynchronously, and the job
     that this process belongs to is no longer running, then notify the user
     of that fact now. */
  if (asynchronous_notification && interactive)
    notify_of_job_status ();

  return (children_exited);
}
warning: parse error {
  WAIT status;
  PROCESS *child;
  pid_t pid;
  int call_set_current, last_stopped_job, job, children_exited, waitpid_flags;
  static int wcontinued = WCONTINUED;	/* run-time fix for glibc problem */

  call_set_current = children_exited = 0;
  last_stopped_job = NO_JOB;

  do
    {
      /* We don't want to be notified about jobs stopping if job control
	 is not active.  XXX - was interactive_shell instead of job_control */
      waitpid_flags = (job_control && subshell_environment == 0)
			? (WUNTRACED|wcontinued)
			: 0;
      if (sigchld || block == 0)
	waitpid_flags |= WNOHANG;
      /* Check for terminating signals and exit the shell if we receive one */
      CHECK_TERMSIG;

      if (block == 1 && queue_sigchld == 0 && (waitpid_flags & WNOHANG) == 0)
	{
	  internal_warning (_("waitchld: turning on WNOHANG to avoid indefinite block"));
	  waitpid_flags |= WNOHANG;
	}

      pid = WAITPID (-1, &status, waitpid_flags);

      /* WCONTINUED may be rejected by waitpid as invalid even when defined */
      if (wcontinued && pid < 0 && errno == EINVAL)
	{
	  wcontinued = 0;
	  continue;	/* jump back to the test and retry without WCONTINUED */
	}

      /* The check for WNOHANG is to make sure we decrement sigchld only
	 if it was non-zero before we called waitpid. */
      if (sigchld > 0 && (waitpid_flags & WNOHANG))
	sigchld--;
  
      /* If waitpid returns -1 with errno == ECHILD, there are no more
	 unwaited-for child processes of this shell. */
      if (pid < 0 && errno == ECHILD)
	{
	  if (children_exited == 0)
	    return -1;
	  else
	    break;
	}

      /* If waitpid returns 0, there are running children.  If it returns -1,
	 the only other error POSIX says it can return is EINTR. */
      CHECK_TERMSIG;
      if (pid <= 0)
	continue;	/* jumps right to the test */

      /* children_exited is used to run traps on SIGCHLD.  We don't want to
         run the trap if a process is just being continued. */
      if (WIFCONTINUED(status) == 0)
	{
	  children_exited++;
	  js.c_living--;
	}

      /* Locate our PROCESS for this pid. */
      child = find_process (pid, 1, &job);	/* want living procs only */

#if defined (COPROCESS_SUPPORT)
      coproc_pidchk (pid, status);
#endif

      /* It is not an error to have a child terminate that we did
	 not have a record of.  This child could have been part of
	 a pipeline in backquote substitution.  Even so, I'm not
	 sure child is ever non-zero. */
      if (child == 0)
	{
	  if (WIFEXITED (status) || WIFSIGNALED (status))
	    js.c_reaped++;
	  continue;
	}

      /* Remember status, and whether or not the process is running. */
      child->status = status;
      child->running = WIFCONTINUED(status) ? PS_RUNNING : PS_DONE;

      if (PEXITED (child))
	{
	  js.c_totreaped++;
	  if (job != NO_JOB)
	    js.c_reaped++;
	}
        
      if (job == NO_JOB)
	continue;

      call_set_current += set_job_status_and_cleanup (job);

      if (STOPPED (job))
	last_stopped_job = job;
      else if (DEADJOB (job) && last_stopped_job == job)
	last_stopped_job = NO_JOB;
    }
  while ((sigchld || block == 0) && pid > (pid_t)0);

  /* If a job was running and became stopped, then set the current
     job.  Otherwise, don't change a thing. */
  if (call_set_current)
    {
      if (last_stopped_job != NO_JOB)
	set_current_job (last_stopped_job);
      else
	reset_current ();
    }

  /* Call a SIGCHLD trap handler for each child that exits, if one is set. */
  if (job_control && signal_is_trapped (SIGCHLD) && children_exited &&
      trap_list[SIGCHLD] != (char *)IGNORE_SIG)
    {
      if (posixly_correct && this_shell_builtin && this_shell_builtin == wait_builtin)
	{
	  interrupt_immediately = 0;
	  trap_handler (SIGCHLD);	/* set pending_traps[SIGCHLD] */
	  wait_signal_received = SIGCHLD;
	  longjmp (wait_intr_buf, 1);
	}

      run_sigchld_trap (children_exited);
    }

  /* We have successfully recorded the useful information about this process
     that has just changed state.  If we notify asynchronously, and the job
     that this process belongs to is no longer running, then notify the user
     of that fact now. */
  if (asynchronous_notification && interactive)
    notify_of_job_status ();

  return (children_exited);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\jobs.c:3,065
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\jobs.c:3,213
parsing error 
{
  PROCESS *child;
  int tstatus, job_state, any_stopped, any_tstped, call_set_current;
  SigHandler *temp_handler;

  child = jobs[job]->pipe;
  jobs[job]->flags &= ~J_NOTIFIED;

  call_set_current = 0;

  /*
   * COMPUTE JOB STATUS
   */

  /* If all children are not running, but any of them is  stopped, then
     the job is stopped, not dead. */
  job_state = any_stopped = any_tstped = 0;
  do
    {
      job_state |= PRUNNING (child);
#if 0
      if (PEXITED (child) && (WIFSTOPPED (child->status)))
#else
      /* Only checking for WIFSTOPPED now, not for PS_DONE */
      if (PSTOPPED (child))
#endif
	{
	  any_stopped = 1;
	  any_tstped |= interactive && job_control &&
			    (WSTOPSIG (child->status) == SIGTSTP);
	}
      child = child->next;
    }
  while (child != jobs[job]->pipe);

  /* If job_state != 0, the job is still running, so don't bother with
     setting the process exit status and job state unless we're
     transitioning from stopped to running. */
  if (job_state != 0 && JOBSTATE(job) != JSTOPPED)
    return 0;

  /*
   * SET JOB STATUS
   */

  /* The job is either stopped or dead.  Set the state of the job accordingly. */
  if (any_stopped)
    {
      jobs[job]->state = JSTOPPED;
      jobs[job]->flags &= ~J_FOREGROUND;
      call_set_current++;
      /* Suspending a job with SIGTSTP breaks all active loops. */
      if (any_tstped && loop_level)
	breaking = loop_level;
    }
  else if (job_state != 0)	/* was stopped, now running */
    {
      jobs[job]->state = JRUNNING;
      call_set_current++;
    }
  else
    {
      jobs[job]->state = JDEAD;
      js.j_ndead++;

#if 0
      if (IS_FOREGROUND (job))
	setjstatus (job);
#endif

      /* If this job has a cleanup function associated with it, call it
	 with `cleanarg' as the single argument, then set the function
	 pointer to NULL so it is not inadvertently called twice.  The
	 cleanup function is responsible for deallocating cleanarg. */
      if (jobs[job]->j_cleanup)
	{
	  (*jobs[job]->j_cleanup) (jobs[job]->cleanarg);
	  jobs[job]->j_cleanup = (sh_vptrfunc_t *)NULL;
	}
    }

  /*
   * CLEANUP
   *
   * Currently, we just do special things if we got a SIGINT while waiting
   * for a foreground job to complete
   */

  if (JOBSTATE (job) == JDEAD)
    {
      /* If we're running a shell script and we get a SIGINT with a
	 SIGINT trap handler, but the foreground job handles it and
	 does not exit due to SIGINT, run the trap handler but do not
	 otherwise act as if we got the interrupt. */
      if (wait_sigint_received && interactive_shell == 0 &&
	  WIFSIGNALED (child->status) == 0 && IS_FOREGROUND (job) &&
	  signal_is_trapped (SIGINT))
	{
	  int old_frozen;
	  wait_sigint_received = 0;
	  last_command_exit_value = process_exit_status (child->status);

	  old_frozen = jobs_list_frozen;
	  jobs_list_frozen = 1;
	  tstatus = maybe_call_trap_handler (SIGINT);
	  jobs_list_frozen = old_frozen;
	}

      /* If the foreground job is killed by SIGINT when job control is not
	 active, we need to perform some special handling.

	 The check of wait_sigint_received is a way to determine if the
	 SIGINT came from the keyboard (in which case the shell has already
	 seen it, and wait_sigint_received is non-zero, because keyboard
	 signals are sent to process groups) or via kill(2) to the foreground
	 process by another process (or itself).  If the shell did receive the
	 SIGINT, it needs to perform normal SIGINT processing. */
      else if (wait_sigint_received && (WTERMSIG (child->status) == SIGINT) &&
	      IS_FOREGROUND (job) && IS_JOBCONTROL (job) == 0)
	{
	  int old_frozen;

	  wait_sigint_received = 0;

	  /* If SIGINT is trapped, set the exit status so that the trap
	     handler can see it. */
	  if (signal_is_trapped (SIGINT))
	    last_command_exit_value = process_exit_status (child->status);

	  /* If the signal is trapped, let the trap handler get it no matter
	     what and simply return if the trap handler returns.
	    maybe_call_trap_handler() may cause dead jobs to be removed from
	    the job table because of a call to execute_command.  We work
	    around this by setting JOBS_LIST_FROZEN. */
	  old_frozen = jobs_list_frozen;
	  jobs_list_frozen = 1;
	  tstatus = maybe_call_trap_handler (SIGINT);
	  jobs_list_frozen = old_frozen;
	  if (tstatus == 0 && old_sigint_handler != INVALID_SIGNAL_HANDLER)
	    {
	      /* wait_sigint_handler () has already seen SIGINT and
		 allowed the wait builtin to jump out.  We need to
		 call the original SIGINT handler, if necessary.  If
		 the original handler is SIG_DFL, we need to resend
		 the signal to ourselves. */

	      temp_handler = old_sigint_handler;

	      /* Bogus.  If we've reset the signal handler as the result
		 of a trap caught on SIGINT, then old_sigint_handler
		 will point to trap_handler, which now knows nothing about
		 SIGINT (if we reset the sighandler to the default).
		 In this case, we have to fix things up.  What a crock. */
	      if (temp_handler == trap_handler && signal_is_trapped (SIGINT) == 0)
		  temp_handler = trap_to_sighandler (SIGINT);
		restore_sigint_handler ();
	      if (temp_handler == SIG_DFL)
		termsig_handler (SIGINT);
	      else if (temp_handler != SIG_IGN)
		(*temp_handler) (SIGINT);
	    }
	}
    }

  return call_set_current;
}
warning: parse error {
  PROCESS *child;
  int tstatus, job_state, any_stopped, any_tstped, call_set_current;
  SigHandler *temp_handler;

  child = jobs[job]->pipe;
  jobs[job]->flags &= ~J_NOTIFIED;

  call_set_current = 0;

  /*
   * COMPUTE JOB STATUS
   */

  /* If all children are not running, but any of them is  stopped, then
     the job is stopped, not dead. */
  job_state = any_stopped = any_tstped = 0;
  do
    {
      job_state |= PRUNNING (child);
#if 0
      if (PEXITED (child) && (WIFSTOPPED (child->status)))
#else
      /* Only checking for WIFSTOPPED now, not for PS_DONE */
      if (PSTOPPED (child))
#endif
	{
	  any_stopped = 1;
	  any_tstped |= interactive && job_control &&
			    (WSTOPSIG (child->status) == SIGTSTP);
	}
      child = child->next;
    }
  while (child != jobs[job]->pipe);

  /* If job_state != 0, the job is still running, so don't bother with
     setting the process exit status and job state unless we're
     transitioning from stopped to running. */
  if (job_state != 0 && JOBSTATE(job) != JSTOPPED)
    return 0;

  /*
   * SET JOB STATUS
   */

  /* The job is either stopped or dead.  Set the state of the job accordingly. */
  if (any_stopped)
    {
      jobs[job]->state = JSTOPPED;
      jobs[job]->flags &= ~J_FOREGROUND;
      call_set_current++;
      /* Suspending a job with SIGTSTP breaks all active loops. */
      if (any_tstped && loop_level)
	breaking = loop_level;
    }
  else if (job_state != 0)	/* was stopped, now running */
    {
      jobs[job]->state = JRUNNING;
      call_set_current++;
    }
  else
    {
      jobs[job]->state = JDEAD;
      js.j_ndead++;

#if 0
      if (IS_FOREGROUND (job))
	setjstatus (job);
#endif

      /* If this job has a cleanup function associated with it, call it
	 with `cleanarg' as the single argument, then set the function
	 pointer to NULL so it is not inadvertently called twice.  The
	 cleanup function is responsible for deallocating cleanarg. */
      if (jobs[job]->j_cleanup)
	{
	  (*jobs[job]->j_cleanup) (jobs[job]->cleanarg);
	  jobs[job]->j_cleanup = (sh_vptrfunc_t *)NULL;
	}
    }

  /*
   * CLEANUP
   *
   * Currently, we just do special things if we got a SIGINT while waiting
   * for a foreground job to complete
   */

  if (JOBSTATE (job) == JDEAD)
    {
      /* If we're running a shell script and we get a SIGINT with a
	 SIGINT trap handler, but the foreground job handles it and
	 does not exit due to SIGINT, run the trap handler but do not
	 otherwise act as if we got the interrupt. */
      if (wait_sigint_received && interactive_shell == 0 &&
	  WIFSIGNALED (child->status) == 0 && IS_FOREGROUND (job) &&
	  signal_is_trapped (SIGINT))
	{
	  int old_frozen;
	  wait_sigint_received = 0;
	  last_command_exit_value = process_exit_status (child->status);

	  old_frozen = jobs_list_frozen;
	  jobs_list_frozen = 1;
	  tstatus = maybe_call_trap_handler (SIGINT);
	  jobs_list_frozen = old_frozen;
	}

      /* If the foreground job is killed by SIGINT when job control is not
	 active, we need to perform some special handling.

	 The check of wait_sigint_received is a way to determine if the
	 SIGINT came from the keyboard (in which case the shell has already
	 seen it, and wait_sigint_received is non-zero, because keyboard
	 signals are sent to process groups) or via kill(2) to the foreground
	 process by another process (or itself).  If the shell did receive the
	 SIGINT, it needs to perform normal SIGINT processing. */
      else if (wait_sigint_received && (WTERMSIG (child->status) == SIGINT) &&
	      IS_FOREGROUND (job) && IS_JOBCONTROL (job) == 0)
	{
	  int old_frozen;

	  wait_sigint_received = 0;

	  /* If SIGINT is trapped, set the exit status so that the trap
	     handler can see it. */
	  if (signal_is_trapped (SIGINT))
	    last_command_exit_value = process_exit_status (child->status);

	  /* If the signal is trapped, let the trap handler get it no matter
	     what and simply return if the trap handler returns.
	    maybe_call_trap_handler() may cause dead jobs to be removed from
	    the job table because of a call to execute_command.  We work
	    around this by setting JOBS_LIST_FROZEN. */
	  old_frozen = jobs_list_frozen;
	  jobs_list_frozen = 1;
	  tstatus = maybe_call_trap_handler (SIGINT);
	  jobs_list_frozen = old_frozen;
	  if (tstatus == 0 && old_sigint_handler != INVALID_SIGNAL_HANDLER)
	    {
	      /* wait_sigint_handler () has already seen SIGINT and
		 allowed the wait builtin to jump out.  We need to
		 call the original SIGINT handler, if necessary.  If
		 the original handler is SIG_DFL, we need to resend
		 the signal to ourselves. */

	      temp_handler = old_sigint_handler;

	      /* Bogus.  If we've reset the signal handler as the result
		 of a trap caught on SIGINT, then old_sigint_handler
		 will point to trap_handler, which now knows nothing about
		 SIGINT (if we reset the sighandler to the default).
		 In this case, we have to fix things up.  What a crock. */
	      if (temp_handler == trap_handler && signal_is_trapped (SIGINT) == 0)
		  temp_handler = trap_to_sighandler (SIGINT);
		restore_sigint_handler ();
	      if (temp_handler == SIG_DFL)
		termsig_handler (SIGINT);
	      else if (temp_handler != SIG_IGN)
		(*temp_handler) (SIGINT);
	    }
	}
    }

  return call_set_current;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\jobs.c:3,215
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\jobs.c:3,385
parsing error 
{
#if defined (ARRAY_VARS)
  register int i;
  register PROCESS *p;

  for (i = 1, p = jobs[j]->pipe; p->next != jobs[j]->pipe; p = p->next, i++)
    ;
  i++;
  if (statsize < i)
    {
      pstatuses = (int *)xrealloc (pstatuses, i * sizeof (int));
      statsize = i;
    }
  i = 0;
  p = jobs[j]->pipe;
  do
    {
      pstatuses[i++] = process_exit_status (p->status);
      p = p->next;
    }
  while (p != jobs[j]->pipe);

  pstatuses[i] = -1;	/* sentinel */
  set_pipestatus_array (pstatuses, i);
#endif
}
warning: parse error {
#if defined (ARRAY_VARS)
  register int i;
  register PROCESS *p;

  for (i = 1, p = jobs[j]->pipe; p->next != jobs[j]->pipe; p = p->next, i++)
    ;
  i++;
  if (statsize < i)
    {
      pstatuses = (int *)xrealloc (pstatuses, i * sizeof (int));
      statsize = i;
    }
  i = 0;
  p = jobs[j]->pipe;
  do
    {
      pstatuses[i++] = process_exit_status (p->status);
      p = p->next;
    }
  while (p != jobs[j]->pipe);

  pstatuses[i] = -1;	/* sentinel */
  set_pipestatus_array (pstatuses, i);
#endif
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\jobs.c:3,387
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\jobs.c:3,415
parsing error 
{
  char *trap_command;
  int i;

  /* Turn off the trap list during the call to parse_and_execute ()
     to avoid potentially infinite recursive calls.  Preserve the
     values of last_command_exit_value, last_made_pid, and the_pipeline
     around the execution of the trap commands. */
  trap_command = savestring (trap_list[SIGCHLD]);

  begin_unwind_frame ("SIGCHLD trap");
  unwind_protect_int (last_command_exit_value);
  unwind_protect_int (last_command_exit_signal);
  unwind_protect_var (last_made_pid);
  unwind_protect_int (interrupt_immediately);
  unwind_protect_int (jobs_list_frozen);
  unwind_protect_pointer (the_pipeline);
  unwind_protect_pointer (subst_assign_varlist);

  /* We have to add the commands this way because they will be run
     in reverse order of adding.  We don't want maybe_set_sigchld_trap ()
     to reference freed memory. */
  add_unwind_protect (xfree, trap_command);
  add_unwind_protect (maybe_set_sigchld_trap, trap_command);

  subst_assign_varlist = (WORD_LIST *)NULL;
  the_pipeline = (PROCESS *)NULL;

  set_impossible_sigchld_trap ();
  jobs_list_frozen = 1;
  for (i = 0; i < nchild; i++)
    {
      interrupt_immediately = 1;
      parse_and_execute (savestring (trap_command), "trap", SEVAL_NOHIST|SEVAL_RESETLINE);
    }

  run_unwind_frame ("SIGCHLD trap");
}
warning: parse error {
  char *trap_command;
  int i;

  /* Turn off the trap list during the call to parse_and_execute ()
     to avoid potentially infinite recursive calls.  Preserve the
     values of last_command_exit_value, last_made_pid, and the_pipeline
     around the execution of the trap commands. */
  trap_command = savestring (trap_list[SIGCHLD]);

  begin_unwind_frame ("SIGCHLD trap");
  unwind_protect_int (last_command_exit_value);
  unwind_protect_int (last_command_exit_signal);
  unwind_protect_var (last_made_pid);
  unwind_protect_int (interrupt_immediately);
  unwind_protect_int (jobs_list_frozen);
  unwind_protect_pointer (the_pipeline);
  unwind_protect_pointer (subst_assign_varlist);

  /* We have to add the commands this way because they will be run
     in reverse order of adding.  We don't want maybe_set_sigchld_trap ()
     to reference freed memory. */
  add_unwind_protect (xfree, trap_command);
  add_unwind_protect (maybe_set_sigchld_trap, trap_command);

  subst_assign_varlist = (WORD_LIST *)NULL;
  the_pipeline = (PROCESS *)NULL;

  set_impossible_sigchld_trap ();
  jobs_list_frozen = 1;
  for (i = 0; i < nchild; i++)
    {
      interrupt_immediately = 1;
      parse_and_execute (savestring (trap_command), "trap", SEVAL_NOHIST|SEVAL_RESETLINE);
    }

  run_unwind_frame ("SIGCHLD trap");
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\jobs.c:3,417
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\jobs.c:3,598
parsing error 
{
  pid_t t;
  int t_errno;

  t_errno = -1;
  shell_pgrp = getpgid (0);

  if (shell_pgrp == -1)
    {
      sys_error (_("initialize_job_control: getpgrp failed"));
      exit (1);
    }

  /* We can only have job control if we are interactive. */
  if (interactive == 0)
    {
      job_control = 0;
      original_pgrp = NO_PID;
      shell_tty = fileno (stderr);
    }
  else
    {
      shell_tty = -1;

      /* If forced_interactive is set, we skip the normal check that stderr
	 is attached to a tty, so we need to check here.  If it's not, we
	 need to see whether we have a controlling tty by opening /dev/tty,
	 since trying to use job control tty pgrp manipulations on a non-tty
	 is going to fail. */
      if (forced_interactive && isatty (fileno (stderr)) == 0)
	shell_tty = open ("/dev/tty", O_RDWR|O_NONBLOCK);

      /* Get our controlling terminal.  If job_control is set, or
	 interactive is set, then this is an interactive shell no
	 matter where fd 2 is directed. */
      if (shell_tty == -1)
	shell_tty = dup (fileno (stderr));	/* fd 2 */

      shell_tty = move_to_high_fd (shell_tty, 1, -1);

      /* Compensate for a bug in systems that compiled the BSD
	 rlogind with DEBUG defined, like NeXT and Alliant. */
      if (shell_pgrp == 0)
	{
	  shell_pgrp = getpid ();
	  setpgid (0, shell_pgrp);
	  tcsetpgrp (shell_tty, shell_pgrp);
	}

      while ((terminal_pgrp = tcgetpgrp (shell_tty)) != -1)
	{
	  if (shell_pgrp != terminal_pgrp)
	    {
	      SigHandler *ottin;

	      ottin = set_signal_handler(SIGTTIN, SIG_DFL);
	      kill (0, SIGTTIN);
	      set_signal_handler (SIGTTIN, ottin);
	      continue;
	    }
	  break;
	}

      if (terminal_pgrp == -1)
	t_errno = errno;

      /* Make sure that we are using the new line discipline. */
      if (set_new_line_discipline (shell_tty) < 0)
	{
	  sys_error (_("initialize_job_control: line discipline"));
	  job_control = 0;
	}
      else
	{
	  original_pgrp = shell_pgrp;
	  shell_pgrp = getpid ();

	  if ((original_pgrp != shell_pgrp) && (setpgid (0, shell_pgrp) < 0))
	    {
	      sys_error (_("initialize_job_control: setpgid"));
	      shell_pgrp = original_pgrp;
	    }

	  job_control = 1;

	  /* If (and only if) we just set our process group to our pid,
	     thereby becoming a process group leader, and the terminal
	     is not in the same process group as our (new) process group,
	     then set the terminal's process group to our (new) process
	     group.  If that fails, set our process group back to what it
	     was originally (so we can still read from the terminal) and
	     turn off job control.  */
	  if (shell_pgrp != original_pgrp && shell_pgrp != terminal_pgrp)
	    {
	      if (give_terminal_to (shell_pgrp, 0) < 0)
		{
		  t_errno = errno;
		  setpgid (0, original_pgrp);
		  shell_pgrp = original_pgrp;
		  job_control = 0;
		}
	    }

	  if (job_control && ((t = tcgetpgrp (shell_tty)) == -1 || t != shell_pgrp))
	    {
	      if (t_errno != -1)
		errno = t_errno;
	      sys_error (_("cannot set terminal process group (%d)"), t);
	      job_control = 0;
	    }
	}
      if (job_control == 0)
	internal_error (_("no job control in this shell"));
    }

  if (shell_tty != fileno (stderr))
    SET_CLOSE_ON_EXEC (shell_tty);

  set_signal_handler (SIGCHLD, sigchld_handler);

  change_flag ('m', job_control ? '-' : '+');

  if (interactive)
    get_tty_state ();

  if (js.c_childmax < 0)
    js.c_childmax = getmaxchild ();
  if (js.c_childmax < 0)
    js.c_childmax = DEFAULT_CHILD_MAX;

  return job_control;
}
warning: parse error {
  pid_t t;
  int t_errno;

  t_errno = -1;
  shell_pgrp = getpgid (0);

  if (shell_pgrp == -1)
    {
      sys_error (_("initialize_job_control: getpgrp failed"));
      exit (1);
    }

  /* We can only have job control if we are interactive. */
  if (interactive == 0)
    {
      job_control = 0;
      original_pgrp = NO_PID;
      shell_tty = fileno (stderr);
    }
  else
    {
      shell_tty = -1;

      /* If forced_interactive is set, we skip the normal check that stderr
	 is attached to a tty, so we need to check here.  If it's not, we
	 need to see whether we have a controlling tty by opening /dev/tty,
	 since trying to use job control tty pgrp manipulations on a non-tty
	 is going to fail. */
      if (forced_interactive && isatty (fileno (stderr)) == 0)
	shell_tty = open ("/dev/tty", O_RDWR|O_NONBLOCK);

      /* Get our controlling terminal.  If job_control is set, or
	 interactive is set, then this is an interactive shell no
	 matter where fd 2 is directed. */
      if (shell_tty == -1)
	shell_tty = dup (fileno (stderr));	/* fd 2 */

      shell_tty = move_to_high_fd (shell_tty, 1, -1);

      /* Compensate for a bug in systems that compiled the BSD
	 rlogind with DEBUG defined, like NeXT and Alliant. */
      if (shell_pgrp == 0)
	{
	  shell_pgrp = getpid ();
	  setpgid (0, shell_pgrp);
	  tcsetpgrp (shell_tty, shell_pgrp);
	}

      while ((terminal_pgrp = tcgetpgrp (shell_tty)) != -1)
	{
	  if (shell_pgrp != terminal_pgrp)
	    {
	      SigHandler *ottin;

	      ottin = set_signal_handler(SIGTTIN, SIG_DFL);
	      kill (0, SIGTTIN);
	      set_signal_handler (SIGTTIN, ottin);
	      continue;
	    }
	  break;
	}

      if (terminal_pgrp == -1)
	t_errno = errno;

      /* Make sure that we are using the new line discipline. */
      if (set_new_line_discipline (shell_tty) < 0)
	{
	  sys_error (_("initialize_job_control: line discipline"));
	  job_control = 0;
	}
      else
	{
	  original_pgrp = shell_pgrp;
	  shell_pgrp = getpid ();

	  if ((original_pgrp != shell_pgrp) && (setpgid (0, shell_pgrp) < 0))
	    {
	      sys_error (_("initialize_job_control: setpgid"));
	      shell_pgrp = original_pgrp;
	    }

	  job_control = 1;

	  /* If (and only if) we just set our process group to our pid,
	     thereby becoming a process group leader, and the terminal
	     is not in the same process group as our (new) process group,
	     then set the terminal's process group to our (new) process
	     group.  If that fails, set our process group back to what it
	     was originally (so we can still read from the terminal) and
	     turn off job control.  */
	  if (shell_pgrp != original_pgrp && shell_pgrp != terminal_pgrp)
	    {
	      if (give_terminal_to (shell_pgrp, 0) < 0)
		{
		  t_errno = errno;
		  setpgid (0, original_pgrp);
		  shell_pgrp = original_pgrp;
		  job_control = 0;
		}
	    }

	  if (job_control && ((t = tcgetpgrp (shell_tty)) == -1 || t != shell_pgrp))
	    {
	      if (t_errno != -1)
		errno = t_errno;
	      sys_error (_("cannot set terminal process group (%d)"), t);
	      job_control = 0;
	    }
	}
      if (job_control == 0)
	internal_error (_("no job control in this shell"));
    }

  if (shell_tty != fileno (stderr))
    SET_CLOSE_ON_EXEC (shell_tty);

  set_signal_handler (SIGCHLD, sigchld_handler);

  change_flag ('m', job_control ? '-' : '+');

  if (interactive)
    get_tty_state ();

  if (js.c_childmax < 0)
    js.c_childmax = getmaxchild ();
  if (js.c_childmax < 0)
    js.c_childmax = DEFAULT_CHILD_MAX;

  return job_control;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\jobs.c:3,600
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\jobs.c:3,747
parsing error 
{
#if defined (NEW_TTY_DRIVER)
  int ldisc;

  if (ioctl (tty, TIOCGETD, &ldisc) < 0)
    return (-1);

  if (ldisc != NTTYDISC)
    {
      ldisc = NTTYDISC;

      if (ioctl (tty, TIOCSETD, &ldisc) < 0)
	return (-1);
    }
  return (0);
#endif /* NEW_TTY_DRIVER */

#if defined (TERMIO_TTY_DRIVER)
#  if defined (TERMIO_LDISC) && (NTTYDISC)
  if (ioctl (tty, TCGETA, &shell_tty_info) < 0)
    return (-1);

  if (shell_tty_info.c_line != NTTYDISC)
    {
      shell_tty_info.c_line = NTTYDISC;
      if (ioctl (tty, TCSETAW, &shell_tty_info) < 0)
	return (-1);
    }
#  endif /* TERMIO_LDISC && NTTYDISC */
  return (0);
#endif /* TERMIO_TTY_DRIVER */

#if defined (TERMIOS_TTY_DRIVER)
#  if defined (TERMIOS_LDISC) && defined (NTTYDISC)
  if (tcgetattr (tty, &shell_tty_info) < 0)
    return (-1);

  if (shell_tty_info.c_line != NTTYDISC)
    {
      shell_tty_info.c_line = NTTYDISC;
      if (tcsetattr (tty, TCSADRAIN, &shell_tty_info) < 0)
	return (-1);
    }
#  endif /* TERMIOS_LDISC && NTTYDISC */
  return (0);
#endif /* TERMIOS_TTY_DRIVER */

#if !defined (NEW_TTY_DRIVER) && !defined (TERMIO_TTY_DRIVER) && !defined (TERMIOS_TTY_DRIVER)
  return (-1);
#endif
}
warning: parse error {
#if defined (NEW_TTY_DRIVER)
  int ldisc;

  if (ioctl (tty, TIOCGETD, &ldisc) < 0)
    return (-1);

  if (ldisc != NTTYDISC)
    {
      ldisc = NTTYDISC;

      if (ioctl (tty, TIOCSETD, &ldisc) < 0)
	return (-1);
    }
  return (0);
#endif /* NEW_TTY_DRIVER */

#if defined (TERMIO_TTY_DRIVER)
#  if defined (TERMIO_LDISC) && (NTTYDISC)
  if (ioctl (tty, TCGETA, &shell_tty_info) < 0)
    return (-1);

  if (shell_tty_info.c_line != NTTYDISC)
    {
      shell_tty_info.c_line = NTTYDISC;
      if (ioctl (tty, TCSETAW, &shell_tty_info) < 0)
	return (-1);
    }
#  endif /* TERMIO_LDISC && NTTYDISC */
  return (0);
#endif /* TERMIO_TTY_DRIVER */

#if defined (TERMIOS_TTY_DRIVER)
#  if defined (TERMIOS_LDISC) && defined (NTTYDISC)
  if (tcgetattr (tty, &shell_tty_info) < 0)
    return (-1);

  if (shell_tty_info.c_line != NTTYDISC)
    {
      shell_tty_info.c_line = NTTYDISC;
      if (tcsetattr (tty, TCSADRAIN, &shell_tty_info) < 0)
	return (-1);
    }
#  endif /* TERMIOS_LDISC && NTTYDISC */
  return (0);
#endif /* TERMIOS_TTY_DRIVER */

#if !defined (NEW_TTY_DRIVER) && !defined (TERMIO_TTY_DRIVER) && !defined (TERMIOS_TTY_DRIVER)
  return (-1);
#endif
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\jobs.c:3,749
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\jobs.c:3,824
parsing error 
{
  initialize_job_signals ();
  set_signal_handler (SIGCONT, old_cont);
  kill (getpid (), SIGCONT);

  SIGRETURN (0);
}
warning: parse error {
  initialize_job_signals ();
  set_signal_handler (SIGCONT, old_cont);
  kill (getpid (), SIGCONT);

  SIGRETURN (0);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\jobs.c:3,826
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\jobs.c:3,836
parsing error 
{
  set_signal_handler (SIGTSTP, old_tstp);
  set_signal_handler (SIGTTOU, old_ttou);
  set_signal_handler (SIGTTIN, old_ttin);

  old_cont = set_signal_handler (SIGCONT, sigcont_sighandler);

  give_terminal_to (shell_pgrp, 0);

  kill (getpid (), sig);

  SIGRETURN (0);
}
warning: parse error {
  set_signal_handler (SIGTSTP, old_tstp);
  set_signal_handler (SIGTTOU, old_ttou);
  set_signal_handler (SIGTTIN, old_ttin);

  old_cont = set_signal_handler (SIGCONT, sigcont_sighandler);

  give_terminal_to (shell_pgrp, 0);

  kill (getpid (), sig);

  SIGRETURN (0);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\jobs.c:3,838
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\jobs.c:3,854
parsing error 
{
  sigset_t set, oset;
  int r, e;

  r = 0;
  if (job_control || force)
    {
      sigemptyset (&set);
      sigaddset (&set, SIGTTOU);
      sigaddset (&set, SIGTTIN);
      sigaddset (&set, SIGTSTP);
      sigaddset (&set, SIGCHLD);
      sigemptyset (&oset);
      sigprocmask (SIG_BLOCK, &set, &oset);

      if (tcsetpgrp (shell_tty, pgrp) < 0)
	{
	  /* Maybe we should print an error message? */
#if 0
	  sys_error ("tcsetpgrp(%d) failed: pid %ld to pgrp %ld",
	    shell_tty, (long)getpid(), (long)pgrp);
#endif
	  r = -1;
	  e = errno;
	}
      else
	terminal_pgrp = pgrp;
      sigprocmask (SIG_SETMASK, &oset, (sigset_t *)NULL);
    }

  if (r == -1)
    errno = e;

  return r;
}
warning: parse error {
  sigset_t set, oset;
  int r, e;

  r = 0;
  if (job_control || force)
    {
      sigemptyset (&set);
      sigaddset (&set, SIGTTOU);
      sigaddset (&set, SIGTTIN);
      sigaddset (&set, SIGTSTP);
      sigaddset (&set, SIGCHLD);
      sigemptyset (&oset);
      sigprocmask (SIG_BLOCK, &set, &oset);

      if (tcsetpgrp (shell_tty, pgrp) < 0)
	{
	  /* Maybe we should print an error message? */
#if 0
	  sys_error ("tcsetpgrp(%d) failed: pid %ld to pgrp %ld",
	    shell_tty, (long)getpid(), (long)pgrp);
#endif
	  r = -1;
	  e = errno;
	}
      else
	terminal_pgrp = pgrp;
      sigprocmask (SIG_SETMASK, &oset, (sigset_t *)NULL);
    }

  if (r == -1)
    errno = e;

  return r;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\jobs.c:3,857
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\jobs.c:3,896
parsing error 
{
  int tpgrp;

  tpgrp = tcgetpgrp (shell_tty);
  if (tpgrp < 0 && errno == ENOTTY)
    return -1;
  if (tpgrp == npgrp)
    {
      terminal_pgrp = npgrp;
      return 0;
    }
  else if (tpgrp != opgrp)
    {
#if defined (DEBUG)
      internal_warning ("maybe_give_terminal_to: terminal pgrp == %d shell pgrp = %d new pgrp = %d", tpgrp, opgrp, npgrp);
#endif
      return -1;
    }
  else
    return (give_terminal_to (npgrp, flags));     
}
warning: parse error {
  int tpgrp;

  tpgrp = tcgetpgrp (shell_tty);
  if (tpgrp < 0 && errno == ENOTTY)
    return -1;
  if (tpgrp == npgrp)
    {
      terminal_pgrp = npgrp;
      return 0;
    }
  else if (tpgrp != opgrp)
    {
#if defined (DEBUG)
      internal_warning ("maybe_give_terminal_to: terminal pgrp == %d shell pgrp = %d new pgrp = %d", tpgrp, opgrp, npgrp);
#endif
      return -1;
    }
  else
    return (give_terminal_to (npgrp, flags));     
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\jobs.c:3,899
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\jobs.c:3,927
parsing error 
{
  register int i;
  sigset_t set, oset;

  BLOCK_CHILD (set, oset);

  /* XXX - need to set j_lastj, j_firstj appropriately if running_only != 0. */
  if (js.j_jobslots)
    {
      js.j_current = js.j_previous = NO_JOB;

      /* XXX could use js.j_firstj here */
      for (i = 0; i < js.j_jobslots; i++)
	{
#if defined (DEBUG)
	  if (i < js.j_firstj && jobs[i])
	    itrace("delete_all_jobs: job %d non-null before js.j_firstj (%d)", i, js.j_firstj);
	  if (i > js.j_lastj && jobs[i])
	    itrace("delete_all_jobs: job %d non-null after js.j_lastj (%d)", i, js.j_lastj);
#endif
	  if (jobs[i] && (running_only == 0 || (running_only && RUNNING(i))))
	    delete_job (i, DEL_WARNSTOPPED);
	}
      if (running_only == 0)
	{
	  free ((char *)jobs);
	  js.j_jobslots = 0;
	  js.j_firstj = js.j_lastj = js.j_njobs = 0;
	}
    }

  if (running_only == 0)
    bgp_clear ();

  UNBLOCK_CHILD (oset);
}
warning: parse error {
  register int i;
  sigset_t set, oset;

  BLOCK_CHILD (set, oset);

  /* XXX - need to set j_lastj, j_firstj appropriately if running_only != 0. */
  if (js.j_jobslots)
    {
      js.j_current = js.j_previous = NO_JOB;

      /* XXX could use js.j_firstj here */
      for (i = 0; i < js.j_jobslots; i++)
	{
#if defined (DEBUG)
	  if (i < js.j_firstj && jobs[i])
	    itrace("delete_all_jobs: job %d non-null before js.j_firstj (%d)", i, js.j_firstj);
	  if (i > js.j_lastj && jobs[i])
	    itrace("delete_all_jobs: job %d non-null after js.j_lastj (%d)", i, js.j_lastj);
#endif
	  if (jobs[i] && (running_only == 0 || (running_only && RUNNING(i))))
	    delete_job (i, DEL_WARNSTOPPED);
	}
      if (running_only == 0)
	{
	  free ((char *)jobs);
	  js.j_jobslots = 0;
	  js.j_firstj = js.j_lastj = js.j_njobs = 0;
	}
    }

  if (running_only == 0)
    bgp_clear ();

  UNBLOCK_CHILD (oset);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\jobs.c:3,929
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\jobs.c:3,969
parsing error 
{
  register int i;
  sigset_t set, oset;

  BLOCK_CHILD (set, oset);

  if (js.j_jobslots)
    {
      /* XXX could use js.j_firstj here */
      for (i = 0; i < js.j_jobslots; i++)
	if (jobs[i] && (running_only == 0 || (running_only && RUNNING(i))))
	  nohup_job (i);
    }

  UNBLOCK_CHILD (oset);
}
warning: parse error {
  register int i;
  sigset_t set, oset;

  BLOCK_CHILD (set, oset);

  if (js.j_jobslots)
    {
      /* XXX could use js.j_firstj here */
      for (i = 0; i < js.j_jobslots; i++)
	if (jobs[i] && (running_only == 0 || (running_only && RUNNING(i))))
	  nohup_job (i);
    }

  UNBLOCK_CHILD (oset);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\jobs.c:3,971
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\jobs.c:4,039
parsing error 
{
  register int i, ndead, ndeadproc;
  sigset_t set, oset;

  if (js.j_jobslots == 0)
    return;

  BLOCK_CHILD (set, oset);

  /* If FORCE is non-zero, we don't have to keep CHILD_MAX statuses
     around; just run through the array. */
  if (force)
    {
    /* XXX could use js.j_firstj here */
      for (i = 0; i < js.j_jobslots; i++)
	{
	  if (jobs[i] && DEADJOB (i) && (interactive_shell || (find_last_pid (i, 0) != last_asynchronous_pid)))
	    jobs[i]->flags |= J_NOTIFIED;
	}
      UNBLOCK_CHILD (oset);
      return;
    }

  /* Mark enough dead jobs as notified to keep CHILD_MAX processes left in the
     array with the corresponding not marked as notified.  This is a better
     way to avoid pid aliasing and reuse problems than keeping the POSIX-
     mandated CHILD_MAX jobs around.  delete_job() takes care of keeping the
     bgpids list regulated. */
          
  /* Count the number of dead jobs */
  /* XXX could use js.j_firstj here */
  for (i = ndead = ndeadproc = 0; i < js.j_jobslots; i++)
    {
#if defined (DEBUG)
      if (i < js.j_firstj && jobs[i])
	itrace("mark_dead_jobs_as_notified: job %d non-null before js.j_firstj (%d)", i, js.j_firstj);
      if (i > js.j_lastj && jobs[i])
	itrace("mark_dead_jobs_as_notified: job %d non-null after js.j_lastj (%d)", i, js.j_lastj);
#endif
      if (jobs[i] && DEADJOB (i))
	{
	  ndead++;
	  ndeadproc += processes_in_job (i);
	}
    }

#ifdef DEBUG
  if (ndeadproc != js.c_reaped)
    itrace("mark_dead_jobs_as_notified: ndeadproc (%d) != js.c_reaped (%d)", ndeadproc, js.c_reaped);
  if (ndead != js.j_ndead)
    itrace("mark_dead_jobs_as_notified: ndead (%d) != js.j_ndead (%d)", ndead, js.j_ndead);
#endif

  if (js.c_childmax < 0)
    js.c_childmax = getmaxchild ();
  if (js.c_childmax < 0)
    js.c_childmax = DEFAULT_CHILD_MAX;

  /* Don't do anything if the number of dead processes is less than CHILD_MAX
     and we're not forcing a cleanup. */
  if (ndeadproc <= js.c_childmax)
    {
      UNBLOCK_CHILD (oset);
      return;
    }

#if 0
itrace("mark_dead_jobs_as_notified: child_max = %d ndead = %d ndeadproc = %d", js.c_childmax, ndead, ndeadproc);
#endif

  /* Mark enough dead jobs as notified that we keep CHILD_MAX jobs in
     the list.  This isn't exactly right yet; changes need to be made
     to stop_pipeline so we don't mark the newer jobs after we've
     created CHILD_MAX slots in the jobs array.  This needs to be
     integrated with a way to keep the jobs array from growing without
     bound.  Maybe we wrap back around to 0 after we reach some max
     limit, and there are sufficient job slots free (keep track of total
     size of jobs array (js.j_jobslots) and running count of number of jobs
     in jobs array.  Then keep a job index corresponding to the `oldest job'
     and start this loop there, wrapping around as necessary.  In effect,
     we turn the list into a circular buffer. */
  /* XXX could use js.j_firstj here */
  for (i = 0; i < js.j_jobslots; i++)
    {
      if (jobs[i] && DEADJOB (i) && (interactive_shell || (find_last_pid (i, 0) != last_asynchronous_pid)))
	{
#if defined (DEBUG)
	  if (i < js.j_firstj && jobs[i])
	    itrace("mark_dead_jobs_as_notified: job %d non-null before js.j_firstj (%d)", i, js.j_firstj);
	  if (i > js.j_lastj && jobs[i])
	    itrace("mark_dead_jobs_as_notified: job %d non-null after js.j_lastj (%d)", i, js.j_lastj);
#endif
	  /* If marking this job as notified would drop us down below
	     child_max, don't mark it so we can keep at least child_max
	     statuses.  XXX -- need to check what Posix actually says
	     about keeping statuses. */
	  if ((ndeadproc -= processes_in_job (i)) <= js.c_childmax)
	    break;
	  jobs[i]->flags |= J_NOTIFIED;
	}
    }

  UNBLOCK_CHILD (oset);
}
warning: parse error {
  register int i, ndead, ndeadproc;
  sigset_t set, oset;

  if (js.j_jobslots == 0)
    return;

  BLOCK_CHILD (set, oset);

  /* If FORCE is non-zero, we don't have to keep CHILD_MAX statuses
     around; just run through the array. */
  if (force)
    {
    /* XXX could use js.j_firstj here */
      for (i = 0; i < js.j_jobslots; i++)
	{
	  if (jobs[i] && DEADJOB (i) && (interactive_shell || (find_last_pid (i, 0) != last_asynchronous_pid)))
	    jobs[i]->flags |= J_NOTIFIED;
	}
      UNBLOCK_CHILD (oset);
      return;
    }

  /* Mark enough dead jobs as notified to keep CHILD_MAX processes left in the
     array with the corresponding not marked as notified.  This is a better
     way to avoid pid aliasing and reuse problems than keeping the POSIX-
     mandated CHILD_MAX jobs around.  delete_job() takes care of keeping the
     bgpids list regulated. */
          
  /* Count the number of dead jobs */
  /* XXX could use js.j_firstj here */
  for (i = ndead = ndeadproc = 0; i < js.j_jobslots; i++)
    {
#if defined (DEBUG)
      if (i < js.j_firstj && jobs[i])
	itrace("mark_dead_jobs_as_notified: job %d non-null before js.j_firstj (%d)", i, js.j_firstj);
      if (i > js.j_lastj && jobs[i])
	itrace("mark_dead_jobs_as_notified: job %d non-null after js.j_lastj (%d)", i, js.j_lastj);
#endif
      if (jobs[i] && DEADJOB (i))
	{
	  ndead++;
	  ndeadproc += processes_in_job (i);
	}
    }

#ifdef DEBUG
  if (ndeadproc != js.c_reaped)
    itrace("mark_dead_jobs_as_notified: ndeadproc (%d) != js.c_reaped (%d)", ndeadproc, js.c_reaped);
  if (ndead != js.j_ndead)
    itrace("mark_dead_jobs_as_notified: ndead (%d) != js.j_ndead (%d)", ndead, js.j_ndead);
#endif

  if (js.c_childmax < 0)
    js.c_childmax = getmaxchild ();
  if (js.c_childmax < 0)
    js.c_childmax = DEFAULT_CHILD_MAX;

  /* Don't do anything if the number of dead processes is less than CHILD_MAX
     and we're not forcing a cleanup. */
  if (ndeadproc <= js.c_childmax)
    {
      UNBLOCK_CHILD (oset);
      return;
    }

#if 0
itrace("mark_dead_jobs_as_notified: child_max = %d ndead = %d ndeadproc = %d", js.c_childmax, ndead, ndeadproc);
#endif

  /* Mark enough dead jobs as notified that we keep CHILD_MAX jobs in
     the list.  This isn't exactly right yet; changes need to be made
     to stop_pipeline so we don't mark the newer jobs after we've
     created CHILD_MAX slots in the jobs array.  This needs to be
     integrated with a way to keep the jobs array from growing without
     bound.  Maybe we wrap back around to 0 after we reach some max
     limit, and there are sufficient job slots free (keep track of total
     size of jobs array (js.j_jobslots) and running count of number of jobs
     in jobs array.  Then keep a job index corresponding to the `oldest job'
     and start this loop there, wrapping around as necessary.  In effect,
     we turn the list into a circular buffer. */
  /* XXX could use js.j_firstj here */
  for (i = 0; i < js.j_jobslots; i++)
    {
      if (jobs[i] && DEADJOB (i) && (interactive_shell || (find_last_pid (i, 0) != last_asynchronous_pid)))
	{
#if defined (DEBUG)
	  if (i < js.j_firstj && jobs[i])
	    itrace("mark_dead_jobs_as_notified: job %d non-null before js.j_firstj (%d)", i, js.j_firstj);
	  if (i > js.j_lastj && jobs[i])
	    itrace("mark_dead_jobs_as_notified: job %d non-null after js.j_lastj (%d)", i, js.j_lastj);
#endif
	  /* If marking this job as notified would drop us down below
	     child_max, don't mark it so we can keep at least child_max
	     statuses.  XXX -- need to check what Posix actually says
	     about keeping statuses. */
	  if ((ndeadproc -= processes_in_job (i)) <= js.c_childmax)
	    break;
	  jobs[i]->flags |= J_NOTIFIED;
	}
    }

  UNBLOCK_CHILD (oset);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\jobs.c:4,041
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\jobs.c:4,163
parsing error 
{
  int old;

  old = job_control;
  job_control = arg;

  /* If we're turning on job control, reset pipeline_pgrp so make_child will
     put new child processes into the right pgrp */
  if (job_control != old && job_control)
    pipeline_pgrp = 0;

  return (old);
}
warning: parse error {
  int old;

  old = job_control;
  job_control = arg;

  /* If we're turning on job control, reset pipeline_pgrp so make_child will
     put new child processes into the right pgrp */
  if (job_control != old && job_control)
    pipeline_pgrp = 0;

  return (old);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\jobs.c:4,165
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\glob\glob.c...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\bashtypes.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\bashansi.h...skip
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\posixdir.h...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\posixstat.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\shmbutil.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\xmalloc.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\filecntl.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\stdc.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\memalloc.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\shell.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\glob\glob.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\glob\strmatch.h...skip
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\glob\glob_loop.c...
parsing error 
static int INTERNAL_GLOB_PATTERN_P __P((const CHAR *));
warning: parse error static int INTERNAL_GLOB_PATTERN_P __P((const CHAR *));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\glob\glob_loop.c:19
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\glob\glob_loop.c:25
parsing error 
{
  register const CHAR *p;
  register CHAR c;
  int bopen;

  p = pattern;
  bopen = 0;

  while ((c = *p++) != L('\0'))
    switch (c)
      {
      case L('?'):
      case L('*'):
	return 1;

      case L('['):      /* Only accept an open brace if there is a close */
	bopen++;        /* brace to match it.  Bracket expressions must be */
	continue;       /* complete, according to Posix.2 */
      case L(']'):
	if (bopen)
	  return 1;
	continue;

      case L('+'):         /* extended matching operators */
      case L('@'):
      case L('!'):
	if (*p == L('('))  /*) */
	  return 1;
	continue;

      case L('\\'):
	if (*p++ == L('\0'))
	  return 0;
      }

  return 0;
}
warning: parse error {
  register const CHAR *p;
  register CHAR c;
  int bopen;

  p = pattern;
  bopen = 0;

  while ((c = *p++) != L('\0'))
    switch (c)
      {
      case L('?'):
      case L('*'):
	return 1;

      case L('['):      /* Only accept an open brace if there is a close */
	bopen++;        /* brace to match it.  Bracket expressions must be */
	continue;       /* complete, according to Posix.2 */
      case L(']'):
	if (bopen)
	  return 1;
	continue;

      case L('+'):         /* extended matching operators */
      case L('@'):
      case L('!'):
	if (*p == L('('))  /*) */
	  return 1;
	continue;

      case L('\\'):
	if (*p++ == L('\0'))
	  return 0;
      }

  return 0;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\glob\glob_loop.c:26
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\glob\glob_loop.c...skip
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\glob\glob.c:140
parsing error 
{
#if HANDLE_MULTIBYTE
  size_t n;
  wchar_t *wpattern;
  int r;

  if (MB_CUR_MAX == 1)
    return (internal_glob_pattern_p ((unsigned char *)pattern));

  /* Convert strings to wide chars, and call the multibyte version. */
  n = xdupmbstowcs (&wpattern, NULL, pattern);
  if (n == (size_t)-1)
    /* Oops.  Invalid multibyte sequence.  Try it as single-byte sequence. */
    return (internal_glob_pattern_p ((unsigned char *)pattern));

  r = internal_glob_wpattern_p (wpattern);
  free (wpattern);

  return r;
#else
  return (internal_glob_pattern_p (pattern));
#endif
}
warning: parse error {
#if HANDLE_MULTIBYTE
  size_t n;
  wchar_t *wpattern;
  int r;

  if (MB_CUR_MAX == 1)
    return (internal_glob_pattern_p ((unsigned char *)pattern));

  /* Convert strings to wide chars, and call the multibyte version. */
  n = xdupmbstowcs (&wpattern, NULL, pattern);
  if (n == (size_t)-1)
    /* Oops.  Invalid multibyte sequence.  Try it as single-byte sequence. */
    return (internal_glob_pattern_p ((unsigned char *)pattern));

  r = internal_glob_wpattern_p (wpattern);
  free (wpattern);

  return r;
#else
  return (internal_glob_pattern_p (pattern));
#endif
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\glob\glob.c:141
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\glob\glob.c:169
parsing error 
{
  /* If a leading dot need not be explicitly matched, and the pattern
     doesn't start with a `.', don't match `.' or `..' */
  if (noglob_dot_filenames == 0 && pat[0] != '.' &&
	(pat[0] != '\\' || pat[1] != '.') &&
	(dname[0] == '.' &&
	  (dname[1] == '\0' || (dname[1] == '.' && dname[2] == '\0'))))
    return 1;

  /* If a dot must be explicity matched, check to see if they do. */
  else if (noglob_dot_filenames && dname[0] == '.' && pat[0] != '.' &&
	(pat[0] != '\\' || pat[1] != '.'))
    return 1;

  return 0;
}
warning: parse error {
  /* If a leading dot need not be explicitly matched, and the pattern
     doesn't start with a `.', don't match `.' or `..' */
  if (noglob_dot_filenames == 0 && pat[0] != '.' &&
	(pat[0] != '\\' || pat[1] != '.') &&
	(dname[0] == '.' &&
	  (dname[1] == '\0' || (dname[1] == '.' && dname[2] == '\0'))))
    return 1;

  /* If a dot must be explicity matched, check to see if they do. */
  else if (noglob_dot_filenames && dname[0] == '.' && pat[0] != '.' &&
	(pat[0] != '\\' || pat[1] != '.'))
    return 1;

  return 0;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\glob\glob.c:173
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\glob\glob.c:234
parsing error 
{
  register int i, j;

  for (i = j = 0; pathname && pathname[i]; )
    {
      if (pathname[i] == '\\')
	i++;

      pathname[j++] = pathname[i++];

      if (pathname[i - 1] == 0)
	break;
    }
  if (pathname)
    pathname[j] = '\0';
}
warning: parse error {
  register int i, j;

  for (i = j = 0; pathname && pathname[i]; )
    {
      if (pathname[i] == '\\')
	i++;

      pathname[j++] = pathname[i++];

      if (pathname[i - 1] == 0)
	break;
    }
  if (pathname)
    pathname[j] = '\0';
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\glob\glob.c:236
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\glob\glob.c:320
parsing error 
{
  struct stat finfo;

/*itrace("glob_testdir: testing %s", dir);*/
  if (stat (dir, &finfo) < 0)
    return (-1);

  if (S_ISDIR (finfo.st_mode) == 0)
    return (-1);

  return (0);
}
warning: parse error {
  struct stat finfo;

/*itrace("glob_testdir: testing %s", dir);*/
  if (stat (dir, &finfo) < 0)
    return (-1);

  if (S_ISDIR (finfo.st_mode) == 0)
    return (-1);

  return (0);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\glob\glob.c:322
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\glob\glob.c:342
parsing error 
{
  char **r, *n;
  int ndirs;
  struct globval *ret, *e, *g;

/*itrace("finddirs: pat = `%s' sdir = `%s' flags = 0x%x", pat, sdir, flags);*/
  e = ret = 0;
  r = glob_vector (pat, sdir, flags);
  if (r == 0 || r[0] == 0)
    {
      if (np)
	*np = 0;
      if (ep)
        *ep = 0;
      if (r && r != &glob_error_return)
	free (r);
      return (struct globval *)0;
    }
  for (ndirs = 0; r[ndirs] != 0; ndirs++)
    {
      g = (struct globval *) malloc (sizeof (struct globval));
      if (g == 0)
	{
	  while (ret)		/* free list built so far */
	    {
	      g = ret->next;
	      free (ret);
	      ret = g;
	    }

	  free (r);
	  if (np)
	    *np = 0;
	  if (ep)
	    *ep = 0;
	  return (&finddirs_error_return);
	}
      if (e == 0)
	e = g;

      g->next = ret;
      ret = g;

      g->name = r[ndirs];
    }

  free (r);
  if (ep)
    *ep = e;
  if (np)
    *np = ndirs;

  return ret;
}
warning: parse error {
  char **r, *n;
  int ndirs;
  struct globval *ret, *e, *g;

/*itrace("finddirs: pat = `%s' sdir = `%s' flags = 0x%x", pat, sdir, flags);*/
  e = ret = 0;
  r = glob_vector (pat, sdir, flags);
  if (r == 0 || r[0] == 0)
    {
      if (np)
	*np = 0;
      if (ep)
        *ep = 0;
      if (r && r != &glob_error_return)
	free (r);
      return (struct globval *)0;
    }
  for (ndirs = 0; r[ndirs] != 0; ndirs++)
    {
      g = (struct globval *) malloc (sizeof (struct globval));
      if (g == 0)
	{
	  while (ret)		/* free list built so far */
	    {
	      g = ret->next;
	      free (ret);
	      ret = g;
	    }

	  free (r);
	  if (np)
	    *np = 0;
	  if (ep)
	    *ep = 0;
	  return (&finddirs_error_return);
	}
      if (e == 0)
	e = g;

      g->next = ret;
      ret = g;

      g->name = r[ndirs];
    }

  free (r);
  if (ep)
    *ep = e;
  if (np)
    *np = ndirs;

  return ret;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\glob\glob.c:348
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\glob\glob.c:421
parsing error 
{
  DIR *d;
  register struct dirent *dp;
  struct globval *lastlink, *e, *dirlist;
  register struct globval *nextlink;
  register char *nextname, *npat, *subdir;
  unsigned int count;
  int lose, skip, ndirs, isdir, sdlen, add_current, patlen;
  register char **name_vector;
  register unsigned int i;
  int mflags;		/* Flags passed to strmatch (). */
  int pflags;		/* flags passed to sh_makepath () */
  int nalloca;
  struct globval *firstmalloc, *tmplink;
  char *convfn;

  lastlink = 0;
  count = lose = skip = add_current = 0;

  firstmalloc = 0;
  nalloca = 0;

/*itrace("glob_vector: pat = `%s' dir = `%s' flags = 0x%x", pat, dir, flags);*/
  /* If PAT is empty, skip the loop, but return one (empty) filename. */
  if (pat == 0 || *pat == '\0')
    {
      if (glob_testdir (dir) < 0)
	return ((char **) &glob_error_return);

      nextlink = (struct globval *)alloca (sizeof (struct globval));
      if (nextlink == NULL)
	return ((char **) NULL);

      nextlink->next = (struct globval *)0;
      nextname = (char *) malloc (1);
      if (nextname == 0)
	lose = 1;
      else
	{
	  lastlink = nextlink;
	  nextlink->name = nextname;
	  nextname[0] = '\0';
	  count = 1;
	}

      skip = 1;
    }

  patlen = strlen (pat);

  /* If the filename pattern (PAT) does not contain any globbing characters,
     we can dispense with reading the directory, and just see if there is
     a filename `DIR/PAT'.  If there is, and we can access it, just make the
     vector to return and bail immediately. */
  if (skip == 0 && glob_pattern_p (pat) == 0)
    {
      int dirlen;
      struct stat finfo;

      if (glob_testdir (dir) < 0)
	return ((char **) &glob_error_return);

      dirlen = strlen (dir);
      nextname = (char *)malloc (dirlen + patlen + 2);
      npat = (char *)malloc (patlen + 1);
      if (nextname == 0 || npat == 0)
	lose = 1;
      else
	{
	  strcpy (npat, pat);
	  dequote_pathname (npat);

	  strcpy (nextname, dir);
	  nextname[dirlen++] = '/';
	  strcpy (nextname + dirlen, npat);

	  if (GLOB_TESTNAME (nextname) >= 0)
	    {
	      free (nextname);
	      nextlink = (struct globval *)alloca (sizeof (struct globval));
	      if (nextlink)
		{
		  nextlink->next = (struct globval *)0;
		  lastlink = nextlink;
		  nextlink->name = npat;
		  count = 1;
		}
	      else
		lose = 1;
	    }
	  else
	    {
	      free (nextname);
	      free (npat);
	    }
	}

      skip = 1;
    }

  if (skip == 0)
    {
      /* Open the directory, punting immediately if we cannot.  If opendir
	 is not robust (i.e., it opens non-directories successfully), test
	 that DIR is a directory and punt if it's not. */
#if defined (OPENDIR_NOT_ROBUST)
      if (glob_testdir (dir) < 0)
	return ((char **) &glob_error_return);
#endif

      d = opendir (dir);
      if (d == NULL)
	return ((char **) &glob_error_return);

      /* Compute the flags that will be passed to strmatch().  We don't
	 need to do this every time through the loop. */
      mflags = (noglob_dot_filenames ? FNM_PERIOD : 0) | FNM_PATHNAME;

#ifdef FNM_CASEFOLD
      if (glob_ignore_case)
	mflags |= FNM_CASEFOLD;
#endif

      if (extended_glob)
	mflags |= FNM_EXTMATCH;

      add_current = ((flags & (GX_ALLDIRS|GX_ADDCURDIR)) == (GX_ALLDIRS|GX_ADDCURDIR));

      /* Scan the directory, finding all names that match.
	 For each name that matches, allocate a struct globval
	 on the stack and store the name in it.
	 Chain those structs together; lastlink is the front of the chain.  */
      while (1)
	{
	  /* Make globbing interruptible in the shell. */
	  if (interrupt_state || terminating_signal)
	    {
	      lose = 1;
	      break;
	    }
	  
	  dp = readdir (d);
	  if (dp == NULL)
	    break;

	  /* If this directory entry is not to be used, try again. */
	  if (REAL_DIR_ENTRY (dp) == 0)
	    continue;

#if 0
	  if (dp->d_name == 0 || *dp->d_name == 0)
	    continue;
#endif

#if HANDLE_MULTIBYTE
	  if (MB_CUR_MAX > 1 && mbskipname (pat, dp->d_name, flags))
	    continue;
	  else
#endif
	  if (skipname (pat, dp->d_name, flags))
	    continue;

	  /* If we're only interested in directories, don't bother with files */
	  if (flags & (GX_MATCHDIRS|GX_ALLDIRS))
	    {
	      pflags = (flags & GX_ALLDIRS) ? MP_RMDOT : 0;
	      if (flags & GX_NULLDIR)
		pflags |= MP_IGNDOT;
	      subdir = sh_makepath (dir, dp->d_name, pflags);
	      isdir = glob_testdir (subdir);
	      if (isdir < 0 && (flags & GX_MATCHDIRS))
		{
		  free (subdir);
		  continue;
		}
	    }

	  if (flags & GX_ALLDIRS)
	    {
	      if (isdir == 0)
		{
		  dirlist = finddirs (pat, subdir, (flags & ~GX_ADDCURDIR), &e, &ndirs);
		  if (dirlist == &finddirs_error_return)
		    {
		      free (subdir);
		      lose = 1;
		      break;
		    }
		  if (ndirs)		/* add recursive directories to list */
		    {
		      if (firstmalloc == 0)
		        firstmalloc = e;
		      e->next = lastlink;
		      lastlink = dirlist;
		      count += ndirs;
		    }
		}

	      nextlink = (struct globval *) malloc (sizeof (struct globval));
	      if (firstmalloc == 0)
		firstmalloc = nextlink;
	      sdlen = strlen (subdir);
	      nextname = (char *) malloc (sdlen + 1);
	      if (nextlink == 0 || nextname == 0)
		{
		  free (subdir);
		  lose = 1;
		  break;
		}
	      nextlink->next = lastlink;
	      lastlink = nextlink;
	      nextlink->name = nextname;
	      bcopy (subdir, nextname, sdlen + 1);
	      free (subdir);
	      ++count;
	      continue;
	    }

	  convfn = fnx_fromfs (dp->d_name, D_NAMLEN (dp));
	  if (strmatch (pat, convfn, mflags) != FNM_NOMATCH)
	    {
	      if (nalloca < ALLOCA_MAX)
		{
		  nextlink = (struct globval *) alloca (sizeof (struct globval));
		  nalloca += sizeof (struct globval);
		}
	      else
		{
		  nextlink = (struct globval *) malloc (sizeof (struct globval));
		  if (firstmalloc == 0)
		    firstmalloc = nextlink;
		}

	      nextname = (char *) malloc (D_NAMLEN (dp) + 1);
	      if (nextlink == 0 || nextname == 0)
		{
		  lose = 1;
		  break;
		}
	      nextlink->next = lastlink;
	      lastlink = nextlink;
	      nextlink->name = nextname;
	      bcopy (dp->d_name, nextname, D_NAMLEN (dp) + 1);
	      ++count;
	    }
	}

      (void) closedir (d);
    }

  /* compat: if GX_ADDCURDIR, add the passed directory also.  Add an empty
     directory name as a placeholder if GX_NULLDIR (in which case the passed
     directory name is "."). */
  if (add_current)
    {
      sdlen = strlen (dir);
      nextname = (char *)malloc (sdlen + 1);
      nextlink = (struct globval *) malloc (sizeof (struct globval));
      if (nextlink == 0 || nextname == 0)
	lose = 1;
      else
	{
	  nextlink->name = nextname;
	  nextlink->next = lastlink;
	  lastlink = nextlink;
	  if (flags & GX_NULLDIR)
	    nextname[0] = '\0';
	  else
	    bcopy (dir, nextname, sdlen + 1);
	  ++count;
	}
    }

  if (lose == 0)
    {
      name_vector = (char **) malloc ((count + 1) * sizeof (char *));
      lose |= name_vector == NULL;
    }

  /* Have we run out of memory?	 */
  if (lose)
    {
      tmplink = 0;

      /* Here free the strings we have got.  */
      while (lastlink)
	{
	  /* Since we build the list in reverse order, the first N entries
	     will be allocated with malloc, if firstmalloc is set, from
	     lastlink to firstmalloc. */
	  if (firstmalloc)
	    {
	      if (lastlink == firstmalloc)
		firstmalloc = 0;
	      tmplink = lastlink;
	    }
	  else
	    tmplink = 0;
	  free (lastlink->name);
	  lastlink = lastlink->next;
	  FREE (tmplink);
	}

      QUIT;

      return ((char **)NULL);
    }

  /* Copy the name pointers from the linked list into the vector.  */
  for (tmplink = lastlink, i = 0; i < count; ++i)
    {
      name_vector[i] = tmplink->name;
      tmplink = tmplink->next;
    }

  name_vector[count] = NULL;

  /* If we allocated some of the struct globvals, free them now. */
  if (firstmalloc)
    {
      tmplink = 0;
      while (lastlink)
	{
	  tmplink = lastlink;
	  if (lastlink == firstmalloc)
	    lastlink = firstmalloc = 0;
	  else
	    lastlink = lastlink->next;
	  free (tmplink);
	}
    }

  return (name_vector);
}
warning: parse error {
  DIR *d;
  register struct dirent *dp;
  struct globval *lastlink, *e, *dirlist;
  register struct globval *nextlink;
  register char *nextname, *npat, *subdir;
  unsigned int count;
  int lose, skip, ndirs, isdir, sdlen, add_current, patlen;
  register char **name_vector;
  register unsigned int i;
  int mflags;		/* Flags passed to strmatch (). */
  int pflags;		/* flags passed to sh_makepath () */
  int nalloca;
  struct globval *firstmalloc, *tmplink;
  char *convfn;

  lastlink = 0;
  count = lose = skip = add_current = 0;

  firstmalloc = 0;
  nalloca = 0;

/*itrace("glob_vector: pat = `%s' dir = `%s' flags = 0x%x", pat, dir, flags);*/
  /* If PAT is empty, skip the loop, but return one (empty) filename. */
  if (pat == 0 || *pat == '\0')
    {
      if (glob_testdir (dir) < 0)
	return ((char **) &glob_error_return);

      nextlink = (struct globval *)alloca (sizeof (struct globval));
      if (nextlink == NULL)
	return ((char **) NULL);

      nextlink->next = (struct globval *)0;
      nextname = (char *) malloc (1);
      if (nextname == 0)
	lose = 1;
      else
	{
	  lastlink = nextlink;
	  nextlink->name = nextname;
	  nextname[0] = '\0';
	  count = 1;
	}

      skip = 1;
    }

  patlen = strlen (pat);

  /* If the filename pattern (PAT) does not contain any globbing characters,
     we can dispense with reading the directory, and just see if there is
     a filename `DIR/PAT'.  If there is, and we can access it, just make the
     vector to return and bail immediately. */
  if (skip == 0 && glob_pattern_p (pat) == 0)
    {
      int dirlen;
      struct stat finfo;

      if (glob_testdir (dir) < 0)
	return ((char **) &glob_error_return);

      dirlen = strlen (dir);
      nextname = (char *)malloc (dirlen + patlen + 2);
      npat = (char *)malloc (patlen + 1);
      if (nextname == 0 || npat == 0)
	lose = 1;
      else
	{
	  strcpy (npat, pat);
	  dequote_pathname (npat);

	  strcpy (nextname, dir);
	  nextname[dirlen++] = '/';
	  strcpy (nextname + dirlen, npat);

	  if (GLOB_TESTNAME (nextname) >= 0)
	    {
	      free (nextname);
	      nextlink = (struct globval *)alloca (sizeof (struct globval));
	      if (nextlink)
		{
		  nextlink->next = (struct globval *)0;
		  lastlink = nextlink;
		  nextlink->name = npat;
		  count = 1;
		}
	      else
		lose = 1;
	    }
	  else
	    {
	      free (nextname);
	      free (npat);
	    }
	}

      skip = 1;
    }

  if (skip == 0)
    {
      /* Open the directory, punting immediately if we cannot.  If opendir
	 is not robust (i.e., it opens non-directories successfully), test
	 that DIR is a directory and punt if it's not. */
#if defined (OPENDIR_NOT_ROBUST)
      if (glob_testdir (dir) < 0)
	return ((char **) &glob_error_return);
#endif

      d = opendir (dir);
      if (d == NULL)
	return ((char **) &glob_error_return);

      /* Compute the flags that will be passed to strmatch().  We don't
	 need to do this every time through the loop. */
      mflags = (noglob_dot_filenames ? FNM_PERIOD : 0) | FNM_PATHNAME;

#ifdef FNM_CASEFOLD
      if (glob_ignore_case)
	mflags |= FNM_CASEFOLD;
#endif

      if (extended_glob)
	mflags |= FNM_EXTMATCH;

      add_current = ((flags & (GX_ALLDIRS|GX_ADDCURDIR)) == (GX_ALLDIRS|GX_ADDCURDIR));

      /* Scan the directory, finding all names that match.
	 For each name that matches, allocate a struct globval
	 on the stack and store the name in it.
	 Chain those structs together; lastlink is the front of the chain.  */
      while (1)
	{
	  /* Make globbing interruptible in the shell. */
	  if (interrupt_state || terminating_signal)
	    {
	      lose = 1;
	      break;
	    }
	  
	  dp = readdir (d);
	  if (dp == NULL)
	    break;

	  /* If this directory entry is not to be used, try again. */
	  if (REAL_DIR_ENTRY (dp) == 0)
	    continue;

#if 0
	  if (dp->d_name == 0 || *dp->d_name == 0)
	    continue;
#endif

#if HANDLE_MULTIBYTE
	  if (MB_CUR_MAX > 1 && mbskipname (pat, dp->d_name, flags))
	    continue;
	  else
#endif
	  if (skipname (pat, dp->d_name, flags))
	    continue;

	  /* If we're only interested in directories, don't bother with files */
	  if (flags & (GX_MATCHDIRS|GX_ALLDIRS))
	    {
	      pflags = (flags & GX_ALLDIRS) ? MP_RMDOT : 0;
	      if (flags & GX_NULLDIR)
		pflags |= MP_IGNDOT;
	      subdir = sh_makepath (dir, dp->d_name, pflags);
	      isdir = glob_testdir (subdir);
	      if (isdir < 0 && (flags & GX_MATCHDIRS))
		{
		  free (subdir);
		  continue;
		}
	    }

	  if (flags & GX_ALLDIRS)
	    {
	      if (isdir == 0)
		{
		  dirlist = finddirs (pat, subdir, (flags & ~GX_ADDCURDIR), &e, &ndirs);
		  if (dirlist == &finddirs_error_return)
		    {
		      free (subdir);
		      lose = 1;
		      break;
		    }
		  if (ndirs)		/* add recursive directories to list */
		    {
		      if (firstmalloc == 0)
		        firstmalloc = e;
		      e->next = lastlink;
		      lastlink = dirlist;
		      count += ndirs;
		    }
		}

	      nextlink = (struct globval *) malloc (sizeof (struct globval));
	      if (firstmalloc == 0)
		firstmalloc = nextlink;
	      sdlen = strlen (subdir);
	      nextname = (char *) malloc (sdlen + 1);
	      if (nextlink == 0 || nextname == 0)
		{
		  free (subdir);
		  lose = 1;
		  break;
		}
	      nextlink->next = lastlink;
	      lastlink = nextlink;
	      nextlink->name = nextname;
	      bcopy (subdir, nextname, sdlen + 1);
	      free (subdir);
	      ++count;
	      continue;
	    }

	  convfn = fnx_fromfs (dp->d_name, D_NAMLEN (dp));
	  if (strmatch (pat, convfn, mflags) != FNM_NOMATCH)
	    {
	      if (nalloca < ALLOCA_MAX)
		{
		  nextlink = (struct globval *) alloca (sizeof (struct globval));
		  nalloca += sizeof (struct globval);
		}
	      else
		{
		  nextlink = (struct globval *) malloc (sizeof (struct globval));
		  if (firstmalloc == 0)
		    firstmalloc = nextlink;
		}

	      nextname = (char *) malloc (D_NAMLEN (dp) + 1);
	      if (nextlink == 0 || nextname == 0)
		{
		  lose = 1;
		  break;
		}
	      nextlink->next = lastlink;
	      lastlink = nextlink;
	      nextlink->name = nextname;
	      bcopy (dp->d_name, nextname, D_NAMLEN (dp) + 1);
	      ++count;
	    }
	}

      (void) closedir (d);
    }

  /* compat: if GX_ADDCURDIR, add the passed directory also.  Add an empty
     directory name as a placeholder if GX_NULLDIR (in which case the passed
     directory name is "."). */
  if (add_current)
    {
      sdlen = strlen (dir);
      nextname = (char *)malloc (sdlen + 1);
      nextlink = (struct globval *) malloc (sizeof (struct globval));
      if (nextlink == 0 || nextname == 0)
	lose = 1;
      else
	{
	  nextlink->name = nextname;
	  nextlink->next = lastlink;
	  lastlink = nextlink;
	  if (flags & GX_NULLDIR)
	    nextname[0] = '\0';
	  else
	    bcopy (dir, nextname, sdlen + 1);
	  ++count;
	}
    }

  if (lose == 0)
    {
      name_vector = (char **) malloc ((count + 1) * sizeof (char *));
      lose |= name_vector == NULL;
    }

  /* Have we run out of memory?	 */
  if (lose)
    {
      tmplink = 0;

      /* Here free the strings we have got.  */
      while (lastlink)
	{
	  /* Since we build the list in reverse order, the first N entries
	     will be allocated with malloc, if firstmalloc is set, from
	     lastlink to firstmalloc. */
	  if (firstmalloc)
	    {
	      if (lastlink == firstmalloc)
		firstmalloc = 0;
	      tmplink = lastlink;
	    }
	  else
	    tmplink = 0;
	  free (lastlink->name);
	  lastlink = lastlink->next;
	  FREE (tmplink);
	}

      QUIT;

      return ((char **)NULL);
    }

  /* Copy the name pointers from the linked list into the vector.  */
  for (tmplink = lastlink, i = 0; i < count; ++i)
    {
      name_vector[i] = tmplink->name;
      tmplink = tmplink->next;
    }

  name_vector[count] = NULL;

  /* If we allocated some of the struct globvals, free them now. */
  if (firstmalloc)
    {
      tmplink = 0;
      while (lastlink)
	{
	  tmplink = lastlink;
	  if (lastlink == firstmalloc)
	    lastlink = firstmalloc = 0;
	  else
	    lastlink = lastlink->next;
	  free (tmplink);
	}
    }

  return (name_vector);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\glob\glob.c:425
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\glob\glob.c:765
parsing error 
{
  register unsigned int i, l;
  int add_slash;
  char **result, *new;
  struct stat sb;

  l = strlen (dir);
  if (l == 0)
    {
      if (flags & GX_MARKDIRS)
	for (i = 0; array[i]; i++)
	  {
	    if ((stat (array[i], &sb) == 0) && S_ISDIR (sb.st_mode))
	      {
		l = strlen (array[i]);
		new = (char *)realloc (array[i], l + 2);
		if (new == 0)
		  return NULL;
		new[l] = '/';
		new[l+1] = '\0';
		array[i] = new;
	      }
	  }
      return (array);
    }

  add_slash = dir[l - 1] != '/';

  i = 0;
  while (array[i] != NULL)
    ++i;

  result = (char **) malloc ((i + 1) * sizeof (char *));
  if (result == NULL)
    return (NULL);

  for (i = 0; array[i] != NULL; i++)
    {
      /* 3 == 1 for NUL, 1 for slash at end of DIR, 1 for GX_MARKDIRS */
      result[i] = (char *) malloc (l + strlen (array[i]) + 3);

      if (result[i] == NULL)
	return (NULL);

      strcpy (result[i], dir);
      if (add_slash)
	result[i][l] = '/';
      strcpy (result[i] + l + add_slash, array[i]);
      if (flags & GX_MARKDIRS)
	{
	  if ((stat (result[i], &sb) == 0) && S_ISDIR (sb.st_mode))
	    {
	      size_t rlen;
	      rlen = strlen (result[i]);
	      result[i][rlen] = '/';
	      result[i][rlen+1] = '\0';
	    }
	}
    }
  result[i] = NULL;

  /* Free the input array.  */
  for (i = 0; array[i] != NULL; i++)
    free (array[i]);
  free ((char *) array);

  return (result);
}
warning: parse error {
  register unsigned int i, l;
  int add_slash;
  char **result, *new;
  struct stat sb;

  l = strlen (dir);
  if (l == 0)
    {
      if (flags & GX_MARKDIRS)
	for (i = 0; array[i]; i++)
	  {
	    if ((stat (array[i], &sb) == 0) && S_ISDIR (sb.st_mode))
	      {
		l = strlen (array[i]);
		new = (char *)realloc (array[i], l + 2);
		if (new == 0)
		  return NULL;
		new[l] = '/';
		new[l+1] = '\0';
		array[i] = new;
	      }
	  }
      return (array);
    }

  add_slash = dir[l - 1] != '/';

  i = 0;
  while (array[i] != NULL)
    ++i;

  result = (char **) malloc ((i + 1) * sizeof (char *));
  if (result == NULL)
    return (NULL);

  for (i = 0; array[i] != NULL; i++)
    {
      /* 3 == 1 for NUL, 1 for slash at end of DIR, 1 for GX_MARKDIRS */
      result[i] = (char *) malloc (l + strlen (array[i]) + 3);

      if (result[i] == NULL)
	return (NULL);

      strcpy (result[i], dir);
      if (add_slash)
	result[i][l] = '/';
      strcpy (result[i] + l + add_slash, array[i]);
      if (flags & GX_MARKDIRS)
	{
	  if ((stat (result[i], &sb) == 0) && S_ISDIR (sb.st_mode))
	    {
	      size_t rlen;
	      rlen = strlen (result[i]);
	      result[i][rlen] = '/';
	      result[i][rlen+1] = '\0';
	    }
	}
    }
  result[i] = NULL;

  /* Free the input array.  */
  for (i = 0; array[i] != NULL; i++)
    free (array[i]);
  free ((char *) array);

  return (result);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\glob\glob.c:768
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\glob\glob.c:843
parsing error 
{
  char **result;
  unsigned int result_size;
  char *directory_name, *filename, *dname;
  unsigned int directory_len;
  int free_dirname;			/* flag */
  int dflags;

  result = (char **) malloc (sizeof (char *));
  result_size = 1;
  if (result == NULL)
    return (NULL);

  result[0] = NULL;

  directory_name = NULL;

  /* Find the filename.  */
  filename = strrchr (pathname, '/');
  if (filename == NULL)
    {
      filename = pathname;
      directory_name = "";
      directory_len = 0;
      free_dirname = 0;
    }
  else
    {
      directory_len = (filename - pathname) + 1;
      directory_name = (char *) malloc (directory_len + 1);

      if (directory_name == 0)		/* allocation failed? */
	return (NULL);

      bcopy (pathname, directory_name, directory_len);
      directory_name[directory_len] = '\0';
      ++filename;
      free_dirname = 1;
    }

  /* If directory_name contains globbing characters, then we
     have to expand the previous levels.  Just recurse. */
  if (glob_pattern_p (directory_name))
    {
      char **directories;
      register unsigned int i;

      dflags = flags & ~GX_MARKDIRS;
      if ((flags & GX_GLOBSTAR) && directory_name[0] == '*' && directory_name[1] == '*' && (directory_name[2] == '/' || directory_name[2] == '\0'))
	dflags |= GX_ALLDIRS|GX_ADDCURDIR;

      if (directory_name[directory_len - 1] == '/')
	directory_name[directory_len - 1] = '\0';

      directories = glob_filename (directory_name, dflags);

      if (free_dirname)
	{
	  free (directory_name);
	  directory_name = NULL;
	}

      if (directories == NULL)
	goto memory_error;
      else if (directories == (char **)&glob_error_return)
	{
	  free ((char *) result);
	  return ((char **) &glob_error_return);
	}
      else if (*directories == NULL)
	{
	  free ((char *) directories);
	  free ((char *) result);
	  return ((char **) &glob_error_return);
	}

      /* We have successfully globbed the preceding directory name.
	 For each name in DIRECTORIES, call glob_vector on it and
	 FILENAME.  Concatenate the results together.  */
      for (i = 0; directories[i] != NULL; ++i)
	{
	  char **temp_results;

	  /* XXX -- we've recursively scanned any directories resulting from
	     a `**', so turn off the flag.  We turn it on again below if
	     filename is `**' */
	  /* Scan directory even on a NULL filename.  That way, `*h/'
	     returns only directories ending in `h', instead of all
	     files ending in `h' with a `/' appended. */
	  dname = directories[i];
	  dflags = flags & ~(GX_MARKDIRS|GX_ALLDIRS|GX_ADDCURDIR);
	  if ((flags & GX_GLOBSTAR) && filename[0] == '*' && filename[1] == '*' && filename[2] == '\0')
	    dflags |= GX_ALLDIRS|GX_ADDCURDIR;
	  if (dname[0] == '\0' && filename[0])
	    {
	      dflags |= GX_NULLDIR;
	      dname = ".";	/* treat null directory name and non-null filename as current directory */
	    }
	  temp_results = glob_vector (filename, dname, dflags);

	  /* Handle error cases. */
	  if (temp_results == NULL)
	    goto memory_error;
	  else if (temp_results == (char **)&glob_error_return)
	    /* This filename is probably not a directory.  Ignore it.  */
	    ;
	  else
	    {
	      char **array;
	      register unsigned int l;

	      /* If we're expanding **, we don't need to glue the directory
		 name to the results; we've already done it in glob_vector */
	      if ((dflags & GX_ALLDIRS) && filename[0] == '*' && filename[1] == '*' && filename[2] == '\0')
		array = temp_results;
	      else
		array = glob_dir_to_array (directories[i], temp_results, flags);
	      l = 0;
	      while (array[l] != NULL)
		++l;

	      result =
		(char **)realloc (result, (result_size + l) * sizeof (char *));

	      if (result == NULL)
		goto memory_error;

	      for (l = 0; array[l] != NULL; ++l)
		result[result_size++ - 1] = array[l];

	      result[result_size - 1] = NULL;

	      /* Note that the elements of ARRAY are not freed.  */
	      if (array != temp_results)
		free ((char *) array);
	    }
	}
      /* Free the directories.  */
      for (i = 0; directories[i]; i++)
	free (directories[i]);

      free ((char *) directories);

      return (result);
    }

  /* If there is only a directory name, return it. */
  if (*filename == '\0')
    {
      result = (char **) realloc ((char *) result, 2 * sizeof (char *));
      if (result == NULL)
	return (NULL);
      /* Handle GX_MARKDIRS here. */
      result[0] = (char *) malloc (directory_len + 1);
      if (result[0] == NULL)
	goto memory_error;
      bcopy (directory_name, result[0], directory_len + 1);
      if (free_dirname)
	free (directory_name);
      result[1] = NULL;
      return (result);
    }
  else
    {
      char **temp_results;

      /* There are no unquoted globbing characters in DIRECTORY_NAME.
	 Dequote it before we try to open the directory since there may
	 be quoted globbing characters which should be treated verbatim. */
      if (directory_len > 0)
	dequote_pathname (directory_name);

      /* We allocated a small array called RESULT, which we won't be using.
	 Free that memory now. */
      free (result);

      /* Just return what glob_vector () returns appended to the
	 directory name. */
      /* If flags & GX_ALLDIRS, we're called recursively */
      dflags = flags & ~GX_MARKDIRS;
      if (directory_len == 0)
	dflags |= GX_NULLDIR;
      if ((flags & GX_GLOBSTAR) && filename[0] == '*' && filename[1] == '*' && filename[2] == '\0')
	{
	  dflags |= GX_ALLDIRS|GX_ADDCURDIR;
#if 0
	  /* If we want all directories (dflags & GX_ALLDIRS) and we're not
	     being called recursively as something like `echo [star][star]/[star].o'
	     ((flags & GX_ALLDIRS) == 0), we want to prevent glob_vector from
	     adding a null directory name to the front of the temp_results
	     array.  We turn off ADDCURDIR if not called recursively and
	     dlen == 0 */
#endif
	  if (directory_len == 0 && (flags & GX_ALLDIRS) == 0)
	    dflags &= ~GX_ADDCURDIR;
	}
      temp_results = glob_vector (filename,
				  (directory_len == 0 ? "." : directory_name),
				  dflags);

      if (temp_results == NULL || temp_results == (char **)&glob_error_return)
	{
	  if (free_dirname)
	    free (directory_name);
	  return (temp_results);
	}

      result = glob_dir_to_array ((dflags & GX_ALLDIRS) ? "" : directory_name, temp_results, flags);
      if (free_dirname)
	free (directory_name);
      return (result);
    }

  /* We get to memory_error if the program has run out of memory, or
     if this is the shell, and we have been interrupted. */
 memory_error:
  if (result != NULL)
    {
      register unsigned int i;
      for (i = 0; result[i] != NULL; ++i)
	free (result[i]);
      free ((char *) result);
    }

  if (free_dirname && directory_name)
    free (directory_name);

  QUIT;

  return (NULL);
}
warning: parse error {
  char **result;
  unsigned int result_size;
  char *directory_name, *filename, *dname;
  unsigned int directory_len;
  int free_dirname;			/* flag */
  int dflags;

  result = (char **) malloc (sizeof (char *));
  result_size = 1;
  if (result == NULL)
    return (NULL);

  result[0] = NULL;

  directory_name = NULL;

  /* Find the filename.  */
  filename = strrchr (pathname, '/');
  if (filename == NULL)
    {
      filename = pathname;
      directory_name = "";
      directory_len = 0;
      free_dirname = 0;
    }
  else
    {
      directory_len = (filename - pathname) + 1;
      directory_name = (char *) malloc (directory_len + 1);

      if (directory_name == 0)		/* allocation failed? */
	return (NULL);

      bcopy (pathname, directory_name, directory_len);
      directory_name[directory_len] = '\0';
      ++filename;
      free_dirname = 1;
    }

  /* If directory_name contains globbing characters, then we
     have to expand the previous levels.  Just recurse. */
  if (glob_pattern_p (directory_name))
    {
      char **directories;
      register unsigned int i;

      dflags = flags & ~GX_MARKDIRS;
      if ((flags & GX_GLOBSTAR) && directory_name[0] == '*' && directory_name[1] == '*' && (directory_name[2] == '/' || directory_name[2] == '\0'))
	dflags |= GX_ALLDIRS|GX_ADDCURDIR;

      if (directory_name[directory_len - 1] == '/')
	directory_name[directory_len - 1] = '\0';

      directories = glob_filename (directory_name, dflags);

      if (free_dirname)
	{
	  free (directory_name);
	  directory_name = NULL;
	}

      if (directories == NULL)
	goto memory_error;
      else if (directories == (char **)&glob_error_return)
	{
	  free ((char *) result);
	  return ((char **) &glob_error_return);
	}
      else if (*directories == NULL)
	{
	  free ((char *) directories);
	  free ((char *) result);
	  return ((char **) &glob_error_return);
	}

      /* We have successfully globbed the preceding directory name.
	 For each name in DIRECTORIES, call glob_vector on it and
	 FILENAME.  Concatenate the results together.  */
      for (i = 0; directories[i] != NULL; ++i)
	{
	  char **temp_results;

	  /* XXX -- we've recursively scanned any directories resulting from
	     a `**', so turn off the flag.  We turn it on again below if
	     filename is `**' */
	  /* Scan directory even on a NULL filename.  That way, `*h/'
	     returns only directories ending in `h', instead of all
	     files ending in `h' with a `/' appended. */
	  dname = directories[i];
	  dflags = flags & ~(GX_MARKDIRS|GX_ALLDIRS|GX_ADDCURDIR);
	  if ((flags & GX_GLOBSTAR) && filename[0] == '*' && filename[1] == '*' && filename[2] == '\0')
	    dflags |= GX_ALLDIRS|GX_ADDCURDIR;
	  if (dname[0] == '\0' && filename[0])
	    {
	      dflags |= GX_NULLDIR;
	      dname = ".";	/* treat null directory name and non-null filename as current directory */
	    }
	  temp_results = glob_vector (filename, dname, dflags);

	  /* Handle error cases. */
	  if (temp_results == NULL)
	    goto memory_error;
	  else if (temp_results == (char **)&glob_error_return)
	    /* This filename is probably not a directory.  Ignore it.  */
	    ;
	  else
	    {
	      char **array;
	      register unsigned int l;

	      /* If we're expanding **, we don't need to glue the directory
		 name to the results; we've already done it in glob_vector */
	      if ((dflags & GX_ALLDIRS) && filename[0] == '*' && filename[1] == '*' && filename[2] == '\0')
		array = temp_results;
	      else
		array = glob_dir_to_array (directories[i], temp_results, flags);
	      l = 0;
	      while (array[l] != NULL)
		++l;

	      result =
		(char **)realloc (result, (result_size + l) * sizeof (char *));

	      if (result == NULL)
		goto memory_error;

	      for (l = 0; array[l] != NULL; ++l)
		result[result_size++ - 1] = array[l];

	      result[result_size - 1] = NULL;

	      /* Note that the elements of ARRAY are not freed.  */
	      if (array != temp_results)
		free ((char *) array);
	    }
	}
      /* Free the directories.  */
      for (i = 0; directories[i]; i++)
	free (directories[i]);

      free ((char *) directories);

      return (result);
    }

  /* If there is only a directory name, return it. */
  if (*filename == '\0')
    {
      result = (char **) realloc ((char *) result, 2 * sizeof (char *));
      if (result == NULL)
	return (NULL);
      /* Handle GX_MARKDIRS here. */
      result[0] = (char *) malloc (directory_len + 1);
      if (result[0] == NULL)
	goto memory_error;
      bcopy (directory_name, result[0], directory_len + 1);
      if (free_dirname)
	free (directory_name);
      result[1] = NULL;
      return (result);
    }
  else
    {
      char **temp_results;

      /* There are no unquoted globbing characters in DIRECTORY_NAME.
	 Dequote it before we try to open the directory since there may
	 be quoted globbing characters which should be treated verbatim. */
      if (directory_len > 0)
	dequote_pathname (directory_name);

      /* We allocated a small array called RESULT, which we won't be using.
	 Free that memory now. */
      free (result);

      /* Just return what glob_vector () returns appended to the
	 directory name. */
      /* If flags & GX_ALLDIRS, we're called recursively */
      dflags = flags & ~GX_MARKDIRS;
      if (directory_len == 0)
	dflags |= GX_NULLDIR;
      if ((flags & GX_GLOBSTAR) && filename[0] == '*' && filename[1] == '*' && filename[2] == '\0')
	{
	  dflags |= GX_ALLDIRS|GX_ADDCURDIR;
#if 0
	  /* If we want all directories (dflags & GX_ALLDIRS) and we're not
	     being called recursively as something like `echo [star][star]/[star].o'
	     ((flags & GX_ALLDIRS) == 0), we want to prevent glob_vector from
	     adding a null directory name to the front of the temp_results
	     array.  We turn off ADDCURDIR if not called recursively and
	     dlen == 0 */
#endif
	  if (directory_len == 0 && (flags & GX_ALLDIRS) == 0)
	    dflags &= ~GX_ADDCURDIR;
	}
      temp_results = glob_vector (filename,
				  (directory_len == 0 ? "." : directory_name),
				  dflags);

      if (temp_results == NULL || temp_results == (char **)&glob_error_return)
	{
	  if (free_dirname)
	    free (directory_name);
	  return (temp_results);
	}

      result = glob_dir_to_array ((dflags & GX_ALLDIRS) ? "" : directory_name, temp_results, flags);
      if (free_dirname)
	free (directory_name);
      return (result);
    }

  /* We get to memory_error if the program has run out of memory, or
     if this is the shell, and we have been interrupted. */
 memory_error:
  if (result != NULL)
    {
      register unsigned int i;
      for (i = 0; result[i] != NULL; ++i)
	free (result[i]);
      free ((char *) result);
    }

  if (free_dirname && directory_name)
    free (directory_name);

  QUIT;

  return (NULL);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\glob\glob.c:846
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\glob\glob_loop.c...skip
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\glob\gmisc.c...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\bashtypes.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\bashansi.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\shmbutil.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\stdc.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\glob\gmisc.c:184
parsing error 
{
  char c;

  if (*string == 0)
    return (0);

  switch (c = *pat++)
    {
    default:
      return (*string == c);
    case '\\':
      return (*string == *pat);
    case '?':
      return (*pat == LPAREN ? 1 : (*string != '\0'));
    case '*':
      return (1);
    case '+':
    case '!':
    case '@':
      return (*pat == LPAREN ? 1 : (*string == c));
    case '[':
      return (*string != '\0');
    }
}
warning: parse error {
  char c;

  if (*string == 0)
    return (0);

  switch (c = *pat++)
    {
    default:
      return (*string == c);
    case '\\':
      return (*string == *pat);
    case '?':
      return (*pat == LPAREN ? 1 : (*string != '\0'));
    case '*':
      return (1);
    case '+':
    case '!':
    case '@':
      return (*pat == LPAREN ? 1 : (*string == c));
    case '[':
      return (*string != '\0');
    }
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\glob\gmisc.c:186
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\glob\gmisc.c:212
parsing error 
{
  char c, *brack;
  int matlen, t, in_cclass, in_collsym, in_equiv;

  if (*pat == 0)
    return (0);

  matlen = in_cclass = in_collsym = in_equiv = 0;
  while (c = *pat++)
    {
      switch (c)
	{
	default:
	  matlen++;
	  break;
	case '\\':
	  if (*pat == 0)
	    return ++matlen;
	  else
	    {
	      matlen++;
	      pat++;
	    }
	  break;
	case '?':
	  if (*pat == LPAREN)
	    return (matlen = -1);		/* XXX for now */
	  else
	    matlen++;
	  break;
	case '*':
	  return (matlen = -1);
	case '+':
	case '!':
	case '@':
	  if (*pat == LPAREN)
	    return (matlen = -1);		/* XXX for now */
	  else
	    matlen++;
	  break;
	case '[':
	  /* scan for ending `]', skipping over embedded [:...:] */
	  brack = pat;
	  c = *pat++;
	  do
	    {
	      if (c == 0)
		{
	          matlen += pat - brack - 1;	/* incremented below */
	          break;
	        }
	      else if (c == '\\')
		{
		  c = *pat++;
		  if (*pat == 0)
		    break;
		}
	      else if (c == '[' && *pat == ':')	/* character class */
		{
		  pat++;
		  in_cclass = 1;
		}
	      else if (in_cclass && c == ':' && *pat == ']')
		{
		  pat++;
		  in_cclass = 0;
		}
	      else if (c == '[' && *pat == '.')	/* collating symbol */
		{
		  pat++;
		  if (*pat == ']')	/* right bracket can appear as collating symbol */
		    pat++;
		  in_collsym = 1;
		}
	      else if (in_collsym && c == '.' && *pat == ']')
		{
		  pat++;
		  in_collsym = 0;
		}
	      else if (c == '[' && *pat == '=')	/* equivalence class */
		{
		  pat++;
		  if (*pat == ']')	/* right bracket can appear as equivalence class */
		    pat++;
		  in_equiv = 1;
		}
	      else if (in_equiv && c == '=' && *pat == ']')
		{
		  pat++;
		  in_equiv = 0;
		}
	    }
	  while ((c = *pat++) != ']');
	  matlen++;		/* bracket expression can only match one char */
	  break;
	}
    }

  return matlen;
}
warning: parse error {
  char c, *brack;
  int matlen, t, in_cclass, in_collsym, in_equiv;

  if (*pat == 0)
    return (0);

  matlen = in_cclass = in_collsym = in_equiv = 0;
  while (c = *pat++)
    {
      switch (c)
	{
	default:
	  matlen++;
	  break;
	case '\\':
	  if (*pat == 0)
	    return ++matlen;
	  else
	    {
	      matlen++;
	      pat++;
	    }
	  break;
	case '?':
	  if (*pat == LPAREN)
	    return (matlen = -1);		/* XXX for now */
	  else
	    matlen++;
	  break;
	case '*':
	  return (matlen = -1);
	case '+':
	case '!':
	case '@':
	  if (*pat == LPAREN)
	    return (matlen = -1);		/* XXX for now */
	  else
	    matlen++;
	  break;
	case '[':
	  /* scan for ending `]', skipping over embedded [:...:] */
	  brack = pat;
	  c = *pat++;
	  do
	    {
	      if (c == 0)
		{
	          matlen += pat - brack - 1;	/* incremented below */
	          break;
	        }
	      else if (c == '\\')
		{
		  c = *pat++;
		  if (*pat == 0)
		    break;
		}
	      else if (c == '[' && *pat == ':')	/* character class */
		{
		  pat++;
		  in_cclass = 1;
		}
	      else if (in_cclass && c == ':' && *pat == ']')
		{
		  pat++;
		  in_cclass = 0;
		}
	      else if (c == '[' && *pat == '.')	/* collating symbol */
		{
		  pat++;
		  if (*pat == ']')	/* right bracket can appear as collating symbol */
		    pat++;
		  in_collsym = 1;
		}
	      else if (in_collsym && c == '.' && *pat == ']')
		{
		  pat++;
		  in_collsym = 0;
		}
	      else if (c == '[' && *pat == '=')	/* equivalence class */
		{
		  pat++;
		  if (*pat == ']')	/* right bracket can appear as equivalence class */
		    pat++;
		  in_equiv = 1;
		}
	      else if (in_equiv && c == '=' && *pat == ']')
		{
		  pat++;
		  in_equiv = 0;
		}
	    }
	  while ((c = *pat++) != ']');
	  matlen++;		/* bracket expression can only match one char */
	  break;
	}
    }

  return matlen;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\glob\gmisc.c:215
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\glob\smatch.c...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\glob\strmatch.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\chartypes.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\bashansi.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\shmbutil.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\xmalloc.h...skip
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\glob\collsyms.h...
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\glob\sm_loop.c...
parsing error 
int FCT __P((CHAR *, CHAR *, int));
warning: parse error int FCT __P((CHAR *, CHAR *, int));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\glob\sm_loop.c:19
parsing error 
static int GMATCH __P((CHAR *, CHAR *, CHAR *, CHAR *, int));
warning: parse error static int GMATCH __P((CHAR *, CHAR *, CHAR *, CHAR *, int));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\glob\sm_loop.c:21
parsing error 
static CHAR *PARSE_COLLSYM __P((CHAR *, INT *));
warning: parse error static CHAR *PARSE_COLLSYM __P((CHAR *, INT *));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\glob\sm_loop.c:22
parsing error 
static CHAR *BRACKMATCH __P((CHAR *, U_CHAR, int));
warning: parse error static CHAR *BRACKMATCH __P((CHAR *, U_CHAR, int));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\glob\sm_loop.c:23
parsing error 
static int EXTMATCH __P((INT, CHAR *, CHAR *, CHAR *, CHAR *, int));
warning: parse error static int EXTMATCH __P((INT, CHAR *, CHAR *, CHAR *, CHAR *, int));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\glob\sm_loop.c:24
parsing error 
static CHAR *PATSCAN __P((CHAR *, CHAR *, INT));
warning: parse error static CHAR *PATSCAN __P((CHAR *, CHAR *, INT));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\glob\sm_loop.c:25
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\glob\sm_loop.c:28
parsing error 
{
  CHAR *se, *pe;

  if (string == 0 || pattern == 0)
    return FNM_NOMATCH;

  se = string + STRLEN ((XCHAR *)string);
  pe = pattern + STRLEN ((XCHAR *)pattern);

  return (GMATCH (string, se, pattern, pe, flags));
}
warning: parse error {
  CHAR *se, *pe;

  if (string == 0 || pattern == 0)
    return FNM_NOMATCH;

  se = string + STRLEN ((XCHAR *)string);
  pe = pattern + STRLEN ((XCHAR *)pattern);

  return (GMATCH (string, se, pattern, pe, flags));
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\glob\sm_loop.c:32
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\glob\sm_loop.c:47
parsing error 
{
  CHAR *p, *n;		/* pattern, string */
  INT c;		/* current pattern character - XXX U_CHAR? */
  INT sc;		/* current string character - XXX U_CHAR? */

  p = pattern;
  n = string;

  if (string == 0 || pattern == 0)
    return FNM_NOMATCH;

#if DEBUG_MATCHING
fprintf(stderr, "gmatch: string = %s; se = %s\n", string, se);
fprintf(stderr, "gmatch: pattern = %s; pe = %s\n", pattern, pe);
#endif

  while (p < pe)
    {
      c = *p++;
      c = FOLD (c);

      sc = n < se ? *n : '\0';

#ifdef EXTENDED_GLOB
      /* EXTMATCH () will handle recursively calling GMATCH, so we can
	 just return what EXTMATCH() returns. */
      if ((flags & FNM_EXTMATCH) && *p == L('(') &&
	  (c == L('+') || c == L('*') || c == L('?') || c == L('@') || c == L('!'))) /* ) */
	{
	  int lflags;
	  /* If we're not matching the start of the string, we're not
	     concerned about the special cases for matching `.' */
	  lflags = (n == string) ? flags : (flags & ~FNM_PERIOD);
	  return (EXTMATCH (c, n, se, p, pe, lflags));
	}
#endif /* EXTENDED_GLOB */

      switch (c)
	{
	case L('?'):		/* Match single character */
	  if (sc == '\0')
	    return FNM_NOMATCH;
	  else if ((flags & FNM_PATHNAME) && sc == L('/'))
	    /* If we are matching a pathname, `?' can never match a `/'. */
	    return FNM_NOMATCH;
	  else if ((flags & FNM_PERIOD) && sc == L('.') &&
		   (n == string || ((flags & FNM_PATHNAME) && n[-1] == L('/'))))
	    /* `?' cannot match a `.' if it is the first character of the
	       string or if it is the first character following a slash and
	       we are matching a pathname. */
	    return FNM_NOMATCH;
	  break;

	case L('\\'):		/* backslash escape removes special meaning */
	  if (p == pe)
	    return FNM_NOMATCH;

	  if ((flags & FNM_NOESCAPE) == 0)
	    {
	      c = *p++;
	      /* A trailing `\' cannot match. */
	      if (p > pe)
		return FNM_NOMATCH;
	      c = FOLD (c);
	    }
	  if (FOLD (sc) != (U_CHAR)c)
	    return FNM_NOMATCH;
	  break;

	case '*':		/* Match zero or more characters */
	  if (p == pe)
	    return 0;
	  
	  if ((flags & FNM_PERIOD) && sc == L('.') &&
	      (n == string || ((flags & FNM_PATHNAME) && n[-1] == L('/'))))
	    /* `*' cannot match a `.' if it is the first character of the
	       string or if it is the first character following a slash and
	       we are matching a pathname. */
	    return FNM_NOMATCH;

	  /* Collapse multiple consecutive `*' and `?', but make sure that
	     one character of the string is consumed for each `?'. */
	  for (c = *p++; (c == L('?') || c == L('*')); c = *p++)
	    {
	      if ((flags & FNM_PATHNAME) && sc == L('/'))
		/* A slash does not match a wildcard under FNM_PATHNAME. */
		return FNM_NOMATCH;
#ifdef EXTENDED_GLOB
	      else if ((flags & FNM_EXTMATCH) && c == L('?') && *p == L('(')) /* ) */
		{
		  CHAR *newn;
		  for (newn = n; newn < se; ++newn)
		    {
		      if (EXTMATCH (c, newn, se, p, pe, flags) == 0)
			return (0);
		    }
		  /* We didn't match.  If we have a `?(...)', that's failure. */
		  return FNM_NOMATCH;
		}
#endif
	      else if (c == L('?'))
		{
		  if (sc == L('\0'))
		    return FNM_NOMATCH;
		  /* One character of the string is consumed in matching
		     this ? wildcard, so *??? won't match if there are
		     fewer than three characters. */
		  n++;
		  sc = n < se ? *n : '\0';
		}

#ifdef EXTENDED_GLOB
	      /* Handle ******(patlist) */
	      if ((flags & FNM_EXTMATCH) && c == L('*') && *p == L('('))  /*)*/
		{
		  CHAR *newn;
		  /* We need to check whether or not the extended glob
		     pattern matches the remainder of the string.
		     If it does, we match the entire pattern. */
		  for (newn = n; newn < se; ++newn)
		    {
		      if (EXTMATCH (c, newn, se, p, pe, flags) == 0)
			return (0);
		    }
		  /* We didn't match the extended glob pattern, but
		     that's OK, since we can match 0 or more occurrences.
		     We need to skip the glob pattern and see if we
		     match the rest of the string. */
		  newn = PATSCAN (p + 1, pe, 0);
		  /* If NEWN is 0, we have an ill-formed pattern. */
		  p = newn ? newn : pe;
		}
#endif
	      if (p == pe)
		break;
	    }

	  /* If we've hit the end of the pattern and the last character of
	     the pattern was handled by the loop above, we've succeeded.
	     Otherwise, we need to match that last character. */
	  if (p == pe && (c == L('?') || c == L('*')))
	    return (0);

	  /* General case, use recursion. */
	  {
	    U_CHAR c1;

	    c1 = ((flags & FNM_NOESCAPE) == 0 && c == L('\\')) ? *p : c;
	    c1 = FOLD (c1);
	    for (--p; n < se; ++n)
	      {
		/* Only call strmatch if the first character indicates a
		   possible match.  We can check the first character if
		   we're not doing an extended glob match. */
		if ((flags & FNM_EXTMATCH) == 0 && c != L('[') && FOLD (*n) != c1) /*]*/
		  continue;

		/* If we're doing an extended glob match and the pattern is not
		   one of the extended glob patterns, we can check the first
		   character. */
		if ((flags & FNM_EXTMATCH) && p[1] != L('(') && /*)*/
		    STRCHR (L("?*+@!"), *p) == 0 && c != L('[') && FOLD (*n) != c1) /*]*/
		  continue;

		/* Otherwise, we just recurse. */
		if (GMATCH (n, se, p, pe, flags & ~FNM_PERIOD) == 0)
		  return (0);
	      }
	    return FNM_NOMATCH;
	  }

	case L('['):
	  {
	    if (sc == L('\0') || n == se)
	      return FNM_NOMATCH;

	    /* A character class cannot match a `.' if it is the first
	       character of the string or if it is the first character
	       following a slash and we are matching a pathname. */
	    if ((flags & FNM_PERIOD) && sc == L('.') &&
		(n == string || ((flags & FNM_PATHNAME) && n[-1] == L('/'))))
	      return (FNM_NOMATCH);

	    p = BRACKMATCH (p, sc, flags);
	    if (p == 0)
	      return FNM_NOMATCH;
	  }
	  break;

	default:
	  if ((U_CHAR)c != FOLD (sc))
	    return (FNM_NOMATCH);
	}

      ++n;
    }

  if (n == se)
    return (0);

  if ((flags & FNM_LEADING_DIR) && *n == L('/'))
    /* The FNM_LEADING_DIR flag says that "foo*" matches "foobar/frobozz".  */
    return 0;
	  
  return (FNM_NOMATCH);
}
warning: parse error {
  CHAR *p, *n;		/* pattern, string */
  INT c;		/* current pattern character - XXX U_CHAR? */
  INT sc;		/* current string character - XXX U_CHAR? */

  p = pattern;
  n = string;

  if (string == 0 || pattern == 0)
    return FNM_NOMATCH;

#if DEBUG_MATCHING
fprintf(stderr, "gmatch: string = %s; se = %s\n", string, se);
fprintf(stderr, "gmatch: pattern = %s; pe = %s\n", pattern, pe);
#endif

  while (p < pe)
    {
      c = *p++;
      c = FOLD (c);

      sc = n < se ? *n : '\0';

#ifdef EXTENDED_GLOB
      /* EXTMATCH () will handle recursively calling GMATCH, so we can
	 just return what EXTMATCH() returns. */
      if ((flags & FNM_EXTMATCH) && *p == L('(') &&
	  (c == L('+') || c == L('*') || c == L('?') || c == L('@') || c == L('!'))) /* ) */
	{
	  int lflags;
	  /* If we're not matching the start of the string, we're not
	     concerned about the special cases for matching `.' */
	  lflags = (n == string) ? flags : (flags & ~FNM_PERIOD);
	  return (EXTMATCH (c, n, se, p, pe, lflags));
	}
#endif /* EXTENDED_GLOB */

      switch (c)
	{
	case L('?'):		/* Match single character */
	  if (sc == '\0')
	    return FNM_NOMATCH;
	  else if ((flags & FNM_PATHNAME) && sc == L('/'))
	    /* If we are matching a pathname, `?' can never match a `/'. */
	    return FNM_NOMATCH;
	  else if ((flags & FNM_PERIOD) && sc == L('.') &&
		   (n == string || ((flags & FNM_PATHNAME) && n[-1] == L('/'))))
	    /* `?' cannot match a `.' if it is the first character of the
	       string or if it is the first character following a slash and
	       we are matching a pathname. */
	    return FNM_NOMATCH;
	  break;

	case L('\\'):		/* backslash escape removes special meaning */
	  if (p == pe)
	    return FNM_NOMATCH;

	  if ((flags & FNM_NOESCAPE) == 0)
	    {
	      c = *p++;
	      /* A trailing `\' cannot match. */
	      if (p > pe)
		return FNM_NOMATCH;
	      c = FOLD (c);
	    }
	  if (FOLD (sc) != (U_CHAR)c)
	    return FNM_NOMATCH;
	  break;

	case '*':		/* Match zero or more characters */
	  if (p == pe)
	    return 0;
	  
	  if ((flags & FNM_PERIOD) && sc == L('.') &&
	      (n == string || ((flags & FNM_PATHNAME) && n[-1] == L('/'))))
	    /* `*' cannot match a `.' if it is the first character of the
	       string or if it is the first character following a slash and
	       we are matching a pathname. */
	    return FNM_NOMATCH;

	  /* Collapse multiple consecutive `*' and `?', but make sure that
	     one character of the string is consumed for each `?'. */
	  for (c = *p++; (c == L('?') || c == L('*')); c = *p++)
	    {
	      if ((flags & FNM_PATHNAME) && sc == L('/'))
		/* A slash does not match a wildcard under FNM_PATHNAME. */
		return FNM_NOMATCH;
#ifdef EXTENDED_GLOB
	      else if ((flags & FNM_EXTMATCH) && c == L('?') && *p == L('(')) /* ) */
		{
		  CHAR *newn;
		  for (newn = n; newn < se; ++newn)
		    {
		      if (EXTMATCH (c, newn, se, p, pe, flags) == 0)
			return (0);
		    }
		  /* We didn't match.  If we have a `?(...)', that's failure. */
		  return FNM_NOMATCH;
		}
#endif
	      else if (c == L('?'))
		{
		  if (sc == L('\0'))
		    return FNM_NOMATCH;
		  /* One character of the string is consumed in matching
		     this ? wildcard, so *??? won't match if there are
		     fewer than three characters. */
		  n++;
		  sc = n < se ? *n : '\0';
		}

#ifdef EXTENDED_GLOB
	      /* Handle ******(patlist) */
	      if ((flags & FNM_EXTMATCH) && c == L('*') && *p == L('('))  /*)*/
		{
		  CHAR *newn;
		  /* We need to check whether or not the extended glob
		     pattern matches the remainder of the string.
		     If it does, we match the entire pattern. */
		  for (newn = n; newn < se; ++newn)
		    {
		      if (EXTMATCH (c, newn, se, p, pe, flags) == 0)
			return (0);
		    }
		  /* We didn't match the extended glob pattern, but
		     that's OK, since we can match 0 or more occurrences.
		     We need to skip the glob pattern and see if we
		     match the rest of the string. */
		  newn = PATSCAN (p + 1, pe, 0);
		  /* If NEWN is 0, we have an ill-formed pattern. */
		  p = newn ? newn : pe;
		}
#endif
	      if (p == pe)
		break;
	    }

	  /* If we've hit the end of the pattern and the last character of
	     the pattern was handled by the loop above, we've succeeded.
	     Otherwise, we need to match that last character. */
	  if (p == pe && (c == L('?') || c == L('*')))
	    return (0);

	  /* General case, use recursion. */
	  {
	    U_CHAR c1;

	    c1 = ((flags & FNM_NOESCAPE) == 0 && c == L('\\')) ? *p : c;
	    c1 = FOLD (c1);
	    for (--p; n < se; ++n)
	      {
		/* Only call strmatch if the first character indicates a
		   possible match.  We can check the first character if
		   we're not doing an extended glob match. */
		if ((flags & FNM_EXTMATCH) == 0 && c != L('[') && FOLD (*n) != c1) /*]*/
		  continue;

		/* If we're doing an extended glob match and the pattern is not
		   one of the extended glob patterns, we can check the first
		   character. */
		if ((flags & FNM_EXTMATCH) && p[1] != L('(') && /*)*/
		    STRCHR (L("?*+@!"), *p) == 0 && c != L('[') && FOLD (*n) != c1) /*]*/
		  continue;

		/* Otherwise, we just recurse. */
		if (GMATCH (n, se, p, pe, flags & ~FNM_PERIOD) == 0)
		  return (0);
	      }
	    return FNM_NOMATCH;
	  }

	case L('['):
	  {
	    if (sc == L('\0') || n == se)
	      return FNM_NOMATCH;

	    /* A character class cannot match a `.' if it is the first
	       character of the string or if it is the first character
	       following a slash and we are matching a pathname. */
	    if ((flags & FNM_PERIOD) && sc == L('.') &&
		(n == string || ((flags & FNM_PATHNAME) && n[-1] == L('/'))))
	      return (FNM_NOMATCH);

	    p = BRACKMATCH (p, sc, flags);
	    if (p == 0)
	      return FNM_NOMATCH;
	  }
	  break;

	default:
	  if ((U_CHAR)c != FOLD (sc))
	    return (FNM_NOMATCH);
	}

      ++n;
    }

  if (n == se)
    return (0);

  if ((flags & FNM_LEADING_DIR) && *n == L('/'))
    /* The FNM_LEADING_DIR flag says that "foo*" matches "foobar/frobozz".  */
    return 0;
	  
  return (FNM_NOMATCH);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\glob\sm_loop.c:51
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\glob\sm_loop.c:262
parsing error 
{
  register int pc;
  INT val;

  p++;				/* move past the `.' */
	  
  for (pc = 0; p[pc]; pc++)
    if (p[pc] == L('.') && p[pc+1] == L(']'))
      break;
   val = COLLSYM (p, pc);
   if (vp)
     *vp = val;
   return (p + pc + 2);
}
warning: parse error {
  register int pc;
  INT val;

  p++;				/* move past the `.' */
	  
  for (pc = 0; p[pc]; pc++)
    if (p[pc] == L('.') && p[pc+1] == L(']'))
      break;
   val = COLLSYM (p, pc);
   if (vp)
     *vp = val;
   return (p + pc + 2);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\glob\sm_loop.c:265
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\glob\sm_loop.c:285
parsing error 
{
  register CHAR cstart, cend, c;
  register int not;    /* Nonzero if the sense of the character class is inverted.  */
  int brcnt;
  INT pc;
  CHAR *savep;

  test = FOLD (test);

  savep = p;

  /* POSIX.2 3.13.1 says that an exclamation mark (`!') shall replace the
     circumflex (`^') in its role in a `nonmatching list'.  A bracket
     expression starting with an unquoted circumflex character produces
     unspecified results.  This implementation treats the two identically. */
  if (not = (*p == L('!') || *p == L('^')))
    ++p;

  c = *p++;
  for (;;)
    {
      /* Initialize cstart and cend in case `-' is the last
	 character of the pattern. */
      cstart = cend = c;

      /* POSIX.2 equivalence class:  [=c=].  See POSIX.2 2.8.3.2.  Find
	 the end of the equivalence class, move the pattern pointer past
	 it, and check for equivalence.  XXX - this handles only
	 single-character equivalence classes, which is wrong, or at
	 least incomplete. */
      if (c == L('[') && *p == L('=') && p[2] == L('=') && p[3] == L(']'))
	{
	  pc = FOLD (p[1]);
	  p += 4;
	  if (COLLEQUIV (test, pc))
	    {
/*[*/	      /* Move past the closing `]', since the first thing we do at
		 the `matched:' label is back p up one. */
	      p++;
	      goto matched;
	    }
	  else
	    {
	      c = *p++;
	      if (c == L('\0'))
		return ((test == L('[')) ? savep : (CHAR *)0); /*]*/
	      c = FOLD (c);
	      continue;
	    }
	}

      /* POSIX.2 character class expression.  See POSIX.2 2.8.3.2. */
      if (c == L('[') && *p == L(':'))
	{
	  CHAR *close, *ccname;

	  pc = 0;	/* make sure invalid char classes don't match. */
	  /* Find end of character class name */
	  for (close = p + 1; *close != '\0'; close++)
	    if (*close == L(':') && *(close+1) == L(']'))
	      break;

	  if (*close != L('\0'))
	    {
	      ccname = (CHAR *)malloc ((close - p) * sizeof (CHAR));
	      if (ccname == 0)
		pc = 0;
	      else
		{
		  bcopy (p + 1, ccname, (close - p - 1) * sizeof (CHAR));
		  *(ccname + (close - p - 1)) = L('\0');
		  pc = IS_CCLASS (test, (XCHAR *)ccname);
		}
	      if (pc == -1)
		pc = 0;
	      else
		p = close + 2;

	      free (ccname);
	    }
	    
	  if (pc)
	    {
/*[*/	      /* Move past the closing `]', since the first thing we do at
		 the `matched:' label is back p up one. */
	      p++;
	      goto matched;
	    }
	  else
	    {
	      /* continue the loop here, since this expression can't be
		 the first part of a range expression. */
	      c = *p++;
	      if (c == L('\0'))
		return ((test == L('[')) ? savep : (CHAR *)0);
	      else if (c == L(']'))
		break;
	      c = FOLD (c);
	      continue;
	    }
	}
 
      /* POSIX.2 collating symbols.  See POSIX.2 2.8.3.2.  Find the end of
	 the symbol name, make sure it is terminated by `.]', translate
	 the name to a character using the external table, and do the
	 comparison. */
      if (c == L('[') && *p == L('.'))
	{
	  p = PARSE_COLLSYM (p, &pc);
	  /* An invalid collating symbol cannot be the first point of a
	     range.  If it is, we set cstart to one greater than `test',
	     so any comparisons later will fail. */
	  cstart = (pc == INVALID) ? test + 1 : pc;
	}

      if (!(flags & FNM_NOESCAPE) && c == L('\\'))
	{
	  if (*p == '\0')
	    return (CHAR *)0;
	  cstart = cend = *p++;
	}

      cstart = cend = FOLD (cstart);

      /* POSIX.2 2.8.3.1.2 says: `An expression containing a `[' that
	 is not preceded by a backslash and is not part of a bracket
	 expression produces undefined results.'  This implementation
	 treats the `[' as just a character to be matched if there is
	 not a closing `]'. */
      if (c == L('\0'))
	return ((test == L('[')) ? savep : (CHAR *)0);

      c = *p++;
      c = FOLD (c);

      if ((flags & FNM_PATHNAME) && c == L('/'))
	/* [/] can never match when matching a pathname.  */
	return (CHAR *)0;

      /* This introduces a range, unless the `-' is the last
	 character of the class.  Find the end of the range
	 and move past it. */
      if (c == L('-') && *p != L(']'))
	{
	  cend = *p++;
	  if (!(flags & FNM_NOESCAPE) && cend == L('\\'))
	    cend = *p++;
	  if (cend == L('\0'))
	    return (CHAR *)0;
	  if (cend == L('[') && *p == L('.'))
	    {
	      p = PARSE_COLLSYM (p, &pc);
	      /* An invalid collating symbol cannot be the second part of a
		 range expression.  If we get one, we set cend to one fewer
		 than the test character to make sure the range test fails. */
	      cend = (pc == INVALID) ? test - 1 : pc;
	    }
	  cend = FOLD (cend);

	  c = *p++;

	  /* POSIX.2 2.8.3.2:  ``The ending range point shall collate
	     equal to or higher than the starting range point; otherwise
	     the expression shall be treated as invalid.''  Note that this
	     applies to only the range expression; the rest of the bracket
	     expression is still checked for matches. */
	  if (RANGECMP (cstart, cend) > 0)
	    {
	      if (c == L(']'))
		break;
	      c = FOLD (c);
	      continue;
	    }
	}

      if (RANGECMP (test, cstart) >= 0 && RANGECMP (test, cend) <= 0)
	goto matched;

      if (c == L(']'))
	break;
    }
  /* No match. */
  return (!not ? (CHAR *)0 : p);

matched:
  /* Skip the rest of the [...] that already matched.  */
  c = *--p;
  brcnt = 1;
  while (brcnt > 0)
    {
      /* A `[' without a matching `]' is just another character to match. */
      if (c == L('\0'))
	return ((test == L('[')) ? savep : (CHAR *)0);

      c = *p++;
      if (c == L('[') && (*p == L('=') || *p == L(':') || *p == L('.')))
	brcnt++;
      else if (c == L(']'))
	brcnt--;
      else if (!(flags & FNM_NOESCAPE) && c == L('\\'))
	{
	  if (*p == '\0')
	    return (CHAR *)0;
	  /* XXX 1003.2d11 is unclear if this is right. */
	  ++p;
	}
    }
  return (not ? (CHAR *)0 : p);
}
warning: parse error {
  register CHAR cstart, cend, c;
  register int not;    /* Nonzero if the sense of the character class is inverted.  */
  int brcnt;
  INT pc;
  CHAR *savep;

  test = FOLD (test);

  savep = p;

  /* POSIX.2 3.13.1 says that an exclamation mark (`!') shall replace the
     circumflex (`^') in its role in a `nonmatching list'.  A bracket
     expression starting with an unquoted circumflex character produces
     unspecified results.  This implementation treats the two identically. */
  if (not = (*p == L('!') || *p == L('^')))
    ++p;

  c = *p++;
  for (;;)
    {
      /* Initialize cstart and cend in case `-' is the last
	 character of the pattern. */
      cstart = cend = c;

      /* POSIX.2 equivalence class:  [=c=].  See POSIX.2 2.8.3.2.  Find
	 the end of the equivalence class, move the pattern pointer past
	 it, and check for equivalence.  XXX - this handles only
	 single-character equivalence classes, which is wrong, or at
	 least incomplete. */
      if (c == L('[') && *p == L('=') && p[2] == L('=') && p[3] == L(']'))
	{
	  pc = FOLD (p[1]);
	  p += 4;
	  if (COLLEQUIV (test, pc))
	    {
/*[*/	      /* Move past the closing `]', since the first thing we do at
		 the `matched:' label is back p up one. */
	      p++;
	      goto matched;
	    }
	  else
	    {
	      c = *p++;
	      if (c == L('\0'))
		return ((test == L('[')) ? savep : (CHAR *)0); /*]*/
	      c = FOLD (c);
	      continue;
	    }
	}

      /* POSIX.2 character class expression.  See POSIX.2 2.8.3.2. */
      if (c == L('[') && *p == L(':'))
	{
	  CHAR *close, *ccname;

	  pc = 0;	/* make sure invalid char classes don't match. */
	  /* Find end of character class name */
	  for (close = p + 1; *close != '\0'; close++)
	    if (*close == L(':') && *(close+1) == L(']'))
	      break;

	  if (*close != L('\0'))
	    {
	      ccname = (CHAR *)malloc ((close - p) * sizeof (CHAR));
	      if (ccname == 0)
		pc = 0;
	      else
		{
		  bcopy (p + 1, ccname, (close - p - 1) * sizeof (CHAR));
		  *(ccname + (close - p - 1)) = L('\0');
		  pc = IS_CCLASS (test, (XCHAR *)ccname);
		}
	      if (pc == -1)
		pc = 0;
	      else
		p = close + 2;

	      free (ccname);
	    }
	    
	  if (pc)
	    {
/*[*/	      /* Move past the closing `]', since the first thing we do at
		 the `matched:' label is back p up one. */
	      p++;
	      goto matched;
	    }
	  else
	    {
	      /* continue the loop here, since this expression can't be
		 the first part of a range expression. */
	      c = *p++;
	      if (c == L('\0'))
		return ((test == L('[')) ? savep : (CHAR *)0);
	      else if (c == L(']'))
		break;
	      c = FOLD (c);
	      continue;
	    }
	}
 
      /* POSIX.2 collating symbols.  See POSIX.2 2.8.3.2.  Find the end of
	 the symbol name, make sure it is terminated by `.]', translate
	 the name to a character using the external table, and do the
	 comparison. */
      if (c == L('[') && *p == L('.'))
	{
	  p = PARSE_COLLSYM (p, &pc);
	  /* An invalid collating symbol cannot be the first point of a
	     range.  If it is, we set cstart to one greater than `test',
	     so any comparisons later will fail. */
	  cstart = (pc == INVALID) ? test + 1 : pc;
	}

      if (!(flags & FNM_NOESCAPE) && c == L('\\'))
	{
	  if (*p == '\0')
	    return (CHAR *)0;
	  cstart = cend = *p++;
	}

      cstart = cend = FOLD (cstart);

      /* POSIX.2 2.8.3.1.2 says: `An expression containing a `[' that
	 is not preceded by a backslash and is not part of a bracket
	 expression produces undefined results.'  This implementation
	 treats the `[' as just a character to be matched if there is
	 not a closing `]'. */
      if (c == L('\0'))
	return ((test == L('[')) ? savep : (CHAR *)0);

      c = *p++;
      c = FOLD (c);

      if ((flags & FNM_PATHNAME) && c == L('/'))
	/* [/] can never match when matching a pathname.  */
	return (CHAR *)0;

      /* This introduces a range, unless the `-' is the last
	 character of the class.  Find the end of the range
	 and move past it. */
      if (c == L('-') && *p != L(']'))
	{
	  cend = *p++;
	  if (!(flags & FNM_NOESCAPE) && cend == L('\\'))
	    cend = *p++;
	  if (cend == L('\0'))
	    return (CHAR *)0;
	  if (cend == L('[') && *p == L('.'))
	    {
	      p = PARSE_COLLSYM (p, &pc);
	      /* An invalid collating symbol cannot be the second part of a
		 range expression.  If we get one, we set cend to one fewer
		 than the test character to make sure the range test fails. */
	      cend = (pc == INVALID) ? test - 1 : pc;
	    }
	  cend = FOLD (cend);

	  c = *p++;

	  /* POSIX.2 2.8.3.2:  ``The ending range point shall collate
	     equal to or higher than the starting range point; otherwise
	     the expression shall be treated as invalid.''  Note that this
	     applies to only the range expression; the rest of the bracket
	     expression is still checked for matches. */
	  if (RANGECMP (cstart, cend) > 0)
	    {
	      if (c == L(']'))
		break;
	      c = FOLD (c);
	      continue;
	    }
	}

      if (RANGECMP (test, cstart) >= 0 && RANGECMP (test, cend) <= 0)
	goto matched;

      if (c == L(']'))
	break;
    }
  /* No match. */
  return (!not ? (CHAR *)0 : p);

matched:
  /* Skip the rest of the [...] that already matched.  */
  c = *--p;
  brcnt = 1;
  while (brcnt > 0)
    {
      /* A `[' without a matching `]' is just another character to match. */
      if (c == L('\0'))
	return ((test == L('[')) ? savep : (CHAR *)0);

      c = *p++;
      if (c == L('[') && (*p == L('=') || *p == L(':') || *p == L('.')))
	brcnt++;
      else if (c == L(']'))
	brcnt--;
      else if (!(flags & FNM_NOESCAPE) && c == L('\\'))
	{
	  if (*p == '\0')
	    return (CHAR *)0;
	  /* XXX 1003.2d11 is unclear if this is right. */
	  ++p;
	}
    }
  return (not ? (CHAR *)0 : p);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\glob\sm_loop.c:290
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\glob\sm_loop.c...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\glob\smatch.c:95
parsing error 
{
  register struct _collsym *csp;
  char *x;

  x = (char *)s;
  for (csp = posix_collsyms; csp->name; csp++)
    {
      if (STREQN(csp->name, x, len) && csp->name[len] == '\0')
	return (csp->code);
    }
  if (len == 1)
    return s[0];
  return INVALID;
}
warning: parse error {
  register struct _collsym *csp;
  char *x;

  x = (char *)s;
  for (csp = posix_collsyms; csp->name; csp++)
    {
      if (STREQN(csp->name, x, len) && csp->name[len] == '\0')
	return (csp->code);
    }
  if (len == 1)
    return s[0];
  return INVALID;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\glob\smatch.c:98
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\glob\smatch.c:135
parsing error 
{
  enum char_class char_class = CC_NO_CLASS;
  int i, result;

  for (i = 1; i < N_CHAR_CLASS; i++)
    {
      if (STREQ (name, cclass_name[i]))
	{
	  char_class = (enum char_class)i;
	  break;
	}
    }

  if (char_class == 0)
    return -1;

  switch (char_class)
    {
      case CC_ASCII:
	result = isascii (c);
	break;
      case CC_ALNUM:
	result = ISALNUM (c);
	break;
      case CC_ALPHA:
	result = ISALPHA (c);
	break;
      case CC_BLANK:  
	result = ISBLANK (c);
	break;
      case CC_CNTRL:
	result = ISCNTRL (c);
	break;
      case CC_DIGIT:
	result = ISDIGIT (c);
	break;
      case CC_GRAPH:
	result = ISGRAPH (c);
	break;
      case CC_LOWER:
	result = ISLOWER (c);
	break;
      case CC_PRINT: 
	result = ISPRINT (c);
	break;
      case CC_PUNCT:
	result = ISPUNCT (c);
	break;
      case CC_SPACE:
	result = ISSPACE (c);
	break;
      case CC_UPPER:
	result = ISUPPER (c);
	break;
      case CC_WORD:
        result = (ISALNUM (c) || c == '_');
	break;
      case CC_XDIGIT:
	result = ISXDIGIT (c);
	break;
      default:
	result = -1;
	break;
    }

  return result;  
}
warning: parse error {
  enum char_class char_class = CC_NO_CLASS;
  int i, result;

  for (i = 1; i < N_CHAR_CLASS; i++)
    {
      if (STREQ (name, cclass_name[i]))
	{
	  char_class = (enum char_class)i;
	  break;
	}
    }

  if (char_class == 0)
    return -1;

  switch (char_class)
    {
      case CC_ASCII:
	result = isascii (c);
	break;
      case CC_ALNUM:
	result = ISALNUM (c);
	break;
      case CC_ALPHA:
	result = ISALPHA (c);
	break;
      case CC_BLANK:  
	result = ISBLANK (c);
	break;
      case CC_CNTRL:
	result = ISCNTRL (c);
	break;
      case CC_DIGIT:
	result = ISDIGIT (c);
	break;
      case CC_GRAPH:
	result = ISGRAPH (c);
	break;
      case CC_LOWER:
	result = ISLOWER (c);
	break;
      case CC_PRINT: 
	result = ISPRINT (c);
	break;
      case CC_PUNCT:
	result = ISPUNCT (c);
	break;
      case CC_SPACE:
	result = ISSPACE (c);
	break;
      case CC_UPPER:
	result = ISUPPER (c);
	break;
      case CC_WORD:
        result = (ISALNUM (c) || c == '_');
	break;
      case CC_XDIGIT:
	result = ISXDIGIT (c);
	break;
      default:
	result = -1;
	break;
    }

  return result;  
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\glob\smatch.c:138
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\glob\smatch.c:361
parsing error 
{
#if HANDLE_MULTIBYTE
  int ret;
  size_t n;
  wchar_t *wpattern, *wstring;
  size_t plen, slen, mplen, mslen;

#if 0
  plen = strlen (pattern);
  mplen = mbstrlen (pattern);
  if (plen == mplen && strlen (string) == mbstrlen (string))
#else
  if (mbsmbchar (string) == 0 && mbsmbchar (pattern) == 0)
#endif
    return (internal_strmatch ((unsigned char *)pattern, (unsigned char *)string, flags));

  if (MB_CUR_MAX == 1)
    return (internal_strmatch ((unsigned char *)pattern, (unsigned char *)string, flags));

  n = xdupmbstowcs (&wpattern, NULL, pattern);
  if (n == (size_t)-1 || n == (size_t)-2)
    return (internal_strmatch ((unsigned char *)pattern, (unsigned char *)string, flags));

  n = xdupmbstowcs (&wstring, NULL, string);
  if (n == (size_t)-1 || n == (size_t)-2)
    {
      free (wpattern);
      return (internal_strmatch ((unsigned char *)pattern, (unsigned char *)string, flags));
    }

  ret = internal_wstrmatch (wpattern, wstring, flags);

  free (wpattern);
  free (wstring);

  return ret;
#else
  return (internal_strmatch ((unsigned char *)pattern, (unsigned char *)string, flags));
#endif /* !HANDLE_MULTIBYTE */
}
warning: parse error {
#if HANDLE_MULTIBYTE
  int ret;
  size_t n;
  wchar_t *wpattern, *wstring;
  size_t plen, slen, mplen, mslen;

#if 0
  plen = strlen (pattern);
  mplen = mbstrlen (pattern);
  if (plen == mplen && strlen (string) == mbstrlen (string))
#else
  if (mbsmbchar (string) == 0 && mbsmbchar (pattern) == 0)
#endif
    return (internal_strmatch ((unsigned char *)pattern, (unsigned char *)string, flags));

  if (MB_CUR_MAX == 1)
    return (internal_strmatch ((unsigned char *)pattern, (unsigned char *)string, flags));

  n = xdupmbstowcs (&wpattern, NULL, pattern);
  if (n == (size_t)-1 || n == (size_t)-2)
    return (internal_strmatch ((unsigned char *)pattern, (unsigned char *)string, flags));

  n = xdupmbstowcs (&wstring, NULL, string);
  if (n == (size_t)-1 || n == (size_t)-2)
    {
      free (wpattern);
      return (internal_strmatch ((unsigned char *)pattern, (unsigned char *)string, flags));
    }

  ret = internal_wstrmatch (wpattern, wstring, flags);

  free (wpattern);
  free (wstring);

  return ret;
#else
  return (internal_strmatch ((unsigned char *)pattern, (unsigned char *)string, flags));
#endif /* !HANDLE_MULTIBYTE */
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\glob\smatch.c:365
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\glob\sm_loop.c...skip
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\glob\strmatch.c...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\stdc.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\glob\strmatch.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\glob\strmatch.c:33
parsing error 
{
  if (string == 0 || pattern == 0)
    return FNM_NOMATCH;

  return (xstrmatch (pattern, string, flags));
}
warning: parse error {
  if (string == 0 || pattern == 0)
    return FNM_NOMATCH;

  return (xstrmatch (pattern, string, flags));
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\glob\strmatch.c:37
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\glob\xmbsrtowcs.c...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\bashansi.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\shmbutil.h...skip
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\intl\bindtextdom.c...
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\intl\gettextP.h...
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\intl\loadinfo.h...
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\intl\gmo.h...
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\intl\gettextP.h:73
parsing error 
{
  return (i << 24) | ((i & 0xff00) << 8) | ((i >> 8) & 0xff00) | (i >> 24);
}
warning: parse error {
  return (i << 24) | ((i & 0xff00) << 8) | ((i >> 8) & 0xff00) | (i >> 24);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\intl\gettextP.h:75
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\intl\bindtextdom.c:104
parsing error 
{
  struct binding *binding;
  int modified;

  /* Some sanity checks.  */
  if (domainname == NULL || domainname[0] == '\0')
    {
      if (dirnamep)
	*dirnamep = NULL;
      if (codesetp)
	*codesetp = NULL;
      return;
    }

  __libc_rwlock_wrlock (_nl_state_lock);

  modified = 0;

  for (binding = _nl_domain_bindings; binding != NULL; binding = binding->next)
    {
      int compare = strcmp (domainname, binding->domainname);
      if (compare == 0)
	/* We found it!  */
	break;
      if (compare < 0)
	{
	  /* It is not in the list.  */
	  binding = NULL;
	  break;
	}
    }

  if (binding != NULL)
    {
      if (dirnamep)
	{
	  const char *dirname = *dirnamep;

	  if (dirname == NULL)
	    /* The current binding has be to returned.  */
	    *dirnamep = binding->dirname;
	  else
	    {
	      /* The domain is already bound.  If the new value and the old
		 one are equal we simply do nothing.  Otherwise replace the
		 old binding.  */
	      char *result = binding->dirname;
	      if (strcmp (dirname, result) != 0)
		{
		  if (strcmp (dirname, INTUSE(_nl_default_dirname)) == 0)
		    result = (char *) INTUSE(_nl_default_dirname);
		  else
		    {
#if defined _LIBC || defined HAVE_STRDUP
		      result = strdup (dirname);
#else
		      size_t len = strlen (dirname) + 1;
		      result = (char *) malloc (len);
		      if (__builtin_expect (result != NULL, 1))
			memcpy (result, dirname, len);
#endif
		    }

		  if (__builtin_expect (result != NULL, 1))
		    {
		      if (binding->dirname != INTUSE(_nl_default_dirname))
			free (binding->dirname);

		      binding->dirname = result;
		      modified = 1;
		    }
		}
	      *dirnamep = result;
	    }
	}

      if (codesetp)
	{
	  const char *codeset = *codesetp;

	  if (codeset == NULL)
	    /* The current binding has be to returned.  */
	    *codesetp = binding->codeset;
	  else
	    {
	      /* The domain is already bound.  If the new value and the old
		 one are equal we simply do nothing.  Otherwise replace the
		 old binding.  */
	      char *result = binding->codeset;
	      if (result == NULL || strcmp (codeset, result) != 0)
		{
#if defined _LIBC || defined HAVE_STRDUP
		  result = strdup (codeset);
#else
		  size_t len = strlen (codeset) + 1;
		  result = (char *) malloc (len);
		  if (__builtin_expect (result != NULL, 1))
		    memcpy (result, codeset, len);
#endif

		  if (__builtin_expect (result != NULL, 1))
		    {
		      if (binding->codeset != NULL)
			free (binding->codeset);

		      binding->codeset = result;
		      binding->codeset_cntr++;
		      modified = 1;
		    }
		}
	      *codesetp = result;
	    }
	}
    }
  else if ((dirnamep == NULL || *dirnamep == NULL)
	   && (codesetp == NULL || *codesetp == NULL))
    {
      /* Simply return the default values.  */
      if (dirnamep)
	*dirnamep = INTUSE(_nl_default_dirname);
      if (codesetp)
	*codesetp = NULL;
    }
  else
    {
      /* We have to create a new binding.  */
      size_t len = strlen (domainname) + 1;
      struct binding *new_binding =
	(struct binding *) malloc (offsetof (struct binding, domainname) + len);

      if (__builtin_expect (new_binding == NULL, 0))
	goto failed;

      memcpy (new_binding->domainname, domainname, len);

      if (dirnamep)
	{
	  const char *dirname = *dirnamep;

	  if (dirname == NULL)
	    /* The default value.  */
	    dirname = INTUSE(_nl_default_dirname);
	  else
	    {
	      if (strcmp (dirname, INTUSE(_nl_default_dirname)) == 0)
		dirname = INTUSE(_nl_default_dirname);
	      else
		{
		  char *result;
#if defined _LIBC || defined HAVE_STRDUP
		  result = strdup (dirname);
		  if (__builtin_expect (result == NULL, 0))
		    goto failed_dirname;
#else
		  size_t len = strlen (dirname) + 1;
		  result = (char *) malloc (len);
		  if (__builtin_expect (result == NULL, 0))
		    goto failed_dirname;
		  memcpy (result, dirname, len);
#endif
		  dirname = result;
		}
	    }
	  *dirnamep = dirname;
	  new_binding->dirname = (char *) dirname;
	}
      else
	/* The default value.  */
	new_binding->dirname = (char *) INTUSE(_nl_default_dirname);

      new_binding->codeset_cntr = 0;

      if (codesetp)
	{
	  const char *codeset = *codesetp;

	  if (codeset != NULL)
	    {
	      char *result;

#if defined _LIBC || defined HAVE_STRDUP
	      result = strdup (codeset);
	      if (__builtin_expect (result == NULL, 0))
		goto failed_codeset;
#else
	      size_t len = strlen (codeset) + 1;
	      result = (char *) malloc (len);
	      if (__builtin_expect (result == NULL, 0))
		goto failed_codeset;
	      memcpy (result, codeset, len);
#endif
	      codeset = result;
	      new_binding->codeset_cntr++;
	    }
	  *codesetp = codeset;
	  new_binding->codeset = (char *) codeset;
	}
      else
	new_binding->codeset = NULL;

      /* Now enqueue it.  */
      if (_nl_domain_bindings == NULL
	  || strcmp (domainname, _nl_domain_bindings->domainname) < 0)
	{
	  new_binding->next = _nl_domain_bindings;
	  _nl_domain_bindings = new_binding;
	}
      else
	{
	  binding = _nl_domain_bindings;
	  while (binding->next != NULL
		 && strcmp (domainname, binding->next->domainname) > 0)
	    binding = binding->next;

	  new_binding->next = binding->next;
	  binding->next = new_binding;
	}

      modified = 1;

      /* Here we deal with memory allocation failures.  */
      if (0)
	{
	failed_codeset:
	  if (new_binding->dirname != INTUSE(_nl_default_dirname))
	    free (new_binding->dirname);
	failed_dirname:
	  free (new_binding);
	failed:
	  if (dirnamep)
	    *dirnamep = NULL;
	  if (codesetp)
	    *codesetp = NULL;
	}
    }

  /* If we modified any binding, we flush the caches.  */
  if (modified)
    ++_nl_msg_cat_cntr;

  __libc_rwlock_unlock (_nl_state_lock);
}
warning: parse error {
  struct binding *binding;
  int modified;

  /* Some sanity checks.  */
  if (domainname == NULL || domainname[0] == '\0')
    {
      if (dirnamep)
	*dirnamep = NULL;
      if (codesetp)
	*codesetp = NULL;
      return;
    }

  __libc_rwlock_wrlock (_nl_state_lock);

  modified = 0;

  for (binding = _nl_domain_bindings; binding != NULL; binding = binding->next)
    {
      int compare = strcmp (domainname, binding->domainname);
      if (compare == 0)
	/* We found it!  */
	break;
      if (compare < 0)
	{
	  /* It is not in the list.  */
	  binding = NULL;
	  break;
	}
    }

  if (binding != NULL)
    {
      if (dirnamep)
	{
	  const char *dirname = *dirnamep;

	  if (dirname == NULL)
	    /* The current binding has be to returned.  */
	    *dirnamep = binding->dirname;
	  else
	    {
	      /* The domain is already bound.  If the new value and the old
		 one are equal we simply do nothing.  Otherwise replace the
		 old binding.  */
	      char *result = binding->dirname;
	      if (strcmp (dirname, result) != 0)
		{
		  if (strcmp (dirname, INTUSE(_nl_default_dirname)) == 0)
		    result = (char *) INTUSE(_nl_default_dirname);
		  else
		    {
#if defined _LIBC || defined HAVE_STRDUP
		      result = strdup (dirname);
#else
		      size_t len = strlen (dirname) + 1;
		      result = (char *) malloc (len);
		      if (__builtin_expect (result != NULL, 1))
			memcpy (result, dirname, len);
#endif
		    }

		  if (__builtin_expect (result != NULL, 1))
		    {
		      if (binding->dirname != INTUSE(_nl_default_dirname))
			free (binding->dirname);

		      binding->dirname = result;
		      modified = 1;
		    }
		}
	      *dirnamep = result;
	    }
	}

      if (codesetp)
	{
	  const char *codeset = *codesetp;

	  if (codeset == NULL)
	    /* The current binding has be to returned.  */
	    *codesetp = binding->codeset;
	  else
	    {
	      /* The domain is already bound.  If the new value and the old
		 one are equal we simply do nothing.  Otherwise replace the
		 old binding.  */
	      char *result = binding->codeset;
	      if (result == NULL || strcmp (codeset, result) != 0)
		{
#if defined _LIBC || defined HAVE_STRDUP
		  result = strdup (codeset);
#else
		  size_t len = strlen (codeset) + 1;
		  result = (char *) malloc (len);
		  if (__builtin_expect (result != NULL, 1))
		    memcpy (result, codeset, len);
#endif

		  if (__builtin_expect (result != NULL, 1))
		    {
		      if (binding->codeset != NULL)
			free (binding->codeset);

		      binding->codeset = result;
		      binding->codeset_cntr++;
		      modified = 1;
		    }
		}
	      *codesetp = result;
	    }
	}
    }
  else if ((dirnamep == NULL || *dirnamep == NULL)
	   && (codesetp == NULL || *codesetp == NULL))
    {
      /* Simply return the default values.  */
      if (dirnamep)
	*dirnamep = INTUSE(_nl_default_dirname);
      if (codesetp)
	*codesetp = NULL;
    }
  else
    {
      /* We have to create a new binding.  */
      size_t len = strlen (domainname) + 1;
      struct binding *new_binding =
	(struct binding *) malloc (offsetof (struct binding, domainname) + len);

      if (__builtin_expect (new_binding == NULL, 0))
	goto failed;

      memcpy (new_binding->domainname, domainname, len);

      if (dirnamep)
	{
	  const char *dirname = *dirnamep;

	  if (dirname == NULL)
	    /* The default value.  */
	    dirname = INTUSE(_nl_default_dirname);
	  else
	    {
	      if (strcmp (dirname, INTUSE(_nl_default_dirname)) == 0)
		dirname = INTUSE(_nl_default_dirname);
	      else
		{
		  char *result;
#if defined _LIBC || defined HAVE_STRDUP
		  result = strdup (dirname);
		  if (__builtin_expect (result == NULL, 0))
		    goto failed_dirname;
#else
		  size_t len = strlen (dirname) + 1;
		  result = (char *) malloc (len);
		  if (__builtin_expect (result == NULL, 0))
		    goto failed_dirname;
		  memcpy (result, dirname, len);
#endif
		  dirname = result;
		}
	    }
	  *dirnamep = dirname;
	  new_binding->dirname = (char *) dirname;
	}
      else
	/* The default value.  */
	new_binding->dirname = (char *) INTUSE(_nl_default_dirname);

      new_binding->codeset_cntr = 0;

      if (codesetp)
	{
	  const char *codeset = *codesetp;

	  if (codeset != NULL)
	    {
	      char *result;

#if defined _LIBC || defined HAVE_STRDUP
	      result = strdup (codeset);
	      if (__builtin_expect (result == NULL, 0))
		goto failed_codeset;
#else
	      size_t len = strlen (codeset) + 1;
	      result = (char *) malloc (len);
	      if (__builtin_expect (result == NULL, 0))
		goto failed_codeset;
	      memcpy (result, codeset, len);
#endif
	      codeset = result;
	      new_binding->codeset_cntr++;
	    }
	  *codesetp = codeset;
	  new_binding->codeset = (char *) codeset;
	}
      else
	new_binding->codeset = NULL;

      /* Now enqueue it.  */
      if (_nl_domain_bindings == NULL
	  || strcmp (domainname, _nl_domain_bindings->domainname) < 0)
	{
	  new_binding->next = _nl_domain_bindings;
	  _nl_domain_bindings = new_binding;
	}
      else
	{
	  binding = _nl_domain_bindings;
	  while (binding->next != NULL
		 && strcmp (domainname, binding->next->domainname) > 0)
	    binding = binding->next;

	  new_binding->next = binding->next;
	  binding->next = new_binding;
	}

      modified = 1;

      /* Here we deal with memory allocation failures.  */
      if (0)
	{
	failed_codeset:
	  if (new_binding->dirname != INTUSE(_nl_default_dirname))
	    free (new_binding->dirname);
	failed_dirname:
	  free (new_binding);
	failed:
	  if (dirnamep)
	    *dirnamep = NULL;
	  if (codesetp)
	    *codesetp = NULL;
	}
    }

  /* If we modified any binding, we flush the caches.  */
  if (modified)
    ++_nl_msg_cat_cntr;

  __libc_rwlock_unlock (_nl_state_lock);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\intl\bindtextdom.c:107
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\intl\bindtextdom.c:354
parsing error 
{
  set_binding_values (domainname, &dirname, NULL);
  return (char *) dirname;
}
warning: parse error {
  set_binding_values (domainname, &dirname, NULL);
  return (char *) dirname;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\intl\bindtextdom.c:356
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\intl\bindtextdom.c:365
parsing error 
{
  set_binding_values (domainname, NULL, &codeset);
  return (char *) codeset;
}
warning: parse error {
  set_binding_values (domainname, NULL, &codeset);
  return (char *) codeset;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\intl\bindtextdom.c:367
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\intl\dcgettext.c...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\intl\gettextP.h...skip
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\intl\dcgettext.c:50
parsing error 
{
  return DCIGETTEXT (domainname, msgid, NULL, 0, 0, category);
}
warning: parse error {
  return DCIGETTEXT (domainname, msgid, NULL, 0, 0, category);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\intl\dcgettext.c:53
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\intl\dcigettext.c...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\intl\gettextP.h...skip
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\intl\plural-exp.h...
parsing error 
enum operator
  {
    /* Without arguments:  */
    var,			/* The variable "n".  */
    num,			/* Decimal number.  */
    /* Unary operators:  */
    lnot,			/* Logical NOT.  */
    /* Binary operators:  */
    mult,			/* Multiplication.  */
    divide,			/* Division.  */
    module,			/* Modulo operation.  */
    plus,			/* Addition.  */
    minus,			/* Subtraction.  */
    less_than,			/* Comparison.  */
    greater_than,		/* Comparison.  */
    less_or_equal,		/* Comparison.  */
    greater_or_equal,		/* Comparison.  */
    equal,			/* Comparison for equality.  */
    not_equal,			/* Comparison for inequality.  */
    land,			/* Logical AND.  */
    lor,			/* Logical OR.  */
    /* Ternary operators:  */
    qmop			/* Question mark operator.  */
  }
warning: parse error enum operator
  {
    /* Without arguments:  */
    var,			/* The variable "n".  */
    num,			/* Decimal number.  */
    /* Unary operators:  */
    lnot,			/* Logical NOT.  */
    /* Binary operators:  */
    mult,			/* Multiplication.  */
    divide,			/* Division.  */
    module,			/* Modulo operation.  */
    plus,			/* Addition.  */
    minus,			/* Subtraction.  */
    less_than,			/* Comparison.  */
    greater_than,		/* Comparison.  */
    less_or_equal,		/* Comparison.  */
    greater_or_equal,		/* Comparison.  */
    equal,			/* Comparison for equality.  */
    not_equal,			/* Comparison for inequality.  */
    land,			/* Logical AND.  */
    lor,			/* Logical OR.  */
    /* Ternary operators:  */
    qmop			/* Question mark operator.  */
  }Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\intl\plural-exp.h:47
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\intl\hash-string.h...
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\intl\hash-string.h:42
parsing error 
{
  unsigned long int hval, g;
  const char *str = str_param;

  /* Compute the hash value for the given string.  */
  hval = 0;
  while (*str != '\0')
    {
      hval <<= 4;
      hval += (unsigned long int) *str++;
      g = hval & ((unsigned long int) 0xf << (HASHWORDBITS - 4));
      if (g != 0)
	{
	  hval ^= g >> (HASHWORDBITS - 8);
	  hval ^= g;
	}
    }
  return hval;
}
warning: parse error {
  unsigned long int hval, g;
  const char *str = str_param;

  /* Compute the hash value for the given string.  */
  hval = 0;
  while (*str != '\0')
    {
      hval <<= 4;
      hval += (unsigned long int) *str++;
      g = hval & ((unsigned long int) 0xf << (HASHWORDBITS - 4));
      if (g != 0)
	{
	  hval ^= g >> (HASHWORDBITS - 8);
	  hval ^= g;
	}
    }
  return hval;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\intl\hash-string.h:43
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\intl\eval-plural.h...
parsing error 
STATIC unsigned long int plural_eval PARAMS ((struct expression *pexp,
					      unsigned long int n))
     internal_function;
warning: parse error STATIC unsigned long int plural_eval PARAMS ((struct expression *pexp,
					      unsigned long int n))
     internal_function;Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\intl\eval-plural.h:26
parsing error 
n
warning: parse error nMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\intl\eval-plural.h:32
parsing error 
plural_eval (pexp, n)
     struct expression *pexp;
warning: parse error plural_eval (pexp, n)
     struct expression *pexp;Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\intl\eval-plural.h:33
parsing error 
{
  switch (pexp->nargs)
    {
    case 0:
      switch (pexp->operation)
	{
	case var:
	  return n;
	case num:
	  return pexp->val.num;
	default:
	  break;
	}
      /* NOTREACHED */
      break;
    case 1:
      {
	/* pexp->operation must be lnot.  */
	unsigned long int arg = plural_eval (pexp->val.args[0], n);
	return ! arg;
      }
    case 2:
      {
	unsigned long int leftarg = plural_eval (pexp->val.args[0], n);
	if (pexp->operation == lor)
	  return leftarg || plural_eval (pexp->val.args[1], n);
	else if (pexp->operation == land)
	  return leftarg && plural_eval (pexp->val.args[1], n);
	else
	  {
	    unsigned long int rightarg = plural_eval (pexp->val.args[1], n);

	    switch (pexp->operation)
	      {
	      case mult:
		return leftarg * rightarg;
	      case divide:
#if !INTDIV0_RAISES_SIGFPE
		if (rightarg == 0)
		  raise (SIGFPE);
#endif
		return leftarg / rightarg;
	      case module:
#if !INTDIV0_RAISES_SIGFPE
		if (rightarg == 0)
		  raise (SIGFPE);
#endif
		return leftarg % rightarg;
	      case plus:
		return leftarg + rightarg;
	      case minus:
		return leftarg - rightarg;
	      case less_than:
		return leftarg < rightarg;
	      case greater_than:
		return leftarg > rightarg;
	      case less_or_equal:
		return leftarg <= rightarg;
	      case greater_or_equal:
		return leftarg >= rightarg;
	      case equal:
		return leftarg == rightarg;
	      case not_equal:
		return leftarg != rightarg;
	      default:
		break;
	      }
	  }
	/* NOTREACHED */
	break;
      }
    case 3:
      {
	/* pexp->operation must be qmop.  */
	unsigned long int boolarg = plural_eval (pexp->val.args[0], n);
	return plural_eval (pexp->val.args[boolarg ? 1 : 2], n);
      }
    }
  /* NOTREACHED */
  return 0;
}
warning: parse error {
  switch (pexp->nargs)
    {
    case 0:
      switch (pexp->operation)
	{
	case var:
	  return n;
	case num:
	  return pexp->val.num;
	default:
	  break;
	}
      /* NOTREACHED */
      break;
    case 1:
      {
	/* pexp->operation must be lnot.  */
	unsigned long int arg = plural_eval (pexp->val.args[0], n);
	return ! arg;
      }
    case 2:
      {
	unsigned long int leftarg = plural_eval (pexp->val.args[0], n);
	if (pexp->operation == lor)
	  return leftarg || plural_eval (pexp->val.args[1], n);
	else if (pexp->operation == land)
	  return leftarg && plural_eval (pexp->val.args[1], n);
	else
	  {
	    unsigned long int rightarg = plural_eval (pexp->val.args[1], n);

	    switch (pexp->operation)
	      {
	      case mult:
		return leftarg * rightarg;
	      case divide:
#if !INTDIV0_RAISES_SIGFPE
		if (rightarg == 0)
		  raise (SIGFPE);
#endif
		return leftarg / rightarg;
	      case module:
#if !INTDIV0_RAISES_SIGFPE
		if (rightarg == 0)
		  raise (SIGFPE);
#endif
		return leftarg % rightarg;
	      case plus:
		return leftarg + rightarg;
	      case minus:
		return leftarg - rightarg;
	      case less_than:
		return leftarg < rightarg;
	      case greater_than:
		return leftarg > rightarg;
	      case less_or_equal:
		return leftarg <= rightarg;
	      case greater_or_equal:
		return leftarg >= rightarg;
	      case equal:
		return leftarg == rightarg;
	      case not_equal:
		return leftarg != rightarg;
	      default:
		break;
	      }
	  }
	/* NOTREACHED */
	break;
      }
    case 3:
      {
	/* pexp->operation must be qmop.  */
	unsigned long int boolarg = plural_eval (pexp->val.args[0], n);
	return plural_eval (pexp->val.args[boolarg ? 1 : 2], n);
      }
    }
  /* NOTREACHED */
  return 0;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\intl\eval-plural.h:36
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\intl\dcigettext.c:438
parsing error 
{
#ifndef HAVE_ALLOCA
  struct block_list *block_list = NULL;
#endif
  struct loaded_l10nfile *domain;
  struct binding *binding;
  const char *categoryname;
  const char *categoryvalue;
  char *dirname, *xdomainname;
  char *single_locale;
  char *retval;
  size_t retlen;
  int saved_errno;
#if defined HAVE_TSEARCH || defined _LIBC
  struct known_translation_t *search;
  struct known_translation_t **foundp = NULL;
  size_t msgid_len;
#endif
  size_t domainname_len;

  /* If no real MSGID is given return NULL.  */
  if (msgid1 == NULL)
    return NULL;

#ifdef _LIBC
  if (category < 0 || category >= __LC_LAST || category == LC_ALL)
    /* Bogus.  */
    return (plural == 0
	    ? (char *) msgid1
	    /* Use the Germanic plural rule.  */
	    : n == 1 ? (char *) msgid1 : (char *) msgid2);
#endif

  __libc_rwlock_rdlock (_nl_state_lock);

  /* If DOMAINNAME is NULL, we are interested in the default domain.  If
     CATEGORY is not LC_MESSAGES this might not make much sense but the
     definition left this undefined.  */
  if (domainname == NULL)
    domainname = _nl_current_default_domain;

  /* OS/2 specific: backward compatibility with older libintl versions  */
#ifdef LC_MESSAGES_COMPAT
  if (category == LC_MESSAGES_COMPAT)
    category = LC_MESSAGES;
#endif

#if defined HAVE_TSEARCH || defined _LIBC
  msgid_len = strlen (msgid1) + 1;

  /* Try to find the translation among those which we found at
     some time.  */
  search = (struct known_translation_t *)
	   alloca (offsetof (struct known_translation_t, msgid) + msgid_len);
  memcpy (search->msgid, msgid1, msgid_len);
  search->domainname = (char *) domainname;
  search->category = category;

  foundp = (struct known_translation_t **) tfind (search, &root, transcmp);
  freea (search);
  if (foundp != NULL && (*foundp)->counter == _nl_msg_cat_cntr)
    {
      /* Now deal with plural.  */
      if (plural)
	retval = plural_lookup ((*foundp)->domain, n, (*foundp)->translation,
				(*foundp)->translation_length);
      else
	retval = (char *) (*foundp)->translation;

      __libc_rwlock_unlock (_nl_state_lock);
      return retval;
    }
#endif

  /* Preserve the `errno' value.  */
  saved_errno = errno;

  /* See whether this is a SUID binary or not.  */
  DETERMINE_SECURE;

  /* First find matching binding.  */
  for (binding = _nl_domain_bindings; binding != NULL; binding = binding->next)
    {
      int compare = strcmp (domainname, binding->domainname);
      if (compare == 0)
	/* We found it!  */
	break;
      if (compare < 0)
	{
	  /* It is not in the list.  */
	  binding = NULL;
	  break;
	}
    }

  if (binding == NULL)
    dirname = (char *) INTUSE(_nl_default_dirname);
  else if (IS_ABSOLUTE_PATH (binding->dirname))
    dirname = binding->dirname;
  else
    {
      /* We have a relative path.  Make it absolute now.  */
      size_t dirname_len = strlen (binding->dirname) + 1;
      size_t path_max;
      char *ret;

      path_max = (unsigned int) PATH_MAX;
      path_max += 2;		/* The getcwd docs say to do this.  */

      for (;;)
	{
	  dirname = (char *) alloca (path_max + dirname_len);
	  ADD_BLOCK (block_list, dirname);

	  __set_errno (0);
	  ret = getcwd (dirname, path_max);
	  if (ret != NULL || errno != ERANGE)
	    break;

	  path_max += path_max / 2;
	  path_max += PATH_INCR;
	}

      if (ret == NULL)
	/* We cannot get the current working directory.  Don't signal an
	   error but simply return the default string.  */
	goto return_untranslated;

      stpcpy (stpcpy (strchr (dirname, '\0'), "/"), binding->dirname);
    }

  /* Now determine the symbolic name of CATEGORY and its value.  */
  categoryname = category_to_name (category);
  categoryvalue = guess_category_value (category, categoryname);

  domainname_len = strlen (domainname);
  xdomainname = (char *) alloca (strlen (categoryname)
				 + domainname_len + 5);
  ADD_BLOCK (block_list, xdomainname);

  stpcpy (mempcpy (stpcpy (stpcpy (xdomainname, categoryname), "/"),
		  domainname, domainname_len),
	  ".mo");

  /* Creating working area.  */
  single_locale = (char *) alloca (strlen (categoryvalue) + 1);
  ADD_BLOCK (block_list, single_locale);


  /* Search for the given string.  This is a loop because we perhaps
     got an ordered list of languages to consider for the translation.  */
  while (1)
    {
      /* Make CATEGORYVALUE point to the next element of the list.  */
      while (categoryvalue[0] != '\0' && categoryvalue[0] == ':')
	++categoryvalue;
      if (categoryvalue[0] == '\0')
	{
	  /* The whole contents of CATEGORYVALUE has been searched but
	     no valid entry has been found.  We solve this situation
	     by implicitly appending a "C" entry, i.e. no translation
	     will take place.  */
	  single_locale[0] = 'C';
	  single_locale[1] = '\0';
	}
      else
	{
	  char *cp = single_locale;
	  while (categoryvalue[0] != '\0' && categoryvalue[0] != ':')
	    *cp++ = *categoryvalue++;
	  *cp = '\0';

	  /* When this is a SUID binary we must not allow accessing files
	     outside the dedicated directories.  */
	  if (ENABLE_SECURE && IS_PATH_WITH_DIR (single_locale))
	    /* Ingore this entry.  */
	    continue;
	}

      /* If the current locale value is C (or POSIX) we don't load a
	 domain.  Return the MSGID.  */
      if (strcmp (single_locale, "C") == 0
	  || strcmp (single_locale, "POSIX") == 0)
	break;

      /* Find structure describing the message catalog matching the
	 DOMAINNAME and CATEGORY.  */
      domain = _nl_find_domain (dirname, single_locale, xdomainname, binding);

      if (domain != NULL)
	{
	  retval = _nl_find_msg (domain, binding, msgid1, &retlen);

	  if (retval == NULL)
	    {
	      int cnt;

	      for (cnt = 0; domain->successor[cnt] != NULL; ++cnt)
		{
		  retval = _nl_find_msg (domain->successor[cnt], binding,
					 msgid1, &retlen);

		  if (retval != NULL)
		    {
		      domain = domain->successor[cnt];
		      break;
		    }
		}
	    }

	  if (retval != NULL)
	    {
	      /* Found the translation of MSGID1 in domain DOMAIN:
		 starting at RETVAL, RETLEN bytes.  */
	      FREE_BLOCKS (block_list);
#if defined HAVE_TSEARCH || defined _LIBC
	      if (foundp == NULL)
		{
		  /* Create a new entry and add it to the search tree.  */
		  struct known_translation_t *newp;

		  newp = (struct known_translation_t *)
		    malloc (offsetof (struct known_translation_t, msgid)
			    + msgid_len + domainname_len + 1);
		  if (newp != NULL)
		    {
		      newp->domainname =
			mempcpy (newp->msgid, msgid1, msgid_len);
		      memcpy (newp->domainname, domainname, domainname_len + 1);
		      newp->category = category;
		      newp->counter = _nl_msg_cat_cntr;
		      newp->domain = domain;
		      newp->translation = retval;
		      newp->translation_length = retlen;

		      /* Insert the entry in the search tree.  */
		      foundp = (struct known_translation_t **)
			tsearch (newp, &root, transcmp);
		      if (foundp == NULL
			  || __builtin_expect (*foundp != newp, 0))
			/* The insert failed.  */
			free (newp);
		    }
		}
	      else
		{
		  /* We can update the existing entry.  */
		  (*foundp)->counter = _nl_msg_cat_cntr;
		  (*foundp)->domain = domain;
		  (*foundp)->translation = retval;
		  (*foundp)->translation_length = retlen;
		}
#endif
	      __set_errno (saved_errno);

	      /* Now deal with plural.  */
	      if (plural)
		retval = plural_lookup (domain, n, retval, retlen);

	      __libc_rwlock_unlock (_nl_state_lock);
	      return retval;
	    }
	}
    }

 return_untranslated:
  /* Return the untranslated MSGID.  */
  FREE_BLOCKS (block_list);
  __libc_rwlock_unlock (_nl_state_lock);
#ifndef _LIBC
  if (!ENABLE_SECURE)
    {
      extern void _nl_log_untranslated PARAMS ((const char *logfilename,
						const char *domainname,
						const char *msgid1,
						const char *msgid2,
						int plural));
      const char *logfilename = getenv ("GETTEXT_LOG_UNTRANSLATED");

      if (logfilename != NULL && logfilename[0] != '\0')
	_nl_log_untranslated (logfilename, domainname, msgid1, msgid2, plural);
    }
#endif
  __set_errno (saved_errno);
  return (plural == 0
	  ? (char *) msgid1
	  /* Use the Germanic plural rule.  */
	  : n == 1 ? (char *) msgid1 : (char *) msgid2);
}
warning: parse error {
#ifndef HAVE_ALLOCA
  struct block_list *block_list = NULL;
#endif
  struct loaded_l10nfile *domain;
  struct binding *binding;
  const char *categoryname;
  const char *categoryvalue;
  char *dirname, *xdomainname;
  char *single_locale;
  char *retval;
  size_t retlen;
  int saved_errno;
#if defined HAVE_TSEARCH || defined _LIBC
  struct known_translation_t *search;
  struct known_translation_t **foundp = NULL;
  size_t msgid_len;
#endif
  size_t domainname_len;

  /* If no real MSGID is given return NULL.  */
  if (msgid1 == NULL)
    return NULL;

#ifdef _LIBC
  if (category < 0 || category >= __LC_LAST || category == LC_ALL)
    /* Bogus.  */
    return (plural == 0
	    ? (char *) msgid1
	    /* Use the Germanic plural rule.  */
	    : n == 1 ? (char *) msgid1 : (char *) msgid2);
#endif

  __libc_rwlock_rdlock (_nl_state_lock);

  /* If DOMAINNAME is NULL, we are interested in the default domain.  If
     CATEGORY is not LC_MESSAGES this might not make much sense but the
     definition left this undefined.  */
  if (domainname == NULL)
    domainname = _nl_current_default_domain;

  /* OS/2 specific: backward compatibility with older libintl versions  */
#ifdef LC_MESSAGES_COMPAT
  if (category == LC_MESSAGES_COMPAT)
    category = LC_MESSAGES;
#endif

#if defined HAVE_TSEARCH || defined _LIBC
  msgid_len = strlen (msgid1) + 1;

  /* Try to find the translation among those which we found at
     some time.  */
  search = (struct known_translation_t *)
	   alloca (offsetof (struct known_translation_t, msgid) + msgid_len);
  memcpy (search->msgid, msgid1, msgid_len);
  search->domainname = (char *) domainname;
  search->category = category;

  foundp = (struct known_translation_t **) tfind (search, &root, transcmp);
  freea (search);
  if (foundp != NULL && (*foundp)->counter == _nl_msg_cat_cntr)
    {
      /* Now deal with plural.  */
      if (plural)
	retval = plural_lookup ((*foundp)->domain, n, (*foundp)->translation,
				(*foundp)->translation_length);
      else
	retval = (char *) (*foundp)->translation;

      __libc_rwlock_unlock (_nl_state_lock);
      return retval;
    }
#endif

  /* Preserve the `errno' value.  */
  saved_errno = errno;

  /* See whether this is a SUID binary or not.  */
  DETERMINE_SECURE;

  /* First find matching binding.  */
  for (binding = _nl_domain_bindings; binding != NULL; binding = binding->next)
    {
      int compare = strcmp (domainname, binding->domainname);
      if (compare == 0)
	/* We found it!  */
	break;
      if (compare < 0)
	{
	  /* It is not in the list.  */
	  binding = NULL;
	  break;
	}
    }

  if (binding == NULL)
    dirname = (char *) INTUSE(_nl_default_dirname);
  else if (IS_ABSOLUTE_PATH (binding->dirname))
    dirname = binding->dirname;
  else
    {
      /* We have a relative path.  Make it absolute now.  */
      size_t dirname_len = strlen (binding->dirname) + 1;
      size_t path_max;
      char *ret;

      path_max = (unsigned int) PATH_MAX;
      path_max += 2;		/* The getcwd docs say to do this.  */

      for (;;)
	{
	  dirname = (char *) alloca (path_max + dirname_len);
	  ADD_BLOCK (block_list, dirname);

	  __set_errno (0);
	  ret = getcwd (dirname, path_max);
	  if (ret != NULL || errno != ERANGE)
	    break;

	  path_max += path_max / 2;
	  path_max += PATH_INCR;
	}

      if (ret == NULL)
	/* We cannot get the current working directory.  Don't signal an
	   error but simply return the default string.  */
	goto return_untranslated;

      stpcpy (stpcpy (strchr (dirname, '\0'), "/"), binding->dirname);
    }

  /* Now determine the symbolic name of CATEGORY and its value.  */
  categoryname = category_to_name (category);
  categoryvalue = guess_category_value (category, categoryname);

  domainname_len = strlen (domainname);
  xdomainname = (char *) alloca (strlen (categoryname)
				 + domainname_len + 5);
  ADD_BLOCK (block_list, xdomainname);

  stpcpy (mempcpy (stpcpy (stpcpy (xdomainname, categoryname), "/"),
		  domainname, domainname_len),
	  ".mo");

  /* Creating working area.  */
  single_locale = (char *) alloca (strlen (categoryvalue) + 1);
  ADD_BLOCK (block_list, single_locale);


  /* Search for the given string.  This is a loop because we perhaps
     got an ordered list of languages to consider for the translation.  */
  while (1)
    {
      /* Make CATEGORYVALUE point to the next element of the list.  */
      while (categoryvalue[0] != '\0' && categoryvalue[0] == ':')
	++categoryvalue;
      if (categoryvalue[0] == '\0')
	{
	  /* The whole contents of CATEGORYVALUE has been searched but
	     no valid entry has been found.  We solve this situation
	     by implicitly appending a "C" entry, i.e. no translation
	     will take place.  */
	  single_locale[0] = 'C';
	  single_locale[1] = '\0';
	}
      else
	{
	  char *cp = single_locale;
	  while (categoryvalue[0] != '\0' && categoryvalue[0] != ':')
	    *cp++ = *categoryvalue++;
	  *cp = '\0';

	  /* When this is a SUID binary we must not allow accessing files
	     outside the dedicated directories.  */
	  if (ENABLE_SECURE && IS_PATH_WITH_DIR (single_locale))
	    /* Ingore this entry.  */
	    continue;
	}

      /* If the current locale value is C (or POSIX) we don't load a
	 domain.  Return the MSGID.  */
      if (strcmp (single_locale, "C") == 0
	  || strcmp (single_locale, "POSIX") == 0)
	break;

      /* Find structure describing the message catalog matching the
	 DOMAINNAME and CATEGORY.  */
      domain = _nl_find_domain (dirname, single_locale, xdomainname, binding);

      if (domain != NULL)
	{
	  retval = _nl_find_msg (domain, binding, msgid1, &retlen);

	  if (retval == NULL)
	    {
	      int cnt;

	      for (cnt = 0; domain->successor[cnt] != NULL; ++cnt)
		{
		  retval = _nl_find_msg (domain->successor[cnt], binding,
					 msgid1, &retlen);

		  if (retval != NULL)
		    {
		      domain = domain->successor[cnt];
		      break;
		    }
		}
	    }

	  if (retval != NULL)
	    {
	      /* Found the translation of MSGID1 in domain DOMAIN:
		 starting at RETVAL, RETLEN bytes.  */
	      FREE_BLOCKS (block_list);
#if defined HAVE_TSEARCH || defined _LIBC
	      if (foundp == NULL)
		{
		  /* Create a new entry and add it to the search tree.  */
		  struct known_translation_t *newp;

		  newp = (struct known_translation_t *)
		    malloc (offsetof (struct known_translation_t, msgid)
			    + msgid_len + domainname_len + 1);
		  if (newp != NULL)
		    {
		      newp->domainname =
			mempcpy (newp->msgid, msgid1, msgid_len);
		      memcpy (newp->domainname, domainname, domainname_len + 1);
		      newp->category = category;
		      newp->counter = _nl_msg_cat_cntr;
		      newp->domain = domain;
		      newp->translation = retval;
		      newp->translation_length = retlen;

		      /* Insert the entry in the search tree.  */
		      foundp = (struct known_translation_t **)
			tsearch (newp, &root, transcmp);
		      if (foundp == NULL
			  || __builtin_expect (*foundp != newp, 0))
			/* The insert failed.  */
			free (newp);
		    }
		}
	      else
		{
		  /* We can update the existing entry.  */
		  (*foundp)->counter = _nl_msg_cat_cntr;
		  (*foundp)->domain = domain;
		  (*foundp)->translation = retval;
		  (*foundp)->translation_length = retlen;
		}
#endif
	      __set_errno (saved_errno);

	      /* Now deal with plural.  */
	      if (plural)
		retval = plural_lookup (domain, n, retval, retlen);

	      __libc_rwlock_unlock (_nl_state_lock);
	      return retval;
	    }
	}
    }

 return_untranslated:
  /* Return the untranslated MSGID.  */
  FREE_BLOCKS (block_list);
  __libc_rwlock_unlock (_nl_state_lock);
#ifndef _LIBC
  if (!ENABLE_SECURE)
    {
      extern void _nl_log_untranslated PARAMS ((const char *logfilename,
						const char *domainname,
						const char *msgid1,
						const char *msgid2,
						int plural));
      const char *logfilename = getenv ("GETTEXT_LOG_UNTRANSLATED");

      if (logfilename != NULL && logfilename[0] != '\0')
	_nl_log_untranslated (logfilename, domainname, msgid1, msgid2, plural);
    }
#endif
  __set_errno (saved_errno);
  return (plural == 0
	  ? (char *) msgid1
	  /* Use the Germanic plural rule.  */
	  : n == 1 ? (char *) msgid1 : (char *) msgid2);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\intl\dcigettext.c:444
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\intl\dcigettext.c:737
parsing error 
{
  struct loaded_domain *domain;
  nls_uint32 nstrings;
  size_t act;
  char *result;
  size_t resultlen;

  if (domain_file->decided == 0)
    _nl_load_domain (domain_file, domainbinding);

  if (domain_file->data == NULL)
    return NULL;

  domain = (struct loaded_domain *) domain_file->data;

  nstrings = domain->nstrings;

  /* Locate the MSGID and its translation.  */
  if (domain->hash_tab != NULL)
    {
      /* Use the hashing table.  */
      nls_uint32 len = strlen (msgid);
      nls_uint32 hash_val = hash_string (msgid);
      nls_uint32 idx = hash_val % domain->hash_size;
      nls_uint32 incr = 1 + (hash_val % (domain->hash_size - 2));

      while (1)
	{
	  nls_uint32 nstr =
	    W (domain->must_swap_hash_tab, domain->hash_tab[idx]);

	  if (nstr == 0)
	    /* Hash table entry is empty.  */
	    return NULL;

	  nstr--;

	  /* Compare msgid with the original string at index nstr.
	     We compare the lengths with >=, not ==, because plural entries
	     are represented by strings with an embedded NUL.  */
	  if (nstr < nstrings
	      ? W (domain->must_swap, domain->orig_tab[nstr].length) >= len
		&& (strcmp (msgid,
			    domain->data + W (domain->must_swap,
					      domain->orig_tab[nstr].offset))
		    == 0)
	      : domain->orig_sysdep_tab[nstr - nstrings].length > len
		&& (strcmp (msgid,
			    domain->orig_sysdep_tab[nstr - nstrings].pointer)
		    == 0))
	    {
	      act = nstr;
	      goto found;
	    }

	  if (idx >= domain->hash_size - incr)
	    idx -= domain->hash_size - incr;
	  else
	    idx += incr;
	}
      /* NOTREACHED */
    }
  else
    {
      /* Try the default method:  binary search in the sorted array of
	 messages.  */
      size_t top, bottom;

      bottom = 0;
      top = nstrings;
      while (bottom < top)
	{
	  int cmp_val;

	  act = (bottom + top) / 2;
	  cmp_val = strcmp (msgid, (domain->data
				    + W (domain->must_swap,
					 domain->orig_tab[act].offset)));
	  if (cmp_val < 0)
	    top = act;
	  else if (cmp_val > 0)
	    bottom = act + 1;
	  else
	    goto found;
	}
      /* No translation was found.  */
      return NULL;
    }

 found:
  /* The translation was found at index ACT.  If we have to convert the
     string to use a different character set, this is the time.  */
  if (act < nstrings)
    {
      result = (char *)
	(domain->data + W (domain->must_swap, domain->trans_tab[act].offset));
      resultlen = W (domain->must_swap, domain->trans_tab[act].length) + 1;
    }
  else
    {
      result = (char *) domain->trans_sysdep_tab[act - nstrings].pointer;
      resultlen = domain->trans_sysdep_tab[act - nstrings].length;
    }

#if defined _LIBC || HAVE_ICONV
  if (domain->codeset_cntr
      != (domainbinding != NULL ? domainbinding->codeset_cntr : 0))
    {
      /* The domain's codeset has changed through bind_textdomain_codeset()
	 since the message catalog was initialized or last accessed.  We
	 have to reinitialize the converter.  */
      _nl_free_domain_conv (domain);
      _nl_init_domain_conv (domain_file, domain, domainbinding);
    }

  if (
# ifdef _LIBC
      domain->conv != (__gconv_t) -1
# else
#  if HAVE_ICONV
      domain->conv != (iconv_t) -1
#  endif
# endif
      )
    {
      /* We are supposed to do a conversion.  First allocate an
	 appropriate table with the same structure as the table
	 of translations in the file, where we can put the pointers
	 to the converted strings in.
	 There is a slight complication with plural entries.  They
	 are represented by consecutive NUL terminated strings.  We
	 handle this case by converting RESULTLEN bytes, including
	 NULs.  */

      if (domain->conv_tab == NULL
	  && ((domain->conv_tab =
		 (char **) calloc (nstrings + domain->n_sysdep_strings,
				   sizeof (char *)))
	      == NULL))
	/* Mark that we didn't succeed allocating a table.  */
	domain->conv_tab = (char **) -1;

      if (__builtin_expect (domain->conv_tab == (char **) -1, 0))
	/* Nothing we can do, no more memory.  */
	goto converted;

      if (domain->conv_tab[act] == NULL)
	{
	  /* We haven't used this string so far, so it is not
	     translated yet.  Do this now.  */
	  /* We use a bit more efficient memory handling.
	     We allocate always larger blocks which get used over
	     time.  This is faster than many small allocations.   */
	  __libc_lock_define_initialized (static, lock)
# define INITIAL_BLOCK_SIZE	4080
	  static unsigned char *freemem;
	  static size_t freemem_size;

	  const unsigned char *inbuf;
	  unsigned char *outbuf;
	  int malloc_count;
# ifndef _LIBC
	  transmem_block_t *transmem_list = NULL;
# endif

	  __libc_lock_lock (lock);

	  inbuf = (const unsigned char *) result;
	  outbuf = freemem + sizeof (size_t);

	  malloc_count = 0;
	  while (1)
	    {
	      transmem_block_t *newmem;
# ifdef _LIBC
	      size_t non_reversible;
	      int res;

	      if (freemem_size < sizeof (size_t))
		goto resize_freemem;

	      res = __gconv (domain->conv,
			     &inbuf, inbuf + resultlen,
			     &outbuf,
			     outbuf + freemem_size - sizeof (size_t),
			     &non_reversible);

	      if (res == __GCONV_OK || res == __GCONV_EMPTY_INPUT)
		break;

	      if (res != __GCONV_FULL_OUTPUT)
		{
		  __libc_lock_unlock (lock);
		  goto converted;
		}

	      inbuf = result;
# else
#  if HAVE_ICONV
	      const char *inptr = (const char *) inbuf;
	      size_t inleft = resultlen;
	      char *outptr = (char *) outbuf;
	      size_t outleft;

	      if (freemem_size < sizeof (size_t))
		goto resize_freemem;

	      outleft = freemem_size - sizeof (size_t);
	      if (iconv (domain->conv,
			 (ICONV_CONST char **) &inptr, &inleft,
			 &outptr, &outleft)
		  != (size_t) (-1))
		{
		  outbuf = (unsigned char *) outptr;
		  break;
		}
	      if (errno != E2BIG)
		{
		  __libc_lock_unlock (lock);
		  goto converted;
		}
#  endif
# endif

	    resize_freemem:
	      /* We must allocate a new buffer or resize the old one.  */
	      if (malloc_count > 0)
		{
		  ++malloc_count;
		  freemem_size = malloc_count * INITIAL_BLOCK_SIZE;
		  newmem = (transmem_block_t *) realloc (transmem_list,
							 freemem_size);
# ifdef _LIBC
		  if (newmem != NULL)
		    transmem_list = transmem_list->next;
		  else
		    {
		      struct transmem_list *old = transmem_list;

		      transmem_list = transmem_list->next;
		      free (old);
		    }
# endif
		}
	      else
		{
		  malloc_count = 1;
		  freemem_size = INITIAL_BLOCK_SIZE;
		  newmem = (transmem_block_t *) malloc (freemem_size);
		}
	      if (__builtin_expect (newmem == NULL, 0))
		{
		  freemem = NULL;
		  freemem_size = 0;
		  __libc_lock_unlock (lock);
		  goto converted;
		}

# ifdef _LIBC
	      /* Add the block to the list of blocks we have to free
                 at some point.  */
	      newmem->next = transmem_list;
	      transmem_list = newmem;

	      freemem = newmem->data;
	      freemem_size -= offsetof (struct transmem_list, data);
# else
	      transmem_list = newmem;
	      freemem = newmem;
# endif

	      outbuf = freemem + sizeof (size_t);
	    }

	  /* We have now in our buffer a converted string.  Put this
	     into the table of conversions.  */
	  *(size_t *) freemem = outbuf - freemem - sizeof (size_t);
	  domain->conv_tab[act] = (char *) freemem;
	  /* Shrink freemem, but keep it aligned.  */
	  freemem_size -= outbuf - freemem;
	  freemem = outbuf;
	  freemem += freemem_size & (alignof (size_t) - 1);
	  freemem_size = freemem_size & ~ (alignof (size_t) - 1);

	  __libc_lock_unlock (lock);
	}

      /* Now domain->conv_tab[act] contains the translation of all
	 the plural variants.  */
      result = domain->conv_tab[act] + sizeof (size_t);
      resultlen = *(size_t *) domain->conv_tab[act];
    }

 converted:
  /* The result string is converted.  */

#endif /* _LIBC || HAVE_ICONV */

  *lengthp = resultlen;
  return result;
}
warning: parse error {
  struct loaded_domain *domain;
  nls_uint32 nstrings;
  size_t act;
  char *result;
  size_t resultlen;

  if (domain_file->decided == 0)
    _nl_load_domain (domain_file, domainbinding);

  if (domain_file->data == NULL)
    return NULL;

  domain = (struct loaded_domain *) domain_file->data;

  nstrings = domain->nstrings;

  /* Locate the MSGID and its translation.  */
  if (domain->hash_tab != NULL)
    {
      /* Use the hashing table.  */
      nls_uint32 len = strlen (msgid);
      nls_uint32 hash_val = hash_string (msgid);
      nls_uint32 idx = hash_val % domain->hash_size;
      nls_uint32 incr = 1 + (hash_val % (domain->hash_size - 2));

      while (1)
	{
	  nls_uint32 nstr =
	    W (domain->must_swap_hash_tab, domain->hash_tab[idx]);

	  if (nstr == 0)
	    /* Hash table entry is empty.  */
	    return NULL;

	  nstr--;

	  /* Compare msgid with the original string at index nstr.
	     We compare the lengths with >=, not ==, because plural entries
	     are represented by strings with an embedded NUL.  */
	  if (nstr < nstrings
	      ? W (domain->must_swap, domain->orig_tab[nstr].length) >= len
		&& (strcmp (msgid,
			    domain->data + W (domain->must_swap,
					      domain->orig_tab[nstr].offset))
		    == 0)
	      : domain->orig_sysdep_tab[nstr - nstrings].length > len
		&& (strcmp (msgid,
			    domain->orig_sysdep_tab[nstr - nstrings].pointer)
		    == 0))
	    {
	      act = nstr;
	      goto found;
	    }

	  if (idx >= domain->hash_size - incr)
	    idx -= domain->hash_size - incr;
	  else
	    idx += incr;
	}
      /* NOTREACHED */
    }
  else
    {
      /* Try the default method:  binary search in the sorted array of
	 messages.  */
      size_t top, bottom;

      bottom = 0;
      top = nstrings;
      while (bottom < top)
	{
	  int cmp_val;

	  act = (bottom + top) / 2;
	  cmp_val = strcmp (msgid, (domain->data
				    + W (domain->must_swap,
					 domain->orig_tab[act].offset)));
	  if (cmp_val < 0)
	    top = act;
	  else if (cmp_val > 0)
	    bottom = act + 1;
	  else
	    goto found;
	}
      /* No translation was found.  */
      return NULL;
    }

 found:
  /* The translation was found at index ACT.  If we have to convert the
     string to use a different character set, this is the time.  */
  if (act < nstrings)
    {
      result = (char *)
	(domain->data + W (domain->must_swap, domain->trans_tab[act].offset));
      resultlen = W (domain->must_swap, domain->trans_tab[act].length) + 1;
    }
  else
    {
      result = (char *) domain->trans_sysdep_tab[act - nstrings].pointer;
      resultlen = domain->trans_sysdep_tab[act - nstrings].length;
    }

#if defined _LIBC || HAVE_ICONV
  if (domain->codeset_cntr
      != (domainbinding != NULL ? domainbinding->codeset_cntr : 0))
    {
      /* The domain's codeset has changed through bind_textdomain_codeset()
	 since the message catalog was initialized or last accessed.  We
	 have to reinitialize the converter.  */
      _nl_free_domain_conv (domain);
      _nl_init_domain_conv (domain_file, domain, domainbinding);
    }

  if (
# ifdef _LIBC
      domain->conv != (__gconv_t) -1
# else
#  if HAVE_ICONV
      domain->conv != (iconv_t) -1
#  endif
# endif
      )
    {
      /* We are supposed to do a conversion.  First allocate an
	 appropriate table with the same structure as the table
	 of translations in the file, where we can put the pointers
	 to the converted strings in.
	 There is a slight complication with plural entries.  They
	 are represented by consecutive NUL terminated strings.  We
	 handle this case by converting RESULTLEN bytes, including
	 NULs.  */

      if (domain->conv_tab == NULL
	  && ((domain->conv_tab =
		 (char **) calloc (nstrings + domain->n_sysdep_strings,
				   sizeof (char *)))
	      == NULL))
	/* Mark that we didn't succeed allocating a table.  */
	domain->conv_tab = (char **) -1;

      if (__builtin_expect (domain->conv_tab == (char **) -1, 0))
	/* Nothing we can do, no more memory.  */
	goto converted;

      if (domain->conv_tab[act] == NULL)
	{
	  /* We haven't used this string so far, so it is not
	     translated yet.  Do this now.  */
	  /* We use a bit more efficient memory handling.
	     We allocate always larger blocks which get used over
	     time.  This is faster than many small allocations.   */
	  __libc_lock_define_initialized (static, lock)
# define INITIAL_BLOCK_SIZE	4080
	  static unsigned char *freemem;
	  static size_t freemem_size;

	  const unsigned char *inbuf;
	  unsigned char *outbuf;
	  int malloc_count;
# ifndef _LIBC
	  transmem_block_t *transmem_list = NULL;
# endif

	  __libc_lock_lock (lock);

	  inbuf = (const unsigned char *) result;
	  outbuf = freemem + sizeof (size_t);

	  malloc_count = 0;
	  while (1)
	    {
	      transmem_block_t *newmem;
# ifdef _LIBC
	      size_t non_reversible;
	      int res;

	      if (freemem_size < sizeof (size_t))
		goto resize_freemem;

	      res = __gconv (domain->conv,
			     &inbuf, inbuf + resultlen,
			     &outbuf,
			     outbuf + freemem_size - sizeof (size_t),
			     &non_reversible);

	      if (res == __GCONV_OK || res == __GCONV_EMPTY_INPUT)
		break;

	      if (res != __GCONV_FULL_OUTPUT)
		{
		  __libc_lock_unlock (lock);
		  goto converted;
		}

	      inbuf = result;
# else
#  if HAVE_ICONV
	      const char *inptr = (const char *) inbuf;
	      size_t inleft = resultlen;
	      char *outptr = (char *) outbuf;
	      size_t outleft;

	      if (freemem_size < sizeof (size_t))
		goto resize_freemem;

	      outleft = freemem_size - sizeof (size_t);
	      if (iconv (domain->conv,
			 (ICONV_CONST char **) &inptr, &inleft,
			 &outptr, &outleft)
		  != (size_t) (-1))
		{
		  outbuf = (unsigned char *) outptr;
		  break;
		}
	      if (errno != E2BIG)
		{
		  __libc_lock_unlock (lock);
		  goto converted;
		}
#  endif
# endif

	    resize_freemem:
	      /* We must allocate a new buffer or resize the old one.  */
	      if (malloc_count > 0)
		{
		  ++malloc_count;
		  freemem_size = malloc_count * INITIAL_BLOCK_SIZE;
		  newmem = (transmem_block_t *) realloc (transmem_list,
							 freemem_size);
# ifdef _LIBC
		  if (newmem != NULL)
		    transmem_list = transmem_list->next;
		  else
		    {
		      struct transmem_list *old = transmem_list;

		      transmem_list = transmem_list->next;
		      free (old);
		    }
# endif
		}
	      else
		{
		  malloc_count = 1;
		  freemem_size = INITIAL_BLOCK_SIZE;
		  newmem = (transmem_block_t *) malloc (freemem_size);
		}
	      if (__builtin_expect (newmem == NULL, 0))
		{
		  freemem = NULL;
		  freemem_size = 0;
		  __libc_lock_unlock (lock);
		  goto converted;
		}

# ifdef _LIBC
	      /* Add the block to the list of blocks we have to free
                 at some point.  */
	      newmem->next = transmem_list;
	      transmem_list = newmem;

	      freemem = newmem->data;
	      freemem_size -= offsetof (struct transmem_list, data);
# else
	      transmem_list = newmem;
	      freemem = newmem;
# endif

	      outbuf = freemem + sizeof (size_t);
	    }

	  /* We have now in our buffer a converted string.  Put this
	     into the table of conversions.  */
	  *(size_t *) freemem = outbuf - freemem - sizeof (size_t);
	  domain->conv_tab[act] = (char *) freemem;
	  /* Shrink freemem, but keep it aligned.  */
	  freemem_size -= outbuf - freemem;
	  freemem = outbuf;
	  freemem += freemem_size & (alignof (size_t) - 1);
	  freemem_size = freemem_size & ~ (alignof (size_t) - 1);

	  __libc_lock_unlock (lock);
	}

      /* Now domain->conv_tab[act] contains the translation of all
	 the plural variants.  */
      result = domain->conv_tab[act] + sizeof (size_t);
      resultlen = *(size_t *) domain->conv_tab[act];
    }

 converted:
  /* The result string is converted.  */

#endif /* _LIBC || HAVE_ICONV */

  *lengthp = resultlen;
  return result;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\intl\dcigettext.c:742
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\intl\dcigettext.c:1,048
parsing error 
{
  struct loaded_domain *domaindata = (struct loaded_domain *) domain->data;
  unsigned long int index;
  const char *p;

  index = plural_eval (domaindata->plural, n);
  if (index >= domaindata->nplurals)
    /* This should never happen.  It means the plural expression and the
       given maximum value do not match.  */
    index = 0;

  /* Skip INDEX strings at TRANSLATION.  */
  p = translation;
  while (index-- > 0)
    {
#ifdef _LIBC
      p = __rawmemchr (p, '\0');
#else
      p = strchr (p, '\0');
#endif
      /* And skip over the NUL byte.  */
      p++;

      if (p >= translation + translation_len)
	/* This should never happen.  It means the plural expression
	   evaluated to a value larger than the number of variants
	   available for MSGID1.  */
	return (char *) translation;
    }
  return (char *) p;
}
warning: parse error {
  struct loaded_domain *domaindata = (struct loaded_domain *) domain->data;
  unsigned long int index;
  const char *p;

  index = plural_eval (domaindata->plural, n);
  if (index >= domaindata->nplurals)
    /* This should never happen.  It means the plural expression and the
       given maximum value do not match.  */
    index = 0;

  /* Skip INDEX strings at TRANSLATION.  */
  p = translation;
  while (index-- > 0)
    {
#ifdef _LIBC
      p = __rawmemchr (p, '\0');
#else
      p = strchr (p, '\0');
#endif
      /* And skip over the NUL byte.  */
      p++;

      if (p >= translation + translation_len)
	/* This should never happen.  It means the plural expression
	   evaluated to a value larger than the number of variants
	   available for MSGID1.  */
	return (char *) translation;
    }
  return (char *) p;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\intl\dcigettext.c:1,053
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\intl\dcigettext.c:1,089
parsing error 
{
  const char *retval;

  switch (category)
  {
#ifdef LC_COLLATE
  case LC_COLLATE:
    retval = "LC_COLLATE";
    break;
#endif
#ifdef LC_CTYPE
  case LC_CTYPE:
    retval = "LC_CTYPE";
    break;
#endif
#ifdef LC_MONETARY
  case LC_MONETARY:
    retval = "LC_MONETARY";
    break;
#endif
#ifdef LC_NUMERIC
  case LC_NUMERIC:
    retval = "LC_NUMERIC";
    break;
#endif
#ifdef LC_TIME
  case LC_TIME:
    retval = "LC_TIME";
    break;
#endif
#ifdef LC_MESSAGES
  case LC_MESSAGES:
    retval = "LC_MESSAGES";
    break;
#endif
#ifdef LC_RESPONSE
  case LC_RESPONSE:
    retval = "LC_RESPONSE";
    break;
#endif
#ifdef LC_ALL
  case LC_ALL:
    /* This might not make sense but is perhaps better than any other
       value.  */
    retval = "LC_ALL";
    break;
#endif
  default:
    /* If you have a better idea for a default value let me know.  */
    retval = "LC_XXX";
  }

  return retval;
}
warning: parse error {
  const char *retval;

  switch (category)
  {
#ifdef LC_COLLATE
  case LC_COLLATE:
    retval = "LC_COLLATE";
    break;
#endif
#ifdef LC_CTYPE
  case LC_CTYPE:
    retval = "LC_CTYPE";
    break;
#endif
#ifdef LC_MONETARY
  case LC_MONETARY:
    retval = "LC_MONETARY";
    break;
#endif
#ifdef LC_NUMERIC
  case LC_NUMERIC:
    retval = "LC_NUMERIC";
    break;
#endif
#ifdef LC_TIME
  case LC_TIME:
    retval = "LC_TIME";
    break;
#endif
#ifdef LC_MESSAGES
  case LC_MESSAGES:
    retval = "LC_MESSAGES";
    break;
#endif
#ifdef LC_RESPONSE
  case LC_RESPONSE:
    retval = "LC_RESPONSE";
    break;
#endif
#ifdef LC_ALL
  case LC_ALL:
    /* This might not make sense but is perhaps better than any other
       value.  */
    retval = "LC_ALL";
    break;
#endif
  default:
    /* If you have a better idea for a default value let me know.  */
    retval = "LC_XXX";
  }

  return retval;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\intl\dcigettext.c:1,091
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\intl\dcigettext.c:1,150
parsing error 
{
  const char *language;
  const char *retval;

  /* The highest priority value is the `LANGUAGE' environment
     variable.  But we don't use the value if the currently selected
     locale is the C locale.  This is a GNU extension.  */
  language = getenv ("LANGUAGE");
  if (language != NULL && language[0] == '\0')
    language = NULL;

  /* We have to proceed with the POSIX methods of looking to `LC_ALL',
     `LC_xxx', and `LANG'.  On some systems this can be done by the
     `setlocale' function itself.  */
#ifdef _LIBC
  retval = __current_locale_name (category);
#else
  retval = _nl_locale_name (category, categoryname);
#endif

  /* Ignore LANGUAGE if the locale is set to "C" because
     1. "C" locale usually uses the ASCII encoding, and most international
	messages use non-ASCII characters. These characters get displayed
	as question marks (if using glibc's iconv()) or as invalid 8-bit
	characters (because other iconv()s refuse to convert most non-ASCII
	characters to ASCII). In any case, the output is ugly.
     2. The precise output of some programs in the "C" locale is specified
	by POSIX and should not depend on environment variables like
	"LANGUAGE".  We allow such programs to use gettext().  */
  return language != NULL && strcmp (retval, "C") != 0 ? language : retval;
}
warning: parse error {
  const char *language;
  const char *retval;

  /* The highest priority value is the `LANGUAGE' environment
     variable.  But we don't use the value if the currently selected
     locale is the C locale.  This is a GNU extension.  */
  language = getenv ("LANGUAGE");
  if (language != NULL && language[0] == '\0')
    language = NULL;

  /* We have to proceed with the POSIX methods of looking to `LC_ALL',
     `LC_xxx', and `LANG'.  On some systems this can be done by the
     `setlocale' function itself.  */
#ifdef _LIBC
  retval = __current_locale_name (category);
#else
  retval = _nl_locale_name (category, categoryname);
#endif

  /* Ignore LANGUAGE if the locale is set to "C" because
     1. "C" locale usually uses the ASCII encoding, and most international
	messages use non-ASCII characters. These characters get displayed
	as question marks (if using glibc's iconv()) or as invalid 8-bit
	characters (because other iconv()s refuse to convert most non-ASCII
	characters to ASCII). In any case, the output is ugly.
     2. The precise output of some programs in the "C" locale is specified
	by POSIX and should not depend on environment variables like
	"LANGUAGE".  We allow such programs to use gettext().  */
  return language != NULL && strcmp (retval, "C") != 0 ? language : retval;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\intl\dcigettext.c:1,153
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\intl\dcigettext.c:1,193
parsing error 
{
  while ((*dest++ = *src++) != '\0')
    /* Do nothing. */ ;
  return dest - 1;
}
warning: parse error {
  while ((*dest++ = *src++) != '\0')
    /* Do nothing. */ ;
  return dest - 1;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\intl\dcigettext.c:1,196
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\intl\dcigettext.c:1,205
parsing error 
{
  return (void *) ((char *) memcpy (dest, src, n) + n);
}
warning: parse error {
  return (void *) ((char *) memcpy (dest, src, n) + n);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\intl\dcigettext.c:1,209
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\intl\dcngettext.c...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\intl\gettextP.h...skip
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\intl\dcngettext.c:50
parsing error 
{
  return DCIGETTEXT (domainname, msgid1, msgid2, 1, n, category);
}
warning: parse error {
  return DCIGETTEXT (domainname, msgid1, msgid2, 1, n, category);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\intl\dcngettext.c:55
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\intl\dgettext.c...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\intl\gettextP.h...skip
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\intl\dgettext.c:52
parsing error 
{
  return DCGETTEXT (domainname, msgid, LC_MESSAGES);
}
warning: parse error {
  return DCGETTEXT (domainname, msgid, LC_MESSAGES);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\intl\dgettext.c:54
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\intl\dngettext.c...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\intl\gettextP.h...skip
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\intl\dngettext.c:52
parsing error 
{
  return DCNGETTEXT (domainname, msgid1, msgid2, n, LC_MESSAGES);
}
warning: parse error {
  return DCNGETTEXT (domainname, msgid1, msgid2, n, LC_MESSAGES);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\intl\dngettext.c:56
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\intl\explodename.c...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\intl\loadinfo.h...skip
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\intl\explodename.c:45
parsing error 
{
  while (name[0] != '\0' && name[0] != '_' && name[0] != '@'
	 && name[0] != '+' && name[0] != ',')
    ++name;

  return (char *) name;
}
warning: parse error {
  while (name[0] != '\0' && name[0] != '_' && name[0] != '@'
	 && name[0] != '+' && name[0] != ',')
    ++name;

  return (char *) name;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\intl\explodename.c:46
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\intl\explodename.c:57
parsing error 
{
  enum { undecided, xpg, cen } syntax;
  char *cp;
  int mask;

  *modifier = NULL;
  *territory = NULL;
  *codeset = NULL;
  *normalized_codeset = NULL;
  *special = NULL;
  *sponsor = NULL;
  *revision = NULL;

  /* Now we determine the single parts of the locale name.  First
     look for the language.  Termination symbols are `_' and `@' if
     we use XPG4 style, and `_', `+', and `,' if we use CEN syntax.  */
  mask = 0;
  syntax = undecided;
  *language = cp = name;
  cp = _nl_find_language (*language);

  if (*language == cp)
    /* This does not make sense: language has to be specified.  Use
       this entry as it is without exploding.  Perhaps it is an alias.  */
    cp = strchr (*language, '\0');
  else if (cp[0] == '_')
    {
      /* Next is the territory.  */
      cp[0] = '\0';
      *territory = ++cp;

      while (cp[0] != '\0' && cp[0] != '.' && cp[0] != '@'
	     && cp[0] != '+' && cp[0] != ',' && cp[0] != '_')
	++cp;

      mask |= TERRITORY;

      if (cp[0] == '.')
	{
	  /* Next is the codeset.  */
	  syntax = xpg;
	  cp[0] = '\0';
	  *codeset = ++cp;

	  while (cp[0] != '\0' && cp[0] != '@')
	    ++cp;

	  mask |= XPG_CODESET;

	  if (*codeset != cp && (*codeset)[0] != '\0')
	    {
	      *normalized_codeset = _nl_normalize_codeset (*codeset,
							   cp - *codeset);
	      if (strcmp (*codeset, *normalized_codeset) == 0)
		free ((char *) *normalized_codeset);
	      else
		mask |= XPG_NORM_CODESET;
	    }
	}
    }

  if (cp[0] == '@' || (syntax != xpg && cp[0] == '+'))
    {
      /* Next is the modifier.  */
      syntax = cp[0] == '@' ? xpg : cen;
      cp[0] = '\0';
      *modifier = ++cp;

      while (syntax == cen && cp[0] != '\0' && cp[0] != '+'
	     && cp[0] != ',' && cp[0] != '_')
	++cp;

      mask |= XPG_MODIFIER | CEN_AUDIENCE;
    }

  if (syntax != xpg && (cp[0] == '+' || cp[0] == ',' || cp[0] == '_'))
    {
      syntax = cen;

      if (cp[0] == '+')
	{
 	  /* Next is special application (CEN syntax).  */
	  cp[0] = '\0';
	  *special = ++cp;

	  while (cp[0] != '\0' && cp[0] != ',' && cp[0] != '_')
	    ++cp;

	  mask |= CEN_SPECIAL;
	}

      if (cp[0] == ',')
	{
 	  /* Next is sponsor (CEN syntax).  */
	  cp[0] = '\0';
	  *sponsor = ++cp;

	  while (cp[0] != '\0' && cp[0] != '_')
	    ++cp;

	  mask |= CEN_SPONSOR;
	}

      if (cp[0] == '_')
	{
 	  /* Next is revision (CEN syntax).  */
	  cp[0] = '\0';
	  *revision = ++cp;

	  mask |= CEN_REVISION;
	}
    }

  /* For CEN syntax values it might be important to have the
     separator character in the file name, not for XPG syntax.  */
  if (syntax == xpg)
    {
      if (*territory != NULL && (*territory)[0] == '\0')
	mask &= ~TERRITORY;

      if (*codeset != NULL && (*codeset)[0] == '\0')
	mask &= ~XPG_CODESET;

      if (*modifier != NULL && (*modifier)[0] == '\0')
	mask &= ~XPG_MODIFIER;
    }

  return mask;
}
warning: parse error {
  enum { undecided, xpg, cen } syntax;
  char *cp;
  int mask;

  *modifier = NULL;
  *territory = NULL;
  *codeset = NULL;
  *normalized_codeset = NULL;
  *special = NULL;
  *sponsor = NULL;
  *revision = NULL;

  /* Now we determine the single parts of the locale name.  First
     look for the language.  Termination symbols are `_' and `@' if
     we use XPG4 style, and `_', `+', and `,' if we use CEN syntax.  */
  mask = 0;
  syntax = undecided;
  *language = cp = name;
  cp = _nl_find_language (*language);

  if (*language == cp)
    /* This does not make sense: language has to be specified.  Use
       this entry as it is without exploding.  Perhaps it is an alias.  */
    cp = strchr (*language, '\0');
  else if (cp[0] == '_')
    {
      /* Next is the territory.  */
      cp[0] = '\0';
      *territory = ++cp;

      while (cp[0] != '\0' && cp[0] != '.' && cp[0] != '@'
	     && cp[0] != '+' && cp[0] != ',' && cp[0] != '_')
	++cp;

      mask |= TERRITORY;

      if (cp[0] == '.')
	{
	  /* Next is the codeset.  */
	  syntax = xpg;
	  cp[0] = '\0';
	  *codeset = ++cp;

	  while (cp[0] != '\0' && cp[0] != '@')
	    ++cp;

	  mask |= XPG_CODESET;

	  if (*codeset != cp && (*codeset)[0] != '\0')
	    {
	      *normalized_codeset = _nl_normalize_codeset (*codeset,
							   cp - *codeset);
	      if (strcmp (*codeset, *normalized_codeset) == 0)
		free ((char *) *normalized_codeset);
	      else
		mask |= XPG_NORM_CODESET;
	    }
	}
    }

  if (cp[0] == '@' || (syntax != xpg && cp[0] == '+'))
    {
      /* Next is the modifier.  */
      syntax = cp[0] == '@' ? xpg : cen;
      cp[0] = '\0';
      *modifier = ++cp;

      while (syntax == cen && cp[0] != '\0' && cp[0] != '+'
	     && cp[0] != ',' && cp[0] != '_')
	++cp;

      mask |= XPG_MODIFIER | CEN_AUDIENCE;
    }

  if (syntax != xpg && (cp[0] == '+' || cp[0] == ',' || cp[0] == '_'))
    {
      syntax = cen;

      if (cp[0] == '+')
	{
 	  /* Next is special application (CEN syntax).  */
	  cp[0] = '\0';
	  *special = ++cp;

	  while (cp[0] != '\0' && cp[0] != ',' && cp[0] != '_')
	    ++cp;

	  mask |= CEN_SPECIAL;
	}

      if (cp[0] == ',')
	{
 	  /* Next is sponsor (CEN syntax).  */
	  cp[0] = '\0';
	  *sponsor = ++cp;

	  while (cp[0] != '\0' && cp[0] != '_')
	    ++cp;

	  mask |= CEN_SPONSOR;
	}

      if (cp[0] == '_')
	{
 	  /* Next is revision (CEN syntax).  */
	  cp[0] = '\0';
	  *revision = ++cp;

	  mask |= CEN_REVISION;
	}
    }

  /* For CEN syntax values it might be important to have the
     separator character in the file name, not for XPG syntax.  */
  if (syntax == xpg)
    {
      if (*territory != NULL && (*territory)[0] == '\0')
	mask &= ~TERRITORY;

      if (*codeset != NULL && (*codeset)[0] == '\0')
	mask &= ~XPG_CODESET;

      if (*modifier != NULL && (*modifier)[0] == '\0')
	mask &= ~XPG_MODIFIER;
    }

  return mask;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\intl\explodename.c:67
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\intl\finddomain.c...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\intl\gettextP.h...skip
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\intl\finddomain.c:53
parsing error 
{
  struct loaded_l10nfile *retval;
  const char *language;
  const char *modifier;
  const char *territory;
  const char *codeset;
  const char *normalized_codeset;
  const char *special;
  const char *sponsor;
  const char *revision;
  const char *alias_value;
  int mask;

  /* LOCALE can consist of up to four recognized parts for the XPG syntax:

		language[_territory[.codeset]][@modifier]

     and six parts for the CEN syntax:

	language[_territory][+audience][+special][,[sponsor][_revision]]

     Beside the first part all of them are allowed to be missing.  If
     the full specified locale is not found, the less specific one are
     looked for.  The various parts will be stripped off according to
     the following order:
		(1) revision
		(2) sponsor
		(3) special
		(4) codeset
		(5) normalized codeset
		(6) territory
		(7) audience/modifier
   */

  /* If we have already tested for this locale entry there has to
     be one data set in the list of loaded domains.  */
  retval = _nl_make_l10nflist (&_nl_loaded_domains, dirname,
			       strlen (dirname) + 1, 0, locale, NULL, NULL,
			       NULL, NULL, NULL, NULL, NULL, domainname, 0);
  if (retval != NULL)
    {
      /* We know something about this locale.  */
      int cnt;

      if (retval->decided == 0)
	_nl_load_domain (retval, domainbinding);

      if (retval->data != NULL)
	return retval;

      for (cnt = 0; retval->successor[cnt] != NULL; ++cnt)
	{
	  if (retval->successor[cnt]->decided == 0)
	    _nl_load_domain (retval->successor[cnt], domainbinding);

	  if (retval->successor[cnt]->data != NULL)
	    break;
	}
      return cnt >= 0 ? retval : NULL;
      /* NOTREACHED */
    }

  /* See whether the locale value is an alias.  If yes its value
     *overwrites* the alias name.  No test for the original value is
     done.  */
  alias_value = _nl_expand_alias (locale);
  if (alias_value != NULL)
    {
#if defined _LIBC || defined HAVE_STRDUP
      locale = strdup (alias_value);
      if (locale == NULL)
	return NULL;
#else
      size_t len = strlen (alias_value) + 1;
      locale = (char *) malloc (len);
      if (locale == NULL)
	return NULL;

      memcpy (locale, alias_value, len);
#endif
    }

  /* Now we determine the single parts of the locale name.  First
     look for the language.  Termination symbols are `_' and `@' if
     we use XPG4 style, and `_', `+', and `,' if we use CEN syntax.  */
  mask = _nl_explode_name (locale, &language, &modifier, &territory,
			   &codeset, &normalized_codeset, &special,
			   &sponsor, &revision);

  /* Create all possible locale entries which might be interested in
     generalization.  */
  retval = _nl_make_l10nflist (&_nl_loaded_domains, dirname,
			       strlen (dirname) + 1, mask, language, territory,
			       codeset, normalized_codeset, modifier, special,
			       sponsor, revision, domainname, 1);
  if (retval == NULL)
    /* This means we are out of core.  */
    return NULL;

  if (retval->decided == 0)
    _nl_load_domain (retval, domainbinding);
  if (retval->data == NULL)
    {
      int cnt;
      for (cnt = 0; retval->successor[cnt] != NULL; ++cnt)
	{
	  if (retval->successor[cnt]->decided == 0)
	    _nl_load_domain (retval->successor[cnt], domainbinding);
	  if (retval->successor[cnt]->data != NULL)
	    break;
	}
    }

  /* The room for an alias was dynamically allocated.  Free it now.  */
  if (alias_value != NULL)
    free (locale);

  /* The space for normalized_codeset is dynamically allocated.  Free it.  */
  if (mask & XPG_NORM_CODESET)
    free ((void *) normalized_codeset);

  return retval;
}
warning: parse error {
  struct loaded_l10nfile *retval;
  const char *language;
  const char *modifier;
  const char *territory;
  const char *codeset;
  const char *normalized_codeset;
  const char *special;
  const char *sponsor;
  const char *revision;
  const char *alias_value;
  int mask;

  /* LOCALE can consist of up to four recognized parts for the XPG syntax:

		language[_territory[.codeset]][@modifier]

     and six parts for the CEN syntax:

	language[_territory][+audience][+special][,[sponsor][_revision]]

     Beside the first part all of them are allowed to be missing.  If
     the full specified locale is not found, the less specific one are
     looked for.  The various parts will be stripped off according to
     the following order:
		(1) revision
		(2) sponsor
		(3) special
		(4) codeset
		(5) normalized codeset
		(6) territory
		(7) audience/modifier
   */

  /* If we have already tested for this locale entry there has to
     be one data set in the list of loaded domains.  */
  retval = _nl_make_l10nflist (&_nl_loaded_domains, dirname,
			       strlen (dirname) + 1, 0, locale, NULL, NULL,
			       NULL, NULL, NULL, NULL, NULL, domainname, 0);
  if (retval != NULL)
    {
      /* We know something about this locale.  */
      int cnt;

      if (retval->decided == 0)
	_nl_load_domain (retval, domainbinding);

      if (retval->data != NULL)
	return retval;

      for (cnt = 0; retval->successor[cnt] != NULL; ++cnt)
	{
	  if (retval->successor[cnt]->decided == 0)
	    _nl_load_domain (retval->successor[cnt], domainbinding);

	  if (retval->successor[cnt]->data != NULL)
	    break;
	}
      return cnt >= 0 ? retval : NULL;
      /* NOTREACHED */
    }

  /* See whether the locale value is an alias.  If yes its value
     *overwrites* the alias name.  No test for the original value is
     done.  */
  alias_value = _nl_expand_alias (locale);
  if (alias_value != NULL)
    {
#if defined _LIBC || defined HAVE_STRDUP
      locale = strdup (alias_value);
      if (locale == NULL)
	return NULL;
#else
      size_t len = strlen (alias_value) + 1;
      locale = (char *) malloc (len);
      if (locale == NULL)
	return NULL;

      memcpy (locale, alias_value, len);
#endif
    }

  /* Now we determine the single parts of the locale name.  First
     look for the language.  Termination symbols are `_' and `@' if
     we use XPG4 style, and `_', `+', and `,' if we use CEN syntax.  */
  mask = _nl_explode_name (locale, &language, &modifier, &territory,
			   &codeset, &normalized_codeset, &special,
			   &sponsor, &revision);

  /* Create all possible locale entries which might be interested in
     generalization.  */
  retval = _nl_make_l10nflist (&_nl_loaded_domains, dirname,
			       strlen (dirname) + 1, mask, language, territory,
			       codeset, normalized_codeset, modifier, special,
			       sponsor, revision, domainname, 1);
  if (retval == NULL)
    /* This means we are out of core.  */
    return NULL;

  if (retval->decided == 0)
    _nl_load_domain (retval, domainbinding);
  if (retval->data == NULL)
    {
      int cnt;
      for (cnt = 0; retval->successor[cnt] != NULL; ++cnt)
	{
	  if (retval->successor[cnt]->decided == 0)
	    _nl_load_domain (retval->successor[cnt], domainbinding);
	  if (retval->successor[cnt]->data != NULL)
	    break;
	}
    }

  /* The room for an alias was dynamically allocated.  Free it now.  */
  if (alias_value != NULL)
    free (locale);

  /* The space for normalized_codeset is dynamically allocated.  Free it.  */
  if (mask & XPG_NORM_CODESET)
    free ((void *) normalized_codeset);

  return retval;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\intl\finddomain.c:57
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\intl\gettext.c...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\intl\gettextP.h...skip
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\intl\gettext.c:58
parsing error 
{
  return DCGETTEXT (NULL, msgid, LC_MESSAGES);
}
warning: parse error {
  return DCGETTEXT (NULL, msgid, LC_MESSAGES);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\intl\gettext.c:59
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\intl\intl-compat.c...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\intl\gettextP.h...skip
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\intl\intl-compat.c:63
parsing error 
{
  return libintl_gettext (msgid);
}
warning: parse error {
  return libintl_gettext (msgid);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\intl\intl-compat.c:64
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\intl\intl-compat.c:72
parsing error 
{
  return libintl_dgettext (domainname, msgid);
}
warning: parse error {
  return libintl_dgettext (domainname, msgid);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\intl\intl-compat.c:74
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\intl\intl-compat.c:82
parsing error 
{
  return libintl_dcgettext (domainname, msgid, category);
}
warning: parse error {
  return libintl_dcgettext (domainname, msgid, category);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\intl\intl-compat.c:85
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\intl\intl-compat.c:93
parsing error 
{
  return libintl_ngettext (msgid1, msgid2, n);
}
warning: parse error {
  return libintl_ngettext (msgid1, msgid2, n);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\intl\intl-compat.c:96
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\intl\intl-compat.c:104
parsing error 
{
  return libintl_dngettext (domainname, msgid1, msgid2, n);
}
warning: parse error {
  return libintl_dngettext (domainname, msgid1, msgid2, n);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\intl\intl-compat.c:108
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\intl\intl-compat.c:116
parsing error 
{
  return libintl_dcngettext (domainname, msgid1, msgid2, n, category);
}
warning: parse error {
  return libintl_dcngettext (domainname, msgid1, msgid2, n, category);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\intl\intl-compat.c:121
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\intl\intl-compat.c:129
parsing error 
{
  return libintl_textdomain (domainname);
}
warning: parse error {
  return libintl_textdomain (domainname);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\intl\intl-compat.c:130
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\intl\intl-compat.c:138
parsing error 
{
  return libintl_bindtextdomain (domainname, dirname);
}
warning: parse error {
  return libintl_bindtextdomain (domainname, dirname);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\intl\intl-compat.c:140
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\intl\intl-compat.c:148
parsing error 
{
  return libintl_bind_textdomain_codeset (domainname, codeset);
}
warning: parse error {
  return libintl_bind_textdomain_codeset (domainname, codeset);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\intl\intl-compat.c:150
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\intl\l10nflist.c...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\intl\loadinfo.h...skip
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\intl\l10nflist.c:94
parsing error 
{
  size_t count = 0;
  while (len > 0)
    {
      size_t part_len = strlen (argz);
      argz += part_len + 1;
      len -= part_len + 1;
      count++;
    }
  return count;
}
warning: parse error {
  size_t count = 0;
  while (len > 0)
    {
      size_t part_len = strlen (argz);
      argz += part_len + 1;
      len -= part_len + 1;
      count++;
    }
  return count;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\intl\l10nflist.c:96
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\intl\l10nflist.c:121
parsing error 
{
  while (len > 0)
    {
      size_t part_len = strlen (argz);
      argz += part_len;
      len -= part_len + 1;
      if (len > 0)
	*argz++ = sep;
    }
}
warning: parse error {
  while (len > 0)
    {
      size_t part_len = strlen (argz);
      argz += part_len;
      len -= part_len + 1;
      if (len > 0)
	*argz++ = sep;
    }
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\intl\l10nflist.c:125
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\intl\l10nflist.c:149
parsing error 
{
  if (entry)
    {
      if (entry < argz + argz_len)
        entry = strchr (entry, '\0') + 1;

      return entry >= argz + argz_len ? NULL : (char *) entry;
    }
  else
    if (argz_len > 0)
      return argz;
    else
      return 0;
}
warning: parse error {
  if (entry)
    {
      if (entry < argz + argz_len)
        entry = strchr (entry, '\0') + 1;

      return entry >= argz + argz_len ? NULL : (char *) entry;
    }
  else
    if (argz_len > 0)
      return argz;
    else
      return 0;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\intl\l10nflist.c:153
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\intl\l10nflist.c:176
parsing error 
{
  /* We assume that no more than 16 bits are used.  */
  x = ((x & ~0x5555) >> 1) + (x & 0x5555);
  x = ((x & ~0x3333) >> 2) + (x & 0x3333);
  x = ((x >> 4) + x) & 0x0f0f;
  x = ((x >> 8) + x) & 0xff;

  return x;
}
warning: parse error {
  /* We assume that no more than 16 bits are used.  */
  x = ((x & ~0x5555) >> 1) + (x & 0x5555);
  x = ((x & ~0x3333) >> 2) + (x & 0x3333);
  x = ((x >> 4) + x) & 0x0f0f;
  x = ((x >> 8) + x) & 0xff;

  return x;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\intl\l10nflist.c:178
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\intl\l10nflist.c:192
parsing error 
{
  char *abs_filename;
  struct loaded_l10nfile **lastp;
  struct loaded_l10nfile *retval;
  char *cp;
  size_t dirlist_count;
  size_t entries;
  int cnt;

  /* If LANGUAGE contains an absolute directory specification, we ignore
     DIRLIST.  */
  if (IS_ABSOLUTE_PATH (language))
    dirlist_len = 0;

  /* Allocate room for the full file name.  */
  abs_filename = (char *) malloc (dirlist_len
				  + strlen (language)
				  + ((mask & TERRITORY) != 0
				     ? strlen (territory) + 1 : 0)
				  + ((mask & XPG_CODESET) != 0
				     ? strlen (codeset) + 1 : 0)
				  + ((mask & XPG_NORM_CODESET) != 0
				     ? strlen (normalized_codeset) + 1 : 0)
				  + (((mask & XPG_MODIFIER) != 0
				      || (mask & CEN_AUDIENCE) != 0)
				     ? strlen (modifier) + 1 : 0)
				  + ((mask & CEN_SPECIAL) != 0
				     ? strlen (special) + 1 : 0)
				  + (((mask & CEN_SPONSOR) != 0
				      || (mask & CEN_REVISION) != 0)
				     ? (1 + ((mask & CEN_SPONSOR) != 0
					     ? strlen (sponsor) : 0)
					+ ((mask & CEN_REVISION) != 0
					   ? strlen (revision) + 1 : 0)) : 0)
				  + 1 + strlen (filename) + 1);

  if (abs_filename == NULL)
    return NULL;

  /* Construct file name.  */
  cp = abs_filename;
  if (dirlist_len > 0)
    {
      memcpy (cp, dirlist, dirlist_len);
      __argz_stringify (cp, dirlist_len, PATH_SEPARATOR);
      cp += dirlist_len;
      cp[-1] = '/';
    }

  cp = stpcpy (cp, language);

  if ((mask & TERRITORY) != 0)
    {
      *cp++ = '_';
      cp = stpcpy (cp, territory);
    }
  if ((mask & XPG_CODESET) != 0)
    {
      *cp++ = '.';
      cp = stpcpy (cp, codeset);
    }
  if ((mask & XPG_NORM_CODESET) != 0)
    {
      *cp++ = '.';
      cp = stpcpy (cp, normalized_codeset);
    }
  if ((mask & (XPG_MODIFIER | CEN_AUDIENCE)) != 0)
    {
      /* This component can be part of both syntaces but has different
	 leading characters.  For CEN we use `+', else `@'.  */
      *cp++ = (mask & CEN_AUDIENCE) != 0 ? '+' : '@';
      cp = stpcpy (cp, modifier);
    }
  if ((mask & CEN_SPECIAL) != 0)
    {
      *cp++ = '+';
      cp = stpcpy (cp, special);
    }
  if ((mask & (CEN_SPONSOR | CEN_REVISION)) != 0)
    {
      *cp++ = ',';
      if ((mask & CEN_SPONSOR) != 0)
	cp = stpcpy (cp, sponsor);
      if ((mask & CEN_REVISION) != 0)
	{
	  *cp++ = '_';
	  cp = stpcpy (cp, revision);
	}
    }

  *cp++ = '/';
  stpcpy (cp, filename);

  /* Look in list of already loaded domains whether it is already
     available.  */
  lastp = l10nfile_list;
  for (retval = *l10nfile_list; retval != NULL; retval = retval->next)
    if (retval->filename != NULL)
      {
	int compare = strcmp (retval->filename, abs_filename);
	if (compare == 0)
	  /* We found it!  */
	  break;
	if (compare < 0)
	  {
	    /* It's not in the list.  */
	    retval = NULL;
	    break;
	  }

	lastp = &retval->next;
      }

  if (retval != NULL || do_allocate == 0)
    {
      free (abs_filename);
      return retval;
    }

  dirlist_count = (dirlist_len > 0 ? __argz_count (dirlist, dirlist_len) : 1);

  /* Allocate a new loaded_l10nfile.  */
  retval =
    (struct loaded_l10nfile *)
    malloc (sizeof (*retval)
	    + (((dirlist_count << pop (mask)) + (dirlist_count > 1 ? 1 : 0))
	       * sizeof (struct loaded_l10nfile *)));
  if (retval == NULL)
    return NULL;

  retval->filename = abs_filename;

  /* We set retval->data to NULL here; it is filled in later.
     Setting retval->decided to 1 here means that retval does not
     correspond to a real file (dirlist_count > 1) or is not worth
     looking up (if an unnormalized codeset was specified).  */
  retval->decided = (dirlist_count > 1
		     || ((mask & XPG_CODESET) != 0
			 && (mask & XPG_NORM_CODESET) != 0));
  retval->data = NULL;

  retval->next = *lastp;
  *lastp = retval;

  entries = 0;
  /* Recurse to fill the inheritance list of RETVAL.
     If the DIRLIST is a real list (i.e. DIRLIST_COUNT > 1), the RETVAL
     entry does not correspond to a real file; retval->filename contains
     colons.  In this case we loop across all elements of DIRLIST and
     across all bit patterns dominated by MASK.
     If the DIRLIST is a single directory or entirely redundant (i.e.
     DIRLIST_COUNT == 1), we loop across all bit patterns dominated by
     MASK, excluding MASK itself.
     In either case, we loop down from MASK to 0.  This has the effect
     that the extra bits in the locale name are dropped in this order:
     first the modifier, then the territory, then the codeset, then the
     normalized_codeset.  */
  for (cnt = dirlist_count > 1 ? mask : mask - 1; cnt >= 0; --cnt)
    if ((cnt & ~mask) == 0
	&& ((cnt & CEN_SPECIFIC) == 0 || (cnt & XPG_SPECIFIC) == 0)
	&& ((cnt & XPG_CODESET) == 0 || (cnt & XPG_NORM_CODESET) == 0))
      {
	if (dirlist_count > 1)
	  {
	    /* Iterate over all elements of the DIRLIST.  */
	    char *dir = NULL;

	    while ((dir = __argz_next ((char *) dirlist, dirlist_len, dir))
		   != NULL)
	      retval->successor[entries++]
		= _nl_make_l10nflist (l10nfile_list, dir, strlen (dir) + 1,
				      cnt, language, territory, codeset,
				      normalized_codeset, modifier, special,
				      sponsor, revision, filename, 1);
	  }
	else
	  retval->successor[entries++]
	    = _nl_make_l10nflist (l10nfile_list, dirlist, dirlist_len,
				  cnt, language, territory, codeset,
				  normalized_codeset, modifier, special,
				  sponsor, revision, filename, 1);
      }
  retval->successor[entries] = NULL;

  return retval;
}
warning: parse error {
  char *abs_filename;
  struct loaded_l10nfile **lastp;
  struct loaded_l10nfile *retval;
  char *cp;
  size_t dirlist_count;
  size_t entries;
  int cnt;

  /* If LANGUAGE contains an absolute directory specification, we ignore
     DIRLIST.  */
  if (IS_ABSOLUTE_PATH (language))
    dirlist_len = 0;

  /* Allocate room for the full file name.  */
  abs_filename = (char *) malloc (dirlist_len
				  + strlen (language)
				  + ((mask & TERRITORY) != 0
				     ? strlen (territory) + 1 : 0)
				  + ((mask & XPG_CODESET) != 0
				     ? strlen (codeset) + 1 : 0)
				  + ((mask & XPG_NORM_CODESET) != 0
				     ? strlen (normalized_codeset) + 1 : 0)
				  + (((mask & XPG_MODIFIER) != 0
				      || (mask & CEN_AUDIENCE) != 0)
				     ? strlen (modifier) + 1 : 0)
				  + ((mask & CEN_SPECIAL) != 0
				     ? strlen (special) + 1 : 0)
				  + (((mask & CEN_SPONSOR) != 0
				      || (mask & CEN_REVISION) != 0)
				     ? (1 + ((mask & CEN_SPONSOR) != 0
					     ? strlen (sponsor) : 0)
					+ ((mask & CEN_REVISION) != 0
					   ? strlen (revision) + 1 : 0)) : 0)
				  + 1 + strlen (filename) + 1);

  if (abs_filename == NULL)
    return NULL;

  /* Construct file name.  */
  cp = abs_filename;
  if (dirlist_len > 0)
    {
      memcpy (cp, dirlist, dirlist_len);
      __argz_stringify (cp, dirlist_len, PATH_SEPARATOR);
      cp += dirlist_len;
      cp[-1] = '/';
    }

  cp = stpcpy (cp, language);

  if ((mask & TERRITORY) != 0)
    {
      *cp++ = '_';
      cp = stpcpy (cp, territory);
    }
  if ((mask & XPG_CODESET) != 0)
    {
      *cp++ = '.';
      cp = stpcpy (cp, codeset);
    }
  if ((mask & XPG_NORM_CODESET) != 0)
    {
      *cp++ = '.';
      cp = stpcpy (cp, normalized_codeset);
    }
  if ((mask & (XPG_MODIFIER | CEN_AUDIENCE)) != 0)
    {
      /* This component can be part of both syntaces but has different
	 leading characters.  For CEN we use `+', else `@'.  */
      *cp++ = (mask & CEN_AUDIENCE) != 0 ? '+' : '@';
      cp = stpcpy (cp, modifier);
    }
  if ((mask & CEN_SPECIAL) != 0)
    {
      *cp++ = '+';
      cp = stpcpy (cp, special);
    }
  if ((mask & (CEN_SPONSOR | CEN_REVISION)) != 0)
    {
      *cp++ = ',';
      if ((mask & CEN_SPONSOR) != 0)
	cp = stpcpy (cp, sponsor);
      if ((mask & CEN_REVISION) != 0)
	{
	  *cp++ = '_';
	  cp = stpcpy (cp, revision);
	}
    }

  *cp++ = '/';
  stpcpy (cp, filename);

  /* Look in list of already loaded domains whether it is already
     available.  */
  lastp = l10nfile_list;
  for (retval = *l10nfile_list; retval != NULL; retval = retval->next)
    if (retval->filename != NULL)
      {
	int compare = strcmp (retval->filename, abs_filename);
	if (compare == 0)
	  /* We found it!  */
	  break;
	if (compare < 0)
	  {
	    /* It's not in the list.  */
	    retval = NULL;
	    break;
	  }

	lastp = &retval->next;
      }

  if (retval != NULL || do_allocate == 0)
    {
      free (abs_filename);
      return retval;
    }

  dirlist_count = (dirlist_len > 0 ? __argz_count (dirlist, dirlist_len) : 1);

  /* Allocate a new loaded_l10nfile.  */
  retval =
    (struct loaded_l10nfile *)
    malloc (sizeof (*retval)
	    + (((dirlist_count << pop (mask)) + (dirlist_count > 1 ? 1 : 0))
	       * sizeof (struct loaded_l10nfile *)));
  if (retval == NULL)
    return NULL;

  retval->filename = abs_filename;

  /* We set retval->data to NULL here; it is filled in later.
     Setting retval->decided to 1 here means that retval does not
     correspond to a real file (dirlist_count > 1) or is not worth
     looking up (if an unnormalized codeset was specified).  */
  retval->decided = (dirlist_count > 1
		     || ((mask & XPG_CODESET) != 0
			 && (mask & XPG_NORM_CODESET) != 0));
  retval->data = NULL;

  retval->next = *lastp;
  *lastp = retval;

  entries = 0;
  /* Recurse to fill the inheritance list of RETVAL.
     If the DIRLIST is a real list (i.e. DIRLIST_COUNT > 1), the RETVAL
     entry does not correspond to a real file; retval->filename contains
     colons.  In this case we loop across all elements of DIRLIST and
     across all bit patterns dominated by MASK.
     If the DIRLIST is a single directory or entirely redundant (i.e.
     DIRLIST_COUNT == 1), we loop across all bit patterns dominated by
     MASK, excluding MASK itself.
     In either case, we loop down from MASK to 0.  This has the effect
     that the extra bits in the locale name are dropped in this order:
     first the modifier, then the territory, then the codeset, then the
     normalized_codeset.  */
  for (cnt = dirlist_count > 1 ? mask : mask - 1; cnt >= 0; --cnt)
    if ((cnt & ~mask) == 0
	&& ((cnt & CEN_SPECIFIC) == 0 || (cnt & XPG_SPECIFIC) == 0)
	&& ((cnt & XPG_CODESET) == 0 || (cnt & XPG_NORM_CODESET) == 0))
      {
	if (dirlist_count > 1)
	  {
	    /* Iterate over all elements of the DIRLIST.  */
	    char *dir = NULL;

	    while ((dir = __argz_next ((char *) dirlist, dirlist_len, dir))
		   != NULL)
	      retval->successor[entries++]
		= _nl_make_l10nflist (l10nfile_list, dir, strlen (dir) + 1,
				      cnt, language, territory, codeset,
				      normalized_codeset, modifier, special,
				      sponsor, revision, filename, 1);
	  }
	else
	  retval->successor[entries++]
	    = _nl_make_l10nflist (l10nfile_list, dirlist, dirlist_len,
				  cnt, language, territory, codeset,
				  normalized_codeset, modifier, special,
				  sponsor, revision, filename, 1);
      }
  retval->successor[entries] = NULL;

  return retval;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\intl\l10nflist.c:207
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\intl\l10nflist.c:400
parsing error 
{
  int len = 0;
  int only_digit = 1;
  char *retval;
  char *wp;
  size_t cnt;

  for (cnt = 0; cnt < name_len; ++cnt)
    if (isalnum ((unsigned char) codeset[cnt]))
      {
	++len;

	if (isalpha ((unsigned char) codeset[cnt]))
	  only_digit = 0;
      }

  retval = (char *) malloc ((only_digit ? 3 : 0) + len + 1);

  if (retval != NULL)
    {
      if (only_digit)
	wp = stpcpy (retval, "iso");
      else
	wp = retval;

      for (cnt = 0; cnt < name_len; ++cnt)
	if (isalpha ((unsigned char) codeset[cnt]))
	  *wp++ = tolower ((unsigned char) codeset[cnt]);
	else if (isdigit ((unsigned char) codeset[cnt]))
	  *wp++ = codeset[cnt];

      *wp = '\0';
    }

  return (const char *) retval;
}
warning: parse error {
  int len = 0;
  int only_digit = 1;
  char *retval;
  char *wp;
  size_t cnt;

  for (cnt = 0; cnt < name_len; ++cnt)
    if (isalnum ((unsigned char) codeset[cnt]))
      {
	++len;

	if (isalpha ((unsigned char) codeset[cnt]))
	  only_digit = 0;
      }

  retval = (char *) malloc ((only_digit ? 3 : 0) + len + 1);

  if (retval != NULL)
    {
      if (only_digit)
	wp = stpcpy (retval, "iso");
      else
	wp = retval;

      for (cnt = 0; cnt < name_len; ++cnt)
	if (isalpha ((unsigned char) codeset[cnt]))
	  *wp++ = tolower ((unsigned char) codeset[cnt]);
	else if (isdigit ((unsigned char) codeset[cnt]))
	  *wp++ = codeset[cnt];

      *wp = '\0';
    }

  return (const char *) retval;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\intl\l10nflist.c:402
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\intl\l10nflist.c:448
parsing error 
{
  while ((*dest++ = *src++) != '\0')
    /* Do nothing. */ ;
  return dest - 1;
}
warning: parse error {
  while ((*dest++ = *src++) != '\0')
    /* Do nothing. */ ;
  return dest - 1;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\intl\l10nflist.c:451
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\intl\loadmsgcat.c...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\intl\gmo.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\intl\gettextP.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\intl\hash-string.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\intl\plural-exp.h...skip
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\intl\loadmsgcat.c:510
parsing error 
{
  /* Test for an ISO C 99 section 7.8.1 format string directive.
     Syntax:
     P R I { d | i | o | u | x | X }
     { { | LEAST | FAST } { 8 | 16 | 32 | 64 } | MAX | PTR }  */
  /* We don't use a table of 14 times 6 'const char *' strings here, because
     data relocations cost startup time.  */
  if (name[0] == 'P' && name[1] == 'R' && name[2] == 'I')
    {
      if (name[3] == 'd' || name[3] == 'i' || name[3] == 'o' || name[3] == 'u'
	  || name[3] == 'x' || name[3] == 'X')
	{
	  if (name[4] == '8' && name[5] == '\0')
	    {
	      if (name[3] == 'd')
		return PRId8;
	      if (name[3] == 'i')
		return PRIi8;
	      if (name[3] == 'o')
		return PRIo8;
	      if (name[3] == 'u')
		return PRIu8;
	      if (name[3] == 'x')
		return PRIx8;
	      if (name[3] == 'X')
		return PRIX8;
	      abort ();
	    }
	  if (name[4] == '1' && name[5] == '6' && name[6] == '\0')
	    {
	      if (name[3] == 'd')
		return PRId16;
	      if (name[3] == 'i')
		return PRIi16;
	      if (name[3] == 'o')
		return PRIo16;
	      if (name[3] == 'u')
		return PRIu16;
	      if (name[3] == 'x')
		return PRIx16;
	      if (name[3] == 'X')
		return PRIX16;
	      abort ();
	    }
	  if (name[4] == '3' && name[5] == '2' && name[6] == '\0')
	    {
	      if (name[3] == 'd')
		return PRId32;
	      if (name[3] == 'i')
		return PRIi32;
	      if (name[3] == 'o')
		return PRIo32;
	      if (name[3] == 'u')
		return PRIu32;
	      if (name[3] == 'x')
		return PRIx32;
	      if (name[3] == 'X')
		return PRIX32;
	      abort ();
	    }
	  if (name[4] == '6' && name[5] == '4' && name[6] == '\0')
	    {
	      if (name[3] == 'd')
		return PRId64;
	      if (name[3] == 'i')
		return PRIi64;
	      if (name[3] == 'o')
		return PRIo64;
	      if (name[3] == 'u')
		return PRIu64;
	      if (name[3] == 'x')
		return PRIx64;
	      if (name[3] == 'X')
		return PRIX64;
	      abort ();
	    }
	  if (name[4] == 'L' && name[5] == 'E' && name[6] == 'A'
	      && name[7] == 'S' && name[8] == 'T')
	    {
	      if (name[9] == '8' && name[10] == '\0')
		{
		  if (name[3] == 'd')
		    return PRIdLEAST8;
		  if (name[3] == 'i')
		    return PRIiLEAST8;
		  if (name[3] == 'o')
		    return PRIoLEAST8;
		  if (name[3] == 'u')
		    return PRIuLEAST8;
		  if (name[3] == 'x')
		    return PRIxLEAST8;
		  if (name[3] == 'X')
		    return PRIXLEAST8;
		  abort ();
		}
	      if (name[9] == '1' && name[10] == '6' && name[11] == '\0')
		{
		  if (name[3] == 'd')
		    return PRIdLEAST16;
		  if (name[3] == 'i')
		    return PRIiLEAST16;
		  if (name[3] == 'o')
		    return PRIoLEAST16;
		  if (name[3] == 'u')
		    return PRIuLEAST16;
		  if (name[3] == 'x')
		    return PRIxLEAST16;
		  if (name[3] == 'X')
		    return PRIXLEAST16;
		  abort ();
		}
	      if (name[9] == '3' && name[10] == '2' && name[11] == '\0')
		{
		  if (name[3] == 'd')
		    return PRIdLEAST32;
		  if (name[3] == 'i')
		    return PRIiLEAST32;
		  if (name[3] == 'o')
		    return PRIoLEAST32;
		  if (name[3] == 'u')
		    return PRIuLEAST32;
		  if (name[3] == 'x')
		    return PRIxLEAST32;
		  if (name[3] == 'X')
		    return PRIXLEAST32;
		  abort ();
		}
	      if (name[9] == '6' && name[10] == '4' && name[11] == '\0')
		{
		  if (name[3] == 'd')
		    return PRIdLEAST64;
		  if (name[3] == 'i')
		    return PRIiLEAST64;
		  if (name[3] == 'o')
		    return PRIoLEAST64;
		  if (name[3] == 'u')
		    return PRIuLEAST64;
		  if (name[3] == 'x')
		    return PRIxLEAST64;
		  if (name[3] == 'X')
		    return PRIXLEAST64;
		  abort ();
		}
	    }
	  if (name[4] == 'F' && name[5] == 'A' && name[6] == 'S'
	      && name[7] == 'T')
	    {
	      if (name[8] == '8' && name[9] == '\0')
		{
		  if (name[3] == 'd')
		    return PRIdFAST8;
		  if (name[3] == 'i')
		    return PRIiFAST8;
		  if (name[3] == 'o')
		    return PRIoFAST8;
		  if (name[3] == 'u')
		    return PRIuFAST8;
		  if (name[3] == 'x')
		    return PRIxFAST8;
		  if (name[3] == 'X')
		    return PRIXFAST8;
		  abort ();
		}
	      if (name[8] == '1' && name[9] == '6' && name[10] == '\0')
		{
		  if (name[3] == 'd')
		    return PRIdFAST16;
		  if (name[3] == 'i')
		    return PRIiFAST16;
		  if (name[3] == 'o')
		    return PRIoFAST16;
		  if (name[3] == 'u')
		    return PRIuFAST16;
		  if (name[3] == 'x')
		    return PRIxFAST16;
		  if (name[3] == 'X')
		    return PRIXFAST16;
		  abort ();
		}
	      if (name[8] == '3' && name[9] == '2' && name[10] == '\0')
		{
		  if (name[3] == 'd')
		    return PRIdFAST32;
		  if (name[3] == 'i')
		    return PRIiFAST32;
		  if (name[3] == 'o')
		    return PRIoFAST32;
		  if (name[3] == 'u')
		    return PRIuFAST32;
		  if (name[3] == 'x')
		    return PRIxFAST32;
		  if (name[3] == 'X')
		    return PRIXFAST32;
		  abort ();
		}
	      if (name[8] == '6' && name[9] == '4' && name[10] == '\0')
		{
		  if (name[3] == 'd')
		    return PRIdFAST64;
		  if (name[3] == 'i')
		    return PRIiFAST64;
		  if (name[3] == 'o')
		    return PRIoFAST64;
		  if (name[3] == 'u')
		    return PRIuFAST64;
		  if (name[3] == 'x')
		    return PRIxFAST64;
		  if (name[3] == 'X')
		    return PRIXFAST64;
		  abort ();
		}
	    }
	  if (name[4] == 'M' && name[5] == 'A' && name[6] == 'X'
	      && name[7] == '\0')
	    {
	      if (name[3] == 'd')
		return PRIdMAX;
	      if (name[3] == 'i')
		return PRIiMAX;
	      if (name[3] == 'o')
		return PRIoMAX;
	      if (name[3] == 'u')
		return PRIuMAX;
	      if (name[3] == 'x')
		return PRIxMAX;
	      if (name[3] == 'X')
		return PRIXMAX;
	      abort ();
	    }
	  if (name[4] == 'P' && name[5] == 'T' && name[6] == 'R'
	      && name[7] == '\0')
	    {
	      if (name[3] == 'd')
		return PRIdPTR;
	      if (name[3] == 'i')
		return PRIiPTR;
	      if (name[3] == 'o')
		return PRIoPTR;
	      if (name[3] == 'u')
		return PRIuPTR;
	      if (name[3] == 'x')
		return PRIxPTR;
	      if (name[3] == 'X')
		return PRIXPTR;
	      abort ();
	    }
	}
    }
  /* Other system dependent strings are not valid.  */
  return NULL;
}
warning: parse error {
  /* Test for an ISO C 99 section 7.8.1 format string directive.
     Syntax:
     P R I { d | i | o | u | x | X }
     { { | LEAST | FAST } { 8 | 16 | 32 | 64 } | MAX | PTR }  */
  /* We don't use a table of 14 times 6 'const char *' strings here, because
     data relocations cost startup time.  */
  if (name[0] == 'P' && name[1] == 'R' && name[2] == 'I')
    {
      if (name[3] == 'd' || name[3] == 'i' || name[3] == 'o' || name[3] == 'u'
	  || name[3] == 'x' || name[3] == 'X')
	{
	  if (name[4] == '8' && name[5] == '\0')
	    {
	      if (name[3] == 'd')
		return PRId8;
	      if (name[3] == 'i')
		return PRIi8;
	      if (name[3] == 'o')
		return PRIo8;
	      if (name[3] == 'u')
		return PRIu8;
	      if (name[3] == 'x')
		return PRIx8;
	      if (name[3] == 'X')
		return PRIX8;
	      abort ();
	    }
	  if (name[4] == '1' && name[5] == '6' && name[6] == '\0')
	    {
	      if (name[3] == 'd')
		return PRId16;
	      if (name[3] == 'i')
		return PRIi16;
	      if (name[3] == 'o')
		return PRIo16;
	      if (name[3] == 'u')
		return PRIu16;
	      if (name[3] == 'x')
		return PRIx16;
	      if (name[3] == 'X')
		return PRIX16;
	      abort ();
	    }
	  if (name[4] == '3' && name[5] == '2' && name[6] == '\0')
	    {
	      if (name[3] == 'd')
		return PRId32;
	      if (name[3] == 'i')
		return PRIi32;
	      if (name[3] == 'o')
		return PRIo32;
	      if (name[3] == 'u')
		return PRIu32;
	      if (name[3] == 'x')
		return PRIx32;
	      if (name[3] == 'X')
		return PRIX32;
	      abort ();
	    }
	  if (name[4] == '6' && name[5] == '4' && name[6] == '\0')
	    {
	      if (name[3] == 'd')
		return PRId64;
	      if (name[3] == 'i')
		return PRIi64;
	      if (name[3] == 'o')
		return PRIo64;
	      if (name[3] == 'u')
		return PRIu64;
	      if (name[3] == 'x')
		return PRIx64;
	      if (name[3] == 'X')
		return PRIX64;
	      abort ();
	    }
	  if (name[4] == 'L' && name[5] == 'E' && name[6] == 'A'
	      && name[7] == 'S' && name[8] == 'T')
	    {
	      if (name[9] == '8' && name[10] == '\0')
		{
		  if (name[3] == 'd')
		    return PRIdLEAST8;
		  if (name[3] == 'i')
		    return PRIiLEAST8;
		  if (name[3] == 'o')
		    return PRIoLEAST8;
		  if (name[3] == 'u')
		    return PRIuLEAST8;
		  if (name[3] == 'x')
		    return PRIxLEAST8;
		  if (name[3] == 'X')
		    return PRIXLEAST8;
		  abort ();
		}
	      if (name[9] == '1' && name[10] == '6' && name[11] == '\0')
		{
		  if (name[3] == 'd')
		    return PRIdLEAST16;
		  if (name[3] == 'i')
		    return PRIiLEAST16;
		  if (name[3] == 'o')
		    return PRIoLEAST16;
		  if (name[3] == 'u')
		    return PRIuLEAST16;
		  if (name[3] == 'x')
		    return PRIxLEAST16;
		  if (name[3] == 'X')
		    return PRIXLEAST16;
		  abort ();
		}
	      if (name[9] == '3' && name[10] == '2' && name[11] == '\0')
		{
		  if (name[3] == 'd')
		    return PRIdLEAST32;
		  if (name[3] == 'i')
		    return PRIiLEAST32;
		  if (name[3] == 'o')
		    return PRIoLEAST32;
		  if (name[3] == 'u')
		    return PRIuLEAST32;
		  if (name[3] == 'x')
		    return PRIxLEAST32;
		  if (name[3] == 'X')
		    return PRIXLEAST32;
		  abort ();
		}
	      if (name[9] == '6' && name[10] == '4' && name[11] == '\0')
		{
		  if (name[3] == 'd')
		    return PRIdLEAST64;
		  if (name[3] == 'i')
		    return PRIiLEAST64;
		  if (name[3] == 'o')
		    return PRIoLEAST64;
		  if (name[3] == 'u')
		    return PRIuLEAST64;
		  if (name[3] == 'x')
		    return PRIxLEAST64;
		  if (name[3] == 'X')
		    return PRIXLEAST64;
		  abort ();
		}
	    }
	  if (name[4] == 'F' && name[5] == 'A' && name[6] == 'S'
	      && name[7] == 'T')
	    {
	      if (name[8] == '8' && name[9] == '\0')
		{
		  if (name[3] == 'd')
		    return PRIdFAST8;
		  if (name[3] == 'i')
		    return PRIiFAST8;
		  if (name[3] == 'o')
		    return PRIoFAST8;
		  if (name[3] == 'u')
		    return PRIuFAST8;
		  if (name[3] == 'x')
		    return PRIxFAST8;
		  if (name[3] == 'X')
		    return PRIXFAST8;
		  abort ();
		}
	      if (name[8] == '1' && name[9] == '6' && name[10] == '\0')
		{
		  if (name[3] == 'd')
		    return PRIdFAST16;
		  if (name[3] == 'i')
		    return PRIiFAST16;
		  if (name[3] == 'o')
		    return PRIoFAST16;
		  if (name[3] == 'u')
		    return PRIuFAST16;
		  if (name[3] == 'x')
		    return PRIxFAST16;
		  if (name[3] == 'X')
		    return PRIXFAST16;
		  abort ();
		}
	      if (name[8] == '3' && name[9] == '2' && name[10] == '\0')
		{
		  if (name[3] == 'd')
		    return PRIdFAST32;
		  if (name[3] == 'i')
		    return PRIiFAST32;
		  if (name[3] == 'o')
		    return PRIoFAST32;
		  if (name[3] == 'u')
		    return PRIuFAST32;
		  if (name[3] == 'x')
		    return PRIxFAST32;
		  if (name[3] == 'X')
		    return PRIXFAST32;
		  abort ();
		}
	      if (name[8] == '6' && name[9] == '4' && name[10] == '\0')
		{
		  if (name[3] == 'd')
		    return PRIdFAST64;
		  if (name[3] == 'i')
		    return PRIiFAST64;
		  if (name[3] == 'o')
		    return PRIoFAST64;
		  if (name[3] == 'u')
		    return PRIuFAST64;
		  if (name[3] == 'x')
		    return PRIxFAST64;
		  if (name[3] == 'X')
		    return PRIXFAST64;
		  abort ();
		}
	    }
	  if (name[4] == 'M' && name[5] == 'A' && name[6] == 'X'
	      && name[7] == '\0')
	    {
	      if (name[3] == 'd')
		return PRIdMAX;
	      if (name[3] == 'i')
		return PRIiMAX;
	      if (name[3] == 'o')
		return PRIoMAX;
	      if (name[3] == 'u')
		return PRIuMAX;
	      if (name[3] == 'x')
		return PRIxMAX;
	      if (name[3] == 'X')
		return PRIXMAX;
	      abort ();
	    }
	  if (name[4] == 'P' && name[5] == 'T' && name[6] == 'R'
	      && name[7] == '\0')
	    {
	      if (name[3] == 'd')
		return PRIdPTR;
	      if (name[3] == 'i')
		return PRIiPTR;
	      if (name[3] == 'o')
		return PRIoPTR;
	      if (name[3] == 'u')
		return PRIuPTR;
	      if (name[3] == 'x')
		return PRIxPTR;
	      if (name[3] == 'X')
		return PRIXPTR;
	      abort ();
	    }
	}
    }
  /* Other system dependent strings are not valid.  */
  return NULL;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\intl\loadmsgcat.c:511
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\intl\loadmsgcat.c:767
parsing error 
{
  /* Find out about the character set the file is encoded with.
     This can be found (in textual form) in the entry "".  If this
     entry does not exist or if this does not contain the `charset='
     information, we will assume the charset matches the one the
     current locale and we don't have to perform any conversion.  */
  char *nullentry;
  size_t nullentrylen;

  /* Preinitialize fields, to avoid recursion during _nl_find_msg.  */
  domain->codeset_cntr =
    (domainbinding != NULL ? domainbinding->codeset_cntr : 0);
#ifdef _LIBC
  domain->conv = (__gconv_t) -1;
#else
# if HAVE_ICONV
  domain->conv = (iconv_t) -1;
# endif
#endif
  domain->conv_tab = NULL;

  /* Get the header entry.  */
  nullentry = _nl_find_msg (domain_file, domainbinding, "", &nullentrylen);

  if (nullentry != NULL)
    {
#if defined _LIBC || HAVE_ICONV
      const char *charsetstr;

      charsetstr = strstr (nullentry, "charset=");
      if (charsetstr != NULL)
	{
	  size_t len;
	  char *charset;
	  const char *outcharset;

	  charsetstr += strlen ("charset=");
	  len = strcspn (charsetstr, " \t\n");

	  charset = (char *) alloca (len + 1);
# if defined _LIBC || HAVE_MEMPCPY
	  *((char *) mempcpy (charset, charsetstr, len)) = '\0';
# else
	  memcpy (charset, charsetstr, len);
	  charset[len] = '\0';
# endif

	  /* The output charset should normally be determined by the
	     locale.  But sometimes the locale is not used or not correctly
	     set up, so we provide a possibility for the user to override
	     this.  Moreover, the value specified through
	     bind_textdomain_codeset overrides both.  */
	  if (domainbinding != NULL && domainbinding->codeset != NULL)
	    outcharset = domainbinding->codeset;
	  else
	    {
	      outcharset = getenv ("OUTPUT_CHARSET");
	      if (outcharset == NULL || outcharset[0] == '\0')
		{
# ifdef _LIBC
		  outcharset = _NL_CURRENT (LC_CTYPE, CODESET);
# else
#  if HAVE_ICONV
		  extern const char *locale_charset PARAMS ((void));
		  outcharset = locale_charset ();
#  endif
# endif
		}
	    }

# ifdef _LIBC
	  /* We always want to use transliteration.  */
	  outcharset = norm_add_slashes (outcharset, "TRANSLIT");
	  charset = norm_add_slashes (charset, NULL);
	  if (__gconv_open (outcharset, charset, &domain->conv,
			    GCONV_AVOID_NOCONV)
	      != __GCONV_OK)
	    domain->conv = (__gconv_t) -1;
# else
#  if HAVE_ICONV
	  /* When using GNU libc >= 2.2 or GNU libiconv >= 1.5,
	     we want to use transliteration.  */
#   if (__GLIBC__ == 2 && __GLIBC_MINOR__ >= 2) || __GLIBC__ > 2 \
       || _LIBICONV_VERSION >= 0x0105
	  if (strchr (outcharset, '/') == NULL)
	    {
	      char *tmp;

	      len = strlen (outcharset);
	      tmp = (char *) alloca (len + 10 + 1);
	      memcpy (tmp, outcharset, len);
	      memcpy (tmp + len, "//TRANSLIT", 10 + 1);
	      outcharset = tmp;

	      domain->conv = iconv_open (outcharset, charset);

	      freea (outcharset);
	    }
	  else
#   endif
	    domain->conv = iconv_open (outcharset, charset);
#  endif
# endif

	  freea (charset);
	}
#endif /* _LIBC || HAVE_ICONV */
    }

  return nullentry;
}
warning: parse error {
  /* Find out about the character set the file is encoded with.
     This can be found (in textual form) in the entry "".  If this
     entry does not exist or if this does not contain the `charset='
     information, we will assume the charset matches the one the
     current locale and we don't have to perform any conversion.  */
  char *nullentry;
  size_t nullentrylen;

  /* Preinitialize fields, to avoid recursion during _nl_find_msg.  */
  domain->codeset_cntr =
    (domainbinding != NULL ? domainbinding->codeset_cntr : 0);
#ifdef _LIBC
  domain->conv = (__gconv_t) -1;
#else
# if HAVE_ICONV
  domain->conv = (iconv_t) -1;
# endif
#endif
  domain->conv_tab = NULL;

  /* Get the header entry.  */
  nullentry = _nl_find_msg (domain_file, domainbinding, "", &nullentrylen);

  if (nullentry != NULL)
    {
#if defined _LIBC || HAVE_ICONV
      const char *charsetstr;

      charsetstr = strstr (nullentry, "charset=");
      if (charsetstr != NULL)
	{
	  size_t len;
	  char *charset;
	  const char *outcharset;

	  charsetstr += strlen ("charset=");
	  len = strcspn (charsetstr, " \t\n");

	  charset = (char *) alloca (len + 1);
# if defined _LIBC || HAVE_MEMPCPY
	  *((char *) mempcpy (charset, charsetstr, len)) = '\0';
# else
	  memcpy (charset, charsetstr, len);
	  charset[len] = '\0';
# endif

	  /* The output charset should normally be determined by the
	     locale.  But sometimes the locale is not used or not correctly
	     set up, so we provide a possibility for the user to override
	     this.  Moreover, the value specified through
	     bind_textdomain_codeset overrides both.  */
	  if (domainbinding != NULL && domainbinding->codeset != NULL)
	    outcharset = domainbinding->codeset;
	  else
	    {
	      outcharset = getenv ("OUTPUT_CHARSET");
	      if (outcharset == NULL || outcharset[0] == '\0')
		{
# ifdef _LIBC
		  outcharset = _NL_CURRENT (LC_CTYPE, CODESET);
# else
#  if HAVE_ICONV
		  extern const char *locale_charset PARAMS ((void));
		  outcharset = locale_charset ();
#  endif
# endif
		}
	    }

# ifdef _LIBC
	  /* We always want to use transliteration.  */
	  outcharset = norm_add_slashes (outcharset, "TRANSLIT");
	  charset = norm_add_slashes (charset, NULL);
	  if (__gconv_open (outcharset, charset, &domain->conv,
			    GCONV_AVOID_NOCONV)
	      != __GCONV_OK)
	    domain->conv = (__gconv_t) -1;
# else
#  if HAVE_ICONV
	  /* When using GNU libc >= 2.2 or GNU libiconv >= 1.5,
	     we want to use transliteration.  */
#   if (__GLIBC__ == 2 && __GLIBC_MINOR__ >= 2) || __GLIBC__ > 2 \
       || _LIBICONV_VERSION >= 0x0105
	  if (strchr (outcharset, '/') == NULL)
	    {
	      char *tmp;

	      len = strlen (outcharset);
	      tmp = (char *) alloca (len + 10 + 1);
	      memcpy (tmp, outcharset, len);
	      memcpy (tmp + len, "//TRANSLIT", 10 + 1);
	      outcharset = tmp;

	      domain->conv = iconv_open (outcharset, charset);

	      freea (outcharset);
	    }
	  else
#   endif
	    domain->conv = iconv_open (outcharset, charset);
#  endif
# endif

	  freea (charset);
	}
#endif /* _LIBC || HAVE_ICONV */
    }

  return nullentry;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\intl\loadmsgcat.c:771
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\intl\loadmsgcat.c:886
parsing error 
{
  if (domain->conv_tab != NULL && domain->conv_tab != (char **) -1)
    free (domain->conv_tab);

#ifdef _LIBC
  if (domain->conv != (__gconv_t) -1)
    __gconv_close (domain->conv);
#else
# if HAVE_ICONV
  if (domain->conv != (iconv_t) -1)
    iconv_close (domain->conv);
# endif
#endif
}
warning: parse error {
  if (domain->conv_tab != NULL && domain->conv_tab != (char **) -1)
    free (domain->conv_tab);

#ifdef _LIBC
  if (domain->conv != (__gconv_t) -1)
    __gconv_close (domain->conv);
#else
# if HAVE_ICONV
  if (domain->conv != (iconv_t) -1)
    iconv_close (domain->conv);
# endif
#endif
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\intl\loadmsgcat.c:888
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\intl\loadmsgcat.c:907
parsing error 
{
  int fd;
  size_t size;
#ifdef _LIBC
  struct stat64 st;
#else
  struct stat st;
#endif
  struct mo_file_header *data = (struct mo_file_header *) -1;
  int use_mmap = 0;
  struct loaded_domain *domain;
  int revision;
  const char *nullentry;

  domain_file->decided = 1;
  domain_file->data = NULL;

  /* Note that it would be useless to store domainbinding in domain_file
     because domainbinding might be == NULL now but != NULL later (after
     a call to bind_textdomain_codeset).  */

  /* If the record does not represent a valid locale the FILENAME
     might be NULL.  This can happen when according to the given
     specification the locale file name is different for XPG and CEN
     syntax.  */
  if (domain_file->filename == NULL)
    return;

  /* Try to open the addressed file.  */
  fd = open (domain_file->filename, O_RDONLY | O_BINARY);
  if (fd == -1)
    return;

  /* We must know about the size of the file.  */
  if (
#ifdef _LIBC
      __builtin_expect (fstat64 (fd, &st) != 0, 0)
#else
      __builtin_expect (fstat (fd, &st) != 0, 0)
#endif
      || __builtin_expect ((size = (size_t) st.st_size) != st.st_size, 0)
      || __builtin_expect (size < sizeof (struct mo_file_header), 0))
    {
      /* Something went wrong.  */
      close (fd);
      return;
    }

#ifdef HAVE_MMAP
  /* Now we are ready to load the file.  If mmap() is available we try
     this first.  If not available or it failed we try to load it.  */
  data = (struct mo_file_header *) mmap (NULL, size, PROT_READ,
					 MAP_PRIVATE, fd, 0);

  if (__builtin_expect (data != (struct mo_file_header *) -1, 1))
    {
      /* mmap() call was successful.  */
      close (fd);
      use_mmap = 1;
    }
#endif

  /* If the data is not yet available (i.e. mmap'ed) we try to load
     it manually.  */
  if (data == (struct mo_file_header *) -1)
    {
      size_t to_read;
      char *read_ptr;

      data = (struct mo_file_header *) malloc (size);
      if (data == NULL)
	return;

      to_read = size;
      read_ptr = (char *) data;
      do
	{
	  long int nb = (long int) read (fd, read_ptr, to_read);
	  if (nb <= 0)
	    {
#ifdef EINTR
	      if (nb == -1 && errno == EINTR)
		continue;
#endif
	      close (fd);
	      return;
	    }
	  read_ptr += nb;
	  to_read -= nb;
	}
      while (to_read > 0);

      close (fd);
    }

  /* Using the magic number we can test whether it really is a message
     catalog file.  */
  if (__builtin_expect (data->magic != _MAGIC && data->magic != _MAGIC_SWAPPED,
			0))
    {
      /* The magic number is wrong: not a message catalog file.  */
#ifdef HAVE_MMAP
      if (use_mmap)
	munmap ((caddr_t) data, size);
      else
#endif
	free (data);
      return;
    }

  domain = (struct loaded_domain *) malloc (sizeof (struct loaded_domain));
  if (domain == NULL)
    return;
  domain_file->data = domain;

  domain->data = (char *) data;
  domain->use_mmap = use_mmap;
  domain->mmap_size = size;
  domain->must_swap = data->magic != _MAGIC;
  domain->malloced = NULL;

  /* Fill in the information about the available tables.  */
  revision = W (domain->must_swap, data->revision);
  /* We support only the major revision 0.  */
  switch (revision >> 16)
    {
    case 0:
      domain->nstrings = W (domain->must_swap, data->nstrings);
      domain->orig_tab = (const struct string_desc *)
	((char *) data + W (domain->must_swap, data->orig_tab_offset));
      domain->trans_tab = (const struct string_desc *)
	((char *) data + W (domain->must_swap, data->trans_tab_offset));
      domain->hash_size = W (domain->must_swap, data->hash_tab_size);
      domain->hash_tab =
	(domain->hash_size > 2
	 ? (const nls_uint32 *)
	   ((char *) data + W (domain->must_swap, data->hash_tab_offset))
	 : NULL);
      domain->must_swap_hash_tab = domain->must_swap;

      /* Now dispatch on the minor revision.  */
      switch (revision & 0xffff)
	{
	case 0:
	  domain->n_sysdep_strings = 0;
	  domain->orig_sysdep_tab = NULL;
	  domain->trans_sysdep_tab = NULL;
	  break;
	case 1:
	default:
	  {
	    nls_uint32 n_sysdep_strings;

	    if (domain->hash_tab == NULL)
	      /* This is invalid.  These minor revisions need a hash table.  */
	      goto invalid;

	    n_sysdep_strings =
	      W (domain->must_swap, data->n_sysdep_strings);
	    if (n_sysdep_strings > 0)
	      {
		nls_uint32 n_sysdep_segments;
		const struct sysdep_segment *sysdep_segments;
		const char **sysdep_segment_values;
		const nls_uint32 *orig_sysdep_tab;
		const nls_uint32 *trans_sysdep_tab;
		size_t memneed;
		char *mem;
		struct sysdep_string_desc *inmem_orig_sysdep_tab;
		struct sysdep_string_desc *inmem_trans_sysdep_tab;
		nls_uint32 *inmem_hash_tab;
		unsigned int i;

		/* Get the values of the system dependent segments.  */
		n_sysdep_segments =
		  W (domain->must_swap, data->n_sysdep_segments);
		sysdep_segments = (const struct sysdep_segment *)
		  ((char *) data
		   + W (domain->must_swap, data->sysdep_segments_offset));
		sysdep_segment_values =
		  alloca (n_sysdep_segments * sizeof (const char *));
		for (i = 0; i < n_sysdep_segments; i++)
		  {
		    const char *name =
		      (char *) data
		      + W (domain->must_swap, sysdep_segments[i].offset);
		    nls_uint32 namelen =
		      W (domain->must_swap, sysdep_segments[i].length);

		    if (!(namelen > 0 && name[namelen - 1] == '\0'))
		      {
			freea (sysdep_segment_values);
			goto invalid;
		      }

		    sysdep_segment_values[i] = get_sysdep_segment_value (name);
		  }

		orig_sysdep_tab = (const nls_uint32 *)
		  ((char *) data
		   + W (domain->must_swap, data->orig_sysdep_tab_offset));
		trans_sysdep_tab = (const nls_uint32 *)
		  ((char *) data
		   + W (domain->must_swap, data->trans_sysdep_tab_offset));

		/* Compute the amount of additional memory needed for the
		   system dependent strings and the augmented hash table.  */
		memneed = 2 * n_sysdep_strings
			  * sizeof (struct sysdep_string_desc)
			  + domain->hash_size * sizeof (nls_uint32);
		for (i = 0; i < 2 * n_sysdep_strings; i++)
		  {
		    const struct sysdep_string *sysdep_string =
		      (const struct sysdep_string *)
		      ((char *) data
		       + W (domain->must_swap,
			    i < n_sysdep_strings
			    ? orig_sysdep_tab[i]
			    : trans_sysdep_tab[i - n_sysdep_strings]));
		    size_t need = 0;
		    const struct segment_pair *p = sysdep_string->segments;

		    if (W (domain->must_swap, p->sysdepref) != SEGMENTS_END)
		      for (p = sysdep_string->segments;; p++)
			{
			  nls_uint32 sysdepref;

			  need += W (domain->must_swap, p->segsize);

			  sysdepref = W (domain->must_swap, p->sysdepref);
			  if (sysdepref == SEGMENTS_END)
			    break;

			  if (sysdepref >= n_sysdep_segments)
			    {
			      /* Invalid.  */
			      freea (sysdep_segment_values);
			      goto invalid;
			    }

			  need += strlen (sysdep_segment_values[sysdepref]);
			}

		    memneed += need;
		  }

		/* Allocate additional memory.  */
		mem = (char *) malloc (memneed);
		if (mem == NULL)
		  goto invalid;

		domain->malloced = mem;
		inmem_orig_sysdep_tab = (struct sysdep_string_desc *) mem;
		mem += n_sysdep_strings * sizeof (struct sysdep_string_desc);
		inmem_trans_sysdep_tab = (struct sysdep_string_desc *) mem;
		mem += n_sysdep_strings * sizeof (struct sysdep_string_desc);
		inmem_hash_tab = (nls_uint32 *) mem;
		mem += domain->hash_size * sizeof (nls_uint32);

		/* Compute the system dependent strings.  */
		for (i = 0; i < 2 * n_sysdep_strings; i++)
		  {
		    const struct sysdep_string *sysdep_string =
		      (const struct sysdep_string *)
		      ((char *) data
		       + W (domain->must_swap,
			    i < n_sysdep_strings
			    ? orig_sysdep_tab[i]
			    : trans_sysdep_tab[i - n_sysdep_strings]));
		    const char *static_segments =
		      (char *) data
		      + W (domain->must_swap, sysdep_string->offset);
		    const struct segment_pair *p = sysdep_string->segments;

		    /* Concatenate the segments, and fill
		       inmem_orig_sysdep_tab[i] (for i < n_sysdep_strings) and
		       inmem_trans_sysdep_tab[i-n_sysdep_strings] (for
		       i >= n_sysdep_strings).  */

		    if (W (domain->must_swap, p->sysdepref) == SEGMENTS_END)
		      {
			/* Only one static segment.  */
			inmem_orig_sysdep_tab[i].length =
			  W (domain->must_swap, p->segsize);
			inmem_orig_sysdep_tab[i].pointer = static_segments;
		      }
		    else
		      {
			inmem_orig_sysdep_tab[i].pointer = mem;

			for (p = sysdep_string->segments;; p++)
			  {
			    nls_uint32 segsize =
			      W (domain->must_swap, p->segsize);
			    nls_uint32 sysdepref =
			      W (domain->must_swap, p->sysdepref);
			    size_t n;

			    if (segsize > 0)
			      {
				memcpy (mem, static_segments, segsize);
				mem += segsize;
				static_segments += segsize;
			      }

			    if (sysdepref == SEGMENTS_END)
			      break;

			    n = strlen (sysdep_segment_values[sysdepref]);
			    memcpy (mem, sysdep_segment_values[sysdepref], n);
			    mem += n;
			  }

			inmem_orig_sysdep_tab[i].length =
			  mem - inmem_orig_sysdep_tab[i].pointer;
		      }
		  }

		/* Compute the augmented hash table.  */
		for (i = 0; i < domain->hash_size; i++)
		  inmem_hash_tab[i] =
		    W (domain->must_swap_hash_tab, domain->hash_tab[i]);
		for (i = 0; i < n_sysdep_strings; i++)
		  {
		    const char *msgid = inmem_orig_sysdep_tab[i].pointer;
		    nls_uint32 hash_val = hash_string (msgid);
		    nls_uint32 idx = hash_val % domain->hash_size;
		    nls_uint32 incr = 1 + (hash_val % (domain->hash_size - 2));

		    for (;;)
		      {
			if (inmem_hash_tab[idx] == 0)
			  {
			    /* Hash table entry is empty.  Use it.  */
			    inmem_hash_tab[idx] = 1 + domain->nstrings + i;
			    break;
			  }

			if (idx >= domain->hash_size - incr)
			  idx -= domain->hash_size - incr;
			else
			  idx += incr;
		      }
		  }

		freea (sysdep_segment_values);

		domain->n_sysdep_strings = n_sysdep_strings;
		domain->orig_sysdep_tab = inmem_orig_sysdep_tab;
		domain->trans_sysdep_tab = inmem_trans_sysdep_tab;

		domain->hash_tab = inmem_hash_tab;
		domain->must_swap_hash_tab = 0;
	      }
	    else
	      {
		domain->n_sysdep_strings = 0;
		domain->orig_sysdep_tab = NULL;
		domain->trans_sysdep_tab = NULL;
	      }
	  }
	  break;
	}
      break;
    default:
      /* This is an invalid revision.  */
    invalid:
      /* This is an invalid .mo file.  */
      if (domain->malloced)
	free (domain->malloced);
#ifdef HAVE_MMAP
      if (use_mmap)
	munmap ((caddr_t) data, size);
      else
#endif
	free (data);
      free (domain);
      domain_file->data = NULL;
      return;
    }

  /* Now initialize the character set converter from the character set
     the file is encoded with (found in the header entry) to the domain's
     specified character set or the locale's character set.  */
  nullentry = _nl_init_domain_conv (domain_file, domain, domainbinding);

  /* Also look for a plural specification.  */
  EXTRACT_PLURAL_EXPRESSION (nullentry, &domain->plural, &domain->nplurals);
}
warning: parse error {
  int fd;
  size_t size;
#ifdef _LIBC
  struct stat64 st;
#else
  struct stat st;
#endif
  struct mo_file_header *data = (struct mo_file_header *) -1;
  int use_mmap = 0;
  struct loaded_domain *domain;
  int revision;
  const char *nullentry;

  domain_file->decided = 1;
  domain_file->data = NULL;

  /* Note that it would be useless to store domainbinding in domain_file
     because domainbinding might be == NULL now but != NULL later (after
     a call to bind_textdomain_codeset).  */

  /* If the record does not represent a valid locale the FILENAME
     might be NULL.  This can happen when according to the given
     specification the locale file name is different for XPG and CEN
     syntax.  */
  if (domain_file->filename == NULL)
    return;

  /* Try to open the addressed file.  */
  fd = open (domain_file->filename, O_RDONLY | O_BINARY);
  if (fd == -1)
    return;

  /* We must know about the size of the file.  */
  if (
#ifdef _LIBC
      __builtin_expect (fstat64 (fd, &st) != 0, 0)
#else
      __builtin_expect (fstat (fd, &st) != 0, 0)
#endif
      || __builtin_expect ((size = (size_t) st.st_size) != st.st_size, 0)
      || __builtin_expect (size < sizeof (struct mo_file_header), 0))
    {
      /* Something went wrong.  */
      close (fd);
      return;
    }

#ifdef HAVE_MMAP
  /* Now we are ready to load the file.  If mmap() is available we try
     this first.  If not available or it failed we try to load it.  */
  data = (struct mo_file_header *) mmap (NULL, size, PROT_READ,
					 MAP_PRIVATE, fd, 0);

  if (__builtin_expect (data != (struct mo_file_header *) -1, 1))
    {
      /* mmap() call was successful.  */
      close (fd);
      use_mmap = 1;
    }
#endif

  /* If the data is not yet available (i.e. mmap'ed) we try to load
     it manually.  */
  if (data == (struct mo_file_header *) -1)
    {
      size_t to_read;
      char *read_ptr;

      data = (struct mo_file_header *) malloc (size);
      if (data == NULL)
	return;

      to_read = size;
      read_ptr = (char *) data;
      do
	{
	  long int nb = (long int) read (fd, read_ptr, to_read);
	  if (nb <= 0)
	    {
#ifdef EINTR
	      if (nb == -1 && errno == EINTR)
		continue;
#endif
	      close (fd);
	      return;
	    }
	  read_ptr += nb;
	  to_read -= nb;
	}
      while (to_read > 0);

      close (fd);
    }

  /* Using the magic number we can test whether it really is a message
     catalog file.  */
  if (__builtin_expect (data->magic != _MAGIC && data->magic != _MAGIC_SWAPPED,
			0))
    {
      /* The magic number is wrong: not a message catalog file.  */
#ifdef HAVE_MMAP
      if (use_mmap)
	munmap ((caddr_t) data, size);
      else
#endif
	free (data);
      return;
    }

  domain = (struct loaded_domain *) malloc (sizeof (struct loaded_domain));
  if (domain == NULL)
    return;
  domain_file->data = domain;

  domain->data = (char *) data;
  domain->use_mmap = use_mmap;
  domain->mmap_size = size;
  domain->must_swap = data->magic != _MAGIC;
  domain->malloced = NULL;

  /* Fill in the information about the available tables.  */
  revision = W (domain->must_swap, data->revision);
  /* We support only the major revision 0.  */
  switch (revision >> 16)
    {
    case 0:
      domain->nstrings = W (domain->must_swap, data->nstrings);
      domain->orig_tab = (const struct string_desc *)
	((char *) data + W (domain->must_swap, data->orig_tab_offset));
      domain->trans_tab = (const struct string_desc *)
	((char *) data + W (domain->must_swap, data->trans_tab_offset));
      domain->hash_size = W (domain->must_swap, data->hash_tab_size);
      domain->hash_tab =
	(domain->hash_size > 2
	 ? (const nls_uint32 *)
	   ((char *) data + W (domain->must_swap, data->hash_tab_offset))
	 : NULL);
      domain->must_swap_hash_tab = domain->must_swap;

      /* Now dispatch on the minor revision.  */
      switch (revision & 0xffff)
	{
	case 0:
	  domain->n_sysdep_strings = 0;
	  domain->orig_sysdep_tab = NULL;
	  domain->trans_sysdep_tab = NULL;
	  break;
	case 1:
	default:
	  {
	    nls_uint32 n_sysdep_strings;

	    if (domain->hash_tab == NULL)
	      /* This is invalid.  These minor revisions need a hash table.  */
	      goto invalid;

	    n_sysdep_strings =
	      W (domain->must_swap, data->n_sysdep_strings);
	    if (n_sysdep_strings > 0)
	      {
		nls_uint32 n_sysdep_segments;
		const struct sysdep_segment *sysdep_segments;
		const char **sysdep_segment_values;
		const nls_uint32 *orig_sysdep_tab;
		const nls_uint32 *trans_sysdep_tab;
		size_t memneed;
		char *mem;
		struct sysdep_string_desc *inmem_orig_sysdep_tab;
		struct sysdep_string_desc *inmem_trans_sysdep_tab;
		nls_uint32 *inmem_hash_tab;
		unsigned int i;

		/* Get the values of the system dependent segments.  */
		n_sysdep_segments =
		  W (domain->must_swap, data->n_sysdep_segments);
		sysdep_segments = (const struct sysdep_segment *)
		  ((char *) data
		   + W (domain->must_swap, data->sysdep_segments_offset));
		sysdep_segment_values =
		  alloca (n_sysdep_segments * sizeof (const char *));
		for (i = 0; i < n_sysdep_segments; i++)
		  {
		    const char *name =
		      (char *) data
		      + W (domain->must_swap, sysdep_segments[i].offset);
		    nls_uint32 namelen =
		      W (domain->must_swap, sysdep_segments[i].length);

		    if (!(namelen > 0 && name[namelen - 1] == '\0'))
		      {
			freea (sysdep_segment_values);
			goto invalid;
		      }

		    sysdep_segment_values[i] = get_sysdep_segment_value (name);
		  }

		orig_sysdep_tab = (const nls_uint32 *)
		  ((char *) data
		   + W (domain->must_swap, data->orig_sysdep_tab_offset));
		trans_sysdep_tab = (const nls_uint32 *)
		  ((char *) data
		   + W (domain->must_swap, data->trans_sysdep_tab_offset));

		/* Compute the amount of additional memory needed for the
		   system dependent strings and the augmented hash table.  */
		memneed = 2 * n_sysdep_strings
			  * sizeof (struct sysdep_string_desc)
			  + domain->hash_size * sizeof (nls_uint32);
		for (i = 0; i < 2 * n_sysdep_strings; i++)
		  {
		    const struct sysdep_string *sysdep_string =
		      (const struct sysdep_string *)
		      ((char *) data
		       + W (domain->must_swap,
			    i < n_sysdep_strings
			    ? orig_sysdep_tab[i]
			    : trans_sysdep_tab[i - n_sysdep_strings]));
		    size_t need = 0;
		    const struct segment_pair *p = sysdep_string->segments;

		    if (W (domain->must_swap, p->sysdepref) != SEGMENTS_END)
		      for (p = sysdep_string->segments;; p++)
			{
			  nls_uint32 sysdepref;

			  need += W (domain->must_swap, p->segsize);

			  sysdepref = W (domain->must_swap, p->sysdepref);
			  if (sysdepref == SEGMENTS_END)
			    break;

			  if (sysdepref >= n_sysdep_segments)
			    {
			      /* Invalid.  */
			      freea (sysdep_segment_values);
			      goto invalid;
			    }

			  need += strlen (sysdep_segment_values[sysdepref]);
			}

		    memneed += need;
		  }

		/* Allocate additional memory.  */
		mem = (char *) malloc (memneed);
		if (mem == NULL)
		  goto invalid;

		domain->malloced = mem;
		inmem_orig_sysdep_tab = (struct sysdep_string_desc *) mem;
		mem += n_sysdep_strings * sizeof (struct sysdep_string_desc);
		inmem_trans_sysdep_tab = (struct sysdep_string_desc *) mem;
		mem += n_sysdep_strings * sizeof (struct sysdep_string_desc);
		inmem_hash_tab = (nls_uint32 *) mem;
		mem += domain->hash_size * sizeof (nls_uint32);

		/* Compute the system dependent strings.  */
		for (i = 0; i < 2 * n_sysdep_strings; i++)
		  {
		    const struct sysdep_string *sysdep_string =
		      (const struct sysdep_string *)
		      ((char *) data
		       + W (domain->must_swap,
			    i < n_sysdep_strings
			    ? orig_sysdep_tab[i]
			    : trans_sysdep_tab[i - n_sysdep_strings]));
		    const char *static_segments =
		      (char *) data
		      + W (domain->must_swap, sysdep_string->offset);
		    const struct segment_pair *p = sysdep_string->segments;

		    /* Concatenate the segments, and fill
		       inmem_orig_sysdep_tab[i] (for i < n_sysdep_strings) and
		       inmem_trans_sysdep_tab[i-n_sysdep_strings] (for
		       i >= n_sysdep_strings).  */

		    if (W (domain->must_swap, p->sysdepref) == SEGMENTS_END)
		      {
			/* Only one static segment.  */
			inmem_orig_sysdep_tab[i].length =
			  W (domain->must_swap, p->segsize);
			inmem_orig_sysdep_tab[i].pointer = static_segments;
		      }
		    else
		      {
			inmem_orig_sysdep_tab[i].pointer = mem;

			for (p = sysdep_string->segments;; p++)
			  {
			    nls_uint32 segsize =
			      W (domain->must_swap, p->segsize);
			    nls_uint32 sysdepref =
			      W (domain->must_swap, p->sysdepref);
			    size_t n;

			    if (segsize > 0)
			      {
				memcpy (mem, static_segments, segsize);
				mem += segsize;
				static_segments += segsize;
			      }

			    if (sysdepref == SEGMENTS_END)
			      break;

			    n = strlen (sysdep_segment_values[sysdepref]);
			    memcpy (mem, sysdep_segment_values[sysdepref], n);
			    mem += n;
			  }

			inmem_orig_sysdep_tab[i].length =
			  mem - inmem_orig_sysdep_tab[i].pointer;
		      }
		  }

		/* Compute the augmented hash table.  */
		for (i = 0; i < domain->hash_size; i++)
		  inmem_hash_tab[i] =
		    W (domain->must_swap_hash_tab, domain->hash_tab[i]);
		for (i = 0; i < n_sysdep_strings; i++)
		  {
		    const char *msgid = inmem_orig_sysdep_tab[i].pointer;
		    nls_uint32 hash_val = hash_string (msgid);
		    nls_uint32 idx = hash_val % domain->hash_size;
		    nls_uint32 incr = 1 + (hash_val % (domain->hash_size - 2));

		    for (;;)
		      {
			if (inmem_hash_tab[idx] == 0)
			  {
			    /* Hash table entry is empty.  Use it.  */
			    inmem_hash_tab[idx] = 1 + domain->nstrings + i;
			    break;
			  }

			if (idx >= domain->hash_size - incr)
			  idx -= domain->hash_size - incr;
			else
			  idx += incr;
		      }
		  }

		freea (sysdep_segment_values);

		domain->n_sysdep_strings = n_sysdep_strings;
		domain->orig_sysdep_tab = inmem_orig_sysdep_tab;
		domain->trans_sysdep_tab = inmem_trans_sysdep_tab;

		domain->hash_tab = inmem_hash_tab;
		domain->must_swap_hash_tab = 0;
	      }
	    else
	      {
		domain->n_sysdep_strings = 0;
		domain->orig_sysdep_tab = NULL;
		domain->trans_sysdep_tab = NULL;
	      }
	  }
	  break;
	}
      break;
    default:
      /* This is an invalid revision.  */
    invalid:
      /* This is an invalid .mo file.  */
      if (domain->malloced)
	free (domain->malloced);
#ifdef HAVE_MMAP
      if (use_mmap)
	munmap ((caddr_t) data, size);
      else
#endif
	free (data);
      free (domain);
      domain_file->data = NULL;
      return;
    }

  /* Now initialize the character set converter from the character set
     the file is encoded with (found in the header entry) to the domain's
     specified character set or the locale's character set.  */
  nullentry = _nl_init_domain_conv (domain_file, domain, domainbinding);

  /* Also look for a plural specification.  */
  EXTRACT_PLURAL_EXPRESSION (nullentry, &domain->plural, &domain->nplurals);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\intl\loadmsgcat.c:910
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\intl\localcharset.c...
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\intl\localcharset.h...
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\intl\localealias.c...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\intl\gettextP.h...skip
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\intl\localealias.c:154
parsing error 
{
  static const char *locale_alias_path;
  struct alias_map *retval;
  const char *result = NULL;
  size_t added;

#ifdef _LIBC
  __libc_lock_lock (lock);
#endif

  if (locale_alias_path == NULL)
    locale_alias_path = LOCALE_ALIAS_PATH;

  do
    {
      struct alias_map item;

      item.alias = name;

      if (nmap > 0)
	retval = (struct alias_map *) bsearch (&item, map, nmap,
					       sizeof (struct alias_map),
					       (int (*) PARAMS ((const void *,
								 const void *))
						) alias_compare);
      else
	retval = NULL;

      /* We really found an alias.  Return the value.  */
      if (retval != NULL)
	{
	  result = retval->value;
	  break;
	}

      /* Perhaps we can find another alias file.  */
      added = 0;
      while (added == 0 && locale_alias_path[0] != '\0')
	{
	  const char *start;

	  while (locale_alias_path[0] == PATH_SEPARATOR)
	    ++locale_alias_path;
	  start = locale_alias_path;

	  while (locale_alias_path[0] != '\0'
		 && locale_alias_path[0] != PATH_SEPARATOR)
	    ++locale_alias_path;

	  if (start < locale_alias_path)
	    added = read_alias_file (start, locale_alias_path - start);
	}
    }
  while (added != 0);

#ifdef _LIBC
  __libc_lock_unlock (lock);
#endif

  return result;
}
warning: parse error {
  static const char *locale_alias_path;
  struct alias_map *retval;
  const char *result = NULL;
  size_t added;

#ifdef _LIBC
  __libc_lock_lock (lock);
#endif

  if (locale_alias_path == NULL)
    locale_alias_path = LOCALE_ALIAS_PATH;

  do
    {
      struct alias_map item;

      item.alias = name;

      if (nmap > 0)
	retval = (struct alias_map *) bsearch (&item, map, nmap,
					       sizeof (struct alias_map),
					       (int (*) PARAMS ((const void *,
								 const void *))
						) alias_compare);
      else
	retval = NULL;

      /* We really found an alias.  Return the value.  */
      if (retval != NULL)
	{
	  result = retval->value;
	  break;
	}

      /* Perhaps we can find another alias file.  */
      added = 0;
      while (added == 0 && locale_alias_path[0] != '\0')
	{
	  const char *start;

	  while (locale_alias_path[0] == PATH_SEPARATOR)
	    ++locale_alias_path;
	  start = locale_alias_path;

	  while (locale_alias_path[0] != '\0'
		 && locale_alias_path[0] != PATH_SEPARATOR)
	    ++locale_alias_path;

	  if (start < locale_alias_path)
	    added = read_alias_file (start, locale_alias_path - start);
	}
    }
  while (added != 0);

#ifdef _LIBC
  __libc_lock_unlock (lock);
#endif

  return result;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\intl\localealias.c:155
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\intl\localealias.c:221
parsing error 
{
  FILE *fp;
  char *full_fname;
  size_t added;
  static const char aliasfile[] = "/locale.alias";

  full_fname = (char *) alloca (fname_len + sizeof aliasfile);
#ifdef HAVE_MEMPCPY
  mempcpy (mempcpy (full_fname, fname, fname_len),
	   aliasfile, sizeof aliasfile);
#else
  memcpy (full_fname, fname, fname_len);
  memcpy (&full_fname[fname_len], aliasfile, sizeof aliasfile);
#endif

  fp = fopen (relocate (full_fname), "r");
  freea (full_fname);
  if (fp == NULL)
    return 0;

#ifdef HAVE___FSETLOCKING
  /* No threads present.  */
  __fsetlocking (fp, FSETLOCKING_BYCALLER);
#endif

  added = 0;
  while (!FEOF (fp))
    {
      /* It is a reasonable approach to use a fix buffer here because
	 a) we are only interested in the first two fields
	 b) these fields must be usable as file names and so must not
	    be that long
	 We avoid a multi-kilobyte buffer here since this would use up
	 stack space which we might not have if the program ran out of
	 memory.  */
      char buf[400];
      char *alias;
      char *value;
      char *cp;

      if (FGETS (buf, sizeof buf, fp) == NULL)
	/* EOF reached.  */
	break;

      cp = buf;
      /* Ignore leading white space.  */
      while (isspace ((unsigned char) cp[0]))
	++cp;

      /* A leading '#' signals a comment line.  */
      if (cp[0] != '\0' && cp[0] != '#')
	{
	  alias = cp++;
	  while (cp[0] != '\0' && !isspace ((unsigned char) cp[0]))
	    ++cp;
	  /* Terminate alias name.  */
	  if (cp[0] != '\0')
	    *cp++ = '\0';

	  /* Now look for the beginning of the value.  */
	  while (isspace ((unsigned char) cp[0]))
	    ++cp;

	  if (cp[0] != '\0')
	    {
	      size_t alias_len;
	      size_t value_len;

	      value = cp++;
	      while (cp[0] != '\0' && !isspace ((unsigned char) cp[0]))
		++cp;
	      /* Terminate value.  */
	      if (cp[0] == '\n')
		{
		  /* This has to be done to make the following test
		     for the end of line possible.  We are looking for
		     the terminating '\n' which do not overwrite here.  */
		  *cp++ = '\0';
		  *cp = '\n';
		}
	      else if (cp[0] != '\0')
		*cp++ = '\0';

	      if (nmap >= maxmap)
		if (__builtin_expect (extend_alias_table (), 0))
		  return added;

	      alias_len = strlen (alias) + 1;
	      value_len = strlen (value) + 1;

	      if (string_space_act + alias_len + value_len > string_space_max)
		{
		  /* Increase size of memory pool.  */
		  size_t new_size = (string_space_max
				     + (alias_len + value_len > 1024
					? alias_len + value_len : 1024));
		  char *new_pool = (char *) realloc (string_space, new_size);
		  if (new_pool == NULL)
		    return added;

		  if (__builtin_expect (string_space != new_pool, 0))
		    {
		      size_t i;

		      for (i = 0; i < nmap; i++)
			{
			  map[i].alias += new_pool - string_space;
			  map[i].value += new_pool - string_space;
			}
		    }

		  string_space = new_pool;
		  string_space_max = new_size;
		}

	      map[nmap].alias = memcpy (&string_space[string_space_act],
					alias, alias_len);
	      string_space_act += alias_len;

	      map[nmap].value = memcpy (&string_space[string_space_act],
					value, value_len);
	      string_space_act += value_len;

	      ++nmap;
	      ++added;
	    }
	}

      /* Possibly not the whole line fits into the buffer.  Ignore
	 the rest of the line.  */
      while (strchr (buf, '\n') == NULL)
	if (FGETS (buf, sizeof buf, fp) == NULL)
	  /* Make sure the inner loop will be left.  The outer loop
	     will exit at the `feof' test.  */
	  break;
    }

  /* Should we test for ferror()?  I think we have to silently ignore
     errors.  --drepper  */
  fclose (fp);

  if (added > 0)
    qsort (map, nmap, sizeof (struct alias_map),
	   (int (*) PARAMS ((const void *, const void *))) alias_compare);

  return added;
}
warning: parse error {
  FILE *fp;
  char *full_fname;
  size_t added;
  static const char aliasfile[] = "/locale.alias";

  full_fname = (char *) alloca (fname_len + sizeof aliasfile);
#ifdef HAVE_MEMPCPY
  mempcpy (mempcpy (full_fname, fname, fname_len),
	   aliasfile, sizeof aliasfile);
#else
  memcpy (full_fname, fname, fname_len);
  memcpy (&full_fname[fname_len], aliasfile, sizeof aliasfile);
#endif

  fp = fopen (relocate (full_fname), "r");
  freea (full_fname);
  if (fp == NULL)
    return 0;

#ifdef HAVE___FSETLOCKING
  /* No threads present.  */
  __fsetlocking (fp, FSETLOCKING_BYCALLER);
#endif

  added = 0;
  while (!FEOF (fp))
    {
      /* It is a reasonable approach to use a fix buffer here because
	 a) we are only interested in the first two fields
	 b) these fields must be usable as file names and so must not
	    be that long
	 We avoid a multi-kilobyte buffer here since this would use up
	 stack space which we might not have if the program ran out of
	 memory.  */
      char buf[400];
      char *alias;
      char *value;
      char *cp;

      if (FGETS (buf, sizeof buf, fp) == NULL)
	/* EOF reached.  */
	break;

      cp = buf;
      /* Ignore leading white space.  */
      while (isspace ((unsigned char) cp[0]))
	++cp;

      /* A leading '#' signals a comment line.  */
      if (cp[0] != '\0' && cp[0] != '#')
	{
	  alias = cp++;
	  while (cp[0] != '\0' && !isspace ((unsigned char) cp[0]))
	    ++cp;
	  /* Terminate alias name.  */
	  if (cp[0] != '\0')
	    *cp++ = '\0';

	  /* Now look for the beginning of the value.  */
	  while (isspace ((unsigned char) cp[0]))
	    ++cp;

	  if (cp[0] != '\0')
	    {
	      size_t alias_len;
	      size_t value_len;

	      value = cp++;
	      while (cp[0] != '\0' && !isspace ((unsigned char) cp[0]))
		++cp;
	      /* Terminate value.  */
	      if (cp[0] == '\n')
		{
		  /* This has to be done to make the following test
		     for the end of line possible.  We are looking for
		     the terminating '\n' which do not overwrite here.  */
		  *cp++ = '\0';
		  *cp = '\n';
		}
	      else if (cp[0] != '\0')
		*cp++ = '\0';

	      if (nmap >= maxmap)
		if (__builtin_expect (extend_alias_table (), 0))
		  return added;

	      alias_len = strlen (alias) + 1;
	      value_len = strlen (value) + 1;

	      if (string_space_act + alias_len + value_len > string_space_max)
		{
		  /* Increase size of memory pool.  */
		  size_t new_size = (string_space_max
				     + (alias_len + value_len > 1024
					? alias_len + value_len : 1024));
		  char *new_pool = (char *) realloc (string_space, new_size);
		  if (new_pool == NULL)
		    return added;

		  if (__builtin_expect (string_space != new_pool, 0))
		    {
		      size_t i;

		      for (i = 0; i < nmap; i++)
			{
			  map[i].alias += new_pool - string_space;
			  map[i].value += new_pool - string_space;
			}
		    }

		  string_space = new_pool;
		  string_space_max = new_size;
		}

	      map[nmap].alias = memcpy (&string_space[string_space_act],
					alias, alias_len);
	      string_space_act += alias_len;

	      map[nmap].value = memcpy (&string_space[string_space_act],
					value, value_len);
	      string_space_act += value_len;

	      ++nmap;
	      ++added;
	    }
	}

      /* Possibly not the whole line fits into the buffer.  Ignore
	 the rest of the line.  */
      while (strchr (buf, '\n') == NULL)
	if (FGETS (buf, sizeof buf, fp) == NULL)
	  /* Make sure the inner loop will be left.  The outer loop
	     will exit at the `feof' test.  */
	  break;
    }

  /* Should we test for ferror()?  I think we have to silently ignore
     errors.  --drepper  */
  fclose (fp);

  if (added > 0)
    qsort (map, nmap, sizeof (struct alias_map),
	   (int (*) PARAMS ((const void *, const void *))) alias_compare);

  return added;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\intl\localealias.c:223
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\intl\localealias.c:393
parsing error 
{
#if defined _LIBC || defined HAVE_STRCASECMP
  return strcasecmp (map1->alias, map2->alias);
#else
  const unsigned char *p1 = (const unsigned char *) map1->alias;
  const unsigned char *p2 = (const unsigned char *) map2->alias;
  unsigned char c1, c2;

  if (p1 == p2)
    return 0;

  do
    {
      /* I know this seems to be odd but the tolower() function in
	 some systems libc cannot handle nonalpha characters.  */
      c1 = isupper (*p1) ? tolower (*p1) : *p1;
      c2 = isupper (*p2) ? tolower (*p2) : *p2;
      if (c1 == '\0')
	break;
      ++p1;
      ++p2;
    }
  while (c1 == c2);

  return c1 - c2;
#endif
}
warning: parse error {
#if defined _LIBC || defined HAVE_STRCASECMP
  return strcasecmp (map1->alias, map2->alias);
#else
  const unsigned char *p1 = (const unsigned char *) map1->alias;
  const unsigned char *p2 = (const unsigned char *) map2->alias;
  unsigned char c1, c2;

  if (p1 == p2)
    return 0;

  do
    {
      /* I know this seems to be odd but the tolower() function in
	 some systems libc cannot handle nonalpha characters.  */
      c1 = isupper (*p1) ? tolower (*p1) : *p1;
      c2 = isupper (*p2) ? tolower (*p2) : *p2;
      if (c1 == '\0')
	break;
      ++p1;
      ++p2;
    }
  while (c1 == c2);

  return c1 - c2;
#endif
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\intl\localealias.c:395
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\intl\localename.c...
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\intl\localename.c:386
parsing error 
{
  const char *retval;

#ifndef WIN32

  /* Use the POSIX methods of looking to 'LC_ALL', 'LC_xxx', and 'LANG'.
     On some systems this can be done by the 'setlocale' function itself.  */
# if defined HAVE_SETLOCALE && defined HAVE_LC_MESSAGES && defined HAVE_LOCALE_NULL
  retval = setlocale (category, NULL);
# else
  /* Setting of LC_ALL overwrites all other.  */
  retval = getenv ("LC_ALL");
  if (retval == NULL || retval[0] == '\0')
    {
      /* Next comes the name of the desired category.  */
      retval = getenv (categoryname);
      if (retval == NULL || retval[0] == '\0')
	{
	  /* Last possibility is the LANG environment variable.  */
	  retval = getenv ("LANG");
	  if (retval == NULL || retval[0] == '\0')
	    /* We use C as the default domain.  POSIX says this is
	       implementation defined.  */
	    retval = "C";
	}
    }
# endif

  return retval;

#else /* WIN32 */

  /* Return an XPG style locale name language[_territory][@modifier].
     Don't even bother determining the codeset; it's not useful in this
     context, because message catalogs are not specific to a single
     codeset.  */

  LCID lcid;
  LANGID langid;
  int primary, sub;

  /* Let the user override the system settings through environment
     variables, as on POSIX systems.  */
  retval = getenv ("LC_ALL");
  if (retval != NULL && retval[0] != '\0')
    return retval;
  retval = getenv (categoryname);
  if (retval != NULL && retval[0] != '\0')
    return retval;
  retval = getenv ("LANG");
  if (retval != NULL && retval[0] != '\0')
    return retval;

  /* Use native Win32 API locale ID.  */
  lcid = GetThreadLocale ();

  /* Strip off the sorting rules, keep only the language part.  */
  langid = LANGIDFROMLCID (lcid);

  /* Split into language and territory part.  */
  primary = PRIMARYLANGID (langid);
  sub = SUBLANGID (langid);

  /* Dispatch on language.
     See also http://www.unicode.org/unicode/onlinedat/languages.html .
     For details about languages, see http://www.ethnologue.com/ .  */
  switch (primary)
    {
    case LANG_AFRIKAANS: return "af_ZA";
    case LANG_ALBANIAN: return "sq_AL";
    case 0x5e: /* AMHARIC */ return "am_ET";
    case LANG_ARABIC:
      switch (sub)
	{
	case SUBLANG_ARABIC_SAUDI_ARABIA: return "ar_SA";
	case SUBLANG_ARABIC_IRAQ: return "ar_IQ";
	case SUBLANG_ARABIC_EGYPT: return "ar_EG";
	case SUBLANG_ARABIC_LIBYA: return "ar_LY";
	case SUBLANG_ARABIC_ALGERIA: return "ar_DZ";
	case SUBLANG_ARABIC_MOROCCO: return "ar_MA";
	case SUBLANG_ARABIC_TUNISIA: return "ar_TN";
	case SUBLANG_ARABIC_OMAN: return "ar_OM";
	case SUBLANG_ARABIC_YEMEN: return "ar_YE";
	case SUBLANG_ARABIC_SYRIA: return "ar_SY";
	case SUBLANG_ARABIC_JORDAN: return "ar_JO";
	case SUBLANG_ARABIC_LEBANON: return "ar_LB";
	case SUBLANG_ARABIC_KUWAIT: return "ar_KW";
	case SUBLANG_ARABIC_UAE: return "ar_AE";
	case SUBLANG_ARABIC_BAHRAIN: return "ar_BH";
	case SUBLANG_ARABIC_QATAR: return "ar_QA";
	}
      return "ar";
    case LANG_ARMENIAN: return "hy_AM";
    case LANG_ASSAMESE: return "as_IN";
    case LANG_AZERI:
      switch (sub)
	{
	/* FIXME: Adjust this when Azerbaijani locales appear on Unix.  */
	case SUBLANG_AZERI_LATIN: return "az_AZ@latin";
	case SUBLANG_AZERI_CYRILLIC: return "az_AZ@cyrillic";
	}
      return "az";
    case LANG_BASQUE:
      return "eu"; /* Ambiguous: could be "eu_ES" or "eu_FR".  */
    case LANG_BELARUSIAN: return "be_BY";
    case LANG_BENGALI: return "bn_IN";
    case LANG_BULGARIAN: return "bg_BG";
    case 0x55: /* BURMESE */ return "my_MM";
    case 0x53: /* CAMBODIAN */ return "km_KH";
    case LANG_CATALAN: return "ca_ES";
    case 0x5c: /* CHEROKEE */ return "chr_US";
    case LANG_CHINESE:
      switch (sub)
	{
	case SUBLANG_CHINESE_TRADITIONAL: return "zh_TW";
	case SUBLANG_CHINESE_SIMPLIFIED: return "zh_CN";
	case SUBLANG_CHINESE_HONGKONG: return "zh_HK";
	case SUBLANG_CHINESE_SINGAPORE: return "zh_SG";
	case SUBLANG_CHINESE_MACAU: return "zh_MO";
	}
      return "zh";
    case LANG_CROATIAN:		/* LANG_CROATIAN == LANG_SERBIAN
				 * What used to be called Serbo-Croatian
				 * should really now be two separate
				 * languages because of political reasons.
				 * (Says tml, who knows nothing about Serbian
				 * or Croatian.)
				 * (I can feel those flames coming already.)
				 */
      switch (sub)
	{
	case SUBLANG_DEFAULT: return "hr_HR";
	case SUBLANG_SERBIAN_LATIN: return "sr_YU";
	case SUBLANG_SERBIAN_CYRILLIC: return "sr_YU@cyrillic";
	}
      return "hr";
    case LANG_CZECH: return "cs_CZ";
    case LANG_DANISH: return "da_DK";
    case LANG_DIVEHI: return "div_MV";
    case LANG_DUTCH:
      switch (sub)
	{
	case SUBLANG_DUTCH: return "nl_NL";
	case SUBLANG_DUTCH_BELGIAN: /* FLEMISH, VLAAMS */ return "nl_BE";
	}
      return "nl";
    case 0x66: /* EDO */ return "bin_NG";
    case LANG_ENGLISH:
      switch (sub)
	{
	/* SUBLANG_ENGLISH_US == SUBLANG_DEFAULT. Heh. I thought
	 * English was the language spoken in England.
	 * Oh well.
	 */
	case SUBLANG_ENGLISH_US: return "en_US";
	case SUBLANG_ENGLISH_UK: return "en_GB";
	case SUBLANG_ENGLISH_AUS: return "en_AU";
	case SUBLANG_ENGLISH_CAN: return "en_CA";
	case SUBLANG_ENGLISH_NZ: return "en_NZ";
	case SUBLANG_ENGLISH_EIRE: return "en_IE";
	case SUBLANG_ENGLISH_SOUTH_AFRICA: return "en_ZA";
	case SUBLANG_ENGLISH_JAMAICA: return "en_JM";
	case SUBLANG_ENGLISH_CARIBBEAN: return "en_GD"; /* Grenada? */
	case SUBLANG_ENGLISH_BELIZE: return "en_BZ";
	case SUBLANG_ENGLISH_TRINIDAD: return "en_TT";
	case SUBLANG_ENGLISH_ZIMBABWE: return "en_ZW";
	case SUBLANG_ENGLISH_PHILIPPINES: return "en_PH";
	}
      return "en";
    case LANG_ESTONIAN: return "et_EE";
    case LANG_FAEROESE: return "fo_FO";
    case LANG_FARSI: return "fa_IR";
    case LANG_FINNISH: return "fi_FI";
    case LANG_FRENCH:
      switch (sub)
	{
	case SUBLANG_FRENCH: return "fr_FR";
	case SUBLANG_FRENCH_BELGIAN: /* WALLOON */ return "fr_BE";
	case SUBLANG_FRENCH_CANADIAN: return "fr_CA";
	case SUBLANG_FRENCH_SWISS: return "fr_CH";
	case SUBLANG_FRENCH_LUXEMBOURG: return "fr_LU";
	case SUBLANG_FRENCH_MONACO: return "fr_MC";
	}
      return "fr";
    case 0x62: /* FRISIAN */ return "fy_NL";
    case 0x67: /* FULFULDE */ return "ful_NG";
    case 0x3c: /* GAELIC */
      switch (sub)
	{
	case 0x01: /* SCOTTISH */ return "gd_GB";
	case 0x02: /* IRISH */ return "ga_IE";
	}
      return "C";
    case LANG_GALICIAN: return "gl_ES";
    case LANG_GEORGIAN: return "ka_GE";
    case LANG_GERMAN:
      switch (sub)
	{
	case SUBLANG_GERMAN: return "de_DE";
	case SUBLANG_GERMAN_SWISS: return "de_CH";
	case SUBLANG_GERMAN_AUSTRIAN: return "de_AT";
	case SUBLANG_GERMAN_LUXEMBOURG: return "de_LU";
	case SUBLANG_GERMAN_LIECHTENSTEIN: return "de_LI";
	}
      return "de";
    case LANG_GREEK: return "el_GR";
    case 0x74: /* GUARANI */ return "gn_PY";
    case LANG_GUJARATI: return "gu_IN";
    case 0x68: /* HAUSA */ return "ha_NG";
    case 0x75: /* HAWAIIAN */
      /* FIXME: Do they mean Hawaiian ("haw_US", 1000 speakers)
	 or Hawaii Creole English ("cpe_US", 600000 speakers)?  */
      return "cpe_US";
    case LANG_HEBREW: return "he_IL";
    case LANG_HINDI: return "hi_IN";
    case LANG_HUNGARIAN: return "hu_HU";
    case 0x69: /* IBIBIO */ return "nic_NG";
    case LANG_ICELANDIC: return "is_IS";
    case 0x70: /* IGBO */ return "ibo_NG";
    case LANG_INDONESIAN: return "id_ID";
    case 0x5d: /* INUKTITUT */ return "iu_CA";
    case LANG_ITALIAN:
      switch (sub)
	{
	case SUBLANG_ITALIAN: return "it_IT";
	case SUBLANG_ITALIAN_SWISS: return "it_CH";
	}
      return "it";
    case LANG_JAPANESE: return "ja_JP";
    case LANG_KANNADA: return "kn_IN";
    case 0x71: /* KANURI */ return "kau_NG";
    case LANG_KASHMIRI:
      switch (sub)
	{
	case SUBLANG_DEFAULT: return "ks_PK";
	case SUBLANG_KASHMIRI_INDIA: return "ks_IN";
	}
      return "ks";
    case LANG_KAZAK: return "kk_KZ";
    case LANG_KONKANI:
      /* FIXME: Adjust this when such locales appear on Unix.  */
      return "kok_IN";
    case LANG_KOREAN: return "ko_KR";
    case LANG_KYRGYZ: return "ky_KG";
    case 0x54: /* LAO */ return "lo_LA";
    case 0x76: /* LATIN */ return "la_VA";
    case LANG_LATVIAN: return "lv_LV";
    case LANG_LITHUANIAN: return "lt_LT";
    case LANG_MACEDONIAN: return "mk_MK";
    case LANG_MALAY:
      switch (sub)
	{
	case SUBLANG_MALAY_MALAYSIA: return "ms_MY";
	case SUBLANG_MALAY_BRUNEI_DARUSSALAM: return "ms_BN";
	}
      return "ms";
    case LANG_MALAYALAM: return "ml_IN";
    case 0x3a: /* MALTESE */ return "mt_MT";
    case LANG_MANIPURI:
      /* FIXME: Adjust this when such locales appear on Unix.  */
      return "mni_IN";
    case LANG_MARATHI: return "mr_IN";
    case LANG_MONGOLIAN:
      return "mn"; /* Ambiguous: could be "mn_CN" or "mn_MN".  */
    case LANG_NEPALI:
      switch (sub)
	{
	case SUBLANG_DEFAULT: return "ne_NP";
	case SUBLANG_NEPALI_INDIA: return "ne_IN";
	}
      return "ne";
    case LANG_NORWEGIAN:
      switch (sub)
	{
	case SUBLANG_NORWEGIAN_BOKMAL: return "no_NO";
	case SUBLANG_NORWEGIAN_NYNORSK: return "nn_NO";
	}
      return "no";
    case LANG_ORIYA: return "or_IN";
    case 0x72: /* OROMO */ return "om_ET";
    case 0x79: /* PAPIAMENTU */ return "pap_AN";
    case 0x63: /* PASHTO */
      return "ps"; /* Ambiguous: could be "ps_PK" or "ps_AF".  */
    case LANG_POLISH: return "pl_PL";
    case LANG_PORTUGUESE:
      switch (sub)
	{
	case SUBLANG_PORTUGUESE: return "pt_PT";
	/* Hmm. SUBLANG_PORTUGUESE_BRAZILIAN == SUBLANG_DEFAULT.
	   Same phenomenon as SUBLANG_ENGLISH_US == SUBLANG_DEFAULT. */
	case SUBLANG_PORTUGUESE_BRAZILIAN: return "pt_BR";
	}
      return "pt";
    case LANG_PUNJABI: return "pa_IN";
    case 0x17: /* RHAETO-ROMANCE */ return "rm_CH";
    case LANG_ROMANIAN: return "ro_RO";
    case LANG_RUSSIAN:
      return "ru"; /* Ambiguous: could be "ru_RU" or "ru_UA".  */
    case 0x3b: /* SAMI */ return "se_NO";
    case LANG_SANSKRIT: return "sa_IN";
    case LANG_SINDHI: return "sd";
    case 0x5b: /* SINHALESE */ return "si_LK";
    case LANG_SLOVAK: return "sk_SK";
    case LANG_SLOVENIAN: return "sl_SI";
    case 0x77: /* SOMALI */ return "so_SO";
    case LANG_SORBIAN:
      /* FIXME: Adjust this when such locales appear on Unix.  */
      return "wen_DE";
    case LANG_SPANISH:
      switch (sub)
	{
	case SUBLANG_SPANISH: return "es_ES";
	case SUBLANG_SPANISH_MEXICAN: return "es_MX";
	case SUBLANG_SPANISH_MODERN:
	  return "es_ES@modern";	/* not seen on Unix */
	case SUBLANG_SPANISH_GUATEMALA: return "es_GT";
	case SUBLANG_SPANISH_COSTA_RICA: return "es_CR";
	case SUBLANG_SPANISH_PANAMA: return "es_PA";
	case SUBLANG_SPANISH_DOMINICAN_REPUBLIC: return "es_DO";
	case SUBLANG_SPANISH_VENEZUELA: return "es_VE";
	case SUBLANG_SPANISH_COLOMBIA: return "es_CO";
	case SUBLANG_SPANISH_PERU: return "es_PE";
	case SUBLANG_SPANISH_ARGENTINA: return "es_AR";
	case SUBLANG_SPANISH_ECUADOR: return "es_EC";
	case SUBLANG_SPANISH_CHILE: return "es_CL";
	case SUBLANG_SPANISH_URUGUAY: return "es_UY";
	case SUBLANG_SPANISH_PARAGUAY: return "es_PY";
	case SUBLANG_SPANISH_BOLIVIA: return "es_BO";
	case SUBLANG_SPANISH_EL_SALVADOR: return "es_SV";
	case SUBLANG_SPANISH_HONDURAS: return "es_HN";
	case SUBLANG_SPANISH_NICARAGUA: return "es_NI";
	case SUBLANG_SPANISH_PUERTO_RICO: return "es_PR";
	}
      return "es";
    case 0x30: /* SUTU */ return "bnt_TZ";
    case LANG_SWAHILI: return "sw_KE";
    case LANG_SWEDISH:
      switch (sub)
	{
	case SUBLANG_DEFAULT: return "sv_SE";
	case SUBLANG_SWEDISH_FINLAND: return "sv_FI";
	}
      return "sv";
    case LANG_SYRIAC: return "syr_TR"; /* An extinct language.  */
    case 0x64: /* TAGALOG */ return "tl_PH";
    case 0x28: /* TAJIK */ return "tg_TJ";
    case 0x5f: /* TAMAZIGHT */ return "ber_MA";
    case LANG_TAMIL:
      return "ta"; /* Ambiguous: could be "ta_IN" or "ta_LK" or "ta_SG".  */
    case LANG_TATAR: return "tt_RU";
    case LANG_TELUGU: return "te_IN";
    case LANG_THAI: return "th_TH";
    case 0x51: /* TIBETAN */ return "bo_CN";
    case 0x73: /* TIGRINYA */ return "ti_ET";
    case 0x31: /* TSONGA */ return "ts_ZA";
    case LANG_TURKISH: return "tr_TR";
    case 0x42: /* TURKMEN */ return "tk_TM";
    case LANG_UKRAINIAN: return "uk_UA";
    case LANG_URDU:
      switch (sub)
	{
	case SUBLANG_URDU_PAKISTAN: return "ur_PK";
	case SUBLANG_URDU_INDIA: return "ur_IN";
	}
      return "ur";
    case LANG_UZBEK:
      switch (sub)
	{
	/* FIXME: Adjust this when Uzbek locales appear on Unix.  */
	case SUBLANG_UZBEK_LATIN: return "uz_UZ@latin";
	case SUBLANG_UZBEK_CYRILLIC: return "uz_UZ@cyrillic";
	}
      return "uz";
    case 0x33: /* VENDA */ return "ven_ZA";
    case LANG_VIETNAMESE: return "vi_VN";
    case 0x52: /* WELSH */ return "cy_GB";
    case 0x34: /* XHOSA */ return "xh_ZA";
    case 0x78: /* YI */ return "sit_CN";
    case 0x3d: /* YIDDISH */ return "yi_IL";
    case 0x6a: /* YORUBA */ return "yo_NG";
    case 0x35: /* ZULU */ return "zu_ZA";
    default: return "C";
    }

#endif
}
warning: parse error {
  const char *retval;

#ifndef WIN32

  /* Use the POSIX methods of looking to 'LC_ALL', 'LC_xxx', and 'LANG'.
     On some systems this can be done by the 'setlocale' function itself.  */
# if defined HAVE_SETLOCALE && defined HAVE_LC_MESSAGES && defined HAVE_LOCALE_NULL
  retval = setlocale (category, NULL);
# else
  /* Setting of LC_ALL overwrites all other.  */
  retval = getenv ("LC_ALL");
  if (retval == NULL || retval[0] == '\0')
    {
      /* Next comes the name of the desired category.  */
      retval = getenv (categoryname);
      if (retval == NULL || retval[0] == '\0')
	{
	  /* Last possibility is the LANG environment variable.  */
	  retval = getenv ("LANG");
	  if (retval == NULL || retval[0] == '\0')
	    /* We use C as the default domain.  POSIX says this is
	       implementation defined.  */
	    retval = "C";
	}
    }
# endif

  return retval;

#else /* WIN32 */

  /* Return an XPG style locale name language[_territory][@modifier].
     Don't even bother determining the codeset; it's not useful in this
     context, because message catalogs are not specific to a single
     codeset.  */

  LCID lcid;
  LANGID langid;
  int primary, sub;

  /* Let the user override the system settings through environment
     variables, as on POSIX systems.  */
  retval = getenv ("LC_ALL");
  if (retval != NULL && retval[0] != '\0')
    return retval;
  retval = getenv (categoryname);
  if (retval != NULL && retval[0] != '\0')
    return retval;
  retval = getenv ("LANG");
  if (retval != NULL && retval[0] != '\0')
    return retval;

  /* Use native Win32 API locale ID.  */
  lcid = GetThreadLocale ();

  /* Strip off the sorting rules, keep only the language part.  */
  langid = LANGIDFROMLCID (lcid);

  /* Split into language and territory part.  */
  primary = PRIMARYLANGID (langid);
  sub = SUBLANGID (langid);

  /* Dispatch on language.
     See also http://www.unicode.org/unicode/onlinedat/languages.html .
     For details about languages, see http://www.ethnologue.com/ .  */
  switch (primary)
    {
    case LANG_AFRIKAANS: return "af_ZA";
    case LANG_ALBANIAN: return "sq_AL";
    case 0x5e: /* AMHARIC */ return "am_ET";
    case LANG_ARABIC:
      switch (sub)
	{
	case SUBLANG_ARABIC_SAUDI_ARABIA: return "ar_SA";
	case SUBLANG_ARABIC_IRAQ: return "ar_IQ";
	case SUBLANG_ARABIC_EGYPT: return "ar_EG";
	case SUBLANG_ARABIC_LIBYA: return "ar_LY";
	case SUBLANG_ARABIC_ALGERIA: return "ar_DZ";
	case SUBLANG_ARABIC_MOROCCO: return "ar_MA";
	case SUBLANG_ARABIC_TUNISIA: return "ar_TN";
	case SUBLANG_ARABIC_OMAN: return "ar_OM";
	case SUBLANG_ARABIC_YEMEN: return "ar_YE";
	case SUBLANG_ARABIC_SYRIA: return "ar_SY";
	case SUBLANG_ARABIC_JORDAN: return "ar_JO";
	case SUBLANG_ARABIC_LEBANON: return "ar_LB";
	case SUBLANG_ARABIC_KUWAIT: return "ar_KW";
	case SUBLANG_ARABIC_UAE: return "ar_AE";
	case SUBLANG_ARABIC_BAHRAIN: return "ar_BH";
	case SUBLANG_ARABIC_QATAR: return "ar_QA";
	}
      return "ar";
    case LANG_ARMENIAN: return "hy_AM";
    case LANG_ASSAMESE: return "as_IN";
    case LANG_AZERI:
      switch (sub)
	{
	/* FIXME: Adjust this when Azerbaijani locales appear on Unix.  */
	case SUBLANG_AZERI_LATIN: return "az_AZ@latin";
	case SUBLANG_AZERI_CYRILLIC: return "az_AZ@cyrillic";
	}
      return "az";
    case LANG_BASQUE:
      return "eu"; /* Ambiguous: could be "eu_ES" or "eu_FR".  */
    case LANG_BELARUSIAN: return "be_BY";
    case LANG_BENGALI: return "bn_IN";
    case LANG_BULGARIAN: return "bg_BG";
    case 0x55: /* BURMESE */ return "my_MM";
    case 0x53: /* CAMBODIAN */ return "km_KH";
    case LANG_CATALAN: return "ca_ES";
    case 0x5c: /* CHEROKEE */ return "chr_US";
    case LANG_CHINESE:
      switch (sub)
	{
	case SUBLANG_CHINESE_TRADITIONAL: return "zh_TW";
	case SUBLANG_CHINESE_SIMPLIFIED: return "zh_CN";
	case SUBLANG_CHINESE_HONGKONG: return "zh_HK";
	case SUBLANG_CHINESE_SINGAPORE: return "zh_SG";
	case SUBLANG_CHINESE_MACAU: return "zh_MO";
	}
      return "zh";
    case LANG_CROATIAN:		/* LANG_CROATIAN == LANG_SERBIAN
				 * What used to be called Serbo-Croatian
				 * should really now be two separate
				 * languages because of political reasons.
				 * (Says tml, who knows nothing about Serbian
				 * or Croatian.)
				 * (I can feel those flames coming already.)
				 */
      switch (sub)
	{
	case SUBLANG_DEFAULT: return "hr_HR";
	case SUBLANG_SERBIAN_LATIN: return "sr_YU";
	case SUBLANG_SERBIAN_CYRILLIC: return "sr_YU@cyrillic";
	}
      return "hr";
    case LANG_CZECH: return "cs_CZ";
    case LANG_DANISH: return "da_DK";
    case LANG_DIVEHI: return "div_MV";
    case LANG_DUTCH:
      switch (sub)
	{
	case SUBLANG_DUTCH: return "nl_NL";
	case SUBLANG_DUTCH_BELGIAN: /* FLEMISH, VLAAMS */ return "nl_BE";
	}
      return "nl";
    case 0x66: /* EDO */ return "bin_NG";
    case LANG_ENGLISH:
      switch (sub)
	{
	/* SUBLANG_ENGLISH_US == SUBLANG_DEFAULT. Heh. I thought
	 * English was the language spoken in England.
	 * Oh well.
	 */
	case SUBLANG_ENGLISH_US: return "en_US";
	case SUBLANG_ENGLISH_UK: return "en_GB";
	case SUBLANG_ENGLISH_AUS: return "en_AU";
	case SUBLANG_ENGLISH_CAN: return "en_CA";
	case SUBLANG_ENGLISH_NZ: return "en_NZ";
	case SUBLANG_ENGLISH_EIRE: return "en_IE";
	case SUBLANG_ENGLISH_SOUTH_AFRICA: return "en_ZA";
	case SUBLANG_ENGLISH_JAMAICA: return "en_JM";
	case SUBLANG_ENGLISH_CARIBBEAN: return "en_GD"; /* Grenada? */
	case SUBLANG_ENGLISH_BELIZE: return "en_BZ";
	case SUBLANG_ENGLISH_TRINIDAD: return "en_TT";
	case SUBLANG_ENGLISH_ZIMBABWE: return "en_ZW";
	case SUBLANG_ENGLISH_PHILIPPINES: return "en_PH";
	}
      return "en";
    case LANG_ESTONIAN: return "et_EE";
    case LANG_FAEROESE: return "fo_FO";
    case LANG_FARSI: return "fa_IR";
    case LANG_FINNISH: return "fi_FI";
    case LANG_FRENCH:
      switch (sub)
	{
	case SUBLANG_FRENCH: return "fr_FR";
	case SUBLANG_FRENCH_BELGIAN: /* WALLOON */ return "fr_BE";
	case SUBLANG_FRENCH_CANADIAN: return "fr_CA";
	case SUBLANG_FRENCH_SWISS: return "fr_CH";
	case SUBLANG_FRENCH_LUXEMBOURG: return "fr_LU";
	case SUBLANG_FRENCH_MONACO: return "fr_MC";
	}
      return "fr";
    case 0x62: /* FRISIAN */ return "fy_NL";
    case 0x67: /* FULFULDE */ return "ful_NG";
    case 0x3c: /* GAELIC */
      switch (sub)
	{
	case 0x01: /* SCOTTISH */ return "gd_GB";
	case 0x02: /* IRISH */ return "ga_IE";
	}
      return "C";
    case LANG_GALICIAN: return "gl_ES";
    case LANG_GEORGIAN: return "ka_GE";
    case LANG_GERMAN:
      switch (sub)
	{
	case SUBLANG_GERMAN: return "de_DE";
	case SUBLANG_GERMAN_SWISS: return "de_CH";
	case SUBLANG_GERMAN_AUSTRIAN: return "de_AT";
	case SUBLANG_GERMAN_LUXEMBOURG: return "de_LU";
	case SUBLANG_GERMAN_LIECHTENSTEIN: return "de_LI";
	}
      return "de";
    case LANG_GREEK: return "el_GR";
    case 0x74: /* GUARANI */ return "gn_PY";
    case LANG_GUJARATI: return "gu_IN";
    case 0x68: /* HAUSA */ return "ha_NG";
    case 0x75: /* HAWAIIAN */
      /* FIXME: Do they mean Hawaiian ("haw_US", 1000 speakers)
	 or Hawaii Creole English ("cpe_US", 600000 speakers)?  */
      return "cpe_US";
    case LANG_HEBREW: return "he_IL";
    case LANG_HINDI: return "hi_IN";
    case LANG_HUNGARIAN: return "hu_HU";
    case 0x69: /* IBIBIO */ return "nic_NG";
    case LANG_ICELANDIC: return "is_IS";
    case 0x70: /* IGBO */ return "ibo_NG";
    case LANG_INDONESIAN: return "id_ID";
    case 0x5d: /* INUKTITUT */ return "iu_CA";
    case LANG_ITALIAN:
      switch (sub)
	{
	case SUBLANG_ITALIAN: return "it_IT";
	case SUBLANG_ITALIAN_SWISS: return "it_CH";
	}
      return "it";
    case LANG_JAPANESE: return "ja_JP";
    case LANG_KANNADA: return "kn_IN";
    case 0x71: /* KANURI */ return "kau_NG";
    case LANG_KASHMIRI:
      switch (sub)
	{
	case SUBLANG_DEFAULT: return "ks_PK";
	case SUBLANG_KASHMIRI_INDIA: return "ks_IN";
	}
      return "ks";
    case LANG_KAZAK: return "kk_KZ";
    case LANG_KONKANI:
      /* FIXME: Adjust this when such locales appear on Unix.  */
      return "kok_IN";
    case LANG_KOREAN: return "ko_KR";
    case LANG_KYRGYZ: return "ky_KG";
    case 0x54: /* LAO */ return "lo_LA";
    case 0x76: /* LATIN */ return "la_VA";
    case LANG_LATVIAN: return "lv_LV";
    case LANG_LITHUANIAN: return "lt_LT";
    case LANG_MACEDONIAN: return "mk_MK";
    case LANG_MALAY:
      switch (sub)
	{
	case SUBLANG_MALAY_MALAYSIA: return "ms_MY";
	case SUBLANG_MALAY_BRUNEI_DARUSSALAM: return "ms_BN";
	}
      return "ms";
    case LANG_MALAYALAM: return "ml_IN";
    case 0x3a: /* MALTESE */ return "mt_MT";
    case LANG_MANIPURI:
      /* FIXME: Adjust this when such locales appear on Unix.  */
      return "mni_IN";
    case LANG_MARATHI: return "mr_IN";
    case LANG_MONGOLIAN:
      return "mn"; /* Ambiguous: could be "mn_CN" or "mn_MN".  */
    case LANG_NEPALI:
      switch (sub)
	{
	case SUBLANG_DEFAULT: return "ne_NP";
	case SUBLANG_NEPALI_INDIA: return "ne_IN";
	}
      return "ne";
    case LANG_NORWEGIAN:
      switch (sub)
	{
	case SUBLANG_NORWEGIAN_BOKMAL: return "no_NO";
	case SUBLANG_NORWEGIAN_NYNORSK: return "nn_NO";
	}
      return "no";
    case LANG_ORIYA: return "or_IN";
    case 0x72: /* OROMO */ return "om_ET";
    case 0x79: /* PAPIAMENTU */ return "pap_AN";
    case 0x63: /* PASHTO */
      return "ps"; /* Ambiguous: could be "ps_PK" or "ps_AF".  */
    case LANG_POLISH: return "pl_PL";
    case LANG_PORTUGUESE:
      switch (sub)
	{
	case SUBLANG_PORTUGUESE: return "pt_PT";
	/* Hmm. SUBLANG_PORTUGUESE_BRAZILIAN == SUBLANG_DEFAULT.
	   Same phenomenon as SUBLANG_ENGLISH_US == SUBLANG_DEFAULT. */
	case SUBLANG_PORTUGUESE_BRAZILIAN: return "pt_BR";
	}
      return "pt";
    case LANG_PUNJABI: return "pa_IN";
    case 0x17: /* RHAETO-ROMANCE */ return "rm_CH";
    case LANG_ROMANIAN: return "ro_RO";
    case LANG_RUSSIAN:
      return "ru"; /* Ambiguous: could be "ru_RU" or "ru_UA".  */
    case 0x3b: /* SAMI */ return "se_NO";
    case LANG_SANSKRIT: return "sa_IN";
    case LANG_SINDHI: return "sd";
    case 0x5b: /* SINHALESE */ return "si_LK";
    case LANG_SLOVAK: return "sk_SK";
    case LANG_SLOVENIAN: return "sl_SI";
    case 0x77: /* SOMALI */ return "so_SO";
    case LANG_SORBIAN:
      /* FIXME: Adjust this when such locales appear on Unix.  */
      return "wen_DE";
    case LANG_SPANISH:
      switch (sub)
	{
	case SUBLANG_SPANISH: return "es_ES";
	case SUBLANG_SPANISH_MEXICAN: return "es_MX";
	case SUBLANG_SPANISH_MODERN:
	  return "es_ES@modern";	/* not seen on Unix */
	case SUBLANG_SPANISH_GUATEMALA: return "es_GT";
	case SUBLANG_SPANISH_COSTA_RICA: return "es_CR";
	case SUBLANG_SPANISH_PANAMA: return "es_PA";
	case SUBLANG_SPANISH_DOMINICAN_REPUBLIC: return "es_DO";
	case SUBLANG_SPANISH_VENEZUELA: return "es_VE";
	case SUBLANG_SPANISH_COLOMBIA: return "es_CO";
	case SUBLANG_SPANISH_PERU: return "es_PE";
	case SUBLANG_SPANISH_ARGENTINA: return "es_AR";
	case SUBLANG_SPANISH_ECUADOR: return "es_EC";
	case SUBLANG_SPANISH_CHILE: return "es_CL";
	case SUBLANG_SPANISH_URUGUAY: return "es_UY";
	case SUBLANG_SPANISH_PARAGUAY: return "es_PY";
	case SUBLANG_SPANISH_BOLIVIA: return "es_BO";
	case SUBLANG_SPANISH_EL_SALVADOR: return "es_SV";
	case SUBLANG_SPANISH_HONDURAS: return "es_HN";
	case SUBLANG_SPANISH_NICARAGUA: return "es_NI";
	case SUBLANG_SPANISH_PUERTO_RICO: return "es_PR";
	}
      return "es";
    case 0x30: /* SUTU */ return "bnt_TZ";
    case LANG_SWAHILI: return "sw_KE";
    case LANG_SWEDISH:
      switch (sub)
	{
	case SUBLANG_DEFAULT: return "sv_SE";
	case SUBLANG_SWEDISH_FINLAND: return "sv_FI";
	}
      return "sv";
    case LANG_SYRIAC: return "syr_TR"; /* An extinct language.  */
    case 0x64: /* TAGALOG */ return "tl_PH";
    case 0x28: /* TAJIK */ return "tg_TJ";
    case 0x5f: /* TAMAZIGHT */ return "ber_MA";
    case LANG_TAMIL:
      return "ta"; /* Ambiguous: could be "ta_IN" or "ta_LK" or "ta_SG".  */
    case LANG_TATAR: return "tt_RU";
    case LANG_TELUGU: return "te_IN";
    case LANG_THAI: return "th_TH";
    case 0x51: /* TIBETAN */ return "bo_CN";
    case 0x73: /* TIGRINYA */ return "ti_ET";
    case 0x31: /* TSONGA */ return "ts_ZA";
    case LANG_TURKISH: return "tr_TR";
    case 0x42: /* TURKMEN */ return "tk_TM";
    case LANG_UKRAINIAN: return "uk_UA";
    case LANG_URDU:
      switch (sub)
	{
	case SUBLANG_URDU_PAKISTAN: return "ur_PK";
	case SUBLANG_URDU_INDIA: return "ur_IN";
	}
      return "ur";
    case LANG_UZBEK:
      switch (sub)
	{
	/* FIXME: Adjust this when Uzbek locales appear on Unix.  */
	case SUBLANG_UZBEK_LATIN: return "uz_UZ@latin";
	case SUBLANG_UZBEK_CYRILLIC: return "uz_UZ@cyrillic";
	}
      return "uz";
    case 0x33: /* VENDA */ return "ven_ZA";
    case LANG_VIETNAMESE: return "vi_VN";
    case 0x52: /* WELSH */ return "cy_GB";
    case 0x34: /* XHOSA */ return "xh_ZA";
    case 0x78: /* YI */ return "sit_CN";
    case 0x3d: /* YIDDISH */ return "yi_IL";
    case 0x6a: /* YORUBA */ return "yo_NG";
    case 0x35: /* ZULU */ return "zu_ZA";
    default: return "C";
    }

#endif
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\intl\localename.c:389
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\intl\log.c...
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\intl\log.c:33
parsing error 
{
  putc ('"', stream);
  for (; *str != '\0'; str++)
    if (*str == '\n')
      {
	fputs ("\\n\"", stream);
	if (str[1] == '\0')
	  return;
	fputs ("\n\"", stream);
      }
    else
      {
	if (*str == '"' || *str == '\\')
	  putc ('\\', stream);
	putc (*str, stream);
      }
  putc ('"', stream);
}
warning: parse error {
  putc ('"', stream);
  for (; *str != '\0'; str++)
    if (*str == '\n')
      {
	fputs ("\\n\"", stream);
	if (str[1] == '\0')
	  return;
	fputs ("\n\"", stream);
      }
    else
      {
	if (*str == '"' || *str == '\\')
	  putc ('\\', stream);
	putc (*str, stream);
      }
  putc ('"', stream);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\intl\log.c:36
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\intl\log.c:58
parsing error 
{
  static char *last_logfilename = NULL;
  static FILE *last_logfile = NULL;
  FILE *logfile;

  /* Can we reuse the last opened logfile?  */
  if (last_logfilename == NULL || strcmp (logfilename, last_logfilename) != 0)
    {
      /* Close the last used logfile.  */
      if (last_logfilename != NULL)
	{
	  if (last_logfile != NULL)
	    {
	      fclose (last_logfile);
	      last_logfile = NULL;
	    }
	  free (last_logfilename);
	  last_logfilename = NULL;
	}
      /* Open the logfile.  */
      last_logfilename = (char *) malloc (strlen (logfilename) + 1);
      if (last_logfilename == NULL)
	return;
      strcpy (last_logfilename, logfilename);
      last_logfile = fopen (logfilename, "a");
      if (last_logfile == NULL)
	return;
    }
  logfile = last_logfile;

  fprintf (logfile, "domain ");
  print_escaped (logfile, domainname);
  fprintf (logfile, "\nmsgid ");
  print_escaped (logfile, msgid1);
  if (plural)
    {
      fprintf (logfile, "\nmsgid_plural ");
      print_escaped (logfile, msgid2);
      fprintf (logfile, "\nmsgstr[0] \"\"\n");
    }
  else
    fprintf (logfile, "\nmsgstr \"\"\n");
  putc ('\n', logfile);
}
warning: parse error {
  static char *last_logfilename = NULL;
  static FILE *last_logfile = NULL;
  FILE *logfile;

  /* Can we reuse the last opened logfile?  */
  if (last_logfilename == NULL || strcmp (logfilename, last_logfilename) != 0)
    {
      /* Close the last used logfile.  */
      if (last_logfilename != NULL)
	{
	  if (last_logfile != NULL)
	    {
	      fclose (last_logfile);
	      last_logfile = NULL;
	    }
	  free (last_logfilename);
	  last_logfilename = NULL;
	}
      /* Open the logfile.  */
      last_logfilename = (char *) malloc (strlen (logfilename) + 1);
      if (last_logfilename == NULL)
	return;
      strcpy (last_logfilename, logfilename);
      last_logfile = fopen (logfilename, "a");
      if (last_logfile == NULL)
	return;
    }
  logfile = last_logfile;

  fprintf (logfile, "domain ");
  print_escaped (logfile, domainname);
  fprintf (logfile, "\nmsgid ");
  print_escaped (logfile, msgid1);
  if (plural)
    {
      fprintf (logfile, "\nmsgid_plural ");
      print_escaped (logfile, msgid2);
      fprintf (logfile, "\nmsgstr[0] \"\"\n");
    }
  else
    fprintf (logfile, "\nmsgstr \"\"\n");
  putc ('\n', logfile);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\intl\log.c:63
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\intl\ngettext.c...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\intl\gettextP.h...skip
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\intl\ngettext.c:60
parsing error 
{
  return DCNGETTEXT (NULL, msgid1, msgid2, n, LC_MESSAGES);
}
warning: parse error {
  return DCNGETTEXT (NULL, msgid1, msgid2, n, LC_MESSAGES);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\intl\ngettext.c:63
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\intl\os2compat.c...
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\intl\osdep.c...
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\intl\plural-exp.c...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\intl\plural-exp.h...skip
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\intl\plural-exp.c:102
parsing error 
{
  if (nullentry != NULL)
    {
      const char *plural;
      const char *nplurals;

      plural = strstr (nullentry, "plural=");
      nplurals = strstr (nullentry, "nplurals=");
      if (plural == NULL || nplurals == NULL)
	goto no_plural;
      else
	{
	  char *endp;
	  unsigned long int n;
	  struct parse_args args;

	  /* First get the number.  */
	  nplurals += 9;
	  while (*nplurals != '\0' && isspace ((unsigned char) *nplurals))
	    ++nplurals;
	  if (!(*nplurals >= '0' && *nplurals <= '9'))
	    goto no_plural;
#if defined HAVE_STRTOUL || defined _LIBC
	  n = strtoul (nplurals, &endp, 10);
#else
	  for (endp = nplurals, n = 0; *endp >= '0' && *endp <= '9'; endp++)
	    n = n * 10 + (*endp - '0');
#endif
	  if (nplurals == endp)
	    goto no_plural;
	  *npluralsp = n;

	  /* Due to the restrictions bison imposes onto the interface of the
	     scanner function we have to put the input string and the result
	     passed up from the parser into the same structure which address
	     is passed down to the parser.  */
	  plural += 7;
	  args.cp = plural;
	  if (PLURAL_PARSE (&args) != 0)
	    goto no_plural;
	  *pluralp = args.res;
	}
    }
  else
    {
      /* By default we are using the Germanic form: singular form only
         for `one', the plural form otherwise.  Yes, this is also what
         English is using since English is a Germanic language.  */
    no_plural:
      INIT_GERMANIC_PLURAL ();
      *pluralp = &GERMANIC_PLURAL;
      *npluralsp = 2;
    }
}
warning: parse error {
  if (nullentry != NULL)
    {
      const char *plural;
      const char *nplurals;

      plural = strstr (nullentry, "plural=");
      nplurals = strstr (nullentry, "nplurals=");
      if (plural == NULL || nplurals == NULL)
	goto no_plural;
      else
	{
	  char *endp;
	  unsigned long int n;
	  struct parse_args args;

	  /* First get the number.  */
	  nplurals += 9;
	  while (*nplurals != '\0' && isspace ((unsigned char) *nplurals))
	    ++nplurals;
	  if (!(*nplurals >= '0' && *nplurals <= '9'))
	    goto no_plural;
#if defined HAVE_STRTOUL || defined _LIBC
	  n = strtoul (nplurals, &endp, 10);
#else
	  for (endp = nplurals, n = 0; *endp >= '0' && *endp <= '9'; endp++)
	    n = n * 10 + (*endp - '0');
#endif
	  if (nplurals == endp)
	    goto no_plural;
	  *npluralsp = n;

	  /* Due to the restrictions bison imposes onto the interface of the
	     scanner function we have to put the input string and the result
	     passed up from the parser into the same structure which address
	     is passed down to the parser.  */
	  plural += 7;
	  args.cp = plural;
	  if (PLURAL_PARSE (&args) != 0)
	    goto no_plural;
	  *pluralp = args.res;
	}
    }
  else
    {
      /* By default we are using the Germanic form: singular form only
         for `one', the plural form otherwise.  Yes, this is also what
         English is using since English is a Germanic language.  */
    no_plural:
      INIT_GERMANIC_PLURAL ();
      *pluralp = &GERMANIC_PLURAL;
      *npluralsp = 2;
    }
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\intl\plural-exp.c:105
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\intl\plural.c...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\intl\plural-exp.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\intl\plural.c:182
parsing error 
{
  int i;
  struct expression *newp;

  /* If any of the argument could not be malloc'ed, just return NULL.  */
  for (i = nargs - 1; i >= 0; i--)
    if (args[i] == NULL)
      goto fail;

  /* Allocate a new expression.  */
  newp = (struct expression *) malloc (sizeof (*newp));
  if (newp != NULL)
    {
      newp->nargs = nargs;
      newp->operation = op;
      for (i = nargs - 1; i >= 0; i--)
	newp->val.args[i] = args[i];
      return newp;
    }

 fail:
  for (i = nargs - 1; i >= 0; i--)
    FREE_EXPRESSION (args[i]);

  return NULL;
}
warning: parse error {
  int i;
  struct expression *newp;

  /* If any of the argument could not be malloc'ed, just return NULL.  */
  for (i = nargs - 1; i >= 0; i--)
    if (args[i] == NULL)
      goto fail;

  /* Allocate a new expression.  */
  newp = (struct expression *) malloc (sizeof (*newp));
  if (newp != NULL)
    {
      newp->nargs = nargs;
      newp->operation = op;
      for (i = nargs - 1; i >= 0; i--)
	newp->val.args[i] = args[i];
      return newp;
    }

 fail:
  for (i = nargs - 1; i >= 0; i--)
    FREE_EXPRESSION (args[i]);

  return NULL;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\intl\plural.c:186
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\intl\plural.c:214
parsing error 
{
  return new_exp (0, op, NULL);
}
warning: parse error {
  return new_exp (0, op, NULL);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\intl\plural.c:216
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\intl\plural.c:221
parsing error 
{
  struct expression *args[1];

  args[0] = right;
  return new_exp (1, op, args);
}
warning: parse error {
  struct expression *args[1];

  args[0] = right;
  return new_exp (1, op, args);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\intl\plural.c:224
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\intl\plural.c:232
parsing error 
{
  struct expression *args[2];

  args[0] = left;
  args[1] = right;
  return new_exp (2, op, args);
}
warning: parse error {
  struct expression *args[2];

  args[0] = left;
  args[1] = right;
  return new_exp (2, op, args);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\intl\plural.c:236
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\intl\plural.c:245
parsing error 
{
  struct expression *args[3];

  args[0] = bexp;
  args[1] = tbranch;
  args[2] = fbranch;
  return new_exp (3, op, args);
}
warning: parse error {
  struct expression *args[3];

  args[0] = bexp;
  args[1] = tbranch;
  args[2] = fbranch;
  return new_exp (3, op, args);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\intl\plural.c:250
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\intl\plural.c:1,503
parsing error 
{
  if (exp == NULL)
    return;

  /* Handle the recursive case.  */
  switch (exp->nargs)
    {
    case 3:
      FREE_EXPRESSION (exp->val.args[2]);
      /* FALLTHROUGH */
    case 2:
      FREE_EXPRESSION (exp->val.args[1]);
      /* FALLTHROUGH */
    case 1:
      FREE_EXPRESSION (exp->val.args[0]);
      /* FALLTHROUGH */
    default:
      break;
    }

  free (exp);
}
warning: parse error {
  if (exp == NULL)
    return;

  /* Handle the recursive case.  */
  switch (exp->nargs)
    {
    case 3:
      FREE_EXPRESSION (exp->val.args[2]);
      /* FALLTHROUGH */
    case 2:
      FREE_EXPRESSION (exp->val.args[1]);
      /* FALLTHROUGH */
    case 1:
      FREE_EXPRESSION (exp->val.args[0]);
      /* FALLTHROUGH */
    default:
      break;
    }

  free (exp);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\intl\plural.c:1,505
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\intl\plural.c:1,530
parsing error 
{
  const char *exp = *pexp;
  int result;

  while (1)
    {
      if (exp[0] == '\0')
	{
	  *pexp = exp;
	  return YYEOF;
	}

      if (exp[0] != ' ' && exp[0] != '\t')
	break;

      ++exp;
    }

  result = *exp++;
  switch (result)
    {
    case '0': case '1': case '2': case '3': case '4':
    case '5': case '6': case '7': case '8': case '9':
      {
	unsigned long int n = result - '0';
	while (exp[0] >= '0' && exp[0] <= '9')
	  {
	    n *= 10;
	    n += exp[0] - '0';
	    ++exp;
	  }
	lval->num = n;
	result = NUMBER;
      }
      break;

    case '=':
      if (exp[0] == '=')
	{
	  ++exp;
	  lval->op = equal;
	  result = EQUOP2;
	}
      else
	result = YYERRCODE;
      break;

    case '!':
      if (exp[0] == '=')
	{
	  ++exp;
	  lval->op = not_equal;
	  result = EQUOP2;
	}
      break;

    case '&':
    case '|':
      if (exp[0] == result)
	++exp;
      else
	result = YYERRCODE;
      break;

    case '<':
      if (exp[0] == '=')
	{
	  ++exp;
	  lval->op = less_or_equal;
	}
      else
	lval->op = less_than;
      result = CMPOP2;
      break;

    case '>':
      if (exp[0] == '=')
	{
	  ++exp;
	  lval->op = greater_or_equal;
	}
      else
	lval->op = greater_than;
      result = CMPOP2;
      break;

    case '*':
      lval->op = mult;
      result = MULOP2;
      break;

    case '/':
      lval->op = divide;
      result = MULOP2;
      break;

    case '%':
      lval->op = module;
      result = MULOP2;
      break;

    case '+':
      lval->op = plus;
      result = ADDOP2;
      break;

    case '-':
      lval->op = minus;
      result = ADDOP2;
      break;

    case 'n':
    case '?':
    case ':':
    case '(':
    case ')':
      /* Nothing, just return the character.  */
      break;

    case ';':
    case '\n':
    case '\0':
      /* Be safe and let the user call this function again.  */
      --exp;
      result = YYEOF;
      break;

    default:
      result = YYERRCODE;
#if YYDEBUG != 0
      --exp;
#endif
      break;
    }

  *pexp = exp;

  return result;
}
warning: parse error {
  const char *exp = *pexp;
  int result;

  while (1)
    {
      if (exp[0] == '\0')
	{
	  *pexp = exp;
	  return YYEOF;
	}

      if (exp[0] != ' ' && exp[0] != '\t')
	break;

      ++exp;
    }

  result = *exp++;
  switch (result)
    {
    case '0': case '1': case '2': case '3': case '4':
    case '5': case '6': case '7': case '8': case '9':
      {
	unsigned long int n = result - '0';
	while (exp[0] >= '0' && exp[0] <= '9')
	  {
	    n *= 10;
	    n += exp[0] - '0';
	    ++exp;
	  }
	lval->num = n;
	result = NUMBER;
      }
      break;

    case '=':
      if (exp[0] == '=')
	{
	  ++exp;
	  lval->op = equal;
	  result = EQUOP2;
	}
      else
	result = YYERRCODE;
      break;

    case '!':
      if (exp[0] == '=')
	{
	  ++exp;
	  lval->op = not_equal;
	  result = EQUOP2;
	}
      break;

    case '&':
    case '|':
      if (exp[0] == result)
	++exp;
      else
	result = YYERRCODE;
      break;

    case '<':
      if (exp[0] == '=')
	{
	  ++exp;
	  lval->op = less_or_equal;
	}
      else
	lval->op = less_than;
      result = CMPOP2;
      break;

    case '>':
      if (exp[0] == '=')
	{
	  ++exp;
	  lval->op = greater_or_equal;
	}
      else
	lval->op = greater_than;
      result = CMPOP2;
      break;

    case '*':
      lval->op = mult;
      result = MULOP2;
      break;

    case '/':
      lval->op = divide;
      result = MULOP2;
      break;

    case '%':
      lval->op = module;
      result = MULOP2;
      break;

    case '+':
      lval->op = plus;
      result = ADDOP2;
      break;

    case '-':
      lval->op = minus;
      result = ADDOP2;
      break;

    case 'n':
    case '?':
    case ':':
    case '(':
    case ')':
      /* Nothing, just return the character.  */
      break;

    case ';':
    case '\n':
    case '\0':
      /* Be safe and let the user call this function again.  */
      --exp;
      result = YYEOF;
      break;

    default:
      result = YYERRCODE;
#if YYDEBUG != 0
      --exp;
#endif
      break;
    }

  *pexp = exp;

  return result;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\intl\plural.c:1,533
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\intl\plural.c:1,676
parsing error 
{
  /* Do nothing.  We don't print error messages here.  */
}
warning: parse error {
  /* Do nothing.  We don't print error messages here.  */
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\intl\plural.c:1,677
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\intl\relocatable.c...
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\intl\relocatable.h...
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\intl\textdomain.c...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\intl\gettextP.h...skip
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\intl\textdomain.c:83
parsing error 
{
  char *new_domain;
  char *old_domain;

  /* A NULL pointer requests the current setting.  */
  if (domainname == NULL)
    return (char *) _nl_current_default_domain;

  __libc_rwlock_wrlock (_nl_state_lock);

  old_domain = (char *) _nl_current_default_domain;

  /* If domain name is the null string set to default domain "messages".  */
  if (domainname[0] == '\0'
      || strcmp (domainname, _nl_default_default_domain) == 0)
    {
      _nl_current_default_domain = _nl_default_default_domain;
      new_domain = (char *) _nl_current_default_domain;
    }
  else if (strcmp (domainname, old_domain) == 0)
    /* This can happen and people will use it to signal that some
       environment variable changed.  */
    new_domain = old_domain;
  else
    {
      /* If the following malloc fails `_nl_current_default_domain'
	 will be NULL.  This value will be returned and so signals we
	 are out of core.  */
#if defined _LIBC || defined HAVE_STRDUP
      new_domain = strdup (domainname);
#else
      size_t len = strlen (domainname) + 1;
      new_domain = (char *) malloc (len);
      if (new_domain != NULL)
	memcpy (new_domain, domainname, len);
#endif

      if (new_domain != NULL)
	_nl_current_default_domain = new_domain;
    }

  /* We use this possibility to signal a change of the loaded catalogs
     since this is most likely the case and there is no other easy we
     to do it.  Do it only when the call was successful.  */
  if (new_domain != NULL)
    {
      ++_nl_msg_cat_cntr;

      if (old_domain != new_domain && old_domain != _nl_default_default_domain)
	free (old_domain);
    }

  __libc_rwlock_unlock (_nl_state_lock);

  return new_domain;
}
warning: parse error {
  char *new_domain;
  char *old_domain;

  /* A NULL pointer requests the current setting.  */
  if (domainname == NULL)
    return (char *) _nl_current_default_domain;

  __libc_rwlock_wrlock (_nl_state_lock);

  old_domain = (char *) _nl_current_default_domain;

  /* If domain name is the null string set to default domain "messages".  */
  if (domainname[0] == '\0'
      || strcmp (domainname, _nl_default_default_domain) == 0)
    {
      _nl_current_default_domain = _nl_default_default_domain;
      new_domain = (char *) _nl_current_default_domain;
    }
  else if (strcmp (domainname, old_domain) == 0)
    /* This can happen and people will use it to signal that some
       environment variable changed.  */
    new_domain = old_domain;
  else
    {
      /* If the following malloc fails `_nl_current_default_domain'
	 will be NULL.  This value will be returned and so signals we
	 are out of core.  */
#if defined _LIBC || defined HAVE_STRDUP
      new_domain = strdup (domainname);
#else
      size_t len = strlen (domainname) + 1;
      new_domain = (char *) malloc (len);
      if (new_domain != NULL)
	memcpy (new_domain, domainname, len);
#endif

      if (new_domain != NULL)
	_nl_current_default_domain = new_domain;
    }

  /* We use this possibility to signal a change of the loaded catalogs
     since this is most likely the case and there is no other easy we
     to do it.  Do it only when the call was successful.  */
  if (new_domain != NULL)
    {
      ++_nl_msg_cat_cntr;

      if (old_domain != new_domain && old_domain != _nl_default_default_domain)
	free (old_domain);
    }

  __libc_rwlock_unlock (_nl_state_lock);

  return new_domain;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\intl\textdomain.c:84
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\malloc\alloca.c...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\bashtypes.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\malloc\alloca.c:159
parsing error 
{
  auto char probe;		/* Probes stack depth: */
  register char *depth = ADDRESS_FUNCTION (probe);

#if STACK_DIRECTION == 0
  if (STACK_DIR == 0)		/* Unknown growth direction.  */
    find_stack_direction ();
#endif

  /* Reclaim garbage, defined as all alloca'd storage that
     was allocated from deeper in the stack than currently. */

  {
    register header *hp;	/* Traverses linked list.  */

    for (hp = last_alloca_header; hp != NULL;)
      if ((STACK_DIR > 0 && hp->h.deep > depth)
	  || (STACK_DIR < 0 && hp->h.deep < depth))
	{
	  register header *np = hp->h.next;

	  free ((pointer) hp);	/* Collect garbage.  */

	  hp = np;		/* -> next header.  */
	}
      else
	break;			/* Rest are not deeper.  */

    last_alloca_header = hp;	/* -> last valid storage.  */
  }

  if (size == 0)
    return NULL;		/* No allocation required.  */

  /* Allocate combined header + user data storage.  */

  {
    register pointer new = malloc (sizeof (header) + size);
    /* Address of header.  */

    ((header *) new)->h.next = last_alloca_header;
    ((header *) new)->h.deep = depth;

    last_alloca_header = (header *) new;

    /* User storage begins just after header.  */

    return (pointer) ((char *) new + sizeof (header));
  }
}
warning: parse error {
  auto char probe;		/* Probes stack depth: */
  register char *depth = ADDRESS_FUNCTION (probe);

#if STACK_DIRECTION == 0
  if (STACK_DIR == 0)		/* Unknown growth direction.  */
    find_stack_direction ();
#endif

  /* Reclaim garbage, defined as all alloca'd storage that
     was allocated from deeper in the stack than currently. */

  {
    register header *hp;	/* Traverses linked list.  */

    for (hp = last_alloca_header; hp != NULL;)
      if ((STACK_DIR > 0 && hp->h.deep > depth)
	  || (STACK_DIR < 0 && hp->h.deep < depth))
	{
	  register header *np = hp->h.next;

	  free ((pointer) hp);	/* Collect garbage.  */

	  hp = np;		/* -> next header.  */
	}
      else
	break;			/* Rest are not deeper.  */

    last_alloca_header = hp;	/* -> last valid storage.  */
  }

  if (size == 0)
    return NULL;		/* No allocation required.  */

  /* Allocate combined header + user data storage.  */

  {
    register pointer new = malloc (sizeof (header) + size);
    /* Address of header.  */

    ((header *) new)->h.next = last_alloca_header;
    ((header *) new)->h.deep = depth;

    last_alloca_header = (header *) new;

    /* User storage begins just after header.  */

    return (pointer) ((char *) new + sizeof (header));
  }
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\malloc\alloca.c:161
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\malloc\malloc.c...
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\malloc\imalloc.h...
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\malloc\malloc.c:292
parsing error 
{
  fprintf (stderr, _("malloc: failed assertion: %s\n"), s);
  (void)fflush (stderr);
  abort ();
}
warning: parse error {
  fprintf (stderr, _("malloc: failed assertion: %s\n"), s);
  (void)fflush (stderr);
  abort ();
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\malloc\malloc.c:295
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\malloc\malloc.c:305
parsing error 
{
  fprintf (stderr, _("\r\nmalloc: %s:%d: assertion botched\r\n"),
			file ? file : _("unknown"), line);
#ifdef MALLOC_REGISTER
  if (mem != NULL && malloc_register)
    mregister_describe_mem (mem, stderr);
#endif
  (void)fflush (stderr);
  botch(s, file, line);
}
warning: parse error {
  fprintf (stderr, _("\r\nmalloc: %s:%d: assertion botched\r\n"),
			file ? file : _("unknown"), line);
#ifdef MALLOC_REGISTER
  if (mem != NULL && malloc_register)
    mregister_describe_mem (mem, stderr);
#endif
  (void)fflush (stderr);
  botch(s, file, line);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\malloc\malloc.c:311
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\malloc\malloc.c:327
parsing error 
{
  register union mhead *mp, *mp1, *mp2;
  register int nbuck;
  unsigned long siz;

  nbuck = nu - 1;
  if (nextf[nbuck] == 0 || busy[nbuck])
    return;

  busy[nbuck] = 1;
  siz = binsize (nbuck);

  mp2 = mp1 = nextf[nbuck];
  mp = CHAIN (mp1);
  while (mp && mp != (union mhead *)((char *)mp1 + siz))
    {
      mp2 = mp1;
      mp1 = mp;
      mp = CHAIN (mp);
    }

  if (mp == 0)
    {
      busy[nbuck] = 0;
      return;
    }

  /* OK, now we have mp1 pointing to the block we want to add to nextf[NU].
     CHAIN(mp2) must equal mp1.  Check that mp1 and mp are adjacent. */
  if (mp2 != mp1 && CHAIN(mp2) != mp1)
    {
      busy[nbuck] = 0;
      xbotch ((PTR_T)0, 0, "bcoalesce: CHAIN(mp2) != mp1", (char *)NULL, 0);
    }

#ifdef MALLOC_DEBUG
  if (CHAIN (mp1) != (union mhead *)((char *)mp1 + siz))
    {
      busy[nbuck] = 0;
      return;	/* not adjacent */
    }
#endif

  /* Since they are adjacent, remove them from the free list */
  if (mp1 == nextf[nbuck])
    nextf[nbuck] = CHAIN (mp);
  else
    CHAIN (mp2) = CHAIN (mp);
  busy[nbuck] = 0;

#ifdef MALLOC_STATS
  _mstats.tbcoalesce++;
  _mstats.ncoalesce[nbuck]++;
#endif

  /* And add the combined two blocks to nextf[NU]. */
  mp1->mh_alloc = ISFREE;
  mp1->mh_index = nu;
  CHAIN (mp1) = nextf[nu];
  nextf[nu] = mp1;
}
warning: parse error {
  register union mhead *mp, *mp1, *mp2;
  register int nbuck;
  unsigned long siz;

  nbuck = nu - 1;
  if (nextf[nbuck] == 0 || busy[nbuck])
    return;

  busy[nbuck] = 1;
  siz = binsize (nbuck);

  mp2 = mp1 = nextf[nbuck];
  mp = CHAIN (mp1);
  while (mp && mp != (union mhead *)((char *)mp1 + siz))
    {
      mp2 = mp1;
      mp1 = mp;
      mp = CHAIN (mp);
    }

  if (mp == 0)
    {
      busy[nbuck] = 0;
      return;
    }

  /* OK, now we have mp1 pointing to the block we want to add to nextf[NU].
     CHAIN(mp2) must equal mp1.  Check that mp1 and mp are adjacent. */
  if (mp2 != mp1 && CHAIN(mp2) != mp1)
    {
      busy[nbuck] = 0;
      xbotch ((PTR_T)0, 0, "bcoalesce: CHAIN(mp2) != mp1", (char *)NULL, 0);
    }

#ifdef MALLOC_DEBUG
  if (CHAIN (mp1) != (union mhead *)((char *)mp1 + siz))
    {
      busy[nbuck] = 0;
      return;	/* not adjacent */
    }
#endif

  /* Since they are adjacent, remove them from the free list */
  if (mp1 == nextf[nbuck])
    nextf[nbuck] = CHAIN (mp);
  else
    CHAIN (mp2) = CHAIN (mp);
  busy[nbuck] = 0;

#ifdef MALLOC_STATS
  _mstats.tbcoalesce++;
  _mstats.ncoalesce[nbuck]++;
#endif

  /* And add the combined two blocks to nextf[NU]. */
  mp1->mh_alloc = ISFREE;
  mp1->mh_index = nu;
  CHAIN (mp1) = nextf[nu];
  nextf[nu] = mp1;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\malloc\malloc.c:329
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\malloc\malloc.c:396
parsing error 
{
  register union mhead *mp;
  int nbuck, nblks, split_max;
  unsigned long siz;

  split_max = (maxbuck > SPLIT_MAX) ? maxbuck : SPLIT_MAX;

  if (nu >= SPLIT_MID)
    {
      for (nbuck = split_max; nbuck > nu; nbuck--)
	{
	  if (busy[nbuck] || nextf[nbuck] == 0)
	    continue;
	  break;
	}
    }
  else
    {
      for (nbuck = nu + 1; nbuck <= split_max; nbuck++)
	{
	  if (busy[nbuck] || nextf[nbuck] == 0)
	    continue;
	  break;
	}
    }

  if (nbuck > split_max || nbuck <= nu)
    return;

  /* XXX might want to split only if nextf[nbuck] has >= 2 blocks free
     and nbuck is below some threshold. */

  /* Remove the block from the chain of larger blocks. */
  busy[nbuck] = 1;
  mp = nextf[nbuck];
  nextf[nbuck] = CHAIN (mp);
  busy[nbuck] = 0;

#ifdef MALLOC_STATS
  _mstats.tbsplit++;
  _mstats.nsplit[nbuck]++;
#endif

  /* Figure out how many blocks we'll get. */
  siz = binsize (nu);
  nblks = binsize (nbuck) / siz;

  /* Split the block and put it on the requested chain. */
  nextf[nu] = mp;
  while (1)
    {
      mp->mh_alloc = ISFREE;
      mp->mh_index = nu;
      if (--nblks <= 0) break;
      CHAIN (mp) = (union mhead *)((char *)mp + siz);
      mp = (union mhead *)((char *)mp + siz);
    }
  CHAIN (mp) = 0;
}
warning: parse error {
  register union mhead *mp;
  int nbuck, nblks, split_max;
  unsigned long siz;

  split_max = (maxbuck > SPLIT_MAX) ? maxbuck : SPLIT_MAX;

  if (nu >= SPLIT_MID)
    {
      for (nbuck = split_max; nbuck > nu; nbuck--)
	{
	  if (busy[nbuck] || nextf[nbuck] == 0)
	    continue;
	  break;
	}
    }
  else
    {
      for (nbuck = nu + 1; nbuck <= split_max; nbuck++)
	{
	  if (busy[nbuck] || nextf[nbuck] == 0)
	    continue;
	  break;
	}
    }

  if (nbuck > split_max || nbuck <= nu)
    return;

  /* XXX might want to split only if nextf[nbuck] has >= 2 blocks free
     and nbuck is below some threshold. */

  /* Remove the block from the chain of larger blocks. */
  busy[nbuck] = 1;
  mp = nextf[nbuck];
  nextf[nbuck] = CHAIN (mp);
  busy[nbuck] = 0;

#ifdef MALLOC_STATS
  _mstats.tbsplit++;
  _mstats.nsplit[nbuck]++;
#endif

  /* Figure out how many blocks we'll get. */
  siz = binsize (nu);
  nblks = binsize (nbuck) / siz;

  /* Split the block and put it on the requested chain. */
  nextf[nu] = mp;
  while (1)
    {
      mp->mh_alloc = ISFREE;
      mp->mh_index = nu;
      if (--nblks <= 0) break;
      CHAIN (mp) = (union mhead *)((char *)mp + siz);
      mp = (union mhead *)((char *)mp + siz);
    }
  CHAIN (mp) = 0;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\malloc\malloc.c:398
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\malloc\malloc.c:461
parsing error 
{
  union mhead *nh;
  int nbuck, nblks, split_max;
  unsigned long siz;

  nbuck = nu - 1;
  while (nbuck >= SPLIT_MIN && busy[nbuck])
    nbuck--;
  if (nbuck < SPLIT_MIN)
    return;

#ifdef MALLOC_STATS
  _mstats.tbsplit++;
  _mstats.nsplit[nu]++;
#endif

  /* Figure out how many blocks we'll get. */
  siz = binsize (nu);			/* original block size */
  nblks = siz / binsize (nbuck);	/* should be 2 most of the time */

  /* And add it to nextf[nbuck] */
  siz = binsize (nbuck);		/* XXX - resetting here */
  nh = mp;
  while (1)
    {
      mp->mh_alloc = ISFREE;
      mp->mh_index = nbuck;
      if (--nblks <= 0) break;
      CHAIN (mp) = (union mhead *)((char *)mp + siz);
      mp = (union mhead *)((char *)mp + siz);
    }
  busy[nbuck] = 1;
  CHAIN (mp) = nextf[nbuck];
  nextf[nbuck] = nh;
  busy[nbuck] = 0;
}
warning: parse error {
  union mhead *nh;
  int nbuck, nblks, split_max;
  unsigned long siz;

  nbuck = nu - 1;
  while (nbuck >= SPLIT_MIN && busy[nbuck])
    nbuck--;
  if (nbuck < SPLIT_MIN)
    return;

#ifdef MALLOC_STATS
  _mstats.tbsplit++;
  _mstats.nsplit[nu]++;
#endif

  /* Figure out how many blocks we'll get. */
  siz = binsize (nu);			/* original block size */
  nblks = siz / binsize (nbuck);	/* should be 2 most of the time */

  /* And add it to nextf[nbuck] */
  siz = binsize (nbuck);		/* XXX - resetting here */
  nh = mp;
  while (1)
    {
      mp->mh_alloc = ISFREE;
      mp->mh_index = nbuck;
      if (--nblks <= 0) break;
      CHAIN (mp) = (union mhead *)((char *)mp + siz);
      mp = (union mhead *)((char *)mp + siz);
    }
  busy[nbuck] = 1;
  CHAIN (mp) = nextf[nbuck];
  nextf[nbuck] = nh;
  busy[nbuck] = 0;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\malloc\malloc.c:464
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\malloc\malloc.c:502
parsing error 
{
#ifdef HAVE_POSIX_SIGNALS
  sigfillset (setp);
  sigemptyset (osetp);
  sigprocmask (SIG_BLOCK, setp, osetp);
#else
#  if defined (HAVE_BSD_SIGNALS)
  *osetp = sigsetmask (-1);
#  endif
#endif
}
warning: parse error {
#ifdef HAVE_POSIX_SIGNALS
  sigfillset (setp);
  sigemptyset (osetp);
  sigprocmask (SIG_BLOCK, setp, osetp);
#else
#  if defined (HAVE_BSD_SIGNALS)
  *osetp = sigsetmask (-1);
#  endif
#endif
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\malloc\malloc.c:504
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\malloc\malloc.c:517
parsing error 
{
#ifdef HAVE_POSIX_SIGNALS
  sigprocmask (SIG_SETMASK, osetp, (sigset_t *)NULL);
#else
#  if defined (HAVE_BSD_SIGNALS)
  sigsetmask (*osetp);
#  endif
#endif
}
warning: parse error {
#ifdef HAVE_POSIX_SIGNALS
  sigprocmask (SIG_SETMASK, osetp, (sigset_t *)NULL);
#else
#  if defined (HAVE_BSD_SIGNALS)
  sigsetmask (*osetp);
#  endif
#endif
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\malloc\malloc.c:519
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\malloc\malloc.c:533
parsing error 
{
  long siz;

  siz = binsize (nu);
  /* Should check for errors here, I guess. */
  sbrk (-siz);
  memtop -= siz;

#ifdef MALLOC_STATS
  _mstats.nsbrk++;
  _mstats.tsbrk -= siz;
  _mstats.nlesscore[nu]++;
#endif
}
warning: parse error {
  long siz;

  siz = binsize (nu);
  /* Should check for errors here, I guess. */
  sbrk (-siz);
  memtop -= siz;

#ifdef MALLOC_STATS
  _mstats.nsbrk++;
  _mstats.tsbrk -= siz;
  _mstats.nlesscore[nu]++;
#endif
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\malloc\malloc.c:535
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\malloc\malloc.c:552
parsing error 
{
  register union mhead *mp;
  register int nblks;
  register long siz;
  long sbrk_amt;		/* amount to get via sbrk() */
  sigset_t set, oset;
  int blocked_sigs;

  /* Block all signals in case we are executed from a signal handler. */
  blocked_sigs = 0;
#ifdef SHELL
  if (interrupt_immediately || signal_is_trapped (SIGINT) || signal_is_trapped (SIGCHLD))
#endif
    {
      block_signals (&set, &oset);
      blocked_sigs = 1;
    }

  siz = binsize (nu);	/* size of desired block for nextf[nu] */

  if (siz < 0)
    goto morecore_done;		/* oops */

#ifdef MALLOC_STATS
  _mstats.nmorecore[nu]++;
#endif

  /* Try to split a larger block here, if we're within the range of sizes
     to split. */
  if (nu >= SPLIT_MIN)
    {
      bsplit (nu);
      if (nextf[nu] != 0)
	goto morecore_done;
    }

  /* Try to coalesce two adjacent blocks from the free list on nextf[nu - 1],
     if we can, and we're within the range of the block coalescing limits. */
  if (nu >= COMBINE_MIN && nu < COMBINE_MAX && busy[nu - 1] == 0 && nextf[nu - 1])
    {
      bcoalesce (nu);
      if (nextf[nu] != 0)
	goto morecore_done;
    }

  /* Take at least a page, and figure out how many blocks of the requested
     size we're getting. */
  if (siz <= pagesz)
    {
      sbrk_amt = pagesz;
      nblks = sbrk_amt / siz;
    }
  else
    {
      /* We always want to request an integral multiple of the page size
	 from the kernel, so let's compute whether or not `siz' is such
	 an amount.  If it is, we can just request it.  If not, we want
	 the smallest integral multiple of pagesize that is larger than
	 `siz' and will satisfy the request. */
      sbrk_amt = siz & (pagesz - 1);
      if (sbrk_amt == 0)
	sbrk_amt = siz;
      else
	sbrk_amt = siz + pagesz - sbrk_amt;
      nblks = 1;
    }

#ifdef MALLOC_STATS
  _mstats.nsbrk++;
  _mstats.tsbrk += sbrk_amt;
#endif

  mp = (union mhead *) sbrk (sbrk_amt);

  /* Totally out of memory. */
  if ((long)mp == -1)
    goto morecore_done;

  memtop += sbrk_amt;

  /* shouldn't happen, but just in case -- require 8-byte alignment */
  if ((long)mp & MALIGN_MASK)
    {
      mp = (union mhead *) (((long)mp + MALIGN_MASK) & ~MALIGN_MASK);
      nblks--;
    }

  /* save new header and link the nblks blocks together */
  nextf[nu] = mp;
  while (1)
    {
      mp->mh_alloc = ISFREE;
      mp->mh_index = nu;
      if (--nblks <= 0) break;
      CHAIN (mp) = (union mhead *)((char *)mp + siz);
      mp = (union mhead *)((char *)mp + siz);
    }
  CHAIN (mp) = 0;

morecore_done:
  if (blocked_sigs)
    unblock_signals (&set, &oset);
}
warning: parse error {
  register union mhead *mp;
  register int nblks;
  register long siz;
  long sbrk_amt;		/* amount to get via sbrk() */
  sigset_t set, oset;
  int blocked_sigs;

  /* Block all signals in case we are executed from a signal handler. */
  blocked_sigs = 0;
#ifdef SHELL
  if (interrupt_immediately || signal_is_trapped (SIGINT) || signal_is_trapped (SIGCHLD))
#endif
    {
      block_signals (&set, &oset);
      blocked_sigs = 1;
    }

  siz = binsize (nu);	/* size of desired block for nextf[nu] */

  if (siz < 0)
    goto morecore_done;		/* oops */

#ifdef MALLOC_STATS
  _mstats.nmorecore[nu]++;
#endif

  /* Try to split a larger block here, if we're within the range of sizes
     to split. */
  if (nu >= SPLIT_MIN)
    {
      bsplit (nu);
      if (nextf[nu] != 0)
	goto morecore_done;
    }

  /* Try to coalesce two adjacent blocks from the free list on nextf[nu - 1],
     if we can, and we're within the range of the block coalescing limits. */
  if (nu >= COMBINE_MIN && nu < COMBINE_MAX && busy[nu - 1] == 0 && nextf[nu - 1])
    {
      bcoalesce (nu);
      if (nextf[nu] != 0)
	goto morecore_done;
    }

  /* Take at least a page, and figure out how many blocks of the requested
     size we're getting. */
  if (siz <= pagesz)
    {
      sbrk_amt = pagesz;
      nblks = sbrk_amt / siz;
    }
  else
    {
      /* We always want to request an integral multiple of the page size
	 from the kernel, so let's compute whether or not `siz' is such
	 an amount.  If it is, we can just request it.  If not, we want
	 the smallest integral multiple of pagesize that is larger than
	 `siz' and will satisfy the request. */
      sbrk_amt = siz & (pagesz - 1);
      if (sbrk_amt == 0)
	sbrk_amt = siz;
      else
	sbrk_amt = siz + pagesz - sbrk_amt;
      nblks = 1;
    }

#ifdef MALLOC_STATS
  _mstats.nsbrk++;
  _mstats.tsbrk += sbrk_amt;
#endif

  mp = (union mhead *) sbrk (sbrk_amt);

  /* Totally out of memory. */
  if ((long)mp == -1)
    goto morecore_done;

  memtop += sbrk_amt;

  /* shouldn't happen, but just in case -- require 8-byte alignment */
  if ((long)mp & MALIGN_MASK)
    {
      mp = (union mhead *) (((long)mp + MALIGN_MASK) & ~MALIGN_MASK);
      nblks--;
    }

  /* save new header and link the nblks blocks together */
  nextf[nu] = mp;
  while (1)
    {
      mp->mh_alloc = ISFREE;
      mp->mh_index = nu;
      if (--nblks <= 0) break;
      CHAIN (mp) = (union mhead *)((char *)mp + siz);
      mp = (union mhead *)((char *)mp + siz);
    }
  CHAIN (mp) = 0;

morecore_done:
  if (blocked_sigs)
    unblock_signals (&set, &oset);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\malloc\malloc.c:554
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\malloc\malloc.c:735
parsing error 
{
  register union mhead *p;
  register int nunits;
  register char *m, *z;
  long nbytes;
  mguard_t mg;

  /* Get the system page size and align break pointer so future sbrks will
     be page-aligned.  The page size must be at least 1K -- anything
     smaller is increased. */
  if (pagesz == 0)
    if (pagealign () < 0)
      return ((PTR_T)NULL);
 
  /* Figure out how many bytes are required, rounding up to the nearest
     multiple of 8, then figure out which nextf[] area to use.  Try to
     be smart about where to start searching -- if the number of bytes
     needed is greater than the page size, we can start at pagebucket. */
  nbytes = ALLOCATED_BYTES(n);
  nunits = (nbytes <= (pagesz >> 1)) ? STARTBUCK : pagebucket;
  for ( ; nunits < NBUCKETS; nunits++)
    if (nbytes <= binsize(nunits))
      break;

  /* Silently reject too-large requests. */
  if (nunits >= NBUCKETS)
    return ((PTR_T) NULL);

  /* In case this is reentrant use of malloc from signal handler,
     pick a block size that no other malloc level is currently
     trying to allocate.  That's the easiest harmless way not to
     interfere with the other level of execution.  */
#ifdef MALLOC_STATS
  if (busy[nunits]) _mstats.nrecurse++;
#endif
  while (busy[nunits]) nunits++;
  busy[nunits] = 1;

  if (nunits > maxbuck)
    maxbuck = nunits;

  /* If there are no blocks of the appropriate size, go get some */
  if (nextf[nunits] == 0)
    morecore (nunits);

  /* Get one block off the list, and set the new list head */
  if ((p = nextf[nunits]) == NULL)
    {
      busy[nunits] = 0;
      return NULL;
    }
  nextf[nunits] = CHAIN (p);
  busy[nunits] = 0;

  /* Check for free block clobbered */
  /* If not for this check, we would gobble a clobbered free chain ptr
     and bomb out on the NEXT allocate of this size block */
  if (p->mh_alloc != ISFREE || p->mh_index != nunits)
    xbotch ((PTR_T)(p+1), 0, _("malloc: block on free list clobbered"), file, line);

  /* Fill in the info, and set up the magic numbers for range checking. */
  p->mh_alloc = ISALLOC;
  p->mh_magic2 = MAGIC2;
  p->mh_nbytes = n;

  /* End guard */
  mg.i = n;
  z = mg.s;
  m = (char *) (p + 1) + n;
  *m++ = *z++, *m++ = *z++, *m++ = *z++, *m++ = *z++;

#ifdef MEMSCRAMBLE
  if (n)
    MALLOC_MEMSET ((char *)(p + 1), 0xdf, n);	/* scramble previous contents */
#endif
#ifdef MALLOC_STATS
  _mstats.nmalloc[nunits]++;
  _mstats.tmalloc[nunits]++;
  _mstats.nmal++;
  _mstats.bytesreq += n;
#endif /* MALLOC_STATS */

#ifdef MALLOC_TRACE
  if (malloc_trace && (flags & MALLOC_NOTRACE) == 0)
    mtrace_alloc ("malloc", p + 1, n, file, line);
  else if (_malloc_trace_buckets[nunits])
    mtrace_alloc ("malloc", p + 1, n, file, line);
#endif

#ifdef MALLOC_REGISTER
  if (malloc_register && (flags & MALLOC_NOREG) == 0)
    mregister_alloc ("malloc", p + 1, n, file, line);
#endif

#ifdef MALLOC_WATCH
  if (_malloc_nwatch > 0)
    _malloc_ckwatch (p + 1, file, line, W_ALLOC, n);
#endif

  return (PTR_T) (p + 1);
}
warning: parse error {
  register union mhead *p;
  register int nunits;
  register char *m, *z;
  long nbytes;
  mguard_t mg;

  /* Get the system page size and align break pointer so future sbrks will
     be page-aligned.  The page size must be at least 1K -- anything
     smaller is increased. */
  if (pagesz == 0)
    if (pagealign () < 0)
      return ((PTR_T)NULL);
 
  /* Figure out how many bytes are required, rounding up to the nearest
     multiple of 8, then figure out which nextf[] area to use.  Try to
     be smart about where to start searching -- if the number of bytes
     needed is greater than the page size, we can start at pagebucket. */
  nbytes = ALLOCATED_BYTES(n);
  nunits = (nbytes <= (pagesz >> 1)) ? STARTBUCK : pagebucket;
  for ( ; nunits < NBUCKETS; nunits++)
    if (nbytes <= binsize(nunits))
      break;

  /* Silently reject too-large requests. */
  if (nunits >= NBUCKETS)
    return ((PTR_T) NULL);

  /* In case this is reentrant use of malloc from signal handler,
     pick a block size that no other malloc level is currently
     trying to allocate.  That's the easiest harmless way not to
     interfere with the other level of execution.  */
#ifdef MALLOC_STATS
  if (busy[nunits]) _mstats.nrecurse++;
#endif
  while (busy[nunits]) nunits++;
  busy[nunits] = 1;

  if (nunits > maxbuck)
    maxbuck = nunits;

  /* If there are no blocks of the appropriate size, go get some */
  if (nextf[nunits] == 0)
    morecore (nunits);

  /* Get one block off the list, and set the new list head */
  if ((p = nextf[nunits]) == NULL)
    {
      busy[nunits] = 0;
      return NULL;
    }
  nextf[nunits] = CHAIN (p);
  busy[nunits] = 0;

  /* Check for free block clobbered */
  /* If not for this check, we would gobble a clobbered free chain ptr
     and bomb out on the NEXT allocate of this size block */
  if (p->mh_alloc != ISFREE || p->mh_index != nunits)
    xbotch ((PTR_T)(p+1), 0, _("malloc: block on free list clobbered"), file, line);

  /* Fill in the info, and set up the magic numbers for range checking. */
  p->mh_alloc = ISALLOC;
  p->mh_magic2 = MAGIC2;
  p->mh_nbytes = n;

  /* End guard */
  mg.i = n;
  z = mg.s;
  m = (char *) (p + 1) + n;
  *m++ = *z++, *m++ = *z++, *m++ = *z++, *m++ = *z++;

#ifdef MEMSCRAMBLE
  if (n)
    MALLOC_MEMSET ((char *)(p + 1), 0xdf, n);	/* scramble previous contents */
#endif
#ifdef MALLOC_STATS
  _mstats.nmalloc[nunits]++;
  _mstats.tmalloc[nunits]++;
  _mstats.nmal++;
  _mstats.bytesreq += n;
#endif /* MALLOC_STATS */

#ifdef MALLOC_TRACE
  if (malloc_trace && (flags & MALLOC_NOTRACE) == 0)
    mtrace_alloc ("malloc", p + 1, n, file, line);
  else if (_malloc_trace_buckets[nunits])
    mtrace_alloc ("malloc", p + 1, n, file, line);
#endif

#ifdef MALLOC_REGISTER
  if (malloc_register && (flags & MALLOC_NOREG) == 0)
    mregister_alloc ("malloc", p + 1, n, file, line);
#endif

#ifdef MALLOC_WATCH
  if (_malloc_nwatch > 0)
    _malloc_ckwatch (p + 1, file, line, W_ALLOC, n);
#endif

  return (PTR_T) (p + 1);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\malloc\malloc.c:739
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\malloc\malloc.c:842
parsing error 
{
  register union mhead *p;
  register char *ap, *z;
  register int nunits;
  register unsigned int nbytes;
  int ubytes;		/* caller-requested size */
  mguard_t mg;

  if ((ap = (char *)mem) == 0)
    return;

  p = (union mhead *) ap - 1;

  if (p->mh_alloc == ISMEMALIGN)
    {
      ap -= p->mh_nbytes;
      p = (union mhead *) ap - 1;
    }

#if defined (MALLOC_TRACE) || defined (MALLOC_REGISTER)
  if (malloc_trace || malloc_register)
    ubytes = p->mh_nbytes;
#endif

  if (p->mh_alloc != ISALLOC)
    {
      if (p->mh_alloc == ISFREE)
	xbotch (mem, ERR_DUPFREE,
		_("free: called with already freed block argument"), file, line);
      else
	xbotch (mem, ERR_UNALLOC,
		_("free: called with unallocated block argument"), file, line);
    }

  ASSERT (p->mh_magic2 == MAGIC2);

  nunits = p->mh_index;
  nbytes = ALLOCATED_BYTES(p->mh_nbytes);
  /* Since the sizeof(u_bits32_t) bytes before the memory handed to the user
     are now used for the number of bytes allocated, a simple check of
     mh_magic2 is no longer sufficient to catch things like p[-1] = 'x'.
     We sanity-check the value of mh_nbytes against the size of the blocks
     in the appropriate bucket before we use it.  This can still cause problems
     and obscure errors if mh_nbytes is wrong but still within range; the
     checks against the size recorded at the end of the chunk will probably
     fail then.  Using MALLOC_REGISTER will help here, since it saves the
     original number of bytes requested. */

  if (IN_BUCKET(nbytes, nunits) == 0)
    xbotch (mem, ERR_UNDERFLOW,
	    _("free: underflow detected; mh_nbytes out of range"), file, line);

  ap += p->mh_nbytes;
  z = mg.s;
  *z++ = *ap++, *z++ = *ap++, *z++ = *ap++, *z++ = *ap++;  
  if (mg.i != p->mh_nbytes)
    xbotch (mem, ERR_ASSERT_FAILED, _("free: start and end chunk sizes differ"), file, line);

#if 1
  if (nunits >= LESSCORE_MIN && ((char *)p + binsize(nunits) == memtop))
#else
  if (((char *)p + binsize(nunits) == memtop) && nunits >= LESSCORE_MIN)
#endif
    {
      /* If above LESSCORE_FRC, give back unconditionally.  This should be set
	 high enough to be infrequently encountered.  If between LESSCORE_MIN
	 and LESSCORE_FRC, call lesscore if the bucket is marked as busy or if
	 there's already a block on the free list. */
      if ((nunits >= LESSCORE_FRC) || busy[nunits] || nextf[nunits] != 0)
	{
	  lesscore (nunits);
	  /* keeps the tracing and registering code in one place */
	  goto free_return;
	}
    }

#ifdef MEMSCRAMBLE
  if (p->mh_nbytes)
    MALLOC_MEMSET (mem, 0xcf, p->mh_nbytes);
#endif

  ASSERT (nunits < NBUCKETS);

  if (busy[nunits] == 1)
    {
      xsplit (p, nunits);	/* split block and add to different chain */
      goto free_return;
    }

  p->mh_alloc = ISFREE;
  /* Protect against signal handlers calling malloc.  */
  busy[nunits] = 1;
  /* Put this block on the free list.  */
  CHAIN (p) = nextf[nunits];
  nextf[nunits] = p;
  busy[nunits] = 0;

free_return:
  ;		/* Empty statement in case this is the end of the function */

#ifdef MALLOC_STATS
  _mstats.nmalloc[nunits]--;
  _mstats.nfre++;
#endif /* MALLOC_STATS */

#ifdef MALLOC_TRACE
  if (malloc_trace && (flags & MALLOC_NOTRACE) == 0)
    mtrace_free (mem, ubytes, file, line);
  else if (_malloc_trace_buckets[nunits])
    mtrace_free (mem, ubytes, file, line);
#endif

#ifdef MALLOC_REGISTER
  if (malloc_register && (flags & MALLOC_NOREG) == 0)
    mregister_free (mem, ubytes, file, line);
#endif

#ifdef MALLOC_WATCH
  if (_malloc_nwatch > 0)
    _malloc_ckwatch (mem, file, line, W_FREE, ubytes);
#endif
}
warning: parse error {
  register union mhead *p;
  register char *ap, *z;
  register int nunits;
  register unsigned int nbytes;
  int ubytes;		/* caller-requested size */
  mguard_t mg;

  if ((ap = (char *)mem) == 0)
    return;

  p = (union mhead *) ap - 1;

  if (p->mh_alloc == ISMEMALIGN)
    {
      ap -= p->mh_nbytes;
      p = (union mhead *) ap - 1;
    }

#if defined (MALLOC_TRACE) || defined (MALLOC_REGISTER)
  if (malloc_trace || malloc_register)
    ubytes = p->mh_nbytes;
#endif

  if (p->mh_alloc != ISALLOC)
    {
      if (p->mh_alloc == ISFREE)
	xbotch (mem, ERR_DUPFREE,
		_("free: called with already freed block argument"), file, line);
      else
	xbotch (mem, ERR_UNALLOC,
		_("free: called with unallocated block argument"), file, line);
    }

  ASSERT (p->mh_magic2 == MAGIC2);

  nunits = p->mh_index;
  nbytes = ALLOCATED_BYTES(p->mh_nbytes);
  /* Since the sizeof(u_bits32_t) bytes before the memory handed to the user
     are now used for the number of bytes allocated, a simple check of
     mh_magic2 is no longer sufficient to catch things like p[-1] = 'x'.
     We sanity-check the value of mh_nbytes against the size of the blocks
     in the appropriate bucket before we use it.  This can still cause problems
     and obscure errors if mh_nbytes is wrong but still within range; the
     checks against the size recorded at the end of the chunk will probably
     fail then.  Using MALLOC_REGISTER will help here, since it saves the
     original number of bytes requested. */

  if (IN_BUCKET(nbytes, nunits) == 0)
    xbotch (mem, ERR_UNDERFLOW,
	    _("free: underflow detected; mh_nbytes out of range"), file, line);

  ap += p->mh_nbytes;
  z = mg.s;
  *z++ = *ap++, *z++ = *ap++, *z++ = *ap++, *z++ = *ap++;  
  if (mg.i != p->mh_nbytes)
    xbotch (mem, ERR_ASSERT_FAILED, _("free: start and end chunk sizes differ"), file, line);

#if 1
  if (nunits >= LESSCORE_MIN && ((char *)p + binsize(nunits) == memtop))
#else
  if (((char *)p + binsize(nunits) == memtop) && nunits >= LESSCORE_MIN)
#endif
    {
      /* If above LESSCORE_FRC, give back unconditionally.  This should be set
	 high enough to be infrequently encountered.  If between LESSCORE_MIN
	 and LESSCORE_FRC, call lesscore if the bucket is marked as busy or if
	 there's already a block on the free list. */
      if ((nunits >= LESSCORE_FRC) || busy[nunits] || nextf[nunits] != 0)
	{
	  lesscore (nunits);
	  /* keeps the tracing and registering code in one place */
	  goto free_return;
	}
    }

#ifdef MEMSCRAMBLE
  if (p->mh_nbytes)
    MALLOC_MEMSET (mem, 0xcf, p->mh_nbytes);
#endif

  ASSERT (nunits < NBUCKETS);

  if (busy[nunits] == 1)
    {
      xsplit (p, nunits);	/* split block and add to different chain */
      goto free_return;
    }

  p->mh_alloc = ISFREE;
  /* Protect against signal handlers calling malloc.  */
  busy[nunits] = 1;
  /* Put this block on the free list.  */
  CHAIN (p) = nextf[nunits];
  nextf[nunits] = p;
  busy[nunits] = 0;

free_return:
  ;		/* Empty statement in case this is the end of the function */

#ifdef MALLOC_STATS
  _mstats.nmalloc[nunits]--;
  _mstats.nfre++;
#endif /* MALLOC_STATS */

#ifdef MALLOC_TRACE
  if (malloc_trace && (flags & MALLOC_NOTRACE) == 0)
    mtrace_free (mem, ubytes, file, line);
  else if (_malloc_trace_buckets[nunits])
    mtrace_free (mem, ubytes, file, line);
#endif

#ifdef MALLOC_REGISTER
  if (malloc_register && (flags & MALLOC_NOREG) == 0)
    mregister_free (mem, ubytes, file, line);
#endif

#ifdef MALLOC_WATCH
  if (_malloc_nwatch > 0)
    _malloc_ckwatch (mem, file, line, W_FREE, ubytes);
#endif
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\malloc\malloc.c:846
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\malloc\malloc.c:970
parsing error 
{
  register union mhead *p;
  register u_bits32_t tocopy;
  register unsigned int nbytes;
  register int nunits;
  register char *m, *z;
  mguard_t mg;

#ifdef MALLOC_STATS
  _mstats.nrealloc++;
#endif

  if (n == 0)
    {
      internal_free (mem, file, line, MALLOC_INTERNAL);
      return (NULL);
    }
  if ((p = (union mhead *) mem) == 0)
    return internal_malloc (n, file, line, MALLOC_INTERNAL);

  p--;
  nunits = p->mh_index;
  ASSERT (nunits < NBUCKETS);

  if (p->mh_alloc != ISALLOC)
    xbotch (mem, ERR_UNALLOC,
	    _("realloc: called with unallocated block argument"), file, line);

  ASSERT (p->mh_magic2 == MAGIC2);
  nbytes = ALLOCATED_BYTES(p->mh_nbytes);
  /* Since the sizeof(u_bits32_t) bytes before the memory handed to the user
     are now used for the number of bytes allocated, a simple check of
     mh_magic2 is no longer sufficient to catch things like p[-1] = 'x'.
     We sanity-check the value of mh_nbytes against the size of the blocks
     in the appropriate bucket before we use it.  This can still cause problems
     and obscure errors if mh_nbytes is wrong but still within range; the
     checks against the size recorded at the end of the chunk will probably
     fail then.  Using MALLOC_REGISTER will help here, since it saves the
     original number of bytes requested. */
  if (IN_BUCKET(nbytes, nunits) == 0)
    xbotch (mem, ERR_UNDERFLOW,
	    _("realloc: underflow detected; mh_nbytes out of range"), file, line);

  m = (char *)mem + (tocopy = p->mh_nbytes);
  z = mg.s;
  *z++ = *m++, *z++ = *m++, *z++ = *m++, *z++ = *m++;
  if (mg.i != p->mh_nbytes)
    xbotch (mem, ERR_ASSERT_FAILED, _("realloc: start and end chunk sizes differ"), file, line);

#ifdef MALLOC_WATCH
  if (_malloc_nwatch > 0)
    _malloc_ckwatch (p + 1, file, line, W_REALLOC, n);
#endif
#ifdef MALLOC_STATS
  _mstats.bytesreq += (n < tocopy) ? 0 : n - tocopy;
#endif

  /* See if desired size rounds to same power of 2 as actual size. */
  nbytes = ALLOCATED_BYTES(n);

  /* If ok, use the same block, just marking its size as changed.  */
  if (RIGHT_BUCKET(nbytes, nunits))
    {
#if 0
      m = (char *)mem + p->mh_nbytes;
#else
      /* Compensate for increment above. */
      m -= 4;
#endif
      *m++ = 0;  *m++ = 0;  *m++ = 0;  *m++ = 0;
      m = (char *)mem + (p->mh_nbytes = n);

      mg.i = n;
      z = mg.s;
      *m++ = *z++, *m++ = *z++, *m++ = *z++, *m++ = *z++;      

      return mem;
    }

  if (n < tocopy)
    tocopy = n;

#ifdef MALLOC_STATS
  _mstats.nrcopy++;
#endif

  if ((m = internal_malloc (n, file, line, MALLOC_INTERNAL|MALLOC_NOTRACE|MALLOC_NOREG)) == 0)
    return 0;
  FASTCOPY (mem, m, tocopy);
  internal_free (mem, file, line, MALLOC_INTERNAL);

#ifdef MALLOC_TRACE
  if (malloc_trace && (flags & MALLOC_NOTRACE) == 0)
    mtrace_alloc ("realloc", m, n, file, line);
  else if (_malloc_trace_buckets[nunits])
    mtrace_alloc ("realloc", m, n, file, line);
#endif

#ifdef MALLOC_REGISTER
  if (malloc_register && (flags & MALLOC_NOREG) == 0)
    mregister_alloc ("realloc", m, n, file, line);
#endif

#ifdef MALLOC_WATCH
  if (_malloc_nwatch > 0)
    _malloc_ckwatch (m, file, line, W_RESIZED, n);
#endif

  return m;
}
warning: parse error {
  register union mhead *p;
  register u_bits32_t tocopy;
  register unsigned int nbytes;
  register int nunits;
  register char *m, *z;
  mguard_t mg;

#ifdef MALLOC_STATS
  _mstats.nrealloc++;
#endif

  if (n == 0)
    {
      internal_free (mem, file, line, MALLOC_INTERNAL);
      return (NULL);
    }
  if ((p = (union mhead *) mem) == 0)
    return internal_malloc (n, file, line, MALLOC_INTERNAL);

  p--;
  nunits = p->mh_index;
  ASSERT (nunits < NBUCKETS);

  if (p->mh_alloc != ISALLOC)
    xbotch (mem, ERR_UNALLOC,
	    _("realloc: called with unallocated block argument"), file, line);

  ASSERT (p->mh_magic2 == MAGIC2);
  nbytes = ALLOCATED_BYTES(p->mh_nbytes);
  /* Since the sizeof(u_bits32_t) bytes before the memory handed to the user
     are now used for the number of bytes allocated, a simple check of
     mh_magic2 is no longer sufficient to catch things like p[-1] = 'x'.
     We sanity-check the value of mh_nbytes against the size of the blocks
     in the appropriate bucket before we use it.  This can still cause problems
     and obscure errors if mh_nbytes is wrong but still within range; the
     checks against the size recorded at the end of the chunk will probably
     fail then.  Using MALLOC_REGISTER will help here, since it saves the
     original number of bytes requested. */
  if (IN_BUCKET(nbytes, nunits) == 0)
    xbotch (mem, ERR_UNDERFLOW,
	    _("realloc: underflow detected; mh_nbytes out of range"), file, line);

  m = (char *)mem + (tocopy = p->mh_nbytes);
  z = mg.s;
  *z++ = *m++, *z++ = *m++, *z++ = *m++, *z++ = *m++;
  if (mg.i != p->mh_nbytes)
    xbotch (mem, ERR_ASSERT_FAILED, _("realloc: start and end chunk sizes differ"), file, line);

#ifdef MALLOC_WATCH
  if (_malloc_nwatch > 0)
    _malloc_ckwatch (p + 1, file, line, W_REALLOC, n);
#endif
#ifdef MALLOC_STATS
  _mstats.bytesreq += (n < tocopy) ? 0 : n - tocopy;
#endif

  /* See if desired size rounds to same power of 2 as actual size. */
  nbytes = ALLOCATED_BYTES(n);

  /* If ok, use the same block, just marking its size as changed.  */
  if (RIGHT_BUCKET(nbytes, nunits))
    {
#if 0
      m = (char *)mem + p->mh_nbytes;
#else
      /* Compensate for increment above. */
      m -= 4;
#endif
      *m++ = 0;  *m++ = 0;  *m++ = 0;  *m++ = 0;
      m = (char *)mem + (p->mh_nbytes = n);

      mg.i = n;
      z = mg.s;
      *m++ = *z++, *m++ = *z++, *m++ = *z++, *m++ = *z++;      

      return mem;
    }

  if (n < tocopy)
    tocopy = n;

#ifdef MALLOC_STATS
  _mstats.nrcopy++;
#endif

  if ((m = internal_malloc (n, file, line, MALLOC_INTERNAL|MALLOC_NOTRACE|MALLOC_NOREG)) == 0)
    return 0;
  FASTCOPY (mem, m, tocopy);
  internal_free (mem, file, line, MALLOC_INTERNAL);

#ifdef MALLOC_TRACE
  if (malloc_trace && (flags & MALLOC_NOTRACE) == 0)
    mtrace_alloc ("realloc", m, n, file, line);
  else if (_malloc_trace_buckets[nunits])
    mtrace_alloc ("realloc", m, n, file, line);
#endif

#ifdef MALLOC_REGISTER
  if (malloc_register && (flags & MALLOC_NOREG) == 0)
    mregister_alloc ("realloc", m, n, file, line);
#endif

#ifdef MALLOC_WATCH
  if (_malloc_nwatch > 0)
    _malloc_ckwatch (m, file, line, W_RESIZED, n);
#endif

  return m;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\malloc\malloc.c:975
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\malloc\malloc.c:1,087
parsing error 
{
  register char *ptr;
  register char *aligned;
  register union mhead *p;

  ptr = internal_malloc (size + alignment, file, line, MALLOC_INTERNAL);

  if (ptr == 0)
    return 0;
  /* If entire block has the desired alignment, just accept it.  */
  if (((long) ptr & (alignment - 1)) == 0)
    return ptr;
  /* Otherwise, get address of byte in the block that has that alignment.  */
#if 0
  aligned = (char *) (((long) ptr + alignment - 1) & -alignment);
#else
  aligned = (char *) (((long) ptr + alignment - 1) & (~alignment + 1));
#endif

  /* Store a suitable indication of how to free the block,
     so that free can find the true beginning of it.  */
  p = (union mhead *) aligned - 1;
  p->mh_nbytes = aligned - ptr;
  p->mh_alloc = ISMEMALIGN;

  return aligned;
}
warning: parse error {
  register char *ptr;
  register char *aligned;
  register union mhead *p;

  ptr = internal_malloc (size + alignment, file, line, MALLOC_INTERNAL);

  if (ptr == 0)
    return 0;
  /* If entire block has the desired alignment, just accept it.  */
  if (((long) ptr & (alignment - 1)) == 0)
    return ptr;
  /* Otherwise, get address of byte in the block that has that alignment.  */
#if 0
  aligned = (char *) (((long) ptr + alignment - 1) & -alignment);
#else
  aligned = (char *) (((long) ptr + alignment - 1) & (~alignment + 1));
#endif

  /* Store a suitable indication of how to free the block,
     so that free can find the true beginning of it.  */
  p = (union mhead *) aligned - 1;
  p->mh_nbytes = aligned - ptr;
  p->mh_alloc = ISMEMALIGN;

  return aligned;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\malloc\malloc.c:1,092
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\malloc\malloc.c:1,124
parsing error 
{
  return internal_memalign (getpagesize (), size, file, line, flags|MALLOC_INTERNAL);
}
warning: parse error {
  return internal_memalign (getpagesize (), size, file, line, flags|MALLOC_INTERNAL);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\malloc\malloc.c:1,128
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\malloc\malloc.c:1,135
parsing error 
{
  size_t total;
  PTR_T result;

  total = n * s;
  result = internal_malloc (total, file, line, flags|MALLOC_INTERNAL);
  if (result)
    memset (result, 0, total);
  return result;  
}
warning: parse error {
  size_t total;
  PTR_T result;

  total = n * s;
  result = internal_malloc (total, file, line, flags|MALLOC_INTERNAL);
  if (result)
    memset (result, 0, total);
  return result;  
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\malloc\malloc.c:1,139
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\malloc\malloc.c:1,151
parsing error 
{
  internal_free (p, file, line, flags|MALLOC_INTERNAL);
}
warning: parse error {
  internal_free (p, file, line, flags|MALLOC_INTERNAL);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\malloc\malloc.c:1,155
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\malloc\malloc.c:1,162
parsing error 
{
  int nfree;
  register union mhead *p;

  nfree = 0;
  for (p = nextf[size]; p; p = CHAIN (p))
    nfree++;

  return nfree;
}
warning: parse error {
  int nfree;
  register union mhead *p;

  nfree = 0;
  for (p = nextf[size]; p; p = CHAIN (p))
    nfree++;

  return nfree;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\malloc\malloc.c:1,164
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\malloc\malloc.c:1,178
parsing error 
{
  return internal_malloc (bytes, file, line, MALLOC_WRAPPER);
}
warning: parse error {
  return internal_malloc (bytes, file, line, MALLOC_WRAPPER);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\malloc\malloc.c:1,182
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\malloc\malloc.c:1,187
parsing error 
{
  return internal_realloc (ptr, size, file, line, MALLOC_WRAPPER);
}
warning: parse error {
  return internal_realloc (ptr, size, file, line, MALLOC_WRAPPER);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\malloc\malloc.c:1,192
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\malloc\malloc.c:1,197
parsing error 
{
  internal_free (mem, file, line, MALLOC_WRAPPER);
}
warning: parse error {
  internal_free (mem, file, line, MALLOC_WRAPPER);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\malloc\malloc.c:1,201
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\malloc\malloc.c:1,206
parsing error 
{
  return internal_memalign (alignment, size, file, line, MALLOC_WRAPPER);
}
warning: parse error {
  return internal_memalign (alignment, size, file, line, MALLOC_WRAPPER);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\malloc\malloc.c:1,211
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\malloc\malloc.c:1,217
parsing error 
{
  return internal_calloc (n, s, file, line, MALLOC_WRAPPER);
}
warning: parse error {
  return internal_calloc (n, s, file, line, MALLOC_WRAPPER);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\malloc\malloc.c:1,221
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\malloc\malloc.c:1,226
parsing error 
{
  internal_cfree (mem, file, line, MALLOC_WRAPPER);
}
warning: parse error {
  internal_cfree (mem, file, line, MALLOC_WRAPPER);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\malloc\malloc.c:1,230
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\malloc\malloc.c:1,237
parsing error 
{
  return internal_valloc (size, file, line, MALLOC_WRAPPER);
}
warning: parse error {
  return internal_valloc (size, file, line, MALLOC_WRAPPER);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\malloc\malloc.c:1,241
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\malloc\malloc.c:1,251
parsing error 
{
  return internal_malloc (size, (char *)NULL, 0, 0);
}
warning: parse error {
  return internal_malloc (size, (char *)NULL, 0, 0);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\malloc\malloc.c:1,253
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\malloc\malloc.c:1,258
parsing error 
{
  return internal_realloc (mem, nbytes, (char *)NULL, 0, 0);
}
warning: parse error {
  return internal_realloc (mem, nbytes, (char *)NULL, 0, 0);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\malloc\malloc.c:1,261
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\malloc\malloc.c:1,266
parsing error 
{
  internal_free (mem,  (char *)NULL, 0, 0);
}
warning: parse error {
  internal_free (mem,  (char *)NULL, 0, 0);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\malloc\malloc.c:1,268
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\malloc\malloc.c:1,273
parsing error 
{
  return internal_memalign (alignment, size, (char *)NULL, 0, 0);
}
warning: parse error {
  return internal_memalign (alignment, size, (char *)NULL, 0, 0);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\malloc\malloc.c:1,276
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\malloc\malloc.c:1,282
parsing error 
{
  return internal_valloc (size, (char *)NULL, 0, 0);
}
warning: parse error {
  return internal_valloc (size, (char *)NULL, 0, 0);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\malloc\malloc.c:1,284
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\malloc\malloc.c:1,291
parsing error 
{
  return internal_calloc (n, s, (char *)NULL, 0, 0);
}
warning: parse error {
  return internal_calloc (n, s, (char *)NULL, 0, 0);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\malloc\malloc.c:1,293
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\malloc\malloc.c:1,298
parsing error 
{
  internal_cfree (mem, (char *)NULL, 0, 0);
}
warning: parse error {
  internal_cfree (mem, (char *)NULL, 0, 0);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\malloc\malloc.c:1,300
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\malloc\stats.c...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\malloc\imalloc.h...skip
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\malloc\mstats.h...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\malloc\imalloc.h...skip
parsing error 
s
warning: parse error sMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\malloc\stats.c:43
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\malloc\stats.c:44
parsing error 
{
  struct bucket_stats v;

  v.nfree = 0;

  if (size < 0 || size >= NBUCKETS)
    {
      v.blocksize = 0;
      v.nused = v.nmal = v.nmorecore = v.nlesscore = v.nsplit = 0;
      return v;
    }

  v.blocksize = 1 << (size + 3);
  v.nused = _mstats.nmalloc[size];
  v.nmal = _mstats.tmalloc[size];
  v.nmorecore = _mstats.nmorecore[size];
  v.nlesscore = _mstats.nlesscore[size];
  v.nsplit = _mstats.nsplit[size];
  v.ncoalesce = _mstats.ncoalesce[size];

  v.nfree = malloc_free_blocks (size);	/* call back to malloc.c */

  return v;
}
warning: parse error {
  struct bucket_stats v;

  v.nfree = 0;

  if (size < 0 || size >= NBUCKETS)
    {
      v.blocksize = 0;
      v.nused = v.nmal = v.nmorecore = v.nlesscore = v.nsplit = 0;
      return v;
    }

  v.blocksize = 1 << (size + 3);
  v.nused = _mstats.nmalloc[size];
  v.nmal = _mstats.tmalloc[size];
  v.nmorecore = _mstats.nmorecore[size];
  v.nlesscore = _mstats.nlesscore[size];
  v.nsplit = _mstats.nsplit[size];
  v.ncoalesce = _mstats.ncoalesce[size];

  v.nfree = malloc_free_blocks (size);	/* call back to malloc.c */

  return v;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\malloc\stats.c:46
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\malloc\stats.c:94
parsing error 
{
  register int i;
  unsigned long totused, totfree;
  struct bucket_stats v;

  fprintf (fp, "Memory allocation statistics: %s\n    size\tfree\tin use\ttotal\tmorecore lesscore split\tcoalesce\n", s ? s : "");
  for (i = totused = totfree = 0; i < NBUCKETS; i++)
    {
      v = malloc_bucket_stats (i);
      if (v.nmal > 0)
	fprintf (fp, "%8lu\t%4d\t%6d\t%5d\t%8d\t%d %5d %8d\n", (unsigned long)v.blocksize, v.nfree, v.nused, v.nmal, v.nmorecore, v.nlesscore, v.nsplit, v.ncoalesce);
      totfree += v.nfree * v.blocksize;
      totused += v.nused * v.blocksize;
    }
  fprintf (fp, "\nTotal bytes in use: %lu, total bytes free: %lu\n",
	   totused, totfree);
  fprintf (fp, "\nTotal bytes requested by application: %lu\n", _mstats.bytesreq);
  fprintf (fp, "Total mallocs: %d, total frees: %d, total reallocs: %d (%d copies)\n",
	   _mstats.nmal, _mstats.nfre, _mstats.nrealloc, _mstats.nrcopy);
  fprintf (fp, "Total sbrks: %d, total bytes via sbrk: %d\n",
  	   _mstats.nsbrk, _mstats.tsbrk);
  fprintf (fp, "Total blocks split: %d, total block coalesces: %d\n",
  	   _mstats.tbsplit, _mstats.tbcoalesce);
}
warning: parse error {
  register int i;
  unsigned long totused, totfree;
  struct bucket_stats v;

  fprintf (fp, "Memory allocation statistics: %s\n    size\tfree\tin use\ttotal\tmorecore lesscore split\tcoalesce\n", s ? s : "");
  for (i = totused = totfree = 0; i < NBUCKETS; i++)
    {
      v = malloc_bucket_stats (i);
      if (v.nmal > 0)
	fprintf (fp, "%8lu\t%4d\t%6d\t%5d\t%8d\t%d %5d %8d\n", (unsigned long)v.blocksize, v.nfree, v.nused, v.nmal, v.nmorecore, v.nlesscore, v.nsplit, v.ncoalesce);
      totfree += v.nfree * v.blocksize;
      totused += v.nused * v.blocksize;
    }
  fprintf (fp, "\nTotal bytes in use: %lu, total bytes free: %lu\n",
	   totused, totfree);
  fprintf (fp, "\nTotal bytes requested by application: %lu\n", _mstats.bytesreq);
  fprintf (fp, "Total mallocs: %d, total frees: %d, total reallocs: %d (%d copies)\n",
	   _mstats.nmal, _mstats.nfre, _mstats.nrealloc, _mstats.nrcopy);
  fprintf (fp, "Total sbrks: %d, total bytes via sbrk: %d\n",
  	   _mstats.nsbrk, _mstats.tsbrk);
  fprintf (fp, "Total blocks split: %d, total block coalesces: %d\n",
  	   _mstats.tbsplit, _mstats.tbcoalesce);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\malloc\stats.c:97
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\malloc\stats.c:123
parsing error 
{
  _print_malloc_stats (s, stderr);
}
warning: parse error {
  _print_malloc_stats (s, stderr);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\malloc\stats.c:125
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\malloc\stats.c:130
parsing error 
{
  _print_malloc_stats (s, fp);
}
warning: parse error {
  _print_malloc_stats (s, fp);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\malloc\stats.c:133
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\malloc\stats.c:140
parsing error 
{
  FILE *fp;
  char defname[sizeof (TRACEROOT) + 64];
  static char mallbuf[1024];

  fp = _imalloc_fopen (s, fn, TRACEROOT, defname, sizeof (defname));
  if (fp)
    {
      setvbuf (fp, mallbuf, _IOFBF, sizeof (mallbuf));
      _print_malloc_stats (s, fp);
      fflush(fp);
      fclose(fp);
    }
}
warning: parse error {
  FILE *fp;
  char defname[sizeof (TRACEROOT) + 64];
  static char mallbuf[1024];

  fp = _imalloc_fopen (s, fn, TRACEROOT, defname, sizeof (defname));
  if (fp)
    {
      setvbuf (fp, mallbuf, _IOFBF, sizeof (mallbuf));
      _print_malloc_stats (s, fp);
      fflush(fp);
      fclose(fp);
    }
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\malloc\stats.c:142
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\malloc\stats.c:161
parsing error 
{
  char fname[1024];
  long l;
  FILE *fp;

  l = (long)getpid ();
  if (fn == 0)
    {
      sprintf (defbuf, "%s%ld", def, l);
      fp = fopen(defbuf, "w");
    }
  else
    {
      char *p, *q, *r;
      char pidbuf[32];
      int sp;

      sprintf (pidbuf, "%ld", l);
      if ((strlen (pidbuf) + strlen (fn) + 2) >= sizeof (fname))
	return ((FILE *)0);
      for (sp = 0, p = fname, q = fn; *q; )
	{
	  if (sp == 0 && *q == '%' && q[1] == 'p')
	    {
	      sp = 1;
	      for (r = pidbuf; *r; )
		*p++ = *r++;
	      q += 2;
	    }
	  else
	    *p++ = *q++;
	}
      *p = '\0';
      fp = fopen (fname, "w");
    }

  return fp;
}
warning: parse error {
  char fname[1024];
  long l;
  FILE *fp;

  l = (long)getpid ();
  if (fn == 0)
    {
      sprintf (defbuf, "%s%ld", def, l);
      fp = fopen(defbuf, "w");
    }
  else
    {
      char *p, *q, *r;
      char pidbuf[32];
      int sp;

      sprintf (pidbuf, "%ld", l);
      if ((strlen (pidbuf) + strlen (fn) + 2) >= sizeof (fname))
	return ((FILE *)0);
      for (sp = 0, p = fname, q = fn; *q; )
	{
	  if (sp == 0 && *q == '%' && q[1] == 'p')
	    {
	      sp = 1;
	      for (r = pidbuf; *r; )
		*p++ = *r++;
	      q += 2;
	    }
	  else
	    *p++ = *q++;
	}
      *p = '\0';
      fp = fopen (fname, "w");
    }

  return fp;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\malloc\stats.c:167
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\malloc\stub.c...
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\malloc\table.c...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\malloc\imalloc.h...skip
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\malloc\table.h...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\malloc\imalloc.h...skip
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\malloc\table.c:48
parsing error 
{
  unsigned int a, b, c;
  unsigned long x;

  /* set up the internal state */
  a = 0x9e3779b9;	/* the golden ratio; an arbitrary value */
  x = (unsigned long)key;		/* truncation is OK */
  b = x >> 8;
  c = x >> 3;				/* XXX - was >> 4 */

  HASH_MIX(a, b, c);
  return c;
}
warning: parse error {
  unsigned int a, b, c;
  unsigned long x;

  /* set up the internal state */
  a = 0x9e3779b9;	/* the golden ratio; an arbitrary value */
  x = (unsigned long)key;		/* truncation is OK */
  b = x >> 8;
  c = x >> 3;				/* XXX - was >> 4 */

  HASH_MIX(a, b, c);
  return c;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\malloc\table.c:49
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\malloc\table.c:75
parsing error 
{
  unsigned int bucket;
  register mr_table_t *tp;
  mr_table_t *endp, *lastp;

  if (mem_overflow.mem == mem)
    return (&mem_overflow);

  bucket = which_bucket (mem);	/* get initial hash */
  tp = endp = mem_table + bucket;
  lastp = mem_table + REG_TABLE_SIZE;

  while (1)
    {
      if (tp->mem == mem)
	return (tp);
      if (tp->mem == 0 && (flags & FIND_ALLOC))
	{
	  table_count++;
	  return (tp);
	}

      tp++;

      if (tp == lastp)		/* wrap around */
        tp = mem_table;

      if (tp == endp && (flags & FIND_EXIST))
        return ((mr_table_t *)NULL);

      if (tp == endp && (flags & FIND_ALLOC))
        break;
    }

  /* oops.  table is full.  replace an existing free entry. */
  do
    {
      /* If there are no free entries, punt right away without searching. */
      if (table_allocated == REG_TABLE_SIZE)
	break;

      if (tp->flags & MT_FREE)
	{
	  memset(tp, 0, sizeof (mr_table_t));
	  return (tp);
	}
      tp++;

      if (tp == lastp)
	tp = mem_table;
    }
  while (tp != endp);

  /* wow. entirely full.  return mem_overflow dummy entry. */
  tp = &mem_overflow;
  memset (tp, 0, sizeof (mr_table_t));
  return tp;
}
warning: parse error {
  unsigned int bucket;
  register mr_table_t *tp;
  mr_table_t *endp, *lastp;

  if (mem_overflow.mem == mem)
    return (&mem_overflow);

  bucket = which_bucket (mem);	/* get initial hash */
  tp = endp = mem_table + bucket;
  lastp = mem_table + REG_TABLE_SIZE;

  while (1)
    {
      if (tp->mem == mem)
	return (tp);
      if (tp->mem == 0 && (flags & FIND_ALLOC))
	{
	  table_count++;
	  return (tp);
	}

      tp++;

      if (tp == lastp)		/* wrap around */
        tp = mem_table;

      if (tp == endp && (flags & FIND_EXIST))
        return ((mr_table_t *)NULL);

      if (tp == endp && (flags & FIND_ALLOC))
        break;
    }

  /* oops.  table is full.  replace an existing free entry. */
  do
    {
      /* If there are no free entries, punt right away without searching. */
      if (table_allocated == REG_TABLE_SIZE)
	break;

      if (tp->flags & MT_FREE)
	{
	  memset(tp, 0, sizeof (mr_table_t));
	  return (tp);
	}
      tp++;

      if (tp == lastp)
	tp = mem_table;
    }
  while (tp != endp);

  /* wow. entirely full.  return mem_overflow dummy entry. */
  tp = &mem_overflow;
  memset (tp, 0, sizeof (mr_table_t));
  return tp;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\malloc\table.c:78
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\malloc\table.c:138
parsing error 
{
  return (find_entry (mem, FIND_EXIST));
}
warning: parse error {
  return (find_entry (mem, FIND_EXIST));
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\malloc\table.c:140
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\malloc\table.c:145
parsing error 
{
  mr_table_t *entry;

  entry = find_entry (mem, FIND_EXIST);
  if (entry == 0)
    return;
  fprintf (fp, "malloc: %p: %s: last %s from %s:%d\n",
  		mem,
		(entry->flags & MT_ALLOC) ? "allocated" : "free",
		(entry->flags & MT_ALLOC) ? "allocated" : "freed",
		entry->file ? entry->file : "unknown",
		entry->line);
}
warning: parse error {
  mr_table_t *entry;

  entry = find_entry (mem, FIND_EXIST);
  if (entry == 0)
    return;
  fprintf (fp, "malloc: %p: %s: last %s from %s:%d\n",
  		mem,
		(entry->flags & MT_ALLOC) ? "allocated" : "free",
		(entry->flags & MT_ALLOC) ? "allocated" : "freed",
		entry->file ? entry->file : "unknown",
		entry->line);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\malloc\table.c:148
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\malloc\table.c:164
parsing error 
{
  mr_table_t *tentry;

  tentry = find_entry (mem, FIND_ALLOC);

  if (tentry == 0)
    {
      /* oops.  table is full.  punt. */
      fprintf (stderr, _("register_alloc: alloc table is full with FIND_ALLOC?\n"));
      return;
    }
  
  if (tentry->flags & MT_ALLOC)
    {
      /* oops.  bad bookkeeping. ignore for now */
      fprintf (stderr, _("register_alloc: %p already in table as allocated?\n"), mem);
    }

  tentry->mem = mem;
  tentry->size = size;
  tentry->func = tag;
  tentry->flags = MT_ALLOC;
  tentry->file = file;
  tentry->line = line;
  tentry->nalloc++;

  if (tentry != &mem_overflow)
    table_allocated++;
}
warning: parse error {
  mr_table_t *tentry;

  tentry = find_entry (mem, FIND_ALLOC);

  if (tentry == 0)
    {
      /* oops.  table is full.  punt. */
      fprintf (stderr, _("register_alloc: alloc table is full with FIND_ALLOC?\n"));
      return;
    }
  
  if (tentry->flags & MT_ALLOC)
    {
      /* oops.  bad bookkeeping. ignore for now */
      fprintf (stderr, _("register_alloc: %p already in table as allocated?\n"), mem);
    }

  tentry->mem = mem;
  tentry->size = size;
  tentry->func = tag;
  tentry->flags = MT_ALLOC;
  tentry->file = file;
  tentry->line = line;
  tentry->nalloc++;

  if (tentry != &mem_overflow)
    table_allocated++;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\malloc\table.c:169
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\malloc\table.c:200
parsing error 
{
  mr_table_t *tentry;

  tentry = find_entry (mem, FIND_EXIST);
  if (tentry == 0)
    {
      /* oops.  not found. */
#if 0
      fprintf (stderr, "register_free: %p not in allocation table?\n", mem);
#endif
      return;
    }
  if (tentry->flags & MT_FREE)
    {
      /* oops.  bad bookkeeping. ignore for now */
      fprintf (stderr, _("register_free: %p already in table as free?\n"), mem);
    }
    	
  tentry->flags = MT_FREE;
  tentry->func = "free";
  tentry->file = file;
  tentry->line = line;
  tentry->nfree++;

  if (tentry != &mem_overflow)
    table_allocated--;
}
warning: parse error {
  mr_table_t *tentry;

  tentry = find_entry (mem, FIND_EXIST);
  if (tentry == 0)
    {
      /* oops.  not found. */
#if 0
      fprintf (stderr, "register_free: %p not in allocation table?\n", mem);
#endif
      return;
    }
  if (tentry->flags & MT_FREE)
    {
      /* oops.  bad bookkeeping. ignore for now */
      fprintf (stderr, _("register_free: %p already in table as free?\n"), mem);
    }
    	
  tentry->flags = MT_FREE;
  tentry->func = "free";
  tentry->file = file;
  tentry->line = line;
  tentry->nfree++;

  if (tentry != &mem_overflow)
    table_allocated--;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\malloc\table.c:205
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\malloc\table.c:235
parsing error 
{
  if (x & MT_FREE)
    return "free";
  else if (x & MT_ALLOC)
    return "allocated";
  else
    return "undetermined?";
}
warning: parse error {
  if (x & MT_FREE)
    return "free";
  else if (x & MT_ALLOC)
    return "allocated";
  else
    return "undetermined?";
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\malloc\table.c:237
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\malloc\table.c:247
parsing error 
{
  register int i;
  mr_table_t entry;

  for (i = 0; i < REG_TABLE_SIZE; i++)
    {
      entry = mem_table[i];
      if (entry.mem)
	fprintf (fp, "[%d] %p:%d:%s:%s:%s:%d:%d:%d\n", i,
						entry.mem, entry.size,
						_entry_flags(entry.flags),
						entry.func ? entry.func : "unknown",
						entry.file ? entry.file : "unknown",
						entry.line,
						entry.nalloc, entry.nfree);
    }
}
warning: parse error {
  register int i;
  mr_table_t entry;

  for (i = 0; i < REG_TABLE_SIZE; i++)
    {
      entry = mem_table[i];
      if (entry.mem)
	fprintf (fp, "[%d] %p:%d:%s:%s:%s:%d:%d:%d\n", i,
						entry.mem, entry.size,
						_entry_flags(entry.flags),
						entry.func ? entry.func : "unknown",
						entry.file ? entry.file : "unknown",
						entry.line,
						entry.nalloc, entry.nfree);
    }
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\malloc\table.c:249
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\malloc\table.c:284
parsing error 
{
  int old;

  old = malloc_register;
  malloc_register = n;
  return old;
}
warning: parse error {
  int old;

  old = malloc_register;
  malloc_register = n;
  return old;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\malloc\table.c:286
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\malloc\trace.c...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\malloc\imalloc.h...skip
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\malloc\trace.c:45
parsing error 
{
  if (_mtrace_fp == NULL)
    _mtrace_fp = stderr;

  if (_mtrace_verbose)
    fprintf (_mtrace_fp, "alloc: %s: %p (%d bytes) from '%s:%d'\n",
		tag, mem, size, file ? file : "unknown", line);
  else
    fprintf (_mtrace_fp, "alloc:%p:%d:%s:%d\n",
		mem, size, file ? file : "unknown", line);
}
warning: parse error {
  if (_mtrace_fp == NULL)
    _mtrace_fp = stderr;

  if (_mtrace_verbose)
    fprintf (_mtrace_fp, "alloc: %s: %p (%d bytes) from '%s:%d'\n",
		tag, mem, size, file ? file : "unknown", line);
  else
    fprintf (_mtrace_fp, "alloc:%p:%d:%s:%d\n",
		mem, size, file ? file : "unknown", line);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\malloc\trace.c:50
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\malloc\trace.c:63
parsing error 
{
  if (_mtrace_fp == NULL)
    _mtrace_fp = stderr;

  if (_mtrace_verbose)
    fprintf (_mtrace_fp, "free: %p (%d bytes) from '%s:%d'\n",
		mem, size, file ? file : "unknown", line);
  else
    fprintf (_mtrace_fp, "free:%p:%d:%s:%d\n",
		mem, size, file ? file : "unknown", line);
}
warning: parse error {
  if (_mtrace_fp == NULL)
    _mtrace_fp = stderr;

  if (_mtrace_verbose)
    fprintf (_mtrace_fp, "free: %p (%d bytes) from '%s:%d'\n",
		mem, size, file ? file : "unknown", line);
  else
    fprintf (_mtrace_fp, "free:%p:%d:%s:%d\n",
		mem, size, file ? file : "unknown", line);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\malloc\trace.c:68
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\malloc\trace.c:82
parsing error 
{
  int old;

  old = malloc_trace;
  malloc_trace = n;
  _mtrace_verbose = (n > 1);
  return old;
}
warning: parse error {
  int old;

  old = malloc_trace;
  malloc_trace = n;
  _mtrace_verbose = (n > 1);
  return old;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\malloc\trace.c:84
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\malloc\trace.c:94
parsing error 
{
#ifdef MALLOC_TRACE
  _mtrace_fp = fp ? fp : stderr;
#endif
}
warning: parse error {
#ifdef MALLOC_TRACE
  _mtrace_fp = fp ? fp : stderr;
#endif
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\malloc\trace.c:96
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\malloc\trace.c:103
parsing error 
{
#ifdef MALLOC_TRACE
  _malloc_trace_buckets[n] = 1;
#endif
}
warning: parse error {
#ifdef MALLOC_TRACE
  _malloc_trace_buckets[n] = 1;
#endif
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\malloc\trace.c:105
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\malloc\trace.c:114
parsing error 
{
#ifdef MALLOC_TRACE
  FILE *fp;
  char defname[sizeof (TRACEROOT) + 64];

  fp = _imalloc_fopen (s, fn, TRACEROOT, defname, sizeof (defname));
  if (fp)
    malloc_set_tracefp (fp);
#endif
}
warning: parse error {
#ifdef MALLOC_TRACE
  FILE *fp;
  char defname[sizeof (TRACEROOT) + 64];

  fp = _imalloc_fopen (s, fn, TRACEROOT, defname, sizeof (defname));
  if (fp)
    malloc_set_tracefp (fp);
#endif
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\malloc\trace.c:117
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\malloc\watch.c...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\malloc\imalloc.h...skip
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\malloc\watch.h...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\malloc\imalloc.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\malloc\watch.c:38
parsing error 
{
  char *tag;

  if (type == W_ALLOC)
    tag = "allocated";
  else if (type == W_FREE)
    tag = "freed";
  else if (type == W_REALLOC)
    tag = "requesting resize";
  else if (type == W_RESIZED)
    tag = "just resized";
  else
    tag = "bug: unknown operation";

  fprintf (stderr, "malloc: watch alert: %p %s ", addr, tag);
  if (data != (unsigned long)-1)
    fprintf (stderr, "(size %lu) ", data);
  fprintf (stderr, "from '%s:%d'\n", file ? file : "unknown", line);
}
warning: parse error {
  char *tag;

  if (type == W_ALLOC)
    tag = "allocated";
  else if (type == W_FREE)
    tag = "freed";
  else if (type == W_REALLOC)
    tag = "requesting resize";
  else if (type == W_RESIZED)
    tag = "just resized";
  else
    tag = "bug: unknown operation";

  fprintf (stderr, "malloc: watch alert: %p %s ", addr, tag);
  if (data != (unsigned long)-1)
    fprintf (stderr, "(size %lu) ", data);
  fprintf (stderr, "from '%s:%d'\n", file ? file : "unknown", line);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\malloc\watch.c:43
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\malloc\watch.c:64
parsing error 
{
  register int i;

  for (i = _malloc_nwatch - 1; i >= 0; i--)
    {
      if (_malloc_watch_list[i] == addr)
	{
	  watch_warn (addr, file, line, type, data);
	  return;
	}
    }
}
warning: parse error {
  register int i;

  for (i = _malloc_nwatch - 1; i >= 0; i--)
    {
      if (_malloc_watch_list[i] == addr)
	{
	  watch_warn (addr, file, line, type, data);
	  return;
	}
    }
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\malloc\watch.c:69
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\malloc\watch.c:84
parsing error 
{
  register int i;
  PTR_T ret;

  if (addr == 0)
    return addr;
  ret = (PTR_T)0;

#ifdef MALLOC_WATCH
  for (i = _malloc_nwatch - 1; i >= 0; i--)
    {
      if (_malloc_watch_list[i] == addr)
        break;
    }
  if (i < 0)
    {
      if (_malloc_nwatch == WATCH_MAX)	/* full, take out first */
	{
	  ret = _malloc_watch_list[0];
	  _malloc_nwatch--;
	  for (i = 0; i < _malloc_nwatch; i++)
	    _malloc_watch_list[i] = _malloc_watch_list[i+1];
	}
      _malloc_watch_list[_malloc_nwatch++] = addr;
    }
#endif

  return ret;  
}
warning: parse error {
  register int i;
  PTR_T ret;

  if (addr == 0)
    return addr;
  ret = (PTR_T)0;

#ifdef MALLOC_WATCH
  for (i = _malloc_nwatch - 1; i >= 0; i--)
    {
      if (_malloc_watch_list[i] == addr)
        break;
    }
  if (i < 0)
    {
      if (_malloc_nwatch == WATCH_MAX)	/* full, take out first */
	{
	  ret = _malloc_watch_list[0];
	  _malloc_nwatch--;
	  for (i = 0; i < _malloc_nwatch; i++)
	    _malloc_watch_list[i] = _malloc_watch_list[i+1];
	}
      _malloc_watch_list[_malloc_nwatch++] = addr;
    }
#endif

  return ret;  
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\malloc\watch.c:86
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\malloc\watch.c:120
parsing error 
{
#ifdef MALLOC_WATCH
  register int i;

  if (addr == 0)
    {
      for (i = 0; i < _malloc_nwatch; i++)
        _malloc_watch_list[i] = (PTR_T)0;
      _malloc_nwatch = 0;
      return ((PTR_T)0);
    }
  else
    {
      for (i = 0; i < _malloc_nwatch; i++)
	{
	  if (_malloc_watch_list[i] == addr)
	    break;
	}
      if (i == _malloc_nwatch)
        return ((PTR_T)0);		/* not found */
      /* shuffle everything from i+1 to end down 1 */
      _malloc_nwatch--;
      for ( ; i < _malloc_nwatch; i++)
        _malloc_watch_list[i] = _malloc_watch_list[i+1];
      return addr;
    }
#else
  return ((PTR_T)0);
#endif
}
warning: parse error {
#ifdef MALLOC_WATCH
  register int i;

  if (addr == 0)
    {
      for (i = 0; i < _malloc_nwatch; i++)
        _malloc_watch_list[i] = (PTR_T)0;
      _malloc_nwatch = 0;
      return ((PTR_T)0);
    }
  else
    {
      for (i = 0; i < _malloc_nwatch; i++)
	{
	  if (_malloc_watch_list[i] == addr)
	    break;
	}
      if (i == _malloc_nwatch)
        return ((PTR_T)0);		/* not found */
      /* shuffle everything from i+1 to end down 1 */
      _malloc_nwatch--;
      for ( ; i < _malloc_nwatch; i++)
        _malloc_watch_list[i] = _malloc_watch_list[i+1];
      return addr;
    }
#else
  return ((PTR_T)0);
#endif
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\malloc\watch.c:122
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\malloc\xmalloc.c...
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\malloc\xmalloc.c:52
parsing error 
{
  fprintf (stderr, "%s: out of virtual memory\n", fname);
  exit (2);
}
warning: parse error {
  fprintf (stderr, "%s: out of virtual memory\n", fname);
  exit (2);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\malloc\xmalloc.c:54
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\malloc\xmalloc.c:63
parsing error 
{
  PTR_T temp;

  temp = malloc (bytes);
  if (temp == 0)
    memory_error_and_abort ("xmalloc");
  return (temp);
}
warning: parse error {
  PTR_T temp;

  temp = malloc (bytes);
  if (temp == 0)
    memory_error_and_abort ("xmalloc");
  return (temp);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\malloc\xmalloc.c:65
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\malloc\xmalloc.c:75
parsing error 
{
  PTR_T temp;

  temp = pointer ? realloc (pointer, bytes) : malloc (bytes);

  if (temp == 0)
    memory_error_and_abort ("xrealloc");
  return (temp);
}
warning: parse error {
  PTR_T temp;

  temp = pointer ? realloc (pointer, bytes) : malloc (bytes);

  if (temp == 0)
    memory_error_and_abort ("xrealloc");
  return (temp);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\malloc\xmalloc.c:78
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\malloc\xmalloc.c:89
parsing error 
{
  if (string)
    free (string);
}
warning: parse error {
  if (string)
    free (string);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\malloc\xmalloc.c:91
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\bind.c...
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\posixstat.h...
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\rldefs.h...
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\rlstdc.h...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\rlconf.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\history.h...skip
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\rlprivate.h...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\rlconf.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\rlstdc.h...skip
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\posixjmp.h...
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\rlshell.h...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\rlstdc.h...skip
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\xmalloc.h...
parsing error 
extern PTR_T xmalloc PARAMS((size_t));
warning: parse error extern PTR_T xmalloc PARAMS((size_t));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\xmalloc.h:41
parsing error 
extern PTR_T xrealloc PARAMS((void *, size_t));
warning: parse error extern PTR_T xrealloc PARAMS((void *, size_t));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\xmalloc.h:42
parsing error 
extern void xfree PARAMS((void *));
warning: parse error extern void xfree PARAMS((void *));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\xmalloc.h:43
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\bind.c:100
parsing error 
{
  if (key != -1)
    rl_bind_key (key, function);
  rl_add_funmap_entry (name, function);
  return 0;
}
warning: parse error {
  if (key != -1)
    rl_bind_key (key, function);
  rl_add_funmap_entry (name, function);
  return 0;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\bind.c:103
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\bind.c:112
parsing error 
{
  if (key < 0)
    return (key);

  if (META_CHAR (key) && _rl_convert_meta_chars_to_ascii)
    {
      if (_rl_keymap[ESC].type == ISKMAP)
	{
	  Keymap escmap;

	  escmap = FUNCTION_TO_KEYMAP (_rl_keymap, ESC);
	  key = UNMETA (key);
	  escmap[key].type = ISFUNC;
	  escmap[key].function = function;
	  return (0);
	}
      return (key);
    }

  _rl_keymap[key].type = ISFUNC;
  _rl_keymap[key].function = function;
  rl_binding_keymap = _rl_keymap;
  return (0);
}
warning: parse error {
  if (key < 0)
    return (key);

  if (META_CHAR (key) && _rl_convert_meta_chars_to_ascii)
    {
      if (_rl_keymap[ESC].type == ISKMAP)
	{
	  Keymap escmap;

	  escmap = FUNCTION_TO_KEYMAP (_rl_keymap, ESC);
	  key = UNMETA (key);
	  escmap[key].type = ISFUNC;
	  escmap[key].function = function;
	  return (0);
	}
      return (key);
    }

  _rl_keymap[key].type = ISFUNC;
  _rl_keymap[key].function = function;
  rl_binding_keymap = _rl_keymap;
  return (0);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\bind.c:115
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\bind.c:143
parsing error 
{
  int result;
  Keymap oldmap;

  oldmap = _rl_keymap;
  _rl_keymap = map;
  result = rl_bind_key (key, function);
  _rl_keymap = oldmap;
  return (result);
}
warning: parse error {
  int result;
  Keymap oldmap;

  oldmap = _rl_keymap;
  _rl_keymap = map;
  result = rl_bind_key (key, function);
  _rl_keymap = oldmap;
  return (result);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\bind.c:147
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\bind.c:162
parsing error 
{
  char keyseq[2];

  keyseq[0] = (unsigned char)key;
  keyseq[1] = '\0';
  return (rl_bind_keyseq_if_unbound_in_map (keyseq, default_func, kmap));
}
warning: parse error {
  char keyseq[2];

  keyseq[0] = (unsigned char)key;
  keyseq[1] = '\0';
  return (rl_bind_keyseq_if_unbound_in_map (keyseq, default_func, kmap));
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\bind.c:166
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\bind.c:175
parsing error 
{
  char keyseq[2];

  keyseq[0] = (unsigned char)key;
  keyseq[1] = '\0';
  return (rl_bind_keyseq_if_unbound_in_map (keyseq, default_func, _rl_keymap));
}
warning: parse error {
  char keyseq[2];

  keyseq[0] = (unsigned char)key;
  keyseq[1] = '\0';
  return (rl_bind_keyseq_if_unbound_in_map (keyseq, default_func, _rl_keymap));
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\bind.c:178
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\bind.c:189
parsing error 
{
  return (rl_bind_key (key, (rl_command_func_t *)NULL));
}
warning: parse error {
  return (rl_bind_key (key, (rl_command_func_t *)NULL));
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\bind.c:191
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\bind.c:198
parsing error 
{
  return (rl_bind_key_in_map (key, (rl_command_func_t *)NULL, map));
}
warning: parse error {
  return (rl_bind_key_in_map (key, (rl_command_func_t *)NULL, map));
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\bind.c:201
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\bind.c:207
parsing error 
{
  register int i, rval;

  for (i = rval = 0; i < KEYMAP_SIZE; i++)
    {
      if (map[i].type == ISFUNC && map[i].function == func)
	{
	  map[i].function = (rl_command_func_t *)NULL;
	  rval = 1;
	}
    }
  return rval;
}
warning: parse error {
  register int i, rval;

  for (i = rval = 0; i < KEYMAP_SIZE; i++)
    {
      if (map[i].type == ISFUNC && map[i].function == func)
	{
	  map[i].function = (rl_command_func_t *)NULL;
	  rval = 1;
	}
    }
  return rval;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\bind.c:210
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\bind.c:226
parsing error 
{
  rl_command_func_t *func;

  func = rl_named_function (command);
  if (func == 0)
    return 0;
  return (rl_unbind_function_in_map (func, map));
}
warning: parse error {
  rl_command_func_t *func;

  func = rl_named_function (command);
  if (func == 0)
    return 0;
  return (rl_unbind_function_in_map (func, map));
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\bind.c:228
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\bind.c:242
parsing error 
{
  return (rl_generic_bind (ISFUNC, keyseq, (char *)function, _rl_keymap));
}
warning: parse error {
  return (rl_generic_bind (ISFUNC, keyseq, (char *)function, _rl_keymap));
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\bind.c:244
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\bind.c:253
parsing error 
{
  return (rl_generic_bind (ISFUNC, keyseq, (char *)function, map));
}
warning: parse error {
  return (rl_generic_bind (ISFUNC, keyseq, (char *)function, map));
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\bind.c:256
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\bind.c:263
parsing error 
{
  return (rl_generic_bind (ISFUNC, keyseq, (char *)function, map));
}
warning: parse error {
  return (rl_generic_bind (ISFUNC, keyseq, (char *)function, map));
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\bind.c:266
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\bind.c:275
parsing error 
{
  rl_command_func_t *func;

  if (keyseq)
    {
      func = rl_function_of_keyseq (keyseq, kmap, (int *)NULL);
#if defined (VI_MODE)
      if (!func || func == rl_do_lowercase_version || func == rl_vi_movement_mode)
#else
      if (!func || func == rl_do_lowercase_version)
#endif
	return (rl_bind_keyseq_in_map (keyseq, default_func, kmap));
      else
	return 1;
    }
  return 0;
}
warning: parse error {
  rl_command_func_t *func;

  if (keyseq)
    {
      func = rl_function_of_keyseq (keyseq, kmap, (int *)NULL);
#if defined (VI_MODE)
      if (!func || func == rl_do_lowercase_version || func == rl_vi_movement_mode)
#else
      if (!func || func == rl_do_lowercase_version)
#endif
	return (rl_bind_keyseq_in_map (keyseq, default_func, kmap));
      else
	return 1;
    }
  return 0;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\bind.c:278
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\bind.c:298
parsing error 
{
  return (rl_bind_keyseq_if_unbound_in_map (keyseq, default_func, _rl_keymap));
}
warning: parse error {
  return (rl_bind_keyseq_if_unbound_in_map (keyseq, default_func, _rl_keymap));
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\bind.c:300
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\bind.c:309
parsing error 
{
  char *macro_keys;
  int macro_keys_len;

  macro_keys = (char *)xmalloc ((2 * strlen (macro)) + 1);

  if (rl_translate_keyseq (macro, macro_keys, &macro_keys_len))
    {
      xfree (macro_keys);
      return -1;
    }
  rl_generic_bind (ISMACR, keyseq, macro_keys, map);
  return 0;
}
warning: parse error {
  char *macro_keys;
  int macro_keys_len;

  macro_keys = (char *)xmalloc ((2 * strlen (macro)) + 1);

  if (rl_translate_keyseq (macro, macro_keys, &macro_keys_len))
    {
      xfree (macro_keys);
      return -1;
    }
  rl_generic_bind (ISMACR, keyseq, macro_keys, map);
  return 0;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\bind.c:311
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\bind.c:332
parsing error 
{
  char *keys;
  int keys_len;
  register int i;
  KEYMAP_ENTRY k;

  k.function = 0;

  /* If no keys to bind to, exit right away. */
  if (keyseq == 0 || *keyseq == 0)
    {
      if (type == ISMACR)
	xfree (data);
      return -1;
    }

  keys = (char *)xmalloc (1 + (2 * strlen (keyseq)));

  /* Translate the ASCII representation of KEYSEQ into an array of
     characters.  Stuff the characters into KEYS, and the length of
     KEYS into KEYS_LEN. */
  if (rl_translate_keyseq (keyseq, keys, &keys_len))
    {
      xfree (keys);
      return -1;
    }

  /* Bind keys, making new keymaps as necessary. */
  for (i = 0; i < keys_len; i++)
    {
      unsigned char uc = keys[i];
      int ic;

      ic = uc;
      if (ic < 0 || ic >= KEYMAP_SIZE)
        {
          xfree (keys);
	  return -1;
        }

      if (META_CHAR (ic) && _rl_convert_meta_chars_to_ascii)
	{
	  ic = UNMETA (ic);
	  if (map[ESC].type == ISKMAP)
	    map = FUNCTION_TO_KEYMAP (map, ESC);
	}

      if ((i + 1) < keys_len)
	{
	  if (map[ic].type != ISKMAP)
	    {
	      /* We allow subsequences of keys.  If a keymap is being
		 created that will `shadow' an existing function or macro
		 key binding, we save that keybinding into the ANYOTHERKEY
		 index in the new map.  The dispatch code will look there
		 to find the function to execute if the subsequence is not
		 matched.  ANYOTHERKEY was chosen to be greater than
		 UCHAR_MAX. */
	      k = map[ic];

	      map[ic].type = ISKMAP;
	      map[ic].function = KEYMAP_TO_FUNCTION (rl_make_bare_keymap());
	    }
	  map = FUNCTION_TO_KEYMAP (map, ic);
	  /* The dispatch code will return this function if no matching
	     key sequence is found in the keymap.  This (with a little
	     help from the dispatch code in readline.c) allows `a' to be
	     mapped to something, `abc' to be mapped to something else,
	     and the function bound  to `a' to be executed when the user
	     types `abx', leaving `bx' in the input queue. */
	  if (k.function && ((k.type == ISFUNC && k.function != rl_do_lowercase_version) || k.type == ISMACR))
	    {
	      map[ANYOTHERKEY] = k;
	      k.function = 0;
	    }
	}
      else
	{
	  if (map[ic].type == ISMACR)
	    xfree ((char *)map[ic].function);
	  else if (map[ic].type == ISKMAP)
	    {
	      map = FUNCTION_TO_KEYMAP (map, ic);
	      ic = ANYOTHERKEY;
	      /* If we're trying to override a keymap with a null function
		 (e.g., trying to unbind it), we can't use a null pointer
		 here because that's indistinguishable from having not been
		 overridden.  We use a special bindable function that does
		 nothing. */
	      if (type == ISFUNC && data == 0)
		data = (char *)_rl_null_function;
	    }

	  map[ic].function = KEYMAP_TO_FUNCTION (data);
	  map[ic].type = type;
	}

      rl_binding_keymap = map;
    }
  xfree (keys);
  return 0;
}
warning: parse error {
  char *keys;
  int keys_len;
  register int i;
  KEYMAP_ENTRY k;

  k.function = 0;

  /* If no keys to bind to, exit right away. */
  if (keyseq == 0 || *keyseq == 0)
    {
      if (type == ISMACR)
	xfree (data);
      return -1;
    }

  keys = (char *)xmalloc (1 + (2 * strlen (keyseq)));

  /* Translate the ASCII representation of KEYSEQ into an array of
     characters.  Stuff the characters into KEYS, and the length of
     KEYS into KEYS_LEN. */
  if (rl_translate_keyseq (keyseq, keys, &keys_len))
    {
      xfree (keys);
      return -1;
    }

  /* Bind keys, making new keymaps as necessary. */
  for (i = 0; i < keys_len; i++)
    {
      unsigned char uc = keys[i];
      int ic;

      ic = uc;
      if (ic < 0 || ic >= KEYMAP_SIZE)
        {
          xfree (keys);
	  return -1;
        }

      if (META_CHAR (ic) && _rl_convert_meta_chars_to_ascii)
	{
	  ic = UNMETA (ic);
	  if (map[ESC].type == ISKMAP)
	    map = FUNCTION_TO_KEYMAP (map, ESC);
	}

      if ((i + 1) < keys_len)
	{
	  if (map[ic].type != ISKMAP)
	    {
	      /* We allow subsequences of keys.  If a keymap is being
		 created that will `shadow' an existing function or macro
		 key binding, we save that keybinding into the ANYOTHERKEY
		 index in the new map.  The dispatch code will look there
		 to find the function to execute if the subsequence is not
		 matched.  ANYOTHERKEY was chosen to be greater than
		 UCHAR_MAX. */
	      k = map[ic];

	      map[ic].type = ISKMAP;
	      map[ic].function = KEYMAP_TO_FUNCTION (rl_make_bare_keymap());
	    }
	  map = FUNCTION_TO_KEYMAP (map, ic);
	  /* The dispatch code will return this function if no matching
	     key sequence is found in the keymap.  This (with a little
	     help from the dispatch code in readline.c) allows `a' to be
	     mapped to something, `abc' to be mapped to something else,
	     and the function bound  to `a' to be executed when the user
	     types `abx', leaving `bx' in the input queue. */
	  if (k.function && ((k.type == ISFUNC && k.function != rl_do_lowercase_version) || k.type == ISMACR))
	    {
	      map[ANYOTHERKEY] = k;
	      k.function = 0;
	    }
	}
      else
	{
	  if (map[ic].type == ISMACR)
	    xfree ((char *)map[ic].function);
	  else if (map[ic].type == ISKMAP)
	    {
	      map = FUNCTION_TO_KEYMAP (map, ic);
	      ic = ANYOTHERKEY;
	      /* If we're trying to override a keymap with a null function
		 (e.g., trying to unbind it), we can't use a null pointer
		 here because that's indistinguishable from having not been
		 overridden.  We use a special bindable function that does
		 nothing. */
	      if (type == ISFUNC && data == 0)
		data = (char *)_rl_null_function;
	    }

	  map[ic].function = KEYMAP_TO_FUNCTION (data);
	  map[ic].type = type;
	}

      rl_binding_keymap = map;
    }
  xfree (keys);
  return 0;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\bind.c:337
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\bind.c:445
parsing error 
{
  register int i, c, l, temp;

  for (i = l = 0; c = seq[i]; i++)
    {
      if (c == '\\')
	{
	  c = seq[++i];

	  if (c == 0)
	    break;

	  /* Handle \C- and \M- prefixes. */
	  if ((c == 'C' || c == 'M') && seq[i + 1] == '-')
	    {
	      /* Handle special case of backwards define. */
	      if (strncmp (&seq[i], "C-\\M-", 5) == 0)
		{
		  array[l++] = ESC;	/* ESC is meta-prefix */
		  i += 5;
		  array[l++] = CTRL (_rl_to_upper (seq[i]));
		  if (seq[i] == '\0')
		    i--;
		}
	      else if (c == 'M')
		{
		  i++;		/* seq[i] == '-' */
		  /* XXX - obey convert-meta setting */
		  if (_rl_convert_meta_chars_to_ascii && _rl_keymap[ESC].type == ISKMAP)
		    array[l++] = ESC;	/* ESC is meta-prefix */
		  else if (seq[i+1] == '\\' && seq[i+2] == 'C' && seq[i+3] == '-')
		    {
		      i += 4;
		      temp = (seq[i] == '?') ? RUBOUT : CTRL (_rl_to_upper (seq[i]));
		      array[l++] = META (temp);
		    }
		  else
		    {
		      /* This doesn't yet handle things like \M-\a, which may
			 or may not have any reasonable meaning.  You're
			 probably better off using straight octal or hex. */
		      i++;
		      array[l++] = META (seq[i]);
		    }
		}
	      else if (c == 'C')
		{
		  i += 2;
		  /* Special hack for C-?... */
		  array[l++] = (seq[i] == '?') ? RUBOUT : CTRL (_rl_to_upper (seq[i]));
		}
	      continue;
	    }	      

	  /* Translate other backslash-escaped characters.  These are the
	     same escape sequences that bash's `echo' and `printf' builtins
	     handle, with the addition of \d -> RUBOUT.  A backslash
	     preceding a character that is not special is stripped. */
	  switch (c)
	    {
	    case 'a':
	      array[l++] = '\007';
	      break;
	    case 'b':
	      array[l++] = '\b';
	      break;
	    case 'd':
	      array[l++] = RUBOUT;	/* readline-specific */
	      break;
	    case 'e':
	      array[l++] = ESC;
	      break;
	    case 'f':
	      array[l++] = '\f';
	      break;
	    case 'n':
	      array[l++] = NEWLINE;
	      break;
	    case 'r':
	      array[l++] = RETURN;
	      break;
	    case 't':
	      array[l++] = TAB;
	      break;
	    case 'v':
	      array[l++] = 0x0B;
	      break;
	    case '\\':
	      array[l++] = '\\';
	      break;
	    case '0': case '1': case '2': case '3':
	    case '4': case '5': case '6': case '7':
	      i++;
	      for (temp = 2, c -= '0'; ISOCTAL (seq[i]) && temp--; i++)
	        c = (c * 8) + OCTVALUE (seq[i]);
	      i--;	/* auto-increment in for loop */
	      array[l++] = c & largest_char;
	      break;
	    case 'x':
	      i++;
	      for (temp = 2, c = 0; ISXDIGIT ((unsigned char)seq[i]) && temp--; i++)
	        c = (c * 16) + HEXVALUE (seq[i]);
	      if (temp == 2)
	        c = 'x';
	      i--;	/* auto-increment in for loop */
	      array[l++] = c & largest_char;
	      break;
	    default:	/* backslashes before non-special chars just add the char */
	      array[l++] = c;
	      break;	/* the backslash is stripped */
	    }
	  continue;
	}

      array[l++] = c;
    }

  *len = l;
  array[l] = '\0';
  return (0);
}
warning: parse error {
  register int i, c, l, temp;

  for (i = l = 0; c = seq[i]; i++)
    {
      if (c == '\\')
	{
	  c = seq[++i];

	  if (c == 0)
	    break;

	  /* Handle \C- and \M- prefixes. */
	  if ((c == 'C' || c == 'M') && seq[i + 1] == '-')
	    {
	      /* Handle special case of backwards define. */
	      if (strncmp (&seq[i], "C-\\M-", 5) == 0)
		{
		  array[l++] = ESC;	/* ESC is meta-prefix */
		  i += 5;
		  array[l++] = CTRL (_rl_to_upper (seq[i]));
		  if (seq[i] == '\0')
		    i--;
		}
	      else if (c == 'M')
		{
		  i++;		/* seq[i] == '-' */
		  /* XXX - obey convert-meta setting */
		  if (_rl_convert_meta_chars_to_ascii && _rl_keymap[ESC].type == ISKMAP)
		    array[l++] = ESC;	/* ESC is meta-prefix */
		  else if (seq[i+1] == '\\' && seq[i+2] == 'C' && seq[i+3] == '-')
		    {
		      i += 4;
		      temp = (seq[i] == '?') ? RUBOUT : CTRL (_rl_to_upper (seq[i]));
		      array[l++] = META (temp);
		    }
		  else
		    {
		      /* This doesn't yet handle things like \M-\a, which may
			 or may not have any reasonable meaning.  You're
			 probably better off using straight octal or hex. */
		      i++;
		      array[l++] = META (seq[i]);
		    }
		}
	      else if (c == 'C')
		{
		  i += 2;
		  /* Special hack for C-?... */
		  array[l++] = (seq[i] == '?') ? RUBOUT : CTRL (_rl_to_upper (seq[i]));
		}
	      continue;
	    }	      

	  /* Translate other backslash-escaped characters.  These are the
	     same escape sequences that bash's `echo' and `printf' builtins
	     handle, with the addition of \d -> RUBOUT.  A backslash
	     preceding a character that is not special is stripped. */
	  switch (c)
	    {
	    case 'a':
	      array[l++] = '\007';
	      break;
	    case 'b':
	      array[l++] = '\b';
	      break;
	    case 'd':
	      array[l++] = RUBOUT;	/* readline-specific */
	      break;
	    case 'e':
	      array[l++] = ESC;
	      break;
	    case 'f':
	      array[l++] = '\f';
	      break;
	    case 'n':
	      array[l++] = NEWLINE;
	      break;
	    case 'r':
	      array[l++] = RETURN;
	      break;
	    case 't':
	      array[l++] = TAB;
	      break;
	    case 'v':
	      array[l++] = 0x0B;
	      break;
	    case '\\':
	      array[l++] = '\\';
	      break;
	    case '0': case '1': case '2': case '3':
	    case '4': case '5': case '6': case '7':
	      i++;
	      for (temp = 2, c -= '0'; ISOCTAL (seq[i]) && temp--; i++)
	        c = (c * 8) + OCTVALUE (seq[i]);
	      i--;	/* auto-increment in for loop */
	      array[l++] = c & largest_char;
	      break;
	    case 'x':
	      i++;
	      for (temp = 2, c = 0; ISXDIGIT ((unsigned char)seq[i]) && temp--; i++)
	        c = (c * 16) + HEXVALUE (seq[i]);
	      if (temp == 2)
	        c = 'x';
	      i--;	/* auto-increment in for loop */
	      array[l++] = c & largest_char;
	      break;
	    default:	/* backslashes before non-special chars just add the char */
	      array[l++] = c;
	      break;	/* the backslash is stripped */
	    }
	  continue;
	}

      array[l++] = c;
    }

  *len = l;
  array[l] = '\0';
  return (0);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\bind.c:448
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\bind.c:571
parsing error 
{
  static char kseq[16];
  int i, c;

  i = 0;
  c = seq;
  if (META_CHAR (c))
    {
      kseq[i++] = '\\';
      kseq[i++] = 'M';
      kseq[i++] = '-';
      c = UNMETA (c);
    }
  else if (c == ESC)
    {
      kseq[i++] = '\\';
      c = 'e';
    }
  else if (CTRL_CHAR (c))
    {
      kseq[i++] = '\\';
      kseq[i++] = 'C';
      kseq[i++] = '-';
      c = _rl_to_lower (UNCTRL (c));
    }
  else if (c == RUBOUT)
    {
      kseq[i++] = '\\';
      kseq[i++] = 'C';
      kseq[i++] = '-';
      c = '?';
    }

  if (c == ESC)
    {
      kseq[i++] = '\\';
      c = 'e';
    }
  else if (c == '\\' || c == '"')
    {
      kseq[i++] = '\\';
    }

  kseq[i++] = (unsigned char) c;
  kseq[i] = '\0';
  return kseq;
}
warning: parse error {
  static char kseq[16];
  int i, c;

  i = 0;
  c = seq;
  if (META_CHAR (c))
    {
      kseq[i++] = '\\';
      kseq[i++] = 'M';
      kseq[i++] = '-';
      c = UNMETA (c);
    }
  else if (c == ESC)
    {
      kseq[i++] = '\\';
      c = 'e';
    }
  else if (CTRL_CHAR (c))
    {
      kseq[i++] = '\\';
      kseq[i++] = 'C';
      kseq[i++] = '-';
      c = _rl_to_lower (UNCTRL (c));
    }
  else if (c == RUBOUT)
    {
      kseq[i++] = '\\';
      kseq[i++] = 'C';
      kseq[i++] = '-';
      c = '?';
    }

  if (c == ESC)
    {
      kseq[i++] = '\\';
      c = 'e';
    }
  else if (c == '\\' || c == '"')
    {
      kseq[i++] = '\\';
    }

  kseq[i++] = (unsigned char) c;
  kseq[i] = '\0';
  return kseq;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\bind.c:573
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\bind.c:622
parsing error 
{
  char *ret, *r, *s;
  int c;

  r = ret = (char *)xmalloc (7 * strlen (seq) + 1);
  for (s = seq; *s; s++)
    {
      c = *s;
      if (META_CHAR (c))
	{
	  *r++ = '\\';
	  *r++ = 'M';
	  *r++ = '-';
	  c = UNMETA (c);
	}
      else if (c == ESC)
	{
	  *r++ = '\\';
	  c = 'e';
	}
      else if (CTRL_CHAR (c))
	{
	  *r++ = '\\';
	  *r++ = 'C';
	  *r++ = '-';
	  c = _rl_to_lower (UNCTRL (c));
	}
      else if (c == RUBOUT)
 	{
 	  *r++ = '\\';
 	  *r++ = 'C';
 	  *r++ = '-';
 	  c = '?';
 	}

      if (c == ESC)
	{
	  *r++ = '\\';
	  c = 'e';
	}
      else if (c == '\\' || c == '"')
	*r++ = '\\';

      *r++ = (unsigned char)c;
    }
  *r = '\0';
  return ret;
}
warning: parse error {
  char *ret, *r, *s;
  int c;

  r = ret = (char *)xmalloc (7 * strlen (seq) + 1);
  for (s = seq; *s; s++)
    {
      c = *s;
      if (META_CHAR (c))
	{
	  *r++ = '\\';
	  *r++ = 'M';
	  *r++ = '-';
	  c = UNMETA (c);
	}
      else if (c == ESC)
	{
	  *r++ = '\\';
	  c = 'e';
	}
      else if (CTRL_CHAR (c))
	{
	  *r++ = '\\';
	  *r++ = 'C';
	  *r++ = '-';
	  c = _rl_to_lower (UNCTRL (c));
	}
      else if (c == RUBOUT)
 	{
 	  *r++ = '\\';
 	  *r++ = 'C';
 	  *r++ = '-';
 	  c = '?';
 	}

      if (c == ESC)
	{
	  *r++ = '\\';
	  c = 'e';
	}
      else if (c == '\\' || c == '"')
	*r++ = '\\';

      *r++ = (unsigned char)c;
    }
  *r = '\0';
  return ret;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\bind.c:624
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\bind.c:678
parsing error 
{
  register int i;

  rl_initialize_funmap ();

  for (i = 0; funmap[i]; i++)
    if (_rl_stricmp (funmap[i]->name, string) == 0)
      return (funmap[i]->function);
  return ((rl_command_func_t *)NULL);
}
warning: parse error {
  register int i;

  rl_initialize_funmap ();

  for (i = 0; funmap[i]; i++)
    if (_rl_stricmp (funmap[i]->name, string) == 0)
      return (funmap[i]->function);
  return ((rl_command_func_t *)NULL);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\bind.c:679
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\bind.c:697
parsing error 
{
  register int i;

  if (map == 0)
    map = _rl_keymap;

  for (i = 0; keyseq && keyseq[i]; i++)
    {
      unsigned char ic = keyseq[i];

      if (META_CHAR (ic) && _rl_convert_meta_chars_to_ascii)
	{
	  if (map[ESC].type == ISKMAP)
	    {
	      map = FUNCTION_TO_KEYMAP (map, ESC);
	      ic = UNMETA (ic);
	    }
	  /* XXX - should we just return NULL here, since this obviously
	     doesn't match? */
	  else
	    {
	      if (type)
		*type = map[ESC].type;

	      return (map[ESC].function);
	    }
	}

      if (map[ic].type == ISKMAP)
	{
	  /* If this is the last key in the key sequence, return the
	     map. */
	  if (keyseq[i + 1] == '\0')
	    {
	      if (type)
		*type = ISKMAP;

	      return (map[ic].function);
	    }
	  else
	    map = FUNCTION_TO_KEYMAP (map, ic);
	}
      /* If we're not at the end of the key sequence, and the current key
	 is bound to something other than a keymap, then the entire key
	 sequence is not bound. */
      else if (map[ic].type != ISKMAP && keyseq[i+1])
	return ((rl_command_func_t *)NULL);
      else	/* map[ic].type != ISKMAP && keyseq[i+1] == 0 */
	{
	  if (type)
	    *type = map[ic].type;

	  return (map[ic].function);
	}
    }
  return ((rl_command_func_t *) NULL);
}
warning: parse error {
  register int i;

  if (map == 0)
    map = _rl_keymap;

  for (i = 0; keyseq && keyseq[i]; i++)
    {
      unsigned char ic = keyseq[i];

      if (META_CHAR (ic) && _rl_convert_meta_chars_to_ascii)
	{
	  if (map[ESC].type == ISKMAP)
	    {
	      map = FUNCTION_TO_KEYMAP (map, ESC);
	      ic = UNMETA (ic);
	    }
	  /* XXX - should we just return NULL here, since this obviously
	     doesn't match? */
	  else
	    {
	      if (type)
		*type = map[ESC].type;

	      return (map[ESC].function);
	    }
	}

      if (map[ic].type == ISKMAP)
	{
	  /* If this is the last key in the key sequence, return the
	     map. */
	  if (keyseq[i + 1] == '\0')
	    {
	      if (type)
		*type = ISKMAP;

	      return (map[ic].function);
	    }
	  else
	    map = FUNCTION_TO_KEYMAP (map, ic);
	}
      /* If we're not at the end of the key sequence, and the current key
	 is bound to something other than a keymap, then the entire key
	 sequence is not bound. */
      else if (map[ic].type != ISKMAP && keyseq[i+1])
	return ((rl_command_func_t *)NULL);
      else	/* map[ic].type != ISKMAP && keyseq[i+1] == 0 */
	{
	  if (type)
	    *type = map[ic].type;

	  return (map[ic].function);
	}
    }
  return ((rl_command_func_t *) NULL);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\bind.c:700
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\bind.c:770
parsing error 
{
  struct stat finfo;
  size_t file_size;
  char *buffer;
  int i, file;

  if ((stat (filename, &finfo) < 0) || (file = open (filename, O_RDONLY, 0666)) < 0)
    return ((char *)NULL);

  file_size = (size_t)finfo.st_size;

  /* check for overflow on very large files */
  if (file_size != finfo.st_size || file_size + 1 < file_size)
    {
      if (file >= 0)
	close (file);
#if defined (EFBIG)
      errno = EFBIG;
#endif
      return ((char *)NULL);
    }

  /* Read the file into BUFFER. */
  buffer = (char *)xmalloc (file_size + 1);
  i = read (file, buffer, file_size);
  close (file);

  if (i < 0)
    {
      xfree (buffer);
      return ((char *)NULL);
    }

  RL_CHECK_SIGNALS ();

  buffer[i] = '\0';
  if (sizep)
    *sizep = i;

  return (buffer);
}
warning: parse error {
  struct stat finfo;
  size_t file_size;
  char *buffer;
  int i, file;

  if ((stat (filename, &finfo) < 0) || (file = open (filename, O_RDONLY, 0666)) < 0)
    return ((char *)NULL);

  file_size = (size_t)finfo.st_size;

  /* check for overflow on very large files */
  if (file_size != finfo.st_size || file_size + 1 < file_size)
    {
      if (file >= 0)
	close (file);
#if defined (EFBIG)
      errno = EFBIG;
#endif
      return ((char *)NULL);
    }

  /* Read the file into BUFFER. */
  buffer = (char *)xmalloc (file_size + 1);
  i = read (file, buffer, file_size);
  close (file);

  if (i < 0)
    {
      xfree (buffer);
      return ((char *)NULL);
    }

  RL_CHECK_SIGNALS ();

  buffer[i] = '\0';
  if (sizep)
    *sizep = i;

  return (buffer);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\bind.c:773
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\bind.c:817
parsing error 
{
  int r;
  r = rl_read_init_file ((const char *)NULL);
  rl_set_keymap_from_edit_mode ();
  return r;
}
warning: parse error {
  int r;
  r = rl_read_init_file ((const char *)NULL);
  rl_set_keymap_from_edit_mode ();
  return r;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\bind.c:819
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\bind.c:836
parsing error 
{
  /* Default the filename. */
  if (filename == 0)
    filename = last_readline_init_file;
  if (filename == 0)
    filename = sh_get_env_value ("INPUTRC");
  if (filename == 0 || *filename == 0)
    {
      filename = DEFAULT_INPUTRC;
      /* Try to read DEFAULT_INPUTRC; fall back to SYS_INPUTRC on failure */
      if (_rl_read_init_file (filename, 0) == 0)
	return 0;
      filename = SYS_INPUTRC;
    }

#if defined (__MSDOS__)
  if (_rl_read_init_file (filename, 0) == 0)
    return 0;
  filename = "~/_inputrc";
#endif
  return (_rl_read_init_file (filename, 0));
}
warning: parse error {
  /* Default the filename. */
  if (filename == 0)
    filename = last_readline_init_file;
  if (filename == 0)
    filename = sh_get_env_value ("INPUTRC");
  if (filename == 0 || *filename == 0)
    {
      filename = DEFAULT_INPUTRC;
      /* Try to read DEFAULT_INPUTRC; fall back to SYS_INPUTRC on failure */
      if (_rl_read_init_file (filename, 0) == 0)
	return 0;
      filename = SYS_INPUTRC;
    }

#if defined (__MSDOS__)
  if (_rl_read_init_file (filename, 0) == 0)
    return 0;
  filename = "~/_inputrc";
#endif
  return (_rl_read_init_file (filename, 0));
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\bind.c:837
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\bind.c:862
parsing error 
{
  register int i;
  char *buffer, *openname, *line, *end;
  size_t file_size;

  current_readline_init_file = filename;
  current_readline_init_include_level = include_level;

  openname = tilde_expand (filename);
  buffer = _rl_read_file (openname, &file_size);
  xfree (openname);

  RL_CHECK_SIGNALS ();
  if (buffer == 0)
    return (errno);
  
  if (include_level == 0 && filename != last_readline_init_file)
    {
      FREE (last_readline_init_file);
      last_readline_init_file = savestring (filename);
    }

  currently_reading_init_file = 1;

  /* Loop over the lines in the file.  Lines that start with `#' are
     comments; all other lines are commands for readline initialization. */
  current_readline_init_lineno = 1;
  line = buffer;
  end = buffer + file_size;
  while (line < end)
    {
      /* Find the end of this line. */
      for (i = 0; line + i != end && line[i] != '\n'; i++);

#if defined (__CYGWIN__)
      /* ``Be liberal in what you accept.'' */
      if (line[i] == '\n' && line[i-1] == '\r')
	line[i - 1] = '\0';
#endif

      /* Mark end of line. */
      line[i] = '\0';

      /* Skip leading whitespace. */
      while (*line && whitespace (*line))
        {
	  line++;
	  i--;
        }

      /* If the line is not a comment, then parse it. */
      if (*line && *line != '#')
	rl_parse_and_bind (line);

      /* Move to the next line. */
      line += i + 1;
      current_readline_init_lineno++;
    }

  xfree (buffer);
  currently_reading_init_file = 0;
  return (0);
}
warning: parse error {
  register int i;
  char *buffer, *openname, *line, *end;
  size_t file_size;

  current_readline_init_file = filename;
  current_readline_init_include_level = include_level;

  openname = tilde_expand (filename);
  buffer = _rl_read_file (openname, &file_size);
  xfree (openname);

  RL_CHECK_SIGNALS ();
  if (buffer == 0)
    return (errno);
  
  if (include_level == 0 && filename != last_readline_init_file)
    {
      FREE (last_readline_init_file);
      last_readline_init_file = savestring (filename);
    }

  currently_reading_init_file = 1;

  /* Loop over the lines in the file.  Lines that start with `#' are
     comments; all other lines are commands for readline initialization. */
  current_readline_init_lineno = 1;
  line = buffer;
  end = buffer + file_size;
  while (line < end)
    {
      /* Find the end of this line. */
      for (i = 0; line + i != end && line[i] != '\n'; i++);

#if defined (__CYGWIN__)
      /* ``Be liberal in what you accept.'' */
      if (line[i] == '\n' && line[i-1] == '\r')
	line[i - 1] = '\0';
#endif

      /* Mark end of line. */
      line[i] = '\0';

      /* Skip leading whitespace. */
      while (*line && whitespace (*line))
        {
	  line++;
	  i--;
        }

      /* If the line is not a comment, then parse it. */
      if (*line && *line != '#')
	rl_parse_and_bind (line);

      /* Move to the next line. */
      line += i + 1;
      current_readline_init_lineno++;
    }

  xfree (buffer);
  currently_reading_init_file = 0;
  return (0);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\bind.c:864
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\bind.c:930
parsing error 
{
  if (currently_reading_init_file)
    _rl_errmsg ("%s: line %d: %s\n", current_readline_init_file,
		     current_readline_init_lineno, msg);
  else
    _rl_errmsg ("%s", msg);
}
warning: parse error {
  if (currently_reading_init_file)
    _rl_errmsg ("%s: line %d: %s\n", current_readline_init_file,
		     current_readline_init_lineno, msg);
  else
    _rl_errmsg ("%s", msg);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\bind.c:931
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\bind.c:969
parsing error 
{
  register int i;

  /* Push parser state. */
  if (if_stack_depth + 1 >= if_stack_size)
    {
      if (!if_stack)
	if_stack = (unsigned char *)xmalloc (if_stack_size = 20);
      else
	if_stack = (unsigned char *)xrealloc (if_stack, if_stack_size += 20);
    }
  if_stack[if_stack_depth++] = _rl_parsing_conditionalized_out;

  /* If parsing is turned off, then nothing can turn it back on except
     for finding the matching endif.  In that case, return right now. */
  if (_rl_parsing_conditionalized_out)
    return 0;

  /* Isolate first argument. */
  for (i = 0; args[i] && !whitespace (args[i]); i++);

  if (args[i])
    args[i++] = '\0';

  /* Handle "$if term=foo" and "$if mode=emacs" constructs.  If this
     isn't term=foo, or mode=emacs, then check to see if the first
     word in ARGS is the same as the value stored in rl_readline_name. */
  if (rl_terminal_name && _rl_strnicmp (args, "term=", 5) == 0)
    {
      char *tem, *tname;

      /* Terminals like "aaa-60" are equivalent to "aaa". */
      tname = savestring (rl_terminal_name);
      tem = strchr (tname, '-');
      if (tem)
	*tem = '\0';

      /* Test the `long' and `short' forms of the terminal name so that
	 if someone has a `sun-cmd' and does not want to have bindings
	 that will be executed if the terminal is a `sun', they can put
	 `$if term=sun-cmd' into their .inputrc. */
      _rl_parsing_conditionalized_out = _rl_stricmp (args + 5, tname) &&
					_rl_stricmp (args + 5, rl_terminal_name);
      xfree (tname);
    }
#if defined (VI_MODE)
  else if (_rl_strnicmp (args, "mode=", 5) == 0)
    {
      int mode;

      if (_rl_stricmp (args + 5, "emacs") == 0)
	mode = emacs_mode;
      else if (_rl_stricmp (args + 5, "vi") == 0)
	mode = vi_mode;
      else
	mode = no_mode;

      _rl_parsing_conditionalized_out = mode != rl_editing_mode;
    }
#endif /* VI_MODE */
  /* Check to see if the first word in ARGS is the same as the
     value stored in rl_readline_name. */
  else if (_rl_stricmp (args, rl_readline_name) == 0)
    _rl_parsing_conditionalized_out = 0;
  else
    _rl_parsing_conditionalized_out = 1;
  return 0;
}
warning: parse error {
  register int i;

  /* Push parser state. */
  if (if_stack_depth + 1 >= if_stack_size)
    {
      if (!if_stack)
	if_stack = (unsigned char *)xmalloc (if_stack_size = 20);
      else
	if_stack = (unsigned char *)xrealloc (if_stack, if_stack_size += 20);
    }
  if_stack[if_stack_depth++] = _rl_parsing_conditionalized_out;

  /* If parsing is turned off, then nothing can turn it back on except
     for finding the matching endif.  In that case, return right now. */
  if (_rl_parsing_conditionalized_out)
    return 0;

  /* Isolate first argument. */
  for (i = 0; args[i] && !whitespace (args[i]); i++);

  if (args[i])
    args[i++] = '\0';

  /* Handle "$if term=foo" and "$if mode=emacs" constructs.  If this
     isn't term=foo, or mode=emacs, then check to see if the first
     word in ARGS is the same as the value stored in rl_readline_name. */
  if (rl_terminal_name && _rl_strnicmp (args, "term=", 5) == 0)
    {
      char *tem, *tname;

      /* Terminals like "aaa-60" are equivalent to "aaa". */
      tname = savestring (rl_terminal_name);
      tem = strchr (tname, '-');
      if (tem)
	*tem = '\0';

      /* Test the `long' and `short' forms of the terminal name so that
	 if someone has a `sun-cmd' and does not want to have bindings
	 that will be executed if the terminal is a `sun', they can put
	 `$if term=sun-cmd' into their .inputrc. */
      _rl_parsing_conditionalized_out = _rl_stricmp (args + 5, tname) &&
					_rl_stricmp (args + 5, rl_terminal_name);
      xfree (tname);
    }
#if defined (VI_MODE)
  else if (_rl_strnicmp (args, "mode=", 5) == 0)
    {
      int mode;

      if (_rl_stricmp (args + 5, "emacs") == 0)
	mode = emacs_mode;
      else if (_rl_stricmp (args + 5, "vi") == 0)
	mode = vi_mode;
      else
	mode = no_mode;

      _rl_parsing_conditionalized_out = mode != rl_editing_mode;
    }
#endif /* VI_MODE */
  /* Check to see if the first word in ARGS is the same as the
     value stored in rl_readline_name. */
  else if (_rl_stricmp (args, rl_readline_name) == 0)
    _rl_parsing_conditionalized_out = 0;
  else
    _rl_parsing_conditionalized_out = 1;
  return 0;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\bind.c:971
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\bind.c:1,042
parsing error 
{
  register int i;

  if (if_stack_depth == 0)
    {
      _rl_init_file_error ("$else found without matching $if");
      return 0;
    }

#if 0
  /* Check the previous (n - 1) levels of the stack to make sure that
     we haven't previously turned off parsing. */
  for (i = 0; i < if_stack_depth - 1; i++)
#else
  /* Check the previous (n) levels of the stack to make sure that
     we haven't previously turned off parsing. */
  for (i = 0; i < if_stack_depth; i++)
#endif
    if (if_stack[i] == 1)
      return 0;

  /* Invert the state of parsing if at top level. */
  _rl_parsing_conditionalized_out = !_rl_parsing_conditionalized_out;
  return 0;
}
warning: parse error {
  register int i;

  if (if_stack_depth == 0)
    {
      _rl_init_file_error ("$else found without matching $if");
      return 0;
    }

#if 0
  /* Check the previous (n - 1) levels of the stack to make sure that
     we haven't previously turned off parsing. */
  for (i = 0; i < if_stack_depth - 1; i++)
#else
  /* Check the previous (n) levels of the stack to make sure that
     we haven't previously turned off parsing. */
  for (i = 0; i < if_stack_depth; i++)
#endif
    if (if_stack[i] == 1)
      return 0;

  /* Invert the state of parsing if at top level. */
  _rl_parsing_conditionalized_out = !_rl_parsing_conditionalized_out;
  return 0;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\bind.c:1,044
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\bind.c:1,073
parsing error 
{
  if (if_stack_depth)
    _rl_parsing_conditionalized_out = if_stack[--if_stack_depth];
  else
    _rl_init_file_error ("$endif without matching $if");
  return 0;
}
warning: parse error {
  if (if_stack_depth)
    _rl_parsing_conditionalized_out = if_stack[--if_stack_depth];
  else
    _rl_init_file_error ("$endif without matching $if");
  return 0;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\bind.c:1,075
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\bind.c:1,084
parsing error 
{
  const char *old_init_file;
  char *e;
  int old_line_number, old_include_level, r;

  if (_rl_parsing_conditionalized_out)
    return (0);

  old_init_file = current_readline_init_file;
  old_line_number = current_readline_init_lineno;
  old_include_level = current_readline_init_include_level;

  e = strchr (args, '\n');
  if (e)
    *e = '\0';
  r = _rl_read_init_file ((const char *)args, old_include_level + 1);

  current_readline_init_file = old_init_file;
  current_readline_init_lineno = old_line_number;
  current_readline_init_include_level = old_include_level;

  return r;
}
warning: parse error {
  const char *old_init_file;
  char *e;
  int old_line_number, old_include_level, r;

  if (_rl_parsing_conditionalized_out)
    return (0);

  old_init_file = current_readline_init_file;
  old_line_number = current_readline_init_lineno;
  old_include_level = current_readline_init_include_level;

  e = strchr (args, '\n');
  if (e)
    *e = '\0';
  r = _rl_read_init_file ((const char *)args, old_include_level + 1);

  current_readline_init_file = old_init_file;
  current_readline_init_lineno = old_line_number;
  current_readline_init_include_level = old_include_level;

  return r;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\bind.c:1,086
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\bind.c:1,125
parsing error 
{
  register int i;
  char *directive, *args;

  /* Isolate the actual directive. */

  /* Skip whitespace. */
  for (i = 0; whitespace (statement[i]); i++);

  directive = &statement[i];

  for (; statement[i] && !whitespace (statement[i]); i++);

  if (statement[i])
    statement[i++] = '\0';

  for (; statement[i] && whitespace (statement[i]); i++);

  args = &statement[i];

  /* Lookup the command, and act on it. */
  for (i = 0; parser_directives[i].name; i++)
    if (_rl_stricmp (directive, parser_directives[i].name) == 0)
      {
	(*parser_directives[i].function) (args);
	return (0);
      }

  /* display an error message about the unknown parser directive */
  _rl_init_file_error ("unknown parser directive");
  return (1);
}
warning: parse error {
  register int i;
  char *directive, *args;

  /* Isolate the actual directive. */

  /* Skip whitespace. */
  for (i = 0; whitespace (statement[i]); i++);

  directive = &statement[i];

  for (; statement[i] && !whitespace (statement[i]); i++);

  if (statement[i])
    statement[i++] = '\0';

  for (; statement[i] && whitespace (statement[i]); i++);

  args = &statement[i];

  /* Lookup the command, and act on it. */
  for (i = 0; parser_directives[i].name; i++)
    if (_rl_stricmp (directive, parser_directives[i].name) == 0)
      {
	(*parser_directives[i].function) (args);
	return (0);
      }

  /* display an error message about the unknown parser directive */
  _rl_init_file_error ("unknown parser directive");
  return (1);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\bind.c:1,127
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\bind.c:1,165
parsing error 
{
  char *funname, *kname;
  register int c, i;
  int key, equivalency;

  while (string && whitespace (*string))
    string++;

  if (!string || !*string || *string == '#')
    return 0;

  /* If this is a parser directive, act on it. */
  if (*string == '$')
    {
      handle_parser_directive (&string[1]);
      return 0;
    }

  /* If we aren't supposed to be parsing right now, then we're done. */
  if (_rl_parsing_conditionalized_out)
    return 0;

  i = 0;
  /* If this keyname is a complex key expression surrounded by quotes,
     advance to after the matching close quote.  This code allows the
     backslash to quote characters in the key expression. */
  if (*string == '"')
    {
      int passc = 0;

      for (i = 1; c = string[i]; i++)
	{
	  if (passc)
	    {
	      passc = 0;
	      continue;
	    }

	  if (c == '\\')
	    {
	      passc++;
	      continue;
	    }

	  if (c == '"')
	    break;
	}
      /* If we didn't find a closing quote, abort the line. */
      if (string[i] == '\0')
        {
          _rl_init_file_error ("no closing `\"' in key binding");
          return 1;
        }
    }

  /* Advance to the colon (:) or whitespace which separates the two objects. */
  for (; (c = string[i]) && c != ':' && c != ' ' && c != '\t'; i++ );

  equivalency = (c == ':' && string[i + 1] == '=');

  /* Mark the end of the command (or keyname). */
  if (string[i])
    string[i++] = '\0';

  /* If doing assignment, skip the '=' sign as well. */
  if (equivalency)
    string[i++] = '\0';

  /* If this is a command to set a variable, then do that. */
  if (_rl_stricmp (string, "set") == 0)
    {
      char *var, *value, *e;

      var = string + i;
      /* Make VAR point to start of variable name. */
      while (*var && whitespace (*var)) var++;

      /* Make VALUE point to start of value string. */
      value = var;
      while (*value && !whitespace (*value)) value++;
      if (*value)
	*value++ = '\0';
      while (*value && whitespace (*value)) value++;

      /* Strip trailing whitespace from values to boolean variables.  Temp
	 fix until I get a real quoted-string parser here. */
      i = find_boolean_var (var);
      if (i >= 0)
	{
	  /* remove trailing whitespace */
	  e = value + strlen (value) - 1;
	  while (e >= value && whitespace (*e))
	    e--;
	  e++;		/* skip back to whitespace or EOS */
	  if (*e && e >= value)
	    *e = '\0';
	}

      rl_variable_bind (var, value);
      return 0;
    }

  /* Skip any whitespace between keyname and funname. */
  for (; string[i] && whitespace (string[i]); i++);
  funname = &string[i];

  /* Now isolate funname.
     For straight function names just look for whitespace, since
     that will signify the end of the string.  But this could be a
     macro definition.  In that case, the string is quoted, so skip
     to the matching delimiter.  We allow the backslash to quote the
     delimiter characters in the macro body. */
  /* This code exists to allow whitespace in macro expansions, which
     would otherwise be gobbled up by the next `for' loop.*/
  /* XXX - it may be desirable to allow backslash quoting only if " is
     the quoted string delimiter, like the shell. */
  if (*funname == '\'' || *funname == '"')
    {
      int delimiter, passc;

      delimiter = string[i++];
      for (passc = 0; c = string[i]; i++)
	{
	  if (passc)
	    {
	      passc = 0;
	      continue;
	    }

	  if (c == '\\')
	    {
	      passc = 1;
	      continue;
	    }

	  if (c == delimiter)
	    break;
	}
      if (c)
	i++;
    }

  /* Advance to the end of the string.  */
  for (; string[i] && !whitespace (string[i]); i++);

  /* No extra whitespace at the end of the string. */
  string[i] = '\0';

  /* Handle equivalency bindings here.  Make the left-hand side be exactly
     whatever the right-hand evaluates to, including keymaps. */
  if (equivalency)
    {
      return 0;
    }

  /* If this is a new-style key-binding, then do the binding with
     rl_bind_keyseq ().  Otherwise, let the older code deal with it. */
  if (*string == '"')
    {
      char *seq;
      register int j, k, passc;

      seq = (char *)xmalloc (1 + strlen (string));
      for (j = 1, k = passc = 0; string[j]; j++)
	{
	  /* Allow backslash to quote characters, but leave them in place.
	     This allows a string to end with a backslash quoting another
	     backslash, or with a backslash quoting a double quote.  The
	     backslashes are left in place for rl_translate_keyseq (). */
	  if (passc || (string[j] == '\\'))
	    {
	      seq[k++] = string[j];
	      passc = !passc;
	      continue;
	    }

	  if (string[j] == '"')
	    break;

	  seq[k++] = string[j];
	}
      seq[k] = '\0';

      /* Binding macro? */
      if (*funname == '\'' || *funname == '"')
	{
	  j = strlen (funname);

	  /* Remove the delimiting quotes from each end of FUNNAME. */
	  if (j && funname[j - 1] == *funname)
	    funname[j - 1] = '\0';

	  rl_macro_bind (seq, &funname[1], _rl_keymap);
	}
      else
	rl_bind_keyseq (seq, rl_named_function (funname));

      xfree (seq);
      return 0;
    }

  /* Get the actual character we want to deal with. */
  kname = strrchr (string, '-');
  if (!kname)
    kname = string;
  else
    kname++;

  key = glean_key_from_name (kname);

  /* Add in control and meta bits. */
  if (substring_member_of_array (string, _rl_possible_control_prefixes))
    key = CTRL (_rl_to_upper (key));

  if (substring_member_of_array (string, _rl_possible_meta_prefixes))
    key = META (key);

  /* Temporary.  Handle old-style keyname with macro-binding. */
  if (*funname == '\'' || *funname == '"')
    {
      char useq[2];
      int fl = strlen (funname);

      useq[0] = key; useq[1] = '\0';
      if (fl && funname[fl - 1] == *funname)
	funname[fl - 1] = '\0';

      rl_macro_bind (useq, &funname[1], _rl_keymap);
    }
#if defined (PREFIX_META_HACK)
  /* Ugly, but working hack to keep prefix-meta around. */
  else if (_rl_stricmp (funname, "prefix-meta") == 0)
    {
      char seq[2];

      seq[0] = key;
      seq[1] = '\0';
      rl_generic_bind (ISKMAP, seq, (char *)emacs_meta_keymap, _rl_keymap);
    }
#endif /* PREFIX_META_HACK */
  else
    rl_bind_key (key, rl_named_function (funname));
  return 0;
}
warning: parse error {
  char *funname, *kname;
  register int c, i;
  int key, equivalency;

  while (string && whitespace (*string))
    string++;

  if (!string || !*string || *string == '#')
    return 0;

  /* If this is a parser directive, act on it. */
  if (*string == '$')
    {
      handle_parser_directive (&string[1]);
      return 0;
    }

  /* If we aren't supposed to be parsing right now, then we're done. */
  if (_rl_parsing_conditionalized_out)
    return 0;

  i = 0;
  /* If this keyname is a complex key expression surrounded by quotes,
     advance to after the matching close quote.  This code allows the
     backslash to quote characters in the key expression. */
  if (*string == '"')
    {
      int passc = 0;

      for (i = 1; c = string[i]; i++)
	{
	  if (passc)
	    {
	      passc = 0;
	      continue;
	    }

	  if (c == '\\')
	    {
	      passc++;
	      continue;
	    }

	  if (c == '"')
	    break;
	}
      /* If we didn't find a closing quote, abort the line. */
      if (string[i] == '\0')
        {
          _rl_init_file_error ("no closing `\"' in key binding");
          return 1;
        }
    }

  /* Advance to the colon (:) or whitespace which separates the two objects. */
  for (; (c = string[i]) && c != ':' && c != ' ' && c != '\t'; i++ );

  equivalency = (c == ':' && string[i + 1] == '=');

  /* Mark the end of the command (or keyname). */
  if (string[i])
    string[i++] = '\0';

  /* If doing assignment, skip the '=' sign as well. */
  if (equivalency)
    string[i++] = '\0';

  /* If this is a command to set a variable, then do that. */
  if (_rl_stricmp (string, "set") == 0)
    {
      char *var, *value, *e;

      var = string + i;
      /* Make VAR point to start of variable name. */
      while (*var && whitespace (*var)) var++;

      /* Make VALUE point to start of value string. */
      value = var;
      while (*value && !whitespace (*value)) value++;
      if (*value)
	*value++ = '\0';
      while (*value && whitespace (*value)) value++;

      /* Strip trailing whitespace from values to boolean variables.  Temp
	 fix until I get a real quoted-string parser here. */
      i = find_boolean_var (var);
      if (i >= 0)
	{
	  /* remove trailing whitespace */
	  e = value + strlen (value) - 1;
	  while (e >= value && whitespace (*e))
	    e--;
	  e++;		/* skip back to whitespace or EOS */
	  if (*e && e >= value)
	    *e = '\0';
	}

      rl_variable_bind (var, value);
      return 0;
    }

  /* Skip any whitespace between keyname and funname. */
  for (; string[i] && whitespace (string[i]); i++);
  funname = &string[i];

  /* Now isolate funname.
     For straight function names just look for whitespace, since
     that will signify the end of the string.  But this could be a
     macro definition.  In that case, the string is quoted, so skip
     to the matching delimiter.  We allow the backslash to quote the
     delimiter characters in the macro body. */
  /* This code exists to allow whitespace in macro expansions, which
     would otherwise be gobbled up by the next `for' loop.*/
  /* XXX - it may be desirable to allow backslash quoting only if " is
     the quoted string delimiter, like the shell. */
  if (*funname == '\'' || *funname == '"')
    {
      int delimiter, passc;

      delimiter = string[i++];
      for (passc = 0; c = string[i]; i++)
	{
	  if (passc)
	    {
	      passc = 0;
	      continue;
	    }

	  if (c == '\\')
	    {
	      passc = 1;
	      continue;
	    }

	  if (c == delimiter)
	    break;
	}
      if (c)
	i++;
    }

  /* Advance to the end of the string.  */
  for (; string[i] && !whitespace (string[i]); i++);

  /* No extra whitespace at the end of the string. */
  string[i] = '\0';

  /* Handle equivalency bindings here.  Make the left-hand side be exactly
     whatever the right-hand evaluates to, including keymaps. */
  if (equivalency)
    {
      return 0;
    }

  /* If this is a new-style key-binding, then do the binding with
     rl_bind_keyseq ().  Otherwise, let the older code deal with it. */
  if (*string == '"')
    {
      char *seq;
      register int j, k, passc;

      seq = (char *)xmalloc (1 + strlen (string));
      for (j = 1, k = passc = 0; string[j]; j++)
	{
	  /* Allow backslash to quote characters, but leave them in place.
	     This allows a string to end with a backslash quoting another
	     backslash, or with a backslash quoting a double quote.  The
	     backslashes are left in place for rl_translate_keyseq (). */
	  if (passc || (string[j] == '\\'))
	    {
	      seq[k++] = string[j];
	      passc = !passc;
	      continue;
	    }

	  if (string[j] == '"')
	    break;

	  seq[k++] = string[j];
	}
      seq[k] = '\0';

      /* Binding macro? */
      if (*funname == '\'' || *funname == '"')
	{
	  j = strlen (funname);

	  /* Remove the delimiting quotes from each end of FUNNAME. */
	  if (j && funname[j - 1] == *funname)
	    funname[j - 1] = '\0';

	  rl_macro_bind (seq, &funname[1], _rl_keymap);
	}
      else
	rl_bind_keyseq (seq, rl_named_function (funname));

      xfree (seq);
      return 0;
    }

  /* Get the actual character we want to deal with. */
  kname = strrchr (string, '-');
  if (!kname)
    kname = string;
  else
    kname++;

  key = glean_key_from_name (kname);

  /* Add in control and meta bits. */
  if (substring_member_of_array (string, _rl_possible_control_prefixes))
    key = CTRL (_rl_to_upper (key));

  if (substring_member_of_array (string, _rl_possible_meta_prefixes))
    key = META (key);

  /* Temporary.  Handle old-style keyname with macro-binding. */
  if (*funname == '\'' || *funname == '"')
    {
      char useq[2];
      int fl = strlen (funname);

      useq[0] = key; useq[1] = '\0';
      if (fl && funname[fl - 1] == *funname)
	funname[fl - 1] = '\0';

      rl_macro_bind (useq, &funname[1], _rl_keymap);
    }
#if defined (PREFIX_META_HACK)
  /* Ugly, but working hack to keep prefix-meta around. */
  else if (_rl_stricmp (funname, "prefix-meta") == 0)
    {
      char seq[2];

      seq[0] = key;
      seq[1] = '\0';
      rl_generic_bind (ISKMAP, seq, (char *)emacs_meta_keymap, _rl_keymap);
    }
#endif /* PREFIX_META_HACK */
  else
    rl_bind_key (key, rl_named_function (funname));
  return 0;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\bind.c:1,167
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\bind.c:1,459
parsing error 
{
  register int i;

  for (i = 0; boolean_varlist[i].name; i++)
    if (_rl_stricmp (name, boolean_varlist[i].name) == 0)
      return i;
  return -1;
}
warning: parse error {
  register int i;

  for (i = 0; boolean_varlist[i].name; i++)
    if (_rl_stricmp (name, boolean_varlist[i].name) == 0)
      return i;
  return -1;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\bind.c:1,460
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\bind.c:1,473
parsing error 
{
  const char *name;

  name = boolean_varlist[i].name;

  if (_rl_stricmp (name, "blink-matching-paren") == 0)
    _rl_enable_paren_matching (rl_blink_matching_paren);
  else if (_rl_stricmp (name, "prefer-visible-bell") == 0)
    {
      if (_rl_prefer_visible_bell)
	_rl_bell_preference = VISIBLE_BELL;
      else
	_rl_bell_preference = AUDIBLE_BELL;
    }
}
warning: parse error {
  const char *name;

  name = boolean_varlist[i].name;

  if (_rl_stricmp (name, "blink-matching-paren") == 0)
    _rl_enable_paren_matching (rl_blink_matching_paren);
  else if (_rl_stricmp (name, "prefer-visible-bell") == 0)
    {
      if (_rl_prefer_visible_bell)
	_rl_bell_preference = VISIBLE_BELL;
      else
	_rl_bell_preference = AUDIBLE_BELL;
    }
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\bind.c:1,475
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\bind.c:1,534
parsing error 
{
  register int i;

  for (i = 0; string_varlist[i].name; i++)
    if (_rl_stricmp (name, string_varlist[i].name) == 0)
      return i;
  return -1;
}
warning: parse error {
  register int i;

  for (i = 0; string_varlist[i].name; i++)
    if (_rl_stricmp (name, string_varlist[i].name) == 0)
      return i;
  return -1;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\bind.c:1,535
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\bind.c:1,549
parsing error 
{
  return (value == 0 || *value == '\0' ||
		(_rl_stricmp (value, "on") == 0) ||
		(value[0] == '1' && value[1] == '\0'));
}
warning: parse error {
  return (value == 0 || *value == '\0' ||
		(_rl_stricmp (value, "on") == 0) ||
		(value[0] == '1' && value[1] == '\0'));
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\bind.c:1,550
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\bind.c:1,558
parsing error 
{
  register int i;

  /* Check for simple variables first. */
  i = find_boolean_var (name);
  if (i >= 0)
    return (*boolean_varlist[i].value ? "on" : "off");

  i = find_string_var (name);
  if (i >= 0)
    return (_rl_get_string_variable_value (string_varlist[i].name));

  /* Unknown variable names return NULL. */
  return 0;
}
warning: parse error {
  register int i;

  /* Check for simple variables first. */
  i = find_boolean_var (name);
  if (i >= 0)
    return (*boolean_varlist[i].value ? "on" : "off");

  i = find_string_var (name);
  if (i >= 0)
    return (_rl_get_string_variable_value (string_varlist[i].name));

  /* Unknown variable names return NULL. */
  return 0;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\bind.c:1,559
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\bind.c:1,577
parsing error 
{
  register int i;
  int	v;

  /* Check for simple variables first. */
  i = find_boolean_var (name);
  if (i >= 0)
    {
      *boolean_varlist[i].value = bool_to_int (value);
      if (boolean_varlist[i].flags & V_SPECIAL)
	hack_special_boolean_var (i);
      return 0;
    }

  i = find_string_var (name);

  /* For the time being, unknown variable names or string names without a
     handler function are simply ignored. */
  if (i < 0 || string_varlist[i].set_func == 0)
    return 0;

  v = (*string_varlist[i].set_func) (value);
  return v;
}
warning: parse error {
  register int i;
  int	v;

  /* Check for simple variables first. */
  i = find_boolean_var (name);
  if (i >= 0)
    {
      *boolean_varlist[i].value = bool_to_int (value);
      if (boolean_varlist[i].flags & V_SPECIAL)
	hack_special_boolean_var (i);
      return 0;
    }

  i = find_string_var (name);

  /* For the time being, unknown variable names or string names without a
     handler function are simply ignored. */
  if (i < 0 || string_varlist[i].set_func == 0)
    return 0;

  v = (*string_varlist[i].set_func) (value);
  return v;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\bind.c:1,578
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\bind.c:1,605
parsing error 
{
  if (_rl_strnicmp (value, "vi", 2) == 0)
    {
#if defined (VI_MODE)
      _rl_keymap = vi_insertion_keymap;
      rl_editing_mode = vi_mode;
#endif /* VI_MODE */
      return 0;
    }
  else if (_rl_strnicmp (value, "emacs", 5) == 0)
    {
      _rl_keymap = emacs_standard_keymap;
      rl_editing_mode = emacs_mode;
      return 0;
    }
  return 1;
}
warning: parse error {
  if (_rl_strnicmp (value, "vi", 2) == 0)
    {
#if defined (VI_MODE)
      _rl_keymap = vi_insertion_keymap;
      rl_editing_mode = vi_mode;
#endif /* VI_MODE */
      return 0;
    }
  else if (_rl_strnicmp (value, "emacs", 5) == 0)
    {
      _rl_keymap = emacs_standard_keymap;
      rl_editing_mode = emacs_mode;
      return 0;
    }
  return 1;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\bind.c:1,606
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\bind.c:1,626
parsing error 
{
  if (value && *value)
    {
      FREE (_rl_comment_begin);
      _rl_comment_begin = savestring (value);
      return 0;
    }
  return 1;
}
warning: parse error {
  if (value && *value)
    {
      FREE (_rl_comment_begin);
      _rl_comment_begin = savestring (value);
      return 0;
    }
  return 1;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\bind.c:1,627
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\bind.c:1,639
parsing error 
{
  int nval = 0;

  if (value && *value)
    {
      nval = atoi (value);
      if (nval < 0)
	nval = 0;
    }
  _rl_completion_prefix_display_length = nval;
  return 0;
}
warning: parse error {
  int nval = 0;

  if (value && *value)
    {
      nval = atoi (value);
      if (nval < 0)
	nval = 0;
    }
  _rl_completion_prefix_display_length = nval;
  return 0;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\bind.c:1,640
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\bind.c:1,655
parsing error 
{
  int nval = 100;

  if (value && *value)
    {
      nval = atoi (value);
      if (nval < 0)
	nval = 0;
    }
  rl_completion_query_items = nval;
  return 0;
}
warning: parse error {
  int nval = 100;

  if (value && *value)
    {
      nval = atoi (value);
      if (nval < 0)
	nval = 0;
    }
  rl_completion_query_items = nval;
  return 0;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\bind.c:1,656
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\bind.c:1,671
parsing error 
{
  int nval = -1;

  if (value && *value)
    nval = atoi (value);

  _rl_completion_columns = nval;
  return 0;
}
warning: parse error {
  int nval = -1;

  if (value && *value)
    nval = atoi (value);

  _rl_completion_columns = nval;
  return 0;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\bind.c:1,672
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\bind.c:1,684
parsing error 
{
  int nval = 500;

  if (value && *value)
    {
      nval = atoi (value);
      if (nval < 0)
	return 1;
    }
  stifle_history (nval);
  return 0;
}
warning: parse error {
  int nval = 500;

  if (value && *value)
    {
      nval = atoi (value);
      if (nval < 0)
	return 1;
    }
  stifle_history (nval);
  return 0;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\bind.c:1,685
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\bind.c:1,700
parsing error 
{
  Keymap kmap;

  kmap = rl_get_keymap_by_name (value);
  if (kmap)
    {
      rl_set_keymap (kmap);
      return 0;
    }
  return 1;
}
warning: parse error {
  Keymap kmap;

  kmap = rl_get_keymap_by_name (value);
  if (kmap)
    {
      rl_set_keymap (kmap);
      return 0;
    }
  return 1;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\bind.c:1,701
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\bind.c:1,715
parsing error 
{
  if (value == 0 || *value == '\0')
    _rl_bell_preference = AUDIBLE_BELL;
  else if (_rl_stricmp (value, "none") == 0 || _rl_stricmp (value, "off") == 0)
    _rl_bell_preference = NO_BELL;
  else if (_rl_stricmp (value, "audible") == 0 || _rl_stricmp (value, "on") == 0)
    _rl_bell_preference = AUDIBLE_BELL;
  else if (_rl_stricmp (value, "visible") == 0)
    _rl_bell_preference = VISIBLE_BELL;
  else
    return 1;
  return 0;
}
warning: parse error {
  if (value == 0 || *value == '\0')
    _rl_bell_preference = AUDIBLE_BELL;
  else if (_rl_stricmp (value, "none") == 0 || _rl_stricmp (value, "off") == 0)
    _rl_bell_preference = NO_BELL;
  else if (_rl_stricmp (value, "audible") == 0 || _rl_stricmp (value, "on") == 0)
    _rl_bell_preference = AUDIBLE_BELL;
  else if (_rl_stricmp (value, "visible") == 0)
    _rl_bell_preference = VISIBLE_BELL;
  else
    return 1;
  return 0;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\bind.c:1,716
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\bind.c:1,732
parsing error 
{
  int beg, end, delim;
  char *v;

  if (value == 0)
    return 1;

  /* Isolate the value and translate it into a character string. */
  v = savestring (value);
  FREE (_rl_isearch_terminators);
  if (v[0] == '"' || v[0] == '\'')
    {
      delim = v[0];
      for (beg = end = 1; v[end] && v[end] != delim; end++)
	;
    }
  else
    {
      for (beg = end = 0; whitespace (v[end]) == 0; end++)
	;
    }

  v[end] = '\0';

  /* The value starts at v + beg.  Translate it into a character string. */
  _rl_isearch_terminators = (char *)xmalloc (2 * strlen (v) + 1);
  rl_translate_keyseq (v + beg, _rl_isearch_terminators, &end);
  _rl_isearch_terminators[end] = '\0';

  xfree (v);
  return 0;
}
warning: parse error {
  int beg, end, delim;
  char *v;

  if (value == 0)
    return 1;

  /* Isolate the value and translate it into a character string. */
  v = savestring (value);
  FREE (_rl_isearch_terminators);
  if (v[0] == '"' || v[0] == '\'')
    {
      delim = v[0];
      for (beg = end = 1; v[end] && v[end] != delim; end++)
	;
    }
  else
    {
      for (beg = end = 0; whitespace (v[end]) == 0; end++)
	;
    }

  v[end] = '\0';

  /* The value starts at v + beg.  Translate it into a character string. */
  _rl_isearch_terminators = (char *)xmalloc (2 * strlen (v) + 1);
  rl_translate_keyseq (v + beg, _rl_isearch_terminators, &end);
  _rl_isearch_terminators[end] = '\0';

  xfree (v);
  return 0;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\bind.c:1,733
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\bind.c:1,790
parsing error 
{
  register int i;

  for (i = 0; name_key_alist[i].name; i++)
    if (_rl_stricmp (name, name_key_alist[i].name) == 0)
      return (name_key_alist[i].value);

  return (*(unsigned char *)name);	/* XXX was return (*name) */
}
warning: parse error {
  register int i;

  for (i = 0; name_key_alist[i].name; i++)
    if (_rl_stricmp (name, name_key_alist[i].name) == 0)
      return (name_key_alist[i].value);

  return (*(unsigned char *)name);	/* XXX was return (*name) */
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\bind.c:1,792
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\bind.c:1,822
parsing error 
{
  register int i;

  for (i = 0; keymap_names[i].name; i++)
    if (_rl_stricmp (name, keymap_names[i].name) == 0)
      return (keymap_names[i].map);
  return ((Keymap) NULL);
}
warning: parse error {
  register int i;

  for (i = 0; keymap_names[i].name; i++)
    if (_rl_stricmp (name, keymap_names[i].name) == 0)
      return (keymap_names[i].map);
  return ((Keymap) NULL);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\bind.c:1,823
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\bind.c:1,833
parsing error 
{
  register int i;
  for (i = 0; keymap_names[i].name; i++)
    if (map == keymap_names[i].map)
      return ((char *)keymap_names[i].name);
  return ((char *)NULL);
}
warning: parse error {
  register int i;
  for (i = 0; keymap_names[i].name; i++)
    if (map == keymap_names[i].map)
      return ((char *)keymap_names[i].name);
  return ((char *)NULL);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\bind.c:1,835
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\bind.c:1,844
parsing error 
{
  if (map)
    _rl_keymap = map;
}
warning: parse error {
  if (map)
    _rl_keymap = map;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\bind.c:1,846
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\bind.c:1,911
parsing error 
{
  char *keyname;
  int i, c;

  keyname = (char *)xmalloc (8);

  c = key;
  /* Since this is going to be used to write out keysequence-function
     pairs for possible inclusion in an inputrc file, we don't want to
     do any special meta processing on KEY. */

#if 1
  /* XXX - Experimental */
  /* We might want to do this, but the old version of the code did not. */

  /* If this is an escape character, we don't want to do any more processing.
     Just add the special ESC key sequence and return. */
  if (c == ESC)
    {
      keyname[0] = '\\';
      keyname[1] = 'e';
      keyname[2] = '\0';
      return keyname;
    }
#endif

  /* RUBOUT is translated directly into \C-? */
  if (key == RUBOUT)
    {
      keyname[0] = '\\';
      keyname[1] = 'C';
      keyname[2] = '-';
      keyname[3] = '?';
      keyname[4] = '\0';
      return keyname;
    }

  i = 0;
  /* Now add special prefixes needed for control characters.  This can
     potentially change C. */
  if (CTRL_CHAR (c))
    {
      keyname[i++] = '\\';
      keyname[i++] = 'C';
      keyname[i++] = '-';
      c = _rl_to_lower (UNCTRL (c));
    }

  /* XXX experimental code.  Turn the characters that are not ASCII or
     ISO Latin 1 (128 - 159) into octal escape sequences (\200 - \237).
     This changes C. */
  if (c >= 128 && c <= 159)
    {
      keyname[i++] = '\\';
      keyname[i++] = '2';
      c -= 128;
      keyname[i++] = (c / 8) + '0';
      c = (c % 8) + '0';
    }

  /* Now, if the character needs to be quoted with a backslash, do that. */
  if (c == '\\' || c == '"')
    keyname[i++] = '\\';

  /* Now add the key, terminate the string, and return it. */
  keyname[i++] = (char) c;
  keyname[i] = '\0';

  return keyname;
}
warning: parse error {
  char *keyname;
  int i, c;

  keyname = (char *)xmalloc (8);

  c = key;
  /* Since this is going to be used to write out keysequence-function
     pairs for possible inclusion in an inputrc file, we don't want to
     do any special meta processing on KEY. */

#if 1
  /* XXX - Experimental */
  /* We might want to do this, but the old version of the code did not. */

  /* If this is an escape character, we don't want to do any more processing.
     Just add the special ESC key sequence and return. */
  if (c == ESC)
    {
      keyname[0] = '\\';
      keyname[1] = 'e';
      keyname[2] = '\0';
      return keyname;
    }
#endif

  /* RUBOUT is translated directly into \C-? */
  if (key == RUBOUT)
    {
      keyname[0] = '\\';
      keyname[1] = 'C';
      keyname[2] = '-';
      keyname[3] = '?';
      keyname[4] = '\0';
      return keyname;
    }

  i = 0;
  /* Now add special prefixes needed for control characters.  This can
     potentially change C. */
  if (CTRL_CHAR (c))
    {
      keyname[i++] = '\\';
      keyname[i++] = 'C';
      keyname[i++] = '-';
      c = _rl_to_lower (UNCTRL (c));
    }

  /* XXX experimental code.  Turn the characters that are not ASCII or
     ISO Latin 1 (128 - 159) into octal escape sequences (\200 - \237).
     This changes C. */
  if (c >= 128 && c <= 159)
    {
      keyname[i++] = '\\';
      keyname[i++] = '2';
      c -= 128;
      keyname[i++] = (c / 8) + '0';
      c = (c % 8) + '0';
    }

  /* Now, if the character needs to be quoted with a backslash, do that. */
  if (c == '\\' || c == '"')
    keyname[i++] = '\\';

  /* Now add the key, terminate the string, and return it. */
  keyname[i++] = (char) c;
  keyname[i] = '\0';

  return keyname;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\bind.c:1,913
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\bind.c:1,987
parsing error 
{
  register int key;
  char **result;
  int result_index, result_size;

  result = (char **)NULL;
  result_index = result_size = 0;

  for (key = 0; key < KEYMAP_SIZE; key++)
    {
      switch (map[key].type)
	{
	case ISMACR:
	  /* Macros match, if, and only if, the pointers are identical.
	     Thus, they are treated exactly like functions in here. */
	case ISFUNC:
	  /* If the function in the keymap is the one we are looking for,
	     then add the current KEY to the list of invoking keys. */
	  if (map[key].function == function)
	    {
	      char *keyname;

	      keyname = _rl_get_keyname (key);

	      if (result_index + 2 > result_size)
	        {
	          result_size += 10;
		  result = (char **)xrealloc (result, result_size * sizeof (char *));
	        }

	      result[result_index++] = keyname;
	      result[result_index] = (char *)NULL;
	    }
	  break;

	case ISKMAP:
	  {
	    char **seqs;
	    register int i;

	    /* Find the list of keyseqs in this map which have FUNCTION as
	       their target.  Add the key sequences found to RESULT. */
	    if (map[key].function)
	      seqs =
	        rl_invoking_keyseqs_in_map (function, FUNCTION_TO_KEYMAP (map, key));
	    else
	      break;

	    if (seqs == 0)
	      break;

	    for (i = 0; seqs[i]; i++)
	      {
		char *keyname = (char *)xmalloc (6 + strlen (seqs[i]));

		if (key == ESC)
		  {
		    /* If ESC is the meta prefix and we're converting chars
		       with the eighth bit set to ESC-prefixed sequences, then
		       we can use \M-.  Otherwise we need to use the sequence
		       for ESC. */
		    if (_rl_convert_meta_chars_to_ascii && map[ESC].type == ISKMAP)
		      sprintf (keyname, "\\M-");
		    else
		      sprintf (keyname, "\\e");
		  }
		else if (CTRL_CHAR (key))
		  sprintf (keyname, "\\C-%c", _rl_to_lower (UNCTRL (key)));
		else if (key == RUBOUT)
		  sprintf (keyname, "\\C-?");
		else if (key == '\\' || key == '"')
		  {
		    keyname[0] = '\\';
		    keyname[1] = (char) key;
		    keyname[2] = '\0';
		  }
		else
		  {
		    keyname[0] = (char) key;
		    keyname[1] = '\0';
		  }
		
		strcat (keyname, seqs[i]);
		xfree (seqs[i]);

		if (result_index + 2 > result_size)
		  {
		    result_size += 10;
		    result = (char **)xrealloc (result, result_size * sizeof (char *));
		  }

		result[result_index++] = keyname;
		result[result_index] = (char *)NULL;
	      }

	    xfree (seqs);
	  }
	  break;
	}
    }
  return (result);
}
warning: parse error {
  register int key;
  char **result;
  int result_index, result_size;

  result = (char **)NULL;
  result_index = result_size = 0;

  for (key = 0; key < KEYMAP_SIZE; key++)
    {
      switch (map[key].type)
	{
	case ISMACR:
	  /* Macros match, if, and only if, the pointers are identical.
	     Thus, they are treated exactly like functions in here. */
	case ISFUNC:
	  /* If the function in the keymap is the one we are looking for,
	     then add the current KEY to the list of invoking keys. */
	  if (map[key].function == function)
	    {
	      char *keyname;

	      keyname = _rl_get_keyname (key);

	      if (result_index + 2 > result_size)
	        {
	          result_size += 10;
		  result = (char **)xrealloc (result, result_size * sizeof (char *));
	        }

	      result[result_index++] = keyname;
	      result[result_index] = (char *)NULL;
	    }
	  break;

	case ISKMAP:
	  {
	    char **seqs;
	    register int i;

	    /* Find the list of keyseqs in this map which have FUNCTION as
	       their target.  Add the key sequences found to RESULT. */
	    if (map[key].function)
	      seqs =
	        rl_invoking_keyseqs_in_map (function, FUNCTION_TO_KEYMAP (map, key));
	    else
	      break;

	    if (seqs == 0)
	      break;

	    for (i = 0; seqs[i]; i++)
	      {
		char *keyname = (char *)xmalloc (6 + strlen (seqs[i]));

		if (key == ESC)
		  {
		    /* If ESC is the meta prefix and we're converting chars
		       with the eighth bit set to ESC-prefixed sequences, then
		       we can use \M-.  Otherwise we need to use the sequence
		       for ESC. */
		    if (_rl_convert_meta_chars_to_ascii && map[ESC].type == ISKMAP)
		      sprintf (keyname, "\\M-");
		    else
		      sprintf (keyname, "\\e");
		  }
		else if (CTRL_CHAR (key))
		  sprintf (keyname, "\\C-%c", _rl_to_lower (UNCTRL (key)));
		else if (key == RUBOUT)
		  sprintf (keyname, "\\C-?");
		else if (key == '\\' || key == '"')
		  {
		    keyname[0] = '\\';
		    keyname[1] = (char) key;
		    keyname[2] = '\0';
		  }
		else
		  {
		    keyname[0] = (char) key;
		    keyname[1] = '\0';
		  }
		
		strcat (keyname, seqs[i]);
		xfree (seqs[i]);

		if (result_index + 2 > result_size)
		  {
		    result_size += 10;
		    result = (char **)xrealloc (result, result_size * sizeof (char *));
		  }

		result[result_index++] = keyname;
		result[result_index] = (char *)NULL;
	      }

	    xfree (seqs);
	  }
	  break;
	}
    }
  return (result);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\bind.c:1,990
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\bind.c:2,096
parsing error 
{
  return (rl_invoking_keyseqs_in_map (function, _rl_keymap));
}
warning: parse error {
  return (rl_invoking_keyseqs_in_map (function, _rl_keymap));
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\bind.c:2,098
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\bind.c:2,106
parsing error 
{
  register int i;
  const char **names;
  const char *name;

  names = rl_funmap_names ();

  fprintf (rl_outstream, "\n");

  for (i = 0; name = names[i]; i++)
    {
      rl_command_func_t *function;
      char **invokers;

      function = rl_named_function (name);
      invokers = rl_invoking_keyseqs_in_map (function, _rl_keymap);

      if (print_readably)
	{
	  if (!invokers)
	    fprintf (rl_outstream, "# %s (not bound)\n", name);
	  else
	    {
	      register int j;

	      for (j = 0; invokers[j]; j++)
		{
		  fprintf (rl_outstream, "\"%s\": %s\n",
			   invokers[j], name);
		  xfree (invokers[j]);
		}

	      xfree (invokers);
	    }
	}
      else
	{
	  if (!invokers)
	    fprintf (rl_outstream, "%s is not bound to any keys\n",
		     name);
	  else
	    {
	      register int j;

	      fprintf (rl_outstream, "%s can be found on ", name);

	      for (j = 0; invokers[j] && j < 5; j++)
		{
		  fprintf (rl_outstream, "\"%s\"%s", invokers[j],
			   invokers[j + 1] ? ", " : ".\n");
		}

	      if (j == 5 && invokers[j])
		fprintf (rl_outstream, "...\n");

	      for (j = 0; invokers[j]; j++)
		xfree (invokers[j]);

	      xfree (invokers);
	    }
	}
    }
}
warning: parse error {
  register int i;
  const char **names;
  const char *name;

  names = rl_funmap_names ();

  fprintf (rl_outstream, "\n");

  for (i = 0; name = names[i]; i++)
    {
      rl_command_func_t *function;
      char **invokers;

      function = rl_named_function (name);
      invokers = rl_invoking_keyseqs_in_map (function, _rl_keymap);

      if (print_readably)
	{
	  if (!invokers)
	    fprintf (rl_outstream, "# %s (not bound)\n", name);
	  else
	    {
	      register int j;

	      for (j = 0; invokers[j]; j++)
		{
		  fprintf (rl_outstream, "\"%s\": %s\n",
			   invokers[j], name);
		  xfree (invokers[j]);
		}

	      xfree (invokers);
	    }
	}
      else
	{
	  if (!invokers)
	    fprintf (rl_outstream, "%s is not bound to any keys\n",
		     name);
	  else
	    {
	      register int j;

	      fprintf (rl_outstream, "%s can be found on ", name);

	      for (j = 0; invokers[j] && j < 5; j++)
		{
		  fprintf (rl_outstream, "\"%s\"%s", invokers[j],
			   invokers[j + 1] ? ", " : ".\n");
		}

	      if (j == 5 && invokers[j])
		fprintf (rl_outstream, "...\n");

	      for (j = 0; invokers[j]; j++)
		xfree (invokers[j]);

	      xfree (invokers);
	    }
	}
    }
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\bind.c:2,108
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\bind.c:2,176
parsing error 
{
  if (rl_dispatching)
    fprintf (rl_outstream, "\r\n");
  rl_function_dumper (rl_explicit_arg);
  rl_on_new_line ();
  return (0);
}
warning: parse error {
  if (rl_dispatching)
    fprintf (rl_outstream, "\r\n");
  rl_function_dumper (rl_explicit_arg);
  rl_on_new_line ();
  return (0);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\bind.c:2,178
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\bind.c:2,187
parsing error 
{
  register int key;
  char *keyname, *out;
  int prefix_len;

  for (key = 0; key < KEYMAP_SIZE; key++)
    {
      switch (map[key].type)
	{
	case ISMACR:
	  keyname = _rl_get_keyname (key);
	  out = _rl_untranslate_macro_value ((char *)map[key].function);

	  if (print_readably)
	    fprintf (rl_outstream, "\"%s%s\": \"%s\"\n", prefix ? prefix : "",
						         keyname,
						         out ? out : "");
	  else
	    fprintf (rl_outstream, "%s%s outputs %s\n", prefix ? prefix : "",
							keyname,
							out ? out : "");
	  xfree (keyname);
	  xfree (out);
	  break;
	case ISFUNC:
	  break;
	case ISKMAP:
	  prefix_len = prefix ? strlen (prefix) : 0;
	  if (key == ESC)
	    {
	      keyname = (char *)xmalloc (3 + prefix_len);
	      if (prefix)
		strcpy (keyname, prefix);
	      keyname[prefix_len] = '\\';
	      keyname[prefix_len + 1] = 'e';
	      keyname[prefix_len + 2] = '\0';
	    }
	  else
	    {
	      keyname = _rl_get_keyname (key);
	      if (prefix)
		{
		  out = (char *)xmalloc (strlen (keyname) + prefix_len + 1);
		  strcpy (out, prefix);
		  strcpy (out + prefix_len, keyname);
		  xfree (keyname);
		  keyname = out;
		}
	    }

	  _rl_macro_dumper_internal (print_readably, FUNCTION_TO_KEYMAP (map, key), keyname);
	  xfree (keyname);
	  break;
	}
    }
}
warning: parse error {
  register int key;
  char *keyname, *out;
  int prefix_len;

  for (key = 0; key < KEYMAP_SIZE; key++)
    {
      switch (map[key].type)
	{
	case ISMACR:
	  keyname = _rl_get_keyname (key);
	  out = _rl_untranslate_macro_value ((char *)map[key].function);

	  if (print_readably)
	    fprintf (rl_outstream, "\"%s%s\": \"%s\"\n", prefix ? prefix : "",
						         keyname,
						         out ? out : "");
	  else
	    fprintf (rl_outstream, "%s%s outputs %s\n", prefix ? prefix : "",
							keyname,
							out ? out : "");
	  xfree (keyname);
	  xfree (out);
	  break;
	case ISFUNC:
	  break;
	case ISKMAP:
	  prefix_len = prefix ? strlen (prefix) : 0;
	  if (key == ESC)
	    {
	      keyname = (char *)xmalloc (3 + prefix_len);
	      if (prefix)
		strcpy (keyname, prefix);
	      keyname[prefix_len] = '\\';
	      keyname[prefix_len + 1] = 'e';
	      keyname[prefix_len + 2] = '\0';
	    }
	  else
	    {
	      keyname = _rl_get_keyname (key);
	      if (prefix)
		{
		  out = (char *)xmalloc (strlen (keyname) + prefix_len + 1);
		  strcpy (out, prefix);
		  strcpy (out + prefix_len, keyname);
		  xfree (keyname);
		  keyname = out;
		}
	    }

	  _rl_macro_dumper_internal (print_readably, FUNCTION_TO_KEYMAP (map, key), keyname);
	  xfree (keyname);
	  break;
	}
    }
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\bind.c:2,191
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\bind.c:2,249
parsing error 
{
  _rl_macro_dumper_internal (print_readably, _rl_keymap, (char *)NULL);
}
warning: parse error {
  _rl_macro_dumper_internal (print_readably, _rl_keymap, (char *)NULL);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\bind.c:2,251
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\bind.c:2,256
parsing error 
{
  if (rl_dispatching)
    fprintf (rl_outstream, "\r\n");
  rl_macro_dumper (rl_explicit_arg);
  rl_on_new_line ();
  return (0);
}
warning: parse error {
  if (rl_dispatching)
    fprintf (rl_outstream, "\r\n");
  rl_macro_dumper (rl_explicit_arg);
  rl_on_new_line ();
  return (0);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\bind.c:2,258
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\bind.c:2,268
parsing error 
{
  static char numbuf[32];
  char *ret;

  if (_rl_stricmp (name, "bell-style") == 0)
    {
      switch (_rl_bell_preference)
	{
	  case NO_BELL:
	    return "none";
	  case VISIBLE_BELL:
	    return "visible";
	  case AUDIBLE_BELL:
	  default:
	    return "audible";
	}
    }
  else if (_rl_stricmp (name, "comment-begin") == 0)
    return (_rl_comment_begin ? _rl_comment_begin : RL_COMMENT_BEGIN_DEFAULT);
  else if (_rl_stricmp (name, "completion-display-width") == 0)
    {
      sprintf (numbuf, "%d", _rl_completion_columns);
      return (numbuf);
    }
  else if (_rl_stricmp (name, "completion-prefix-display-length") == 0)
    {
      sprintf (numbuf, "%d", _rl_completion_prefix_display_length);
      return (numbuf);
    }
  else if (_rl_stricmp (name, "completion-query-items") == 0)
    {
      sprintf (numbuf, "%d", rl_completion_query_items);
      return (numbuf);
    }
  else if (_rl_stricmp (name, "editing-mode") == 0)
    return (rl_get_keymap_name_from_edit_mode ());
  else if (_rl_stricmp (name, "history-size") == 0)
    {
      sprintf (numbuf, "%d", history_is_stifled() ? history_max_entries : 0);
      return (numbuf);
    }
  else if (_rl_stricmp (name, "isearch-terminators") == 0)
    {
      if (_rl_isearch_terminators == 0)
	return 0;
      ret = _rl_untranslate_macro_value (_rl_isearch_terminators);
      if (ret)
	{
	  strncpy (numbuf, ret, sizeof (numbuf) - 1);
	  xfree (ret);
	  numbuf[sizeof(numbuf) - 1] = '\0';
	}
      else
	numbuf[0] = '\0';
      return numbuf;
    }
  else if (_rl_stricmp (name, "keymap") == 0)
    {
      ret = rl_get_keymap_name (_rl_keymap);
      if (ret == 0)
	ret = rl_get_keymap_name_from_edit_mode ();
      return (ret ? ret : "none");
    }
  else
    return (0);
}
warning: parse error {
  static char numbuf[32];
  char *ret;

  if (_rl_stricmp (name, "bell-style") == 0)
    {
      switch (_rl_bell_preference)
	{
	  case NO_BELL:
	    return "none";
	  case VISIBLE_BELL:
	    return "visible";
	  case AUDIBLE_BELL:
	  default:
	    return "audible";
	}
    }
  else if (_rl_stricmp (name, "comment-begin") == 0)
    return (_rl_comment_begin ? _rl_comment_begin : RL_COMMENT_BEGIN_DEFAULT);
  else if (_rl_stricmp (name, "completion-display-width") == 0)
    {
      sprintf (numbuf, "%d", _rl_completion_columns);
      return (numbuf);
    }
  else if (_rl_stricmp (name, "completion-prefix-display-length") == 0)
    {
      sprintf (numbuf, "%d", _rl_completion_prefix_display_length);
      return (numbuf);
    }
  else if (_rl_stricmp (name, "completion-query-items") == 0)
    {
      sprintf (numbuf, "%d", rl_completion_query_items);
      return (numbuf);
    }
  else if (_rl_stricmp (name, "editing-mode") == 0)
    return (rl_get_keymap_name_from_edit_mode ());
  else if (_rl_stricmp (name, "history-size") == 0)
    {
      sprintf (numbuf, "%d", history_is_stifled() ? history_max_entries : 0);
      return (numbuf);
    }
  else if (_rl_stricmp (name, "isearch-terminators") == 0)
    {
      if (_rl_isearch_terminators == 0)
	return 0;
      ret = _rl_untranslate_macro_value (_rl_isearch_terminators);
      if (ret)
	{
	  strncpy (numbuf, ret, sizeof (numbuf) - 1);
	  xfree (ret);
	  numbuf[sizeof(numbuf) - 1] = '\0';
	}
      else
	numbuf[0] = '\0';
      return numbuf;
    }
  else if (_rl_stricmp (name, "keymap") == 0)
    {
      ret = rl_get_keymap_name (_rl_keymap);
      if (ret == 0)
	ret = rl_get_keymap_name_from_edit_mode ();
      return (ret ? ret : "none");
    }
  else
    return (0);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\bind.c:2,269
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\bind.c:2,337
parsing error 
{
  int i;
  char *v;

  for (i = 0; boolean_varlist[i].name; i++)
    {
      if (print_readably)
        fprintf (rl_outstream, "set %s %s\n", boolean_varlist[i].name,
			       *boolean_varlist[i].value ? "on" : "off");
      else
        fprintf (rl_outstream, "%s is set to `%s'\n", boolean_varlist[i].name,
			       *boolean_varlist[i].value ? "on" : "off");
    }

  for (i = 0; string_varlist[i].name; i++)
    {
      v = _rl_get_string_variable_value (string_varlist[i].name);
      if (v == 0)	/* _rl_isearch_terminators can be NULL */
	continue;
      if (print_readably)
        fprintf (rl_outstream, "set %s %s\n", string_varlist[i].name, v);
      else
        fprintf (rl_outstream, "%s is set to `%s'\n", string_varlist[i].name, v);
    }
}
warning: parse error {
  int i;
  char *v;

  for (i = 0; boolean_varlist[i].name; i++)
    {
      if (print_readably)
        fprintf (rl_outstream, "set %s %s\n", boolean_varlist[i].name,
			       *boolean_varlist[i].value ? "on" : "off");
      else
        fprintf (rl_outstream, "%s is set to `%s'\n", boolean_varlist[i].name,
			       *boolean_varlist[i].value ? "on" : "off");
    }

  for (i = 0; string_varlist[i].name; i++)
    {
      v = _rl_get_string_variable_value (string_varlist[i].name);
      if (v == 0)	/* _rl_isearch_terminators can be NULL */
	continue;
      if (print_readably)
        fprintf (rl_outstream, "set %s %s\n", string_varlist[i].name, v);
      else
        fprintf (rl_outstream, "%s is set to `%s'\n", string_varlist[i].name, v);
    }
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\bind.c:2,339
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\bind.c:2,369
parsing error 
{
  if (rl_dispatching)
    fprintf (rl_outstream, "\r\n");
  rl_variable_dumper (rl_explicit_arg);
  rl_on_new_line ();
  return (0);
}
warning: parse error {
  if (rl_dispatching)
    fprintf (rl_outstream, "\r\n");
  rl_variable_dumper (rl_explicit_arg);
  rl_on_new_line ();
  return (0);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\bind.c:2,371
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\bind.c:2,382
parsing error 
{
  while (*array)
    {
      if (_rl_strindex (string, *array))
	return (1);
      array++;
    }
  return (0);
}
warning: parse error {
  while (*array)
    {
      if (_rl_strindex (string, *array))
	return (1);
      array++;
    }
  return (0);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\bind.c:2,384
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\callback.c...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\rlconf.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\rldefs.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\rlprivate.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\xmalloc.h...skip
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\callback.c:96
parsing error 
{
  rl_set_prompt (prompt);
  RL_SETSTATE (RL_STATE_CALLBACK);
  rl_linefunc = linefunc;
  _rl_callback_newline ();
}
warning: parse error {
  rl_set_prompt (prompt);
  RL_SETSTATE (RL_STATE_CALLBACK);
  rl_linefunc = linefunc;
  _rl_callback_newline ();
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\callback.c:98
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\callback.c:251
parsing error 
{
  _rl_callback_generic_arg *arg;

  arg = (_rl_callback_generic_arg *)xmalloc (sizeof (_rl_callback_generic_arg));
  arg->count = count;

  arg->i1 = arg->i2 = 0;

  return arg;
}
warning: parse error {
  _rl_callback_generic_arg *arg;

  arg = (_rl_callback_generic_arg *)xmalloc (sizeof (_rl_callback_generic_arg));
  arg->count = count;

  arg->i1 = arg->i2 = 0;

  return arg;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\callback.c:253
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\callback.c:264
parsing error 
{
  xfree (arg);
}
warning: parse error {
  xfree (arg);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\callback.c:266
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\compat.c...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\rlstdc.h...skip
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\rltypedefs.h...
parsing error 
typedef int rl_command_func_t PARAMS((int, int));
warning: parse error typedef int rl_command_func_t PARAMS((int, int));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\rltypedefs.h:47
parsing error 
typedef char *rl_compentry_func_t PARAMS((const char *, int));
warning: parse error typedef char *rl_compentry_func_t PARAMS((const char *, int));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\rltypedefs.h:50
parsing error 
typedef char **rl_completion_func_t PARAMS((const char *, int, int));
warning: parse error typedef char **rl_completion_func_t PARAMS((const char *, int, int));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\rltypedefs.h:51
parsing error 
typedef char *rl_quote_func_t PARAMS((char *, int, char *));
warning: parse error typedef char *rl_quote_func_t PARAMS((char *, int, char *));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\rltypedefs.h:53
parsing error 
typedef char *rl_dequote_func_t PARAMS((char *, int));
warning: parse error typedef char *rl_dequote_func_t PARAMS((char *, int));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\rltypedefs.h:54
parsing error 
typedef int rl_compignore_func_t PARAMS((char **));
warning: parse error typedef int rl_compignore_func_t PARAMS((char **));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\rltypedefs.h:56
parsing error 
typedef void rl_compdisp_func_t PARAMS((char **, int, int));
warning: parse error typedef void rl_compdisp_func_t PARAMS((char **, int, int));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\rltypedefs.h:58
parsing error 
typedef int rl_hook_func_t PARAMS((void));
warning: parse error typedef int rl_hook_func_t PARAMS((void));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\rltypedefs.h:61
parsing error 
typedef int rl_getc_func_t PARAMS((FILE *));
warning: parse error typedef int rl_getc_func_t PARAMS((FILE *));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\rltypedefs.h:64
parsing error 
typedef int rl_linebuf_func_t PARAMS((char *, int));
warning: parse error typedef int rl_linebuf_func_t PARAMS((char *, int));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\rltypedefs.h:69
parsing error 
typedef int rl_intfunc_t PARAMS((int));
warning: parse error typedef int rl_intfunc_t PARAMS((int));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\rltypedefs.h:72
parsing error 
typedef int rl_icpfunc_t PARAMS((char *));
warning: parse error typedef int rl_icpfunc_t PARAMS((char *));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\rltypedefs.h:74
parsing error 
typedef int rl_icppfunc_t PARAMS((char **));
warning: parse error typedef int rl_icppfunc_t PARAMS((char **));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\rltypedefs.h:75
parsing error 
typedef void rl_voidfunc_t PARAMS((void));
warning: parse error typedef void rl_voidfunc_t PARAMS((void));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\rltypedefs.h:77
parsing error 
typedef void rl_vintfunc_t PARAMS((int));
warning: parse error typedef void rl_vintfunc_t PARAMS((int));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\rltypedefs.h:78
parsing error 
typedef void rl_vcpfunc_t PARAMS((char *));
warning: parse error typedef void rl_vcpfunc_t PARAMS((char *));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\rltypedefs.h:79
parsing error 
typedef void rl_vcppfunc_t PARAMS((char **));
warning: parse error typedef void rl_vcppfunc_t PARAMS((char **));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\rltypedefs.h:80
parsing error 
typedef char *rl_cpvfunc_t PARAMS((void));
warning: parse error typedef char *rl_cpvfunc_t PARAMS((void));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\rltypedefs.h:82
parsing error 
typedef char *rl_cpifunc_t PARAMS((int));
warning: parse error typedef char *rl_cpifunc_t PARAMS((int));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\rltypedefs.h:83
parsing error 
typedef char *rl_cpcpfunc_t PARAMS((char  *));
warning: parse error typedef char *rl_cpcpfunc_t PARAMS((char  *));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\rltypedefs.h:84
parsing error 
typedef char *rl_cpcppfunc_t PARAMS((char  **));
warning: parse error typedef char *rl_cpcppfunc_t PARAMS((char  **));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\rltypedefs.h:85
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\compat.c:85
parsing error 
{
  return rl_alphabetic (c);
}
warning: parse error {
  return rl_alphabetic (c);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\compat.c:87
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\compat.c:93
parsing error 
{
  return rl_completion_matches (s, f);
}
warning: parse error {
  return rl_completion_matches (s, f);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\compat.c:95
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\compat.c:101
parsing error 
{
  return rl_username_completion_function (s, i);
}
warning: parse error {
  return rl_username_completion_function (s, i);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\compat.c:103
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\compat.c:109
parsing error 
{
  return rl_filename_completion_function (s, i);
}
warning: parse error {
  return rl_filename_completion_function (s, i);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\compat.c:111
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\complete.c...
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\posixdir.h...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\posixstat.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\rldefs.h...skip
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\rlmbutil.h...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\rlstdc.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\xmalloc.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\rlprivate.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\complete.c:393
parsing error 
{
  rl_completion_invoking_key = invoking_key;

  if (rl_inhibit_completion)
    return (_rl_insert_char (ignore, invoking_key));
  else if (rl_last_func == rl_complete && !completion_changed_buffer)
    return (rl_complete_internal ('?'));
  else if (_rl_complete_show_all)
    return (rl_complete_internal ('!'));
  else if (_rl_complete_show_unmodified)
    return (rl_complete_internal ('@'));
  else
    return (rl_complete_internal (TAB));
}
warning: parse error {
  rl_completion_invoking_key = invoking_key;

  if (rl_inhibit_completion)
    return (_rl_insert_char (ignore, invoking_key));
  else if (rl_last_func == rl_complete && !completion_changed_buffer)
    return (rl_complete_internal ('?'));
  else if (_rl_complete_show_all)
    return (rl_complete_internal ('!'));
  else if (_rl_complete_show_unmodified)
    return (rl_complete_internal ('@'));
  else
    return (rl_complete_internal (TAB));
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\complete.c:395
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\complete.c:412
parsing error 
{
  rl_completion_invoking_key = invoking_key;
  return (rl_complete_internal ('?'));
}
warning: parse error {
  rl_completion_invoking_key = invoking_key;
  return (rl_complete_internal ('?'));
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\complete.c:414
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\complete.c:420
parsing error 
{
  rl_completion_invoking_key = invoking_key;
  return (rl_complete_internal ('*'));
}
warning: parse error {
  rl_completion_invoking_key = invoking_key;
  return (rl_complete_internal ('*'));
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\complete.c:422
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\complete.c:433
parsing error 
{
  if (rl_last_func == cfunc && !completion_changed_buffer)
    return '?';
  else if (_rl_complete_show_all)
    return '!';
  else if (_rl_complete_show_unmodified)
    return '@';
  else
    return TAB;
}
warning: parse error {
  if (rl_last_func == cfunc && !completion_changed_buffer)
    return '?';
  else if (_rl_complete_show_all)
    return '!';
  else if (_rl_complete_show_unmodified)
    return '@';
  else
    return TAB;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\complete.c:435
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\complete.c:463
parsing error 
{
  /* Only the completion entry function can change these. */
  rl_filename_completion_desired = 0;
  rl_filename_quoting_desired = 1;
  rl_completion_type = what_to_do;
  rl_completion_suppress_append = rl_completion_suppress_quote = 0;
  rl_completion_append_character = ' ';

  /* The completion entry function may optionally change this. */
  rl_completion_mark_symlink_dirs = _rl_complete_mark_symlink_dirs;
}
warning: parse error {
  /* Only the completion entry function can change these. */
  rl_filename_completion_desired = 0;
  rl_filename_quoting_desired = 1;
  rl_completion_type = what_to_do;
  rl_completion_suppress_append = rl_completion_suppress_quote = 0;
  rl_completion_append_character = ' ';

  /* The completion entry function may optionally change this. */
  rl_completion_mark_symlink_dirs = _rl_complete_mark_symlink_dirs;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\complete.c:465
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\complete.c:479
parsing error 
{
  int c;

  /* For now, disable pager in callback mode, until we later convert to state
     driven functions.  Have to wait until next major version to add new
     state definition, since it will change value of RL_STATE_DONE. */
#if defined (READLINE_CALLBACKS)
  if (RL_ISSTATE (RL_STATE_CALLBACK))
    return 1;
#endif

  for (;;)
    {
      RL_SETSTATE(RL_STATE_MOREINPUT);
      c = rl_read_key ();
      RL_UNSETSTATE(RL_STATE_MOREINPUT);

      if (c == 'y' || c == 'Y' || c == ' ')
	return (1);
      if (c == 'n' || c == 'N' || c == RUBOUT)
	return (0);
      if (c == ABORT_CHAR || c < 0)
	_rl_abort_internal ();
      if (for_pager && (c == NEWLINE || c == RETURN))
	return (2);
      if (for_pager && (c == 'q' || c == 'Q'))
	return (0);
      rl_ding ();
    }
}
warning: parse error {
  int c;

  /* For now, disable pager in callback mode, until we later convert to state
     driven functions.  Have to wait until next major version to add new
     state definition, since it will change value of RL_STATE_DONE. */
#if defined (READLINE_CALLBACKS)
  if (RL_ISSTATE (RL_STATE_CALLBACK))
    return 1;
#endif

  for (;;)
    {
      RL_SETSTATE(RL_STATE_MOREINPUT);
      c = rl_read_key ();
      RL_UNSETSTATE(RL_STATE_MOREINPUT);

      if (c == 'y' || c == 'Y' || c == ' ')
	return (1);
      if (c == 'n' || c == 'N' || c == RUBOUT)
	return (0);
      if (c == ABORT_CHAR || c < 0)
	_rl_abort_internal ();
      if (for_pager && (c == NEWLINE || c == RETURN))
	return (2);
      if (for_pager && (c == 'q' || c == 'Q'))
	return (0);
      rl_ding ();
    }
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\complete.c:481
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\complete.c:513
parsing error 
{
  int i;

  fprintf (rl_outstream, "--More--");
  fflush (rl_outstream);
  i = get_y_or_n (1);
  _rl_erase_entire_line ();
  if (i == 0)
    return -1;
  else if (i == 2)
    return (lines - 1);
  else
    return 0;
}
warning: parse error {
  int i;

  fprintf (rl_outstream, "--More--");
  fflush (rl_outstream);
  i = get_y_or_n (1);
  _rl_erase_entire_line ();
  if (i == 0)
    return -1;
  else if (i == 2)
    return (lines - 1);
  else
    return 0;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\complete.c:515
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\complete.c:532
parsing error 
{
  struct stat finfo;

  return (stat (filename, &finfo) == 0 && S_ISDIR (finfo.st_mode));
}
warning: parse error {
  struct stat finfo;

  return (stat (filename, &finfo) == 0 && S_ISDIR (finfo.st_mode));
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\complete.c:533
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\complete.c:549
parsing error 
{
  struct stat finfo;
  int character, r;

  /* Short-circuit a //server on cygwin, since that will always behave as
     a directory. */
#if __CYGWIN__
  if (filename[0] == '/' && filename[1] == '/' && strchr (filename+2, '/') == 0)
    return '/';
#endif

#if defined (HAVE_LSTAT) && defined (S_ISLNK)
  r = lstat (filename, &finfo);
#else
  r = stat (filename, &finfo);
#endif

  if (r == -1)
    return (0);

  character = 0;
  if (S_ISDIR (finfo.st_mode))
    character = '/';
#if defined (S_ISCHR)
  else if (S_ISCHR (finfo.st_mode))
    character = '%';
#endif /* S_ISCHR */
#if defined (S_ISBLK)
  else if (S_ISBLK (finfo.st_mode))
    character = '#';
#endif /* S_ISBLK */
#if defined (S_ISLNK)
  else if (S_ISLNK (finfo.st_mode))
    character = '@';
#endif /* S_ISLNK */
#if defined (S_ISSOCK)
  else if (S_ISSOCK (finfo.st_mode))
    character = '=';
#endif /* S_ISSOCK */
#if defined (S_ISFIFO)
  else if (S_ISFIFO (finfo.st_mode))
    character = '|';
#endif
  else if (S_ISREG (finfo.st_mode))
    {
      if (access (filename, X_OK) == 0)
	character = '*';
    }
  return (character);
}
warning: parse error {
  struct stat finfo;
  int character, r;

  /* Short-circuit a //server on cygwin, since that will always behave as
     a directory. */
#if __CYGWIN__
  if (filename[0] == '/' && filename[1] == '/' && strchr (filename+2, '/') == 0)
    return '/';
#endif

#if defined (HAVE_LSTAT) && defined (S_ISLNK)
  r = lstat (filename, &finfo);
#else
  r = stat (filename, &finfo);
#endif

  if (r == -1)
    return (0);

  character = 0;
  if (S_ISDIR (finfo.st_mode))
    character = '/';
#if defined (S_ISCHR)
  else if (S_ISCHR (finfo.st_mode))
    character = '%';
#endif /* S_ISCHR */
#if defined (S_ISBLK)
  else if (S_ISBLK (finfo.st_mode))
    character = '#';
#endif /* S_ISBLK */
#if defined (S_ISLNK)
  else if (S_ISLNK (finfo.st_mode))
    character = '@';
#endif /* S_ISLNK */
#if defined (S_ISSOCK)
  else if (S_ISSOCK (finfo.st_mode))
    character = '=';
#endif /* S_ISSOCK */
#if defined (S_ISFIFO)
  else if (S_ISFIFO (finfo.st_mode))
    character = '|';
#endif
  else if (S_ISREG (finfo.st_mode))
    {
      if (access (filename, X_OK) == 0)
	character = '*';
    }
  return (character);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\complete.c:551
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\complete.c:612
parsing error 
{
  char *temp, *x;

  if (rl_filename_completion_desired == 0)	/* don't need to do anything */
    return (pathname);

  temp = strrchr (pathname, '/');
#if defined (__MSDOS__)
  if (temp == 0 && ISALPHA ((unsigned char)pathname[0]) && pathname[1] == ':')
    temp = pathname + 1;
#endif

  if (temp == 0 || *temp == '\0')
    return (pathname);
  /* If the basename is NULL, we might have a pathname like '/usr/src/'.
     Look for a previous slash and, if one is found, return the portion
     following that slash.  If there's no previous slash, just return the
     pathname we were passed. */
  else if (temp[1] == '\0')
    {
      for (x = temp - 1; x > pathname; x--)
        if (*x == '/')
          break;
      return ((*x == '/') ? x + 1 : pathname);
    }
  else
    return ++temp;
}
warning: parse error {
  char *temp, *x;

  if (rl_filename_completion_desired == 0)	/* don't need to do anything */
    return (pathname);

  temp = strrchr (pathname, '/');
#if defined (__MSDOS__)
  if (temp == 0 && ISALPHA ((unsigned char)pathname[0]) && pathname[1] == ':')
    temp = pathname + 1;
#endif

  if (temp == 0 || *temp == '\0')
    return (pathname);
  /* If the basename is NULL, we might have a pathname like '/usr/src/'.
     Look for a previous slash and, if one is found, return the portion
     following that slash.  If there's no previous slash, just return the
     pathname we were passed. */
  else if (temp[1] == '\0')
    {
      for (x = temp - 1; x > pathname; x--)
        if (*x == '/')
          break;
      return ((*x == '/') ? x + 1 : pathname);
    }
  else
    return ++temp;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\complete.c:614
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\complete.c:646
parsing error 
{
  int width, pos;
#if defined (HANDLE_MULTIBYTE)
  mbstate_t ps;
  int left, w;
  size_t clen;
  wchar_t wc;

  left = strlen (string) + 1;
  memset (&ps, 0, sizeof (mbstate_t));
#endif

  width = pos = 0;
  while (string[pos])
    {
      if (CTRL_CHAR (string[pos]) || string[pos] == RUBOUT)
	{
	  width += 2;
	  pos++;
	}
      else
	{
#if defined (HANDLE_MULTIBYTE)
	  clen = mbrtowc (&wc, string + pos, left - pos, &ps);
	  if (MB_INVALIDCH (clen))
	    {
	      width++;
	      pos++;
	      memset (&ps, 0, sizeof (mbstate_t));
	    }
	  else if (MB_NULLWCH (clen))
	    break;
	  else
	    {
	      pos += clen;
	      w = wcwidth (wc);
	      width += (w >= 0) ? w : 1;
	    }
#else
	  width++;
	  pos++;
#endif
	}
    }

  return width;
}
warning: parse error {
  int width, pos;
#if defined (HANDLE_MULTIBYTE)
  mbstate_t ps;
  int left, w;
  size_t clen;
  wchar_t wc;

  left = strlen (string) + 1;
  memset (&ps, 0, sizeof (mbstate_t));
#endif

  width = pos = 0;
  while (string[pos])
    {
      if (CTRL_CHAR (string[pos]) || string[pos] == RUBOUT)
	{
	  width += 2;
	  pos++;
	}
      else
	{
#if defined (HANDLE_MULTIBYTE)
	  clen = mbrtowc (&wc, string + pos, left - pos, &ps);
	  if (MB_INVALIDCH (clen))
	    {
	      width++;
	      pos++;
	      memset (&ps, 0, sizeof (mbstate_t));
	    }
	  else if (MB_NULLWCH (clen))
	    break;
	  else
	    {
	      pos += clen;
	      w = wcwidth (wc);
	      width += (w >= 0) ? w : 1;
	    }
#else
	  width++;
	  pos++;
#endif
	}
    }

  return width;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\complete.c:647
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\complete.c:699
parsing error 
{
  int printed_len, w;
  const char *s;
#if defined (HANDLE_MULTIBYTE)
  mbstate_t ps;
  const char *end;
  size_t tlen;
  int width;
  wchar_t wc;

  end = to_print + strlen (to_print) + 1;
  memset (&ps, 0, sizeof (mbstate_t));
#endif

  printed_len = 0;

  /* Don't print only the ellipsis if the common prefix is one of the
     possible completions */
  if (to_print[prefix_bytes] == '\0')
    prefix_bytes = 0;

  if (prefix_bytes)
    {
      char ellipsis;

      ellipsis = (to_print[prefix_bytes] == '.') ? '_' : '.';
      for (w = 0; w < ELLIPSIS_LEN; w++)
	putc (ellipsis, rl_outstream);
      printed_len = ELLIPSIS_LEN;
    }

  s = to_print + prefix_bytes;
  while (*s)
    {
      if (CTRL_CHAR (*s))
        {
          putc ('^', rl_outstream);
          putc (UNCTRL (*s), rl_outstream);
          printed_len += 2;
          s++;
#if defined (HANDLE_MULTIBYTE)
	  memset (&ps, 0, sizeof (mbstate_t));
#endif
        }
      else if (*s == RUBOUT)
	{
	  putc ('^', rl_outstream);
	  putc ('?', rl_outstream);
	  printed_len += 2;
	  s++;
#if defined (HANDLE_MULTIBYTE)
	  memset (&ps, 0, sizeof (mbstate_t));
#endif
	}
      else
	{
#if defined (HANDLE_MULTIBYTE)
	  tlen = mbrtowc (&wc, s, end - s, &ps);
	  if (MB_INVALIDCH (tlen))
	    {
	      tlen = 1;
	      width = 1;
	      memset (&ps, 0, sizeof (mbstate_t));
	    }
	  else if (MB_NULLWCH (tlen))
	    break;
	  else
	    {
	      w = wcwidth (wc);
	      width = (w >= 0) ? w : 1;
	    }
	  fwrite (s, 1, tlen, rl_outstream);
	  s += tlen;
	  printed_len += width;
#else
	  putc (*s, rl_outstream);
	  s++;
	  printed_len++;
#endif
	}
    }

  return printed_len;
}
warning: parse error {
  int printed_len, w;
  const char *s;
#if defined (HANDLE_MULTIBYTE)
  mbstate_t ps;
  const char *end;
  size_t tlen;
  int width;
  wchar_t wc;

  end = to_print + strlen (to_print) + 1;
  memset (&ps, 0, sizeof (mbstate_t));
#endif

  printed_len = 0;

  /* Don't print only the ellipsis if the common prefix is one of the
     possible completions */
  if (to_print[prefix_bytes] == '\0')
    prefix_bytes = 0;

  if (prefix_bytes)
    {
      char ellipsis;

      ellipsis = (to_print[prefix_bytes] == '.') ? '_' : '.';
      for (w = 0; w < ELLIPSIS_LEN; w++)
	putc (ellipsis, rl_outstream);
      printed_len = ELLIPSIS_LEN;
    }

  s = to_print + prefix_bytes;
  while (*s)
    {
      if (CTRL_CHAR (*s))
        {
          putc ('^', rl_outstream);
          putc (UNCTRL (*s), rl_outstream);
          printed_len += 2;
          s++;
#if defined (HANDLE_MULTIBYTE)
	  memset (&ps, 0, sizeof (mbstate_t));
#endif
        }
      else if (*s == RUBOUT)
	{
	  putc ('^', rl_outstream);
	  putc ('?', rl_outstream);
	  printed_len += 2;
	  s++;
#if defined (HANDLE_MULTIBYTE)
	  memset (&ps, 0, sizeof (mbstate_t));
#endif
	}
      else
	{
#if defined (HANDLE_MULTIBYTE)
	  tlen = mbrtowc (&wc, s, end - s, &ps);
	  if (MB_INVALIDCH (tlen))
	    {
	      tlen = 1;
	      width = 1;
	      memset (&ps, 0, sizeof (mbstate_t));
	    }
	  else if (MB_NULLWCH (tlen))
	    break;
	  else
	    {
	      w = wcwidth (wc);
	      width = (w >= 0) ? w : 1;
	    }
	  fwrite (s, 1, tlen, rl_outstream);
	  s += tlen;
	  printed_len += width;
#else
	  putc (*s, rl_outstream);
	  s++;
	  printed_len++;
#endif
	}
    }

  return printed_len;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\complete.c:701
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\complete.c:791
parsing error 
{
  int printed_len, extension_char, slen, tlen;
  char *s, c, *new_full_pathname, *dn;

  extension_char = 0;
  printed_len = fnprint (to_print, prefix_bytes);

#if defined (VISIBLE_STATS)
 if (rl_filename_completion_desired && (rl_visible_stats || _rl_complete_mark_directories))
#else
 if (rl_filename_completion_desired && _rl_complete_mark_directories)
#endif
    {
      /* If to_print != full_pathname, to_print is the basename of the
	 path passed.  In this case, we try to expand the directory
	 name before checking for the stat character. */
      if (to_print != full_pathname)
	{
	  /* Terminate the directory name. */
	  c = to_print[-1];
	  to_print[-1] = '\0';

	  /* If setting the last slash in full_pathname to a NUL results in
	     full_pathname being the empty string, we are trying to complete
	     files in the root directory.  If we pass a null string to the
	     bash directory completion hook, for example, it will expand it
	     to the current directory.  We just want the `/'. */
	  if (full_pathname == 0 || *full_pathname == 0)
	    dn = "/";
	  else if (full_pathname[0] != '/')
	    dn = full_pathname;
	  else if (full_pathname[1] == 0)
	    dn = "//";		/* restore trailing slash to `//' */
	  else if (full_pathname[1] == '/' && full_pathname[2] == 0)
	    dn = "/";		/* don't turn /// into // */
	  else
	    dn = full_pathname;
	  s = tilde_expand (dn);
	  if (rl_directory_completion_hook)
	    (*rl_directory_completion_hook) (&s);

	  slen = strlen (s);
	  tlen = strlen (to_print);
	  new_full_pathname = (char *)xmalloc (slen + tlen + 2);
	  strcpy (new_full_pathname, s);
	  if (s[slen - 1] == '/')
	    slen--;
	  else
	    new_full_pathname[slen] = '/';
	  new_full_pathname[slen] = '/';
	  strcpy (new_full_pathname + slen + 1, to_print);

#if defined (VISIBLE_STATS)
	  if (rl_visible_stats)
	    extension_char = stat_char (new_full_pathname);
	  else
#endif
	  if (path_isdir (new_full_pathname))
	    extension_char = '/';

	  xfree (new_full_pathname);
	  to_print[-1] = c;
	}
      else
	{
	  s = tilde_expand (full_pathname);
#if defined (VISIBLE_STATS)
	  if (rl_visible_stats)
	    extension_char = stat_char (s);
	  else
#endif
	    if (path_isdir (s))
	      extension_char = '/';
	}

      xfree (s);
      if (extension_char)
	{
	  putc (extension_char, rl_outstream);
	  printed_len++;
	}
    }

  return printed_len;
}
warning: parse error {
  int printed_len, extension_char, slen, tlen;
  char *s, c, *new_full_pathname, *dn;

  extension_char = 0;
  printed_len = fnprint (to_print, prefix_bytes);

#if defined (VISIBLE_STATS)
 if (rl_filename_completion_desired && (rl_visible_stats || _rl_complete_mark_directories))
#else
 if (rl_filename_completion_desired && _rl_complete_mark_directories)
#endif
    {
      /* If to_print != full_pathname, to_print is the basename of the
	 path passed.  In this case, we try to expand the directory
	 name before checking for the stat character. */
      if (to_print != full_pathname)
	{
	  /* Terminate the directory name. */
	  c = to_print[-1];
	  to_print[-1] = '\0';

	  /* If setting the last slash in full_pathname to a NUL results in
	     full_pathname being the empty string, we are trying to complete
	     files in the root directory.  If we pass a null string to the
	     bash directory completion hook, for example, it will expand it
	     to the current directory.  We just want the `/'. */
	  if (full_pathname == 0 || *full_pathname == 0)
	    dn = "/";
	  else if (full_pathname[0] != '/')
	    dn = full_pathname;
	  else if (full_pathname[1] == 0)
	    dn = "//";		/* restore trailing slash to `//' */
	  else if (full_pathname[1] == '/' && full_pathname[2] == 0)
	    dn = "/";		/* don't turn /// into // */
	  else
	    dn = full_pathname;
	  s = tilde_expand (dn);
	  if (rl_directory_completion_hook)
	    (*rl_directory_completion_hook) (&s);

	  slen = strlen (s);
	  tlen = strlen (to_print);
	  new_full_pathname = (char *)xmalloc (slen + tlen + 2);
	  strcpy (new_full_pathname, s);
	  if (s[slen - 1] == '/')
	    slen--;
	  else
	    new_full_pathname[slen] = '/';
	  new_full_pathname[slen] = '/';
	  strcpy (new_full_pathname + slen + 1, to_print);

#if defined (VISIBLE_STATS)
	  if (rl_visible_stats)
	    extension_char = stat_char (new_full_pathname);
	  else
#endif
	  if (path_isdir (new_full_pathname))
	    extension_char = '/';

	  xfree (new_full_pathname);
	  to_print[-1] = c;
	}
      else
	{
	  s = tilde_expand (full_pathname);
#if defined (VISIBLE_STATS)
	  if (rl_visible_stats)
	    extension_char = stat_char (s);
	  else
#endif
	    if (path_isdir (s))
	      extension_char = '/';
	}

      xfree (s);
      if (extension_char)
	{
	  putc (extension_char, rl_outstream);
	  printed_len++;
	}
    }

  return printed_len;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\complete.c:794
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\complete.c:881
parsing error 
{
  char *r;

  r = (char *)xmalloc (strlen (s) + 2);
  *r = *rl_completer_quote_characters;
  strcpy (r + 1, s);
  if (qcp)
    *qcp = *rl_completer_quote_characters;
  return r;
}
warning: parse error {
  char *r;

  r = (char *)xmalloc (strlen (s) + 2);
  *r = *rl_completer_quote_characters;
  strcpy (r + 1, s);
  if (qcp)
    *qcp = *rl_completer_quote_characters;
  return r;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\complete.c:885
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\complete.c:912
parsing error 
{
  int scan, end, found_quote, delimiter, pass_next, isbrk;
  char quote_char, *brkchars;

  end = rl_point;
  found_quote = delimiter = 0;
  quote_char = '\0';

  brkchars = 0;
  if (rl_completion_word_break_hook)
    brkchars = (*rl_completion_word_break_hook) ();
  if (brkchars == 0)
    brkchars = rl_completer_word_break_characters;

  if (rl_completer_quote_characters)
    {
      /* We have a list of characters which can be used in pairs to
	 quote substrings for the completer.  Try to find the start
	 of an unclosed quoted substring. */
      /* FOUND_QUOTE is set so we know what kind of quotes we found. */
      for (scan = pass_next = 0; scan < end; scan = MB_NEXTCHAR (rl_line_buffer, scan, 1, MB_FIND_ANY))
	{
	  if (pass_next)
	    {
	      pass_next = 0;
	      continue;
	    }

	  /* Shell-like semantics for single quotes -- don't allow backslash
	     to quote anything in single quotes, especially not the closing
	     quote.  If you don't like this, take out the check on the value
	     of quote_char. */
	  if (quote_char != '\'' && rl_line_buffer[scan] == '\\')
	    {
	      pass_next = 1;
	      found_quote |= RL_QF_BACKSLASH;
	      continue;
	    }

	  if (quote_char != '\0')
	    {
	      /* Ignore everything until the matching close quote char. */
	      if (rl_line_buffer[scan] == quote_char)
		{
		  /* Found matching close.  Abandon this substring. */
		  quote_char = '\0';
		  rl_point = end;
		}
	    }
	  else if (strchr (rl_completer_quote_characters, rl_line_buffer[scan]))
	    {
	      /* Found start of a quoted substring. */
	      quote_char = rl_line_buffer[scan];
	      rl_point = scan + 1;
	      /* Shell-like quoting conventions. */
	      if (quote_char == '\'')
		found_quote |= RL_QF_SINGLE_QUOTE;
	      else if (quote_char == '"')
		found_quote |= RL_QF_DOUBLE_QUOTE;
	      else
		found_quote |= RL_QF_OTHER_QUOTE;      
	    }
	}
    }

  if (rl_point == end && quote_char == '\0')
    {
      /* We didn't find an unclosed quoted substring upon which to do
         completion, so use the word break characters to find the
         substring on which to complete. */
      while (rl_point = MB_PREVCHAR (rl_line_buffer, rl_point, MB_FIND_ANY))
	{
	  scan = rl_line_buffer[rl_point];

	  if (strchr (brkchars, scan) == 0)
	    continue;

	  /* Call the application-specific function to tell us whether
	     this word break character is quoted and should be skipped. */
	  if (rl_char_is_quoted_p && found_quote &&
	      (*rl_char_is_quoted_p) (rl_line_buffer, rl_point))
	    continue;

	  /* Convoluted code, but it avoids an n^2 algorithm with calls
	     to char_is_quoted. */
	  break;
	}
    }

  /* If we are at an unquoted word break, then advance past it. */
  scan = rl_line_buffer[rl_point];

  /* If there is an application-specific function to say whether or not
     a character is quoted and we found a quote character, let that
     function decide whether or not a character is a word break, even
     if it is found in rl_completer_word_break_characters.  Don't bother
     if we're at the end of the line, though. */
  if (scan)
    {
      if (rl_char_is_quoted_p)
	isbrk = (found_quote == 0 ||
		(*rl_char_is_quoted_p) (rl_line_buffer, rl_point) == 0) &&
		strchr (brkchars, scan) != 0;
      else
	isbrk = strchr (brkchars, scan) != 0;

      if (isbrk)
	{
	  /* If the character that caused the word break was a quoting
	     character, then remember it as the delimiter. */
	  if (rl_basic_quote_characters &&
	      strchr (rl_basic_quote_characters, scan) &&
	      (end - rl_point) > 1)
	    delimiter = scan;

	  /* If the character isn't needed to determine something special
	     about what kind of completion to perform, then advance past it. */
	  if (rl_special_prefixes == 0 || strchr (rl_special_prefixes, scan) == 0)
	    rl_point++;
	}
    }

  if (fp)
    *fp = found_quote;
  if (dp)
    *dp = delimiter;

  return (quote_char);
}
warning: parse error {
  int scan, end, found_quote, delimiter, pass_next, isbrk;
  char quote_char, *brkchars;

  end = rl_point;
  found_quote = delimiter = 0;
  quote_char = '\0';

  brkchars = 0;
  if (rl_completion_word_break_hook)
    brkchars = (*rl_completion_word_break_hook) ();
  if (brkchars == 0)
    brkchars = rl_completer_word_break_characters;

  if (rl_completer_quote_characters)
    {
      /* We have a list of characters which can be used in pairs to
	 quote substrings for the completer.  Try to find the start
	 of an unclosed quoted substring. */
      /* FOUND_QUOTE is set so we know what kind of quotes we found. */
      for (scan = pass_next = 0; scan < end; scan = MB_NEXTCHAR (rl_line_buffer, scan, 1, MB_FIND_ANY))
	{
	  if (pass_next)
	    {
	      pass_next = 0;
	      continue;
	    }

	  /* Shell-like semantics for single quotes -- don't allow backslash
	     to quote anything in single quotes, especially not the closing
	     quote.  If you don't like this, take out the check on the value
	     of quote_char. */
	  if (quote_char != '\'' && rl_line_buffer[scan] == '\\')
	    {
	      pass_next = 1;
	      found_quote |= RL_QF_BACKSLASH;
	      continue;
	    }

	  if (quote_char != '\0')
	    {
	      /* Ignore everything until the matching close quote char. */
	      if (rl_line_buffer[scan] == quote_char)
		{
		  /* Found matching close.  Abandon this substring. */
		  quote_char = '\0';
		  rl_point = end;
		}
	    }
	  else if (strchr (rl_completer_quote_characters, rl_line_buffer[scan]))
	    {
	      /* Found start of a quoted substring. */
	      quote_char = rl_line_buffer[scan];
	      rl_point = scan + 1;
	      /* Shell-like quoting conventions. */
	      if (quote_char == '\'')
		found_quote |= RL_QF_SINGLE_QUOTE;
	      else if (quote_char == '"')
		found_quote |= RL_QF_DOUBLE_QUOTE;
	      else
		found_quote |= RL_QF_OTHER_QUOTE;      
	    }
	}
    }

  if (rl_point == end && quote_char == '\0')
    {
      /* We didn't find an unclosed quoted substring upon which to do
         completion, so use the word break characters to find the
         substring on which to complete. */
      while (rl_point = MB_PREVCHAR (rl_line_buffer, rl_point, MB_FIND_ANY))
	{
	  scan = rl_line_buffer[rl_point];

	  if (strchr (brkchars, scan) == 0)
	    continue;

	  /* Call the application-specific function to tell us whether
	     this word break character is quoted and should be skipped. */
	  if (rl_char_is_quoted_p && found_quote &&
	      (*rl_char_is_quoted_p) (rl_line_buffer, rl_point))
	    continue;

	  /* Convoluted code, but it avoids an n^2 algorithm with calls
	     to char_is_quoted. */
	  break;
	}
    }

  /* If we are at an unquoted word break, then advance past it. */
  scan = rl_line_buffer[rl_point];

  /* If there is an application-specific function to say whether or not
     a character is quoted and we found a quote character, let that
     function decide whether or not a character is a word break, even
     if it is found in rl_completer_word_break_characters.  Don't bother
     if we're at the end of the line, though. */
  if (scan)
    {
      if (rl_char_is_quoted_p)
	isbrk = (found_quote == 0 ||
		(*rl_char_is_quoted_p) (rl_line_buffer, rl_point) == 0) &&
		strchr (brkchars, scan) != 0;
      else
	isbrk = strchr (brkchars, scan) != 0;

      if (isbrk)
	{
	  /* If the character that caused the word break was a quoting
	     character, then remember it as the delimiter. */
	  if (rl_basic_quote_characters &&
	      strchr (rl_basic_quote_characters, scan) &&
	      (end - rl_point) > 1)
	    delimiter = scan;

	  /* If the character isn't needed to determine something special
	     about what kind of completion to perform, then advance past it. */
	  if (rl_special_prefixes == 0 || strchr (rl_special_prefixes, scan) == 0)
	    rl_point++;
	}
    }

  if (fp)
    *fp = found_quote;
  if (dp)
    *dp = delimiter;

  return (quote_char);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\complete.c:914
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\complete.c:1,045
parsing error 
{
  char **matches;

  rl_completion_found_quote = found_quote;
  rl_completion_quote_character = quote_char;

  /* If the user wants to TRY to complete, but then wants to give
     up and use the default completion function, they set the
     variable rl_attempted_completion_function. */
  if (rl_attempted_completion_function)
    {
      _rl_interrupt_immediately++;
      matches = (*rl_attempted_completion_function) (text, start, end);
      if (_rl_interrupt_immediately > 0)
	_rl_interrupt_immediately--;

      if (matches || rl_attempted_completion_over)
	{
	  rl_attempted_completion_over = 0;
	  return (matches);
	}
    }

  /* XXX -- filename dequoting moved into rl_filename_completion_function */

  matches = rl_completion_matches (text, our_func);
  return matches;  
}
warning: parse error {
  char **matches;

  rl_completion_found_quote = found_quote;
  rl_completion_quote_character = quote_char;

  /* If the user wants to TRY to complete, but then wants to give
     up and use the default completion function, they set the
     variable rl_attempted_completion_function. */
  if (rl_attempted_completion_function)
    {
      _rl_interrupt_immediately++;
      matches = (*rl_attempted_completion_function) (text, start, end);
      if (_rl_interrupt_immediately > 0)
	_rl_interrupt_immediately--;

      if (matches || rl_attempted_completion_over)
	{
	  rl_attempted_completion_over = 0;
	  return (matches);
	}
    }

  /* XXX -- filename dequoting moved into rl_filename_completion_function */

  matches = rl_completion_matches (text, our_func);
  return matches;  
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\complete.c:1,050
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\complete.c:1,082
parsing error 
{
  char *lowest_common;
  int i, j, newlen;
  char dead_slot;
  char **temp_array;

  /* Sort the items. */
  for (i = 0; matches[i]; i++)
    ;

  /* Sort the array without matches[0], since we need it to
     stay in place no matter what. */
  if (i && rl_sort_completion_matches)
    qsort (matches+1, i-1, sizeof (char *), (QSFUNC *)_rl_qsort_string_compare);

  /* Remember the lowest common denominator for it may be unique. */
  lowest_common = savestring (matches[0]);

  for (i = newlen = 0; matches[i + 1]; i++)
    {
      if (strcmp (matches[i], matches[i + 1]) == 0)
	{
	  xfree (matches[i]);
	  matches[i] = (char *)&dead_slot;
	}
      else
	newlen++;
    }

  /* We have marked all the dead slots with (char *)&dead_slot.
     Copy all the non-dead entries into a new array. */
  temp_array = (char **)xmalloc ((3 + newlen) * sizeof (char *));
  for (i = j = 1; matches[i]; i++)
    {
      if (matches[i] != (char *)&dead_slot)
	temp_array[j++] = matches[i];
    }
  temp_array[j] = (char *)NULL;

  if (matches[0] != (char *)&dead_slot)
    xfree (matches[0]);

  /* Place the lowest common denominator back in [0]. */
  temp_array[0] = lowest_common;

  /* If there is one string left, and it is identical to the
     lowest common denominator, then the LCD is the string to
     insert. */
  if (j == 2 && strcmp (temp_array[0], temp_array[1]) == 0)
    {
      xfree (temp_array[1]);
      temp_array[1] = (char *)NULL;
    }
  return (temp_array);
}
warning: parse error {
  char *lowest_common;
  int i, j, newlen;
  char dead_slot;
  char **temp_array;

  /* Sort the items. */
  for (i = 0; matches[i]; i++)
    ;

  /* Sort the array without matches[0], since we need it to
     stay in place no matter what. */
  if (i && rl_sort_completion_matches)
    qsort (matches+1, i-1, sizeof (char *), (QSFUNC *)_rl_qsort_string_compare);

  /* Remember the lowest common denominator for it may be unique. */
  lowest_common = savestring (matches[0]);

  for (i = newlen = 0; matches[i + 1]; i++)
    {
      if (strcmp (matches[i], matches[i + 1]) == 0)
	{
	  xfree (matches[i]);
	  matches[i] = (char *)&dead_slot;
	}
      else
	newlen++;
    }

  /* We have marked all the dead slots with (char *)&dead_slot.
     Copy all the non-dead entries into a new array. */
  temp_array = (char **)xmalloc ((3 + newlen) * sizeof (char *));
  for (i = j = 1; matches[i]; i++)
    {
      if (matches[i] != (char *)&dead_slot)
	temp_array[j++] = matches[i];
    }
  temp_array[j] = (char *)NULL;

  if (matches[0] != (char *)&dead_slot)
    xfree (matches[0]);

  /* Place the lowest common denominator back in [0]. */
  temp_array[0] = lowest_common;

  /* If there is one string left, and it is identical to the
     lowest common denominator, then the LCD is the string to
     insert. */
  if (j == 2 && strcmp (temp_array[0], temp_array[1]) == 0)
    {
      xfree (temp_array[1]);
      temp_array[1] = (char *)NULL;
    }
  return (temp_array);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\complete.c:1,084
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\complete.c:1,143
parsing error 
{
  register int i, c1, c2, si;
  int low;		/* Count of max-matched characters. */
  char *dtext;		/* dequoted TEXT, if needed */
#if defined (HANDLE_MULTIBYTE)
  int v;
  mbstate_t ps1, ps2;
  wchar_t wc1, wc2;
#endif

  /* If only one match, just use that.  Otherwise, compare each
     member of the list with the next, finding out where they
     stop matching. */
  if (matches == 1)
    {
      match_list[0] = match_list[1];
      match_list[1] = (char *)NULL;
      return 1;
    }

  for (i = 1, low = 100000; i < matches; i++)
    {
#if defined (HANDLE_MULTIBYTE)
      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
	{
	  memset (&ps1, 0, sizeof (mbstate_t));
	  memset (&ps2, 0, sizeof (mbstate_t));
	}
#endif
      if (_rl_completion_case_fold)
	{
	  for (si = 0;
	       (c1 = _rl_to_lower(match_list[i][si])) &&
	       (c2 = _rl_to_lower(match_list[i + 1][si]));
	       si++)
#if defined (HANDLE_MULTIBYTE)
	    if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
	      {
		v = mbrtowc (&wc1, match_list[i]+si, strlen (match_list[i]+si), &ps1);
		mbrtowc (&wc2, match_list[i+1]+si, strlen (match_list[i+1]+si), &ps2);
		wc1 = towlower (wc1);
		wc2 = towlower (wc2);
		if (wc1 != wc2)
		  break;
		else if (v > 1)
		  si += v - 1;
	      }
	    else
#endif
	    if (c1 != c2)
	      break;
	}
      else
	{
	  for (si = 0;
	       (c1 = match_list[i][si]) &&
	       (c2 = match_list[i + 1][si]);
	       si++)
#if defined (HANDLE_MULTIBYTE)
	    if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
	      {
		mbstate_t ps_back;
		ps_back = ps1;
		if (!_rl_compare_chars (match_list[i], si, &ps1, match_list[i+1], si, &ps2))
		  break;
		else if ((v = _rl_get_char_len (&match_list[i][si], &ps_back)) > 1)
		  si += v - 1;
	      }
	    else
#endif
	    if (c1 != c2)
	      break;
	}

      if (low > si)
	low = si;
    }

  /* If there were multiple matches, but none matched up to even the
     first character, and the user typed something, use that as the
     value of matches[0]. */
  if (low == 0 && text && *text)
    {
      match_list[0] = (char *)xmalloc (strlen (text) + 1);
      strcpy (match_list[0], text);
    }
  else
    {
      match_list[0] = (char *)xmalloc (low + 1);

      /* XXX - this might need changes in the presence of multibyte chars */

      /* If we are ignoring case, try to preserve the case of the string
	 the user typed in the face of multiple matches differing in case. */
      if (_rl_completion_case_fold)
	{
	  /* We're making an assumption here:
		IF we're completing filenames AND
		   the application has defined a filename dequoting function AND
		   we found a quote character AND
		   the application has requested filename quoting
		THEN
		   we assume that TEXT was dequoted before checking against
		   the file system and needs to be dequoted here before we
		   check against the list of matches
		FI */
	  dtext = (char *)NULL;
	  if (rl_filename_completion_desired &&
	      rl_filename_dequoting_function &&
	      rl_completion_found_quote &&
	      rl_filename_quoting_desired)
	    {
	      dtext = (*rl_filename_dequoting_function) ((char *)text, rl_completion_quote_character);
	      text = dtext;
	    }

	  /* sort the list to get consistent answers. */
	  qsort (match_list+1, matches, sizeof(char *), (QSFUNC *)_rl_qsort_string_compare);

	  si = strlen (text);
	  if (si <= low)
	    {
	      for (i = 1; i <= matches; i++)
		if (strncmp (match_list[i], text, si) == 0)
		  {
		    strncpy (match_list[0], match_list[i], low);
		    break;
		  }
	      /* no casematch, use first entry */
	      if (i > matches)
		strncpy (match_list[0], match_list[1], low);
	    }
	  else
	    /* otherwise, just use the text the user typed. */
	    strncpy (match_list[0], text, low);

	  FREE (dtext);
	}
      else
        strncpy (match_list[0], match_list[1], low);

      match_list[0][low] = '\0';
    }

  return matches;
}
warning: parse error {
  register int i, c1, c2, si;
  int low;		/* Count of max-matched characters. */
  char *dtext;		/* dequoted TEXT, if needed */
#if defined (HANDLE_MULTIBYTE)
  int v;
  mbstate_t ps1, ps2;
  wchar_t wc1, wc2;
#endif

  /* If only one match, just use that.  Otherwise, compare each
     member of the list with the next, finding out where they
     stop matching. */
  if (matches == 1)
    {
      match_list[0] = match_list[1];
      match_list[1] = (char *)NULL;
      return 1;
    }

  for (i = 1, low = 100000; i < matches; i++)
    {
#if defined (HANDLE_MULTIBYTE)
      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
	{
	  memset (&ps1, 0, sizeof (mbstate_t));
	  memset (&ps2, 0, sizeof (mbstate_t));
	}
#endif
      if (_rl_completion_case_fold)
	{
	  for (si = 0;
	       (c1 = _rl_to_lower(match_list[i][si])) &&
	       (c2 = _rl_to_lower(match_list[i + 1][si]));
	       si++)
#if defined (HANDLE_MULTIBYTE)
	    if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
	      {
		v = mbrtowc (&wc1, match_list[i]+si, strlen (match_list[i]+si), &ps1);
		mbrtowc (&wc2, match_list[i+1]+si, strlen (match_list[i+1]+si), &ps2);
		wc1 = towlower (wc1);
		wc2 = towlower (wc2);
		if (wc1 != wc2)
		  break;
		else if (v > 1)
		  si += v - 1;
	      }
	    else
#endif
	    if (c1 != c2)
	      break;
	}
      else
	{
	  for (si = 0;
	       (c1 = match_list[i][si]) &&
	       (c2 = match_list[i + 1][si]);
	       si++)
#if defined (HANDLE_MULTIBYTE)
	    if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
	      {
		mbstate_t ps_back;
		ps_back = ps1;
		if (!_rl_compare_chars (match_list[i], si, &ps1, match_list[i+1], si, &ps2))
		  break;
		else if ((v = _rl_get_char_len (&match_list[i][si], &ps_back)) > 1)
		  si += v - 1;
	      }
	    else
#endif
	    if (c1 != c2)
	      break;
	}

      if (low > si)
	low = si;
    }

  /* If there were multiple matches, but none matched up to even the
     first character, and the user typed something, use that as the
     value of matches[0]. */
  if (low == 0 && text && *text)
    {
      match_list[0] = (char *)xmalloc (strlen (text) + 1);
      strcpy (match_list[0], text);
    }
  else
    {
      match_list[0] = (char *)xmalloc (low + 1);

      /* XXX - this might need changes in the presence of multibyte chars */

      /* If we are ignoring case, try to preserve the case of the string
	 the user typed in the face of multiple matches differing in case. */
      if (_rl_completion_case_fold)
	{
	  /* We're making an assumption here:
		IF we're completing filenames AND
		   the application has defined a filename dequoting function AND
		   we found a quote character AND
		   the application has requested filename quoting
		THEN
		   we assume that TEXT was dequoted before checking against
		   the file system and needs to be dequoted here before we
		   check against the list of matches
		FI */
	  dtext = (char *)NULL;
	  if (rl_filename_completion_desired &&
	      rl_filename_dequoting_function &&
	      rl_completion_found_quote &&
	      rl_filename_quoting_desired)
	    {
	      dtext = (*rl_filename_dequoting_function) ((char *)text, rl_completion_quote_character);
	      text = dtext;
	    }

	  /* sort the list to get consistent answers. */
	  qsort (match_list+1, matches, sizeof(char *), (QSFUNC *)_rl_qsort_string_compare);

	  si = strlen (text);
	  if (si <= low)
	    {
	      for (i = 1; i <= matches; i++)
		if (strncmp (match_list[i], text, si) == 0)
		  {
		    strncpy (match_list[0], match_list[i], low);
		    break;
		  }
	      /* no casematch, use first entry */
	      if (i > matches)
		strncpy (match_list[0], match_list[1], low);
	    }
	  else
	    /* otherwise, just use the text the user typed. */
	    strncpy (match_list[0], text, low);

	  FREE (dtext);
	}
      else
        strncpy (match_list[0], match_list[1], low);

      match_list[0][low] = '\0';
    }

  return matches;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\complete.c:1,147
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\complete.c:1,295
parsing error 
{
  char *t, **matches, **temp_matches;
  int nmatch, i;

  matches = *matchesp;

  if (matches == 0)
    return 0;

  /* It seems to me that in all the cases we handle we would like
     to ignore duplicate possiblilities.  Scan for the text to
     insert being identical to the other completions. */
  if (rl_ignore_completion_duplicates)
    {
      temp_matches = remove_duplicate_matches (matches);
      xfree (matches);
      matches = temp_matches;
    }

  /* If we are matching filenames, then here is our chance to
     do clever processing by re-examining the list.  Call the
     ignore function with the array as a parameter.  It can
     munge the array, deleting matches as it desires. */
  if (rl_ignore_some_completions_function && matching_filenames)
    {
      for (nmatch = 1; matches[nmatch]; nmatch++)
	;
      (void)(*rl_ignore_some_completions_function) (matches);
      if (matches == 0 || matches[0] == 0)
	{
	  FREE (matches);
	  *matchesp = (char **)0;
	  return 0;
        }
      else
	{
	  /* If we removed some matches, recompute the common prefix. */
	  for (i = 1; matches[i]; i++)
	    ;
	  if (i > 1 && i < nmatch)
	    {
	      t = matches[0];
	      compute_lcd_of_matches (matches, i - 1, t);
	      FREE (t);
	    }
	}
    }

  *matchesp = matches;
  return (1);
}
warning: parse error {
  char *t, **matches, **temp_matches;
  int nmatch, i;

  matches = *matchesp;

  if (matches == 0)
    return 0;

  /* It seems to me that in all the cases we handle we would like
     to ignore duplicate possiblilities.  Scan for the text to
     insert being identical to the other completions. */
  if (rl_ignore_completion_duplicates)
    {
      temp_matches = remove_duplicate_matches (matches);
      xfree (matches);
      matches = temp_matches;
    }

  /* If we are matching filenames, then here is our chance to
     do clever processing by re-examining the list.  Call the
     ignore function with the array as a parameter.  It can
     munge the array, deleting matches as it desires. */
  if (rl_ignore_some_completions_function && matching_filenames)
    {
      for (nmatch = 1; matches[nmatch]; nmatch++)
	;
      (void)(*rl_ignore_some_completions_function) (matches);
      if (matches == 0 || matches[0] == 0)
	{
	  FREE (matches);
	  *matchesp = (char **)0;
	  return 0;
        }
      else
	{
	  /* If we removed some matches, recompute the common prefix. */
	  for (i = 1; matches[i]; i++)
	    ;
	  if (i > 1 && i < nmatch)
	    {
	      t = matches[0];
	      compute_lcd_of_matches (matches, i - 1, t);
	      FREE (t);
	    }
	}
    }

  *matchesp = matches;
  return (1);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\complete.c:1,298
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\complete.c:1,372
parsing error 
{
  int count, limit, printed_len, lines, cols;
  int i, j, k, l, common_length, sind;
  char *temp, *t;

  /* Find the length of the prefix common to all items: length as displayed
     characters (common_length) and as a byte index into the matches (sind) */
  common_length = sind = 0;
  if (_rl_completion_prefix_display_length > 0)
    {
      t = printable_part (matches[0]);
      temp = strrchr (t, '/');
      common_length = temp ? fnwidth (temp) : fnwidth (t);
      sind = temp ? strlen (temp) : strlen (t);

      if (common_length > _rl_completion_prefix_display_length && common_length > ELLIPSIS_LEN)
	max -= common_length - ELLIPSIS_LEN;
      else
	common_length = sind = 0;
    }

  /* How many items of MAX length can we fit in the screen window? */
  cols = complete_get_screenwidth ();
  max += 2;
  limit = cols / max;
  if (limit != 1 && (limit * max == cols))
    limit--;

  /* If cols == 0, limit will end up -1 */
  if (cols < _rl_screenwidth && limit < 0)
    limit = 1;

  /* Avoid a possible floating exception.  If max > cols,
     limit will be 0 and a divide-by-zero fault will result. */
  if (limit == 0)
    limit = 1;

  /* How many iterations of the printing loop? */
  count = (len + (limit - 1)) / limit;

  /* Watch out for special case.  If LEN is less than LIMIT, then
     just do the inner printing loop.
	   0 < len <= limit  implies  count = 1. */

  /* Sort the items if they are not already sorted. */
  if (rl_ignore_completion_duplicates == 0 && rl_sort_completion_matches)
    qsort (matches + 1, len, sizeof (char *), (QSFUNC *)_rl_qsort_string_compare);

  rl_crlf ();

  lines = 0;
  if (_rl_print_completions_horizontally == 0)
    {
      /* Print the sorted items, up-and-down alphabetically, like ls. */
      for (i = 1; i <= count; i++)
	{
	  for (j = 0, l = i; j < limit; j++)
	    {
	      if (l > len || matches[l] == 0)
		break;
	      else
		{
		  temp = printable_part (matches[l]);
		  printed_len = print_filename (temp, matches[l], sind);

		  if (j + 1 < limit)
		    for (k = 0; k < max - printed_len; k++)
		      putc (' ', rl_outstream);
		}
	      l += count;
	    }
	  rl_crlf ();
	  lines++;
	  if (_rl_page_completions && lines >= (_rl_screenheight - 1) && i < count)
	    {
	      lines = _rl_internal_pager (lines);
	      if (lines < 0)
		return;
	    }
	}
    }
  else
    {
      /* Print the sorted items, across alphabetically, like ls -x. */
      for (i = 1; matches[i]; i++)
	{
	  temp = printable_part (matches[i]);
	  printed_len = print_filename (temp, matches[i], sind);
	  /* Have we reached the end of this line? */
	  if (matches[i+1])
	    {
	      if (i && (limit > 1) && (i % limit) == 0)
		{
		  rl_crlf ();
		  lines++;
		  if (_rl_page_completions && lines >= _rl_screenheight - 1)
		    {
		      lines = _rl_internal_pager (lines);
		      if (lines < 0)
			return;
		    }
		}
	      else
		for (k = 0; k < max - printed_len; k++)
		  putc (' ', rl_outstream);
	    }
	}
      rl_crlf ();
    }
}
warning: parse error {
  int count, limit, printed_len, lines, cols;
  int i, j, k, l, common_length, sind;
  char *temp, *t;

  /* Find the length of the prefix common to all items: length as displayed
     characters (common_length) and as a byte index into the matches (sind) */
  common_length = sind = 0;
  if (_rl_completion_prefix_display_length > 0)
    {
      t = printable_part (matches[0]);
      temp = strrchr (t, '/');
      common_length = temp ? fnwidth (temp) : fnwidth (t);
      sind = temp ? strlen (temp) : strlen (t);

      if (common_length > _rl_completion_prefix_display_length && common_length > ELLIPSIS_LEN)
	max -= common_length - ELLIPSIS_LEN;
      else
	common_length = sind = 0;
    }

  /* How many items of MAX length can we fit in the screen window? */
  cols = complete_get_screenwidth ();
  max += 2;
  limit = cols / max;
  if (limit != 1 && (limit * max == cols))
    limit--;

  /* If cols == 0, limit will end up -1 */
  if (cols < _rl_screenwidth && limit < 0)
    limit = 1;

  /* Avoid a possible floating exception.  If max > cols,
     limit will be 0 and a divide-by-zero fault will result. */
  if (limit == 0)
    limit = 1;

  /* How many iterations of the printing loop? */
  count = (len + (limit - 1)) / limit;

  /* Watch out for special case.  If LEN is less than LIMIT, then
     just do the inner printing loop.
	   0 < len <= limit  implies  count = 1. */

  /* Sort the items if they are not already sorted. */
  if (rl_ignore_completion_duplicates == 0 && rl_sort_completion_matches)
    qsort (matches + 1, len, sizeof (char *), (QSFUNC *)_rl_qsort_string_compare);

  rl_crlf ();

  lines = 0;
  if (_rl_print_completions_horizontally == 0)
    {
      /* Print the sorted items, up-and-down alphabetically, like ls. */
      for (i = 1; i <= count; i++)
	{
	  for (j = 0, l = i; j < limit; j++)
	    {
	      if (l > len || matches[l] == 0)
		break;
	      else
		{
		  temp = printable_part (matches[l]);
		  printed_len = print_filename (temp, matches[l], sind);

		  if (j + 1 < limit)
		    for (k = 0; k < max - printed_len; k++)
		      putc (' ', rl_outstream);
		}
	      l += count;
	    }
	  rl_crlf ();
	  lines++;
	  if (_rl_page_completions && lines >= (_rl_screenheight - 1) && i < count)
	    {
	      lines = _rl_internal_pager (lines);
	      if (lines < 0)
		return;
	    }
	}
    }
  else
    {
      /* Print the sorted items, across alphabetically, like ls -x. */
      for (i = 1; matches[i]; i++)
	{
	  temp = printable_part (matches[i]);
	  printed_len = print_filename (temp, matches[i], sind);
	  /* Have we reached the end of this line? */
	  if (matches[i+1])
	    {
	      if (i && (limit > 1) && (i % limit) == 0)
		{
		  rl_crlf ();
		  lines++;
		  if (_rl_page_completions && lines >= _rl_screenheight - 1)
		    {
		      lines = _rl_internal_pager (lines);
		      if (lines < 0)
			return;
		    }
		}
	      else
		for (k = 0; k < max - printed_len; k++)
		  putc (' ', rl_outstream);
	    }
	}
      rl_crlf ();
    }
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\complete.c:1,375
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\complete.c:1,498
parsing error 
{
  int len, max, i;
  char *temp;

  /* Move to the last visible line of a possibly-multiple-line command. */
  _rl_move_vert (_rl_vis_botlin);

  /* Handle simple case first.  What if there is only one answer? */
  if (matches[1] == 0)
    {
      temp = printable_part (matches[0]);
      rl_crlf ();
      print_filename (temp, matches[0], 0);
      rl_crlf ();

      rl_forced_update_display ();
      rl_display_fixed = 1;

      return;
    }

  /* There is more than one answer.  Find out how many there are,
     and find the maximum printed length of a single entry. */
  for (max = 0, i = 1; matches[i]; i++)
    {
      temp = printable_part (matches[i]);
      len = fnwidth (temp);

      if (len > max)
	max = len;
    }

  len = i - 1;

  /* If the caller has defined a display hook, then call that now. */
  if (rl_completion_display_matches_hook)
    {
      (*rl_completion_display_matches_hook) (matches, len, max);
      return;
    }
	
  /* If there are many items, then ask the user if she really wants to
     see them all. */
  if (rl_completion_query_items > 0 && len >= rl_completion_query_items)
    {
      rl_crlf ();
      fprintf (rl_outstream, "Display all %d possibilities? (y or n)", len);
      fflush (rl_outstream);
      if ((completion_y_or_n = get_y_or_n (0)) == 0)
	{
	  rl_crlf ();

	  rl_forced_update_display ();
	  rl_display_fixed = 1;

	  return;
	}
    }

  rl_display_match_list (matches, len, max);

  rl_forced_update_display ();
  rl_display_fixed = 1;
}
warning: parse error {
  int len, max, i;
  char *temp;

  /* Move to the last visible line of a possibly-multiple-line command. */
  _rl_move_vert (_rl_vis_botlin);

  /* Handle simple case first.  What if there is only one answer? */
  if (matches[1] == 0)
    {
      temp = printable_part (matches[0]);
      rl_crlf ();
      print_filename (temp, matches[0], 0);
      rl_crlf ();

      rl_forced_update_display ();
      rl_display_fixed = 1;

      return;
    }

  /* There is more than one answer.  Find out how many there are,
     and find the maximum printed length of a single entry. */
  for (max = 0, i = 1; matches[i]; i++)
    {
      temp = printable_part (matches[i]);
      len = fnwidth (temp);

      if (len > max)
	max = len;
    }

  len = i - 1;

  /* If the caller has defined a display hook, then call that now. */
  if (rl_completion_display_matches_hook)
    {
      (*rl_completion_display_matches_hook) (matches, len, max);
      return;
    }
	
  /* If there are many items, then ask the user if she really wants to
     see them all. */
  if (rl_completion_query_items > 0 && len >= rl_completion_query_items)
    {
      rl_crlf ();
      fprintf (rl_outstream, "Display all %d possibilities? (y or n)", len);
      fflush (rl_outstream);
      if ((completion_y_or_n = get_y_or_n (0)) == 0)
	{
	  rl_crlf ();

	  rl_forced_update_display ();
	  rl_display_fixed = 1;

	  return;
	}
    }

  rl_display_match_list (matches, len, max);

  rl_forced_update_display ();
  rl_display_fixed = 1;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\complete.c:1,500
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\complete.c:1,566
parsing error 
{
  int should_quote, do_replace;
  char *replacement;

  /* If we are doing completion on quoted substrings, and any matches
     contain any of the completer_word_break_characters, then auto-
     matically prepend the substring with a quote character (just pick
     the first one from the list of such) if it does not already begin
     with a quote string.  FIXME: Need to remove any such automatically
     inserted quote character when it no longer is necessary, such as
     if we change the string we are completing on and the new set of
     matches don't require a quoted substring. */
  replacement = match;

  should_quote = match && rl_completer_quote_characters &&
			rl_filename_completion_desired &&
			rl_filename_quoting_desired;

  if (should_quote)
    should_quote = should_quote && (!qc || !*qc ||
		     (rl_completer_quote_characters && strchr (rl_completer_quote_characters, *qc)));

  if (should_quote)
    {
      /* If there is a single match, see if we need to quote it.
         This also checks whether the common prefix of several
	 matches needs to be quoted. */
      should_quote = rl_filename_quote_characters
			? (_rl_strpbrk (match, rl_filename_quote_characters) != 0)
			: 0;

      do_replace = should_quote ? mtype : NO_MATCH;
      /* Quote the replacement, since we found an embedded
	 word break character in a potential match. */
      if (do_replace != NO_MATCH && rl_filename_quoting_function)
	replacement = (*rl_filename_quoting_function) (match, do_replace, qc);
    }
  return (replacement);
}
warning: parse error {
  int should_quote, do_replace;
  char *replacement;

  /* If we are doing completion on quoted substrings, and any matches
     contain any of the completer_word_break_characters, then auto-
     matically prepend the substring with a quote character (just pick
     the first one from the list of such) if it does not already begin
     with a quote string.  FIXME: Need to remove any such automatically
     inserted quote character when it no longer is necessary, such as
     if we change the string we are completing on and the new set of
     matches don't require a quoted substring. */
  replacement = match;

  should_quote = match && rl_completer_quote_characters &&
			rl_filename_completion_desired &&
			rl_filename_quoting_desired;

  if (should_quote)
    should_quote = should_quote && (!qc || !*qc ||
		     (rl_completer_quote_characters && strchr (rl_completer_quote_characters, *qc)));

  if (should_quote)
    {
      /* If there is a single match, see if we need to quote it.
         This also checks whether the common prefix of several
	 matches needs to be quoted. */
      should_quote = rl_filename_quote_characters
			? (_rl_strpbrk (match, rl_filename_quote_characters) != 0)
			: 0;

      do_replace = should_quote ? mtype : NO_MATCH;
      /* Quote the replacement, since we found an embedded
	 word break character in a potential match. */
      if (do_replace != NO_MATCH && rl_filename_quoting_function)
	replacement = (*rl_filename_quoting_function) (match, do_replace, qc);
    }
  return (replacement);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\complete.c:1,570
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\complete.c:1,611
parsing error 
{
  char *replacement, *r;
  char oqc;
  int end, rlen;

  oqc = qc ? *qc : '\0';
  replacement = make_quoted_replacement (match, mtype, qc);

  /* Now insert the match. */
  if (replacement)
    {
      rlen = strlen (replacement);
      /* Don't double an opening quote character. */
      if (qc && *qc && start && rl_line_buffer[start - 1] == *qc &&
	    replacement[0] == *qc)
	start--;
      /* If make_quoted_replacement changed the quoting character, remove
	 the opening quote and insert the (fully-quoted) replacement. */
      else if (qc && (*qc != oqc) && start && rl_line_buffer[start - 1] == oqc &&
	    replacement[0] != oqc)
	start--;
      end = rl_point - 1;
      /* Don't double a closing quote character */
      if (qc && *qc && end && rl_line_buffer[rl_point] == *qc && replacement[rlen - 1] == *qc)
        end++;
      if (_rl_skip_completed_text)
	{
	  r = replacement;
	  while (start < rl_end && *r && rl_line_buffer[start] == *r)
	    {
	      start++;
	      r++;
	    }
	  if (start <= end || *r)
	    _rl_replace_text (r, start, end);
	  rl_point = start + strlen (r);
	}
      else
	_rl_replace_text (replacement, start, end);
      if (replacement != match)
        xfree (replacement);
    }
}
warning: parse error {
  char *replacement, *r;
  char oqc;
  int end, rlen;

  oqc = qc ? *qc : '\0';
  replacement = make_quoted_replacement (match, mtype, qc);

  /* Now insert the match. */
  if (replacement)
    {
      rlen = strlen (replacement);
      /* Don't double an opening quote character. */
      if (qc && *qc && start && rl_line_buffer[start - 1] == *qc &&
	    replacement[0] == *qc)
	start--;
      /* If make_quoted_replacement changed the quoting character, remove
	 the opening quote and insert the (fully-quoted) replacement. */
      else if (qc && (*qc != oqc) && start && rl_line_buffer[start - 1] == oqc &&
	    replacement[0] != oqc)
	start--;
      end = rl_point - 1;
      /* Don't double a closing quote character */
      if (qc && *qc && end && rl_line_buffer[rl_point] == *qc && replacement[rlen - 1] == *qc)
        end++;
      if (_rl_skip_completed_text)
	{
	  r = replacement;
	  while (start < rl_end && *r && rl_line_buffer[start] == *r)
	    {
	      start++;
	      r++;
	    }
	  if (start <= end || *r)
	    _rl_replace_text (r, start, end);
	  rl_point = start + strlen (r);
	}
      else
	_rl_replace_text (replacement, start, end);
      if (replacement != match)
        xfree (replacement);
    }
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\complete.c:1,615
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\complete.c:1,671
parsing error 
{
  char temp_string[4], *filename;
  int temp_string_index, s;
  struct stat finfo;

  temp_string_index = 0;
  if (quote_char && rl_point && rl_completion_suppress_quote == 0 &&
      rl_line_buffer[rl_point - 1] != quote_char)
    temp_string[temp_string_index++] = quote_char;

  if (delimiter)
    temp_string[temp_string_index++] = delimiter;
  else if (rl_completion_suppress_append == 0 && rl_completion_append_character)
    temp_string[temp_string_index++] = rl_completion_append_character;

  temp_string[temp_string_index++] = '\0';

  if (rl_filename_completion_desired)
    {
      filename = tilde_expand (text);
      s = (nontrivial_match && rl_completion_mark_symlink_dirs == 0)
		? LSTAT (filename, &finfo)
		: stat (filename, &finfo);
      if (s == 0 && S_ISDIR (finfo.st_mode))
	{
	  if (_rl_complete_mark_directories /* && rl_completion_suppress_append == 0 */)
	    {
	      /* This is clumsy.  Avoid putting in a double slash if point
		 is at the end of the line and the previous character is a
		 slash. */
	      if (rl_point && rl_line_buffer[rl_point] == '\0' && rl_line_buffer[rl_point - 1] == '/')
		;
	      else if (rl_line_buffer[rl_point] != '/')
		rl_insert_text ("/");
	    }
	}
#ifdef S_ISLNK
      /* Don't add anything if the filename is a symlink and resolves to a
	 directory. */
      else if (s == 0 && S_ISLNK (finfo.st_mode) &&
	       stat (filename, &finfo) == 0 && S_ISDIR (finfo.st_mode))
	;
#endif
      else
	{
	  if (rl_point == rl_end && temp_string_index)
	    rl_insert_text (temp_string);
	}
      xfree (filename);
    }
  else
    {
      if (rl_point == rl_end && temp_string_index)
	rl_insert_text (temp_string);
    }

  return (temp_string_index);
}
warning: parse error {
  char temp_string[4], *filename;
  int temp_string_index, s;
  struct stat finfo;

  temp_string_index = 0;
  if (quote_char && rl_point && rl_completion_suppress_quote == 0 &&
      rl_line_buffer[rl_point - 1] != quote_char)
    temp_string[temp_string_index++] = quote_char;

  if (delimiter)
    temp_string[temp_string_index++] = delimiter;
  else if (rl_completion_suppress_append == 0 && rl_completion_append_character)
    temp_string[temp_string_index++] = rl_completion_append_character;

  temp_string[temp_string_index++] = '\0';

  if (rl_filename_completion_desired)
    {
      filename = tilde_expand (text);
      s = (nontrivial_match && rl_completion_mark_symlink_dirs == 0)
		? LSTAT (filename, &finfo)
		: stat (filename, &finfo);
      if (s == 0 && S_ISDIR (finfo.st_mode))
	{
	  if (_rl_complete_mark_directories /* && rl_completion_suppress_append == 0 */)
	    {
	      /* This is clumsy.  Avoid putting in a double slash if point
		 is at the end of the line and the previous character is a
		 slash. */
	      if (rl_point && rl_line_buffer[rl_point] == '\0' && rl_line_buffer[rl_point - 1] == '/')
		;
	      else if (rl_line_buffer[rl_point] != '/')
		rl_insert_text ("/");
	    }
	}
#ifdef S_ISLNK
      /* Don't add anything if the filename is a symlink and resolves to a
	 directory. */
      else if (s == 0 && S_ISLNK (finfo.st_mode) &&
	       stat (filename, &finfo) == 0 && S_ISDIR (finfo.st_mode))
	;
#endif
      else
	{
	  if (rl_point == rl_end && temp_string_index)
	    rl_insert_text (temp_string);
	}
      xfree (filename);
    }
  else
    {
      if (rl_point == rl_end && temp_string_index)
	rl_insert_text (temp_string);
    }

  return (temp_string_index);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\complete.c:1,674
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\complete.c:1,734
parsing error 
{
  int i;
  char *rp;

  rl_begin_undo_group ();
  /* remove any opening quote character; make_quoted_replacement will add
     it back. */
  if (qc && *qc && point && rl_line_buffer[point - 1] == *qc)
    point--;
  rl_delete_text (point, rl_point);
  rl_point = point;

  if (matches[1])
    {
      for (i = 1; matches[i]; i++)
	{
	  rp = make_quoted_replacement (matches[i], SINGLE_MATCH, qc);
	  rl_insert_text (rp);
	  rl_insert_text (" ");
	  if (rp != matches[i])
	    xfree (rp);
	}
    }
  else
    {
      rp = make_quoted_replacement (matches[0], SINGLE_MATCH, qc);
      rl_insert_text (rp);
      rl_insert_text (" ");
      if (rp != matches[0])
	xfree (rp);
    }
  rl_end_undo_group ();
}
warning: parse error {
  int i;
  char *rp;

  rl_begin_undo_group ();
  /* remove any opening quote character; make_quoted_replacement will add
     it back. */
  if (qc && *qc && point && rl_line_buffer[point - 1] == *qc)
    point--;
  rl_delete_text (point, rl_point);
  rl_point = point;

  if (matches[1])
    {
      for (i = 1; matches[i]; i++)
	{
	  rp = make_quoted_replacement (matches[i], SINGLE_MATCH, qc);
	  rl_insert_text (rp);
	  rl_insert_text (" ");
	  if (rp != matches[i])
	    xfree (rp);
	}
    }
  else
    {
      rp = make_quoted_replacement (matches[0], SINGLE_MATCH, qc);
      rl_insert_text (rp);
      rl_insert_text (" ");
      if (rp != matches[0])
	xfree (rp);
    }
  rl_end_undo_group ();
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\complete.c:1,738
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\complete.c:1,773
parsing error 
{
  register int i;

  if (matches == 0)
    return;

  for (i = 0; matches[i]; i++)
    xfree (matches[i]);
  xfree (matches);
}
warning: parse error {
  register int i;

  if (matches == 0)
    return;

  for (i = 0; matches[i]; i++)
    xfree (matches[i]);
  xfree (matches);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\complete.c:1,775
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\complete.c:1,796
parsing error 
{
  char **matches;
  rl_compentry_func_t *our_func;
  int start, end, delimiter, found_quote, i, nontrivial_lcd;
  char *text, *saved_line_buffer;
  char quote_char;
#if 1
  int tlen, mlen;
#endif

  RL_SETSTATE(RL_STATE_COMPLETING);

  set_completion_defaults (what_to_do);

  saved_line_buffer = rl_line_buffer ? savestring (rl_line_buffer) : (char *)NULL;
  our_func = rl_completion_entry_function
		? rl_completion_entry_function
		: rl_filename_completion_function;
  /* We now look backwards for the start of a filename/variable word. */
  end = rl_point;
  found_quote = delimiter = 0;
  quote_char = '\0';

  if (rl_point)
    /* This (possibly) changes rl_point.  If it returns a non-zero char,
       we know we have an open quote. */
    quote_char = _rl_find_completion_word (&found_quote, &delimiter);

  start = rl_point;
  rl_point = end;

  text = rl_copy_text (start, end);
  matches = gen_completion_matches (text, start, end, our_func, found_quote, quote_char);
  /* nontrivial_lcd is set if the common prefix adds something to the word
     being completed. */
  nontrivial_lcd = matches && strcmp (text, matches[0]) != 0;
#if 1
  if (what_to_do == '!' || what_to_do == '@')
    tlen = strlen (text);
#endif
  xfree (text);

  if (matches == 0)
    {
      rl_ding ();
      FREE (saved_line_buffer);
      completion_changed_buffer = 0;
      RL_UNSETSTATE(RL_STATE_COMPLETING);
      _rl_reset_completion_state ();
      return (0);
    }

  /* If we are matching filenames, the attempted completion function will
     have set rl_filename_completion_desired to a non-zero value.  The basic
     rl_filename_completion_function does this. */
  i = rl_filename_completion_desired;

  if (postprocess_matches (&matches, i) == 0)
    {
      rl_ding ();
      FREE (saved_line_buffer);
      completion_changed_buffer = 0;
      RL_UNSETSTATE(RL_STATE_COMPLETING);
      _rl_reset_completion_state ();
      return (0);
    }

  switch (what_to_do)
    {
    case TAB:
    case '!':
    case '@':
      /* Insert the first match with proper quoting. */
#if 0
      if (*matches[0])
	insert_match (matches[0], start, matches[1] ? MULT_MATCH : SINGLE_MATCH, &quote_char);
#else
      if (what_to_do == TAB)
        {
          if (*matches[0])
	    insert_match (matches[0], start, matches[1] ? MULT_MATCH : SINGLE_MATCH, &quote_char);
        }
      else if (*matches[0] && matches[1] == 0)
	/* should we perform the check only if there are multiple matches? */
	insert_match (matches[0], start, matches[1] ? MULT_MATCH : SINGLE_MATCH, &quote_char);
      else if (*matches[0])	/* what_to_do != TAB && multiple matches */
	{
	  mlen = *matches[0] ? strlen (matches[0]) : 0;
	  if (mlen >= tlen)
	    insert_match (matches[0], start, matches[1] ? MULT_MATCH : SINGLE_MATCH, &quote_char);
	}
#endif

      /* If there are more matches, ring the bell to indicate.
	 If we are in vi mode, Posix.2 says to not ring the bell.
	 If the `show-all-if-ambiguous' variable is set, display
	 all the matches immediately.  Otherwise, if this was the
	 only match, and we are hacking files, check the file to
	 see if it was a directory.  If so, and the `mark-directories'
	 variable is set, add a '/' to the name.  If not, and we
	 are at the end of the line, then add a space.  */
      if (matches[1])
	{
	  if (what_to_do == '!')
	    {
	      display_matches (matches);
	      break;
	    }
	  else if (what_to_do == '@')
	    {
	      if (nontrivial_lcd == 0)
		display_matches (matches);
	      break;
	    }
	  else if (rl_editing_mode != vi_mode)
	    rl_ding ();	/* There are other matches remaining. */
	}
      else
	append_to_match (matches[0], delimiter, quote_char, nontrivial_lcd);

      break;

    case '*':
      insert_all_matches (matches, start, &quote_char);
      break;

    case '?':
      display_matches (matches);
      break;

    default:
      _rl_ttymsg ("bad value %d for what_to_do in rl_complete", what_to_do);
      rl_ding ();
      FREE (saved_line_buffer);
      RL_UNSETSTATE(RL_STATE_COMPLETING);
      _rl_reset_completion_state ();
      return 1;
    }

  _rl_free_match_list (matches);

  /* Check to see if the line has changed through all of this manipulation. */
  if (saved_line_buffer)
    {
      completion_changed_buffer = strcmp (rl_line_buffer, saved_line_buffer) != 0;
      xfree (saved_line_buffer);
    }

  RL_UNSETSTATE(RL_STATE_COMPLETING);
  _rl_reset_completion_state ();
  return 0;
}
warning: parse error {
  char **matches;
  rl_compentry_func_t *our_func;
  int start, end, delimiter, found_quote, i, nontrivial_lcd;
  char *text, *saved_line_buffer;
  char quote_char;
#if 1
  int tlen, mlen;
#endif

  RL_SETSTATE(RL_STATE_COMPLETING);

  set_completion_defaults (what_to_do);

  saved_line_buffer = rl_line_buffer ? savestring (rl_line_buffer) : (char *)NULL;
  our_func = rl_completion_entry_function
		? rl_completion_entry_function
		: rl_filename_completion_function;
  /* We now look backwards for the start of a filename/variable word. */
  end = rl_point;
  found_quote = delimiter = 0;
  quote_char = '\0';

  if (rl_point)
    /* This (possibly) changes rl_point.  If it returns a non-zero char,
       we know we have an open quote. */
    quote_char = _rl_find_completion_word (&found_quote, &delimiter);

  start = rl_point;
  rl_point = end;

  text = rl_copy_text (start, end);
  matches = gen_completion_matches (text, start, end, our_func, found_quote, quote_char);
  /* nontrivial_lcd is set if the common prefix adds something to the word
     being completed. */
  nontrivial_lcd = matches && strcmp (text, matches[0]) != 0;
#if 1
  if (what_to_do == '!' || what_to_do == '@')
    tlen = strlen (text);
#endif
  xfree (text);

  if (matches == 0)
    {
      rl_ding ();
      FREE (saved_line_buffer);
      completion_changed_buffer = 0;
      RL_UNSETSTATE(RL_STATE_COMPLETING);
      _rl_reset_completion_state ();
      return (0);
    }

  /* If we are matching filenames, the attempted completion function will
     have set rl_filename_completion_desired to a non-zero value.  The basic
     rl_filename_completion_function does this. */
  i = rl_filename_completion_desired;

  if (postprocess_matches (&matches, i) == 0)
    {
      rl_ding ();
      FREE (saved_line_buffer);
      completion_changed_buffer = 0;
      RL_UNSETSTATE(RL_STATE_COMPLETING);
      _rl_reset_completion_state ();
      return (0);
    }

  switch (what_to_do)
    {
    case TAB:
    case '!':
    case '@':
      /* Insert the first match with proper quoting. */
#if 0
      if (*matches[0])
	insert_match (matches[0], start, matches[1] ? MULT_MATCH : SINGLE_MATCH, &quote_char);
#else
      if (what_to_do == TAB)
        {
          if (*matches[0])
	    insert_match (matches[0], start, matches[1] ? MULT_MATCH : SINGLE_MATCH, &quote_char);
        }
      else if (*matches[0] && matches[1] == 0)
	/* should we perform the check only if there are multiple matches? */
	insert_match (matches[0], start, matches[1] ? MULT_MATCH : SINGLE_MATCH, &quote_char);
      else if (*matches[0])	/* what_to_do != TAB && multiple matches */
	{
	  mlen = *matches[0] ? strlen (matches[0]) : 0;
	  if (mlen >= tlen)
	    insert_match (matches[0], start, matches[1] ? MULT_MATCH : SINGLE_MATCH, &quote_char);
	}
#endif

      /* If there are more matches, ring the bell to indicate.
	 If we are in vi mode, Posix.2 says to not ring the bell.
	 If the `show-all-if-ambiguous' variable is set, display
	 all the matches immediately.  Otherwise, if this was the
	 only match, and we are hacking files, check the file to
	 see if it was a directory.  If so, and the `mark-directories'
	 variable is set, add a '/' to the name.  If not, and we
	 are at the end of the line, then add a space.  */
      if (matches[1])
	{
	  if (what_to_do == '!')
	    {
	      display_matches (matches);
	      break;
	    }
	  else if (what_to_do == '@')
	    {
	      if (nontrivial_lcd == 0)
		display_matches (matches);
	      break;
	    }
	  else if (rl_editing_mode != vi_mode)
	    rl_ding ();	/* There are other matches remaining. */
	}
      else
	append_to_match (matches[0], delimiter, quote_char, nontrivial_lcd);

      break;

    case '*':
      insert_all_matches (matches, start, &quote_char);
      break;

    case '?':
      display_matches (matches);
      break;

    default:
      _rl_ttymsg ("bad value %d for what_to_do in rl_complete", what_to_do);
      rl_ding ();
      FREE (saved_line_buffer);
      RL_UNSETSTATE(RL_STATE_COMPLETING);
      _rl_reset_completion_state ();
      return 1;
    }

  _rl_free_match_list (matches);

  /* Check to see if the line has changed through all of this manipulation. */
  if (saved_line_buffer)
    {
      completion_changed_buffer = strcmp (rl_line_buffer, saved_line_buffer) != 0;
      xfree (saved_line_buffer);
    }

  RL_UNSETSTATE(RL_STATE_COMPLETING);
  _rl_reset_completion_state ();
  return 0;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\complete.c:1,798
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\complete.c:1,971
parsing error 
{
  /* Number of slots in match_list. */
  int match_list_size;

  /* The list of matches. */
  char **match_list;

  /* Number of matches actually found. */
  int matches;

  /* Temporary string binder. */
  char *string;

  matches = 0;
  match_list_size = 10;
  match_list = (char **)xmalloc ((match_list_size + 1) * sizeof (char *));
  match_list[1] = (char *)NULL;

  _rl_interrupt_immediately++;
  while (string = (*entry_function) (text, matches))
    {
      if (matches + 1 == match_list_size)
	match_list = (char **)xrealloc
	  (match_list, ((match_list_size += 10) + 1) * sizeof (char *));

      match_list[++matches] = string;
      match_list[matches + 1] = (char *)NULL;
    }
  if (_rl_interrupt_immediately > 0)
    _rl_interrupt_immediately--;

  /* If there were any matches, then look through them finding out the
     lowest common denominator.  That then becomes match_list[0]. */
  if (matches)
    compute_lcd_of_matches (match_list, matches, text);
  else				/* There were no matches. */
    {
      xfree (match_list);
      match_list = (char **)NULL;
    }
  return (match_list);
}
warning: parse error {
  /* Number of slots in match_list. */
  int match_list_size;

  /* The list of matches. */
  char **match_list;

  /* Number of matches actually found. */
  int matches;

  /* Temporary string binder. */
  char *string;

  matches = 0;
  match_list_size = 10;
  match_list = (char **)xmalloc ((match_list_size + 1) * sizeof (char *));
  match_list[1] = (char *)NULL;

  _rl_interrupt_immediately++;
  while (string = (*entry_function) (text, matches))
    {
      if (matches + 1 == match_list_size)
	match_list = (char **)xrealloc
	  (match_list, ((match_list_size += 10) + 1) * sizeof (char *));

      match_list[++matches] = string;
      match_list[matches + 1] = (char *)NULL;
    }
  if (_rl_interrupt_immediately > 0)
    _rl_interrupt_immediately--;

  /* If there were any matches, then look through them finding out the
     lowest common denominator.  That then becomes match_list[0]. */
  if (matches)
    compute_lcd_of_matches (match_list, matches, text);
  else				/* There were no matches. */
    {
      xfree (match_list);
      match_list = (char **)NULL;
    }
  return (match_list);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\complete.c:1,973
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\complete.c:2,021
parsing error 
{
#if defined (__WIN32__) || defined (__OPENNT)
  return (char *)NULL;
#else /* !__WIN32__ && !__OPENNT) */
  static char *username = (char *)NULL;
  static struct passwd *entry;
  static int namelen, first_char, first_char_loc;
  char *value;

  if (state == 0)
    {
      FREE (username);

      first_char = *text;
      first_char_loc = first_char == '~';

      username = savestring (&text[first_char_loc]);
      namelen = strlen (username);
      setpwent ();
    }

#if defined (HAVE_GETPWENT)
  while (entry = getpwent ())
    {
      /* Null usernames should result in all users as possible completions. */
      if (namelen == 0 || (STREQN (username, entry->pw_name, namelen)))
	break;
    }
#endif

  if (entry == 0)
    {
#if defined (HAVE_GETPWENT)
      endpwent ();
#endif
      return ((char *)NULL);
    }
  else
    {
      value = (char *)xmalloc (2 + strlen (entry->pw_name));

      *value = *text;

      strcpy (value + first_char_loc, entry->pw_name);

      if (first_char == '~')
	rl_filename_completion_desired = 1;

      return (value);
    }
#endif /* !__WIN32__ && !__OPENNT */
}
warning: parse error {
#if defined (__WIN32__) || defined (__OPENNT)
  return (char *)NULL;
#else /* !__WIN32__ && !__OPENNT) */
  static char *username = (char *)NULL;
  static struct passwd *entry;
  static int namelen, first_char, first_char_loc;
  char *value;

  if (state == 0)
    {
      FREE (username);

      first_char = *text;
      first_char_loc = first_char == '~';

      username = savestring (&text[first_char_loc]);
      namelen = strlen (username);
      setpwent ();
    }

#if defined (HAVE_GETPWENT)
  while (entry = getpwent ())
    {
      /* Null usernames should result in all users as possible completions. */
      if (namelen == 0 || (STREQN (username, entry->pw_name, namelen)))
	break;
    }
#endif

  if (entry == 0)
    {
#if defined (HAVE_GETPWENT)
      endpwent ();
#endif
      return ((char *)NULL);
    }
  else
    {
      value = (char *)xmalloc (2 + strlen (entry->pw_name));

      *value = *text;

      strcpy (value + first_char_loc, entry->pw_name);

      if (first_char == '~')
	rl_filename_completion_desired = 1;

      return (value);
    }
#endif /* !__WIN32__ && !__OPENNT */
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\complete.c:2,023
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\complete.c:2,082
parsing error 
{
  register char *s1, *s2;
  int d, len;

  /* Otherwise, if these match up to the length of filename, then
     it is a match. */
  if (_rl_completion_case_fold && _rl_completion_case_map)
    {
      /* Case-insensitive comparison treating _ and - as equivalent */
      if (filename_len == 0)
	return 1;
      if (convlen < filename_len)
	return 0;
      s1 = (char *)convfn;
      s2 = (char *)filename;
      len = filename_len;
      do
	{
	  d = _rl_to_lower (*s1) - _rl_to_lower (*s2);
	  /* *s1 == [-_] && *s2 == [-_] */
	  if ((*s1 == '-' || *s1 == '_') && (*s2 == '-' || *s2 == '_'))
	    d = 0;
	  if (d != 0)
	    return 0;
	  s1++; s2++;	/* already checked convlen >= filename_len */
	}
      while (--len != 0);
      return 1;
    }
  else if (_rl_completion_case_fold)
    {
      if ((_rl_to_lower (convfn[0]) == _rl_to_lower (filename[0])) &&
	  (convlen >= filename_len) &&
	  (_rl_strnicmp (filename, convfn, filename_len) == 0))
	return 1;
    }
  else
    {
      if ((convfn[0] == filename[0]) &&
	  (convlen >= filename_len) &&
	  (strncmp (filename, convfn, filename_len) == 0))
	return 1;
    }
  return 0;
}
warning: parse error {
  register char *s1, *s2;
  int d, len;

  /* Otherwise, if these match up to the length of filename, then
     it is a match. */
  if (_rl_completion_case_fold && _rl_completion_case_map)
    {
      /* Case-insensitive comparison treating _ and - as equivalent */
      if (filename_len == 0)
	return 1;
      if (convlen < filename_len)
	return 0;
      s1 = (char *)convfn;
      s2 = (char *)filename;
      len = filename_len;
      do
	{
	  d = _rl_to_lower (*s1) - _rl_to_lower (*s2);
	  /* *s1 == [-_] && *s2 == [-_] */
	  if ((*s1 == '-' || *s1 == '_') && (*s2 == '-' || *s2 == '_'))
	    d = 0;
	  if (d != 0)
	    return 0;
	  s1++; s2++;	/* already checked convlen >= filename_len */
	}
      while (--len != 0);
      return 1;
    }
  else if (_rl_completion_case_fold)
    {
      if ((_rl_to_lower (convfn[0]) == _rl_to_lower (filename[0])) &&
	  (convlen >= filename_len) &&
	  (_rl_strnicmp (filename, convfn, filename_len) == 0))
	return 1;
    }
  else
    {
      if ((convfn[0] == filename[0]) &&
	  (convlen >= filename_len) &&
	  (strncmp (filename, convfn, filename_len) == 0))
	return 1;
    }
  return 0;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\complete.c:2,086
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\complete.c:2,138
parsing error 
{
  static DIR *directory = (DIR *)NULL;
  static char *filename = (char *)NULL;
  static char *dirname = (char *)NULL;
  static char *users_dirname = (char *)NULL;
  static int filename_len;
  char *temp, *dentry, *convfn;
  int dirlen, dentlen, convlen;
  struct dirent *entry;

  /* If we don't have any state, then do some initialization. */
  if (state == 0)
    {
      /* If we were interrupted before closing the directory or reading
	 all of its contents, close it. */
      if (directory)
	{
	  closedir (directory);
	  directory = (DIR *)NULL;
	}
      FREE (dirname);
      FREE (filename);
      FREE (users_dirname);

      filename = savestring (text);
      if (*text == 0)
	text = ".";
      dirname = savestring (text);

      temp = strrchr (dirname, '/');

#if defined (__MSDOS__)
      /* special hack for //X/... */
      if (dirname[0] == '/' && dirname[1] == '/' && ISALPHA ((unsigned char)dirname[2]) && dirname[3] == '/')
        temp = strrchr (dirname + 3, '/');
#endif

      if (temp)
	{
	  strcpy (filename, ++temp);
	  *temp = '\0';
	}
#if defined (__MSDOS__)
      /* searches from current directory on the drive */
      else if (ISALPHA ((unsigned char)dirname[0]) && dirname[1] == ':')
        {
          strcpy (filename, dirname + 2);
          dirname[2] = '\0';
        }
#endif
      else
	{
	  dirname[0] = '.';
	  dirname[1] = '\0';
	}

      /* We aren't done yet.  We also support the "~user" syntax. */

      /* Save the version of the directory that the user typed, dequoting
	 it if necessary. */
      if (rl_completion_found_quote && rl_filename_dequoting_function)
	users_dirname = (*rl_filename_dequoting_function) (dirname, rl_completion_quote_character);
      else
	users_dirname = savestring (dirname);

      if (*dirname == '~')
	{
	  temp = tilde_expand (dirname);
	  xfree (dirname);
	  dirname = temp;
	}

      /* We have saved the possibly-dequoted version of the directory name
	 the user typed.  Now transform the directory name we're going to
	 pass to opendir(2).  The directory rewrite hook modifies only the
	 directory name; the directory completion hook modifies both the
	 directory name passed to opendir(2) and the version the user
	 typed.  Both the directory completion and rewrite hooks should perform
	 any necessary dequoting.  The hook functions return 1 if they modify
	 the directory name argument.  If either hook returns 0, it should
	 not modify the directory name pointer passed as an argument. */
      if (rl_directory_rewrite_hook)
	(*rl_directory_rewrite_hook) (&dirname);
      else if (rl_directory_completion_hook && (*rl_directory_completion_hook) (&dirname))
	{
	  xfree (users_dirname);
	  users_dirname = savestring (dirname);
	}
      else if (rl_completion_found_quote && rl_filename_dequoting_function)
	{
	  /* delete single and double quotes */
	  xfree (dirname);
	  dirname = savestring (users_dirname);
	}
      directory = opendir (dirname);

      /* Now dequote a non-null filename. */
      if (filename && *filename && rl_completion_found_quote && rl_filename_dequoting_function)
	{
	  /* delete single and double quotes */
	  temp = (*rl_filename_dequoting_function) (filename, rl_completion_quote_character);
	  xfree (filename);
	  filename = temp;
	}
      filename_len = strlen (filename);

      rl_filename_completion_desired = 1;
    }

  /* At this point we should entertain the possibility of hacking wildcarded
     filenames, like /usr/man/man<WILD>/te<TAB>.  If the directory name
     contains globbing characters, then build an array of directories, and
     then map over that list while completing. */
  /* *** UNIMPLEMENTED *** */

  /* Now that we have some state, we can read the directory. */

  entry = (struct dirent *)NULL;
  while (directory && (entry = readdir (directory)))
    {
      convfn = dentry = entry->d_name;
      convlen = dentlen = D_NAMLEN (entry);

      if (rl_filename_rewrite_hook)
	{
	  convfn = (*rl_filename_rewrite_hook) (dentry, dentlen);
	  convlen = (convfn == dentry) ? dentlen : strlen (convfn);
	}

      /* Special case for no filename.  If the user has disabled the
         `match-hidden-files' variable, skip filenames beginning with `.'.
	 All other entries except "." and ".." match. */
      if (filename_len == 0)
	{
	  if (_rl_match_hidden_files == 0 && HIDDEN_FILE (convfn))
	    continue;

	  if (convfn[0] != '.' ||
	       (convfn[1] && (convfn[1] != '.' || convfn[2])))
	    break;
	}
      else
	{
	  if (complete_fncmp (convfn, convlen, filename, filename_len))
	    break;
	}
    }

  if (entry == 0)
    {
      if (directory)
	{
	  closedir (directory);
	  directory = (DIR *)NULL;
	}
      if (dirname)
	{
	  xfree (dirname);
	  dirname = (char *)NULL;
	}
      if (filename)
	{
	  xfree (filename);
	  filename = (char *)NULL;
	}
      if (users_dirname)
	{
	  xfree (users_dirname);
	  users_dirname = (char *)NULL;
	}

      return (char *)NULL;
    }
  else
    {
      /* dirname && (strcmp (dirname, ".") != 0) */
      if (dirname && (dirname[0] != '.' || dirname[1]))
	{
	  if (rl_complete_with_tilde_expansion && *users_dirname == '~')
	    {
	      dirlen = strlen (dirname);
	      temp = (char *)xmalloc (2 + dirlen + D_NAMLEN (entry));
	      strcpy (temp, dirname);
	      /* Canonicalization cuts off any final slash present.  We
		 may need to add it back. */
	      if (dirname[dirlen - 1] != '/')
	        {
	          temp[dirlen++] = '/';
	          temp[dirlen] = '\0';
	        }
	    }
	  else
	    {
	      dirlen = strlen (users_dirname);
	      temp = (char *)xmalloc (2 + dirlen + D_NAMLEN (entry));
	      strcpy (temp, users_dirname);
	      /* Make sure that temp has a trailing slash here. */
	      if (users_dirname[dirlen - 1] != '/')
		temp[dirlen++] = '/';
	    }

	  strcpy (temp + dirlen, convfn);
	}
      else
	temp = savestring (convfn);

      if (convfn != dentry)
	xfree (convfn);

      return (temp);
    }
}
warning: parse error {
  static DIR *directory = (DIR *)NULL;
  static char *filename = (char *)NULL;
  static char *dirname = (char *)NULL;
  static char *users_dirname = (char *)NULL;
  static int filename_len;
  char *temp, *dentry, *convfn;
  int dirlen, dentlen, convlen;
  struct dirent *entry;

  /* If we don't have any state, then do some initialization. */
  if (state == 0)
    {
      /* If we were interrupted before closing the directory or reading
	 all of its contents, close it. */
      if (directory)
	{
	  closedir (directory);
	  directory = (DIR *)NULL;
	}
      FREE (dirname);
      FREE (filename);
      FREE (users_dirname);

      filename = savestring (text);
      if (*text == 0)
	text = ".";
      dirname = savestring (text);

      temp = strrchr (dirname, '/');

#if defined (__MSDOS__)
      /* special hack for //X/... */
      if (dirname[0] == '/' && dirname[1] == '/' && ISALPHA ((unsigned char)dirname[2]) && dirname[3] == '/')
        temp = strrchr (dirname + 3, '/');
#endif

      if (temp)
	{
	  strcpy (filename, ++temp);
	  *temp = '\0';
	}
#if defined (__MSDOS__)
      /* searches from current directory on the drive */
      else if (ISALPHA ((unsigned char)dirname[0]) && dirname[1] == ':')
        {
          strcpy (filename, dirname + 2);
          dirname[2] = '\0';
        }
#endif
      else
	{
	  dirname[0] = '.';
	  dirname[1] = '\0';
	}

      /* We aren't done yet.  We also support the "~user" syntax. */

      /* Save the version of the directory that the user typed, dequoting
	 it if necessary. */
      if (rl_completion_found_quote && rl_filename_dequoting_function)
	users_dirname = (*rl_filename_dequoting_function) (dirname, rl_completion_quote_character);
      else
	users_dirname = savestring (dirname);

      if (*dirname == '~')
	{
	  temp = tilde_expand (dirname);
	  xfree (dirname);
	  dirname = temp;
	}

      /* We have saved the possibly-dequoted version of the directory name
	 the user typed.  Now transform the directory name we're going to
	 pass to opendir(2).  The directory rewrite hook modifies only the
	 directory name; the directory completion hook modifies both the
	 directory name passed to opendir(2) and the version the user
	 typed.  Both the directory completion and rewrite hooks should perform
	 any necessary dequoting.  The hook functions return 1 if they modify
	 the directory name argument.  If either hook returns 0, it should
	 not modify the directory name pointer passed as an argument. */
      if (rl_directory_rewrite_hook)
	(*rl_directory_rewrite_hook) (&dirname);
      else if (rl_directory_completion_hook && (*rl_directory_completion_hook) (&dirname))
	{
	  xfree (users_dirname);
	  users_dirname = savestring (dirname);
	}
      else if (rl_completion_found_quote && rl_filename_dequoting_function)
	{
	  /* delete single and double quotes */
	  xfree (dirname);
	  dirname = savestring (users_dirname);
	}
      directory = opendir (dirname);

      /* Now dequote a non-null filename. */
      if (filename && *filename && rl_completion_found_quote && rl_filename_dequoting_function)
	{
	  /* delete single and double quotes */
	  temp = (*rl_filename_dequoting_function) (filename, rl_completion_quote_character);
	  xfree (filename);
	  filename = temp;
	}
      filename_len = strlen (filename);

      rl_filename_completion_desired = 1;
    }

  /* At this point we should entertain the possibility of hacking wildcarded
     filenames, like /usr/man/man<WILD>/te<TAB>.  If the directory name
     contains globbing characters, then build an array of directories, and
     then map over that list while completing. */
  /* *** UNIMPLEMENTED *** */

  /* Now that we have some state, we can read the directory. */

  entry = (struct dirent *)NULL;
  while (directory && (entry = readdir (directory)))
    {
      convfn = dentry = entry->d_name;
      convlen = dentlen = D_NAMLEN (entry);

      if (rl_filename_rewrite_hook)
	{
	  convfn = (*rl_filename_rewrite_hook) (dentry, dentlen);
	  convlen = (convfn == dentry) ? dentlen : strlen (convfn);
	}

      /* Special case for no filename.  If the user has disabled the
         `match-hidden-files' variable, skip filenames beginning with `.'.
	 All other entries except "." and ".." match. */
      if (filename_len == 0)
	{
	  if (_rl_match_hidden_files == 0 && HIDDEN_FILE (convfn))
	    continue;

	  if (convfn[0] != '.' ||
	       (convfn[1] && (convfn[1] != '.' || convfn[2])))
	    break;
	}
      else
	{
	  if (complete_fncmp (convfn, convlen, filename, filename_len))
	    break;
	}
    }

  if (entry == 0)
    {
      if (directory)
	{
	  closedir (directory);
	  directory = (DIR *)NULL;
	}
      if (dirname)
	{
	  xfree (dirname);
	  dirname = (char *)NULL;
	}
      if (filename)
	{
	  xfree (filename);
	  filename = (char *)NULL;
	}
      if (users_dirname)
	{
	  xfree (users_dirname);
	  users_dirname = (char *)NULL;
	}

      return (char *)NULL;
    }
  else
    {
      /* dirname && (strcmp (dirname, ".") != 0) */
      if (dirname && (dirname[0] != '.' || dirname[1]))
	{
	  if (rl_complete_with_tilde_expansion && *users_dirname == '~')
	    {
	      dirlen = strlen (dirname);
	      temp = (char *)xmalloc (2 + dirlen + D_NAMLEN (entry));
	      strcpy (temp, dirname);
	      /* Canonicalization cuts off any final slash present.  We
		 may need to add it back. */
	      if (dirname[dirlen - 1] != '/')
	        {
	          temp[dirlen++] = '/';
	          temp[dirlen] = '\0';
	        }
	    }
	  else
	    {
	      dirlen = strlen (users_dirname);
	      temp = (char *)xmalloc (2 + dirlen + D_NAMLEN (entry));
	      strcpy (temp, users_dirname);
	      /* Make sure that temp has a trailing slash here. */
	      if (users_dirname[dirlen - 1] != '/')
		temp[dirlen++] = '/';
	    }

	  strcpy (temp + dirlen, convfn);
	}
      else
	temp = savestring (convfn);

      if (convfn != dentry)
	xfree (convfn);

      return (temp);
    }
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\complete.c:2,140
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\complete.c:2,363
parsing error 
{
  rl_compentry_func_t *our_func;
  int matching_filenames, found_quote;

  static char *orig_text;
  static char **matches = (char **)0;
  static int match_list_index = 0;
  static int match_list_size = 0;
  static int orig_start, orig_end;
  static char quote_char;
  static int delimiter;

  /* The first time through, we generate the list of matches and set things
     up to insert them. */
  if (rl_last_func != rl_old_menu_complete)
    {
      /* Clean up from previous call, if any. */
      FREE (orig_text);
      if (matches)
	_rl_free_match_list (matches);

      match_list_index = match_list_size = 0;
      matches = (char **)NULL;

      rl_completion_invoking_key = invoking_key;

      RL_SETSTATE(RL_STATE_COMPLETING);

      /* Only the completion entry function can change these. */
      set_completion_defaults ('%');

      our_func = rl_menu_completion_entry_function;
      if (our_func == 0)
	our_func = rl_completion_entry_function
			? rl_completion_entry_function
			: rl_filename_completion_function;

      /* We now look backwards for the start of a filename/variable word. */
      orig_end = rl_point;
      found_quote = delimiter = 0;
      quote_char = '\0';

      if (rl_point)
	/* This (possibly) changes rl_point.  If it returns a non-zero char,
	   we know we have an open quote. */
	quote_char = _rl_find_completion_word (&found_quote, &delimiter);

      orig_start = rl_point;
      rl_point = orig_end;

      orig_text = rl_copy_text (orig_start, orig_end);
      matches = gen_completion_matches (orig_text, orig_start, orig_end,
					our_func, found_quote, quote_char);

      /* If we are matching filenames, the attempted completion function will
	 have set rl_filename_completion_desired to a non-zero value.  The basic
	 rl_filename_completion_function does this. */
      matching_filenames = rl_filename_completion_desired;

      if (matches == 0 || postprocess_matches (&matches, matching_filenames) == 0)
	{
	  rl_ding ();
	  FREE (matches);
	  matches = (char **)0;
	  FREE (orig_text);
	  orig_text = (char *)0;
	  completion_changed_buffer = 0;
	  RL_UNSETSTATE(RL_STATE_COMPLETING);
	  return (0);
	}

      RL_UNSETSTATE(RL_STATE_COMPLETING);

      for (match_list_size = 0; matches[match_list_size]; match_list_size++)
        ;
      /* matches[0] is lcd if match_list_size > 1, but the circular buffer
	 code below should take care of it. */

      if (match_list_size > 1 && _rl_complete_show_all)
	display_matches (matches);
    }

  /* Now we have the list of matches.  Replace the text between
     rl_line_buffer[orig_start] and rl_line_buffer[rl_point] with
     matches[match_list_index], and add any necessary closing char. */

  if (matches == 0 || match_list_size == 0) 
    {
      rl_ding ();
      FREE (matches);
      matches = (char **)0;
      completion_changed_buffer = 0;
      return (0);
    }

  match_list_index += count;
  if (match_list_index < 0)
    {
      while (match_list_index < 0)
	match_list_index += match_list_size;
    }
  else
    match_list_index %= match_list_size;

  if (match_list_index == 0 && match_list_size > 1)
    {
      rl_ding ();
      insert_match (orig_text, orig_start, MULT_MATCH, &quote_char);
    }
  else
    {
      insert_match (matches[match_list_index], orig_start, SINGLE_MATCH, &quote_char);
      append_to_match (matches[match_list_index], delimiter, quote_char,
		       strcmp (orig_text, matches[match_list_index]));
    }

  completion_changed_buffer = 1;
  return (0);
}
warning: parse error {
  rl_compentry_func_t *our_func;
  int matching_filenames, found_quote;

  static char *orig_text;
  static char **matches = (char **)0;
  static int match_list_index = 0;
  static int match_list_size = 0;
  static int orig_start, orig_end;
  static char quote_char;
  static int delimiter;

  /* The first time through, we generate the list of matches and set things
     up to insert them. */
  if (rl_last_func != rl_old_menu_complete)
    {
      /* Clean up from previous call, if any. */
      FREE (orig_text);
      if (matches)
	_rl_free_match_list (matches);

      match_list_index = match_list_size = 0;
      matches = (char **)NULL;

      rl_completion_invoking_key = invoking_key;

      RL_SETSTATE(RL_STATE_COMPLETING);

      /* Only the completion entry function can change these. */
      set_completion_defaults ('%');

      our_func = rl_menu_completion_entry_function;
      if (our_func == 0)
	our_func = rl_completion_entry_function
			? rl_completion_entry_function
			: rl_filename_completion_function;

      /* We now look backwards for the start of a filename/variable word. */
      orig_end = rl_point;
      found_quote = delimiter = 0;
      quote_char = '\0';

      if (rl_point)
	/* This (possibly) changes rl_point.  If it returns a non-zero char,
	   we know we have an open quote. */
	quote_char = _rl_find_completion_word (&found_quote, &delimiter);

      orig_start = rl_point;
      rl_point = orig_end;

      orig_text = rl_copy_text (orig_start, orig_end);
      matches = gen_completion_matches (orig_text, orig_start, orig_end,
					our_func, found_quote, quote_char);

      /* If we are matching filenames, the attempted completion function will
	 have set rl_filename_completion_desired to a non-zero value.  The basic
	 rl_filename_completion_function does this. */
      matching_filenames = rl_filename_completion_desired;

      if (matches == 0 || postprocess_matches (&matches, matching_filenames) == 0)
	{
	  rl_ding ();
	  FREE (matches);
	  matches = (char **)0;
	  FREE (orig_text);
	  orig_text = (char *)0;
	  completion_changed_buffer = 0;
	  RL_UNSETSTATE(RL_STATE_COMPLETING);
	  return (0);
	}

      RL_UNSETSTATE(RL_STATE_COMPLETING);

      for (match_list_size = 0; matches[match_list_size]; match_list_size++)
        ;
      /* matches[0] is lcd if match_list_size > 1, but the circular buffer
	 code below should take care of it. */

      if (match_list_size > 1 && _rl_complete_show_all)
	display_matches (matches);
    }

  /* Now we have the list of matches.  Replace the text between
     rl_line_buffer[orig_start] and rl_line_buffer[rl_point] with
     matches[match_list_index], and add any necessary closing char. */

  if (matches == 0 || match_list_size == 0) 
    {
      rl_ding ();
      FREE (matches);
      matches = (char **)0;
      completion_changed_buffer = 0;
      return (0);
    }

  match_list_index += count;
  if (match_list_index < 0)
    {
      while (match_list_index < 0)
	match_list_index += match_list_size;
    }
  else
    match_list_index %= match_list_size;

  if (match_list_index == 0 && match_list_size > 1)
    {
      rl_ding ();
      insert_match (orig_text, orig_start, MULT_MATCH, &quote_char);
    }
  else
    {
      insert_match (matches[match_list_index], orig_start, SINGLE_MATCH, &quote_char);
      append_to_match (matches[match_list_index], delimiter, quote_char,
		       strcmp (orig_text, matches[match_list_index]));
    }

  completion_changed_buffer = 1;
  return (0);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\complete.c:2,365
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\complete.c:2,486
parsing error 
{
  rl_compentry_func_t *our_func;
  int matching_filenames, found_quote;

  static char *orig_text;
  static char **matches = (char **)0;
  static int match_list_index = 0;
  static int match_list_size = 0;
  static int nontrivial_lcd = 0;
  static int full_completion = 0;	/* set to 1 if menu completion should reinitialize on next call */
  static int orig_start, orig_end;
  static char quote_char;
  static int delimiter, cstate;

  /* The first time through, we generate the list of matches and set things
     up to insert them. */
  if ((rl_last_func != rl_menu_complete && rl_last_func != rl_backward_menu_complete) || full_completion)
    {
      /* Clean up from previous call, if any. */
      FREE (orig_text);
      if (matches)
	_rl_free_match_list (matches);

      match_list_index = match_list_size = 0;
      matches = (char **)NULL;

      full_completion = 0;

      RL_SETSTATE(RL_STATE_COMPLETING);

      /* Only the completion entry function can change these. */
      set_completion_defaults ('%');

      our_func = rl_menu_completion_entry_function;
      if (our_func == 0)
	our_func = rl_completion_entry_function
			? rl_completion_entry_function
			: rl_filename_completion_function;

      /* We now look backwards for the start of a filename/variable word. */
      orig_end = rl_point;
      found_quote = delimiter = 0;
      quote_char = '\0';

      if (rl_point)
	/* This (possibly) changes rl_point.  If it returns a non-zero char,
	   we know we have an open quote. */
	quote_char = _rl_find_completion_word (&found_quote, &delimiter);

      orig_start = rl_point;
      rl_point = orig_end;

      orig_text = rl_copy_text (orig_start, orig_end);
      matches = gen_completion_matches (orig_text, orig_start, orig_end,
					our_func, found_quote, quote_char);

      nontrivial_lcd = matches && strcmp (orig_text, matches[0]) != 0;

      /* If we are matching filenames, the attempted completion function will
	 have set rl_filename_completion_desired to a non-zero value.  The basic
	 rl_filename_completion_function does this. */
      matching_filenames = rl_filename_completion_desired;

      if (matches == 0 || postprocess_matches (&matches, matching_filenames) == 0)
	{
	  rl_ding ();
	  FREE (matches);
	  matches = (char **)0;
	  FREE (orig_text);
	  orig_text = (char *)0;
	  completion_changed_buffer = 0;
	  RL_UNSETSTATE(RL_STATE_COMPLETING);
	  return (0);
	}

      RL_UNSETSTATE(RL_STATE_COMPLETING);

      for (match_list_size = 0; matches[match_list_size]; match_list_size++)
        ;

      if (match_list_size == 0) 
	{
	  rl_ding ();
	  FREE (matches);
	  matches = (char **)0;
	  match_list_index = 0;
	  completion_changed_buffer = 0;
	  return (0);
        }

      /* matches[0] is lcd if match_list_size > 1, but the circular buffer
	 code below should take care of it. */
      if (*matches[0])
	{
	  insert_match (matches[0], orig_start, matches[1] ? MULT_MATCH : SINGLE_MATCH, &quote_char);
	  orig_end = orig_start + strlen (matches[0]);
	  completion_changed_buffer = STREQ (orig_text, matches[0]) == 0;
	}

      if (match_list_size > 1 && _rl_complete_show_all)
	{
	  display_matches (matches);
	  /* If there are so many matches that the user has to be asked
	     whether or not he wants to see the matches, menu completion
	     is unwieldy. */
	  if (rl_completion_query_items > 0 && match_list_size >= rl_completion_query_items)
	    {
	      rl_ding ();
	      FREE (matches);
	      matches = (char **)0;
	      full_completion = 1;
	      return (0);
	    }
	}
      else if (match_list_size <= 1)
	{
	  append_to_match (matches[0], delimiter, quote_char, nontrivial_lcd);
	  full_completion = 1;
	  return (0);
	}
      else if (_rl_menu_complete_prefix_first && match_list_size > 1)
	{
	  rl_ding ();
	  return (0);
	}
    }

  /* Now we have the list of matches.  Replace the text between
     rl_line_buffer[orig_start] and rl_line_buffer[rl_point] with
     matches[match_list_index], and add any necessary closing char. */

  if (matches == 0 || match_list_size == 0) 
    {
      rl_ding ();
      FREE (matches);
      matches = (char **)0;
      completion_changed_buffer = 0;
      return (0);
    }

  match_list_index += count;
  if (match_list_index < 0)
    {
      while (match_list_index < 0)
	match_list_index += match_list_size;
    }
  else
    match_list_index %= match_list_size;

  if (match_list_index == 0 && match_list_size > 1)
    {
      rl_ding ();
      insert_match (matches[0], orig_start, MULT_MATCH, &quote_char);
    }
  else
    {
      insert_match (matches[match_list_index], orig_start, SINGLE_MATCH, &quote_char);
      append_to_match (matches[match_list_index], delimiter, quote_char,
		       strcmp (orig_text, matches[match_list_index]));
    }

  completion_changed_buffer = 1;
  return (0);
}
warning: parse error {
  rl_compentry_func_t *our_func;
  int matching_filenames, found_quote;

  static char *orig_text;
  static char **matches = (char **)0;
  static int match_list_index = 0;
  static int match_list_size = 0;
  static int nontrivial_lcd = 0;
  static int full_completion = 0;	/* set to 1 if menu completion should reinitialize on next call */
  static int orig_start, orig_end;
  static char quote_char;
  static int delimiter, cstate;

  /* The first time through, we generate the list of matches and set things
     up to insert them. */
  if ((rl_last_func != rl_menu_complete && rl_last_func != rl_backward_menu_complete) || full_completion)
    {
      /* Clean up from previous call, if any. */
      FREE (orig_text);
      if (matches)
	_rl_free_match_list (matches);

      match_list_index = match_list_size = 0;
      matches = (char **)NULL;

      full_completion = 0;

      RL_SETSTATE(RL_STATE_COMPLETING);

      /* Only the completion entry function can change these. */
      set_completion_defaults ('%');

      our_func = rl_menu_completion_entry_function;
      if (our_func == 0)
	our_func = rl_completion_entry_function
			? rl_completion_entry_function
			: rl_filename_completion_function;

      /* We now look backwards for the start of a filename/variable word. */
      orig_end = rl_point;
      found_quote = delimiter = 0;
      quote_char = '\0';

      if (rl_point)
	/* This (possibly) changes rl_point.  If it returns a non-zero char,
	   we know we have an open quote. */
	quote_char = _rl_find_completion_word (&found_quote, &delimiter);

      orig_start = rl_point;
      rl_point = orig_end;

      orig_text = rl_copy_text (orig_start, orig_end);
      matches = gen_completion_matches (orig_text, orig_start, orig_end,
					our_func, found_quote, quote_char);

      nontrivial_lcd = matches && strcmp (orig_text, matches[0]) != 0;

      /* If we are matching filenames, the attempted completion function will
	 have set rl_filename_completion_desired to a non-zero value.  The basic
	 rl_filename_completion_function does this. */
      matching_filenames = rl_filename_completion_desired;

      if (matches == 0 || postprocess_matches (&matches, matching_filenames) == 0)
	{
	  rl_ding ();
	  FREE (matches);
	  matches = (char **)0;
	  FREE (orig_text);
	  orig_text = (char *)0;
	  completion_changed_buffer = 0;
	  RL_UNSETSTATE(RL_STATE_COMPLETING);
	  return (0);
	}

      RL_UNSETSTATE(RL_STATE_COMPLETING);

      for (match_list_size = 0; matches[match_list_size]; match_list_size++)
        ;

      if (match_list_size == 0) 
	{
	  rl_ding ();
	  FREE (matches);
	  matches = (char **)0;
	  match_list_index = 0;
	  completion_changed_buffer = 0;
	  return (0);
        }

      /* matches[0] is lcd if match_list_size > 1, but the circular buffer
	 code below should take care of it. */
      if (*matches[0])
	{
	  insert_match (matches[0], orig_start, matches[1] ? MULT_MATCH : SINGLE_MATCH, &quote_char);
	  orig_end = orig_start + strlen (matches[0]);
	  completion_changed_buffer = STREQ (orig_text, matches[0]) == 0;
	}

      if (match_list_size > 1 && _rl_complete_show_all)
	{
	  display_matches (matches);
	  /* If there are so many matches that the user has to be asked
	     whether or not he wants to see the matches, menu completion
	     is unwieldy. */
	  if (rl_completion_query_items > 0 && match_list_size >= rl_completion_query_items)
	    {
	      rl_ding ();
	      FREE (matches);
	      matches = (char **)0;
	      full_completion = 1;
	      return (0);
	    }
	}
      else if (match_list_size <= 1)
	{
	  append_to_match (matches[0], delimiter, quote_char, nontrivial_lcd);
	  full_completion = 1;
	  return (0);
	}
      else if (_rl_menu_complete_prefix_first && match_list_size > 1)
	{
	  rl_ding ();
	  return (0);
	}
    }

  /* Now we have the list of matches.  Replace the text between
     rl_line_buffer[orig_start] and rl_line_buffer[rl_point] with
     matches[match_list_index], and add any necessary closing char. */

  if (matches == 0 || match_list_size == 0) 
    {
      rl_ding ();
      FREE (matches);
      matches = (char **)0;
      completion_changed_buffer = 0;
      return (0);
    }

  match_list_index += count;
  if (match_list_index < 0)
    {
      while (match_list_index < 0)
	match_list_index += match_list_size;
    }
  else
    match_list_index %= match_list_size;

  if (match_list_index == 0 && match_list_size > 1)
    {
      rl_ding ();
      insert_match (matches[0], orig_start, MULT_MATCH, &quote_char);
    }
  else
    {
      insert_match (matches[match_list_index], orig_start, SINGLE_MATCH, &quote_char);
      append_to_match (matches[match_list_index], delimiter, quote_char,
		       strcmp (orig_text, matches[match_list_index]));
    }

  completion_changed_buffer = 1;
  return (0);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\complete.c:2,488
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\complete.c:2,654
parsing error 
{
  /* Positive arguments to backward-menu-complete translate into negative
     arguments for menu-complete, and vice versa. */
  return (rl_menu_complete (-count, key));
}
warning: parse error {
  /* Positive arguments to backward-menu-complete translate into negative
     arguments for menu-complete, and vice versa. */
  return (rl_menu_complete (-count, key));
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\complete.c:2,656
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\display.c...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\posixstat.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\rldefs.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\rlmbutil.h...skip
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\tcap.h...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\history.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\rlprivate.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\xmalloc.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\display.c:251
parsing error 
{
  char *r, *ret, *p, *igstart;
  int l, rl, last, ignoring, ninvis, invfl, invflset, ind, pind, physchars;

  /* Short-circuit if we can. */
  if ((MB_CUR_MAX <= 1 || rl_byte_oriented) && strchr (pmt, RL_PROMPT_START_IGNORE) == 0)
    {
      r = savestring (pmt);
      if (lp)
	*lp = strlen (r);
      if (lip)
	*lip = 0;
      if (niflp)
	*niflp = 0;
      if (vlp)
	*vlp = lp ? *lp : strlen (r);
      return r;
    }

  l = strlen (pmt);
  r = ret = (char *)xmalloc (l + 1);

  invfl = 0;	/* invisible chars in first line of prompt */
  invflset = 0;	/* we only want to set invfl once */

  igstart = 0;
  for (rl = ignoring = last = ninvis = physchars = 0, p = pmt; p && *p; p++)
    {
      /* This code strips the invisible character string markers
	 RL_PROMPT_START_IGNORE and RL_PROMPT_END_IGNORE */
      if (ignoring == 0 && *p == RL_PROMPT_START_IGNORE)		/* XXX - check ignoring? */
	{
	  ignoring = 1;
	  igstart = p;
	  continue;
	}
      else if (ignoring && *p == RL_PROMPT_END_IGNORE)
	{
	  ignoring = 0;
	  if (p != (igstart + 1))
	    last = r - ret - 1;
	  continue;
	}
      else
	{
#if defined (HANDLE_MULTIBYTE)
	  if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
	    {
	      pind = p - pmt;
	      ind = _rl_find_next_mbchar (pmt, pind, 1, MB_FIND_NONZERO);
	      l = ind - pind;
	      while (l--)
	        *r++ = *p++;
	      if (!ignoring)
		{
		  /* rl ends up being assigned to prompt_visible_length,
		     which is the number of characters in the buffer that
		     contribute to characters on the screen, which might
		     not be the same as the number of physical characters
		     on the screen in the presence of multibyte characters */
		  rl += ind - pind;
		  physchars += _rl_col_width (pmt, pind, ind, 0);
		}
	      else
		ninvis += ind - pind;
	      p--;			/* compensate for later increment */
	    }
	  else
#endif
	    {
	      *r++ = *p;
	      if (!ignoring)
		{
		  rl++;			/* visible length byte counter */
		  physchars++;
		}
	      else
		ninvis++;		/* invisible chars byte counter */
	    }

	  if (invflset == 0 && rl >= _rl_screenwidth)
	    {
	      invfl = ninvis;
	      invflset = 1;
	    }
	}
    }

  if (rl < _rl_screenwidth)
    invfl = ninvis;

  *r = '\0';
  if (lp)
    *lp = rl;
  if (lip)
    *lip = last;
  if (niflp)
    *niflp = invfl;
  if  (vlp)
    *vlp = physchars;
  return ret;
}
warning: parse error {
  char *r, *ret, *p, *igstart;
  int l, rl, last, ignoring, ninvis, invfl, invflset, ind, pind, physchars;

  /* Short-circuit if we can. */
  if ((MB_CUR_MAX <= 1 || rl_byte_oriented) && strchr (pmt, RL_PROMPT_START_IGNORE) == 0)
    {
      r = savestring (pmt);
      if (lp)
	*lp = strlen (r);
      if (lip)
	*lip = 0;
      if (niflp)
	*niflp = 0;
      if (vlp)
	*vlp = lp ? *lp : strlen (r);
      return r;
    }

  l = strlen (pmt);
  r = ret = (char *)xmalloc (l + 1);

  invfl = 0;	/* invisible chars in first line of prompt */
  invflset = 0;	/* we only want to set invfl once */

  igstart = 0;
  for (rl = ignoring = last = ninvis = physchars = 0, p = pmt; p && *p; p++)
    {
      /* This code strips the invisible character string markers
	 RL_PROMPT_START_IGNORE and RL_PROMPT_END_IGNORE */
      if (ignoring == 0 && *p == RL_PROMPT_START_IGNORE)		/* XXX - check ignoring? */
	{
	  ignoring = 1;
	  igstart = p;
	  continue;
	}
      else if (ignoring && *p == RL_PROMPT_END_IGNORE)
	{
	  ignoring = 0;
	  if (p != (igstart + 1))
	    last = r - ret - 1;
	  continue;
	}
      else
	{
#if defined (HANDLE_MULTIBYTE)
	  if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
	    {
	      pind = p - pmt;
	      ind = _rl_find_next_mbchar (pmt, pind, 1, MB_FIND_NONZERO);
	      l = ind - pind;
	      while (l--)
	        *r++ = *p++;
	      if (!ignoring)
		{
		  /* rl ends up being assigned to prompt_visible_length,
		     which is the number of characters in the buffer that
		     contribute to characters on the screen, which might
		     not be the same as the number of physical characters
		     on the screen in the presence of multibyte characters */
		  rl += ind - pind;
		  physchars += _rl_col_width (pmt, pind, ind, 0);
		}
	      else
		ninvis += ind - pind;
	      p--;			/* compensate for later increment */
	    }
	  else
#endif
	    {
	      *r++ = *p;
	      if (!ignoring)
		{
		  rl++;			/* visible length byte counter */
		  physchars++;
		}
	      else
		ninvis++;		/* invisible chars byte counter */
	    }

	  if (invflset == 0 && rl >= _rl_screenwidth)
	    {
	      invfl = ninvis;
	      invflset = 1;
	    }
	}
    }

  if (rl < _rl_screenwidth)
    invfl = ninvis;

  *r = '\0';
  if (lp)
    *lp = rl;
  if (lip)
    *lip = last;
  if (niflp)
    *niflp = invfl;
  if  (vlp)
    *vlp = physchars;
  return ret;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\display.c:254
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\display.c:360
parsing error 
{
  char *ret;

  ret = expand_prompt (pmt, (int *)NULL, (int *)NULL, (int *)NULL, (int *)NULL);
  return ret;
}
warning: parse error {
  char *ret;

  ret = expand_prompt (pmt, (int *)NULL, (int *)NULL, (int *)NULL, (int *)NULL);
  return ret;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\display.c:362
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\display.c:387
parsing error 
{
  char *p, *t;
  int c;

  /* Clear out any saved values. */
  FREE (local_prompt);
  FREE (local_prompt_prefix);

  local_prompt = local_prompt_prefix = (char *)0;
  local_prompt_len = 0;
  prompt_last_invisible = prompt_invis_chars_first_line = 0;
  prompt_visible_length = prompt_physical_chars = 0;

  if (prompt == 0 || *prompt == 0)
    return (0);

  p = strrchr (prompt, '\n');
  if (!p)
    {
      /* The prompt is only one logical line, though it might wrap. */
      local_prompt = expand_prompt (prompt, &prompt_visible_length,
					    &prompt_last_invisible,
					    &prompt_invis_chars_first_line,
					    &prompt_physical_chars);
      local_prompt_prefix = (char *)0;
      local_prompt_len = local_prompt ? strlen (local_prompt) : 0;
      return (prompt_visible_length);
    }
  else
    {
      /* The prompt spans multiple lines. */
      t = ++p;
      local_prompt = expand_prompt (p, &prompt_visible_length,
				       &prompt_last_invisible,
				       &prompt_invis_chars_first_line,
				       &prompt_physical_chars);
      c = *t; *t = '\0';
      /* The portion of the prompt string up to and including the
	 final newline is now null-terminated. */
      local_prompt_prefix = expand_prompt (prompt, &prompt_prefix_length,
						   (int *)NULL,
						   (int *)NULL,
						   (int *)NULL);
      *t = c;
      local_prompt_len = local_prompt ? strlen (local_prompt) : 0;
      return (prompt_prefix_length);
    }
}
warning: parse error {
  char *p, *t;
  int c;

  /* Clear out any saved values. */
  FREE (local_prompt);
  FREE (local_prompt_prefix);

  local_prompt = local_prompt_prefix = (char *)0;
  local_prompt_len = 0;
  prompt_last_invisible = prompt_invis_chars_first_line = 0;
  prompt_visible_length = prompt_physical_chars = 0;

  if (prompt == 0 || *prompt == 0)
    return (0);

  p = strrchr (prompt, '\n');
  if (!p)
    {
      /* The prompt is only one logical line, though it might wrap. */
      local_prompt = expand_prompt (prompt, &prompt_visible_length,
					    &prompt_last_invisible,
					    &prompt_invis_chars_first_line,
					    &prompt_physical_chars);
      local_prompt_prefix = (char *)0;
      local_prompt_len = local_prompt ? strlen (local_prompt) : 0;
      return (prompt_visible_length);
    }
  else
    {
      /* The prompt spans multiple lines. */
      t = ++p;
      local_prompt = expand_prompt (p, &prompt_visible_length,
				       &prompt_last_invisible,
				       &prompt_invis_chars_first_line,
				       &prompt_physical_chars);
      c = *t; *t = '\0';
      /* The portion of the prompt string up to and including the
	 final newline is now null-terminated. */
      local_prompt_prefix = expand_prompt (prompt, &prompt_prefix_length,
						   (int *)NULL,
						   (int *)NULL,
						   (int *)NULL);
      *t = c;
      local_prompt_len = local_prompt ? strlen (local_prompt) : 0;
      return (prompt_prefix_length);
    }
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\display.c:389
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\display.c:444
parsing error 
{
  register int n;

  if (invisible_line == 0)	/* initialize it */
    {
      if (line_size < minsize)
	line_size = minsize;
      visible_line = (char *)xmalloc (line_size);
      invisible_line = (char *)xmalloc (line_size);
    }
  else if (line_size < minsize)	/* ensure it can hold MINSIZE chars */
    {
      line_size *= 2;
      if (line_size < minsize)
	line_size = minsize;
      visible_line = (char *)xrealloc (visible_line, line_size);
      invisible_line = (char *)xrealloc (invisible_line, line_size);
    }

  for (n = minsize; n < line_size; n++)
    {
      visible_line[n] = 0;
      invisible_line[n] = 1;
    }

  if (vis_lbreaks == 0)
    {
      /* should be enough. */
      inv_lbsize = vis_lbsize = 256;

#if defined (HANDLE_MULTIBYTE)
      line_state_visible->wbsize = vis_lbsize;
      line_state_visible->wrapped_line = (int *)xmalloc (line_state_visible->wbsize * sizeof (int));

      line_state_invisible->wbsize = inv_lbsize;
      line_state_invisible->wrapped_line = (int *)xmalloc (line_state_invisible->wbsize * sizeof (int));
#endif

      inv_lbreaks = (int *)xmalloc (inv_lbsize * sizeof (int));
      vis_lbreaks = (int *)xmalloc (vis_lbsize * sizeof (int));
      inv_lbreaks[0] = vis_lbreaks[0] = 0;
    }

  line_structures_initialized = 1;
}
warning: parse error {
  register int n;

  if (invisible_line == 0)	/* initialize it */
    {
      if (line_size < minsize)
	line_size = minsize;
      visible_line = (char *)xmalloc (line_size);
      invisible_line = (char *)xmalloc (line_size);
    }
  else if (line_size < minsize)	/* ensure it can hold MINSIZE chars */
    {
      line_size *= 2;
      if (line_size < minsize)
	line_size = minsize;
      visible_line = (char *)xrealloc (visible_line, line_size);
      invisible_line = (char *)xrealloc (invisible_line, line_size);
    }

  for (n = minsize; n < line_size; n++)
    {
      visible_line[n] = 0;
      invisible_line[n] = 1;
    }

  if (vis_lbreaks == 0)
    {
      /* should be enough. */
      inv_lbsize = vis_lbsize = 256;

#if defined (HANDLE_MULTIBYTE)
      line_state_visible->wbsize = vis_lbsize;
      line_state_visible->wrapped_line = (int *)xmalloc (line_state_visible->wbsize * sizeof (int));

      line_state_invisible->wbsize = inv_lbsize;
      line_state_invisible->wrapped_line = (int *)xmalloc (line_state_invisible->wbsize * sizeof (int));
#endif

      inv_lbreaks = (int *)xmalloc (inv_lbsize * sizeof (int));
      vis_lbreaks = (int *)xmalloc (vis_lbsize * sizeof (int));
      inv_lbreaks[0] = vis_lbreaks[0] = 0;
    }

  line_structures_initialized = 1;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\display.c:446
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\display.c:1,269
parsing error 
{
  register char *ofd, *ols, *oe, *nfd, *nls, *ne;
  int temp, lendiff, wsatend, od, nd, twidth, o_cpos;
  int current_invis_chars;
  int col_lendiff, col_temp;
#if defined (HANDLE_MULTIBYTE)
  mbstate_t ps_new, ps_old;
  int new_offset, old_offset;
#endif

  /* If we're at the right edge of a terminal that supports xn, we're
     ready to wrap around, so do so.  This fixes problems with knowing
     the exact cursor position and cut-and-paste with certain terminal
     emulators.  In this calculation, TEMP is the physical screen
     position of the cursor. */
  if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
    temp = _rl_last_c_pos;
  else
    temp = _rl_last_c_pos - WRAP_OFFSET (_rl_last_v_pos, visible_wrap_offset);
  if (temp == _rl_screenwidth && _rl_term_autowrap && !_rl_horizontal_scroll_mode
	&& _rl_last_v_pos == current_line - 1)
    {
#if defined (HANDLE_MULTIBYTE)
      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
	{
	  wchar_t wc;
	  mbstate_t ps;
	  int tempwidth, bytes;
	  size_t ret;

	  /* This fixes only double-column characters, but if the wrapped
	     character comsumes more than three columns, spaces will be
	     inserted in the string buffer. */
	  if (current_line < line_state_visible->wbsize && line_state_visible->wrapped_line[current_line] > 0)
	    _rl_clear_to_eol (line_state_visible->wrapped_line[current_line]);

	  memset (&ps, 0, sizeof (mbstate_t));
	  ret = mbrtowc (&wc, new, MB_CUR_MAX, &ps);
	  if (MB_INVALIDCH (ret))
	    {
	      tempwidth = 1;
	      ret = 1;
	    }
	  else if (MB_NULLWCH (ret))
	    tempwidth = 0;
	  else
	    tempwidth = wcwidth (wc);

	  if (tempwidth > 0)
	    {
	      int count, i;
	      bytes = ret;
	      for (count = 0; count < bytes; count++)
		putc (new[count], rl_outstream);
	      _rl_last_c_pos = tempwidth;
	      _rl_last_v_pos++;
	      memset (&ps, 0, sizeof (mbstate_t));
	      ret = mbrtowc (&wc, old, MB_CUR_MAX, &ps);
	      if (ret != 0 && bytes != 0)
		{
		  if (MB_INVALIDCH (ret))
		    ret = 1;
		  memmove (old+bytes, old+ret, strlen (old+ret));
		  memcpy (old, new, bytes);
		  /* Fix up indices if we copy data from one line to another */
		  omax += bytes - ret;
		  for (i = current_line+1; i < inv_botlin+1; i++)
		    vis_lbreaks[i] += bytes - ret;
		}
	    }
	  else
	    {
	      putc (' ', rl_outstream);
	      _rl_last_c_pos = 1;
	      _rl_last_v_pos++;
	      if (old[0] && new[0])
		old[0] = new[0];
	    }
	}
      else
#endif
	{
	  if (new[0])
	    putc (new[0], rl_outstream);
	  else
	    putc (' ', rl_outstream);
	  _rl_last_c_pos = 1;
	  _rl_last_v_pos++;
	  if (old[0] && new[0])
	    old[0] = new[0];
	}
    }

      
  /* Find first difference. */
#if defined (HANDLE_MULTIBYTE)
  if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
    {
      /* See if the old line is a subset of the new line, so that the
	 only change is adding characters. */
      temp = (omax < nmax) ? omax : nmax;
      if (memcmp (old, new, temp) == 0)		/* adding at the end */
	{
	  ofd = old + temp;
	  nfd = new + temp;
	}
      else
	{      
	  memset (&ps_new, 0, sizeof(mbstate_t));
	  memset (&ps_old, 0, sizeof(mbstate_t));

	  if (omax == nmax && STREQN (new, old, omax))
	    {
	      ofd = old + omax;
	      nfd = new + nmax;
	    }
	  else
	    {
	      new_offset = old_offset = 0;
	      for (ofd = old, nfd = new;
		    (ofd - old < omax) && *ofd &&
		    _rl_compare_chars(old, old_offset, &ps_old, new, new_offset, &ps_new); )
		{
		  old_offset = _rl_find_next_mbchar (old, old_offset, 1, MB_FIND_ANY);
		  new_offset = _rl_find_next_mbchar (new, new_offset, 1, MB_FIND_ANY);
		  ofd = old + old_offset;
		  nfd = new + new_offset;
		}
	    }
	}
    }
  else
#endif
  for (ofd = old, nfd = new;
       (ofd - old < omax) && *ofd && (*ofd == *nfd);
       ofd++, nfd++)
    ;

  /* Move to the end of the screen line.  ND and OD are used to keep track
     of the distance between ne and new and oe and old, respectively, to
     move a subtraction out of each loop. */
  for (od = ofd - old, oe = ofd; od < omax && *oe; oe++, od++);
  for (nd = nfd - new, ne = nfd; nd < nmax && *ne; ne++, nd++);

  /* If no difference, continue to next line. */
  if (ofd == oe && nfd == ne)
    return;

  wsatend = 1;			/* flag for trailing whitespace */

#if defined (HANDLE_MULTIBYTE)
  if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
    {
      ols = old + _rl_find_prev_mbchar (old, oe - old, MB_FIND_ANY);
      nls = new + _rl_find_prev_mbchar (new, ne - new, MB_FIND_ANY);
      while ((ols > ofd) && (nls > nfd))
	{
	  memset (&ps_old, 0, sizeof (mbstate_t));
	  memset (&ps_new, 0, sizeof (mbstate_t));

#if 0
	  /* On advice from jir@yamato.ibm.com */
	  _rl_adjust_point (old, ols - old, &ps_old);
	  _rl_adjust_point (new, nls - new, &ps_new);
#endif

	  if (_rl_compare_chars (old, ols - old, &ps_old, new, nls - new, &ps_new) == 0)
	    break;

	  if (*ols == ' ')
	    wsatend = 0;

	  ols = old + _rl_find_prev_mbchar (old, ols - old, MB_FIND_ANY);
	  nls = new + _rl_find_prev_mbchar (new, nls - new, MB_FIND_ANY);
	}
    }
  else
    {
#endif /* HANDLE_MULTIBYTE */
  ols = oe - 1;			/* find last same */
  nls = ne - 1;
  while ((ols > ofd) && (nls > nfd) && (*ols == *nls))
    {
      if (*ols != ' ')
	wsatend = 0;
      ols--;
      nls--;
    }
#if defined (HANDLE_MULTIBYTE)
    }
#endif

  if (wsatend)
    {
      ols = oe;
      nls = ne;
    }
#if defined (HANDLE_MULTIBYTE)
  /* This may not work for stateful encoding, but who cares?  To handle
     stateful encoding properly, we have to scan each string from the
     beginning and compare. */
  else if (_rl_compare_chars (ols, 0, NULL, nls, 0, NULL) == 0)
#else
  else if (*ols != *nls)
#endif
    {
      if (*ols)			/* don't step past the NUL */
	{
	  if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
	    ols = old + _rl_find_next_mbchar (old, ols - old, 1, MB_FIND_ANY);
	  else
	    ols++;
	}
      if (*nls)
	{
	  if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
	    nls = new + _rl_find_next_mbchar (new, nls - new, 1, MB_FIND_ANY);
	  else
	    nls++;
	}
    }

  /* count of invisible characters in the current invisible line. */
  current_invis_chars = W_OFFSET (current_line, wrap_offset);
  if (_rl_last_v_pos != current_line)
    {
      _rl_move_vert (current_line);
      if ((MB_CUR_MAX == 1 || rl_byte_oriented) && current_line == 0 && visible_wrap_offset)
	_rl_last_c_pos += visible_wrap_offset;
    }

  /* If this is the first line and there are invisible characters in the
     prompt string, and the prompt string has not changed, and the current
     cursor position is before the last invisible character in the prompt,
     and the index of the character to move to is past the end of the prompt
     string, then redraw the entire prompt string.  We can only do this
     reliably if the terminal supports a `cr' capability.

     This is not an efficiency hack -- there is a problem with redrawing
     portions of the prompt string if they contain terminal escape
     sequences (like drawing the `unbold' sequence without a corresponding
     `bold') that manifests itself on certain terminals. */

  lendiff = local_prompt_len;
  od = ofd - old;	/* index of first difference in visible line */
  if (current_line == 0 && !_rl_horizontal_scroll_mode &&
      _rl_term_cr && lendiff > prompt_visible_length && _rl_last_c_pos > 0 &&
      od >= lendiff && _rl_last_c_pos < PROMPT_ENDING_INDEX)
    {
#if defined (__MSDOS__)
      putc ('\r', rl_outstream);
#else
      tputs (_rl_term_cr, 1, _rl_output_character_function);
#endif
      if (modmark)
	_rl_output_some_chars ("*", 1);
      _rl_output_some_chars (local_prompt, lendiff);
      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
	{
	  /* We take wrap_offset into account here so we can pass correct
	     information to _rl_move_cursor_relative. */
	  _rl_last_c_pos = _rl_col_width (local_prompt, 0, lendiff, 1) - wrap_offset + modmark;
	  cpos_adjusted = 1;
	}
      else
	_rl_last_c_pos = lendiff + modmark;
    }

  o_cpos = _rl_last_c_pos;

  /* When this function returns, _rl_last_c_pos is correct, and an absolute
     cursor postion in multibyte mode, but a buffer index when not in a
     multibyte locale. */
  _rl_move_cursor_relative (od, old);
#if 1
#if defined (HANDLE_MULTIBYTE)
  /* We need to indicate that the cursor position is correct in the presence of
     invisible characters in the prompt string.  Let's see if setting this when
     we make sure we're at the end of the drawn prompt string works. */
  if (current_line == 0 && MB_CUR_MAX > 1 && rl_byte_oriented == 0 &&
      (_rl_last_c_pos > 0 || o_cpos > 0) &&
      _rl_last_c_pos == prompt_physical_chars)
    cpos_adjusted = 1;
#endif
#endif

  /* if (len (new) > len (old))
     lendiff == difference in buffer
     col_lendiff == difference on screen
     When not using multibyte characters, these are equal */
  lendiff = (nls - nfd) - (ols - ofd);
  if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
    col_lendiff = _rl_col_width (new, nfd - new, nls - new, 1) - _rl_col_width (old, ofd - old, ols - old, 1);
  else
    col_lendiff = lendiff;

  /* If we are changing the number of invisible characters in a line, and
     the spot of first difference is before the end of the invisible chars,
     lendiff needs to be adjusted. */
  if (current_line == 0 && !_rl_horizontal_scroll_mode &&
      current_invis_chars != visible_wrap_offset)
    {
      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
	{
	  lendiff += visible_wrap_offset - current_invis_chars;
	  col_lendiff += visible_wrap_offset - current_invis_chars;
	}
      else
	{
	  lendiff += visible_wrap_offset - current_invis_chars;
	  col_lendiff = lendiff;
	}
    }

  /* Insert (diff (len (old), len (new)) ch. */
  temp = ne - nfd;
  if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
    col_temp = _rl_col_width (new, nfd - new, ne - new, 1);
  else
    col_temp = temp;

  if (col_lendiff > 0)	/* XXX - was lendiff */
    {
      /* Non-zero if we're increasing the number of lines. */
      int gl = current_line >= _rl_vis_botlin && inv_botlin > _rl_vis_botlin;
      /* If col_lendiff is > 0, implying that the new string takes up more
	 screen real estate than the old, but lendiff is < 0, meaning that it
	 takes fewer bytes, we need to just output the characters starting
	 from the first difference.  These will overwrite what is on the
	 display, so there's no reason to do a smart update.  This can really
	 only happen in a multibyte environment. */
      if (lendiff < 0)
	{
	  _rl_output_some_chars (nfd, temp);
	  _rl_last_c_pos += _rl_col_width (nfd, 0, temp, 1);
	  /* If nfd begins before any invisible characters in the prompt,
	     adjust _rl_last_c_pos to account for wrap_offset and set
	     cpos_adjusted to let the caller know. */
	  if (current_line == 0 && wrap_offset && ((nfd - new) <= prompt_last_invisible))
	    {
	      _rl_last_c_pos -= wrap_offset;
	      cpos_adjusted = 1;
	    }
	  return;
	}
      /* Sometimes it is cheaper to print the characters rather than
	 use the terminal's capabilities.  If we're growing the number
	 of lines, make sure we actually cause the new line to wrap
	 around on auto-wrapping terminals. */
      else if (_rl_terminal_can_insert && ((2 * col_temp) >= col_lendiff || _rl_term_IC) && (!_rl_term_autowrap || !gl))
	{
	  /* If lendiff > prompt_visible_length and _rl_last_c_pos == 0 and
	     _rl_horizontal_scroll_mode == 1, inserting the characters with
	     _rl_term_IC or _rl_term_ic will screw up the screen because of the
	     invisible characters.  We need to just draw them. */
	  /* The same thing happens if we're trying to draw before the last
	     invisible character in the prompt string or we're increasing the
	     number of invisible characters in the line and we're not drawing
	     the entire prompt string. */
	  if (*ols && ((_rl_horizontal_scroll_mode &&
			_rl_last_c_pos == 0 &&
			lendiff > prompt_visible_length &&
			current_invis_chars > 0) == 0) &&
		      (((MB_CUR_MAX > 1 && rl_byte_oriented == 0) &&
		        current_line == 0 && wrap_offset &&
		        ((nfd - new) <= prompt_last_invisible) &&
		        (col_lendiff < prompt_visible_length)) == 0) &&
		      (visible_wrap_offset >= current_invis_chars))
	    {
	      insert_some_chars (nfd, lendiff, col_lendiff);
	      _rl_last_c_pos += col_lendiff;
	    }
#if 0		/* XXX - for now */
	  else if ((MB_CUR_MAX > 1 && rl_byte_oriented == 0) && _rl_last_c_pos == 0 && wrap_offset && (nfd-new) <= prompt_last_invisible && col_lendiff < prompt_visible_length && visible_wrap_offset >= current_invis_chars)
	    {
	      _rl_output_some_chars (nfd, lendiff);
	      _rl_last_c_pos += col_lendiff;
	    }
#endif
	  else if ((MB_CUR_MAX == 1 || rl_byte_oriented != 0) && *ols == 0 && lendiff > 0)
	    {
	      /* At the end of a line the characters do not have to
		 be "inserted".  They can just be placed on the screen. */
	      /* However, this screws up the rest of this block, which
		 assumes you've done the insert because you can. */
	      _rl_output_some_chars (nfd, lendiff);
	      _rl_last_c_pos += col_lendiff;
	    }
	  else
	    {
	      _rl_output_some_chars (nfd, temp);
	      _rl_last_c_pos += col_temp;
	      /* If nfd begins before the last invisible character in the
		 prompt, adjust _rl_last_c_pos to account for wrap_offset
		 and set cpos_adjusted to let the caller know. */
	      if ((MB_CUR_MAX > 1 && rl_byte_oriented == 0) && current_line == 0 && wrap_offset && ((nfd - new) <= prompt_last_invisible))
		{
		  _rl_last_c_pos -= wrap_offset;
		  cpos_adjusted = 1;
		}
	      return;
	    }
	  /* Copy (new) chars to screen from first diff to last match. */
	  temp = nls - nfd;
	  if ((temp - lendiff) > 0)
	    {
	      _rl_output_some_chars (nfd + lendiff, temp - lendiff);
	     /* XXX -- this bears closer inspection.  Fixes a redisplay bug
		reported against bash-3.0-alpha by Andreas Schwab involving
		multibyte characters and prompt strings with invisible
		characters, but was previously disabled. */
	      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
		twidth = _rl_col_width (nfd+lendiff, 0, temp-col_lendiff, 1);
	      else
		twidth = temp - lendiff;
	      _rl_last_c_pos += twidth;
	      /* If nfd begins before the last invisible character in the
		 prompt, adjust _rl_last_c_pos to account for wrap_offset
		 and set cpos_adjusted to let the caller know. */
	      if ((MB_CUR_MAX > 1 && rl_byte_oriented == 0) && current_line == 0 && wrap_offset && ((nfd - new) <= prompt_last_invisible))
		{
		  _rl_last_c_pos -= wrap_offset;
		  cpos_adjusted = 1;
		}
	    }
	}
      else
	{
	  /* cannot insert chars, write to EOL */
	  _rl_output_some_chars (nfd, temp);
	  _rl_last_c_pos += col_temp;
	  /* If we're in a multibyte locale and were before the last invisible
	     char in the current line (which implies we just output some invisible
	     characters) we need to adjust _rl_last_c_pos, since it represents
	     a physical character position. */
	  if ((MB_CUR_MAX > 1 && rl_byte_oriented == 0) &&
		current_line == prompt_last_screen_line && wrap_offset &&
		wrap_offset != prompt_invis_chars_first_line &&
		((nfd-new) < (prompt_last_invisible-(current_line*_rl_screenwidth))))
	    {
	      _rl_last_c_pos -= wrap_offset - prompt_invis_chars_first_line;
	      cpos_adjusted = 1;
	    }
	}
    }
  else				/* Delete characters from line. */
    {
      /* If possible and inexpensive to use terminal deletion, then do so. */
      if (_rl_term_dc && (2 * col_temp) >= -col_lendiff)
	{
	  /* If all we're doing is erasing the invisible characters in the
	     prompt string, don't bother.  It screws up the assumptions
	     about what's on the screen. */
	  if (_rl_horizontal_scroll_mode && _rl_last_c_pos == 0 &&
	      -lendiff == visible_wrap_offset)
	    col_lendiff = 0;

	  if (col_lendiff)
	    delete_chars (-col_lendiff); /* delete (diff) characters */

	  /* Copy (new) chars to screen from first diff to last match */
	  temp = nls - nfd;
	  if (temp > 0)
	    {
	      /* If nfd begins at the prompt, or before the invisible
		 characters in the prompt, we need to adjust _rl_last_c_pos
		 in a multibyte locale to account for the wrap offset and
		 set cpos_adjusted accordingly. */
	      _rl_output_some_chars (nfd, temp);
	      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
		{
		  _rl_last_c_pos += _rl_col_width (nfd, 0, temp, 1);
		  if (current_line == 0 && wrap_offset &&  ((nfd - new) <= prompt_last_invisible))
		    {
		      _rl_last_c_pos -= wrap_offset;
		      cpos_adjusted = 1;
		    }
		}
	      else
		_rl_last_c_pos += temp;
	    }
	}
      /* Otherwise, print over the existing material. */
      else
	{
	  if (temp > 0)
	    {
	      /* If nfd begins at the prompt, or before the invisible
		 characters in the prompt, we need to adjust _rl_last_c_pos
		 in a multibyte locale to account for the wrap offset and
		 set cpos_adjusted accordingly. */
	      _rl_output_some_chars (nfd, temp);
	      _rl_last_c_pos += col_temp;		/* XXX */
	      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
		{
		  if (current_line == 0 && wrap_offset &&  ((nfd - new) <= prompt_last_invisible))
		    {
		      _rl_last_c_pos -= wrap_offset;
		      cpos_adjusted = 1;
		    }
		}
	    }
	  lendiff = (oe - old) - (ne - new);
	  if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
	    col_lendiff = _rl_col_width (old, 0, oe - old, 1) - _rl_col_width (new, 0, ne - new, 1);
	  else
	    col_lendiff = lendiff;

#if 0
	  if (col_lendiff)
#else
	  /* If we've already printed over the entire width of the screen,
	     including the old material, then col_lendiff doesn't matter and
	     space_to_eol will insert too many spaces.  XXX - maybe we should
	     adjust col_lendiff based on the difference between _rl_last_c_pos
	     and _rl_screenwidth */
	  if (col_lendiff && ((MB_CUR_MAX == 1 || rl_byte_oriented) || (_rl_last_c_pos < _rl_screenwidth)))
#endif
	    {	  
	      if (_rl_term_autowrap && current_line < inv_botlin)
		space_to_eol (col_lendiff);
	      else
		_rl_clear_to_eol (col_lendiff);
	    }
	}
    }
}
warning: parse error {
  register char *ofd, *ols, *oe, *nfd, *nls, *ne;
  int temp, lendiff, wsatend, od, nd, twidth, o_cpos;
  int current_invis_chars;
  int col_lendiff, col_temp;
#if defined (HANDLE_MULTIBYTE)
  mbstate_t ps_new, ps_old;
  int new_offset, old_offset;
#endif

  /* If we're at the right edge of a terminal that supports xn, we're
     ready to wrap around, so do so.  This fixes problems with knowing
     the exact cursor position and cut-and-paste with certain terminal
     emulators.  In this calculation, TEMP is the physical screen
     position of the cursor. */
  if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
    temp = _rl_last_c_pos;
  else
    temp = _rl_last_c_pos - WRAP_OFFSET (_rl_last_v_pos, visible_wrap_offset);
  if (temp == _rl_screenwidth && _rl_term_autowrap && !_rl_horizontal_scroll_mode
	&& _rl_last_v_pos == current_line - 1)
    {
#if defined (HANDLE_MULTIBYTE)
      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
	{
	  wchar_t wc;
	  mbstate_t ps;
	  int tempwidth, bytes;
	  size_t ret;

	  /* This fixes only double-column characters, but if the wrapped
	     character comsumes more than three columns, spaces will be
	     inserted in the string buffer. */
	  if (current_line < line_state_visible->wbsize && line_state_visible->wrapped_line[current_line] > 0)
	    _rl_clear_to_eol (line_state_visible->wrapped_line[current_line]);

	  memset (&ps, 0, sizeof (mbstate_t));
	  ret = mbrtowc (&wc, new, MB_CUR_MAX, &ps);
	  if (MB_INVALIDCH (ret))
	    {
	      tempwidth = 1;
	      ret = 1;
	    }
	  else if (MB_NULLWCH (ret))
	    tempwidth = 0;
	  else
	    tempwidth = wcwidth (wc);

	  if (tempwidth > 0)
	    {
	      int count, i;
	      bytes = ret;
	      for (count = 0; count < bytes; count++)
		putc (new[count], rl_outstream);
	      _rl_last_c_pos = tempwidth;
	      _rl_last_v_pos++;
	      memset (&ps, 0, sizeof (mbstate_t));
	      ret = mbrtowc (&wc, old, MB_CUR_MAX, &ps);
	      if (ret != 0 && bytes != 0)
		{
		  if (MB_INVALIDCH (ret))
		    ret = 1;
		  memmove (old+bytes, old+ret, strlen (old+ret));
		  memcpy (old, new, bytes);
		  /* Fix up indices if we copy data from one line to another */
		  omax += bytes - ret;
		  for (i = current_line+1; i < inv_botlin+1; i++)
		    vis_lbreaks[i] += bytes - ret;
		}
	    }
	  else
	    {
	      putc (' ', rl_outstream);
	      _rl_last_c_pos = 1;
	      _rl_last_v_pos++;
	      if (old[0] && new[0])
		old[0] = new[0];
	    }
	}
      else
#endif
	{
	  if (new[0])
	    putc (new[0], rl_outstream);
	  else
	    putc (' ', rl_outstream);
	  _rl_last_c_pos = 1;
	  _rl_last_v_pos++;
	  if (old[0] && new[0])
	    old[0] = new[0];
	}
    }

      
  /* Find first difference. */
#if defined (HANDLE_MULTIBYTE)
  if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
    {
      /* See if the old line is a subset of the new line, so that the
	 only change is adding characters. */
      temp = (omax < nmax) ? omax : nmax;
      if (memcmp (old, new, temp) == 0)		/* adding at the end */
	{
	  ofd = old + temp;
	  nfd = new + temp;
	}
      else
	{      
	  memset (&ps_new, 0, sizeof(mbstate_t));
	  memset (&ps_old, 0, sizeof(mbstate_t));

	  if (omax == nmax && STREQN (new, old, omax))
	    {
	      ofd = old + omax;
	      nfd = new + nmax;
	    }
	  else
	    {
	      new_offset = old_offset = 0;
	      for (ofd = old, nfd = new;
		    (ofd - old < omax) && *ofd &&
		    _rl_compare_chars(old, old_offset, &ps_old, new, new_offset, &ps_new); )
		{
		  old_offset = _rl_find_next_mbchar (old, old_offset, 1, MB_FIND_ANY);
		  new_offset = _rl_find_next_mbchar (new, new_offset, 1, MB_FIND_ANY);
		  ofd = old + old_offset;
		  nfd = new + new_offset;
		}
	    }
	}
    }
  else
#endif
  for (ofd = old, nfd = new;
       (ofd - old < omax) && *ofd && (*ofd == *nfd);
       ofd++, nfd++)
    ;

  /* Move to the end of the screen line.  ND and OD are used to keep track
     of the distance between ne and new and oe and old, respectively, to
     move a subtraction out of each loop. */
  for (od = ofd - old, oe = ofd; od < omax && *oe; oe++, od++);
  for (nd = nfd - new, ne = nfd; nd < nmax && *ne; ne++, nd++);

  /* If no difference, continue to next line. */
  if (ofd == oe && nfd == ne)
    return;

  wsatend = 1;			/* flag for trailing whitespace */

#if defined (HANDLE_MULTIBYTE)
  if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
    {
      ols = old + _rl_find_prev_mbchar (old, oe - old, MB_FIND_ANY);
      nls = new + _rl_find_prev_mbchar (new, ne - new, MB_FIND_ANY);
      while ((ols > ofd) && (nls > nfd))
	{
	  memset (&ps_old, 0, sizeof (mbstate_t));
	  memset (&ps_new, 0, sizeof (mbstate_t));

#if 0
	  /* On advice from jir@yamato.ibm.com */
	  _rl_adjust_point (old, ols - old, &ps_old);
	  _rl_adjust_point (new, nls - new, &ps_new);
#endif

	  if (_rl_compare_chars (old, ols - old, &ps_old, new, nls - new, &ps_new) == 0)
	    break;

	  if (*ols == ' ')
	    wsatend = 0;

	  ols = old + _rl_find_prev_mbchar (old, ols - old, MB_FIND_ANY);
	  nls = new + _rl_find_prev_mbchar (new, nls - new, MB_FIND_ANY);
	}
    }
  else
    {
#endif /* HANDLE_MULTIBYTE */
  ols = oe - 1;			/* find last same */
  nls = ne - 1;
  while ((ols > ofd) && (nls > nfd) && (*ols == *nls))
    {
      if (*ols != ' ')
	wsatend = 0;
      ols--;
      nls--;
    }
#if defined (HANDLE_MULTIBYTE)
    }
#endif

  if (wsatend)
    {
      ols = oe;
      nls = ne;
    }
#if defined (HANDLE_MULTIBYTE)
  /* This may not work for stateful encoding, but who cares?  To handle
     stateful encoding properly, we have to scan each string from the
     beginning and compare. */
  else if (_rl_compare_chars (ols, 0, NULL, nls, 0, NULL) == 0)
#else
  else if (*ols != *nls)
#endif
    {
      if (*ols)			/* don't step past the NUL */
	{
	  if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
	    ols = old + _rl_find_next_mbchar (old, ols - old, 1, MB_FIND_ANY);
	  else
	    ols++;
	}
      if (*nls)
	{
	  if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
	    nls = new + _rl_find_next_mbchar (new, nls - new, 1, MB_FIND_ANY);
	  else
	    nls++;
	}
    }

  /* count of invisible characters in the current invisible line. */
  current_invis_chars = W_OFFSET (current_line, wrap_offset);
  if (_rl_last_v_pos != current_line)
    {
      _rl_move_vert (current_line);
      if ((MB_CUR_MAX == 1 || rl_byte_oriented) && current_line == 0 && visible_wrap_offset)
	_rl_last_c_pos += visible_wrap_offset;
    }

  /* If this is the first line and there are invisible characters in the
     prompt string, and the prompt string has not changed, and the current
     cursor position is before the last invisible character in the prompt,
     and the index of the character to move to is past the end of the prompt
     string, then redraw the entire prompt string.  We can only do this
     reliably if the terminal supports a `cr' capability.

     This is not an efficiency hack -- there is a problem with redrawing
     portions of the prompt string if they contain terminal escape
     sequences (like drawing the `unbold' sequence without a corresponding
     `bold') that manifests itself on certain terminals. */

  lendiff = local_prompt_len;
  od = ofd - old;	/* index of first difference in visible line */
  if (current_line == 0 && !_rl_horizontal_scroll_mode &&
      _rl_term_cr && lendiff > prompt_visible_length && _rl_last_c_pos > 0 &&
      od >= lendiff && _rl_last_c_pos < PROMPT_ENDING_INDEX)
    {
#if defined (__MSDOS__)
      putc ('\r', rl_outstream);
#else
      tputs (_rl_term_cr, 1, _rl_output_character_function);
#endif
      if (modmark)
	_rl_output_some_chars ("*", 1);
      _rl_output_some_chars (local_prompt, lendiff);
      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
	{
	  /* We take wrap_offset into account here so we can pass correct
	     information to _rl_move_cursor_relative. */
	  _rl_last_c_pos = _rl_col_width (local_prompt, 0, lendiff, 1) - wrap_offset + modmark;
	  cpos_adjusted = 1;
	}
      else
	_rl_last_c_pos = lendiff + modmark;
    }

  o_cpos = _rl_last_c_pos;

  /* When this function returns, _rl_last_c_pos is correct, and an absolute
     cursor postion in multibyte mode, but a buffer index when not in a
     multibyte locale. */
  _rl_move_cursor_relative (od, old);
#if 1
#if defined (HANDLE_MULTIBYTE)
  /* We need to indicate that the cursor position is correct in the presence of
     invisible characters in the prompt string.  Let's see if setting this when
     we make sure we're at the end of the drawn prompt string works. */
  if (current_line == 0 && MB_CUR_MAX > 1 && rl_byte_oriented == 0 &&
      (_rl_last_c_pos > 0 || o_cpos > 0) &&
      _rl_last_c_pos == prompt_physical_chars)
    cpos_adjusted = 1;
#endif
#endif

  /* if (len (new) > len (old))
     lendiff == difference in buffer
     col_lendiff == difference on screen
     When not using multibyte characters, these are equal */
  lendiff = (nls - nfd) - (ols - ofd);
  if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
    col_lendiff = _rl_col_width (new, nfd - new, nls - new, 1) - _rl_col_width (old, ofd - old, ols - old, 1);
  else
    col_lendiff = lendiff;

  /* If we are changing the number of invisible characters in a line, and
     the spot of first difference is before the end of the invisible chars,
     lendiff needs to be adjusted. */
  if (current_line == 0 && !_rl_horizontal_scroll_mode &&
      current_invis_chars != visible_wrap_offset)
    {
      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
	{
	  lendiff += visible_wrap_offset - current_invis_chars;
	  col_lendiff += visible_wrap_offset - current_invis_chars;
	}
      else
	{
	  lendiff += visible_wrap_offset - current_invis_chars;
	  col_lendiff = lendiff;
	}
    }

  /* Insert (diff (len (old), len (new)) ch. */
  temp = ne - nfd;
  if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
    col_temp = _rl_col_width (new, nfd - new, ne - new, 1);
  else
    col_temp = temp;

  if (col_lendiff > 0)	/* XXX - was lendiff */
    {
      /* Non-zero if we're increasing the number of lines. */
      int gl = current_line >= _rl_vis_botlin && inv_botlin > _rl_vis_botlin;
      /* If col_lendiff is > 0, implying that the new string takes up more
	 screen real estate than the old, but lendiff is < 0, meaning that it
	 takes fewer bytes, we need to just output the characters starting
	 from the first difference.  These will overwrite what is on the
	 display, so there's no reason to do a smart update.  This can really
	 only happen in a multibyte environment. */
      if (lendiff < 0)
	{
	  _rl_output_some_chars (nfd, temp);
	  _rl_last_c_pos += _rl_col_width (nfd, 0, temp, 1);
	  /* If nfd begins before any invisible characters in the prompt,
	     adjust _rl_last_c_pos to account for wrap_offset and set
	     cpos_adjusted to let the caller know. */
	  if (current_line == 0 && wrap_offset && ((nfd - new) <= prompt_last_invisible))
	    {
	      _rl_last_c_pos -= wrap_offset;
	      cpos_adjusted = 1;
	    }
	  return;
	}
      /* Sometimes it is cheaper to print the characters rather than
	 use the terminal's capabilities.  If we're growing the number
	 of lines, make sure we actually cause the new line to wrap
	 around on auto-wrapping terminals. */
      else if (_rl_terminal_can_insert && ((2 * col_temp) >= col_lendiff || _rl_term_IC) && (!_rl_term_autowrap || !gl))
	{
	  /* If lendiff > prompt_visible_length and _rl_last_c_pos == 0 and
	     _rl_horizontal_scroll_mode == 1, inserting the characters with
	     _rl_term_IC or _rl_term_ic will screw up the screen because of the
	     invisible characters.  We need to just draw them. */
	  /* The same thing happens if we're trying to draw before the last
	     invisible character in the prompt string or we're increasing the
	     number of invisible characters in the line and we're not drawing
	     the entire prompt string. */
	  if (*ols && ((_rl_horizontal_scroll_mode &&
			_rl_last_c_pos == 0 &&
			lendiff > prompt_visible_length &&
			current_invis_chars > 0) == 0) &&
		      (((MB_CUR_MAX > 1 && rl_byte_oriented == 0) &&
		        current_line == 0 && wrap_offset &&
		        ((nfd - new) <= prompt_last_invisible) &&
		        (col_lendiff < prompt_visible_length)) == 0) &&
		      (visible_wrap_offset >= current_invis_chars))
	    {
	      insert_some_chars (nfd, lendiff, col_lendiff);
	      _rl_last_c_pos += col_lendiff;
	    }
#if 0		/* XXX - for now */
	  else if ((MB_CUR_MAX > 1 && rl_byte_oriented == 0) && _rl_last_c_pos == 0 && wrap_offset && (nfd-new) <= prompt_last_invisible && col_lendiff < prompt_visible_length && visible_wrap_offset >= current_invis_chars)
	    {
	      _rl_output_some_chars (nfd, lendiff);
	      _rl_last_c_pos += col_lendiff;
	    }
#endif
	  else if ((MB_CUR_MAX == 1 || rl_byte_oriented != 0) && *ols == 0 && lendiff > 0)
	    {
	      /* At the end of a line the characters do not have to
		 be "inserted".  They can just be placed on the screen. */
	      /* However, this screws up the rest of this block, which
		 assumes you've done the insert because you can. */
	      _rl_output_some_chars (nfd, lendiff);
	      _rl_last_c_pos += col_lendiff;
	    }
	  else
	    {
	      _rl_output_some_chars (nfd, temp);
	      _rl_last_c_pos += col_temp;
	      /* If nfd begins before the last invisible character in the
		 prompt, adjust _rl_last_c_pos to account for wrap_offset
		 and set cpos_adjusted to let the caller know. */
	      if ((MB_CUR_MAX > 1 && rl_byte_oriented == 0) && current_line == 0 && wrap_offset && ((nfd - new) <= prompt_last_invisible))
		{
		  _rl_last_c_pos -= wrap_offset;
		  cpos_adjusted = 1;
		}
	      return;
	    }
	  /* Copy (new) chars to screen from first diff to last match. */
	  temp = nls - nfd;
	  if ((temp - lendiff) > 0)
	    {
	      _rl_output_some_chars (nfd + lendiff, temp - lendiff);
	     /* XXX -- this bears closer inspection.  Fixes a redisplay bug
		reported against bash-3.0-alpha by Andreas Schwab involving
		multibyte characters and prompt strings with invisible
		characters, but was previously disabled. */
	      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
		twidth = _rl_col_width (nfd+lendiff, 0, temp-col_lendiff, 1);
	      else
		twidth = temp - lendiff;
	      _rl_last_c_pos += twidth;
	      /* If nfd begins before the last invisible character in the
		 prompt, adjust _rl_last_c_pos to account for wrap_offset
		 and set cpos_adjusted to let the caller know. */
	      if ((MB_CUR_MAX > 1 && rl_byte_oriented == 0) && current_line == 0 && wrap_offset && ((nfd - new) <= prompt_last_invisible))
		{
		  _rl_last_c_pos -= wrap_offset;
		  cpos_adjusted = 1;
		}
	    }
	}
      else
	{
	  /* cannot insert chars, write to EOL */
	  _rl_output_some_chars (nfd, temp);
	  _rl_last_c_pos += col_temp;
	  /* If we're in a multibyte locale and were before the last invisible
	     char in the current line (which implies we just output some invisible
	     characters) we need to adjust _rl_last_c_pos, since it represents
	     a physical character position. */
	  if ((MB_CUR_MAX > 1 && rl_byte_oriented == 0) &&
		current_line == prompt_last_screen_line && wrap_offset &&
		wrap_offset != prompt_invis_chars_first_line &&
		((nfd-new) < (prompt_last_invisible-(current_line*_rl_screenwidth))))
	    {
	      _rl_last_c_pos -= wrap_offset - prompt_invis_chars_first_line;
	      cpos_adjusted = 1;
	    }
	}
    }
  else				/* Delete characters from line. */
    {
      /* If possible and inexpensive to use terminal deletion, then do so. */
      if (_rl_term_dc && (2 * col_temp) >= -col_lendiff)
	{
	  /* If all we're doing is erasing the invisible characters in the
	     prompt string, don't bother.  It screws up the assumptions
	     about what's on the screen. */
	  if (_rl_horizontal_scroll_mode && _rl_last_c_pos == 0 &&
	      -lendiff == visible_wrap_offset)
	    col_lendiff = 0;

	  if (col_lendiff)
	    delete_chars (-col_lendiff); /* delete (diff) characters */

	  /* Copy (new) chars to screen from first diff to last match */
	  temp = nls - nfd;
	  if (temp > 0)
	    {
	      /* If nfd begins at the prompt, or before the invisible
		 characters in the prompt, we need to adjust _rl_last_c_pos
		 in a multibyte locale to account for the wrap offset and
		 set cpos_adjusted accordingly. */
	      _rl_output_some_chars (nfd, temp);
	      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
		{
		  _rl_last_c_pos += _rl_col_width (nfd, 0, temp, 1);
		  if (current_line == 0 && wrap_offset &&  ((nfd - new) <= prompt_last_invisible))
		    {
		      _rl_last_c_pos -= wrap_offset;
		      cpos_adjusted = 1;
		    }
		}
	      else
		_rl_last_c_pos += temp;
	    }
	}
      /* Otherwise, print over the existing material. */
      else
	{
	  if (temp > 0)
	    {
	      /* If nfd begins at the prompt, or before the invisible
		 characters in the prompt, we need to adjust _rl_last_c_pos
		 in a multibyte locale to account for the wrap offset and
		 set cpos_adjusted accordingly. */
	      _rl_output_some_chars (nfd, temp);
	      _rl_last_c_pos += col_temp;		/* XXX */
	      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
		{
		  if (current_line == 0 && wrap_offset &&  ((nfd - new) <= prompt_last_invisible))
		    {
		      _rl_last_c_pos -= wrap_offset;
		      cpos_adjusted = 1;
		    }
		}
	    }
	  lendiff = (oe - old) - (ne - new);
	  if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
	    col_lendiff = _rl_col_width (old, 0, oe - old, 1) - _rl_col_width (new, 0, ne - new, 1);
	  else
	    col_lendiff = lendiff;

#if 0
	  if (col_lendiff)
#else
	  /* If we've already printed over the entire width of the screen,
	     including the old material, then col_lendiff doesn't matter and
	     space_to_eol will insert too many spaces.  XXX - maybe we should
	     adjust col_lendiff based on the difference between _rl_last_c_pos
	     and _rl_screenwidth */
	  if (col_lendiff && ((MB_CUR_MAX == 1 || rl_byte_oriented) || (_rl_last_c_pos < _rl_screenwidth)))
#endif
	    {	  
	      if (_rl_term_autowrap && current_line < inv_botlin)
		space_to_eol (col_lendiff);
	      else
		_rl_clear_to_eol (col_lendiff);
	    }
	}
    }
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\display.c:1,272
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\display.c:1,898
parsing error 
{
  register int i;
  int woff;			/* number of invisible chars on current line */
  int cpos, dpos;		/* current and desired cursor positions */
  int adjust;

  woff = WRAP_OFFSET (_rl_last_v_pos, wrap_offset);
  cpos = _rl_last_c_pos;

  if (cpos == 0 && cpos == new)
    return;

#if defined (HANDLE_MULTIBYTE)
  /* If we have multibyte characters, NEW is indexed by the buffer point in
     a multibyte string, but _rl_last_c_pos is the display position.  In
     this case, NEW's display position is not obvious and must be
     calculated.  We need to account for invisible characters in this line,
     as long as we are past them and they are counted by _rl_col_width. */
  if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
    {
      adjust = 1;
      /* Try to short-circuit common cases and eliminate a bunch of multibyte
	 character function calls. */
      /* 1.  prompt string */
      if (new == local_prompt_len && memcmp (data, local_prompt, new) == 0)
	{
	  dpos = prompt_physical_chars;
	  cpos_adjusted = 1;
	  adjust = 0;
	}
      /* 2.  prompt_string + line contents */
      else if (new > local_prompt_len && local_prompt && memcmp (data, local_prompt, local_prompt_len) == 0)
	{
	  dpos = prompt_physical_chars + _rl_col_width (data, local_prompt_len, new, 1);
	  cpos_adjusted = 1;
	  adjust = 0;
	}
      else
        dpos = _rl_col_width (data, 0, new, 1);

      /* Use NEW when comparing against the last invisible character in the
	 prompt string, since they're both buffer indices and DPOS is a
	 desired display position. */
      if (adjust && ((new > prompt_last_invisible) ||		/* XXX - don't use woff here */
	  (prompt_physical_chars >= _rl_screenwidth &&
	   _rl_last_v_pos == prompt_last_screen_line &&
	   wrap_offset >= woff && dpos >= woff &&
	   new > (prompt_last_invisible-(_rl_screenwidth*_rl_last_v_pos)-wrap_offset))))
	   /* XXX last comparison might need to be >= */
	{
	  dpos -= woff;
	  /* Since this will be assigned to _rl_last_c_pos at the end (more
	     precisely, _rl_last_c_pos == dpos when this function returns),
	     let the caller know. */
	  cpos_adjusted = 1;
	}
    }
  else
#endif
    dpos = new;

  /* If we don't have to do anything, then return. */
  if (cpos == dpos)
    return;

  /* It may be faster to output a CR, and then move forwards instead
     of moving backwards. */
  /* i == current physical cursor position. */
#if defined (HANDLE_MULTIBYTE)
  if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
    i = _rl_last_c_pos;
  else
#endif
  i = _rl_last_c_pos - woff;
  if (dpos == 0 || CR_FASTER (dpos, _rl_last_c_pos) ||
      (_rl_term_autowrap && i == _rl_screenwidth))
    {
#if defined (__MSDOS__)
      putc ('\r', rl_outstream);
#else
      tputs (_rl_term_cr, 1, _rl_output_character_function);
#endif /* !__MSDOS__ */
      cpos = _rl_last_c_pos = 0;
    }

  if (cpos < dpos)
    {
      /* Move the cursor forward.  We do it by printing the command
	 to move the cursor forward if there is one, else print that
	 portion of the output buffer again.  Which is cheaper? */

      /* The above comment is left here for posterity.  It is faster
	 to print one character (non-control) than to print a control
	 sequence telling the terminal to move forward one character.
	 That kind of control is for people who don't know what the
	 data is underneath the cursor. */

      /* However, we need a handle on where the current display position is
	 in the buffer for the immediately preceding comment to be true.
	 In multibyte locales, we don't currently have that info available.
	 Without it, we don't know where the data we have to display begins
	 in the buffer and we have to go back to the beginning of the screen
	 line.  In this case, we can use the terminal sequence to move forward
	 if it's available. */
      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
	{
	  if (_rl_term_forward_char)
	    {
	      for (i = cpos; i < dpos; i++)
	        tputs (_rl_term_forward_char, 1, _rl_output_character_function);
	    }
	  else
	    {
	      tputs (_rl_term_cr, 1, _rl_output_character_function);
	      for (i = 0; i < new; i++)
		putc (data[i], rl_outstream);
	    }
	}
      else
	for (i = cpos; i < new; i++)
	  putc (data[i], rl_outstream);
    }

#if defined (HANDLE_MULTIBYTE)
  /* NEW points to the buffer point, but _rl_last_c_pos is the display point.
     The byte length of the string is probably bigger than the column width
     of the string, which means that if NEW == _rl_last_c_pos, then NEW's
     display point is less than _rl_last_c_pos. */
#endif
  else if (cpos > dpos)
    _rl_backspace (cpos - dpos);

  _rl_last_c_pos = dpos;
}
warning: parse error {
  register int i;
  int woff;			/* number of invisible chars on current line */
  int cpos, dpos;		/* current and desired cursor positions */
  int adjust;

  woff = WRAP_OFFSET (_rl_last_v_pos, wrap_offset);
  cpos = _rl_last_c_pos;

  if (cpos == 0 && cpos == new)
    return;

#if defined (HANDLE_MULTIBYTE)
  /* If we have multibyte characters, NEW is indexed by the buffer point in
     a multibyte string, but _rl_last_c_pos is the display position.  In
     this case, NEW's display position is not obvious and must be
     calculated.  We need to account for invisible characters in this line,
     as long as we are past them and they are counted by _rl_col_width. */
  if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
    {
      adjust = 1;
      /* Try to short-circuit common cases and eliminate a bunch of multibyte
	 character function calls. */
      /* 1.  prompt string */
      if (new == local_prompt_len && memcmp (data, local_prompt, new) == 0)
	{
	  dpos = prompt_physical_chars;
	  cpos_adjusted = 1;
	  adjust = 0;
	}
      /* 2.  prompt_string + line contents */
      else if (new > local_prompt_len && local_prompt && memcmp (data, local_prompt, local_prompt_len) == 0)
	{
	  dpos = prompt_physical_chars + _rl_col_width (data, local_prompt_len, new, 1);
	  cpos_adjusted = 1;
	  adjust = 0;
	}
      else
        dpos = _rl_col_width (data, 0, new, 1);

      /* Use NEW when comparing against the last invisible character in the
	 prompt string, since they're both buffer indices and DPOS is a
	 desired display position. */
      if (adjust && ((new > prompt_last_invisible) ||		/* XXX - don't use woff here */
	  (prompt_physical_chars >= _rl_screenwidth &&
	   _rl_last_v_pos == prompt_last_screen_line &&
	   wrap_offset >= woff && dpos >= woff &&
	   new > (prompt_last_invisible-(_rl_screenwidth*_rl_last_v_pos)-wrap_offset))))
	   /* XXX last comparison might need to be >= */
	{
	  dpos -= woff;
	  /* Since this will be assigned to _rl_last_c_pos at the end (more
	     precisely, _rl_last_c_pos == dpos when this function returns),
	     let the caller know. */
	  cpos_adjusted = 1;
	}
    }
  else
#endif
    dpos = new;

  /* If we don't have to do anything, then return. */
  if (cpos == dpos)
    return;

  /* It may be faster to output a CR, and then move forwards instead
     of moving backwards. */
  /* i == current physical cursor position. */
#if defined (HANDLE_MULTIBYTE)
  if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
    i = _rl_last_c_pos;
  else
#endif
  i = _rl_last_c_pos - woff;
  if (dpos == 0 || CR_FASTER (dpos, _rl_last_c_pos) ||
      (_rl_term_autowrap && i == _rl_screenwidth))
    {
#if defined (__MSDOS__)
      putc ('\r', rl_outstream);
#else
      tputs (_rl_term_cr, 1, _rl_output_character_function);
#endif /* !__MSDOS__ */
      cpos = _rl_last_c_pos = 0;
    }

  if (cpos < dpos)
    {
      /* Move the cursor forward.  We do it by printing the command
	 to move the cursor forward if there is one, else print that
	 portion of the output buffer again.  Which is cheaper? */

      /* The above comment is left here for posterity.  It is faster
	 to print one character (non-control) than to print a control
	 sequence telling the terminal to move forward one character.
	 That kind of control is for people who don't know what the
	 data is underneath the cursor. */

      /* However, we need a handle on where the current display position is
	 in the buffer for the immediately preceding comment to be true.
	 In multibyte locales, we don't currently have that info available.
	 Without it, we don't know where the data we have to display begins
	 in the buffer and we have to go back to the beginning of the screen
	 line.  In this case, we can use the terminal sequence to move forward
	 if it's available. */
      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
	{
	  if (_rl_term_forward_char)
	    {
	      for (i = cpos; i < dpos; i++)
	        tputs (_rl_term_forward_char, 1, _rl_output_character_function);
	    }
	  else
	    {
	      tputs (_rl_term_cr, 1, _rl_output_character_function);
	      for (i = 0; i < new; i++)
		putc (data[i], rl_outstream);
	    }
	}
      else
	for (i = cpos; i < new; i++)
	  putc (data[i], rl_outstream);
    }

#if defined (HANDLE_MULTIBYTE)
  /* NEW points to the buffer point, but _rl_last_c_pos is the display point.
     The byte length of the string is probably bigger than the column width
     of the string, which means that if NEW == _rl_last_c_pos, then NEW's
     display point is less than _rl_last_c_pos. */
#endif
  else if (cpos > dpos)
    _rl_backspace (cpos - dpos);

  _rl_last_c_pos = dpos;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\display.c:1,901
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\display.c:2,038
parsing error 
{
  register int delta, i;

  if (_rl_last_v_pos == to || to > _rl_screenheight)
    return;

  if ((delta = to - _rl_last_v_pos) > 0)
    {
      for (i = 0; i < delta; i++)
	putc ('\n', rl_outstream);
#if defined (__MSDOS__)
      putc ('\r', rl_outstream);
#else
      tputs (_rl_term_cr, 1, _rl_output_character_function);
#endif
      _rl_last_c_pos = 0;
    }
  else
    {			/* delta < 0 */
      if (_rl_term_up && *_rl_term_up)
	for (i = 0; i < -delta; i++)
	  tputs (_rl_term_up, 1, _rl_output_character_function);
    }

  _rl_last_v_pos = to;		/* Now TO is here */
}
warning: parse error {
  register int delta, i;

  if (_rl_last_v_pos == to || to > _rl_screenheight)
    return;

  if ((delta = to - _rl_last_v_pos) > 0)
    {
      for (i = 0; i < delta; i++)
	putc ('\n', rl_outstream);
#if defined (__MSDOS__)
      putc ('\r', rl_outstream);
#else
      tputs (_rl_term_cr, 1, _rl_output_character_function);
#endif
      _rl_last_c_pos = 0;
    }
  else
    {			/* delta < 0 */
      if (_rl_term_up && *_rl_term_up)
	for (i = 0; i < -delta; i++)
	  tputs (_rl_term_up, 1, _rl_output_character_function);
    }

  _rl_last_v_pos = to;		/* Now TO is here */
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\display.c:2,040
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\display.c:2,070
parsing error 
{
  int n = 1;
  if (META_CHAR (c) && (_rl_output_meta_chars == 0))
    {
      fprintf (rl_outstream, "M-");
      n += 2;
      c = UNMETA (c);
    }

#if defined (DISPLAY_TABS)
  if ((CTRL_CHAR (c) && c != '\t') || c == RUBOUT)
#else
  if (CTRL_CHAR (c) || c == RUBOUT)
#endif /* !DISPLAY_TABS */
    {
      fprintf (rl_outstream, "C-");
      n += 2;
      c = CTRL_CHAR (c) ? UNCTRL (c) : '?';
    }

  putc (c, rl_outstream);
  fflush (rl_outstream);
  return n;
}
warning: parse error {
  int n = 1;
  if (META_CHAR (c) && (_rl_output_meta_chars == 0))
    {
      fprintf (rl_outstream, "M-");
      n += 2;
      c = UNMETA (c);
    }

#if defined (DISPLAY_TABS)
  if ((CTRL_CHAR (c) && c != '\t') || c == RUBOUT)
#else
  if (CTRL_CHAR (c) || c == RUBOUT)
#endif /* !DISPLAY_TABS */
    {
      fprintf (rl_outstream, "C-");
      n += 2;
      c = CTRL_CHAR (c) ? UNCTRL (c) : '?';
    }

  putc (c, rl_outstream);
  fflush (rl_outstream);
  return n;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\display.c:2,072
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\display.c:2,098
parsing error 
{
  unsigned char uc;

  uc = (unsigned char)c;

  if (META_CHAR (uc))
    return ((_rl_output_meta_chars == 0) ? 4 : 1);

  if (uc == '\t')
    {
#if defined (DISPLAY_TABS)
      return (((pos | 7) + 1) - pos);
#else
      return (2);
#endif /* !DISPLAY_TABS */
    }

  if (CTRL_CHAR (c) || c == RUBOUT)
    return (2);

  return ((ISPRINT (uc)) ? 1 : 2);
}
warning: parse error {
  unsigned char uc;

  uc = (unsigned char)c;

  if (META_CHAR (uc))
    return ((_rl_output_meta_chars == 0) ? 4 : 1);

  if (uc == '\t')
    {
#if defined (DISPLAY_TABS)
      return (((pos | 7) + 1) - pos);
#else
      return (2);
#endif /* !DISPLAY_TABS */
    }

  if (CTRL_CHAR (c) || c == RUBOUT)
    return (2);

  return ((ISPRINT (uc)) ? 1 : 2);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\display.c:2,100
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\display.c:2,173
parsing error 
{
  sprintf (msg_buf, format, arg1, arg2);
  msg_buf[sizeof(msg_buf) - 1] = '\0';	/* overflow? */

  rl_display_prompt = msg_buf;
  if (saved_local_prompt == 0)
    {
      rl_save_prompt ();
      msg_saved_prompt = 1;
    }
  local_prompt = expand_prompt (msg_buf, &prompt_visible_length,
					 &prompt_last_invisible,
					 &prompt_invis_chars_first_line,
					 &prompt_physical_chars);
  local_prompt_prefix = (char *)NULL;
  local_prompt_len = local_prompt ? strlen (local_prompt) : 0;
  (*rl_redisplay_function) ();
      
  return 0;
}
warning: parse error {
  sprintf (msg_buf, format, arg1, arg2);
  msg_buf[sizeof(msg_buf) - 1] = '\0';	/* overflow? */

  rl_display_prompt = msg_buf;
  if (saved_local_prompt == 0)
    {
      rl_save_prompt ();
      msg_saved_prompt = 1;
    }
  local_prompt = expand_prompt (msg_buf, &prompt_visible_length,
					 &prompt_last_invisible,
					 &prompt_invis_chars_first_line,
					 &prompt_physical_chars);
  local_prompt_prefix = (char *)NULL;
  local_prompt_len = local_prompt ? strlen (local_prompt) : 0;
  (*rl_redisplay_function) ();
      
  return 0;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\display.c:2,175
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\display.c:2,262
parsing error 
{
  int len;
  char *pmt, *p;

  rl_save_prompt ();

  /* We've saved the prompt, and can do anything with the various prompt
     strings we need before they're restored.  We want the unexpanded
     portion of the prompt string after any final newline. */
  p = rl_prompt ? strrchr (rl_prompt, '\n') : 0;
  if (p == 0)
    {
      len = (rl_prompt && *rl_prompt) ? strlen (rl_prompt) : 0;
      pmt = (char *)xmalloc (len + 2);
      if (len)
	strcpy (pmt, rl_prompt);
      pmt[len] = pchar;
      pmt[len+1] = '\0';
    }
  else
    {
      p++;
      len = strlen (p);
      pmt = (char *)xmalloc (len + 2);
      if (len)
	strcpy (pmt, p);
      pmt[len] = pchar;
      pmt[len+1] = '\0';
    }  

  /* will be overwritten by expand_prompt, called from rl_message */
  prompt_physical_chars = saved_physical_chars + 1;
  return pmt;
}
warning: parse error {
  int len;
  char *pmt, *p;

  rl_save_prompt ();

  /* We've saved the prompt, and can do anything with the various prompt
     strings we need before they're restored.  We want the unexpanded
     portion of the prompt string after any final newline. */
  p = rl_prompt ? strrchr (rl_prompt, '\n') : 0;
  if (p == 0)
    {
      len = (rl_prompt && *rl_prompt) ? strlen (rl_prompt) : 0;
      pmt = (char *)xmalloc (len + 2);
      if (len)
	strcpy (pmt, rl_prompt);
      pmt[len] = pchar;
      pmt[len+1] = '\0';
    }
  else
    {
      p++;
      len = strlen (p);
      pmt = (char *)xmalloc (len + 2);
      if (len)
	strcpy (pmt, p);
      pmt[len] = pchar;
      pmt[len+1] = '\0';
    }  

  /* will be overwritten by expand_prompt, called from rl_message */
  prompt_physical_chars = saved_physical_chars + 1;
  return pmt;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\display.c:2,264
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\display.c:2,301
parsing error 
{
  register int i;

  _rl_backspace (l);
  for (i = 0; i < l; i++)
    putc (' ', rl_outstream);
  _rl_backspace (l);
  for (i = 0; i < l; i++)
    visible_line[--_rl_last_c_pos] = '\0';
  rl_display_fixed++;
}
warning: parse error {
  register int i;

  _rl_backspace (l);
  for (i = 0; i < l; i++)
    putc (' ', rl_outstream);
  _rl_backspace (l);
  for (i = 0; i < l; i++)
    visible_line[--_rl_last_c_pos] = '\0';
  rl_display_fixed++;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\display.c:2,303
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\display.c:2,318
parsing error 
{
  if (_rl_term_clreol)
    tputs (_rl_term_clreol, 1, _rl_output_character_function);
  else if (count)
    space_to_eol (count);
}
warning: parse error {
  if (_rl_term_clreol)
    tputs (_rl_term_clreol, 1, _rl_output_character_function);
  else if (count)
    space_to_eol (count);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\display.c:2,320
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\display.c:2,330
parsing error 
{
  register int i;

  for (i = 0; i < count; i++)
   putc (' ', rl_outstream);

  _rl_last_c_pos += count;
}
warning: parse error {
  register int i;

  for (i = 0; i < count; i++)
   putc (' ', rl_outstream);

  _rl_last_c_pos += count;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\display.c:2,332
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\display.c:2,352
parsing error 
{
#if defined (__MSDOS__) || defined (__MINGW32__)
  _rl_output_some_chars (string, count);
#else
  /* DEBUGGING */
  if (MB_CUR_MAX == 1 || rl_byte_oriented)
    if (count != col)
      _rl_ttymsg ("debug: insert_some_chars: count (%d) != col (%d)", count, col);

  /* If IC is defined, then we do not have to "enter" insert mode. */
  if (_rl_term_IC)
    {
      char *buffer;

      buffer = tgoto (_rl_term_IC, 0, col);
      tputs (buffer, 1, _rl_output_character_function);
      _rl_output_some_chars (string, count);
    }
  else
    {
      register int i;

      /* If we have to turn on insert-mode, then do so. */
      if (_rl_term_im && *_rl_term_im)
	tputs (_rl_term_im, 1, _rl_output_character_function);

      /* If there is a special command for inserting characters, then
	 use that first to open up the space. */
      if (_rl_term_ic && *_rl_term_ic)
	{
	  for (i = col; i--; )
	    tputs (_rl_term_ic, 1, _rl_output_character_function);
	}

      /* Print the text. */
      _rl_output_some_chars (string, count);

      /* If there is a string to turn off insert mode, we had best use
	 it now. */
      if (_rl_term_ei && *_rl_term_ei)
	tputs (_rl_term_ei, 1, _rl_output_character_function);
    }
#endif /* __MSDOS__ || __MINGW32__ */
}
warning: parse error {
#if defined (__MSDOS__) || defined (__MINGW32__)
  _rl_output_some_chars (string, count);
#else
  /* DEBUGGING */
  if (MB_CUR_MAX == 1 || rl_byte_oriented)
    if (count != col)
      _rl_ttymsg ("debug: insert_some_chars: count (%d) != col (%d)", count, col);

  /* If IC is defined, then we do not have to "enter" insert mode. */
  if (_rl_term_IC)
    {
      char *buffer;

      buffer = tgoto (_rl_term_IC, 0, col);
      tputs (buffer, 1, _rl_output_character_function);
      _rl_output_some_chars (string, count);
    }
  else
    {
      register int i;

      /* If we have to turn on insert-mode, then do so. */
      if (_rl_term_im && *_rl_term_im)
	tputs (_rl_term_im, 1, _rl_output_character_function);

      /* If there is a special command for inserting characters, then
	 use that first to open up the space. */
      if (_rl_term_ic && *_rl_term_ic)
	{
	  for (i = col; i--; )
	    tputs (_rl_term_ic, 1, _rl_output_character_function);
	}

      /* Print the text. */
      _rl_output_some_chars (string, count);

      /* If there is a string to turn off insert mode, we had best use
	 it now. */
      if (_rl_term_ei && *_rl_term_ei)
	tputs (_rl_term_ei, 1, _rl_output_character_function);
    }
#endif /* __MSDOS__ || __MINGW32__ */
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\display.c:2,355
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\display.c:2,402
parsing error 
{
  if (count > _rl_screenwidth)	/* XXX */
    return;

#if !defined (__MSDOS__) && !defined (__MINGW32__)
  if (_rl_term_DC && *_rl_term_DC)
    {
      char *buffer;
      buffer = tgoto (_rl_term_DC, count, count);
      tputs (buffer, count, _rl_output_character_function);
    }
  else
    {
      if (_rl_term_dc && *_rl_term_dc)
	while (count--)
	  tputs (_rl_term_dc, 1, _rl_output_character_function);
    }
#endif /* !__MSDOS__ && !__MINGW32__ */
}
warning: parse error {
  if (count > _rl_screenwidth)	/* XXX */
    return;

#if !defined (__MSDOS__) && !defined (__MINGW32__)
  if (_rl_term_DC && *_rl_term_DC)
    {
      char *buffer;
      buffer = tgoto (_rl_term_DC, count, count);
      tputs (buffer, count, _rl_output_character_function);
    }
  else
    {
      if (_rl_term_dc && *_rl_term_dc)
	while (count--)
	  tputs (_rl_term_dc, 1, _rl_output_character_function);
    }
#endif /* !__MSDOS__ && !__MINGW32__ */
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\display.c:2,404
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\display.c:2,475
parsing error 
{
  char *oldp;

  oldp = rl_display_prompt;
  rl_save_prompt ();

  rl_display_prompt = t;
  local_prompt = expand_prompt (t, &prompt_visible_length,
				   &prompt_last_invisible,
				   &prompt_invis_chars_first_line,
				   &prompt_physical_chars);
  local_prompt_prefix = (char *)NULL;
  local_prompt_len = local_prompt ? strlen (local_prompt) : 0;

  rl_forced_update_display ();

  rl_display_prompt = oldp;
  rl_restore_prompt();
}
warning: parse error {
  char *oldp;

  oldp = rl_display_prompt;
  rl_save_prompt ();

  rl_display_prompt = t;
  local_prompt = expand_prompt (t, &prompt_visible_length,
				   &prompt_last_invisible,
				   &prompt_invis_chars_first_line,
				   &prompt_physical_chars);
  local_prompt_prefix = (char *)NULL;
  local_prompt_len = local_prompt ? strlen (local_prompt) : 0;

  rl_forced_update_display ();

  rl_display_prompt = oldp;
  rl_restore_prompt();
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\display.c:2,477
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\display.c:2,592
parsing error 
{
  wchar_t wc;
  mbstate_t ps;
  int tmp, point, width, max;

  if (end <= start)
    return 0;
  if (MB_CUR_MAX == 1 || rl_byte_oriented)
{
_rl_ttymsg ("_rl_col_width: called with MB_CUR_MAX == 1");
    return (end - start);
}

  memset (&ps, 0, sizeof (mbstate_t));

  point = 0;
  max = end;

  /* Try to short-circuit common cases.  The adjustment to remove wrap_offset
     is done by the caller. */
  /* 1.  prompt string */
  if (flags && start == 0 && end == local_prompt_len && memcmp (str, local_prompt, local_prompt_len) == 0)
    return (prompt_physical_chars + wrap_offset);
  /* 2.  prompt string + line contents */
  else if (flags && start == 0 && local_prompt_len > 0 && end > local_prompt_len && local_prompt && memcmp (str, local_prompt, local_prompt_len) == 0)
    {
      tmp = prompt_physical_chars + wrap_offset;
      /* XXX - try to call ourselves recursively with non-prompt portion */
      tmp += _rl_col_width (str, local_prompt_len, end, flags);
      return (tmp);
    }

  while (point < start)
    {
      tmp = mbrlen (str + point, max, &ps);
      if (MB_INVALIDCH ((size_t)tmp))
	{
	  /* In this case, the bytes are invalid or too short to compose a
	     multibyte character, so we assume that the first byte represents
	     a single character. */
	  point++;
	  max--;

	  /* Clear the state of the byte sequence, because in this case the
	     effect of mbstate is undefined. */
	  memset (&ps, 0, sizeof (mbstate_t));
	}
      else if (MB_NULLWCH (tmp))
	break;		/* Found '\0' */
      else
	{
	  point += tmp;
	  max -= tmp;
	}
    }

  /* If START is not a byte that starts a character, then POINT will be
     greater than START.  In this case, assume that (POINT - START) gives
     a byte count that is the number of columns of difference. */
  width = point - start;

  while (point < end)
    {
      tmp = mbrtowc (&wc, str + point, max, &ps);
      if (MB_INVALIDCH ((size_t)tmp))
	{
	  /* In this case, the bytes are invalid or too short to compose a
	     multibyte character, so we assume that the first byte represents
	     a single character. */
	  point++;
	  max--;

	  /* and assume that the byte occupies a single column. */
	  width++;

	  /* Clear the state of the byte sequence, because in this case the
	     effect of mbstate is undefined. */
	  memset (&ps, 0, sizeof (mbstate_t));
	}
      else if (MB_NULLWCH (tmp))
	break;			/* Found '\0' */
      else
	{
	  point += tmp;
	  max -= tmp;
	  tmp = wcwidth(wc);
	  width += (tmp >= 0) ? tmp : 1;
	}
    }

  width += point - end;

  return width;
}
warning: parse error {
  wchar_t wc;
  mbstate_t ps;
  int tmp, point, width, max;

  if (end <= start)
    return 0;
  if (MB_CUR_MAX == 1 || rl_byte_oriented)
{
_rl_ttymsg ("_rl_col_width: called with MB_CUR_MAX == 1");
    return (end - start);
}

  memset (&ps, 0, sizeof (mbstate_t));

  point = 0;
  max = end;

  /* Try to short-circuit common cases.  The adjustment to remove wrap_offset
     is done by the caller. */
  /* 1.  prompt string */
  if (flags && start == 0 && end == local_prompt_len && memcmp (str, local_prompt, local_prompt_len) == 0)
    return (prompt_physical_chars + wrap_offset);
  /* 2.  prompt string + line contents */
  else if (flags && start == 0 && local_prompt_len > 0 && end > local_prompt_len && local_prompt && memcmp (str, local_prompt, local_prompt_len) == 0)
    {
      tmp = prompt_physical_chars + wrap_offset;
      /* XXX - try to call ourselves recursively with non-prompt portion */
      tmp += _rl_col_width (str, local_prompt_len, end, flags);
      return (tmp);
    }

  while (point < start)
    {
      tmp = mbrlen (str + point, max, &ps);
      if (MB_INVALIDCH ((size_t)tmp))
	{
	  /* In this case, the bytes are invalid or too short to compose a
	     multibyte character, so we assume that the first byte represents
	     a single character. */
	  point++;
	  max--;

	  /* Clear the state of the byte sequence, because in this case the
	     effect of mbstate is undefined. */
	  memset (&ps, 0, sizeof (mbstate_t));
	}
      else if (MB_NULLWCH (tmp))
	break;		/* Found '\0' */
      else
	{
	  point += tmp;
	  max -= tmp;
	}
    }

  /* If START is not a byte that starts a character, then POINT will be
     greater than START.  In this case, assume that (POINT - START) gives
     a byte count that is the number of columns of difference. */
  width = point - start;

  while (point < end)
    {
      tmp = mbrtowc (&wc, str + point, max, &ps);
      if (MB_INVALIDCH ((size_t)tmp))
	{
	  /* In this case, the bytes are invalid or too short to compose a
	     multibyte character, so we assume that the first byte represents
	     a single character. */
	  point++;
	  max--;

	  /* and assume that the byte occupies a single column. */
	  width++;

	  /* Clear the state of the byte sequence, because in this case the
	     effect of mbstate is undefined. */
	  memset (&ps, 0, sizeof (mbstate_t));
	}
      else if (MB_NULLWCH (tmp))
	break;			/* Found '\0' */
      else
	{
	  point += tmp;
	  max -= tmp;
	  tmp = wcwidth(wc);
	  width += (tmp >= 0) ? tmp : 1;
	}
    }

  width += point - end;

  return width;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\display.c:2,594
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\emacs_keymap.c...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h...skip
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\examples\excallback.c...
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\examples\fileman.c...
parsing error 
extern char *xmalloc PARAMS((size_t));
warning: parse error extern char *xmalloc PARAMS((size_t));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\examples\fileman.c:64
parsing error 
int com_list PARAMS((char *));
warning: parse error int com_list PARAMS((char *));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\examples\fileman.c:67
parsing error 
int com_view PARAMS((char *));
warning: parse error int com_view PARAMS((char *));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\examples\fileman.c:68
parsing error 
int com_rename PARAMS((char *));
warning: parse error int com_rename PARAMS((char *));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\examples\fileman.c:69
parsing error 
int com_stat PARAMS((char *));
warning: parse error int com_stat PARAMS((char *));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\examples\fileman.c:70
parsing error 
int com_pwd PARAMS((char *));
warning: parse error int com_pwd PARAMS((char *));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\examples\fileman.c:71
parsing error 
int com_delete PARAMS((char *));
warning: parse error int com_delete PARAMS((char *));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\examples\fileman.c:72
parsing error 
int com_help PARAMS((char *));
warning: parse error int com_help PARAMS((char *));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\examples\fileman.c:73
parsing error 
int com_cd PARAMS((char *));
warning: parse error int com_cd PARAMS((char *));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\examples\fileman.c:74
parsing error 
int com_quit PARAMS((char *));
warning: parse error int com_quit PARAMS((char *));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\examples\fileman.c:75
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\examples\fileman.c:112
parsing error 
{
  char *r;

  r = xmalloc (strlen (s) + 1);
  strcpy (r, s);
  return (r);
}
warning: parse error {
  char *r;

  r = xmalloc (strlen (s) + 1);
  strcpy (r, s);
  return (r);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\examples\fileman.c:114
parsing error 
main (argc, argv)
     int argc;
warning: parse error main (argc, argv)
     int argc;Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\examples\fileman.c:122
parsing error 
{
  char *line, *s;

  progname = argv[0];

  initialize_readline ();	/* Bind our completer. */

  /* Loop reading and executing lines until the user quits. */
  for ( ; done == 0; )
    {
      line = readline ("FileMan: ");

      if (!line)
        break;

      /* Remove leading and trailing whitespace from the line.
         Then, if there is anything left, add it to the history list
         and execute it. */
      s = stripwhite (line);

      if (*s)
        {
          add_history (s);
          execute_line (s);
        }

      free (line);
    }
  exit (0);
}
warning: parse error {
  char *line, *s;

  progname = argv[0];

  initialize_readline ();	/* Bind our completer. */

  /* Loop reading and executing lines until the user quits. */
  for ( ; done == 0; )
    {
      line = readline ("FileMan: ");

      if (!line)
        break;

      /* Remove leading and trailing whitespace from the line.
         Then, if there is anything left, add it to the history list
         and execute it. */
      s = stripwhite (line);

      if (*s)
        {
          add_history (s);
          execute_line (s);
        }

      free (line);
    }
  exit (0);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\examples\fileman.c:125
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\examples\fileman.c:158
parsing error 
{
  register int i;
  COMMAND *command;
  char *word;

  /* Isolate the command word. */
  i = 0;
  while (line[i] && whitespace (line[i]))
    i++;
  word = line + i;

  while (line[i] && !whitespace (line[i]))
    i++;

  if (line[i])
    line[i++] = '\0';

  command = find_command (word);

  if (!command)
    {
      fprintf (stderr, "%s: No such command for FileMan.\n", word);
      return (-1);
    }

  /* Get argument to command, if any. */
  while (whitespace (line[i]))
    i++;

  word = line + i;

  /* Call the function. */
  return ((*(command->func)) (word));
}
warning: parse error {
  register int i;
  COMMAND *command;
  char *word;

  /* Isolate the command word. */
  i = 0;
  while (line[i] && whitespace (line[i]))
    i++;
  word = line + i;

  while (line[i] && !whitespace (line[i]))
    i++;

  if (line[i])
    line[i++] = '\0';

  command = find_command (word);

  if (!command)
    {
      fprintf (stderr, "%s: No such command for FileMan.\n", word);
      return (-1);
    }

  /* Get argument to command, if any. */
  while (whitespace (line[i]))
    i++;

  word = line + i;

  /* Call the function. */
  return ((*(command->func)) (word));
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\examples\fileman.c:160
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\examples\fileman.c:198
parsing error 
{
  register int i;

  for (i = 0; commands[i].name; i++)
    if (strcmp (name, commands[i].name) == 0)
      return (&commands[i]);

  return ((COMMAND *)NULL);
}
warning: parse error {
  register int i;

  for (i = 0; commands[i].name; i++)
    if (strcmp (name, commands[i].name) == 0)
      return (&commands[i]);

  return ((COMMAND *)NULL);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\examples\fileman.c:200
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\examples\fileman.c:213
parsing error 
{
  register char *s, *t;

  for (s = string; whitespace (*s); s++)
    ;
    
  if (*s == 0)
    return (s);

  t = s + strlen (s) - 1;
  while (t > s && whitespace (*t))
    t--;
  *++t = '\0';

  return s;
}
warning: parse error {
  register char *s, *t;

  for (s = string; whitespace (*s); s++)
    ;
    
  if (*s == 0)
    return (s);

  t = s + strlen (s) - 1;
  while (t > s && whitespace (*t))
    t--;
  *++t = '\0';

  return s;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\examples\fileman.c:215
parsing error 
char *command_generator PARAMS((const char *, int));
warning: parse error char *command_generator PARAMS((const char *, int));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\examples\fileman.c:238
parsing error 
char **fileman_completion PARAMS((const char *, int, int));
warning: parse error char **fileman_completion PARAMS((const char *, int, int));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\examples\fileman.c:239
parsing error 
initialize_readline ()
{
  /* Allow conditional parsing of the ~/.inputrc file. */
  rl_readline_name = "FileMan";

  /* Tell the completer that we want a crack first. */
  rl_attempted_completion_function = fileman_completion;
}
warning: parse error initialize_readline ()
{
  /* Allow conditional parsing of the ~/.inputrc file. */
  rl_readline_name = "FileMan";

  /* Tell the completer that we want a crack first. */
  rl_attempted_completion_function = fileman_completion;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\examples\fileman.c:244
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\examples\fileman.c:260
parsing error 
{
  char **matches;

  matches = (char **)NULL;

  /* If this word is at the start of the line, then it is a command
     to complete.  Otherwise it is the name of a file in the current
     directory. */
  if (start == 0)
    matches = rl_completion_matches (text, command_generator);

  return (matches);
}
warning: parse error {
  char **matches;

  matches = (char **)NULL;

  /* If this word is at the start of the line, then it is a command
     to complete.  Otherwise it is the name of a file in the current
     directory. */
  if (start == 0)
    matches = rl_completion_matches (text, command_generator);

  return (matches);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\examples\fileman.c:262
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\examples\fileman.c:281
parsing error 
{
  static int list_index, len;
  char *name;

  /* If this is a new word to complete, initialize now.  This includes
     saving the length of TEXT for efficiency, and initializing the index
     variable to 0. */
  if (!state)
    {
      list_index = 0;
      len = strlen (text);
    }

  /* Return the next name which partially matches from the command list. */
  while (name = commands[list_index].name)
    {
      list_index++;

      if (strncmp (name, text, len) == 0)
        return (dupstr(name));
    }

  /* If no names matched, then return NULL. */
  return ((char *)NULL);
}
warning: parse error {
  static int list_index, len;
  char *name;

  /* If this is a new word to complete, initialize now.  This includes
     saving the length of TEXT for efficiency, and initializing the index
     variable to 0. */
  if (!state)
    {
      list_index = 0;
      len = strlen (text);
    }

  /* Return the next name which partially matches from the command list. */
  while (name = commands[list_index].name)
    {
      list_index++;

      if (strncmp (name, text, len) == 0)
        return (dupstr(name));
    }

  /* If no names matched, then return NULL. */
  return ((char *)NULL);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\examples\fileman.c:283
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\examples\fileman.c:320
parsing error 
{
  if (!arg)
    arg = "";

  sprintf (syscom, "ls -FClg %s", arg);
  return (system (syscom));
}
warning: parse error {
  if (!arg)
    arg = "";

  sprintf (syscom, "ls -FClg %s", arg);
  return (system (syscom));
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\examples\fileman.c:322
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\examples\fileman.c:330
parsing error 
{
  if (!valid_argument ("view", arg))
    return 1;

#if defined (__MSDOS__)
  /* more.com doesn't grok slashes in pathnames */
  sprintf (syscom, "less %s", arg);
#else
  sprintf (syscom, "more %s", arg);
#endif
  return (system (syscom));
}
warning: parse error {
  if (!valid_argument ("view", arg))
    return 1;

#if defined (__MSDOS__)
  /* more.com doesn't grok slashes in pathnames */
  sprintf (syscom, "less %s", arg);
#else
  sprintf (syscom, "more %s", arg);
#endif
  return (system (syscom));
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\examples\fileman.c:332
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\examples\fileman.c:345
parsing error 
{
  too_dangerous ("rename");
  return (1);
}
warning: parse error {
  too_dangerous ("rename");
  return (1);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\examples\fileman.c:347
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\examples\fileman.c:352
parsing error 
{
  struct stat finfo;

  if (!valid_argument ("stat", arg))
    return (1);

  if (stat (arg, &finfo) == -1)
    {
      perror (arg);
      return (1);
    }

  printf ("Statistics for `%s':\n", arg);

  printf ("%s has %d link%s, and is %d byte%s in length.\n",
	  arg,
          finfo.st_nlink,
          (finfo.st_nlink == 1) ? "" : "s",
          finfo.st_size,
          (finfo.st_size == 1) ? "" : "s");
  printf ("Inode Last Change at: %s", ctime (&finfo.st_ctime));
  printf ("      Last access at: %s", ctime (&finfo.st_atime));
  printf ("    Last modified at: %s", ctime (&finfo.st_mtime));
  return (0);
}
warning: parse error {
  struct stat finfo;

  if (!valid_argument ("stat", arg))
    return (1);

  if (stat (arg, &finfo) == -1)
    {
      perror (arg);
      return (1);
    }

  printf ("Statistics for `%s':\n", arg);

  printf ("%s has %d link%s, and is %d byte%s in length.\n",
	  arg,
          finfo.st_nlink,
          (finfo.st_nlink == 1) ? "" : "s",
          finfo.st_size,
          (finfo.st_size == 1) ? "" : "s");
  printf ("Inode Last Change at: %s", ctime (&finfo.st_ctime));
  printf ("      Last access at: %s", ctime (&finfo.st_atime));
  printf ("    Last modified at: %s", ctime (&finfo.st_mtime));
  return (0);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\examples\fileman.c:354
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\examples\fileman.c:380
parsing error 
{
  too_dangerous ("delete");
  return (1);
}
warning: parse error {
  too_dangerous ("delete");
  return (1);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\examples\fileman.c:382
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\examples\fileman.c:389
parsing error 
{
  register int i;
  int printed = 0;

  for (i = 0; commands[i].name; i++)
    {
      if (!*arg || (strcmp (arg, commands[i].name) == 0))
        {
          printf ("%s\t\t%s.\n", commands[i].name, commands[i].doc);
          printed++;
        }
    }

  if (!printed)
    {
      printf ("No commands match `%s'.  Possibilties are:\n", arg);

      for (i = 0; commands[i].name; i++)
        {
          /* Print in six columns. */
          if (printed == 6)
            {
              printed = 0;
              printf ("\n");
            }

          printf ("%s\t", commands[i].name);
          printed++;
        }

      if (printed)
        printf ("\n");
    }
  return (0);
}
warning: parse error {
  register int i;
  int printed = 0;

  for (i = 0; commands[i].name; i++)
    {
      if (!*arg || (strcmp (arg, commands[i].name) == 0))
        {
          printf ("%s\t\t%s.\n", commands[i].name, commands[i].doc);
          printed++;
        }
    }

  if (!printed)
    {
      printf ("No commands match `%s'.  Possibilties are:\n", arg);

      for (i = 0; commands[i].name; i++)
        {
          /* Print in six columns. */
          if (printed == 6)
            {
              printed = 0;
              printf ("\n");
            }

          printf ("%s\t", commands[i].name);
          printed++;
        }

      if (printed)
        printf ("\n");
    }
  return (0);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\examples\fileman.c:391
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\examples\fileman.c:428
parsing error 
{
  if (chdir (arg) == -1)
    {
      perror (arg);
      return 1;
    }

  com_pwd ("");
  return (0);
}
warning: parse error {
  if (chdir (arg) == -1)
    {
      perror (arg);
      return 1;
    }

  com_pwd ("");
  return (0);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\examples\fileman.c:430
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\examples\fileman.c:442
parsing error 
{
  char dir[1024], *s;

  s = getcwd (dir, sizeof(dir) - 1);
  if (s == 0)
    {
      printf ("Error getting pwd: %s\n", dir);
      return 1;
    }

  printf ("Current directory is %s\n", dir);
  return 0;
}
warning: parse error {
  char dir[1024], *s;

  s = getcwd (dir, sizeof(dir) - 1);
  if (s == 0)
    {
      printf ("Error getting pwd: %s\n", dir);
      return 1;
    }

  printf ("Current directory is %s\n", dir);
  return 0;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\examples\fileman.c:444
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\examples\fileman.c:459
parsing error 
{
  done = 1;
  return (0);
}
warning: parse error {
  done = 1;
  return (0);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\examples\fileman.c:461
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\examples\fileman.c:467
parsing error 
{
  fprintf (stderr,
           "%s: Too dangerous for me to distribute.  Write it yourself.\n",
           caller);
}
warning: parse error {
  fprintf (stderr,
           "%s: Too dangerous for me to distribute.  Write it yourself.\n",
           caller);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\examples\fileman.c:469
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\examples\fileman.c:478
parsing error 
{
  if (!arg || !*arg)
    {
      fprintf (stderr, "%s: Argument required.\n", caller);
      return (0);
    }

  return (1);
}
warning: parse error {
  if (!arg || !*arg)
    {
      fprintf (stderr, "%s: Argument required.\n", caller);
      return (0);
    }

  return (1);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\examples\fileman.c:480
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\examples\histexamp.c...
parsing error 
main (argc, argv)
     int argc;
warning: parse error main (argc, argv)
     int argc;Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\examples\histexamp.c:32
parsing error 
{
  char line[1024], *t;
  int len, done;

  line[0] = 0;
  done = 0;

  using_history ();
  while (!done)
    {
      printf ("history$ ");
      fflush (stdout);
      t = fgets (line, sizeof (line) - 1, stdin);
      if (t && *t)
	{
	  len = strlen (t);
	  if (t[len - 1] == '\n')
	    t[len - 1] = '\0';
	}

      if (!t)
	strcpy (line, "quit");

      if (line[0])
	{
	  char *expansion;
	  int result;

	  using_history ();

	  result = history_expand (line, &expansion);
	  if (result)
	    fprintf (stderr, "%s\n", expansion);

	  if (result < 0 || result == 2)
	    {
	      free (expansion);
	      continue;
	    }

	  add_history (expansion);
	  strncpy (line, expansion, sizeof (line) - 1);
	  free (expansion);
	}

      if (strcmp (line, "quit") == 0)
	done = 1;
      else if (strcmp (line, "save") == 0)
	write_history ("history_file");
      else if (strcmp (line, "read") == 0)
	read_history ("history_file");
      else if (strcmp (line, "list") == 0)
	{
	  register HIST_ENTRY **the_list;
	  register int i;
	  time_t tt;
	  char timestr[128];

	  the_list = history_list ();
	  if (the_list)
	    for (i = 0; the_list[i]; i++)
	      {
	      	tt = history_get_time (the_list[i]);
		if (tt)
		  strftime (timestr, sizeof (timestr), "%a %R", localtime(&tt));
		else
		  strcpy (timestr, "??");
	        printf ("%d: %s: %s\n", i + history_base, timestr, the_list[i]->line);
	      }
	}
      else if (strncmp (line, "delete", 6) == 0)
	{
	  int which;
	  if ((sscanf (line + 6, "%d", &which)) == 1)
	    {
	      HIST_ENTRY *entry = remove_history (which);
	      if (!entry)
		fprintf (stderr, "No such entry %d\n", which);
	      else
		{
		  free (entry->line);
		  free (entry);
		}
	    }
	  else
	    {
	      fprintf (stderr, "non-numeric arg given to `delete'\n");
	    }
	}
    }
}
warning: parse error {
  char line[1024], *t;
  int len, done;

  line[0] = 0;
  done = 0;

  using_history ();
  while (!done)
    {
      printf ("history$ ");
      fflush (stdout);
      t = fgets (line, sizeof (line) - 1, stdin);
      if (t && *t)
	{
	  len = strlen (t);
	  if (t[len - 1] == '\n')
	    t[len - 1] = '\0';
	}

      if (!t)
	strcpy (line, "quit");

      if (line[0])
	{
	  char *expansion;
	  int result;

	  using_history ();

	  result = history_expand (line, &expansion);
	  if (result)
	    fprintf (stderr, "%s\n", expansion);

	  if (result < 0 || result == 2)
	    {
	      free (expansion);
	      continue;
	    }

	  add_history (expansion);
	  strncpy (line, expansion, sizeof (line) - 1);
	  free (expansion);
	}

      if (strcmp (line, "quit") == 0)
	done = 1;
      else if (strcmp (line, "save") == 0)
	write_history ("history_file");
      else if (strcmp (line, "read") == 0)
	read_history ("history_file");
      else if (strcmp (line, "list") == 0)
	{
	  register HIST_ENTRY **the_list;
	  register int i;
	  time_t tt;
	  char timestr[128];

	  the_list = history_list ();
	  if (the_list)
	    for (i = 0; the_list[i]; i++)
	      {
	      	tt = history_get_time (the_list[i]);
		if (tt)
		  strftime (timestr, sizeof (timestr), "%a %R", localtime(&tt));
		else
		  strcpy (timestr, "??");
	        printf ("%d: %s: %s\n", i + history_base, timestr, the_list[i]->line);
	      }
	}
      else if (strncmp (line, "delete", 6) == 0)
	{
	  int which;
	  if ((sscanf (line + 6, "%d", &which)) == 1)
	    {
	      HIST_ENTRY *entry = remove_history (which);
	      if (!entry)
		fprintf (stderr, "No such entry %d\n", which);
	      else
		{
		  free (entry->line);
		  free (entry);
		}
	    }
	  else
	    {
	      fprintf (stderr, "non-numeric arg given to `delete'\n");
	    }
	}
    }
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\examples\histexamp.c:35
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\examples\manexamp.c...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h...skip
parsing error 
invert_case_line (count, key)
     int count, key;
warning: parse error invert_case_line (count, key)
     int count, key;Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\examples\manexamp.c:63
parsing error 
{
  register int start, end;

  start = rl_point;

  if (count < 0)
    {
      direction = -1;
      count = -count;
    }
  else
    direction = 1;
      
  /* Find the end of the range to modify. */
  end = start + (count * direction);

  /* Force it to be within range. */
  if (end > rl_end)
    end = rl_end;
  else if (end < 0)
    end = -1;

  if (start > end)
    {
      int temp = start;
      start = end;
      end = temp;
    }

  if (start == end)
    return;

  /* Tell readline that we are modifying the line, so save the undo
     information. */
  rl_modifying (start, end);

  for (; start != end; start += direction)
    {
      if (_rl_uppercase_p (rl_line_buffer[start]))
	rl_line_buffer[start] = _rl_to_lower (rl_line_buffer[start]);
      else if (_rl_lowercase_p (rl_line_buffer[start]))
	rl_line_buffer[start] = _rl_to_upper (rl_line_buffer[start]);
    }

  /* Move point to on top of the last character changed. */
  rl_point = end - direction;
}
warning: parse error {
  register int start, end;

  start = rl_point;

  if (count < 0)
    {
      direction = -1;
      count = -count;
    }
  else
    direction = 1;
      
  /* Find the end of the range to modify. */
  end = start + (count * direction);

  /* Force it to be within range. */
  if (end > rl_end)
    end = rl_end;
  else if (end < 0)
    end = -1;

  if (start > end)
    {
      int temp = start;
      start = end;
      end = temp;
    }

  if (start == end)
    return;

  /* Tell readline that we are modifying the line, so save the undo
     information. */
  rl_modifying (start, end);

  for (; start != end; start += direction)
    {
      if (_rl_uppercase_p (rl_line_buffer[start]))
	rl_line_buffer[start] = _rl_to_lower (rl_line_buffer[start]);
      else if (_rl_lowercase_p (rl_line_buffer[start]))
	rl_line_buffer[start] = _rl_to_upper (rl_line_buffer[start]);
    }

  /* Move point to on top of the last character changed. */
  rl_point = end - direction;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\examples\manexamp.c:65
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\examples\rl.c...
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\examples\rl.c:80
parsing error 
{
  char *temp, *prompt;
  struct stat sb;
  int opt, fd, nch;
  FILE *ifp;

  progname = strrchr(argv[0], '/');
  if (progname == 0)
    progname = argv[0];
  else
    progname++;

  /* defaults */
  prompt = "readline$ ";
  fd = nch = 0;
  deftext = (char *)0;

  while ((opt = getopt(argc, argv, "p:u:d:n:")) != EOF)
    {
      switch (opt)
	{
	case 'p':
	  prompt = optarg;
	  break;
	case 'u':
	  fd = atoi(optarg);
	  if (fd < 0)
	    {
	      fprintf (stderr, "%s: bad file descriptor `%s'\n", progname, optarg);
	      exit (2);
	    }
	  break;
	case 'd':
	  deftext = optarg;
	  break;
	case 'n':
	  nch = atoi(optarg);
	  if (nch < 0)
	    {
	      fprintf (stderr, "%s: bad value for -n: `%s'\n", progname, optarg);
	      exit (2);
	    }
	  break;
	default:
	  usage ();
	  exit (2);
	}
    }

  if (fd != 0)
    {
      if (fstat (fd, &sb) < 0)
	{
	  fprintf (stderr, "%s: %d: bad file descriptor\n", progname, fd);
	  exit (1);
	}
      ifp = fdopen (fd, "r");
      rl_instream = ifp;
    }

  if (deftext && *deftext)
    rl_startup_hook = set_deftext;

  if (nch > 0)
    rl_num_chars_to_read = nch;

  temp = readline (prompt);

  /* Test for EOF. */
  if (temp == 0)
    exit (1);

  printf ("%s\n", temp);
  exit (0);
}
warning: parse error {
  char *temp, *prompt;
  struct stat sb;
  int opt, fd, nch;
  FILE *ifp;

  progname = strrchr(argv[0], '/');
  if (progname == 0)
    progname = argv[0];
  else
    progname++;

  /* defaults */
  prompt = "readline$ ";
  fd = nch = 0;
  deftext = (char *)0;

  while ((opt = getopt(argc, argv, "p:u:d:n:")) != EOF)
    {
      switch (opt)
	{
	case 'p':
	  prompt = optarg;
	  break;
	case 'u':
	  fd = atoi(optarg);
	  if (fd < 0)
	    {
	      fprintf (stderr, "%s: bad file descriptor `%s'\n", progname, optarg);
	      exit (2);
	    }
	  break;
	case 'd':
	  deftext = optarg;
	  break;
	case 'n':
	  nch = atoi(optarg);
	  if (nch < 0)
	    {
	      fprintf (stderr, "%s: bad value for -n: `%s'\n", progname, optarg);
	      exit (2);
	    }
	  break;
	default:
	  usage ();
	  exit (2);
	}
    }

  if (fd != 0)
    {
      if (fstat (fd, &sb) < 0)
	{
	  fprintf (stderr, "%s: %d: bad file descriptor\n", progname, fd);
	  exit (1);
	}
      ifp = fdopen (fd, "r");
      rl_instream = ifp;
    }

  if (deftext && *deftext)
    rl_startup_hook = set_deftext;

  if (nch > 0)
    rl_num_chars_to_read = nch;

  temp = readline (prompt);

  /* Test for EOF. */
  if (temp == 0)
    exit (1);

  printf ("%s\n", temp);
  exit (0);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\examples\rl.c:83
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\examples\rlcat.c...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\posixstat.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\examples\rlcat.c:75
parsing error 
{
  char *temp;
  int opt, Vflag, Nflag;

  progname = strrchr(argv[0], '/');
  if (progname == 0)
    progname = argv[0];
  else
    progname++;

  vflag = Vflag = Nflag = 0;
  while ((opt = getopt(argc, argv, "vEVN")) != EOF)
    {
      switch (opt)
	{
	case 'v':
	  vflag = 1;
	  break;
	case 'V':
	  Vflag = 1;
	  break;
	case 'E':
	  Vflag = 0;
	  break;
	case 'N':
	  Nflag = 1;
	  break;
	default:
	  usage ();
	  exit (2);
	}
    }

  argc -= optind;
  argv += optind;

  if (isatty(0) == 0 || argc || Nflag)
    return stdcat(argc, argv);

  rl_variable_bind ("editing-mode", Vflag ? "vi" : "emacs");
  while (temp = readline (""))
    {
      if (*temp)
        add_history (temp);
      printf ("%s\n", temp);
    }

  return (ferror (stdout));
}
warning: parse error {
  char *temp;
  int opt, Vflag, Nflag;

  progname = strrchr(argv[0], '/');
  if (progname == 0)
    progname = argv[0];
  else
    progname++;

  vflag = Vflag = Nflag = 0;
  while ((opt = getopt(argc, argv, "vEVN")) != EOF)
    {
      switch (opt)
	{
	case 'v':
	  vflag = 1;
	  break;
	case 'V':
	  Vflag = 1;
	  break;
	case 'E':
	  Vflag = 0;
	  break;
	case 'N':
	  Nflag = 1;
	  break;
	default:
	  usage ();
	  exit (2);
	}
    }

  argc -= optind;
  argv += optind;

  if (isatty(0) == 0 || argc || Nflag)
    return stdcat(argc, argv);

  rl_variable_bind ("editing-mode", Vflag ? "vi" : "emacs");
  while (temp = readline (""))
    {
      if (*temp)
        add_history (temp);
      printf ("%s\n", temp);
    }

  return (ferror (stdout));
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\examples\rlcat.c:78
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\examples\rlcat.c:129
parsing error 
{
  int c;
  char *x;

  while ((c = getc(fp)) != EOF)
    {
      if (vflag && isascii ((unsigned char)c) && isprint((unsigned char)c) == 0)
	{
	  x = rl_untranslate_keyseq (c);
	  if (fputs (x, stdout) != 0)
	    return 1;
	}
      else if (putchar (c) == EOF)
        return 1;
    }
  return (ferror (stdout));
}
warning: parse error {
  int c;
  char *x;

  while ((c = getc(fp)) != EOF)
    {
      if (vflag && isascii ((unsigned char)c) && isprint((unsigned char)c) == 0)
	{
	  x = rl_untranslate_keyseq (c);
	  if (fputs (x, stdout) != 0)
	    return 1;
	}
      else if (putchar (c) == EOF)
        return 1;
    }
  return (ferror (stdout));
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\examples\rlcat.c:131
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\examples\rlcat.c:150
parsing error 
{
  int  i, fd, r;
  char *s;
  FILE *fp;

  if (argc == 0)
    return (fcopy(stdin));

  for (i = 0, r = 1; i < argc; i++)
    {
      if (*argv[i] == '-' && argv[i][1] == 0)
	fp = stdin;
      else
	{
	  fp = fopen (argv[i], "r");
	  if (fp == 0)
	    {
	      fprintf (stderr, "%s: %s: cannot open: %s\n", progname, argv[i], strerror(errno));
	      continue;
	    }
        }
      r = fcopy (fp);
      if (fp != stdin)
	fclose(fp);
    }
  return r;
}
warning: parse error {
  int  i, fd, r;
  char *s;
  FILE *fp;

  if (argc == 0)
    return (fcopy(stdin));

  for (i = 0, r = 1; i < argc; i++)
    {
      if (*argv[i] == '-' && argv[i][1] == 0)
	fp = stdin;
      else
	{
	  fp = fopen (argv[i], "r");
	  if (fp == 0)
	    {
	      fprintf (stderr, "%s: %s: cannot open: %s\n", progname, argv[i], strerror(errno));
	      continue;
	    }
        }
      r = fcopy (fp);
      if (fp != stdin)
	fclose(fp);
    }
  return r;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\examples\rlcat.c:153
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\examples\rltest.c...
parsing error 
main ()
{
  char *temp, *prompt;
  int done;

  temp = (char *)NULL;
  prompt = "readline$ ";
  done = 0;

  while (!done)
    {
      temp = readline (prompt);

      /* Test for EOF. */
      if (!temp)
	exit (1);

      /* If there is anything on the line, print it and remember it. */
      if (*temp)
	{
	  fprintf (stderr, "%s\r\n", temp);
	  add_history (temp);
	}

      /* Check for `command' that we handle. */
      if (strcmp (temp, "quit") == 0)
	done = 1;

      if (strcmp (temp, "list") == 0)
	{
	  HIST_ENTRY **list;
	  register int i;

	  list = history_list ();
	  if (list)
	    {
	      for (i = 0; list[i]; i++)
		fprintf (stderr, "%d: %s\r\n", i, list[i]->line);
	    }
	}
      free (temp);
    }
  exit (0);
}
warning: parse error main ()
{
  char *temp, *prompt;
  int done;

  temp = (char *)NULL;
  prompt = "readline$ ";
  done = 0;

  while (!done)
    {
      temp = readline (prompt);

      /* Test for EOF. */
      if (!temp)
	exit (1);

      /* If there is anything on the line, print it and remember it. */
      if (*temp)
	{
	  fprintf (stderr, "%s\r\n", temp);
	  add_history (temp);
	}

      /* Check for `command' that we handle. */
      if (strcmp (temp, "quit") == 0)
	done = 1;

      if (strcmp (temp, "list") == 0)
	{
	  HIST_ENTRY **list;
	  register int i;

	  list = history_list ();
	  if (list)
	    {
	      for (i = 0; list[i]; i++)
		fprintf (stderr, "%d: %s\r\n", i, list[i]->line);
	    }
	}
      free (temp);
    }
  exit (0);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\examples\rltest.c:49
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\funmap.c...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\rlconf.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\xmalloc.h...skip
parsing error 
extern int _rl_qsort_string_compare PARAMS((char **, char **));
warning: parse error extern int _rl_qsort_string_compare PARAMS((char **, char **));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\funmap.c:49
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\funmap.c:202
parsing error 
{
  if (funmap_entry + 2 >= funmap_size)
    {
      funmap_size += 64;
      funmap = (FUNMAP **)xrealloc (funmap, funmap_size * sizeof (FUNMAP *));
    }
  
  funmap[funmap_entry] = (FUNMAP *)xmalloc (sizeof (FUNMAP));
  funmap[funmap_entry]->name = name;
  funmap[funmap_entry]->function = function;

  funmap[++funmap_entry] = (FUNMAP *)NULL;
  return funmap_entry;
}
warning: parse error {
  if (funmap_entry + 2 >= funmap_size)
    {
      funmap_size += 64;
      funmap = (FUNMAP **)xrealloc (funmap, funmap_size * sizeof (FUNMAP *));
    }
  
  funmap[funmap_entry] = (FUNMAP *)xmalloc (sizeof (FUNMAP));
  funmap[funmap_entry]->name = name;
  funmap[funmap_entry]->function = function;

  funmap[++funmap_entry] = (FUNMAP *)NULL;
  return funmap_entry;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\funmap.c:204
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\histexpand.c...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\rlmbutil.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\history.h...skip
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\histlib.h...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\rlshell.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\xmalloc.h...skip
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\histexpand.c:131
parsing error 
{
  register int i;
  register char c;
  HIST_ENTRY *entry;
  int which, sign, local_index, substring_okay;
  _hist_search_func_t *search_func;
  char *temp;

  /* The event can be specified in a number of ways.

     !!   the previous command
     !n   command line N
     !-n  current command-line minus N
     !str the most recent command starting with STR
     !?str[?]
	  the most recent command containing STR

     All values N are determined via HISTORY_BASE. */

  i = *caller_index;

  if (string[i] != history_expansion_char)
    return ((char *)NULL);

  /* Move on to the specification. */
  i++;

  sign = 1;
  substring_okay = 0;

#define RETURN_ENTRY(e, w) \
	return ((e = history_get (w)) ? e->line : (char *)NULL)

  /* Handle !! case. */
  if (string[i] == history_expansion_char)
    {
      i++;
      which = history_base + (history_length - 1);
      *caller_index = i;
      RETURN_ENTRY (entry, which);
    }

  /* Hack case of numeric line specification. */
  if (string[i] == '-')
    {
      sign = -1;
      i++;
    }

  if (_rl_digit_p (string[i]))
    {
      /* Get the extent of the digits and compute the value. */
      for (which = 0; _rl_digit_p (string[i]); i++)
	which = (which * 10) + _rl_digit_value (string[i]);

      *caller_index = i;

      if (sign < 0)
	which = (history_length + history_base) - which;

      RETURN_ENTRY (entry, which);
    }

  /* This must be something to search for.  If the spec begins with
     a '?', then the string may be anywhere on the line.  Otherwise,
     the string must be found at the start of a line. */
  if (string[i] == '?')
    {
      substring_okay++;
      i++;
    }

  /* Only a closing `?' or a newline delimit a substring search string. */
  for (local_index = i; c = string[i]; i++)
    {
#if defined (HANDLE_MULTIBYTE)
      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
	{
	  int v;
	  mbstate_t ps;

	  memset (&ps, 0, sizeof (mbstate_t));
	  /* These produce warnings because we're passing a const string to a
	     function that takes a non-const string. */
	  _rl_adjust_point ((char *)string, i, &ps);
	  if ((v = _rl_get_char_len ((char *)string + i, &ps)) > 1)
	    {
	      i += v - 1;
	      continue;
	    }
        }

#endif /* HANDLE_MULTIBYTE */
      if ((!substring_okay && (whitespace (c) || c == ':' ||
	  (history_search_delimiter_chars && member (c, history_search_delimiter_chars)) ||
	  string[i] == delimiting_quote)) ||
	  string[i] == '\n' ||
	  (substring_okay && string[i] == '?'))
	break;
    }

  which = i - local_index;
  temp = (char *)xmalloc (1 + which);
  if (which)
    strncpy (temp, string + local_index, which);
  temp[which] = '\0';

  if (substring_okay && string[i] == '?')
    i++;

  *caller_index = i;

#define FAIL_SEARCH() \
  do { \
    history_offset = history_length; xfree (temp) ; return (char *)NULL; \
  } while (0)

  /* If there is no search string, try to use the previous search string,
     if one exists.  If not, fail immediately. */
  if (*temp == '\0' && substring_okay)
    {
      if (search_string)
        {
          xfree (temp);
          temp = savestring (search_string);
        }
      else
        FAIL_SEARCH ();
    }

  search_func = substring_okay ? history_search : history_search_prefix;
  while (1)
    {
      local_index = (*search_func) (temp, -1);

      if (local_index < 0)
	FAIL_SEARCH ();

      if (local_index == 0 || substring_okay)
	{
	  entry = current_history ();
	  history_offset = history_length;
	
	  /* If this was a substring search, then remember the
	     string that we matched for word substitution. */
	  if (substring_okay)
	    {
	      FREE (search_string);
	      search_string = temp;

	      FREE (search_match);
	      search_match = history_find_word (entry->line, local_index);
	    }
	  else
	    xfree (temp);

	  return (entry->line);
	}

      if (history_offset)
	history_offset--;
      else
	FAIL_SEARCH ();
    }
#undef FAIL_SEARCH
#undef RETURN_ENTRY
}
warning: parse error {
  register int i;
  register char c;
  HIST_ENTRY *entry;
  int which, sign, local_index, substring_okay;
  _hist_search_func_t *search_func;
  char *temp;

  /* The event can be specified in a number of ways.

     !!   the previous command
     !n   command line N
     !-n  current command-line minus N
     !str the most recent command starting with STR
     !?str[?]
	  the most recent command containing STR

     All values N are determined via HISTORY_BASE. */

  i = *caller_index;

  if (string[i] != history_expansion_char)
    return ((char *)NULL);

  /* Move on to the specification. */
  i++;

  sign = 1;
  substring_okay = 0;

#define RETURN_ENTRY(e, w) \
	return ((e = history_get (w)) ? e->line : (char *)NULL)

  /* Handle !! case. */
  if (string[i] == history_expansion_char)
    {
      i++;
      which = history_base + (history_length - 1);
      *caller_index = i;
      RETURN_ENTRY (entry, which);
    }

  /* Hack case of numeric line specification. */
  if (string[i] == '-')
    {
      sign = -1;
      i++;
    }

  if (_rl_digit_p (string[i]))
    {
      /* Get the extent of the digits and compute the value. */
      for (which = 0; _rl_digit_p (string[i]); i++)
	which = (which * 10) + _rl_digit_value (string[i]);

      *caller_index = i;

      if (sign < 0)
	which = (history_length + history_base) - which;

      RETURN_ENTRY (entry, which);
    }

  /* This must be something to search for.  If the spec begins with
     a '?', then the string may be anywhere on the line.  Otherwise,
     the string must be found at the start of a line. */
  if (string[i] == '?')
    {
      substring_okay++;
      i++;
    }

  /* Only a closing `?' or a newline delimit a substring search string. */
  for (local_index = i; c = string[i]; i++)
    {
#if defined (HANDLE_MULTIBYTE)
      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
	{
	  int v;
	  mbstate_t ps;

	  memset (&ps, 0, sizeof (mbstate_t));
	  /* These produce warnings because we're passing a const string to a
	     function that takes a non-const string. */
	  _rl_adjust_point ((char *)string, i, &ps);
	  if ((v = _rl_get_char_len ((char *)string + i, &ps)) > 1)
	    {
	      i += v - 1;
	      continue;
	    }
        }

#endif /* HANDLE_MULTIBYTE */
      if ((!substring_okay && (whitespace (c) || c == ':' ||
	  (history_search_delimiter_chars && member (c, history_search_delimiter_chars)) ||
	  string[i] == delimiting_quote)) ||
	  string[i] == '\n' ||
	  (substring_okay && string[i] == '?'))
	break;
    }

  which = i - local_index;
  temp = (char *)xmalloc (1 + which);
  if (which)
    strncpy (temp, string + local_index, which);
  temp[which] = '\0';

  if (substring_okay && string[i] == '?')
    i++;

  *caller_index = i;

#define FAIL_SEARCH() \
  do { \
    history_offset = history_length; xfree (temp) ; return (char *)NULL; \
  } while (0)

  /* If there is no search string, try to use the previous search string,
     if one exists.  If not, fail immediately. */
  if (*temp == '\0' && substring_okay)
    {
      if (search_string)
        {
          xfree (temp);
          temp = savestring (search_string);
        }
      else
        FAIL_SEARCH ();
    }

  search_func = substring_okay ? history_search : history_search_prefix;
  while (1)
    {
      local_index = (*search_func) (temp, -1);

      if (local_index < 0)
	FAIL_SEARCH ();

      if (local_index == 0 || substring_okay)
	{
	  entry = current_history ();
	  history_offset = history_length;
	
	  /* If this was a substring search, then remember the
	     string that we matched for word substitution. */
	  if (substring_okay)
	    {
	      FREE (search_string);
	      search_string = temp;

	      FREE (search_match);
	      search_match = history_find_word (entry->line, local_index);
	    }
	  else
	    xfree (temp);

	  return (entry->line);
	}

      if (history_offset)
	history_offset--;
      else
	FAIL_SEARCH ();
    }
#undef FAIL_SEARCH
#undef RETURN_ENTRY
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\histexpand.c:134
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\histexpand.c:311
parsing error 
{
  register int i;

  for (i = *sindex; string[i] && string[i] != '\''; i++)
    {
      if ((flags & 1) && string[i] == '\\' && string[i+1])
        i++;
    }

  *sindex = i;
}
warning: parse error {
  register int i;

  for (i = *sindex; string[i] && string[i] != '\''; i++)
    {
      if ((flags & 1) && string[i] == '\\' && string[i+1])
        i++;
    }

  *sindex = i;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\histexpand.c:314
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\histexpand.c:327
parsing error 
{
  register char *p, *r;
  char *ret;
  int len = 3;

  for (p = s; p && *p; p++, len++)
    {
      if (*p == '\'')
	len += 3;
      else if (whitespace (*p) || *p == '\n')
	len += 2;
    }

  r = ret = (char *)xmalloc (len);
  *r++ = '\'';
  for (p = s; p && *p; )
    {
      if (*p == '\'')
	{
	  *r++ = '\'';
	  *r++ = '\\';
	  *r++ = '\'';
	  *r++ = '\'';
	  p++;
	}
      else if (whitespace (*p) || *p == '\n')
	{
	  *r++ = '\'';
	  *r++ = *p++;
	  *r++ = '\'';
	}
      else
	*r++ = *p++;
    }
  *r++ = '\'';
  *r = '\0';
  return ret;
}
warning: parse error {
  register char *p, *r;
  char *ret;
  int len = 3;

  for (p = s; p && *p; p++, len++)
    {
      if (*p == '\'')
	len += 3;
      else if (whitespace (*p) || *p == '\n')
	len += 2;
    }

  r = ret = (char *)xmalloc (len);
  *r++ = '\'';
  for (p = s; p && *p; )
    {
      if (*p == '\'')
	{
	  *r++ = '\'';
	  *r++ = '\\';
	  *r++ = '\'';
	  *r++ = '\'';
	  p++;
	}
      else if (whitespace (*p) || *p == '\n')
	{
	  *r++ = '\'';
	  *r++ = *p++;
	  *r++ = '\'';
	}
      else
	*r++ = *p++;
    }
  *r++ = '\'';
  *r = '\0';
  return ret;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\histexpand.c:329
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\histexpand.c:369
parsing error 
{
  char *temp;
  const char *emsg;
  int ll, elen;

  ll = current - start;

  switch (errtype)
    {
    case EVENT_NOT_FOUND:
      emsg = "event not found";
      elen = 15;
      break;
    case BAD_WORD_SPEC:
      emsg = "bad word specifier";
      elen = 18;
      break;
    case SUBST_FAILED:
      emsg = "substitution failed";
      elen = 19;
      break;
    case BAD_MODIFIER:
      emsg = "unrecognized history modifier";
      elen = 29;
      break;
    case NO_PREV_SUBST:
      emsg = "no previous substitution";
      elen = 24;
      break;
    default:
      emsg = "unknown expansion error";
      elen = 23;
      break;
    }

  temp = (char *)xmalloc (ll + elen + 3);
  strncpy (temp, s + start, ll);
  temp[ll] = ':';
  temp[ll + 1] = ' ';
  strcpy (temp + ll + 2, emsg);
  return (temp);
}
warning: parse error {
  char *temp;
  const char *emsg;
  int ll, elen;

  ll = current - start;

  switch (errtype)
    {
    case EVENT_NOT_FOUND:
      emsg = "event not found";
      elen = 15;
      break;
    case BAD_WORD_SPEC:
      emsg = "bad word specifier";
      elen = 18;
      break;
    case SUBST_FAILED:
      emsg = "substitution failed";
      elen = 19;
      break;
    case BAD_MODIFIER:
      emsg = "unrecognized history modifier";
      elen = 29;
      break;
    case NO_PREV_SUBST:
      emsg = "no previous substitution";
      elen = 24;
      break;
    default:
      emsg = "unknown expansion error";
      elen = 23;
      break;
    }

  temp = (char *)xmalloc (ll + elen + 3);
  strncpy (temp, s + start, ll);
  temp[ll] = ':';
  temp[ll + 1] = ' ';
  strcpy (temp + ll + 2, emsg);
  return (temp);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\histexpand.c:372
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\histexpand.c:428
parsing error 
{
  register int si, i, j, k;
  char *s;
#if defined (HANDLE_MULTIBYTE)
  mbstate_t ps;
#endif

  s = (char *)NULL;
  i = *iptr;

#if defined (HANDLE_MULTIBYTE)
  memset (&ps, 0, sizeof (mbstate_t));
  _rl_adjust_point (str, i, &ps);
#endif

  for (si = i; str[si] && str[si] != delimiter; si++)
#if defined (HANDLE_MULTIBYTE)
    if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
      {
	int v;
	if ((v = _rl_get_char_len (str + si, &ps)) > 1)
	  si += v - 1;
	else if (str[si] == '\\' && str[si + 1] == delimiter)
	  si++;
      }
    else
#endif /* HANDLE_MULTIBYTE */
      if (str[si] == '\\' && str[si + 1] == delimiter)
	si++;

  if (si > i || is_rhs)
    {
      s = (char *)xmalloc (si - i + 1);
      for (j = 0, k = i; k < si; j++, k++)
	{
	  /* Remove a backslash quoting the search string delimiter. */
	  if (str[k] == '\\' && str[k + 1] == delimiter)
	    k++;
	  s[j] = str[k];
	}
      s[j] = '\0';
      if (lenptr)
	*lenptr = j;
    }

  i = si;
  if (str[i])
    i++;
  *iptr = i;

  return s;
}
warning: parse error {
  register int si, i, j, k;
  char *s;
#if defined (HANDLE_MULTIBYTE)
  mbstate_t ps;
#endif

  s = (char *)NULL;
  i = *iptr;

#if defined (HANDLE_MULTIBYTE)
  memset (&ps, 0, sizeof (mbstate_t));
  _rl_adjust_point (str, i, &ps);
#endif

  for (si = i; str[si] && str[si] != delimiter; si++)
#if defined (HANDLE_MULTIBYTE)
    if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
      {
	int v;
	if ((v = _rl_get_char_len (str + si, &ps)) > 1)
	  si += v - 1;
	else if (str[si] == '\\' && str[si + 1] == delimiter)
	  si++;
      }
    else
#endif /* HANDLE_MULTIBYTE */
      if (str[si] == '\\' && str[si + 1] == delimiter)
	si++;

  if (si > i || is_rhs)
    {
      s = (char *)xmalloc (si - i + 1);
      for (j = 0, k = i; k < si; j++, k++)
	{
	  /* Remove a backslash quoting the search string delimiter. */
	  if (str[k] == '\\' && str[k + 1] == delimiter)
	    k++;
	  s[j] = str[k];
	}
      s[j] = '\0';
      if (lenptr)
	*lenptr = j;
    }

  i = si;
  if (str[i])
    i++;
  *iptr = i;

  return s;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\histexpand.c:431
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\histexpand.c:522
parsing error 
{
  int i, n, starting_index;
  int substitute_globally, subst_bywords, want_quotes, print_only;
  char *event, *temp, *result, *tstr, *t, c, *word_spec;
  int result_len;
#if defined (HANDLE_MULTIBYTE)
  mbstate_t ps;

  memset (&ps, 0, sizeof (mbstate_t));
#endif

  result = (char *)xmalloc (result_len = 128);

  i = start;

  /* If it is followed by something that starts a word specifier,
     then !! is implied as the event specifier. */

  if (member (string[i + 1], ":$*%^"))
    {
      char fake_s[3];
      int fake_i = 0;
      i++;
      fake_s[0] = fake_s[1] = history_expansion_char;
      fake_s[2] = '\0';
      event = get_history_event (fake_s, &fake_i, 0);
    }
  else if (string[i + 1] == '#')
    {
      i += 2;
      event = current_line;
    }
  else
    {
      int quoted_search_delimiter = 0;

      /* If the character before this `!' is a double or single
	 quote, then this expansion takes place inside of the
	 quoted string.  If we have to search for some text ("!foo"),
	 allow the delimiter to end the search string. */
#if defined (HANDLE_MULTIBYTE)
      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
	{
	  int ch, l;
	  l = _rl_find_prev_mbchar (string, i, MB_FIND_ANY);
	  ch = string[l];
	  /* XXX - original patch had i - 1 ???  If i == 0 it would fail. */
	  if (i && (ch == '\'' || ch == '"'))
	    quoted_search_delimiter = ch;
	}
      else
#endif /* HANDLE_MULTIBYTE */	  
	if (i && (string[i - 1] == '\'' || string[i - 1] == '"'))
	  quoted_search_delimiter = string[i - 1];

      event = get_history_event (string, &i, quoted_search_delimiter);
    }
	  
  if (event == 0)
    {
      *ret_string = hist_error (string, start, i, EVENT_NOT_FOUND);
      xfree (result);
      return (-1);
    }

  /* If a word specifier is found, then do what that requires. */
  starting_index = i;
  word_spec = get_history_word_specifier (string, event, &i);

  /* There is no such thing as a `malformed word specifier'.  However,
     it is possible for a specifier that has no match.  In that case,
     we complain. */
  if (word_spec == (char *)&error_pointer)
    {
      *ret_string = hist_error (string, starting_index, i, BAD_WORD_SPEC);
      xfree (result);
      return (-1);
    }

  /* If no word specifier, than the thing of interest was the event. */
  temp = word_spec ? savestring (word_spec) : savestring (event);
  FREE (word_spec);

  /* Perhaps there are other modifiers involved.  Do what they say. */
  want_quotes = substitute_globally = subst_bywords = print_only = 0;
  starting_index = i;

  while (string[i] == ':')
    {
      c = string[i + 1];

      if (c == 'g' || c == 'a')
	{
	  substitute_globally = 1;
	  i++;
	  c = string[i + 1];
	}
      else if (c == 'G')
	{
	  subst_bywords = 1;
	  i++;
	  c = string[i + 1];
	}

      switch (c)
	{
	default:
	  *ret_string = hist_error (string, i+1, i+2, BAD_MODIFIER);
	  xfree (result);
	  xfree (temp);
	  return -1;

	case 'q':
	  want_quotes = 'q';
	  break;

	case 'x':
	  want_quotes = 'x';
	  break;

	  /* :p means make this the last executed line.  So we
	     return an error state after adding this line to the
	     history. */
	case 'p':
	  print_only++;
	  break;

	  /* :t discards all but the last part of the pathname. */
	case 't':
	  tstr = strrchr (temp, '/');
	  if (tstr)
	    {
	      tstr++;
	      t = savestring (tstr);
	      xfree (temp);
	      temp = t;
	    }
	  break;

	  /* :h discards the last part of a pathname. */
	case 'h':
	  tstr = strrchr (temp, '/');
	  if (tstr)
	    *tstr = '\0';
	  break;

	  /* :r discards the suffix. */
	case 'r':
	  tstr = strrchr (temp, '.');
	  if (tstr)
	    *tstr = '\0';
	  break;

	  /* :e discards everything but the suffix. */
	case 'e':
	  tstr = strrchr (temp, '.');
	  if (tstr)
	    {
	      t = savestring (tstr);
	      xfree (temp);
	      temp = t;
	    }
	  break;

	/* :s/this/that substitutes `that' for the first
	   occurrence of `this'.  :gs/this/that substitutes `that'
	   for each occurrence of `this'.  :& repeats the last
	   substitution.  :g& repeats the last substitution
	   globally. */

	case '&':
	case 's':
	  {
	    char *new_event;
	    int delimiter, failed, si, l_temp, ws, we;

	    if (c == 's')
	      {
		if (i + 2 < (int)strlen (string))
		  {
#if defined (HANDLE_MULTIBYTE)
		    if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
		      {
			_rl_adjust_point (string, i + 2, &ps);
			if (_rl_get_char_len (string + i + 2, &ps) > 1)
			  delimiter = 0;
			else
			  delimiter = string[i + 2];
		      }
		    else
#endif /* HANDLE_MULTIBYTE */
		      delimiter = string[i + 2];
		  }
		else
		  break;	/* no search delimiter */

		i += 3;

		t = get_subst_pattern (string, &i, delimiter, 0, &subst_lhs_len);
		/* An empty substitution lhs with no previous substitution
		   uses the last search string as the lhs. */
		if (t)
		  {
		    FREE (subst_lhs);
		    subst_lhs = t;
		  }
		else if (!subst_lhs)
		  {
		    if (search_string && *search_string)
		      {
			subst_lhs = savestring (search_string);
			subst_lhs_len = strlen (subst_lhs);
		      }
		    else
		      {
			subst_lhs = (char *) NULL;
			subst_lhs_len = 0;
		      }
		  }

		FREE (subst_rhs);
		subst_rhs = get_subst_pattern (string, &i, delimiter, 1, &subst_rhs_len);

		/* If `&' appears in the rhs, it's supposed to be replaced
		   with the lhs. */
		if (member ('&', subst_rhs))
		  postproc_subst_rhs ();
	      }
	    else
	      i += 2;

	    /* If there is no lhs, the substitution can't succeed. */
	    if (subst_lhs_len == 0)
	      {
		*ret_string = hist_error (string, starting_index, i, NO_PREV_SUBST);
		xfree (result);
		xfree (temp);
		return -1;
	      }

	    l_temp = strlen (temp);
	    /* Ignore impossible cases. */
	    if (subst_lhs_len > l_temp)
	      {
		*ret_string = hist_error (string, starting_index, i, SUBST_FAILED);
		xfree (result);
		xfree (temp);
		return (-1);
	      }

	    /* Find the first occurrence of THIS in TEMP. */
	    /* Substitute SUBST_RHS for SUBST_LHS in TEMP.  There are three
	       cases to consider:

		 1.  substitute_globally == subst_bywords == 0
		 2.  substitute_globally == 1 && subst_bywords == 0
		 3.  substitute_globally == 0 && subst_bywords == 1

	       In the first case, we substitute for the first occurrence only.
	       In the second case, we substitute for every occurrence.
	       In the third case, we tokenize into words and substitute the
	       first occurrence of each word. */

	    si = we = 0;
	    for (failed = 1; (si + subst_lhs_len) <= l_temp; si++)
	      {
		/* First skip whitespace and find word boundaries if
		   we're past the end of the word boundary we found
		   the last time. */
		if (subst_bywords && si > we)
		  {
		    for (; temp[si] && whitespace (temp[si]); si++)
		      ;
		    ws = si;
		    we = history_tokenize_word (temp, si);
		  }

		if (STREQN (temp+si, subst_lhs, subst_lhs_len))
		  {
		    int len = subst_rhs_len - subst_lhs_len + l_temp;
		    new_event = (char *)xmalloc (1 + len);
		    strncpy (new_event, temp, si);
		    strncpy (new_event + si, subst_rhs, subst_rhs_len);
		    strncpy (new_event + si + subst_rhs_len,
			     temp + si + subst_lhs_len,
			     l_temp - (si + subst_lhs_len));
		    new_event[len] = '\0';
		    xfree (temp);
		    temp = new_event;

		    failed = 0;

		    if (substitute_globally)
		      {
			/* Reported to fix a bug that causes it to skip every
			   other match when matching a single character.  Was
			   si += subst_rhs_len previously. */
			si += subst_rhs_len - 1;
			l_temp = strlen (temp);
			substitute_globally++;
			continue;
		      }
		    else if (subst_bywords)
		      {
			si = we;
			l_temp = strlen (temp);
			continue;
		      }
		    else
		      break;
		  }
	      }

	    if (substitute_globally > 1)
	      {
		substitute_globally = 0;
		continue;	/* don't want to increment i */
	      }

	    if (failed == 0)
	      continue;		/* don't want to increment i */

	    *ret_string = hist_error (string, starting_index, i, SUBST_FAILED);
	    xfree (result);
	    xfree (temp);
	    return (-1);
	  }
	}
      i += 2;
    }
  /* Done with modfiers. */
  /* Believe it or not, we have to back the pointer up by one. */
  --i;

  if (want_quotes)
    {
      char *x;

      if (want_quotes == 'q')
	x = sh_single_quote (temp);
      else if (want_quotes == 'x')
	x = quote_breaks (temp);
      else
	x = savestring (temp);

      xfree (temp);
      temp = x;
    }

  n = strlen (temp);
  if (n >= result_len)
    result = (char *)xrealloc (result, n + 2);
  strcpy (result, temp);
  xfree (temp);

  *end_index_ptr = i;
  *ret_string = result;
  return (print_only);
}
warning: parse error {
  int i, n, starting_index;
  int substitute_globally, subst_bywords, want_quotes, print_only;
  char *event, *temp, *result, *tstr, *t, c, *word_spec;
  int result_len;
#if defined (HANDLE_MULTIBYTE)
  mbstate_t ps;

  memset (&ps, 0, sizeof (mbstate_t));
#endif

  result = (char *)xmalloc (result_len = 128);

  i = start;

  /* If it is followed by something that starts a word specifier,
     then !! is implied as the event specifier. */

  if (member (string[i + 1], ":$*%^"))
    {
      char fake_s[3];
      int fake_i = 0;
      i++;
      fake_s[0] = fake_s[1] = history_expansion_char;
      fake_s[2] = '\0';
      event = get_history_event (fake_s, &fake_i, 0);
    }
  else if (string[i + 1] == '#')
    {
      i += 2;
      event = current_line;
    }
  else
    {
      int quoted_search_delimiter = 0;

      /* If the character before this `!' is a double or single
	 quote, then this expansion takes place inside of the
	 quoted string.  If we have to search for some text ("!foo"),
	 allow the delimiter to end the search string. */
#if defined (HANDLE_MULTIBYTE)
      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
	{
	  int ch, l;
	  l = _rl_find_prev_mbchar (string, i, MB_FIND_ANY);
	  ch = string[l];
	  /* XXX - original patch had i - 1 ???  If i == 0 it would fail. */
	  if (i && (ch == '\'' || ch == '"'))
	    quoted_search_delimiter = ch;
	}
      else
#endif /* HANDLE_MULTIBYTE */	  
	if (i && (string[i - 1] == '\'' || string[i - 1] == '"'))
	  quoted_search_delimiter = string[i - 1];

      event = get_history_event (string, &i, quoted_search_delimiter);
    }
	  
  if (event == 0)
    {
      *ret_string = hist_error (string, start, i, EVENT_NOT_FOUND);
      xfree (result);
      return (-1);
    }

  /* If a word specifier is found, then do what that requires. */
  starting_index = i;
  word_spec = get_history_word_specifier (string, event, &i);

  /* There is no such thing as a `malformed word specifier'.  However,
     it is possible for a specifier that has no match.  In that case,
     we complain. */
  if (word_spec == (char *)&error_pointer)
    {
      *ret_string = hist_error (string, starting_index, i, BAD_WORD_SPEC);
      xfree (result);
      return (-1);
    }

  /* If no word specifier, than the thing of interest was the event. */
  temp = word_spec ? savestring (word_spec) : savestring (event);
  FREE (word_spec);

  /* Perhaps there are other modifiers involved.  Do what they say. */
  want_quotes = substitute_globally = subst_bywords = print_only = 0;
  starting_index = i;

  while (string[i] == ':')
    {
      c = string[i + 1];

      if (c == 'g' || c == 'a')
	{
	  substitute_globally = 1;
	  i++;
	  c = string[i + 1];
	}
      else if (c == 'G')
	{
	  subst_bywords = 1;
	  i++;
	  c = string[i + 1];
	}

      switch (c)
	{
	default:
	  *ret_string = hist_error (string, i+1, i+2, BAD_MODIFIER);
	  xfree (result);
	  xfree (temp);
	  return -1;

	case 'q':
	  want_quotes = 'q';
	  break;

	case 'x':
	  want_quotes = 'x';
	  break;

	  /* :p means make this the last executed line.  So we
	     return an error state after adding this line to the
	     history. */
	case 'p':
	  print_only++;
	  break;

	  /* :t discards all but the last part of the pathname. */
	case 't':
	  tstr = strrchr (temp, '/');
	  if (tstr)
	    {
	      tstr++;
	      t = savestring (tstr);
	      xfree (temp);
	      temp = t;
	    }
	  break;

	  /* :h discards the last part of a pathname. */
	case 'h':
	  tstr = strrchr (temp, '/');
	  if (tstr)
	    *tstr = '\0';
	  break;

	  /* :r discards the suffix. */
	case 'r':
	  tstr = strrchr (temp, '.');
	  if (tstr)
	    *tstr = '\0';
	  break;

	  /* :e discards everything but the suffix. */
	case 'e':
	  tstr = strrchr (temp, '.');
	  if (tstr)
	    {
	      t = savestring (tstr);
	      xfree (temp);
	      temp = t;
	    }
	  break;

	/* :s/this/that substitutes `that' for the first
	   occurrence of `this'.  :gs/this/that substitutes `that'
	   for each occurrence of `this'.  :& repeats the last
	   substitution.  :g& repeats the last substitution
	   globally. */

	case '&':
	case 's':
	  {
	    char *new_event;
	    int delimiter, failed, si, l_temp, ws, we;

	    if (c == 's')
	      {
		if (i + 2 < (int)strlen (string))
		  {
#if defined (HANDLE_MULTIBYTE)
		    if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
		      {
			_rl_adjust_point (string, i + 2, &ps);
			if (_rl_get_char_len (string + i + 2, &ps) > 1)
			  delimiter = 0;
			else
			  delimiter = string[i + 2];
		      }
		    else
#endif /* HANDLE_MULTIBYTE */
		      delimiter = string[i + 2];
		  }
		else
		  break;	/* no search delimiter */

		i += 3;

		t = get_subst_pattern (string, &i, delimiter, 0, &subst_lhs_len);
		/* An empty substitution lhs with no previous substitution
		   uses the last search string as the lhs. */
		if (t)
		  {
		    FREE (subst_lhs);
		    subst_lhs = t;
		  }
		else if (!subst_lhs)
		  {
		    if (search_string && *search_string)
		      {
			subst_lhs = savestring (search_string);
			subst_lhs_len = strlen (subst_lhs);
		      }
		    else
		      {
			subst_lhs = (char *) NULL;
			subst_lhs_len = 0;
		      }
		  }

		FREE (subst_rhs);
		subst_rhs = get_subst_pattern (string, &i, delimiter, 1, &subst_rhs_len);

		/* If `&' appears in the rhs, it's supposed to be replaced
		   with the lhs. */
		if (member ('&', subst_rhs))
		  postproc_subst_rhs ();
	      }
	    else
	      i += 2;

	    /* If there is no lhs, the substitution can't succeed. */
	    if (subst_lhs_len == 0)
	      {
		*ret_string = hist_error (string, starting_index, i, NO_PREV_SUBST);
		xfree (result);
		xfree (temp);
		return -1;
	      }

	    l_temp = strlen (temp);
	    /* Ignore impossible cases. */
	    if (subst_lhs_len > l_temp)
	      {
		*ret_string = hist_error (string, starting_index, i, SUBST_FAILED);
		xfree (result);
		xfree (temp);
		return (-1);
	      }

	    /* Find the first occurrence of THIS in TEMP. */
	    /* Substitute SUBST_RHS for SUBST_LHS in TEMP.  There are three
	       cases to consider:

		 1.  substitute_globally == subst_bywords == 0
		 2.  substitute_globally == 1 && subst_bywords == 0
		 3.  substitute_globally == 0 && subst_bywords == 1

	       In the first case, we substitute for the first occurrence only.
	       In the second case, we substitute for every occurrence.
	       In the third case, we tokenize into words and substitute the
	       first occurrence of each word. */

	    si = we = 0;
	    for (failed = 1; (si + subst_lhs_len) <= l_temp; si++)
	      {
		/* First skip whitespace and find word boundaries if
		   we're past the end of the word boundary we found
		   the last time. */
		if (subst_bywords && si > we)
		  {
		    for (; temp[si] && whitespace (temp[si]); si++)
		      ;
		    ws = si;
		    we = history_tokenize_word (temp, si);
		  }

		if (STREQN (temp+si, subst_lhs, subst_lhs_len))
		  {
		    int len = subst_rhs_len - subst_lhs_len + l_temp;
		    new_event = (char *)xmalloc (1 + len);
		    strncpy (new_event, temp, si);
		    strncpy (new_event + si, subst_rhs, subst_rhs_len);
		    strncpy (new_event + si + subst_rhs_len,
			     temp + si + subst_lhs_len,
			     l_temp - (si + subst_lhs_len));
		    new_event[len] = '\0';
		    xfree (temp);
		    temp = new_event;

		    failed = 0;

		    if (substitute_globally)
		      {
			/* Reported to fix a bug that causes it to skip every
			   other match when matching a single character.  Was
			   si += subst_rhs_len previously. */
			si += subst_rhs_len - 1;
			l_temp = strlen (temp);
			substitute_globally++;
			continue;
		      }
		    else if (subst_bywords)
		      {
			si = we;
			l_temp = strlen (temp);
			continue;
		      }
		    else
		      break;
		  }
	      }

	    if (substitute_globally > 1)
	      {
		substitute_globally = 0;
		continue;	/* don't want to increment i */
	      }

	    if (failed == 0)
	      continue;		/* don't want to increment i */

	    *ret_string = hist_error (string, starting_index, i, SUBST_FAILED);
	    xfree (result);
	    xfree (temp);
	    return (-1);
	  }
	}
      i += 2;
    }
  /* Done with modfiers. */
  /* Believe it or not, we have to back the pointer up by one. */
  --i;

  if (want_quotes)
    {
      char *x;

      if (want_quotes == 'q')
	x = sh_single_quote (temp);
      else if (want_quotes == 'x')
	x = quote_breaks (temp);
      else
	x = savestring (temp);

      xfree (temp);
      temp = x;
    }

  n = strlen (temp);
  if (n >= result_len)
    result = (char *)xrealloc (result, n + 2);
  strcpy (result, temp);
  xfree (temp);

  *end_index_ptr = i;
  *ret_string = result;
  return (print_only);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\histexpand.c:527
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\histexpand.c:926
parsing error 
{
  register int j;
  int i, r, l, passc, cc, modified, eindex, only_printing, dquote, flag;
  char *string;

  /* The output string, and its length. */
  int result_len;
  char *result;

#if defined (HANDLE_MULTIBYTE)
  char mb[MB_LEN_MAX];
  mbstate_t ps;
#endif

  /* Used when adding the string. */
  char *temp;

  if (output == 0)
    return 0;

  /* Setting the history expansion character to 0 inhibits all
     history expansion. */
  if (history_expansion_char == 0)
    {
      *output = savestring (hstring);
      return (0);
    }
    
  /* Prepare the buffer for printing error messages. */
  result = (char *)xmalloc (result_len = 256);
  result[0] = '\0';

  only_printing = modified = 0;
  l = strlen (hstring);

  /* Grovel the string.  Only backslash and single quotes can quote the
     history escape character.  We also handle arg specifiers. */

  /* Before we grovel forever, see if the history_expansion_char appears
     anywhere within the text. */

  /* The quick substitution character is a history expansion all right.  That
     is to say, "^this^that^" is equivalent to "!!:s^this^that^", and in fact,
     that is the substitution that we do. */
  if (hstring[0] == history_subst_char)
    {
      string = (char *)xmalloc (l + 5);

      string[0] = string[1] = history_expansion_char;
      string[2] = ':';
      string[3] = 's';
      strcpy (string + 4, hstring);
      l += 4;
    }
  else
    {
#if defined (HANDLE_MULTIBYTE)
      memset (&ps, 0, sizeof (mbstate_t));
#endif

      string = hstring;
      /* If not quick substitution, still maybe have to do expansion. */

      /* `!' followed by one of the characters in history_no_expand_chars
	 is NOT an expansion. */
      for (i = dquote = 0; string[i]; i++)
	{
#if defined (HANDLE_MULTIBYTE)
	  if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
	    {
	      int v;
	      v = _rl_get_char_len (string + i, &ps);
	      if (v > 1)
		{
		  i += v - 1;
		  continue;
		}
	    }
#endif /* HANDLE_MULTIBYTE */

	  cc = string[i + 1];
	  /* The history_comment_char, if set, appearing at the beginning
	     of a word signifies that the rest of the line should not have
	     history expansion performed on it.
	     Skip the rest of the line and break out of the loop. */
	  if (history_comment_char && string[i] == history_comment_char &&
	      (i == 0 || member (string[i - 1], history_word_delimiters)))
	    {
	      while (string[i])
		i++;
	      break;
	    }
	  else if (string[i] == history_expansion_char)
	    {
	      if (cc == 0 || member (cc, history_no_expand_chars))
		continue;
	      /* If the calling application has set
		 history_inhibit_expansion_function to a function that checks
		 for special cases that should not be history expanded,
		 call the function and skip the expansion if it returns a
		 non-zero value. */
	      else if (history_inhibit_expansion_function &&
			(*history_inhibit_expansion_function) (string, i))
		continue;
	      else
		break;
	    }
	  /* Shell-like quoting: allow backslashes to quote double quotes
	     inside a double-quoted string. */
	  else if (dquote && string[i] == '\\' && cc == '"')
	    i++;
	  /* More shell-like quoting:  if we're paying attention to single
	     quotes and letting them quote the history expansion character,
	     then we need to pay attention to double quotes, because single
	     quotes are not special inside double-quoted strings. */
	  else if (history_quotes_inhibit_expansion && string[i] == '"')
	    {
	      dquote = 1 - dquote;
	    }
	  else if (dquote == 0 && history_quotes_inhibit_expansion && string[i] == '\'')
	    {
	      /* If this is bash, single quotes inhibit history expansion. */
	      flag = (i > 0 && string[i - 1] == '$');
	      i++;
	      hist_string_extract_single_quoted (string, &i, flag);
	    }
	  else if (history_quotes_inhibit_expansion && string[i] == '\\')
	    {
	      /* If this is bash, allow backslashes to quote single
		 quotes and the history expansion character. */
	      if (cc == '\'' || cc == history_expansion_char)
		i++;
	    }
	  
	}
	  
      if (string[i] != history_expansion_char)
	{
	  xfree (result);
	  *output = savestring (string);
	  return (0);
	}
    }

  /* Extract and perform the substitution. */
  for (passc = dquote = i = j = 0; i < l; i++)
    {
      int tchar = string[i];

      if (passc)
	{
	  passc = 0;
	  ADD_CHAR (tchar);
	  continue;
	}

#if defined (HANDLE_MULTIBYTE)
      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
	{
	  int k, c;

	  c = tchar;
	  memset (mb, 0, sizeof (mb));
	  for (k = 0; k < MB_LEN_MAX; k++)
	    {
	      mb[k] = (char)c;
	      memset (&ps, 0, sizeof (mbstate_t));
	      if (_rl_get_char_len (mb, &ps) == -2)
		c = string[++i];
	      else
		break;
	    }
	  if (strlen (mb) > 1)
	    {
	      ADD_STRING (mb);
	      continue;
	    }
	}
#endif /* HANDLE_MULTIBYTE */

      if (tchar == history_expansion_char)
	tchar = -3;
      else if (tchar == history_comment_char)
	tchar = -2;

      switch (tchar)
	{
	default:
	  ADD_CHAR (string[i]);
	  break;

	case '\\':
	  passc++;
	  ADD_CHAR (tchar);
	  break;

	case '"':
	  dquote = 1 - dquote;
	  ADD_CHAR (tchar);
	  break;
	  
	case '\'':
	  {
	    /* If history_quotes_inhibit_expansion is set, single quotes
	       inhibit history expansion. */
	    if (dquote == 0 && history_quotes_inhibit_expansion)
	      {
		int quote, slen;

		flag = (i > 0 && string[i - 1] == '$');
		quote = i++;
		hist_string_extract_single_quoted (string, &i, flag);

		slen = i - quote + 2;
		temp = (char *)xmalloc (slen);
		strncpy (temp, string + quote, slen);
		temp[slen - 1] = '\0';
		ADD_STRING (temp);
		xfree (temp);
	      }
	    else
	      ADD_CHAR (string[i]);
	    break;
	  }

	case -2:		/* history_comment_char */
	  if (i == 0 || member (string[i - 1], history_word_delimiters))
	    {
	      temp = (char *)xmalloc (l - i + 1);
	      strcpy (temp, string + i);
	      ADD_STRING (temp);
	      xfree (temp);
	      i = l;
	    }
	  else
	    ADD_CHAR (string[i]);
	  break;

	case -3:		/* history_expansion_char */
	  cc = string[i + 1];

	  /* If the history_expansion_char is followed by one of the
	     characters in history_no_expand_chars, then it is not a
	     candidate for expansion of any kind. */
	  if (cc == 0 || member (cc, history_no_expand_chars) ||
	  		 (history_inhibit_expansion_function && (*history_inhibit_expansion_function) (string, i)))
	    {
	      ADD_CHAR (string[i]);
	      break;
	    }

#if defined (NO_BANG_HASH_MODIFIERS)
	  /* There is something that is listed as a `word specifier' in csh
	     documentation which means `the expanded text to this point'.
	     That is not a word specifier, it is an event specifier.  If we
	     don't want to allow modifiers with `!#', just stick the current
	     output line in again. */
	  if (cc == '#')
	    {
	      if (result)
		{
		  temp = (char *)xmalloc (1 + strlen (result));
		  strcpy (temp, result);
		  ADD_STRING (temp);
		  xfree (temp);
		}
	      i++;
	      break;
	    }
#endif

	  r = history_expand_internal (string, i, &eindex, &temp, result);
	  if (r < 0)
	    {
	      *output = temp;
	      xfree (result);
	      if (string != hstring)
		xfree (string);
	      return -1;
	    }
	  else
	    {
	      if (temp)
		{
		  modified++;
		  if (*temp)
		    ADD_STRING (temp);
		  xfree (temp);
		}
	      only_printing = r == 1;
	      i = eindex;
	    }
	  break;
	}
    }

  *output = result;
  if (string != hstring)
    xfree (string);

  if (only_printing)
    {
#if 0
      add_history (result);
#endif
      return (2);
    }

  return (modified != 0);
}
warning: parse error {
  register int j;
  int i, r, l, passc, cc, modified, eindex, only_printing, dquote, flag;
  char *string;

  /* The output string, and its length. */
  int result_len;
  char *result;

#if defined (HANDLE_MULTIBYTE)
  char mb[MB_LEN_MAX];
  mbstate_t ps;
#endif

  /* Used when adding the string. */
  char *temp;

  if (output == 0)
    return 0;

  /* Setting the history expansion character to 0 inhibits all
     history expansion. */
  if (history_expansion_char == 0)
    {
      *output = savestring (hstring);
      return (0);
    }
    
  /* Prepare the buffer for printing error messages. */
  result = (char *)xmalloc (result_len = 256);
  result[0] = '\0';

  only_printing = modified = 0;
  l = strlen (hstring);

  /* Grovel the string.  Only backslash and single quotes can quote the
     history escape character.  We also handle arg specifiers. */

  /* Before we grovel forever, see if the history_expansion_char appears
     anywhere within the text. */

  /* The quick substitution character is a history expansion all right.  That
     is to say, "^this^that^" is equivalent to "!!:s^this^that^", and in fact,
     that is the substitution that we do. */
  if (hstring[0] == history_subst_char)
    {
      string = (char *)xmalloc (l + 5);

      string[0] = string[1] = history_expansion_char;
      string[2] = ':';
      string[3] = 's';
      strcpy (string + 4, hstring);
      l += 4;
    }
  else
    {
#if defined (HANDLE_MULTIBYTE)
      memset (&ps, 0, sizeof (mbstate_t));
#endif

      string = hstring;
      /* If not quick substitution, still maybe have to do expansion. */

      /* `!' followed by one of the characters in history_no_expand_chars
	 is NOT an expansion. */
      for (i = dquote = 0; string[i]; i++)
	{
#if defined (HANDLE_MULTIBYTE)
	  if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
	    {
	      int v;
	      v = _rl_get_char_len (string + i, &ps);
	      if (v > 1)
		{
		  i += v - 1;
		  continue;
		}
	    }
#endif /* HANDLE_MULTIBYTE */

	  cc = string[i + 1];
	  /* The history_comment_char, if set, appearing at the beginning
	     of a word signifies that the rest of the line should not have
	     history expansion performed on it.
	     Skip the rest of the line and break out of the loop. */
	  if (history_comment_char && string[i] == history_comment_char &&
	      (i == 0 || member (string[i - 1], history_word_delimiters)))
	    {
	      while (string[i])
		i++;
	      break;
	    }
	  else if (string[i] == history_expansion_char)
	    {
	      if (cc == 0 || member (cc, history_no_expand_chars))
		continue;
	      /* If the calling application has set
		 history_inhibit_expansion_function to a function that checks
		 for special cases that should not be history expanded,
		 call the function and skip the expansion if it returns a
		 non-zero value. */
	      else if (history_inhibit_expansion_function &&
			(*history_inhibit_expansion_function) (string, i))
		continue;
	      else
		break;
	    }
	  /* Shell-like quoting: allow backslashes to quote double quotes
	     inside a double-quoted string. */
	  else if (dquote && string[i] == '\\' && cc == '"')
	    i++;
	  /* More shell-like quoting:  if we're paying attention to single
	     quotes and letting them quote the history expansion character,
	     then we need to pay attention to double quotes, because single
	     quotes are not special inside double-quoted strings. */
	  else if (history_quotes_inhibit_expansion && string[i] == '"')
	    {
	      dquote = 1 - dquote;
	    }
	  else if (dquote == 0 && history_quotes_inhibit_expansion && string[i] == '\'')
	    {
	      /* If this is bash, single quotes inhibit history expansion. */
	      flag = (i > 0 && string[i - 1] == '$');
	      i++;
	      hist_string_extract_single_quoted (string, &i, flag);
	    }
	  else if (history_quotes_inhibit_expansion && string[i] == '\\')
	    {
	      /* If this is bash, allow backslashes to quote single
		 quotes and the history expansion character. */
	      if (cc == '\'' || cc == history_expansion_char)
		i++;
	    }
	  
	}
	  
      if (string[i] != history_expansion_char)
	{
	  xfree (result);
	  *output = savestring (string);
	  return (0);
	}
    }

  /* Extract and perform the substitution. */
  for (passc = dquote = i = j = 0; i < l; i++)
    {
      int tchar = string[i];

      if (passc)
	{
	  passc = 0;
	  ADD_CHAR (tchar);
	  continue;
	}

#if defined (HANDLE_MULTIBYTE)
      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
	{
	  int k, c;

	  c = tchar;
	  memset (mb, 0, sizeof (mb));
	  for (k = 0; k < MB_LEN_MAX; k++)
	    {
	      mb[k] = (char)c;
	      memset (&ps, 0, sizeof (mbstate_t));
	      if (_rl_get_char_len (mb, &ps) == -2)
		c = string[++i];
	      else
		break;
	    }
	  if (strlen (mb) > 1)
	    {
	      ADD_STRING (mb);
	      continue;
	    }
	}
#endif /* HANDLE_MULTIBYTE */

      if (tchar == history_expansion_char)
	tchar = -3;
      else if (tchar == history_comment_char)
	tchar = -2;

      switch (tchar)
	{
	default:
	  ADD_CHAR (string[i]);
	  break;

	case '\\':
	  passc++;
	  ADD_CHAR (tchar);
	  break;

	case '"':
	  dquote = 1 - dquote;
	  ADD_CHAR (tchar);
	  break;
	  
	case '\'':
	  {
	    /* If history_quotes_inhibit_expansion is set, single quotes
	       inhibit history expansion. */
	    if (dquote == 0 && history_quotes_inhibit_expansion)
	      {
		int quote, slen;

		flag = (i > 0 && string[i - 1] == '$');
		quote = i++;
		hist_string_extract_single_quoted (string, &i, flag);

		slen = i - quote + 2;
		temp = (char *)xmalloc (slen);
		strncpy (temp, string + quote, slen);
		temp[slen - 1] = '\0';
		ADD_STRING (temp);
		xfree (temp);
	      }
	    else
	      ADD_CHAR (string[i]);
	    break;
	  }

	case -2:		/* history_comment_char */
	  if (i == 0 || member (string[i - 1], history_word_delimiters))
	    {
	      temp = (char *)xmalloc (l - i + 1);
	      strcpy (temp, string + i);
	      ADD_STRING (temp);
	      xfree (temp);
	      i = l;
	    }
	  else
	    ADD_CHAR (string[i]);
	  break;

	case -3:		/* history_expansion_char */
	  cc = string[i + 1];

	  /* If the history_expansion_char is followed by one of the
	     characters in history_no_expand_chars, then it is not a
	     candidate for expansion of any kind. */
	  if (cc == 0 || member (cc, history_no_expand_chars) ||
	  		 (history_inhibit_expansion_function && (*history_inhibit_expansion_function) (string, i)))
	    {
	      ADD_CHAR (string[i]);
	      break;
	    }

#if defined (NO_BANG_HASH_MODIFIERS)
	  /* There is something that is listed as a `word specifier' in csh
	     documentation which means `the expanded text to this point'.
	     That is not a word specifier, it is an event specifier.  If we
	     don't want to allow modifiers with `!#', just stick the current
	     output line in again. */
	  if (cc == '#')
	    {
	      if (result)
		{
		  temp = (char *)xmalloc (1 + strlen (result));
		  strcpy (temp, result);
		  ADD_STRING (temp);
		  xfree (temp);
		}
	      i++;
	      break;
	    }
#endif

	  r = history_expand_internal (string, i, &eindex, &temp, result);
	  if (r < 0)
	    {
	      *output = temp;
	      xfree (result);
	      if (string != hstring)
		xfree (string);
	      return -1;
	    }
	  else
	    {
	      if (temp)
		{
		  modified++;
		  if (*temp)
		    ADD_STRING (temp);
		  xfree (temp);
		}
	      only_printing = r == 1;
	      i = eindex;
	    }
	  break;
	}
    }

  *output = result;
  if (string != hstring)
    xfree (string);

  if (only_printing)
    {
#if 0
      add_history (result);
#endif
      return (2);
    }

  return (modified != 0);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\histexpand.c:929
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\histexpand.c:1,246
parsing error 
{
  register int i = *caller_index;
  int first, last;
  int expecting_word_spec = 0;
  char *result;

  /* The range of words to return doesn't exist yet. */
  first = last = 0;
  result = (char *)NULL;

  /* If we found a colon, then this *must* be a word specification.  If
     it isn't, then it is an error. */
  if (spec[i] == ':')
    {
      i++;
      expecting_word_spec++;
    }

  /* Handle special cases first. */

  /* `%' is the word last searched for. */
  if (spec[i] == '%')
    {
      *caller_index = i + 1;
      return (search_match ? savestring (search_match) : savestring (""));
    }

  /* `*' matches all of the arguments, but not the command. */
  if (spec[i] == '*')
    {
      *caller_index = i + 1;
      result = history_arg_extract (1, '$', from);
      return (result ? result : savestring (""));
    }

  /* `$' is last arg. */
  if (spec[i] == '$')
    {
      *caller_index = i + 1;
      return (history_arg_extract ('$', '$', from));
    }

  /* Try to get FIRST and LAST figured out. */

  if (spec[i] == '-')
    first = 0;
  else if (spec[i] == '^')
    {
      first = 1;
      i++;
    }
  else if (_rl_digit_p (spec[i]) && expecting_word_spec)
    {
      for (first = 0; _rl_digit_p (spec[i]); i++)
	first = (first * 10) + _rl_digit_value (spec[i]);
    }
  else
    return ((char *)NULL);	/* no valid `first' for word specifier */

  if (spec[i] == '^' || spec[i] == '*')
    {
      last = (spec[i] == '^') ? 1 : '$';	/* x* abbreviates x-$ */
      i++;
    }
  else if (spec[i] != '-')
    last = first;
  else
    {
      i++;

      if (_rl_digit_p (spec[i]))
	{
	  for (last = 0; _rl_digit_p (spec[i]); i++)
	    last = (last * 10) + _rl_digit_value (spec[i]);
	}
      else if (spec[i] == '$')
	{
	  i++;
	  last = '$';
	}
#if 0
      else if (!spec[i] || spec[i] == ':')
	/* check against `:' because there could be a modifier separator */
#else
      else
	/* csh seems to allow anything to terminate the word spec here,
	   leaving it as an abbreviation. */
#endif
	last = -1;		/* x- abbreviates x-$ omitting word `$' */
    }

  *caller_index = i;

  if (last >= first || last == '$' || last < 0)
    result = history_arg_extract (first, last, from);

  return (result ? result : (char *)&error_pointer);
}
warning: parse error {
  register int i = *caller_index;
  int first, last;
  int expecting_word_spec = 0;
  char *result;

  /* The range of words to return doesn't exist yet. */
  first = last = 0;
  result = (char *)NULL;

  /* If we found a colon, then this *must* be a word specification.  If
     it isn't, then it is an error. */
  if (spec[i] == ':')
    {
      i++;
      expecting_word_spec++;
    }

  /* Handle special cases first. */

  /* `%' is the word last searched for. */
  if (spec[i] == '%')
    {
      *caller_index = i + 1;
      return (search_match ? savestring (search_match) : savestring (""));
    }

  /* `*' matches all of the arguments, but not the command. */
  if (spec[i] == '*')
    {
      *caller_index = i + 1;
      result = history_arg_extract (1, '$', from);
      return (result ? result : savestring (""));
    }

  /* `$' is last arg. */
  if (spec[i] == '$')
    {
      *caller_index = i + 1;
      return (history_arg_extract ('$', '$', from));
    }

  /* Try to get FIRST and LAST figured out. */

  if (spec[i] == '-')
    first = 0;
  else if (spec[i] == '^')
    {
      first = 1;
      i++;
    }
  else if (_rl_digit_p (spec[i]) && expecting_word_spec)
    {
      for (first = 0; _rl_digit_p (spec[i]); i++)
	first = (first * 10) + _rl_digit_value (spec[i]);
    }
  else
    return ((char *)NULL);	/* no valid `first' for word specifier */

  if (spec[i] == '^' || spec[i] == '*')
    {
      last = (spec[i] == '^') ? 1 : '$';	/* x* abbreviates x-$ */
      i++;
    }
  else if (spec[i] != '-')
    last = first;
  else
    {
      i++;

      if (_rl_digit_p (spec[i]))
	{
	  for (last = 0; _rl_digit_p (spec[i]); i++)
	    last = (last * 10) + _rl_digit_value (spec[i]);
	}
      else if (spec[i] == '$')
	{
	  i++;
	  last = '$';
	}
#if 0
      else if (!spec[i] || spec[i] == ':')
	/* check against `:' because there could be a modifier separator */
#else
      else
	/* csh seems to allow anything to terminate the word spec here,
	   leaving it as an abbreviation. */
#endif
	last = -1;		/* x- abbreviates x-$ omitting word `$' */
    }

  *caller_index = i;

  if (last >= first || last == '$' || last < 0)
    result = history_arg_extract (first, last, from);

  return (result ? result : (char *)&error_pointer);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\histexpand.c:1,249
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\histexpand.c:1,354
parsing error 
{
  register int i, len;
  char *result;
  int size, offset;
  char **list;

  /* XXX - think about making history_tokenize return a struct array,
     each struct in array being a string and a length to avoid the
     calls to strlen below. */
  if ((list = history_tokenize (string)) == NULL)
    return ((char *)NULL);

  for (len = 0; list[len]; len++)
    ;

  if (last < 0)
    last = len + last - 1;

  if (first < 0)
    first = len + first - 1;

  if (last == '$')
    last = len - 1;

  if (first == '$')
    first = len - 1;

  last++;

  if (first >= len || last > len || first < 0 || last < 0 || first > last)
    result = ((char *)NULL);
  else
    {
      for (size = 0, i = first; i < last; i++)
	size += strlen (list[i]) + 1;
      result = (char *)xmalloc (size + 1);
      result[0] = '\0';

      for (i = first, offset = 0; i < last; i++)
	{
	  strcpy (result + offset, list[i]);
	  offset += strlen (list[i]);
	  if (i + 1 < last)
	    {
      	      result[offset++] = ' ';
	      result[offset] = 0;
	    }
	}
    }

  for (i = 0; i < len; i++)
    xfree (list[i]);
  xfree (list);

  return (result);
}
warning: parse error {
  register int i, len;
  char *result;
  int size, offset;
  char **list;

  /* XXX - think about making history_tokenize return a struct array,
     each struct in array being a string and a length to avoid the
     calls to strlen below. */
  if ((list = history_tokenize (string)) == NULL)
    return ((char *)NULL);

  for (len = 0; list[len]; len++)
    ;

  if (last < 0)
    last = len + last - 1;

  if (first < 0)
    first = len + first - 1;

  if (last == '$')
    last = len - 1;

  if (first == '$')
    first = len - 1;

  last++;

  if (first >= len || last > len || first < 0 || last < 0 || first > last)
    result = ((char *)NULL);
  else
    {
      for (size = 0, i = first; i < last; i++)
	size += strlen (list[i]) + 1;
      result = (char *)xmalloc (size + 1);
      result[0] = '\0';

      for (i = first, offset = 0; i < last; i++)
	{
	  strcpy (result + offset, list[i]);
	  offset += strlen (list[i]);
	  if (i + 1 < last)
	    {
      	      result[offset++] = ' ';
	      result[offset] = 0;
	    }
	}
    }

  for (i = 0; i < len; i++)
    xfree (list[i]);
  xfree (list);

  return (result);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\histexpand.c:1,357
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\histexpand.c:1,416
parsing error 
{
  register int i;
  int delimiter, nestdelim, delimopen;

  i = ind;
  delimiter = nestdelim = 0;

  if (member (string[i], "()\n"))
    {
      i++;
      return i;
    }

  if (member (string[i], "<>;&|$"))
    {
      int peek = string[i + 1];

      if (peek == string[i] && peek != '$')
	{
	  if (peek == '<' && string[i + 2] == '-')
	    i++;
	  else if (peek == '<' && string[i + 2] == '<')
	    i++;
	  i += 2;
	  return i;
	}
      else if ((peek == '&' && (string[i] == '>' || string[i] == '<')) ||
		(peek == '>' && string[i] == '&'))
	{
	  i += 2;
	  return i;
	}
      /* XXX - separated out for later -- bash-4.2 */
      else if ((peek == '(' && (string[i] == '>' || string[i] == '<')) || /* ) */
	       (peek == '(' && string[i] == '$')) /*)*/
	{
	  i += 2;
	  delimopen = '(';
	  delimiter = ')';
	  nestdelim = 1;
	  goto get_word;
	}
#if 0
      else if (peek == '\'' && string[i] == '$')
        {
	  i += 2;	/* XXX */
	  return i;
        }
#endif

      if (string[i] != '$')
	{
	  i++;
	  return i;
	}
    }

  /* same code also used for $(...)/<(...)/>(...) above */
  if (member (string[i], "!@?+*"))
    {
      int peek = string[i + 1];

      if (peek == '(')		/*)*/
	{
	  /* Shell extended globbing patterns */
	  i += 2;
	  delimopen = '(';
	  delimiter = ')';	/* XXX - not perfect */
	  nestdelim = 1;
	}
    }

get_word:
  /* Get word from string + i; */

  if (delimiter == 0 && member (string[i], HISTORY_QUOTE_CHARACTERS))
    delimiter = string[i++];

  for (; string[i]; i++)
    {
      if (string[i] == '\\' && string[i + 1] == '\n')
	{
	  i++;
	  continue;
	}

      if (string[i] == '\\' && delimiter != '\'' &&
	  (delimiter != '"' || member (string[i], slashify_in_quotes)))
	{
	  i++;
	  continue;
	}

      /* delimiter must be set and set to something other than a quote if
	 nestdelim is set, so these tests are safe. */
      if (nestdelim && string[i] == delimopen)
	{
	  nestdelim++;
	  continue;
	}
      if (nestdelim && string[i] == delimiter)
	{
	  nestdelim--;
	  if (nestdelim == 0)
	    delimiter = 0;
	  continue;
	}
      
      if (delimiter && string[i] == delimiter)
	{
	  delimiter = 0;
	  continue;
	}

      if (delimiter == 0 && (member (string[i], history_word_delimiters)))
	break;

      if (delimiter == 0 && member (string[i], HISTORY_QUOTE_CHARACTERS))
	delimiter = string[i];
    }

  return i;
}
warning: parse error {
  register int i;
  int delimiter, nestdelim, delimopen;

  i = ind;
  delimiter = nestdelim = 0;

  if (member (string[i], "()\n"))
    {
      i++;
      return i;
    }

  if (member (string[i], "<>;&|$"))
    {
      int peek = string[i + 1];

      if (peek == string[i] && peek != '$')
	{
	  if (peek == '<' && string[i + 2] == '-')
	    i++;
	  else if (peek == '<' && string[i + 2] == '<')
	    i++;
	  i += 2;
	  return i;
	}
      else if ((peek == '&' && (string[i] == '>' || string[i] == '<')) ||
		(peek == '>' && string[i] == '&'))
	{
	  i += 2;
	  return i;
	}
      /* XXX - separated out for later -- bash-4.2 */
      else if ((peek == '(' && (string[i] == '>' || string[i] == '<')) || /* ) */
	       (peek == '(' && string[i] == '$')) /*)*/
	{
	  i += 2;
	  delimopen = '(';
	  delimiter = ')';
	  nestdelim = 1;
	  goto get_word;
	}
#if 0
      else if (peek == '\'' && string[i] == '$')
        {
	  i += 2;	/* XXX */
	  return i;
        }
#endif

      if (string[i] != '$')
	{
	  i++;
	  return i;
	}
    }

  /* same code also used for $(...)/<(...)/>(...) above */
  if (member (string[i], "!@?+*"))
    {
      int peek = string[i + 1];

      if (peek == '(')		/*)*/
	{
	  /* Shell extended globbing patterns */
	  i += 2;
	  delimopen = '(';
	  delimiter = ')';	/* XXX - not perfect */
	  nestdelim = 1;
	}
    }

get_word:
  /* Get word from string + i; */

  if (delimiter == 0 && member (string[i], HISTORY_QUOTE_CHARACTERS))
    delimiter = string[i++];

  for (; string[i]; i++)
    {
      if (string[i] == '\\' && string[i + 1] == '\n')
	{
	  i++;
	  continue;
	}

      if (string[i] == '\\' && delimiter != '\'' &&
	  (delimiter != '"' || member (string[i], slashify_in_quotes)))
	{
	  i++;
	  continue;
	}

      /* delimiter must be set and set to something other than a quote if
	 nestdelim is set, so these tests are safe. */
      if (nestdelim && string[i] == delimopen)
	{
	  nestdelim++;
	  continue;
	}
      if (nestdelim && string[i] == delimiter)
	{
	  nestdelim--;
	  if (nestdelim == 0)
	    delimiter = 0;
	  continue;
	}
      
      if (delimiter && string[i] == delimiter)
	{
	  delimiter = 0;
	  continue;
	}

      if (delimiter == 0 && (member (string[i], history_word_delimiters)))
	break;

      if (delimiter == 0 && member (string[i], HISTORY_QUOTE_CHARACTERS))
	delimiter = string[i];
    }

  return i;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\histexpand.c:1,418
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\histexpand.c:1,544
parsing error 
{
  register int len;
  register char *result;

  len = end - start;
  result = (char *)xmalloc (len + 1);
  strncpy (result, string + start, len);
  result[len] = '\0';
  return result;
}
warning: parse error {
  register int len;
  register char *result;

  len = end - start;
  result = (char *)xmalloc (len + 1);
  strncpy (result, string + start, len);
  result[len] = '\0';
  return result;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\histexpand.c:1,546
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\histexpand.c:1,563
parsing error 
{
  char **result;
  register int i, start, result_index, size;

  /* If we're searching for a string that's not part of a word (e.g., " "),
     make sure we set *INDP to a reasonable value. */
  if (indp && wind != -1)
    *indp = -1;

  /* Get a token, and stuff it into RESULT.  The tokens are split
     exactly where the shell would split them. */
  for (i = result_index = size = 0, result = (char **)NULL; string[i]; )
    {
      /* Skip leading whitespace. */
      for (; string[i] && whitespace (string[i]); i++)
	;
      if (string[i] == 0 || string[i] == history_comment_char)
	return (result);

      start = i;

      i = history_tokenize_word (string, start);

      /* If we have a non-whitespace delimiter character (which would not be
	 skipped by the loop above), use it and any adjacent delimiters to
	 make a separate field.  Any adjacent white space will be skipped the
	 next time through the loop. */
      if (i == start && history_word_delimiters)
	{
	  i++;
	  while (string[i] && member (string[i], history_word_delimiters))
	    i++;
	}

      /* If we are looking for the word in which the character at a
	 particular index falls, remember it. */
      if (indp && wind != -1 && wind >= start && wind < i)
        *indp = result_index;

      if (result_index + 2 >= size)
	result = (char **)xrealloc (result, ((size += 10) * sizeof (char *)));

      result[result_index++] = history_substring (string, start, i);
      result[result_index] = (char *)NULL;
    }

  return (result);
}
warning: parse error {
  char **result;
  register int i, start, result_index, size;

  /* If we're searching for a string that's not part of a word (e.g., " "),
     make sure we set *INDP to a reasonable value. */
  if (indp && wind != -1)
    *indp = -1;

  /* Get a token, and stuff it into RESULT.  The tokens are split
     exactly where the shell would split them. */
  for (i = result_index = size = 0, result = (char **)NULL; string[i]; )
    {
      /* Skip leading whitespace. */
      for (; string[i] && whitespace (string[i]); i++)
	;
      if (string[i] == 0 || string[i] == history_comment_char)
	return (result);

      start = i;

      i = history_tokenize_word (string, start);

      /* If we have a non-whitespace delimiter character (which would not be
	 skipped by the loop above), use it and any adjacent delimiters to
	 make a separate field.  Any adjacent white space will be skipped the
	 next time through the loop. */
      if (i == start && history_word_delimiters)
	{
	  i++;
	  while (string[i] && member (string[i], history_word_delimiters))
	    i++;
	}

      /* If we are looking for the word in which the character at a
	 particular index falls, remember it. */
      if (indp && wind != -1 && wind >= start && wind < i)
        *indp = result_index;

      if (result_index + 2 >= size)
	result = (char **)xrealloc (result, ((size += 10) * sizeof (char *)));

      result[result_index++] = history_substring (string, start, i);
      result[result_index] = (char *)NULL;
    }

  return (result);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\histexpand.c:1,565
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\histexpand.c:1,618
parsing error 
{
  return (history_tokenize_internal (string, -1, (int *)NULL));
}
warning: parse error {
  return (history_tokenize_internal (string, -1, (int *)NULL));
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\histexpand.c:1,619
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\histexpand.c:1,625
parsing error 
{
  register int i;

  for (i = start; words[i]; i++)
    xfree (words[i]);
}
warning: parse error {
  register int i;

  for (i = start; words[i]; i++)
    xfree (words[i]);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\histexpand.c:1,628
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\histexpand.c:1,639
parsing error 
{
  char **words, *s;
  int i, wind;

  words = history_tokenize_internal (line, ind, &wind);
  if (wind == -1 || words == 0)
    {
      if (words)
	freewords (words, 0);
      FREE (words);
      return ((char *)NULL);
    }
  s = words[wind];
  for (i = 0; i < wind; i++)
    xfree (words[i]);
  freewords (words, wind + 1);
  xfree (words);
  return s;
}
warning: parse error {
  char **words, *s;
  int i, wind;

  words = history_tokenize_internal (line, ind, &wind);
  if (wind == -1 || words == 0)
    {
      if (words)
	freewords (words, 0);
      FREE (words);
      return ((char *)NULL);
    }
  s = words[wind];
  for (i = 0; i < wind; i++)
    xfree (words[i]);
  freewords (words, wind + 1);
  xfree (words);
  return s;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\histexpand.c:1,642
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\histfile.c...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\posixstat.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\history.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\histlib.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\rlshell.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\xmalloc.h...skip
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\histfile.c:114
parsing error 
{
  char *return_val;
  const char *home;
  int home_len;

  return_val = filename ? savestring (filename) : (char *)NULL;

  if (return_val)
    return (return_val);
  
  home = sh_get_env_value ("HOME");

  if (home == 0)
    {
#if 0
      home = ".";
      home_len = 1;
#else
      return (NULL);
#endif
    }
  else
    home_len = strlen (home);

  return_val = (char *)xmalloc (2 + home_len + 8); /* strlen(".history") == 8 */
  strcpy (return_val, home);
  return_val[home_len] = '/';
#if defined (__MSDOS__)
  strcpy (return_val + home_len + 1, "_history");
#else
  strcpy (return_val + home_len + 1, ".history");
#endif

  return (return_val);
}
warning: parse error {
  char *return_val;
  const char *home;
  int home_len;

  return_val = filename ? savestring (filename) : (char *)NULL;

  if (return_val)
    return (return_val);
  
  home = sh_get_env_value ("HOME");

  if (home == 0)
    {
#if 0
      home = ".";
      home_len = 1;
#else
      return (NULL);
#endif
    }
  else
    home_len = strlen (home);

  return_val = (char *)xmalloc (2 + home_len + 8); /* strlen(".history") == 8 */
  strcpy (return_val, home);
  return_val[home_len] = '/';
#if defined (__MSDOS__)
  strcpy (return_val + home_len + 1, "_history");
#else
  strcpy (return_val + home_len + 1, ".history");
#endif

  return (return_val);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\histfile.c:115
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\histfile.c:156
parsing error 
{
  return (read_history_range (filename, 0, -1));
}
warning: parse error {
  return (read_history_range (filename, 0, -1));
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\histfile.c:157
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\histfile.c:168
parsing error 
{
  register char *line_start, *line_end, *p;
  char *input, *buffer, *bufend, *last_ts;
  int file, current_line, chars_read;
  struct stat finfo;
  size_t file_size;
#if defined (EFBIG)
  int overflow_errno = EFBIG;
#elif defined (EOVERFLOW)
  int overflow_errno = EOVERFLOW;
#else
  int overflow_errno = EIO;
#endif

  buffer = last_ts = (char *)NULL;
  input = history_filename (filename);
  file = input ? open (input, O_RDONLY|O_BINARY, 0666) : -1;

  if ((file < 0) || (fstat (file, &finfo) == -1))
    goto error_and_exit;

  file_size = (size_t)finfo.st_size;

  /* check for overflow on very large files */
  if (file_size != finfo.st_size || file_size + 1 < file_size)
    {
      errno = overflow_errno;
      goto error_and_exit;
    }

#ifdef HISTORY_USE_MMAP
  /* We map read/write and private so we can change newlines to NULs without
     affecting the underlying object. */
  buffer = (char *)mmap (0, file_size, PROT_READ|PROT_WRITE, MAP_RFLAGS, file, 0);
  if ((void *)buffer == MAP_FAILED)
    {
      errno = overflow_errno;
      goto error_and_exit;
    }
  chars_read = file_size;
#else
  buffer = (char *)malloc (file_size + 1);
  if (buffer == 0)
    {
      errno = overflow_errno;
      goto error_and_exit;
    }

  chars_read = read (file, buffer, file_size);
#endif
  if (chars_read < 0)
    {
  error_and_exit:
      if (errno != 0)
	chars_read = errno;
      else
	chars_read = EIO;
      if (file >= 0)
	close (file);

      FREE (input);
#ifndef HISTORY_USE_MMAP
      FREE (buffer);
#endif

      return (chars_read);
    }

  close (file);

  /* Set TO to larger than end of file if negative. */
  if (to < 0)
    to = chars_read;

  /* Start at beginning of file, work to end. */
  bufend = buffer + chars_read;
  current_line = 0;

  /* Skip lines until we are at FROM. */
  for (line_start = line_end = buffer; line_end < bufend && current_line < from; line_end++)
    if (*line_end == '\n')
      {
      	p = line_end + 1;
      	/* If we see something we think is a timestamp, continue with this
	   line.  We should check more extensively here... */
	if (HIST_TIMESTAMP_START(p) == 0)
	  current_line++;
	line_start = p;
      }

  /* If there are lines left to gobble, then gobble them now. */
  for (line_end = line_start; line_end < bufend; line_end++)
    if (*line_end == '\n')
      {
	/* Change to allow Windows-like \r\n end of line delimiter. */
	if (line_end > line_start && line_end[-1] == '\r')
	  line_end[-1] = '\0';
	else
	  *line_end = '\0';

	if (*line_start)
	  {
	    if (HIST_TIMESTAMP_START(line_start) == 0)
	      {
		add_history (line_start);
		if (last_ts)
		  {
		    add_history_time (last_ts);
		    last_ts = NULL;
		  }
	      }
	    else
	      {
		last_ts = line_start;
		current_line--;
	      }
	  }

	current_line++;

	if (current_line >= to)
	  break;

	line_start = line_end + 1;
      }

  FREE (input);
#ifndef HISTORY_USE_MMAP
  FREE (buffer);
#else
  munmap (buffer, file_size);
#endif

  return (0);
}
warning: parse error {
  register char *line_start, *line_end, *p;
  char *input, *buffer, *bufend, *last_ts;
  int file, current_line, chars_read;
  struct stat finfo;
  size_t file_size;
#if defined (EFBIG)
  int overflow_errno = EFBIG;
#elif defined (EOVERFLOW)
  int overflow_errno = EOVERFLOW;
#else
  int overflow_errno = EIO;
#endif

  buffer = last_ts = (char *)NULL;
  input = history_filename (filename);
  file = input ? open (input, O_RDONLY|O_BINARY, 0666) : -1;

  if ((file < 0) || (fstat (file, &finfo) == -1))
    goto error_and_exit;

  file_size = (size_t)finfo.st_size;

  /* check for overflow on very large files */
  if (file_size != finfo.st_size || file_size + 1 < file_size)
    {
      errno = overflow_errno;
      goto error_and_exit;
    }

#ifdef HISTORY_USE_MMAP
  /* We map read/write and private so we can change newlines to NULs without
     affecting the underlying object. */
  buffer = (char *)mmap (0, file_size, PROT_READ|PROT_WRITE, MAP_RFLAGS, file, 0);
  if ((void *)buffer == MAP_FAILED)
    {
      errno = overflow_errno;
      goto error_and_exit;
    }
  chars_read = file_size;
#else
  buffer = (char *)malloc (file_size + 1);
  if (buffer == 0)
    {
      errno = overflow_errno;
      goto error_and_exit;
    }

  chars_read = read (file, buffer, file_size);
#endif
  if (chars_read < 0)
    {
  error_and_exit:
      if (errno != 0)
	chars_read = errno;
      else
	chars_read = EIO;
      if (file >= 0)
	close (file);

      FREE (input);
#ifndef HISTORY_USE_MMAP
      FREE (buffer);
#endif

      return (chars_read);
    }

  close (file);

  /* Set TO to larger than end of file if negative. */
  if (to < 0)
    to = chars_read;

  /* Start at beginning of file, work to end. */
  bufend = buffer + chars_read;
  current_line = 0;

  /* Skip lines until we are at FROM. */
  for (line_start = line_end = buffer; line_end < bufend && current_line < from; line_end++)
    if (*line_end == '\n')
      {
      	p = line_end + 1;
      	/* If we see something we think is a timestamp, continue with this
	   line.  We should check more extensively here... */
	if (HIST_TIMESTAMP_START(p) == 0)
	  current_line++;
	line_start = p;
      }

  /* If there are lines left to gobble, then gobble them now. */
  for (line_end = line_start; line_end < bufend; line_end++)
    if (*line_end == '\n')
      {
	/* Change to allow Windows-like \r\n end of line delimiter. */
	if (line_end > line_start && line_end[-1] == '\r')
	  line_end[-1] = '\0';
	else
	  *line_end = '\0';

	if (*line_start)
	  {
	    if (HIST_TIMESTAMP_START(line_start) == 0)
	      {
		add_history (line_start);
		if (last_ts)
		  {
		    add_history_time (last_ts);
		    last_ts = NULL;
		  }
	      }
	    else
	      {
		last_ts = line_start;
		current_line--;
	      }
	  }

	current_line++;

	if (current_line >= to)
	  break;

	line_start = line_end + 1;
      }

  FREE (input);
#ifndef HISTORY_USE_MMAP
  FREE (buffer);
#else
  munmap (buffer, file_size);
#endif

  return (0);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\histfile.c:170
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\histfile.c:311
parsing error 
{
  char *buffer, *filename, *bp, *bp1;		/* bp1 == bp+1 */
  int file, chars_read, rv;
  struct stat finfo;
  size_t file_size;

  buffer = (char *)NULL;
  filename = history_filename (fname);
  file = filename ? open (filename, O_RDONLY|O_BINARY, 0666) : -1;
  rv = 0;

  /* Don't try to truncate non-regular files. */
  if (file == -1 || fstat (file, &finfo) == -1)
    {
      rv = errno;
      if (file != -1)
	close (file);
      goto truncate_exit;
    }

  if (S_ISREG (finfo.st_mode) == 0)
    {
      close (file);
#ifdef EFTYPE
      rv = EFTYPE;
#else
      rv = EINVAL;
#endif
      goto truncate_exit;
    }

  file_size = (size_t)finfo.st_size;

  /* check for overflow on very large files */
  if (file_size != finfo.st_size || file_size + 1 < file_size)
    {
      close (file);
#if defined (EFBIG)
      rv = errno = EFBIG;
#elif defined (EOVERFLOW)
      rv = errno = EOVERFLOW;
#else
      rv = errno = EINVAL;
#endif
      goto truncate_exit;
    }

  buffer = (char *)malloc (file_size + 1);
  if (buffer == 0)
    {
      close (file);
      goto truncate_exit;
    }

  chars_read = read (file, buffer, file_size);
  close (file);

  if (chars_read <= 0)
    {
      rv = (chars_read < 0) ? errno : 0;
      goto truncate_exit;
    }

  /* Count backwards from the end of buffer until we have passed
     LINES lines.  bp1 is set funny initially.  But since bp[1] can't
     be a comment character (since it's off the end) and *bp can't be
     both a newline and the history comment character, it should be OK. */
  for (bp1 = bp = buffer + chars_read - 1; lines && bp > buffer; bp--)
    {
      if (*bp == '\n' && HIST_TIMESTAMP_START(bp1) == 0)
	lines--;
      bp1 = bp;
    }

  /* If this is the first line, then the file contains exactly the
     number of lines we want to truncate to, so we don't need to do
     anything.  It's the first line if we don't find a newline between
     the current value of i and 0.  Otherwise, write from the start of
     this line until the end of the buffer. */
  for ( ; bp > buffer; bp--)
    {
      if (*bp == '\n' && HIST_TIMESTAMP_START(bp1) == 0)
        {
	  bp++;
	  break;
        }
      bp1 = bp;
    }

  /* Write only if there are more lines in the file than we want to
     truncate to. */
  if (bp > buffer && ((file = open (filename, O_WRONLY|O_TRUNC|O_BINARY, 0600)) != -1))
    {
      write (file, bp, chars_read - (bp - buffer));

#if defined (__BEOS__)
      /* BeOS ignores O_TRUNC. */
      ftruncate (file, chars_read - (bp - buffer));
#endif

      close (file);
    }

 truncate_exit:

  FREE (buffer);

  xfree (filename);
  return rv;
}
warning: parse error {
  char *buffer, *filename, *bp, *bp1;		/* bp1 == bp+1 */
  int file, chars_read, rv;
  struct stat finfo;
  size_t file_size;

  buffer = (char *)NULL;
  filename = history_filename (fname);
  file = filename ? open (filename, O_RDONLY|O_BINARY, 0666) : -1;
  rv = 0;

  /* Don't try to truncate non-regular files. */
  if (file == -1 || fstat (file, &finfo) == -1)
    {
      rv = errno;
      if (file != -1)
	close (file);
      goto truncate_exit;
    }

  if (S_ISREG (finfo.st_mode) == 0)
    {
      close (file);
#ifdef EFTYPE
      rv = EFTYPE;
#else
      rv = EINVAL;
#endif
      goto truncate_exit;
    }

  file_size = (size_t)finfo.st_size;

  /* check for overflow on very large files */
  if (file_size != finfo.st_size || file_size + 1 < file_size)
    {
      close (file);
#if defined (EFBIG)
      rv = errno = EFBIG;
#elif defined (EOVERFLOW)
      rv = errno = EOVERFLOW;
#else
      rv = errno = EINVAL;
#endif
      goto truncate_exit;
    }

  buffer = (char *)malloc (file_size + 1);
  if (buffer == 0)
    {
      close (file);
      goto truncate_exit;
    }

  chars_read = read (file, buffer, file_size);
  close (file);

  if (chars_read <= 0)
    {
      rv = (chars_read < 0) ? errno : 0;
      goto truncate_exit;
    }

  /* Count backwards from the end of buffer until we have passed
     LINES lines.  bp1 is set funny initially.  But since bp[1] can't
     be a comment character (since it's off the end) and *bp can't be
     both a newline and the history comment character, it should be OK. */
  for (bp1 = bp = buffer + chars_read - 1; lines && bp > buffer; bp--)
    {
      if (*bp == '\n' && HIST_TIMESTAMP_START(bp1) == 0)
	lines--;
      bp1 = bp;
    }

  /* If this is the first line, then the file contains exactly the
     number of lines we want to truncate to, so we don't need to do
     anything.  It's the first line if we don't find a newline between
     the current value of i and 0.  Otherwise, write from the start of
     this line until the end of the buffer. */
  for ( ; bp > buffer; bp--)
    {
      if (*bp == '\n' && HIST_TIMESTAMP_START(bp1) == 0)
        {
	  bp++;
	  break;
        }
      bp1 = bp;
    }

  /* Write only if there are more lines in the file than we want to
     truncate to. */
  if (bp > buffer && ((file = open (filename, O_WRONLY|O_TRUNC|O_BINARY, 0600)) != -1))
    {
      write (file, bp, chars_read - (bp - buffer));

#if defined (__BEOS__)
      /* BeOS ignores O_TRUNC. */
      ftruncate (file, chars_read - (bp - buffer));
#endif

      close (file);
    }

 truncate_exit:

  FREE (buffer);

  xfree (filename);
  return rv;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\histfile.c:313
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\histfile.c:429
parsing error 
{
  register int i;
  char *output;
  int file, mode, rv;
#ifdef HISTORY_USE_MMAP
  size_t cursize;

  mode = overwrite ? O_RDWR|O_CREAT|O_TRUNC|O_BINARY : O_RDWR|O_APPEND|O_BINARY;
#else
  mode = overwrite ? O_WRONLY|O_CREAT|O_TRUNC|O_BINARY : O_WRONLY|O_APPEND|O_BINARY;
#endif
  output = history_filename (filename);
  file = output ? open (output, mode, 0600) : -1;
  rv = 0;

  if (file == -1)
    {
      FREE (output);
      return (errno);
    }

#ifdef HISTORY_USE_MMAP
  cursize = overwrite ? 0 : lseek (file, 0, SEEK_END);
#endif

  if (nelements > history_length)
    nelements = history_length;

  /* Build a buffer of all the lines to write, and write them in one syscall.
     Suggested by Peter Ho (peter@robosts.oxford.ac.uk). */
  {
    HIST_ENTRY **the_history;	/* local */
    register int j;
    int buffer_size;
    char *buffer;

    the_history = history_list ();
    /* Calculate the total number of bytes to write. */
    for (buffer_size = 0, i = history_length - nelements; i < history_length; i++)
#if 0
      buffer_size += 2 + HISTENT_BYTES (the_history[i]);
#else
      {
	if (history_write_timestamps && the_history[i]->timestamp && the_history[i]->timestamp[0])
	  buffer_size += strlen (the_history[i]->timestamp) + 1;
	buffer_size += strlen (the_history[i]->line) + 1;
      }
#endif

    /* Allocate the buffer, and fill it. */
#ifdef HISTORY_USE_MMAP
    if (ftruncate (file, buffer_size+cursize) == -1)
      goto mmap_error;
    buffer = (char *)mmap (0, buffer_size, PROT_READ|PROT_WRITE, MAP_WFLAGS, file, cursize);
    if ((void *)buffer == MAP_FAILED)
      {
mmap_error:
	rv = errno;
	FREE (output);
	close (file);
	return rv;
      }
#else    
    buffer = (char *)malloc (buffer_size);
    if (buffer == 0)
      {
      	rv = errno;
	FREE (output);
	close (file);
	return rv;
      }
#endif

    for (j = 0, i = history_length - nelements; i < history_length; i++)
      {
	if (history_write_timestamps && the_history[i]->timestamp && the_history[i]->timestamp[0])
	  {
	    strcpy (buffer + j, the_history[i]->timestamp);
	    j += strlen (the_history[i]->timestamp);
	    buffer[j++] = '\n';
	  }
	strcpy (buffer + j, the_history[i]->line);
	j += strlen (the_history[i]->line);
	buffer[j++] = '\n';
      }

#ifdef HISTORY_USE_MMAP
    if (msync (buffer, buffer_size, 0) != 0 || munmap (buffer, buffer_size) != 0)
      rv = errno;
#else
    if (write (file, buffer, buffer_size) < 0)
      rv = errno;
    xfree (buffer);
#endif
  }

  close (file);

  FREE (output);

  return (rv);
}
warning: parse error {
  register int i;
  char *output;
  int file, mode, rv;
#ifdef HISTORY_USE_MMAP
  size_t cursize;

  mode = overwrite ? O_RDWR|O_CREAT|O_TRUNC|O_BINARY : O_RDWR|O_APPEND|O_BINARY;
#else
  mode = overwrite ? O_WRONLY|O_CREAT|O_TRUNC|O_BINARY : O_WRONLY|O_APPEND|O_BINARY;
#endif
  output = history_filename (filename);
  file = output ? open (output, mode, 0600) : -1;
  rv = 0;

  if (file == -1)
    {
      FREE (output);
      return (errno);
    }

#ifdef HISTORY_USE_MMAP
  cursize = overwrite ? 0 : lseek (file, 0, SEEK_END);
#endif

  if (nelements > history_length)
    nelements = history_length;

  /* Build a buffer of all the lines to write, and write them in one syscall.
     Suggested by Peter Ho (peter@robosts.oxford.ac.uk). */
  {
    HIST_ENTRY **the_history;	/* local */
    register int j;
    int buffer_size;
    char *buffer;

    the_history = history_list ();
    /* Calculate the total number of bytes to write. */
    for (buffer_size = 0, i = history_length - nelements; i < history_length; i++)
#if 0
      buffer_size += 2 + HISTENT_BYTES (the_history[i]);
#else
      {
	if (history_write_timestamps && the_history[i]->timestamp && the_history[i]->timestamp[0])
	  buffer_size += strlen (the_history[i]->timestamp) + 1;
	buffer_size += strlen (the_history[i]->line) + 1;
      }
#endif

    /* Allocate the buffer, and fill it. */
#ifdef HISTORY_USE_MMAP
    if (ftruncate (file, buffer_size+cursize) == -1)
      goto mmap_error;
    buffer = (char *)mmap (0, buffer_size, PROT_READ|PROT_WRITE, MAP_WFLAGS, file, cursize);
    if ((void *)buffer == MAP_FAILED)
      {
mmap_error:
	rv = errno;
	FREE (output);
	close (file);
	return rv;
      }
#else    
    buffer = (char *)malloc (buffer_size);
    if (buffer == 0)
      {
      	rv = errno;
	FREE (output);
	close (file);
	return rv;
      }
#endif

    for (j = 0, i = history_length - nelements; i < history_length; i++)
      {
	if (history_write_timestamps && the_history[i]->timestamp && the_history[i]->timestamp[0])
	  {
	    strcpy (buffer + j, the_history[i]->timestamp);
	    j += strlen (the_history[i]->timestamp);
	    buffer[j++] = '\n';
	  }
	strcpy (buffer + j, the_history[i]->line);
	j += strlen (the_history[i]->line);
	buffer[j++] = '\n';
      }

#ifdef HISTORY_USE_MMAP
    if (msync (buffer, buffer_size, 0) != 0 || munmap (buffer, buffer_size) != 0)
      rv = errno;
#else
    if (write (file, buffer, buffer_size) < 0)
      rv = errno;
    xfree (buffer);
#endif
  }

  close (file);

  FREE (output);

  return (rv);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\histfile.c:431
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\histfile.c:537
parsing error 
{
  return (history_do_write (filename, nelements, HISTORY_APPEND));
}
warning: parse error {
  return (history_do_write (filename, nelements, HISTORY_APPEND));
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\histfile.c:540
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\histfile.c:549
parsing error 
{
  return (history_do_write (filename, history_length, HISTORY_OVERWRITE));
}
warning: parse error {
  return (history_do_write (filename, history_length, HISTORY_OVERWRITE));
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\histfile.c:550
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\history.c...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\history.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\histlib.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\xmalloc.h...skip
parsing error 
static char *hist_inittime PARAMS((void));
warning: parse error static char *hist_inittime PARAMS((void));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\history.c:54
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\history.c:107
parsing error 
{
  the_history = state->entries;
  history_offset = state->offset;
  history_length = state->length;
  history_size = state->size;
  if (state->flags & HS_STIFLED)
    history_stifled = 1;
}
warning: parse error {
  the_history = state->entries;
  history_offset = state->offset;
  history_length = state->length;
  history_size = state->size;
  if (state->flags & HS_STIFLED)
    history_stifled = 1;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\history.c:109
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\history.c:151
parsing error 
{
  if (pos > history_length || pos < 0 || !the_history)
    return (0);
  history_offset = pos;
  return (1);
}
warning: parse error {
  if (pos > history_length || pos < 0 || !the_history)
    return (0);
  history_offset = pos;
  return (1);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\history.c:153
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\history.c:200
parsing error 
{
  int local_index;

  local_index = offset - history_base;
  return (local_index >= history_length || local_index < 0 || the_history == 0)
		? (HIST_ENTRY *)NULL
		: the_history[local_index];
}
warning: parse error {
  int local_index;

  local_index = offset - history_base;
  return (local_index >= history_length || local_index < 0 || the_history == 0)
		? (HIST_ENTRY *)NULL
		: the_history[local_index];
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\history.c:202
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\history.c:212
parsing error 
{
  HIST_ENTRY *temp;

  temp = (HIST_ENTRY *)xmalloc (sizeof (HIST_ENTRY));

  temp->line = string ? savestring (string) : string;
  temp->data = (char *)NULL;
  temp->timestamp = ts;

  return temp;
}
warning: parse error {
  HIST_ENTRY *temp;

  temp = (HIST_ENTRY *)xmalloc (sizeof (HIST_ENTRY));

  temp->line = string ? savestring (string) : string;
  temp->data = (char *)NULL;
  temp->timestamp = ts;

  return temp;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\history.c:215
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\history.c:228
parsing error 
{
  char *ts;
  time_t t;

  if (hist == 0 || hist->timestamp == 0)
    return 0;
  ts = hist->timestamp;
  if (ts[0] != history_comment_char)
    return 0;
  t = (time_t) atol (ts + 1);		/* XXX - should use strtol() here */
  return t;
}
warning: parse error {
  char *ts;
  time_t t;

  if (hist == 0 || hist->timestamp == 0)
    return 0;
  ts = hist->timestamp;
  if (ts[0] != history_comment_char)
    return 0;
  t = (time_t) atol (ts + 1);		/* XXX - should use strtol() here */
  return t;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\history.c:230
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\history.c:265
parsing error 
{
  HIST_ENTRY *temp;

  if (history_stifled && (history_length == history_max_entries))
    {
      register int i;

      /* If the history is stifled, and history_length is zero,
	 and it equals history_max_entries, we don't save items. */
      if (history_length == 0)
	return;

      /* If there is something in the slot, then remove it. */
      if (the_history[0])
	(void) free_history_entry (the_history[0]);

      /* Copy the rest of the entries, moving down one slot. */
      for (i = 0; i < history_length; i++)
	the_history[i] = the_history[i + 1];

      history_base++;
    }
  else
    {
      if (history_size == 0)
	{
	  history_size = DEFAULT_HISTORY_GROW_SIZE;
	  the_history = (HIST_ENTRY **)xmalloc (history_size * sizeof (HIST_ENTRY *));
	  history_length = 1;
	}
      else
	{
	  if (history_length == (history_size - 1))
	    {
	      history_size += DEFAULT_HISTORY_GROW_SIZE;
	      the_history = (HIST_ENTRY **)
		xrealloc (the_history, history_size * sizeof (HIST_ENTRY *));
	    }
	  history_length++;
	}
    }

  temp = alloc_history_entry (string, hist_inittime ());

  the_history[history_length] = (HIST_ENTRY *)NULL;
  the_history[history_length - 1] = temp;
}
warning: parse error {
  HIST_ENTRY *temp;

  if (history_stifled && (history_length == history_max_entries))
    {
      register int i;

      /* If the history is stifled, and history_length is zero,
	 and it equals history_max_entries, we don't save items. */
      if (history_length == 0)
	return;

      /* If there is something in the slot, then remove it. */
      if (the_history[0])
	(void) free_history_entry (the_history[0]);

      /* Copy the rest of the entries, moving down one slot. */
      for (i = 0; i < history_length; i++)
	the_history[i] = the_history[i + 1];

      history_base++;
    }
  else
    {
      if (history_size == 0)
	{
	  history_size = DEFAULT_HISTORY_GROW_SIZE;
	  the_history = (HIST_ENTRY **)xmalloc (history_size * sizeof (HIST_ENTRY *));
	  history_length = 1;
	}
      else
	{
	  if (history_length == (history_size - 1))
	    {
	      history_size += DEFAULT_HISTORY_GROW_SIZE;
	      the_history = (HIST_ENTRY **)
		xrealloc (the_history, history_size * sizeof (HIST_ENTRY *));
	    }
	  history_length++;
	}
    }

  temp = alloc_history_entry (string, hist_inittime ());

  the_history[history_length] = (HIST_ENTRY *)NULL;
  the_history[history_length - 1] = temp;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\history.c:266
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\history.c:317
parsing error 
{
  HIST_ENTRY *hs;

  if (string == 0)
    return;
  hs = the_history[history_length - 1];
  FREE (hs->timestamp);
  hs->timestamp = savestring (string);
}
warning: parse error {
  HIST_ENTRY *hs;

  if (string == 0)
    return;
  hs = the_history[history_length - 1];
  FREE (hs->timestamp);
  hs->timestamp = savestring (string);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\history.c:318
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\history.c:331
parsing error 
{
  histdata_t x;

  if (hist == 0)
    return ((histdata_t) 0);
  FREE (hist->line);
  FREE (hist->timestamp);
  x = hist->data;
  xfree (hist);
  return (x);
}
warning: parse error {
  histdata_t x;

  if (hist == 0)
    return ((histdata_t) 0);
  FREE (hist->line);
  FREE (hist->timestamp);
  x = hist->data;
  xfree (hist);
  return (x);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\history.c:333
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\history.c:346
parsing error 
{
  HIST_ENTRY *ret;
  char *ts;

  if (hist == 0)
    return hist;

  ret = alloc_history_entry (hist->line, (char *)NULL);

  ts = hist->timestamp ? savestring (hist->timestamp) : hist->timestamp;
  ret->timestamp = ts;

  ret->data = hist->data;

  return ret;
}
warning: parse error {
  HIST_ENTRY *ret;
  char *ts;

  if (hist == 0)
    return hist;

  ret = alloc_history_entry (hist->line, (char *)NULL);

  ts = hist->timestamp ? savestring (hist->timestamp) : hist->timestamp;
  ret->timestamp = ts;

  ret->data = hist->data;

  return ret;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\history.c:348
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\history.c:369
parsing error 
{
  HIST_ENTRY *temp, *old_value;

  if (which < 0 || which >= history_length)
    return ((HIST_ENTRY *)NULL);

  temp = (HIST_ENTRY *)xmalloc (sizeof (HIST_ENTRY));
  old_value = the_history[which];

  temp->line = savestring (line);
  temp->data = data;
  temp->timestamp = savestring (old_value->timestamp);
  the_history[which] = temp;

  return (old_value);
}
warning: parse error {
  HIST_ENTRY *temp, *old_value;

  if (which < 0 || which >= history_length)
    return ((HIST_ENTRY *)NULL);

  temp = (HIST_ENTRY *)xmalloc (sizeof (HIST_ENTRY));
  old_value = the_history[which];

  temp->line = savestring (line);
  temp->data = data;
  temp->timestamp = savestring (old_value->timestamp);
  the_history[which] = temp;

  return (old_value);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\history.c:373
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\history.c:397
parsing error 
{
  HIST_ENTRY *entry;
  register int i, last;

  if (which < -2 || which >= history_length || history_length == 0 || the_history == 0)
    return;

  if (which >= 0)
    {
      entry = the_history[which];
      if (entry && entry->data == old)
	entry->data = new;
      return;
    }

  last = -1;
  for (i = 0; i < history_length; i++)
    {
      entry = the_history[i];
      if (entry == 0)
	continue;
      if (entry->data == old)
	{
	  last = i;
	  if (which == -1)
	    entry->data = new;
	}
    }
  if (which == -2 && last >= 0)
    {
      entry = the_history[last];
      entry->data = new;	/* XXX - we don't check entry->old */
    }
}
warning: parse error {
  HIST_ENTRY *entry;
  register int i, last;

  if (which < -2 || which >= history_length || history_length == 0 || the_history == 0)
    return;

  if (which >= 0)
    {
      entry = the_history[which];
      if (entry && entry->data == old)
	entry->data = new;
      return;
    }

  last = -1;
  for (i = 0; i < history_length; i++)
    {
      entry = the_history[i];
      if (entry == 0)
	continue;
      if (entry->data == old)
	{
	  last = i;
	  if (which == -1)
	    entry->data = new;
	}
    }
  if (which == -2 && last >= 0)
    {
      entry = the_history[last];
      entry->data = new;	/* XXX - we don't check entry->old */
    }
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\history.c:400
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\history.c:439
parsing error 
{
  HIST_ENTRY *return_value;
  register int i;

  if (which < 0 || which >= history_length || history_length ==  0 || the_history == 0)
    return ((HIST_ENTRY *)NULL);

  return_value = the_history[which];

  for (i = which; i < history_length; i++)
    the_history[i] = the_history[i + 1];

  history_length--;

  return (return_value);
}
warning: parse error {
  HIST_ENTRY *return_value;
  register int i;

  if (which < 0 || which >= history_length || history_length ==  0 || the_history == 0)
    return ((HIST_ENTRY *)NULL);

  return_value = the_history[which];

  for (i = which; i < history_length; i++)
    the_history[i] = the_history[i + 1];

  history_length--;

  return (return_value);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\history.c:441
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\history.c:460
parsing error 
{
  register int i, j;

  if (max < 0)
    max = 0;

  if (history_length > max)
    {
      /* This loses because we cannot free the data. */
      for (i = 0, j = history_length - max; i < j; i++)
	free_history_entry (the_history[i]);

      history_base = i;
      for (j = 0, i = history_length - max; j < max; i++, j++)
	the_history[j] = the_history[i];
      the_history[j] = (HIST_ENTRY *)NULL;
      history_length = j;
    }

  history_stifled = 1;
  max_input_history = history_max_entries = max;
}
warning: parse error {
  register int i, j;

  if (max < 0)
    max = 0;

  if (history_length > max)
    {
      /* This loses because we cannot free the data. */
      for (i = 0, j = history_length - max; i < j; i++)
	free_history_entry (the_history[i]);

      history_base = i;
      for (j = 0, i = history_length - max; j < max; i++, j++)
	the_history[j] = the_history[i];
      the_history[j] = (HIST_ENTRY *)NULL;
      history_length = j;
    }

  history_stifled = 1;
  max_input_history = history_max_entries = max;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\history.c:462
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\histsearch.c...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\history.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\histlib.h...skip
parsing error 
static int history_search_internal PARAMS((const char *, int, int));
warning: parse error static int history_search_internal PARAMS((const char *, int, int));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\histsearch.c:49
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\histsearch.c:63
parsing error 
{
  register int i, reverse;
  register char *line;
  register int line_index;
  int string_len;
  HIST_ENTRY **the_history; 	/* local */

  i = history_offset;
  reverse = (direction < 0);

  /* Take care of trivial cases first. */
  if (string == 0 || *string == '\0')
    return (-1);

  if (!history_length || ((i >= history_length) && !reverse))
    return (-1);

  if (reverse && (i >= history_length))
    i = history_length - 1;

#define NEXT_LINE() do { if (reverse) i--; else i++; } while (0)

  the_history = history_list ();
  string_len = strlen (string);
  while (1)
    {
      /* Search each line in the history list for STRING. */

      /* At limit for direction? */
      if ((reverse && i < 0) || (!reverse && i == history_length))
	return (-1);

      line = the_history[i]->line;
      line_index = strlen (line);

      /* If STRING is longer than line, no match. */
      if (string_len > line_index)
	{
	  NEXT_LINE ();
	  continue;
	}

      /* Handle anchored searches first. */
      if (anchored == ANCHORED_SEARCH)
	{
	  if (STREQN (string, line, string_len))
	    {
	      history_offset = i;
	      return (0);
	    }

	  NEXT_LINE ();
	  continue;
	}

      /* Do substring search. */
      if (reverse)
	{
	  line_index -= string_len;

	  while (line_index >= 0)
	    {
	      if (STREQN (string, line + line_index, string_len))
		{
		  history_offset = i;
		  return (line_index);
		}
	      line_index--;
	    }
	}
      else
	{
	  register int limit;

	  limit = line_index - string_len + 1;
	  line_index = 0;

	  while (line_index < limit)
	    {
	      if (STREQN (string, line + line_index, string_len))
		{
		  history_offset = i;
		  return (line_index);
		}
	      line_index++;
	    }
	}
      NEXT_LINE ();
    }
}
warning: parse error {
  register int i, reverse;
  register char *line;
  register int line_index;
  int string_len;
  HIST_ENTRY **the_history; 	/* local */

  i = history_offset;
  reverse = (direction < 0);

  /* Take care of trivial cases first. */
  if (string == 0 || *string == '\0')
    return (-1);

  if (!history_length || ((i >= history_length) && !reverse))
    return (-1);

  if (reverse && (i >= history_length))
    i = history_length - 1;

#define NEXT_LINE() do { if (reverse) i--; else i++; } while (0)

  the_history = history_list ();
  string_len = strlen (string);
  while (1)
    {
      /* Search each line in the history list for STRING. */

      /* At limit for direction? */
      if ((reverse && i < 0) || (!reverse && i == history_length))
	return (-1);

      line = the_history[i]->line;
      line_index = strlen (line);

      /* If STRING is longer than line, no match. */
      if (string_len > line_index)
	{
	  NEXT_LINE ();
	  continue;
	}

      /* Handle anchored searches first. */
      if (anchored == ANCHORED_SEARCH)
	{
	  if (STREQN (string, line, string_len))
	    {
	      history_offset = i;
	      return (0);
	    }

	  NEXT_LINE ();
	  continue;
	}

      /* Do substring search. */
      if (reverse)
	{
	  line_index -= string_len;

	  while (line_index >= 0)
	    {
	      if (STREQN (string, line + line_index, string_len))
		{
		  history_offset = i;
		  return (line_index);
		}
	      line_index--;
	    }
	}
      else
	{
	  register int limit;

	  limit = line_index - string_len + 1;
	  line_index = 0;

	  while (line_index < limit)
	    {
	      if (STREQN (string, line + line_index, string_len))
		{
		  history_offset = i;
		  return (line_index);
		}
	      line_index++;
	    }
	}
      NEXT_LINE ();
    }
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\histsearch.c:65
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\histsearch.c:159
parsing error 
{
  return (history_search_internal (string, direction, NON_ANCHORED_SEARCH));
}
warning: parse error {
  return (history_search_internal (string, direction, NON_ANCHORED_SEARCH));
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\histsearch.c:161
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\histsearch.c:168
parsing error 
{
  return (history_search_internal (string, direction, ANCHORED_SEARCH));
}
warning: parse error {
  return (history_search_internal (string, direction, ANCHORED_SEARCH));
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\histsearch.c:170
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\histsearch.c:179
parsing error 
{
  int ret, old;

  old = where_history ();
  history_set_pos (pos);
  if (history_search (string, dir) == -1)
    {
      history_set_pos (old);
      return (-1);
    }
  ret = where_history ();
  history_set_pos (old);
  return ret;
}
warning: parse error {
  int ret, old;

  old = where_history ();
  history_set_pos (pos);
  if (history_search (string, dir) == -1)
    {
      history_set_pos (old);
      return (-1);
    }
  ret = where_history ();
  history_set_pos (old);
  return ret;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\histsearch.c:181
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\input.c...
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\posixselect.h...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\rldefs.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\rlmbutil.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\rlprivate.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\rlshell.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\xmalloc.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\input.c:122
parsing error 
{
  if (push_index == pop_index)
    return (0);

  *key = ibuffer[pop_index++];
#if 0
  if (pop_index >= ibuffer_len)
#else
  if (pop_index > ibuffer_len)
#endif
    pop_index = 0;

  return (1);
}
warning: parse error {
  if (push_index == pop_index)
    return (0);

  *key = ibuffer[pop_index++];
#if 0
  if (pop_index >= ibuffer_len)
#else
  if (pop_index > ibuffer_len)
#endif
    pop_index = 0;

  return (1);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\input.c:124
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\input.c:143
parsing error 
{
  if (ibuffer_space ())
    {
      pop_index--;
      if (pop_index < 0)
	pop_index = ibuffer_len;
      ibuffer[pop_index] = key;
      return (1);
    }
  return (0);
}
warning: parse error {
  if (ibuffer_space ())
    {
      pop_index--;
      if (pop_index < 0)
	pop_index = ibuffer_len;
      ibuffer[pop_index] = key;
      return (1);
    }
  return (0);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\input.c:145
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\input.c:265
parsing error 
{
  int o;

  o = _keyboard_input_timeout;
  if (u >= 0)
    _keyboard_input_timeout = u;
  return (o);
}
warning: parse error {
  int o;

  o = _keyboard_input_timeout;
  if (u >= 0)
    _keyboard_input_timeout = u;
  return (o);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\input.c:267
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\input.c:322
parsing error 
{
  int old_timeout, r;

  old_timeout = rl_set_keyboard_input_timeout (t);
  r = _rl_input_available ();
  rl_set_keyboard_input_timeout (old_timeout);
  return r;
}
warning: parse error {
  int old_timeout, r;

  old_timeout = rl_set_keyboard_input_timeout (t);
  r = _rl_input_available ();
  rl_set_keyboard_input_timeout (old_timeout);
  return r;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\input.c:324
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\input.c:334
parsing error 
{    	
  int key, t, i;
  char *string;

  i = key = 0;
  string = (char *)xmalloc (ibuffer_len + 1);
  string[i++] = (char) c;

  while ((t = rl_get_char (&key)) &&
	 _rl_keymap[key].type == ISFUNC &&
	 _rl_keymap[key].function == rl_insert)
    string[i++] = key;

  if (t)
    _rl_unget_char (key);

  string[i] = '\0';
  rl_insert_text (string);
  xfree (string);
}
warning: parse error {    	
  int key, t, i;
  char *string;

  i = key = 0;
  string = (char *)xmalloc (ibuffer_len + 1);
  string[i++] = (char) c;

  while ((t = rl_get_char (&key)) &&
	 _rl_keymap[key].type == ISFUNC &&
	 _rl_keymap[key].function == rl_insert)
    string[i++] = key;

  if (t)
    _rl_unget_char (key);

  string[i] = '\0';
  rl_insert_text (string);
  xfree (string);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\input.c:336
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\input.c:360
parsing error 
{
  if (ibuffer_space () == 0)
    return 0;

  if (key == EOF)
    {
      key = NEWLINE;
      rl_pending_input = EOF;
      RL_SETSTATE (RL_STATE_INPUTPENDING);
    }
  ibuffer[push_index++] = key;
#if 0
  if (push_index >= ibuffer_len)
#else
  if (push_index > ibuffer_len)
#endif
    push_index = 0;

  return 1;
}
warning: parse error {
  if (ibuffer_space () == 0)
    return 0;

  if (key == EOF)
    {
      key = NEWLINE;
      rl_pending_input = EOF;
      RL_SETSTATE (RL_STATE_INPUTPENDING);
    }
  ibuffer[push_index++] = key;
#if 0
  if (push_index >= ibuffer_len)
#else
  if (push_index > ibuffer_len)
#endif
    push_index = 0;

  return 1;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\input.c:362
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\input.c:385
parsing error 
{
  rl_pending_input = c;
  RL_SETSTATE (RL_STATE_INPUTPENDING);
  return 0;
}
warning: parse error {
  rl_pending_input = c;
  RL_SETSTATE (RL_STATE_INPUTPENDING);
  return 0;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\input.c:387
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\input.c:457
parsing error 
{
  int result;
  unsigned char c;

  while (1)
    {
      RL_CHECK_SIGNALS ();

#if defined (__MINGW32__)
      if (isatty (fileno (stream)))
	return (getch ());
#endif
      result = read (fileno (stream), &c, sizeof (unsigned char));

      if (result == sizeof (unsigned char))
	return (c);

      /* If zero characters are returned, then the file that we are
	 reading from is empty!  Return EOF in that case. */
      if (result == 0)
	return (EOF);

#if defined (__BEOS__)
      if (errno == EINTR)
	continue;
#endif

#if defined (EWOULDBLOCK)
#  define X_EWOULDBLOCK EWOULDBLOCK
#else
#  define X_EWOULDBLOCK -99
#endif

#if defined (EAGAIN)
#  define X_EAGAIN EAGAIN
#else
#  define X_EAGAIN -99
#endif

      if (errno == X_EWOULDBLOCK || errno == X_EAGAIN)
	{
	  if (sh_unset_nodelay_mode (fileno (stream)) < 0)
	    return (EOF);
	  continue;
	}

#undef X_EWOULDBLOCK
#undef X_EAGAIN

      /* If the error that we received was SIGINT, then try again,
	 this is simply an interrupted system call to read ().
	 Otherwise, some error ocurred, also signifying EOF. */
      if (errno != EINTR)
	return (RL_ISSTATE (RL_STATE_READCMD) ? READERR : EOF);
    }
}
warning: parse error {
  int result;
  unsigned char c;

  while (1)
    {
      RL_CHECK_SIGNALS ();

#if defined (__MINGW32__)
      if (isatty (fileno (stream)))
	return (getch ());
#endif
      result = read (fileno (stream), &c, sizeof (unsigned char));

      if (result == sizeof (unsigned char))
	return (c);

      /* If zero characters are returned, then the file that we are
	 reading from is empty!  Return EOF in that case. */
      if (result == 0)
	return (EOF);

#if defined (__BEOS__)
      if (errno == EINTR)
	continue;
#endif

#if defined (EWOULDBLOCK)
#  define X_EWOULDBLOCK EWOULDBLOCK
#else
#  define X_EWOULDBLOCK -99
#endif

#if defined (EAGAIN)
#  define X_EAGAIN EAGAIN
#else
#  define X_EAGAIN -99
#endif

      if (errno == X_EWOULDBLOCK || errno == X_EAGAIN)
	{
	  if (sh_unset_nodelay_mode (fileno (stream)) < 0)
	    return (EOF);
	  continue;
	}

#undef X_EWOULDBLOCK
#undef X_EAGAIN

      /* If the error that we received was SIGINT, then try again,
	 this is simply an interrupted system call to read ().
	 Otherwise, some error ocurred, also signifying EOF. */
      if (errno != EINTR)
	return (RL_ISSTATE (RL_STATE_READCMD) ? READERR : EOF);
    }
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\input.c:459
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\input.c:519
parsing error 
{
  int mb_len, c;
  size_t mbchar_bytes_length;
  wchar_t wc;
  mbstate_t ps, ps_back;

  memset(&ps, 0, sizeof (mbstate_t));
  memset(&ps_back, 0, sizeof (mbstate_t));

  mb_len = 0;  
  while (mb_len < size)
    {
      RL_SETSTATE(RL_STATE_MOREINPUT);
      c = rl_read_key ();
      RL_UNSETSTATE(RL_STATE_MOREINPUT);

      if (c < 0)
	break;

      mbchar[mb_len++] = c;

      mbchar_bytes_length = mbrtowc (&wc, mbchar, mb_len, &ps);
      if (mbchar_bytes_length == (size_t)(-1))
	break;		/* invalid byte sequence for the current locale */
      else if (mbchar_bytes_length == (size_t)(-2))
	{
	  /* shorted bytes */
	  ps = ps_back;
	  continue;
	} 
      else if (mbchar_bytes_length == 0)
	{
	  mbchar[0] = '\0';	/* null wide character */
	  mb_len = 1;
	  break;
	}
      else if (mbchar_bytes_length > (size_t)(0))
	break;
    }

  return mb_len;
}
warning: parse error {
  int mb_len, c;
  size_t mbchar_bytes_length;
  wchar_t wc;
  mbstate_t ps, ps_back;

  memset(&ps, 0, sizeof (mbstate_t));
  memset(&ps_back, 0, sizeof (mbstate_t));

  mb_len = 0;  
  while (mb_len < size)
    {
      RL_SETSTATE(RL_STATE_MOREINPUT);
      c = rl_read_key ();
      RL_UNSETSTATE(RL_STATE_MOREINPUT);

      if (c < 0)
	break;

      mbchar[mb_len++] = c;

      mbchar_bytes_length = mbrtowc (&wc, mbchar, mb_len, &ps);
      if (mbchar_bytes_length == (size_t)(-1))
	break;		/* invalid byte sequence for the current locale */
      else if (mbchar_bytes_length == (size_t)(-2))
	{
	  /* shorted bytes */
	  ps = ps_back;
	  continue;
	} 
      else if (mbchar_bytes_length == 0)
	{
	  mbchar[0] = '\0';	/* null wide character */
	  mb_len = 1;
	  break;
	}
      else if (mbchar_bytes_length > (size_t)(0))
	break;
    }

  return mb_len;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\input.c:522
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\input.c:570
parsing error 
{
  int i, c;
  mbstate_t ps;

  c = first;
  memset (mb, 0, mlen);
  for (i = 0; c >= 0 && i < mlen; i++)
    {
      mb[i] = (char)c;
      memset (&ps, 0, sizeof (mbstate_t));
      if (_rl_get_char_len (mb, &ps) == -2)
	{
	  /* Read more for multibyte character */
	  RL_SETSTATE (RL_STATE_MOREINPUT);
	  c = rl_read_key ();
	  RL_UNSETSTATE (RL_STATE_MOREINPUT);
	}
      else
	break;
    }
  return c;
}
warning: parse error {
  int i, c;
  mbstate_t ps;

  c = first;
  memset (mb, 0, mlen);
  for (i = 0; c >= 0 && i < mlen; i++)
    {
      mb[i] = (char)c;
      memset (&ps, 0, sizeof (mbstate_t));
      if (_rl_get_char_len (mb, &ps) == -2)
	{
	  /* Read more for multibyte character */
	  RL_SETSTATE (RL_STATE_MOREINPUT);
	  c = rl_read_key ();
	  RL_UNSETSTATE (RL_STATE_MOREINPUT);
	}
      else
	break;
    }
  return c;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\input.c:574
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\isearch.c...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\rldefs.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\rlmbutil.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\history.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\rlprivate.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\xmalloc.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\isearch.c:82
parsing error 
{
  _rl_search_cxt *cxt;

  cxt = (_rl_search_cxt *)xmalloc (sizeof (_rl_search_cxt));

  cxt->type = type;
  cxt->sflags = flags;

  cxt->search_string = 0;
  cxt->search_string_size = cxt->search_string_index = 0;

  cxt->lines = 0;
  cxt->allocated_line = 0;
  cxt->hlen = cxt->hindex = 0;

  cxt->save_point = rl_point;
  cxt->save_mark = rl_mark;
  cxt->save_line = where_history ();
  cxt->last_found_line = cxt->save_line;
  cxt->prev_line_found = 0;

  cxt->save_undo_list = 0;

  cxt->keymap = _rl_keymap;
  cxt->okeymap = _rl_keymap;

  cxt->history_pos = 0;
  cxt->direction = 0;

  cxt->lastc = 0;

  cxt->sline = 0;
  cxt->sline_len = cxt->sline_index = 0;

  cxt->search_terminators = 0;

  return cxt;
}
warning: parse error {
  _rl_search_cxt *cxt;

  cxt = (_rl_search_cxt *)xmalloc (sizeof (_rl_search_cxt));

  cxt->type = type;
  cxt->sflags = flags;

  cxt->search_string = 0;
  cxt->search_string_size = cxt->search_string_index = 0;

  cxt->lines = 0;
  cxt->allocated_line = 0;
  cxt->hlen = cxt->hindex = 0;

  cxt->save_point = rl_point;
  cxt->save_mark = rl_mark;
  cxt->save_line = where_history ();
  cxt->last_found_line = cxt->save_line;
  cxt->prev_line_found = 0;

  cxt->save_undo_list = 0;

  cxt->keymap = _rl_keymap;
  cxt->okeymap = _rl_keymap;

  cxt->history_pos = 0;
  cxt->direction = 0;

  cxt->lastc = 0;

  cxt->sline = 0;
  cxt->sline_len = cxt->sline_index = 0;

  cxt->search_terminators = 0;

  return cxt;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\isearch.c:84
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\isearch.c:124
parsing error 
{
  FREE (cxt->search_string);
  FREE (cxt->allocated_line);
  FREE (cxt->lines);

  xfree (cxt);
}
warning: parse error {
  FREE (cxt->search_string);
  FREE (cxt->allocated_line);
  FREE (cxt->lines);

  xfree (cxt);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\isearch.c:127
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\isearch.c:138
parsing error 
{
  return (rl_search_history (-sign, key));
}
warning: parse error {
  return (rl_search_history (-sign, key));
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\isearch.c:140
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\isearch.c:147
parsing error 
{
  return (rl_search_history (sign, key));
}
warning: parse error {
  return (rl_search_history (sign, key));
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\isearch.c:149
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\isearch.c:159
parsing error 
{
  char *message;
  int msglen, searchlen;

  searchlen = (search_string && *search_string) ? strlen (search_string) : 0;

  message = (char *)xmalloc (searchlen + 33);
  msglen = 0;

#if defined (NOTDEF)
  if (where != -1)
    {
      sprintf (message, "[%d]", where + history_base);
      msglen = strlen (message);
    }
#endif /* NOTDEF */

  message[msglen++] = '(';

  if (reverse_p)
    {
      strcpy (message + msglen, "reverse-");
      msglen += 8;
    }

  strcpy (message + msglen, "i-search)`");
  msglen += 10;

  if (search_string)
    {
      strcpy (message + msglen, search_string);
      msglen += searchlen;
    }

  strcpy (message + msglen, "': ");

  rl_message ("%s", message);
  xfree (message);
  (*rl_redisplay_function) ();
}
warning: parse error {
  char *message;
  int msglen, searchlen;

  searchlen = (search_string && *search_string) ? strlen (search_string) : 0;

  message = (char *)xmalloc (searchlen + 33);
  msglen = 0;

#if defined (NOTDEF)
  if (where != -1)
    {
      sprintf (message, "[%d]", where + history_base);
      msglen = strlen (message);
    }
#endif /* NOTDEF */

  message[msglen++] = '(';

  if (reverse_p)
    {
      strcpy (message + msglen, "reverse-");
      msglen += 8;
    }

  strcpy (message + msglen, "i-search)`");
  msglen += 10;

  if (search_string)
    {
      strcpy (message + msglen, search_string);
      msglen += searchlen;
    }

  strcpy (message + msglen, "': ");

  rl_message ("%s", message);
  xfree (message);
  (*rl_redisplay_function) ();
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\isearch.c:162
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\isearch.c:204
parsing error 
{
  _rl_search_cxt *cxt;
  register int i;
  HIST_ENTRY **hlist;

  cxt = _rl_scxt_alloc (RL_SEARCH_ISEARCH, 0);
  if (direction < 0)
    cxt->sflags |= SF_REVERSE;

  cxt->search_terminators = _rl_isearch_terminators ? _rl_isearch_terminators
						: default_isearch_terminators;

  /* Create an arrary of pointers to the lines that we want to search. */
  hlist = history_list ();
  rl_maybe_replace_line ();
  i = 0;
  if (hlist)
    for (i = 0; hlist[i]; i++);

  /* Allocate space for this many lines, +1 for the current input line,
     and remember those lines. */
  cxt->lines = (char **)xmalloc ((1 + (cxt->hlen = i)) * sizeof (char *));
  for (i = 0; i < cxt->hlen; i++)
    cxt->lines[i] = hlist[i]->line;

  if (_rl_saved_line_for_history)
    cxt->lines[i] = _rl_saved_line_for_history->line;
  else
    {
      /* Keep track of this so we can free it. */
      cxt->allocated_line = (char *)xmalloc (1 + strlen (rl_line_buffer));
      strcpy (cxt->allocated_line, &rl_line_buffer[0]);
      cxt->lines[i] = cxt->allocated_line;
    }

  cxt->hlen++;

  /* The line where we start the search. */
  cxt->history_pos = cxt->save_line;

  rl_save_prompt ();

  /* Initialize search parameters. */
  cxt->search_string = (char *)xmalloc (cxt->search_string_size = 128);
  cxt->search_string[cxt->search_string_index = 0] = '\0';

  /* Normalize DIRECTION into 1 or -1. */
  cxt->direction = (direction >= 0) ? 1 : -1;

  cxt->sline = rl_line_buffer;
  cxt->sline_len = strlen (cxt->sline);
  cxt->sline_index = rl_point;

  _rl_iscxt = cxt;		/* save globally */

  return cxt;
}
warning: parse error {
  _rl_search_cxt *cxt;
  register int i;
  HIST_ENTRY **hlist;

  cxt = _rl_scxt_alloc (RL_SEARCH_ISEARCH, 0);
  if (direction < 0)
    cxt->sflags |= SF_REVERSE;

  cxt->search_terminators = _rl_isearch_terminators ? _rl_isearch_terminators
						: default_isearch_terminators;

  /* Create an arrary of pointers to the lines that we want to search. */
  hlist = history_list ();
  rl_maybe_replace_line ();
  i = 0;
  if (hlist)
    for (i = 0; hlist[i]; i++);

  /* Allocate space for this many lines, +1 for the current input line,
     and remember those lines. */
  cxt->lines = (char **)xmalloc ((1 + (cxt->hlen = i)) * sizeof (char *));
  for (i = 0; i < cxt->hlen; i++)
    cxt->lines[i] = hlist[i]->line;

  if (_rl_saved_line_for_history)
    cxt->lines[i] = _rl_saved_line_for_history->line;
  else
    {
      /* Keep track of this so we can free it. */
      cxt->allocated_line = (char *)xmalloc (1 + strlen (rl_line_buffer));
      strcpy (cxt->allocated_line, &rl_line_buffer[0]);
      cxt->lines[i] = cxt->allocated_line;
    }

  cxt->hlen++;

  /* The line where we start the search. */
  cxt->history_pos = cxt->save_line;

  rl_save_prompt ();

  /* Initialize search parameters. */
  cxt->search_string = (char *)xmalloc (cxt->search_string_size = 128);
  cxt->search_string[cxt->search_string_index = 0] = '\0';

  /* Normalize DIRECTION into 1 or -1. */
  cxt->direction = (direction >= 0) ? 1 : -1;

  cxt->sline = rl_line_buffer;
  cxt->sline_len = strlen (cxt->sline);
  cxt->sline_index = rl_point;

  _rl_iscxt = cxt;		/* save globally */

  return cxt;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\isearch.c:206
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\isearch.c:265
parsing error 
{
  /* First put back the original state. */
  strcpy (rl_line_buffer, cxt->lines[cxt->save_line]);

  rl_restore_prompt ();

  /* Save the search string for possible later use. */
  FREE (last_isearch_string);
  last_isearch_string = cxt->search_string;
  last_isearch_string_len = cxt->search_string_index;
  cxt->search_string = 0;

  if (cxt->last_found_line < cxt->save_line)
    rl_get_previous_history (cxt->save_line - cxt->last_found_line, 0);
  else
    rl_get_next_history (cxt->last_found_line - cxt->save_line, 0);

  /* If the string was not found, put point at the end of the last matching
     line.  If last_found_line == orig_line, we didn't find any matching
     history lines at all, so put point back in its original position. */
  if (cxt->sline_index < 0)
    {
      if (cxt->last_found_line == cxt->save_line)
	cxt->sline_index = cxt->save_point;
      else
	cxt->sline_index = strlen (rl_line_buffer);
      rl_mark = cxt->save_mark;
    }

  rl_point = cxt->sline_index;
  /* Don't worry about where to put the mark here; rl_get_previous_history
     and rl_get_next_history take care of it. */

  rl_clear_message ();
}
warning: parse error {
  /* First put back the original state. */
  strcpy (rl_line_buffer, cxt->lines[cxt->save_line]);

  rl_restore_prompt ();

  /* Save the search string for possible later use. */
  FREE (last_isearch_string);
  last_isearch_string = cxt->search_string;
  last_isearch_string_len = cxt->search_string_index;
  cxt->search_string = 0;

  if (cxt->last_found_line < cxt->save_line)
    rl_get_previous_history (cxt->save_line - cxt->last_found_line, 0);
  else
    rl_get_next_history (cxt->last_found_line - cxt->save_line, 0);

  /* If the string was not found, put point at the end of the last matching
     line.  If last_found_line == orig_line, we didn't find any matching
     history lines at all, so put point back in its original position. */
  if (cxt->sline_index < 0)
    {
      if (cxt->last_found_line == cxt->save_line)
	cxt->sline_index = cxt->save_point;
      else
	cxt->sline_index = strlen (rl_line_buffer);
      rl_mark = cxt->save_mark;
    }

  rl_point = cxt->sline_index;
  /* Don't worry about where to put the mark here; rl_get_previous_history
     and rl_get_next_history take care of it. */

  rl_clear_message ();
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\isearch.c:267
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\isearch.c:304
parsing error 
{
  int c;

  /* Read a key and decide how to proceed. */
  RL_SETSTATE(RL_STATE_MOREINPUT);
  c = cxt->lastc = rl_read_key ();
  RL_UNSETSTATE(RL_STATE_MOREINPUT);

#if defined (HANDLE_MULTIBYTE)
  if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
    c = cxt->lastc = _rl_read_mbstring (cxt->lastc, cxt->mb, MB_LEN_MAX);
#endif

  return c;
}
warning: parse error {
  int c;

  /* Read a key and decide how to proceed. */
  RL_SETSTATE(RL_STATE_MOREINPUT);
  c = cxt->lastc = rl_read_key ();
  RL_UNSETSTATE(RL_STATE_MOREINPUT);

#if defined (HANDLE_MULTIBYTE)
  if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
    c = cxt->lastc = _rl_read_mbstring (cxt->lastc, cxt->mb, MB_LEN_MAX);
#endif

  return c;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\isearch.c:306
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\isearch.c:326
parsing error 
{
  int n, wstart, wlen, limit, cval;
  rl_command_func_t *f;

  f = (rl_command_func_t *)NULL;

  if (c < 0)
    {
      cxt->sflags |= SF_FAILED;
      cxt->history_pos = cxt->last_found_line;
      return -1;
    }

  /* If we are moving into a new keymap, modify cxt->keymap and go on.
     This can be a problem if c == ESC and we want to terminate the
     incremental search, so we check */
  if (c >= 0 && cxt->keymap[c].type == ISKMAP && strchr (cxt->search_terminators, cxt->lastc) == 0)
    {
      cxt->keymap = FUNCTION_TO_KEYMAP (cxt->keymap, c);
      cxt->sflags |= SF_CHGKMAP;
      /* XXX - we should probably save this sequence, so we can do
	 something useful if this doesn't end up mapping to a command. */
      return 1;
    }

  /* Translate the keys we do something with to opcodes. */
  if (c >= 0 && cxt->keymap[c].type == ISFUNC)
    {
      f = cxt->keymap[c].function;

      if (f == rl_reverse_search_history)
	cxt->lastc = (cxt->sflags & SF_REVERSE) ? -1 : -2;
      else if (f == rl_forward_search_history)
	cxt->lastc = (cxt->sflags & SF_REVERSE) ? -2 : -1;
      else if (f == rl_rubout)
	cxt->lastc = -3;
      else if (c == CTRL ('G') || f == rl_abort)
	cxt->lastc = -4;
      else if (c == CTRL ('W') || f == rl_unix_word_rubout)	/* XXX */
	cxt->lastc = -5;
      else if (c == CTRL ('Y') || f == rl_yank)	/* XXX */
	cxt->lastc = -6;
    }

  /* If we changed the keymap earlier while translating a key sequence into
     a command, restore it now that we've succeeded. */
  if (cxt->sflags & SF_CHGKMAP)
    {
      cxt->keymap = cxt->okeymap;
      cxt->sflags &= ~SF_CHGKMAP;
    }

  /* The characters in isearch_terminators (set from the user-settable
     variable isearch-terminators) are used to terminate the search but
     not subsequently execute the character as a command.  The default
     value is "\033\012" (ESC and C-J). */
  if (cxt->lastc > 0 && strchr (cxt->search_terminators, cxt->lastc))
    {
      /* ESC still terminates the search, but if there is pending
	 input or if input arrives within 0.1 seconds (on systems
	 with select(2)) it is used as a prefix character
	 with rl_execute_next.  WATCH OUT FOR THIS!  This is intended
	 to allow the arrow keys to be used like ^F and ^B are used
	 to terminate the search and execute the movement command.
	 XXX - since _rl_input_available depends on the application-
	 settable keyboard timeout value, this could alternatively
	 use _rl_input_queued(100000) */
      if (cxt->lastc == ESC && _rl_input_available ())
	rl_execute_next (ESC);
      return (0);
    }

#define ENDSRCH_CHAR(c) \
  ((CTRL_CHAR (c) || META_CHAR (c) || (c) == RUBOUT) && ((c) != CTRL ('G')))

#if defined (HANDLE_MULTIBYTE)
  if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
    {
      if (cxt->lastc >= 0 && (cxt->mb[0] && cxt->mb[1] == '\0') && ENDSRCH_CHAR (cxt->lastc))
	{
	  /* This sets rl_pending_input to LASTC; it will be picked up the next
	     time rl_read_key is called. */
	  rl_execute_next (cxt->lastc);
	  return (0);
	}
    }
  else
#endif
    if (cxt->lastc >= 0 && ENDSRCH_CHAR (cxt->lastc))
      {
	/* This sets rl_pending_input to LASTC; it will be picked up the next
	   time rl_read_key is called. */
	rl_execute_next (cxt->lastc);
	return (0);
      }

  /* Now dispatch on the character.  `Opcodes' affect the search string or
     state.  Other characters are added to the string.  */
  switch (cxt->lastc)
    {
    /* search again */
    case -1:
      if (cxt->search_string_index == 0)
	{
	  if (last_isearch_string)
	    {
	      cxt->search_string_size = 64 + last_isearch_string_len;
	      cxt->search_string = (char *)xrealloc (cxt->search_string, cxt->search_string_size);
	      strcpy (cxt->search_string, last_isearch_string);
	      cxt->search_string_index = last_isearch_string_len;
	      rl_display_search (cxt->search_string, (cxt->sflags & SF_REVERSE), -1);
	      break;
	    }
	  return (1);
	}
      else if (cxt->sflags & SF_REVERSE)
	cxt->sline_index--;
      else if (cxt->sline_index != cxt->sline_len)
	cxt->sline_index++;
      else
	rl_ding ();
      break;

    /* switch directions */
    case -2:
      cxt->direction = -cxt->direction;
      if (cxt->direction < 0)
	cxt->sflags |= SF_REVERSE;
      else
	cxt->sflags &= ~SF_REVERSE;
      break;

    /* delete character from search string. */
    case -3:	/* C-H, DEL */
      /* This is tricky.  To do this right, we need to keep a
	 stack of search positions for the current search, with
	 sentinels marking the beginning and end.  But this will
	 do until we have a real isearch-undo. */
      if (cxt->search_string_index == 0)
	rl_ding ();
      else
	cxt->search_string[--cxt->search_string_index] = '\0';
      break;

    case -4:	/* C-G, abort */
      rl_replace_line (cxt->lines[cxt->save_line], 0);
      rl_point = cxt->save_point;
      rl_mark = cxt->save_mark;
      rl_restore_prompt();
      rl_clear_message ();

      return -1;

    case -5:	/* C-W */
      /* skip over portion of line we already matched and yank word */
      wstart = rl_point + cxt->search_string_index;
      if (wstart >= rl_end)
	{
	  rl_ding ();
	  break;
	}

      /* if not in a word, move to one. */
      cval = _rl_char_value (rl_line_buffer, wstart);
      if (_rl_walphabetic (cval) == 0)
	{
	  rl_ding ();
	  break;
	}
      n = MB_NEXTCHAR (rl_line_buffer, wstart, 1, MB_FIND_NONZERO);;
      while (n < rl_end)
	{
	  cval = _rl_char_value (rl_line_buffer, n);
	  if (_rl_walphabetic (cval) == 0)
	    break;
	  n = MB_NEXTCHAR (rl_line_buffer, n, 1, MB_FIND_NONZERO);;
	}
      wlen = n - wstart + 1;
      if (cxt->search_string_index + wlen + 1 >= cxt->search_string_size)
	{
	  cxt->search_string_size += wlen + 1;
	  cxt->search_string = (char *)xrealloc (cxt->search_string, cxt->search_string_size);
	}
      for (; wstart < n; wstart++)
	cxt->search_string[cxt->search_string_index++] = rl_line_buffer[wstart];
      cxt->search_string[cxt->search_string_index] = '\0';
      break;

    case -6:	/* C-Y */
      /* skip over portion of line we already matched and yank rest */
      wstart = rl_point + cxt->search_string_index;
      if (wstart >= rl_end)
	{
	  rl_ding ();
	  break;
	}
      n = rl_end - wstart + 1;
      if (cxt->search_string_index + n + 1 >= cxt->search_string_size)
	{
	  cxt->search_string_size += n + 1;
	  cxt->search_string = (char *)xrealloc (cxt->search_string, cxt->search_string_size);
	}
      for (n = wstart; n < rl_end; n++)
	cxt->search_string[cxt->search_string_index++] = rl_line_buffer[n];
      cxt->search_string[cxt->search_string_index] = '\0';
      break;

    /* Add character to search string and continue search. */
    default:
      if (cxt->search_string_index + 2 >= cxt->search_string_size)
	{
	  cxt->search_string_size += 128;
	  cxt->search_string = (char *)xrealloc (cxt->search_string, cxt->search_string_size);
	}
#if defined (HANDLE_MULTIBYTE)
      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
	{
	  int j, l;
	  for (j = 0, l = strlen (cxt->mb); j < l; )
	    cxt->search_string[cxt->search_string_index++] = cxt->mb[j++];
	}
      else
#endif
	cxt->search_string[cxt->search_string_index++] = c;
      cxt->search_string[cxt->search_string_index] = '\0';
      break;
    }

  for (cxt->sflags &= ~(SF_FOUND|SF_FAILED);; )
    {
      limit = cxt->sline_len - cxt->search_string_index + 1;

      /* Search the current line. */
      while ((cxt->sflags & SF_REVERSE) ? (cxt->sline_index >= 0) : (cxt->sline_index < limit))
	{
	  if (STREQN (cxt->search_string, cxt->sline + cxt->sline_index, cxt->search_string_index))
	    {
	      cxt->sflags |= SF_FOUND;
	      break;
	    }
	  else
	    cxt->sline_index += cxt->direction;
	}
      if (cxt->sflags & SF_FOUND)
	break;

      /* Move to the next line, but skip new copies of the line
	 we just found and lines shorter than the string we're
	 searching for. */
      do
	{
	  /* Move to the next line. */
	  cxt->history_pos += cxt->direction;

	  /* At limit for direction? */
	  if ((cxt->sflags & SF_REVERSE) ? (cxt->history_pos < 0) : (cxt->history_pos == cxt->hlen))
	    {
	      cxt->sflags |= SF_FAILED;
	      break;
	    }

	  /* We will need these later. */
	  cxt->sline = cxt->lines[cxt->history_pos];
	  cxt->sline_len = strlen (cxt->sline);
	}
      while ((cxt->prev_line_found && STREQ (cxt->prev_line_found, cxt->lines[cxt->history_pos])) ||
	     (cxt->search_string_index > cxt->sline_len));

      if (cxt->sflags & SF_FAILED)
	break;

      /* Now set up the line for searching... */
      cxt->sline_index = (cxt->sflags & SF_REVERSE) ? cxt->sline_len - cxt->search_string_index : 0;
    }

  if (cxt->sflags & SF_FAILED)
    {
      /* We cannot find the search string.  Ding the bell. */
      rl_ding ();
      cxt->history_pos = cxt->last_found_line;
      return 1;
    }

  /* We have found the search string.  Just display it.  But don't
     actually move there in the history list until the user accepts
     the location. */
  if (cxt->sflags & SF_FOUND)
    {
      cxt->prev_line_found = cxt->lines[cxt->history_pos];
      rl_replace_line (cxt->lines[cxt->history_pos], 0);
      rl_point = cxt->sline_index;
      cxt->last_found_line = cxt->history_pos;
      rl_display_search (cxt->search_string, (cxt->sflags & SF_REVERSE), (cxt->history_pos == cxt->save_line) ? -1 : cxt->history_pos);
    }

  return 1;
}
warning: parse error {
  int n, wstart, wlen, limit, cval;
  rl_command_func_t *f;

  f = (rl_command_func_t *)NULL;

  if (c < 0)
    {
      cxt->sflags |= SF_FAILED;
      cxt->history_pos = cxt->last_found_line;
      return -1;
    }

  /* If we are moving into a new keymap, modify cxt->keymap and go on.
     This can be a problem if c == ESC and we want to terminate the
     incremental search, so we check */
  if (c >= 0 && cxt->keymap[c].type == ISKMAP && strchr (cxt->search_terminators, cxt->lastc) == 0)
    {
      cxt->keymap = FUNCTION_TO_KEYMAP (cxt->keymap, c);
      cxt->sflags |= SF_CHGKMAP;
      /* XXX - we should probably save this sequence, so we can do
	 something useful if this doesn't end up mapping to a command. */
      return 1;
    }

  /* Translate the keys we do something with to opcodes. */
  if (c >= 0 && cxt->keymap[c].type == ISFUNC)
    {
      f = cxt->keymap[c].function;

      if (f == rl_reverse_search_history)
	cxt->lastc = (cxt->sflags & SF_REVERSE) ? -1 : -2;
      else if (f == rl_forward_search_history)
	cxt->lastc = (cxt->sflags & SF_REVERSE) ? -2 : -1;
      else if (f == rl_rubout)
	cxt->lastc = -3;
      else if (c == CTRL ('G') || f == rl_abort)
	cxt->lastc = -4;
      else if (c == CTRL ('W') || f == rl_unix_word_rubout)	/* XXX */
	cxt->lastc = -5;
      else if (c == CTRL ('Y') || f == rl_yank)	/* XXX */
	cxt->lastc = -6;
    }

  /* If we changed the keymap earlier while translating a key sequence into
     a command, restore it now that we've succeeded. */
  if (cxt->sflags & SF_CHGKMAP)
    {
      cxt->keymap = cxt->okeymap;
      cxt->sflags &= ~SF_CHGKMAP;
    }

  /* The characters in isearch_terminators (set from the user-settable
     variable isearch-terminators) are used to terminate the search but
     not subsequently execute the character as a command.  The default
     value is "\033\012" (ESC and C-J). */
  if (cxt->lastc > 0 && strchr (cxt->search_terminators, cxt->lastc))
    {
      /* ESC still terminates the search, but if there is pending
	 input or if input arrives within 0.1 seconds (on systems
	 with select(2)) it is used as a prefix character
	 with rl_execute_next.  WATCH OUT FOR THIS!  This is intended
	 to allow the arrow keys to be used like ^F and ^B are used
	 to terminate the search and execute the movement command.
	 XXX - since _rl_input_available depends on the application-
	 settable keyboard timeout value, this could alternatively
	 use _rl_input_queued(100000) */
      if (cxt->lastc == ESC && _rl_input_available ())
	rl_execute_next (ESC);
      return (0);
    }

#define ENDSRCH_CHAR(c) \
  ((CTRL_CHAR (c) || META_CHAR (c) || (c) == RUBOUT) && ((c) != CTRL ('G')))

#if defined (HANDLE_MULTIBYTE)
  if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
    {
      if (cxt->lastc >= 0 && (cxt->mb[0] && cxt->mb[1] == '\0') && ENDSRCH_CHAR (cxt->lastc))
	{
	  /* This sets rl_pending_input to LASTC; it will be picked up the next
	     time rl_read_key is called. */
	  rl_execute_next (cxt->lastc);
	  return (0);
	}
    }
  else
#endif
    if (cxt->lastc >= 0 && ENDSRCH_CHAR (cxt->lastc))
      {
	/* This sets rl_pending_input to LASTC; it will be picked up the next
	   time rl_read_key is called. */
	rl_execute_next (cxt->lastc);
	return (0);
      }

  /* Now dispatch on the character.  `Opcodes' affect the search string or
     state.  Other characters are added to the string.  */
  switch (cxt->lastc)
    {
    /* search again */
    case -1:
      if (cxt->search_string_index == 0)
	{
	  if (last_isearch_string)
	    {
	      cxt->search_string_size = 64 + last_isearch_string_len;
	      cxt->search_string = (char *)xrealloc (cxt->search_string, cxt->search_string_size);
	      strcpy (cxt->search_string, last_isearch_string);
	      cxt->search_string_index = last_isearch_string_len;
	      rl_display_search (cxt->search_string, (cxt->sflags & SF_REVERSE), -1);
	      break;
	    }
	  return (1);
	}
      else if (cxt->sflags & SF_REVERSE)
	cxt->sline_index--;
      else if (cxt->sline_index != cxt->sline_len)
	cxt->sline_index++;
      else
	rl_ding ();
      break;

    /* switch directions */
    case -2:
      cxt->direction = -cxt->direction;
      if (cxt->direction < 0)
	cxt->sflags |= SF_REVERSE;
      else
	cxt->sflags &= ~SF_REVERSE;
      break;

    /* delete character from search string. */
    case -3:	/* C-H, DEL */
      /* This is tricky.  To do this right, we need to keep a
	 stack of search positions for the current search, with
	 sentinels marking the beginning and end.  But this will
	 do until we have a real isearch-undo. */
      if (cxt->search_string_index == 0)
	rl_ding ();
      else
	cxt->search_string[--cxt->search_string_index] = '\0';
      break;

    case -4:	/* C-G, abort */
      rl_replace_line (cxt->lines[cxt->save_line], 0);
      rl_point = cxt->save_point;
      rl_mark = cxt->save_mark;
      rl_restore_prompt();
      rl_clear_message ();

      return -1;

    case -5:	/* C-W */
      /* skip over portion of line we already matched and yank word */
      wstart = rl_point + cxt->search_string_index;
      if (wstart >= rl_end)
	{
	  rl_ding ();
	  break;
	}

      /* if not in a word, move to one. */
      cval = _rl_char_value (rl_line_buffer, wstart);
      if (_rl_walphabetic (cval) == 0)
	{
	  rl_ding ();
	  break;
	}
      n = MB_NEXTCHAR (rl_line_buffer, wstart, 1, MB_FIND_NONZERO);;
      while (n < rl_end)
	{
	  cval = _rl_char_value (rl_line_buffer, n);
	  if (_rl_walphabetic (cval) == 0)
	    break;
	  n = MB_NEXTCHAR (rl_line_buffer, n, 1, MB_FIND_NONZERO);;
	}
      wlen = n - wstart + 1;
      if (cxt->search_string_index + wlen + 1 >= cxt->search_string_size)
	{
	  cxt->search_string_size += wlen + 1;
	  cxt->search_string = (char *)xrealloc (cxt->search_string, cxt->search_string_size);
	}
      for (; wstart < n; wstart++)
	cxt->search_string[cxt->search_string_index++] = rl_line_buffer[wstart];
      cxt->search_string[cxt->search_string_index] = '\0';
      break;

    case -6:	/* C-Y */
      /* skip over portion of line we already matched and yank rest */
      wstart = rl_point + cxt->search_string_index;
      if (wstart >= rl_end)
	{
	  rl_ding ();
	  break;
	}
      n = rl_end - wstart + 1;
      if (cxt->search_string_index + n + 1 >= cxt->search_string_size)
	{
	  cxt->search_string_size += n + 1;
	  cxt->search_string = (char *)xrealloc (cxt->search_string, cxt->search_string_size);
	}
      for (n = wstart; n < rl_end; n++)
	cxt->search_string[cxt->search_string_index++] = rl_line_buffer[n];
      cxt->search_string[cxt->search_string_index] = '\0';
      break;

    /* Add character to search string and continue search. */
    default:
      if (cxt->search_string_index + 2 >= cxt->search_string_size)
	{
	  cxt->search_string_size += 128;
	  cxt->search_string = (char *)xrealloc (cxt->search_string, cxt->search_string_size);
	}
#if defined (HANDLE_MULTIBYTE)
      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
	{
	  int j, l;
	  for (j = 0, l = strlen (cxt->mb); j < l; )
	    cxt->search_string[cxt->search_string_index++] = cxt->mb[j++];
	}
      else
#endif
	cxt->search_string[cxt->search_string_index++] = c;
      cxt->search_string[cxt->search_string_index] = '\0';
      break;
    }

  for (cxt->sflags &= ~(SF_FOUND|SF_FAILED);; )
    {
      limit = cxt->sline_len - cxt->search_string_index + 1;

      /* Search the current line. */
      while ((cxt->sflags & SF_REVERSE) ? (cxt->sline_index >= 0) : (cxt->sline_index < limit))
	{
	  if (STREQN (cxt->search_string, cxt->sline + cxt->sline_index, cxt->search_string_index))
	    {
	      cxt->sflags |= SF_FOUND;
	      break;
	    }
	  else
	    cxt->sline_index += cxt->direction;
	}
      if (cxt->sflags & SF_FOUND)
	break;

      /* Move to the next line, but skip new copies of the line
	 we just found and lines shorter than the string we're
	 searching for. */
      do
	{
	  /* Move to the next line. */
	  cxt->history_pos += cxt->direction;

	  /* At limit for direction? */
	  if ((cxt->sflags & SF_REVERSE) ? (cxt->history_pos < 0) : (cxt->history_pos == cxt->hlen))
	    {
	      cxt->sflags |= SF_FAILED;
	      break;
	    }

	  /* We will need these later. */
	  cxt->sline = cxt->lines[cxt->history_pos];
	  cxt->sline_len = strlen (cxt->sline);
	}
      while ((cxt->prev_line_found && STREQ (cxt->prev_line_found, cxt->lines[cxt->history_pos])) ||
	     (cxt->search_string_index > cxt->sline_len));

      if (cxt->sflags & SF_FAILED)
	break;

      /* Now set up the line for searching... */
      cxt->sline_index = (cxt->sflags & SF_REVERSE) ? cxt->sline_len - cxt->search_string_index : 0;
    }

  if (cxt->sflags & SF_FAILED)
    {
      /* We cannot find the search string.  Ding the bell. */
      rl_ding ();
      cxt->history_pos = cxt->last_found_line;
      return 1;
    }

  /* We have found the search string.  Just display it.  But don't
     actually move there in the history list until the user accepts
     the location. */
  if (cxt->sflags & SF_FOUND)
    {
      cxt->prev_line_found = cxt->lines[cxt->history_pos];
      rl_replace_line (cxt->lines[cxt->history_pos], 0);
      rl_point = cxt->sline_index;
      cxt->last_found_line = cxt->history_pos;
      rl_display_search (cxt->search_string, (cxt->sflags & SF_REVERSE), (cxt->history_pos == cxt->save_line) ? -1 : cxt->history_pos);
    }

  return 1;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\isearch.c:329
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\isearch.c:628
parsing error 
{
  if (r >= 0)
    _rl_isearch_fini (cxt);
  _rl_scxt_dispose (cxt, 0);
  _rl_iscxt = 0;

  RL_UNSETSTATE(RL_STATE_ISEARCH);

  return (r != 0);
}
warning: parse error {
  if (r >= 0)
    _rl_isearch_fini (cxt);
  _rl_scxt_dispose (cxt, 0);
  _rl_iscxt = 0;

  RL_UNSETSTATE(RL_STATE_ISEARCH);

  return (r != 0);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\isearch.c:631
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\isearch.c:647
parsing error 
{
  _rl_search_cxt *cxt;		/* local for now, but saved globally */
  int c, r;

  RL_SETSTATE(RL_STATE_ISEARCH);
  cxt = _rl_isearch_init (direction);

  rl_display_search (cxt->search_string, (cxt->sflags & SF_REVERSE), -1);

  /* If we are using the callback interface, all we do is set up here and
      return.  The key is that we leave RL_STATE_ISEARCH set. */
  if (RL_ISSTATE (RL_STATE_CALLBACK))
    return (0);

  r = -1;
  for (;;)
    {
      c = _rl_search_getchar (cxt);
      /* We might want to handle EOF here (c == 0) */
      r = _rl_isearch_dispatch (cxt, cxt->lastc);
      if (r <= 0)
        break;
    }

  /* The searching is over.  The user may have found the string that she
     was looking for, or else she may have exited a failing search.  If
     LINE_INDEX is -1, then that shows that the string searched for was
     not found.  We use this to determine where to place rl_point. */
  return (_rl_isearch_cleanup (cxt, r));
}
warning: parse error {
  _rl_search_cxt *cxt;		/* local for now, but saved globally */
  int c, r;

  RL_SETSTATE(RL_STATE_ISEARCH);
  cxt = _rl_isearch_init (direction);

  rl_display_search (cxt->search_string, (cxt->sflags & SF_REVERSE), -1);

  /* If we are using the callback interface, all we do is set up here and
      return.  The key is that we leave RL_STATE_ISEARCH set. */
  if (RL_ISSTATE (RL_STATE_CALLBACK))
    return (0);

  r = -1;
  for (;;)
    {
      c = _rl_search_getchar (cxt);
      /* We might want to handle EOF here (c == 0) */
      r = _rl_isearch_dispatch (cxt, cxt->lastc);
      if (r <= 0)
        break;
    }

  /* The searching is over.  The user may have found the string that she
     was looking for, or else she may have exited a failing search.  If
     LINE_INDEX is -1, then that shows that the string searched for was
     not found.  We use this to determine where to place rl_point. */
  return (_rl_isearch_cleanup (cxt, r));
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\isearch.c:649
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\isearch.c:686
parsing error 
{
  int c, r;

  c = _rl_search_getchar (cxt);
  /* We might want to handle EOF here */
  r = _rl_isearch_dispatch (cxt, cxt->lastc);

  return (r <= 0) ? _rl_isearch_cleanup (cxt, r) : 0;
}
warning: parse error {
  int c, r;

  c = _rl_search_getchar (cxt);
  /* We might want to handle EOF here */
  r = _rl_isearch_dispatch (cxt, cxt->lastc);

  return (r <= 0) ? _rl_isearch_cleanup (cxt, r) : 0;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\isearch.c:688
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\keymaps.c...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\rlconf.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\emacs_keymap.c...skip
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\vi_keymap.c...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\xmalloc.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\keymaps.c:83
parsing error 
{
  register int i;
  Keymap temp;

  temp = rl_make_bare_keymap ();
  for (i = 0; i < KEYMAP_SIZE; i++)
    {
      temp[i].type = map[i].type;
      temp[i].function = map[i].function;
    }
  return (temp);
}
warning: parse error {
  register int i;
  Keymap temp;

  temp = rl_make_bare_keymap ();
  for (i = 0; i < KEYMAP_SIZE; i++)
    {
      temp[i].type = map[i].type;
      temp[i].function = map[i].function;
    }
  return (temp);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\keymaps.c:85
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\keymaps.c:128
parsing error 
{
  int i;

  if (map == 0)
    return;

  for (i = 0; i < KEYMAP_SIZE; i++)
    {
      switch (map[i].type)
	{
	case ISFUNC:
	  break;

	case ISKMAP:
	  rl_discard_keymap ((Keymap)map[i].function);
	  xfree ((char *)map[i].function);
	  break;

	case ISMACR:
	  xfree ((char *)map[i].function);
	  break;
	}
    }
}
warning: parse error {
  int i;

  if (map == 0)
    return;

  for (i = 0; i < KEYMAP_SIZE; i++)
    {
      switch (map[i].type)
	{
	case ISFUNC:
	  break;

	case ISKMAP:
	  rl_discard_keymap ((Keymap)map[i].function);
	  xfree ((char *)map[i].function);
	  break;

	case ISMACR:
	  xfree ((char *)map[i].function);
	  break;
	}
    }
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\keymaps.c:130
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\keymaps.c:157
parsing error 
{
  rl_discard_keymap (map);
  xfree ((char *)map);
}
warning: parse error {
  rl_discard_keymap (map);
  xfree ((char *)map);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\keymaps.c:159
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\kill.c...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\rldefs.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\history.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\rlprivate.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\xmalloc.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\kill.c:81
parsing error 
{
  return 0;
}
warning: parse error {
  return 0;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\kill.c:83
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\kill.c:92
parsing error 
{
  char *old, *new;
  int slot;

  /* First, find the slot to work with. */
  if (_rl_last_command_was_kill == 0)
    {
      /* Get a new slot.  */
      if (rl_kill_ring == 0)
	{
	  /* If we don't have any defined, then make one. */
	  rl_kill_ring = (char **)
	    xmalloc (((rl_kill_ring_length = 1) + 1) * sizeof (char *));
	  rl_kill_ring[slot = 0] = (char *)NULL;
	}
      else
	{
	  /* We have to add a new slot on the end, unless we have
	     exceeded the max limit for remembering kills. */
	  slot = rl_kill_ring_length;
	  if (slot == rl_max_kills)
	    {
	      register int i;
	      xfree (rl_kill_ring[0]);
	      for (i = 0; i < slot; i++)
		rl_kill_ring[i] = rl_kill_ring[i + 1];
	    }
	  else
	    {
	      slot = rl_kill_ring_length += 1;
	      rl_kill_ring = (char **)xrealloc (rl_kill_ring, slot * sizeof (char *));
	    }
	  rl_kill_ring[--slot] = (char *)NULL;
	}
    }
  else
    slot = rl_kill_ring_length - 1;

  /* If the last command was a kill, prepend or append. */
  if (_rl_last_command_was_kill && rl_editing_mode != vi_mode)
    {
      old = rl_kill_ring[slot];
      new = (char *)xmalloc (1 + strlen (old) + strlen (text));

      if (append)
	{
	  strcpy (new, old);
	  strcat (new, text);
	}
      else
	{
	  strcpy (new, text);
	  strcat (new, old);
	}
      xfree (old);
      xfree (text);
      rl_kill_ring[slot] = new;
    }
  else
    rl_kill_ring[slot] = text;

  rl_kill_index = slot;
  return 0;
}
warning: parse error {
  char *old, *new;
  int slot;

  /* First, find the slot to work with. */
  if (_rl_last_command_was_kill == 0)
    {
      /* Get a new slot.  */
      if (rl_kill_ring == 0)
	{
	  /* If we don't have any defined, then make one. */
	  rl_kill_ring = (char **)
	    xmalloc (((rl_kill_ring_length = 1) + 1) * sizeof (char *));
	  rl_kill_ring[slot = 0] = (char *)NULL;
	}
      else
	{
	  /* We have to add a new slot on the end, unless we have
	     exceeded the max limit for remembering kills. */
	  slot = rl_kill_ring_length;
	  if (slot == rl_max_kills)
	    {
	      register int i;
	      xfree (rl_kill_ring[0]);
	      for (i = 0; i < slot; i++)
		rl_kill_ring[i] = rl_kill_ring[i + 1];
	    }
	  else
	    {
	      slot = rl_kill_ring_length += 1;
	      rl_kill_ring = (char **)xrealloc (rl_kill_ring, slot * sizeof (char *));
	    }
	  rl_kill_ring[--slot] = (char *)NULL;
	}
    }
  else
    slot = rl_kill_ring_length - 1;

  /* If the last command was a kill, prepend or append. */
  if (_rl_last_command_was_kill && rl_editing_mode != vi_mode)
    {
      old = rl_kill_ring[slot];
      new = (char *)xmalloc (1 + strlen (old) + strlen (text));

      if (append)
	{
	  strcpy (new, old);
	  strcat (new, text);
	}
      else
	{
	  strcpy (new, text);
	  strcat (new, old);
	}
      xfree (old);
      xfree (text);
      rl_kill_ring[slot] = new;
    }
  else
    rl_kill_ring[slot] = text;

  rl_kill_index = slot;
  return 0;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\kill.c:95
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\kill.c:166
parsing error 
{
  char *text;

  /* Is there anything to kill? */
  if (from == to)
    {
      _rl_last_command_was_kill++;
      return 0;
    }

  text = rl_copy_text (from, to);

  /* Delete the copied text from the line. */
  rl_delete_text (from, to);

  _rl_copy_to_kill_ring (text, from < to);

  _rl_last_command_was_kill++;
  return 0;
}
warning: parse error {
  char *text;

  /* Is there anything to kill? */
  if (from == to)
    {
      _rl_last_command_was_kill++;
      return 0;
    }

  text = rl_copy_text (from, to);

  /* Delete the copied text from the line. */
  rl_delete_text (from, to);

  _rl_copy_to_kill_ring (text, from < to);

  _rl_last_command_was_kill++;
  return 0;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\kill.c:168
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\kill.c:201
parsing error 
{
  int orig_point;

  if (count < 0)
    return (rl_backward_kill_word (-count, key));
  else
    {
      orig_point = rl_point;
      rl_forward_word (count, key);

      if (rl_point != orig_point)
	rl_kill_text (orig_point, rl_point);

      rl_point = orig_point;
      if (rl_editing_mode == emacs_mode)
	rl_mark = rl_point;
    }
  return 0;
}
warning: parse error {
  int orig_point;

  if (count < 0)
    return (rl_backward_kill_word (-count, key));
  else
    {
      orig_point = rl_point;
      rl_forward_word (count, key);

      if (rl_point != orig_point)
	rl_kill_text (orig_point, rl_point);

      rl_point = orig_point;
      if (rl_editing_mode == emacs_mode)
	rl_mark = rl_point;
    }
  return 0;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\kill.c:203
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\kill.c:225
parsing error 
{
  int orig_point;

  if (count < 0)
    return (rl_kill_word (-count, ignore));
  else
    {
      orig_point = rl_point;
      rl_backward_word (count, ignore);

      if (rl_point != orig_point)
	rl_kill_text (orig_point, rl_point);

      if (rl_editing_mode == emacs_mode)
	rl_mark = rl_point;
    }
  return 0;
}
warning: parse error {
  int orig_point;

  if (count < 0)
    return (rl_kill_word (-count, ignore));
  else
    {
      orig_point = rl_point;
      rl_backward_word (count, ignore);

      if (rl_point != orig_point)
	rl_kill_text (orig_point, rl_point);

      if (rl_editing_mode == emacs_mode)
	rl_mark = rl_point;
    }
  return 0;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\kill.c:227
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\kill.c:249
parsing error 
{
  int orig_point;

  if (direction < 0)
    return (rl_backward_kill_line (1, ignore));
  else
    {
      orig_point = rl_point;
      rl_end_of_line (1, ignore);
      if (orig_point != rl_point)
	rl_kill_text (orig_point, rl_point);
      rl_point = orig_point;
      if (rl_editing_mode == emacs_mode)
	rl_mark = rl_point;
    }
  return 0;
}
warning: parse error {
  int orig_point;

  if (direction < 0)
    return (rl_backward_kill_line (1, ignore));
  else
    {
      orig_point = rl_point;
      rl_end_of_line (1, ignore);
      if (orig_point != rl_point)
	rl_kill_text (orig_point, rl_point);
      rl_point = orig_point;
      if (rl_editing_mode == emacs_mode)
	rl_mark = rl_point;
    }
  return 0;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\kill.c:251
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\kill.c:272
parsing error 
{
  int orig_point;

  if (direction < 0)
    return (rl_kill_line (1, ignore));
  else
    {
      if (!rl_point)
	rl_ding ();
      else
	{
	  orig_point = rl_point;
	  rl_beg_of_line (1, ignore);
	  if (rl_point != orig_point)
	    rl_kill_text (orig_point, rl_point);
	  if (rl_editing_mode == emacs_mode)
	    rl_mark = rl_point;
	}
    }
  return 0;
}
warning: parse error {
  int orig_point;

  if (direction < 0)
    return (rl_kill_line (1, ignore));
  else
    {
      if (!rl_point)
	rl_ding ();
      else
	{
	  orig_point = rl_point;
	  rl_beg_of_line (1, ignore);
	  if (rl_point != orig_point)
	    rl_kill_text (orig_point, rl_point);
	  if (rl_editing_mode == emacs_mode)
	    rl_mark = rl_point;
	}
    }
  return 0;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\kill.c:274
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\kill.c:298
parsing error 
{
  rl_begin_undo_group ();
  rl_point = 0;
  rl_kill_text (rl_point, rl_end);
  rl_mark = 0;
  rl_end_undo_group ();
  return 0;
}
warning: parse error {
  rl_begin_undo_group ();
  rl_point = 0;
  rl_kill_text (rl_point, rl_end);
  rl_mark = 0;
  rl_end_undo_group ();
  return 0;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\kill.c:300
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\kill.c:316
parsing error 
{
  int orig_point;

  if (rl_point == 0)
    rl_ding ();
  else
    {
      orig_point = rl_point;
      if (count <= 0)
	count = 1;

      while (count--)
	{
	  while (rl_point && whitespace (rl_line_buffer[rl_point - 1]))
	    rl_point--;

	  while (rl_point && (whitespace (rl_line_buffer[rl_point - 1]) == 0))
	    rl_point--;
	}

      rl_kill_text (orig_point, rl_point);
      if (rl_editing_mode == emacs_mode)
	rl_mark = rl_point;
    }

  return 0;
}
warning: parse error {
  int orig_point;

  if (rl_point == 0)
    rl_ding ();
  else
    {
      orig_point = rl_point;
      if (count <= 0)
	count = 1;

      while (count--)
	{
	  while (rl_point && whitespace (rl_line_buffer[rl_point - 1]))
	    rl_point--;

	  while (rl_point && (whitespace (rl_line_buffer[rl_point - 1]) == 0))
	    rl_point--;
	}

      rl_kill_text (orig_point, rl_point);
      if (rl_editing_mode == emacs_mode)
	rl_mark = rl_point;
    }

  return 0;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\kill.c:318
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\kill.c:349
parsing error 
{
  int orig_point, c;

  if (rl_point == 0)
    rl_ding ();
  else
    {
      orig_point = rl_point;
      if (count <= 0)
	count = 1;

      while (count--)
	{
	  c = rl_line_buffer[rl_point - 1];
	  while (rl_point && (whitespace (c) || c == '/'))
	    {
	      rl_point--;
	      c = rl_line_buffer[rl_point - 1];
	    }

	  while (rl_point && (whitespace (c) == 0) && c != '/')
	    {
	      rl_point--;
	      c = rl_line_buffer[rl_point - 1];
	    }
	}

      rl_kill_text (orig_point, rl_point);
      if (rl_editing_mode == emacs_mode)
	rl_mark = rl_point;
    }

  return 0;
}
warning: parse error {
  int orig_point, c;

  if (rl_point == 0)
    rl_ding ();
  else
    {
      orig_point = rl_point;
      if (count <= 0)
	count = 1;

      while (count--)
	{
	  c = rl_line_buffer[rl_point - 1];
	  while (rl_point && (whitespace (c) || c == '/'))
	    {
	      rl_point--;
	      c = rl_line_buffer[rl_point - 1];
	    }

	  while (rl_point && (whitespace (c) == 0) && c != '/')
	    {
	      rl_point--;
	      c = rl_line_buffer[rl_point - 1];
	    }
	}

      rl_kill_text (orig_point, rl_point);
      if (rl_editing_mode == emacs_mode)
	rl_mark = rl_point;
    }

  return 0;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\kill.c:351
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\kill.c:393
parsing error 
{
  if (rl_point == 0)
    rl_ding ();
  else
    {
      rl_kill_text (rl_point, 0);
      rl_point = 0;
      if (rl_editing_mode == emacs_mode)
	rl_mark = rl_point;
    }
  return 0;
}
warning: parse error {
  if (rl_point == 0)
    rl_ding ();
  else
    {
      rl_kill_text (rl_point, 0);
      rl_point = 0;
      if (rl_editing_mode == emacs_mode)
	rl_mark = rl_point;
    }
  return 0;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\kill.c:395
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\kill.c:411
parsing error 
{
  char *text;

  if (rl_mark != rl_point)
    {
      text = rl_copy_text (rl_point, rl_mark);
      if (delete)
	rl_delete_text (rl_point, rl_mark);
      _rl_copy_to_kill_ring (text, rl_point < rl_mark);
    }

  _rl_last_command_was_kill++;
  return 0;
}
warning: parse error {
  char *text;

  if (rl_mark != rl_point)
    {
      text = rl_copy_text (rl_point, rl_mark);
      if (delete)
	rl_delete_text (rl_point, rl_mark);
      _rl_copy_to_kill_ring (text, rl_point < rl_mark);
    }

  _rl_last_command_was_kill++;
  return 0;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\kill.c:413
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\kill.c:430
parsing error 
{
  return (region_kill_internal (0));
}
warning: parse error {
  return (region_kill_internal (0));
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\kill.c:432
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\kill.c:438
parsing error 
{
  int r, npoint;

  npoint = (rl_point < rl_mark) ? rl_point : rl_mark;
  r = region_kill_internal (1);
  _rl_fix_point (1);
  rl_point = npoint;
  return r;
}
warning: parse error {
  int r, npoint;

  npoint = (rl_point < rl_mark) ? rl_point : rl_mark;
  r = region_kill_internal (1);
  _rl_fix_point (1);
  rl_point = npoint;
  return r;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\kill.c:440
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\kill.c:453
parsing error 
{
  int om, op, r;

  om = rl_mark;
  op = rl_point;

  if (dir > 0)
    rl_forward_word (count, 0);
  else
    rl_backward_word (count, 0);

  rl_mark = rl_point;

  if (dir > 0)
    rl_backward_word (count, 0);
  else
    rl_forward_word (count, 0);

  r = region_kill_internal (0);

  rl_mark = om;
  rl_point = op;

  return r;
}
warning: parse error {
  int om, op, r;

  om = rl_mark;
  op = rl_point;

  if (dir > 0)
    rl_forward_word (count, 0);
  else
    rl_backward_word (count, 0);

  rl_mark = rl_point;

  if (dir > 0)
    rl_backward_word (count, 0);
  else
    rl_forward_word (count, 0);

  r = region_kill_internal (0);

  rl_mark = om;
  rl_point = op;

  return r;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\kill.c:455
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\kill.c:482
parsing error 
{
  if (count < 0)
    return (rl_copy_backward_word (-count, key));

  return (_rl_copy_word_as_kill (count, 1));
}
warning: parse error {
  if (count < 0)
    return (rl_copy_backward_word (-count, key));

  return (_rl_copy_word_as_kill (count, 1));
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\kill.c:484
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\kill.c:492
parsing error 
{
  if (count < 0)
    return (rl_copy_forward_word (-count, key));

  return (_rl_copy_word_as_kill (count, -1));
}
warning: parse error {
  if (count < 0)
    return (rl_copy_forward_word (-count, key));

  return (_rl_copy_word_as_kill (count, -1));
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\kill.c:494
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\kill.c:503
parsing error 
{
  if (rl_kill_ring == 0)
    {
      _rl_abort_internal ();
      return -1;
    }

  _rl_set_mark_at_pos (rl_point);
  rl_insert_text (rl_kill_ring[rl_kill_index]);
  return 0;
}
warning: parse error {
  if (rl_kill_ring == 0)
    {
      _rl_abort_internal ();
      return -1;
    }

  _rl_set_mark_at_pos (rl_point);
  rl_insert_text (rl_kill_ring[rl_kill_index]);
  return 0;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\kill.c:505
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\kill.c:522
parsing error 
{
  int l, n;

  if (((rl_last_func != rl_yank_pop) && (rl_last_func != rl_yank)) ||
      !rl_kill_ring)
    {
      _rl_abort_internal ();
      return -1;
    }

  l = strlen (rl_kill_ring[rl_kill_index]);
  n = rl_point - l;
  if (n >= 0 && STREQN (rl_line_buffer + n, rl_kill_ring[rl_kill_index], l))
    {
      rl_delete_text (n, rl_point);
      rl_point = n;
      rl_kill_index--;
      if (rl_kill_index < 0)
	rl_kill_index = rl_kill_ring_length - 1;
      rl_yank (1, 0);
      return 0;
    }
  else
    {
      _rl_abort_internal ();
      return -1;
    }
}
warning: parse error {
  int l, n;

  if (((rl_last_func != rl_yank_pop) && (rl_last_func != rl_yank)) ||
      !rl_kill_ring)
    {
      _rl_abort_internal ();
      return -1;
    }

  l = strlen (rl_kill_ring[rl_kill_index]);
  n = rl_point - l;
  if (n >= 0 && STREQN (rl_line_buffer + n, rl_kill_ring[rl_kill_index], l))
    {
      rl_delete_text (n, rl_point);
      rl_point = n;
      rl_kill_index--;
      if (rl_kill_index < 0)
	rl_kill_index = rl_kill_ring_length - 1;
      rl_yank (1, 0);
      return 0;
    }
  else
    {
      _rl_abort_internal ();
      return -1;
    }
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\kill.c:524
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\kill.c:556
parsing error 
{
  register HIST_ENTRY *entry;
  char *arg;
  int i, pos;

  pos = where_history ();

  if (history_skip)
    {
      for (i = 0; i < history_skip; i++)
	entry = previous_history ();
    }

  entry = previous_history ();

  history_set_pos (pos);

  if (entry == 0)
    {
      rl_ding ();
      return -1;
    }

  arg = history_arg_extract (count, count, entry->line);
  if (!arg || !*arg)
    {
      rl_ding ();
      FREE (arg);
      return -1;
    }

  rl_begin_undo_group ();

  _rl_set_mark_at_pos (rl_point);

#if defined (VI_MODE)
  /* Vi mode always inserts a space before yanking the argument, and it
     inserts it right *after* rl_point. */
  if (rl_editing_mode == vi_mode)
    {
      rl_vi_append_mode (1, ignore);
      rl_insert_text (" ");
    }
#endif /* VI_MODE */

  rl_insert_text (arg);
  xfree (arg);

  rl_end_undo_group ();
  return 0;
}
warning: parse error {
  register HIST_ENTRY *entry;
  char *arg;
  int i, pos;

  pos = where_history ();

  if (history_skip)
    {
      for (i = 0; i < history_skip; i++)
	entry = previous_history ();
    }

  entry = previous_history ();

  history_set_pos (pos);

  if (entry == 0)
    {
      rl_ding ();
      return -1;
    }

  arg = history_arg_extract (count, count, entry->line);
  if (!arg || !*arg)
    {
      rl_ding ();
      FREE (arg);
      return -1;
    }

  rl_begin_undo_group ();

  _rl_set_mark_at_pos (rl_point);

#if defined (VI_MODE)
  /* Vi mode always inserts a space before yanking the argument, and it
     inserts it right *after* rl_point. */
  if (rl_editing_mode == vi_mode)
    {
      rl_vi_append_mode (1, ignore);
      rl_insert_text (" ");
    }
#endif /* VI_MODE */

  rl_insert_text (arg);
  xfree (arg);

  rl_end_undo_group ();
  return 0;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\kill.c:558
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\kill.c:612
parsing error 
{
  return (rl_yank_nth_arg_internal (count, ignore, 0));
}
warning: parse error {
  return (rl_yank_nth_arg_internal (count, ignore, 0));
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\kill.c:614
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\kill.c:622
parsing error 
{
  static int history_skip = 0;
  static int explicit_arg_p = 0;
  static int count_passed = 1;
  static int direction = 1;
  static int undo_needed = 0;
  int retval;

  if (rl_last_func != rl_yank_last_arg)
    {
      history_skip = 0;
      explicit_arg_p = rl_explicit_arg;
      count_passed = count;
      direction = 1;
    }
  else
    {
      if (undo_needed)
	rl_do_undo ();
      if (count < 0)		/* XXX - was < 1 */
        direction = -direction;
      history_skip += direction;
      if (history_skip < 0)
	history_skip = 0;
    }
 
  if (explicit_arg_p)
    retval = rl_yank_nth_arg_internal (count_passed, key, history_skip);
  else
    retval = rl_yank_nth_arg_internal ('$', key, history_skip);

  undo_needed = retval == 0;
  return retval;
}
warning: parse error {
  static int history_skip = 0;
  static int explicit_arg_p = 0;
  static int count_passed = 1;
  static int direction = 1;
  static int undo_needed = 0;
  int retval;

  if (rl_last_func != rl_yank_last_arg)
    {
      history_skip = 0;
      explicit_arg_p = rl_explicit_arg;
      count_passed = count;
      direction = 1;
    }
  else
    {
      if (undo_needed)
	rl_do_undo ();
      if (count < 0)		/* XXX - was < 1 */
        direction = -direction;
      history_skip += direction;
      if (history_skip < 0)
	history_skip = 0;
    }
 
  if (explicit_arg_p)
    retval = rl_yank_nth_arg_internal (count_passed, key, history_skip);
  else
    retval = rl_yank_nth_arg_internal ('$', key, history_skip);

  undo_needed = retval == 0;
  return retval;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\kill.c:624
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\macro.c...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\rldefs.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\history.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\rlprivate.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\xmalloc.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\macro.c:89
parsing error 
{
  _rl_push_executing_macro ();
  rl_executing_macro = string;
  executing_macro_index = 0;
  RL_SETSTATE(RL_STATE_MACROINPUT);
}
warning: parse error {
  _rl_push_executing_macro ();
  rl_executing_macro = string;
  executing_macro_index = 0;
  RL_SETSTATE(RL_STATE_MACROINPUT);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\macro.c:91
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\macro.c:164
parsing error 
{
  if (current_macro_index + 1 >= current_macro_size)
    {
      if (current_macro == 0)
	current_macro = (char *)xmalloc (current_macro_size = 25);
      else
	current_macro = (char *)xrealloc (current_macro, current_macro_size += 25);
    }

  current_macro[current_macro_index++] = c;
  current_macro[current_macro_index] = '\0';
}
warning: parse error {
  if (current_macro_index + 1 >= current_macro_size)
    {
      if (current_macro == 0)
	current_macro = (char *)xmalloc (current_macro_size = 25);
      else
	current_macro = (char *)xrealloc (current_macro, current_macro_size += 25);
    }

  current_macro[current_macro_index++] = c;
  current_macro[current_macro_index] = '\0';
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\macro.c:166
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\macro.c:203
parsing error 
{
  if (RL_ISSTATE (RL_STATE_MACRODEF))
    {
      _rl_abort_internal ();
      return -1;
    }

  if (rl_explicit_arg)
    {
      if (current_macro)
	_rl_with_macro_input (savestring (current_macro));
    }
  else
    current_macro_index = 0;

  RL_SETSTATE(RL_STATE_MACRODEF);
  return 0;
}
warning: parse error {
  if (RL_ISSTATE (RL_STATE_MACRODEF))
    {
      _rl_abort_internal ();
      return -1;
    }

  if (rl_explicit_arg)
    {
      if (current_macro)
	_rl_with_macro_input (savestring (current_macro));
    }
  else
    current_macro_index = 0;

  RL_SETSTATE(RL_STATE_MACRODEF);
  return 0;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\macro.c:205
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\macro.c:228
parsing error 
{
  if (RL_ISSTATE (RL_STATE_MACRODEF) == 0)
    {
      _rl_abort_internal ();
      return -1;
    }

  current_macro_index -= rl_key_sequence_length - 1;
  current_macro[current_macro_index] = '\0';

  RL_UNSETSTATE(RL_STATE_MACRODEF);

  return (rl_call_last_kbd_macro (--count, 0));
}
warning: parse error {
  if (RL_ISSTATE (RL_STATE_MACRODEF) == 0)
    {
      _rl_abort_internal ();
      return -1;
    }

  current_macro_index -= rl_key_sequence_length - 1;
  current_macro[current_macro_index] = '\0';

  RL_UNSETSTATE(RL_STATE_MACRODEF);

  return (rl_call_last_kbd_macro (--count, 0));
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\macro.c:230
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\macro.c:248
parsing error 
{
  if (current_macro == 0)
    _rl_abort_internal ();

  if (RL_ISSTATE (RL_STATE_MACRODEF))
    {
      rl_ding ();		/* no recursive macros */
      current_macro[--current_macro_index] = '\0';	/* erase this char */
      return 0;
    }

  while (count--)
    _rl_with_macro_input (savestring (current_macro));
  return 0;
}
warning: parse error {
  if (current_macro == 0)
    _rl_abort_internal ();

  if (RL_ISSTATE (RL_STATE_MACRODEF))
    {
      rl_ding ();		/* no recursive macros */
      current_macro[--current_macro_index] = '\0';	/* erase this char */
      return 0;
    }

  while (count--)
    _rl_with_macro_input (savestring (current_macro));
  return 0;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\macro.c:250
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\macro.c:267
parsing error 
{
  _rl_with_macro_input (macro);
}
warning: parse error {
  _rl_with_macro_input (macro);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\macro.c:269
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\mbutil.c...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\posixjmp.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\rldefs.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\rlmbutil.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\rlprivate.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\xmalloc.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\mbutil.c:76
parsing error 
{
  size_t tmp, len;
  mbstate_t ps;
  int point;
  wchar_t wc;

  tmp = 0;

  memset(&ps, 0, sizeof (mbstate_t));
  if (seed < 0)
    seed = 0;
  if (count <= 0)
    return seed;

  point = seed + _rl_adjust_point (string, seed, &ps);
  /* if this is true, means that seed was not pointing to a byte indicating
     the beginning of a multibyte character.  Correct the point and consume
     one char. */
  if (seed < point)
    count--;

  while (count > 0)  
    {
      len = strlen (string + point);
      if (len == 0)
	break;
      tmp = mbrtowc (&wc, string+point, len, &ps);
      if (MB_INVALIDCH ((size_t)tmp))
	{
	  /* invalid bytes. assume a byte represents a character */
	  point++;
	  count--;
	  /* reset states. */
	  memset(&ps, 0, sizeof(mbstate_t));
	}
      else if (MB_NULLWCH (tmp))
	break;			/* found wide '\0' */
      else
	{
	  /* valid bytes */
	  point += tmp;
	  if (find_non_zero)
	    {
	      if (wcwidth (wc) == 0)
		continue;
	      else
		count--;
	    }
	  else
	    count--;
	}
    }

  if (find_non_zero)
    {
      tmp = mbrtowc (&wc, string + point, strlen (string + point), &ps);
      while (MB_NULLWCH (tmp) == 0 && MB_INVALIDCH (tmp) == 0 && wcwidth (wc) == 0)
	{
	  point += tmp;
	  tmp = mbrtowc (&wc, string + point, strlen (string + point), &ps);
	}
    }

  return point;
}
warning: parse error {
  size_t tmp, len;
  mbstate_t ps;
  int point;
  wchar_t wc;

  tmp = 0;

  memset(&ps, 0, sizeof (mbstate_t));
  if (seed < 0)
    seed = 0;
  if (count <= 0)
    return seed;

  point = seed + _rl_adjust_point (string, seed, &ps);
  /* if this is true, means that seed was not pointing to a byte indicating
     the beginning of a multibyte character.  Correct the point and consume
     one char. */
  if (seed < point)
    count--;

  while (count > 0)  
    {
      len = strlen (string + point);
      if (len == 0)
	break;
      tmp = mbrtowc (&wc, string+point, len, &ps);
      if (MB_INVALIDCH ((size_t)tmp))
	{
	  /* invalid bytes. assume a byte represents a character */
	  point++;
	  count--;
	  /* reset states. */
	  memset(&ps, 0, sizeof(mbstate_t));
	}
      else if (MB_NULLWCH (tmp))
	break;			/* found wide '\0' */
      else
	{
	  /* valid bytes */
	  point += tmp;
	  if (find_non_zero)
	    {
	      if (wcwidth (wc) == 0)
		continue;
	      else
		count--;
	    }
	  else
	    count--;
	}
    }

  if (find_non_zero)
    {
      tmp = mbrtowc (&wc, string + point, strlen (string + point), &ps);
      while (MB_NULLWCH (tmp) == 0 && MB_INVALIDCH (tmp) == 0 && wcwidth (wc) == 0)
	{
	  point += tmp;
	  tmp = mbrtowc (&wc, string + point, strlen (string + point), &ps);
	}
    }

  return point;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\mbutil.c:79
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\mbutil.c:146
parsing error 
{
  mbstate_t ps;
  int prev, non_zero_prev, point, length;
  size_t tmp;
  wchar_t wc;

  memset(&ps, 0, sizeof(mbstate_t));
  length = strlen(string);
  
  if (seed < 0)
    return 0;
  else if (length < seed)
    return length;

  prev = non_zero_prev = point = 0;
  while (point < seed)
    {
      tmp = mbrtowc (&wc, string + point, length - point, &ps);
      if (MB_INVALIDCH ((size_t)tmp))
	{
	  /* in this case, bytes are invalid or shorted to compose
	     multibyte char, so assume that the first byte represents
	     a single character anyway. */
	  tmp = 1;
	  /* clear the state of the byte sequence, because
	     in this case effect of mbstate is undefined  */
	  memset(&ps, 0, sizeof (mbstate_t));

	  /* Since we're assuming that this byte represents a single
	     non-zero-width character, don't forget about it. */
	  prev = point;
	}
      else if (MB_NULLWCH (tmp))
	break;			/* Found '\0' char.  Can this happen? */
      else
	{
	  if (find_non_zero)
	    {
	      if (wcwidth (wc) != 0)
		prev = point;
	    }
	  else
	    prev = point;  
	}

      point += tmp;
    }

  return prev;
}
warning: parse error {
  mbstate_t ps;
  int prev, non_zero_prev, point, length;
  size_t tmp;
  wchar_t wc;

  memset(&ps, 0, sizeof(mbstate_t));
  length = strlen(string);
  
  if (seed < 0)
    return 0;
  else if (length < seed)
    return length;

  prev = non_zero_prev = point = 0;
  while (point < seed)
    {
      tmp = mbrtowc (&wc, string + point, length - point, &ps);
      if (MB_INVALIDCH ((size_t)tmp))
	{
	  /* in this case, bytes are invalid or shorted to compose
	     multibyte char, so assume that the first byte represents
	     a single character anyway. */
	  tmp = 1;
	  /* clear the state of the byte sequence, because
	     in this case effect of mbstate is undefined  */
	  memset(&ps, 0, sizeof (mbstate_t));

	  /* Since we're assuming that this byte represents a single
	     non-zero-width character, don't forget about it. */
	  prev = point;
	}
      else if (MB_NULLWCH (tmp))
	break;			/* Found '\0' char.  Can this happen? */
      else
	{
	  if (find_non_zero)
	    {
	      if (wcwidth (wc) != 0)
		prev = point;
	    }
	  else
	    prev = point;  
	}

      point += tmp;
    }

  return prev;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\mbutil.c:149
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\mbutil.c:206
parsing error 
{
  size_t tmp;

  tmp = mbrlen((const char *)src, (size_t)strlen (src), ps);
  if (tmp == (size_t)(-2))
    {
      /* shorted to compose multibyte char */
      if (ps)
	memset (ps, 0, sizeof(mbstate_t));
      return -2;
    }
  else if (tmp == (size_t)(-1))
    {
      /* invalid to compose multibyte char */
      /* initialize the conversion state */
      if (ps)
	memset (ps, 0, sizeof(mbstate_t));
      return -1;
    }
  else if (tmp == (size_t)0)
    return 0;
  else
    return (int)tmp;
}
warning: parse error {
  size_t tmp;

  tmp = mbrlen((const char *)src, (size_t)strlen (src), ps);
  if (tmp == (size_t)(-2))
    {
      /* shorted to compose multibyte char */
      if (ps)
	memset (ps, 0, sizeof(mbstate_t));
      return -2;
    }
  else if (tmp == (size_t)(-1))
    {
      /* invalid to compose multibyte char */
      /* initialize the conversion state */
      if (ps)
	memset (ps, 0, sizeof(mbstate_t));
      return -1;
    }
  else if (tmp == (size_t)0)
    return 0;
  else
    return (int)tmp;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\mbutil.c:209
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\mbutil.c:237
parsing error 
{
  int i, w1, w2;

  if ((w1 = _rl_get_char_len (&buf1[pos1], ps1)) <= 0 || 
	(w2 = _rl_get_char_len (&buf2[pos2], ps2)) <= 0 ||
	(w1 != w2) ||
	(buf1[pos1] != buf2[pos2]))
    return 0;

  for (i = 1; i < w1; i++)
    if (buf1[pos1+i] != buf2[pos2+i])
      return 0;

  return 1;
}
warning: parse error {
  int i, w1, w2;

  if ((w1 = _rl_get_char_len (&buf1[pos1], ps1)) <= 0 || 
	(w2 = _rl_get_char_len (&buf2[pos2], ps2)) <= 0 ||
	(w1 != w2) ||
	(buf1[pos1] != buf2[pos2]))
    return 0;

  for (i = 1; i < w1; i++)
    if (buf1[pos1+i] != buf2[pos2+i])
      return 0;

  return 1;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\mbutil.c:244
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\mbutil.c:266
parsing error 
{
  size_t tmp = 0;
  int length;
  int pos = 0;

  length = strlen(string);
  if (point < 0)
    return -1;
  if (length < point)
    return -1;
  
  while (pos < point)
    {
      tmp = mbrlen (string + pos, length - pos, ps);
      if (MB_INVALIDCH ((size_t)tmp))
	{
	  /* in this case, bytes are invalid or shorted to compose
	     multibyte char, so assume that the first byte represents
	     a single character anyway. */
	  pos++;
	  /* clear the state of the byte sequence, because
	     in this case effect of mbstate is undefined  */
	  if (ps)
	    memset (ps, 0, sizeof (mbstate_t));
	}
      else if (MB_NULLWCH (tmp))
	pos++;
      else
	pos += tmp;
    }

  return (pos - point);
}
warning: parse error {
  size_t tmp = 0;
  int length;
  int pos = 0;

  length = strlen(string);
  if (point < 0)
    return -1;
  if (length < point)
    return -1;
  
  while (pos < point)
    {
      tmp = mbrlen (string + pos, length - pos, ps);
      if (MB_INVALIDCH ((size_t)tmp))
	{
	  /* in this case, bytes are invalid or shorted to compose
	     multibyte char, so assume that the first byte represents
	     a single character anyway. */
	  pos++;
	  /* clear the state of the byte sequence, because
	     in this case effect of mbstate is undefined  */
	  if (ps)
	    memset (ps, 0, sizeof (mbstate_t));
	}
      else if (MB_NULLWCH (tmp))
	pos++;
      else
	pos += tmp;
    }

  return (pos - point);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\mbutil.c:270
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\mbutil.c:305
parsing error 
{
  int i;

  if ((end - seed) < length)
    return 0;

  for (i = 0; i < length; i++)
    if (string[seed + i] != mbchar[i])
      return 0;
  return 1;
}
warning: parse error {
  int i;

  if ((end - seed) < length)
    return 0;

  for (i = 0; i < length; i++)
    if (string[seed + i] != mbchar[i])
      return 0;
  return 1;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\mbutil.c:310
parsing error 
_rl_char_value (buf, ind)
warning: parse error _rl_char_value (buf, ind)Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\mbutil.c:323
parsing error 
{
  size_t tmp;
  wchar_t wc;
  mbstate_t ps;
  int l;

  if (MB_LEN_MAX == 1 || rl_byte_oriented)
    return ((wchar_t) buf[ind]);
  l = strlen (buf);
  if (ind >= l - 1)
    return ((wchar_t) buf[ind]);
  memset (&ps, 0, sizeof (mbstate_t));
  tmp = mbrtowc (&wc, buf + ind, l - ind, &ps);
  if (MB_INVALIDCH (tmp) || MB_NULLWCH (tmp))  
    return ((wchar_t) buf[ind]);
  return wc;
}
warning: parse error {
  size_t tmp;
  wchar_t wc;
  mbstate_t ps;
  int l;

  if (MB_LEN_MAX == 1 || rl_byte_oriented)
    return ((wchar_t) buf[ind]);
  l = strlen (buf);
  if (ind >= l - 1)
    return ((wchar_t) buf[ind]);
  memset (&ps, 0, sizeof (mbstate_t));
  tmp = mbrtowc (&wc, buf + ind, l - ind, &ps);
  if (MB_INVALIDCH (tmp) || MB_NULLWCH (tmp))  
    return ((wchar_t) buf[ind]);
  return wc;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\mbutil.c:326
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\mbutil.c:350
parsing error 
{
#if defined (HANDLE_MULTIBYTE)
  return _rl_find_next_mbchar_internal (string, seed, count, flags);
#else
  return (seed + count);
#endif
}
warning: parse error {
#if defined (HANDLE_MULTIBYTE)
  return _rl_find_next_mbchar_internal (string, seed, count, flags);
#else
  return (seed + count);
#endif
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\mbutil.c:353
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\mbutil.c:366
parsing error 
{
#if defined (HANDLE_MULTIBYTE)
  return _rl_find_prev_mbchar_internal (string, seed, flags);
#else
  return ((seed == 0) ? seed : seed - 1);
#endif
}
warning: parse error {
#if defined (HANDLE_MULTIBYTE)
  return _rl_find_prev_mbchar_internal (string, seed, flags);
#else
  return ((seed == 0) ? seed : seed - 1);
#endif
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\mbutil.c:369
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\misc.c...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\rldefs.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\rlmbutil.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\history.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\rlprivate.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\rlshell.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\xmalloc.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\misc.c:119
parsing error 
{
  int key, r;

  key = c;

  /* If we see a key bound to `universal-argument' after seeing digits,
      it ends the argument but is otherwise ignored. */
  if (_rl_keymap[c].type == ISFUNC && _rl_keymap[c].function == rl_universal_argument)
    {
      if ((cxt & NUM_SAWDIGITS) == 0)
	{
	  rl_numeric_arg *= 4;
	  return 1;
	}
      else if (RL_ISSTATE (RL_STATE_CALLBACK))
        {
          _rl_argcxt |= NUM_READONE;
          return 0;	/* XXX */
        }
      else
	{
	  RL_SETSTATE(RL_STATE_MOREINPUT);
	  key = rl_read_key ();
	  RL_UNSETSTATE(RL_STATE_MOREINPUT);
	  rl_restore_prompt ();
	  rl_clear_message ();
	  RL_UNSETSTATE(RL_STATE_NUMERICARG);
	  if (key < 0)
	    return -1;
	  return (_rl_dispatch (key, _rl_keymap));
	}
    }

  c = UNMETA (c);

  if (_rl_digit_p (c))
    {
      r = _rl_digit_value (c);    	
      rl_numeric_arg = rl_explicit_arg ? (rl_numeric_arg * 10) +  r : r;
      rl_explicit_arg = 1;
      _rl_argcxt |= NUM_SAWDIGITS;
    }
  else if (c == '-' && rl_explicit_arg == 0)
    {
      rl_numeric_arg = 1;
      _rl_argcxt |= NUM_SAWMINUS;
      rl_arg_sign = -1;
    }
  else
    {
      /* Make M-- command equivalent to M--1 command. */
      if ((_rl_argcxt & NUM_SAWMINUS) && rl_numeric_arg == 1 && rl_explicit_arg == 0)
	rl_explicit_arg = 1;
      rl_restore_prompt ();
      rl_clear_message ();
      RL_UNSETSTATE(RL_STATE_NUMERICARG);

      r = _rl_dispatch (key, _rl_keymap);
      if (RL_ISSTATE (RL_STATE_CALLBACK))
	{
	  /* At worst, this will cause an extra redisplay.  Otherwise,
	     we have to wait until the next character comes in. */
	  if (rl_done == 0)
	    (*rl_redisplay_function) ();
	  r = 0;
	}
      return r;
    }

  return 1;
}
warning: parse error {
  int key, r;

  key = c;

  /* If we see a key bound to `universal-argument' after seeing digits,
      it ends the argument but is otherwise ignored. */
  if (_rl_keymap[c].type == ISFUNC && _rl_keymap[c].function == rl_universal_argument)
    {
      if ((cxt & NUM_SAWDIGITS) == 0)
	{
	  rl_numeric_arg *= 4;
	  return 1;
	}
      else if (RL_ISSTATE (RL_STATE_CALLBACK))
        {
          _rl_argcxt |= NUM_READONE;
          return 0;	/* XXX */
        }
      else
	{
	  RL_SETSTATE(RL_STATE_MOREINPUT);
	  key = rl_read_key ();
	  RL_UNSETSTATE(RL_STATE_MOREINPUT);
	  rl_restore_prompt ();
	  rl_clear_message ();
	  RL_UNSETSTATE(RL_STATE_NUMERICARG);
	  if (key < 0)
	    return -1;
	  return (_rl_dispatch (key, _rl_keymap));
	}
    }

  c = UNMETA (c);

  if (_rl_digit_p (c))
    {
      r = _rl_digit_value (c);    	
      rl_numeric_arg = rl_explicit_arg ? (rl_numeric_arg * 10) +  r : r;
      rl_explicit_arg = 1;
      _rl_argcxt |= NUM_SAWDIGITS;
    }
  else if (c == '-' && rl_explicit_arg == 0)
    {
      rl_numeric_arg = 1;
      _rl_argcxt |= NUM_SAWMINUS;
      rl_arg_sign = -1;
    }
  else
    {
      /* Make M-- command equivalent to M--1 command. */
      if ((_rl_argcxt & NUM_SAWMINUS) && rl_numeric_arg == 1 && rl_explicit_arg == 0)
	rl_explicit_arg = 1;
      rl_restore_prompt ();
      rl_clear_message ();
      RL_UNSETSTATE(RL_STATE_NUMERICARG);

      r = _rl_dispatch (key, _rl_keymap);
      if (RL_ISSTATE (RL_STATE_CALLBACK))
	{
	  /* At worst, this will cause an extra redisplay.  Otherwise,
	     we have to wait until the next character comes in. */
	  if (rl_done == 0)
	    (*rl_redisplay_function) ();
	  r = 0;
	}
      return r;
    }

  return 1;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\misc.c:122
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\misc.c:232
parsing error 
{
  _rl_arg_init ();
  if (RL_ISSTATE (RL_STATE_CALLBACK))
    {
      _rl_arg_dispatch (_rl_argcxt, key);
      rl_message ("(arg: %d) ", rl_arg_sign * rl_numeric_arg);
      return 0;
    }
  else
    {
      rl_execute_next (key);
      return (rl_digit_loop ());
    }
}
warning: parse error {
  _rl_arg_init ();
  if (RL_ISSTATE (RL_STATE_CALLBACK))
    {
      _rl_arg_dispatch (_rl_argcxt, key);
      rl_message ("(arg: %d) ", rl_arg_sign * rl_numeric_arg);
      return 0;
    }
  else
    {
      rl_execute_next (key);
      return (rl_digit_loop ());
    }
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\misc.c:234
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\misc.c:253
parsing error 
{
  _rl_arg_init ();
  rl_numeric_arg *= 4;

  return (RL_ISSTATE (RL_STATE_CALLBACK) ? 0 : rl_digit_loop ());
}
warning: parse error {
  _rl_arg_init ();
  rl_numeric_arg *= 4;

  return (RL_ISSTATE (RL_STATE_CALLBACK) ? 0 : rl_digit_loop ());
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\misc.c:255
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\misc.c:263
parsing error 
{
  int c, r;

  c = _rl_arg_getchar ();

  if (_rl_argcxt & NUM_READONE)
    {
      _rl_argcxt &= ~NUM_READONE;
      rl_restore_prompt ();
      rl_clear_message ();
      RL_UNSETSTATE(RL_STATE_NUMERICARG);
      rl_execute_next (c);
      return 0;
    }

  r = _rl_arg_dispatch (cxt, c);
  return (r != 1);
}
warning: parse error {
  int c, r;

  c = _rl_arg_getchar ();

  if (_rl_argcxt & NUM_READONE)
    {
      _rl_argcxt &= ~NUM_READONE;
      rl_restore_prompt ();
      rl_clear_message ();
      RL_UNSETSTATE(RL_STATE_NUMERICARG);
      rl_execute_next (c);
      return 0;
    }

  r = _rl_arg_dispatch (cxt, c);
  return (r != 1);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\misc.c:265
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\misc.c:322
parsing error 
{
  if (entry == 0)
    return;

  FREE (entry->line);
  FREE (entry->timestamp);

  xfree (entry);
}
warning: parse error {
  if (entry == 0)
    return;

  FREE (entry->line);
  FREE (entry->timestamp);

  xfree (entry);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\misc.c:324
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\misc.c:416
parsing error 
{
  /* Can't call with `1' because rl_undo_list might point to an undo list
     from a history entry, just like we're setting up here. */
  rl_replace_line (entry->line, 0);
  rl_undo_list = (UNDO_LIST *)entry->data;
  rl_point = rl_end;
  rl_mark = 0;

#if defined (VI_MODE)
  if (rl_editing_mode == vi_mode)
    {
      rl_point = 0;
      rl_mark = rl_end;
    }
#endif
}
warning: parse error {
  /* Can't call with `1' because rl_undo_list might point to an undo list
     from a history entry, just like we're setting up here. */
  rl_replace_line (entry->line, 0);
  rl_undo_list = (UNDO_LIST *)entry->data;
  rl_point = rl_end;
  rl_mark = 0;

#if defined (VI_MODE)
  if (rl_editing_mode == vi_mode)
    {
      rl_point = 0;
      rl_mark = rl_end;
    }
#endif
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\misc.c:419
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\misc.c:494
parsing error 
{
  return (rl_get_previous_history (1 + where_history (), key));
}
warning: parse error {
  return (rl_get_previous_history (1 + where_history (), key));
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\misc.c:496
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\misc.c:502
parsing error 
{
  rl_maybe_replace_line ();
  using_history ();
  rl_maybe_unsave_line ();
  return 0;
}
warning: parse error {
  rl_maybe_replace_line ();
  using_history ();
  rl_maybe_unsave_line ();
  return 0;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\misc.c:504
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\misc.c:513
parsing error 
{
  HIST_ENTRY *temp;

  if (count < 0)
    return (rl_get_previous_history (-count, key));

  if (count == 0)
    return 0;

  rl_maybe_replace_line ();

  /* either not saved by rl_newline or at end of line, so set appropriately. */
  if (_rl_history_saved_point == -1 && (rl_point || rl_end))
    _rl_history_saved_point = (rl_point == rl_end) ? -1 : rl_point;

  temp = (HIST_ENTRY *)NULL;
  while (count)
    {
      temp = next_history ();
      if (!temp)
	break;
      --count;
    }

  if (temp == 0)
    rl_maybe_unsave_line ();
  else
    {
      rl_replace_from_history (temp, 0);
      _rl_history_set_point ();
    }
  return 0;
}
warning: parse error {
  HIST_ENTRY *temp;

  if (count < 0)
    return (rl_get_previous_history (-count, key));

  if (count == 0)
    return 0;

  rl_maybe_replace_line ();

  /* either not saved by rl_newline or at end of line, so set appropriately. */
  if (_rl_history_saved_point == -1 && (rl_point || rl_end))
    _rl_history_saved_point = (rl_point == rl_end) ? -1 : rl_point;

  temp = (HIST_ENTRY *)NULL;
  while (count)
    {
      temp = next_history ();
      if (!temp)
	break;
      --count;
    }

  if (temp == 0)
    rl_maybe_unsave_line ();
  else
    {
      rl_replace_from_history (temp, 0);
      _rl_history_set_point ();
    }
  return 0;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\misc.c:515
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\misc.c:552
parsing error 
{
  HIST_ENTRY *old_temp, *temp;

  if (count < 0)
    return (rl_get_next_history (-count, key));

  if (count == 0)
    return 0;

  /* either not saved by rl_newline or at end of line, so set appropriately. */
  if (_rl_history_saved_point == -1 && (rl_point || rl_end))
    _rl_history_saved_point = (rl_point == rl_end) ? -1 : rl_point;

  /* If we don't have a line saved, then save this one. */
  rl_maybe_save_line ();

  /* If the current line has changed, save the changes. */
  rl_maybe_replace_line ();

  temp = old_temp = (HIST_ENTRY *)NULL;
  while (count)
    {
      temp = previous_history ();
      if (temp == 0)
	break;

      old_temp = temp;
      --count;
    }

  /* If there was a large argument, and we moved back to the start of the
     history, that is not an error.  So use the last value found. */
  if (!temp && old_temp)
    temp = old_temp;

  if (temp == 0)
    rl_ding ();
  else
    {
      rl_replace_from_history (temp, 0);
      _rl_history_set_point ();
    }

  return 0;
}
warning: parse error {
  HIST_ENTRY *old_temp, *temp;

  if (count < 0)
    return (rl_get_next_history (-count, key));

  if (count == 0)
    return 0;

  /* either not saved by rl_newline or at end of line, so set appropriately. */
  if (_rl_history_saved_point == -1 && (rl_point || rl_end))
    _rl_history_saved_point = (rl_point == rl_end) ? -1 : rl_point;

  /* If we don't have a line saved, then save this one. */
  rl_maybe_save_line ();

  /* If the current line has changed, save the changes. */
  rl_maybe_replace_line ();

  temp = old_temp = (HIST_ENTRY *)NULL;
  while (count)
    {
      temp = previous_history ();
      if (temp == 0)
	break;

      old_temp = temp;
      --count;
    }

  /* If there was a large argument, and we moved back to the start of the
     history, that is not an error.  So use the last value found. */
  if (!temp && old_temp)
    temp = old_temp;

  if (temp == 0)
    rl_ding ();
  else
    {
      rl_replace_from_history (temp, 0);
      _rl_history_set_point ();
    }

  return 0;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\misc.c:554
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\misc.c:607
parsing error 
{
#if defined (VI_MODE)
  _rl_set_insert_mode (RL_IM_INSERT, 1);	/* vi mode ignores insert mode */
  rl_editing_mode = vi_mode;
  rl_vi_insert_mode (1, key);
#endif /* VI_MODE */

  return 0;
}
warning: parse error {
#if defined (VI_MODE)
  _rl_set_insert_mode (RL_IM_INSERT, 1);	/* vi mode ignores insert mode */
  rl_editing_mode = vi_mode;
  rl_vi_insert_mode (1, key);
#endif /* VI_MODE */

  return 0;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\misc.c:609
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\misc.c:620
parsing error 
{
  rl_editing_mode = emacs_mode;
  _rl_set_insert_mode (RL_IM_INSERT, 1); /* emacs mode default is insert mode */
  _rl_keymap = emacs_standard_keymap;
  return 0;
}
warning: parse error {
  rl_editing_mode = emacs_mode;
  _rl_set_insert_mode (RL_IM_INSERT, 1); /* emacs mode default is insert mode */
  _rl_keymap = emacs_standard_keymap;
  return 0;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\misc.c:622
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\misc.c:631
parsing error 
{
#ifdef CURSOR_MODE
  _rl_set_cursor (im, force);
#endif

  rl_insert_mode = im;
}
warning: parse error {
#ifdef CURSOR_MODE
  _rl_set_cursor (im, force);
#endif

  rl_insert_mode = im;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\misc.c:633
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\misc.c:644
parsing error 
{
  if (rl_explicit_arg == 0)
    _rl_set_insert_mode (rl_insert_mode ^ 1, 0);
  else if (count > 0)
    _rl_set_insert_mode (RL_IM_OVERWRITE, 0);
  else
    _rl_set_insert_mode (RL_IM_INSERT, 0);

  return 0;
}
warning: parse error {
  if (rl_explicit_arg == 0)
    _rl_set_insert_mode (rl_insert_mode ^ 1, 0);
  else if (count > 0)
    _rl_set_insert_mode (RL_IM_OVERWRITE, 0);
  else
    _rl_set_insert_mode (RL_IM_INSERT, 0);

  return 0;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\misc.c:646
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\nls.c...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\rldefs.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\rlshell.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\rlprivate.h...skip
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\nls.c:82
parsing error 
{
  char *lspec;

  lspec = sh_get_env_value ("LC_ALL");
  if (lspec == 0 || *lspec == 0)
    lspec = sh_get_env_value (v);
  if (lspec == 0 || *lspec == 0)
    lspec = sh_get_env_value ("LANG");

  return lspec;
}
warning: parse error {
  char *lspec;

  lspec = sh_get_env_value ("LC_ALL");
  if (lspec == 0 || *lspec == 0)
    lspec = sh_get_env_value (v);
  if (lspec == 0 || *lspec == 0)
    lspec = sh_get_env_value ("LANG");

  return lspec;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\nls.c:83
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\nls.c:156
parsing error 
{
  size_t namelen, i;
  int len, all_digits;
  char *wp, *retval;

  codeset = find_codeset (codeset, &namelen);

  if (codeset == 0)
    return (codeset);

  all_digits = 1;
  for (len = 0, i = 0; i < namelen; i++)
    {
      if (ISALNUM ((unsigned char)codeset[i]))
	{
	  len++;
	  all_digits &= _rl_digit_p (codeset[i]);
	}
    }

  retval = (char *)malloc ((all_digits ? 3 : 0) + len + 1);
  if (retval == 0)
    return ((char *)0);

  wp = retval;
  /* Add `iso' to beginning of an all-digit codeset */
  if (all_digits)
    {
      *wp++ = 'i';
      *wp++ = 's';
      *wp++ = 'o';
    }

  for (i = 0; i < namelen; i++)
    if (ISALPHA ((unsigned char)codeset[i]))
      *wp++ = _rl_to_lower (codeset[i]);
    else if (_rl_digit_p (codeset[i]))
      *wp++ = codeset[i];
  *wp = '\0';

  return retval;
}
warning: parse error {
  size_t namelen, i;
  int len, all_digits;
  char *wp, *retval;

  codeset = find_codeset (codeset, &namelen);

  if (codeset == 0)
    return (codeset);

  all_digits = 1;
  for (len = 0, i = 0; i < namelen; i++)
    {
      if (ISALNUM ((unsigned char)codeset[i]))
	{
	  len++;
	  all_digits &= _rl_digit_p (codeset[i]);
	}
    }

  retval = (char *)malloc ((all_digits ? 3 : 0) + len + 1);
  if (retval == 0)
    return ((char *)0);

  wp = retval;
  /* Add `iso' to beginning of an all-digit codeset */
  if (all_digits)
    {
      *wp++ = 'i';
      *wp++ = 's';
      *wp++ = 'o';
    }

  for (i = 0; i < namelen; i++)
    if (ISALPHA ((unsigned char)codeset[i]))
      *wp++ = _rl_to_lower (codeset[i]);
    else if (_rl_digit_p (codeset[i]))
      *wp++ = codeset[i];
  *wp = '\0';

  return retval;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\nls.c:158
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\nls.c:203
parsing error 
{
  char *cp, *language, *result;

  cp = language = name;
  result = (char *)0;

  while (*cp && *cp != '_' && *cp != '@' && *cp != '+' && *cp != ',')
    cp++;

  /* This does not make sense: language has to be specified.  As
     an exception we allow the variable to contain only the codeset
     name.  Perhaps there are funny codeset names.  */
  if (language == cp) 
    {
      *lenp = strlen (language);
      result = language;
    }
  else
    {
      /* Next is the territory. */
      if (*cp == '_')
	do
	  ++cp;
	while (*cp && *cp != '.' && *cp != '@' && *cp != '+' && *cp != ',' && *cp != '_');

      /* Now, finally, is the codeset. */
      result = cp;
      if (*cp == '.')
	do
	  ++cp;
	while (*cp && *cp != '@');

      if (cp - result > 2)
	{
	  result++;
	  *lenp = cp - result;
	}
      else
	{
	  *lenp = strlen (language);
	  result = language;
	}
    }

  return result;
}
warning: parse error {
  char *cp, *language, *result;

  cp = language = name;
  result = (char *)0;

  while (*cp && *cp != '_' && *cp != '@' && *cp != '+' && *cp != ',')
    cp++;

  /* This does not make sense: language has to be specified.  As
     an exception we allow the variable to contain only the codeset
     name.  Perhaps there are funny codeset names.  */
  if (language == cp) 
    {
      *lenp = strlen (language);
      result = language;
    }
  else
    {
      /* Next is the territory. */
      if (*cp == '_')
	do
	  ++cp;
	while (*cp && *cp != '.' && *cp != '@' && *cp != '+' && *cp != ',' && *cp != '_');

      /* Now, finally, is the codeset. */
      result = cp;
      if (*cp == '.')
	do
	  ++cp;
	while (*cp && *cp != '@');

      if (cp - result > 2)
	{
	  result++;
	  *lenp = cp - result;
	}
      else
	{
	  *lenp = strlen (language);
	  result = language;
	}
    }

  return result;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\nls.c:206
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\parens.c...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\rlconf.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\posixselect.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\rlprivate.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\parens.c:71
parsing error 
{
  if (on_or_off)
    {	/* ([{ */
      rl_bind_key_in_map (')', rl_insert_close, emacs_standard_keymap);
      rl_bind_key_in_map (']', rl_insert_close, emacs_standard_keymap);
      rl_bind_key_in_map ('}', rl_insert_close, emacs_standard_keymap);
    }
  else
    {	/* ([{ */
      rl_bind_key_in_map (')', rl_insert, emacs_standard_keymap);
      rl_bind_key_in_map (']', rl_insert, emacs_standard_keymap);
      rl_bind_key_in_map ('}', rl_insert, emacs_standard_keymap);
    }
}
warning: parse error {
  if (on_or_off)
    {	/* ([{ */
      rl_bind_key_in_map (')', rl_insert_close, emacs_standard_keymap);
      rl_bind_key_in_map (']', rl_insert_close, emacs_standard_keymap);
      rl_bind_key_in_map ('}', rl_insert_close, emacs_standard_keymap);
    }
  else
    {	/* ([{ */
      rl_bind_key_in_map (')', rl_insert, emacs_standard_keymap);
      rl_bind_key_in_map (']', rl_insert, emacs_standard_keymap);
      rl_bind_key_in_map ('}', rl_insert, emacs_standard_keymap);
    }
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\parens.c:73
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\parens.c:89
parsing error 
{
  int o;

  o = _paren_blink_usec;
  if (u > 0)
    _paren_blink_usec = u;
  return (o);
}
warning: parse error {
  int o;

  o = _paren_blink_usec;
  if (u > 0)
    _paren_blink_usec = u;
  return (o);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\parens.c:91
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\parens.c:101
parsing error 
{
  if (rl_explicit_arg || !rl_blink_matching_paren)
    _rl_insert_char (count, invoking_key);
  else
    {
#if defined (HAVE_SELECT)
      int orig_point, match_point, ready;
      struct timeval timer;
      fd_set readfds;

      _rl_insert_char (1, invoking_key);
      (*rl_redisplay_function) ();
      match_point =
	find_matching_open (rl_line_buffer, rl_point - 2, invoking_key);

      /* Emacs might message or ring the bell here, but I don't. */
      if (match_point < 0)
	return -1;

      FD_ZERO (&readfds);
      FD_SET (fileno (rl_instream), &readfds);
      USEC_TO_TIMEVAL (_paren_blink_usec, timer);

      orig_point = rl_point;
      rl_point = match_point;
      (*rl_redisplay_function) ();
      ready = select (1, &readfds, (fd_set *)NULL, (fd_set *)NULL, &timer);
      rl_point = orig_point;
#else /* !HAVE_SELECT */
      _rl_insert_char (count, invoking_key);
#endif /* !HAVE_SELECT */
    }
  return 0;
}
warning: parse error {
  if (rl_explicit_arg || !rl_blink_matching_paren)
    _rl_insert_char (count, invoking_key);
  else
    {
#if defined (HAVE_SELECT)
      int orig_point, match_point, ready;
      struct timeval timer;
      fd_set readfds;

      _rl_insert_char (1, invoking_key);
      (*rl_redisplay_function) ();
      match_point =
	find_matching_open (rl_line_buffer, rl_point - 2, invoking_key);

      /* Emacs might message or ring the bell here, but I don't. */
      if (match_point < 0)
	return -1;

      FD_ZERO (&readfds);
      FD_SET (fileno (rl_instream), &readfds);
      USEC_TO_TIMEVAL (_paren_blink_usec, timer);

      orig_point = rl_point;
      rl_point = match_point;
      (*rl_redisplay_function) ();
      ready = select (1, &readfds, (fd_set *)NULL, (fd_set *)NULL, &timer);
      rl_point = orig_point;
#else /* !HAVE_SELECT */
      _rl_insert_char (count, invoking_key);
#endif /* !HAVE_SELECT */
    }
  return 0;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\parens.c:103
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\parens.c:139
parsing error 
{
  register int i;
  int opener, level, delimiter;

  switch (closer)
    {
    case ']': opener = '['; break;
    case '}': opener = '{'; break;
    case ')': opener = '('; break;
    default:
      return (-1);
    }

  level = 1;			/* The closer passed in counts as 1. */
  delimiter = 0;		/* Delimited state unknown. */

  for (i = from; i > -1; i--)
    {
      if (delimiter && (string[i] == delimiter))
	delimiter = 0;
      else if (rl_basic_quote_characters && strchr (rl_basic_quote_characters, string[i]))
	delimiter = string[i];
      else if (!delimiter && (string[i] == closer))
	level++;
      else if (!delimiter && (string[i] == opener))
	level--;

      if (!level)
	break;
    }
  return (i);
}
warning: parse error {
  register int i;
  int opener, level, delimiter;

  switch (closer)
    {
    case ']': opener = '['; break;
    case '}': opener = '{'; break;
    case ')': opener = '('; break;
    default:
      return (-1);
    }

  level = 1;			/* The closer passed in counts as 1. */
  delimiter = 0;		/* Delimited state unknown. */

  for (i = from; i > -1; i--)
    {
      if (delimiter && (string[i] == delimiter))
	delimiter = 0;
      else if (rl_basic_quote_characters && strchr (rl_basic_quote_characters, string[i]))
	delimiter = string[i];
      else if (!delimiter && (string[i] == closer))
	level++;
      else if (!delimiter && (string[i] == opener))
	level--;

      if (!level)
	break;
    }
  return (i);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\parens.c:142
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.c...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\posixstat.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\posixjmp.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\rldefs.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\rlmbutil.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\history.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\rlprivate.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\rlshell.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\xmalloc.h...skip
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.c:295
parsing error 
{
  FREE (rl_prompt);
  rl_prompt = prompt ? savestring (prompt) : (char *)NULL;
  rl_display_prompt = rl_prompt ? rl_prompt : "";

  rl_visible_prompt_length = rl_expand_prompt (rl_prompt);
  return 0;
}
warning: parse error {
  FREE (rl_prompt);
  rl_prompt = prompt ? savestring (prompt) : (char *)NULL;
  rl_display_prompt = rl_prompt ? rl_prompt : "";

  rl_visible_prompt_length = rl_expand_prompt (rl_prompt);
  return 0;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.c:296
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.c:309
parsing error 
{
  char *value;
#if 0
  int in_callback;
#endif

  /* If we are at EOF return a NULL string. */
  if (rl_pending_input == EOF)
    {
      rl_clear_pending_input ();
      return ((char *)NULL);
    }

#if 0
  /* If readline() is called after installing a callback handler, temporarily
     turn off the callback state to avoid ensuing messiness.  Patch supplied
     by the gdb folks.  XXX -- disabled.  This can be fooled and readline
     left in a strange state by a poorly-timed longjmp. */
  if (in_callback = RL_ISSTATE (RL_STATE_CALLBACK))
    RL_UNSETSTATE (RL_STATE_CALLBACK);
#endif

  rl_set_prompt (prompt);

  rl_initialize ();
  if (rl_prep_term_function)
    (*rl_prep_term_function) (_rl_meta_flag);

#if defined (HANDLE_SIGNALS)
  rl_set_signals ();
#endif

  value = readline_internal ();
  if (rl_deprep_term_function)
    (*rl_deprep_term_function) ();

#if defined (HANDLE_SIGNALS)
  rl_clear_signals ();
#endif

#if 0
  if (in_callback)
    RL_SETSTATE (RL_STATE_CALLBACK);
#endif

  return (value);
}
warning: parse error {
  char *value;
#if 0
  int in_callback;
#endif

  /* If we are at EOF return a NULL string. */
  if (rl_pending_input == EOF)
    {
      rl_clear_pending_input ();
      return ((char *)NULL);
    }

#if 0
  /* If readline() is called after installing a callback handler, temporarily
     turn off the callback state to avoid ensuing messiness.  Patch supplied
     by the gdb folks.  XXX -- disabled.  This can be fooled and readline
     left in a strange state by a poorly-timed longjmp. */
  if (in_callback = RL_ISSTATE (RL_STATE_CALLBACK))
    RL_UNSETSTATE (RL_STATE_CALLBACK);
#endif

  rl_set_prompt (prompt);

  rl_initialize ();
  if (rl_prep_term_function)
    (*rl_prep_term_function) (_rl_meta_flag);

#if defined (HANDLE_SIGNALS)
  rl_set_signals ();
#endif

  value = readline_internal ();
  if (rl_deprep_term_function)
    (*rl_deprep_term_function) ();

#if defined (HANDLE_SIGNALS)
  rl_clear_signals ();
#endif

#if 0
  if (in_callback)
    RL_SETSTATE (RL_STATE_CALLBACK);
#endif

  return (value);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.c:310
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.c:409
parsing error 
{
  char *temp;
  HIST_ENTRY *entry;

  RL_CHECK_SIGNALS ();

  /* Restore the original of this history line, iff the line that we
     are editing was originally in the history, AND the line has changed. */
  entry = current_history ();

  if (entry && rl_undo_list)
    {
      temp = savestring (the_line);
      rl_revert_line (1, 0);
      entry = replace_history_entry (where_history (), the_line, (histdata_t)NULL);
      _rl_free_history_entry (entry);

      strcpy (the_line, temp);
      xfree (temp);
    }

  if (_rl_revert_all_at_newline)
    _rl_revert_all_lines ();

  /* At any rate, it is highly likely that this line has an undo list.  Get
     rid of it now. */
  if (rl_undo_list)
    rl_free_undo_list ();

  /* Restore normal cursor, if available. */
  _rl_set_insert_mode (RL_IM_INSERT, 0);

  return (eof ? (char *)NULL : savestring (the_line));
}
warning: parse error {
  char *temp;
  HIST_ENTRY *entry;

  RL_CHECK_SIGNALS ();

  /* Restore the original of this history line, iff the line that we
     are editing was originally in the history, AND the line has changed. */
  entry = current_history ();

  if (entry && rl_undo_list)
    {
      temp = savestring (the_line);
      rl_revert_line (1, 0);
      entry = replace_history_entry (where_history (), the_line, (histdata_t)NULL);
      _rl_free_history_entry (entry);

      strcpy (the_line, temp);
      xfree (temp);
    }

  if (_rl_revert_all_at_newline)
    _rl_revert_all_lines ();

  /* At any rate, it is highly likely that this line has an undo list.  Get
     rid of it now. */
  if (rl_undo_list)
    rl_free_undo_list ();

  /* Restore normal cursor, if available. */
  _rl_set_insert_mode (RL_IM_INSERT, 0);

  return (eof ? (char *)NULL : savestring (the_line));
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.c:411
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.c:629
parsing error 
{
  xfree (cxt);
}
warning: parse error {
  xfree (cxt);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.c:631
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.c:650
parsing error 
{
  int k;

  if (key == ESC)
    RL_SETSTATE(RL_STATE_METANEXT);
  RL_SETSTATE(RL_STATE_MOREINPUT);
  k = rl_read_key ();
  RL_UNSETSTATE(RL_STATE_MOREINPUT);
  if (key == ESC)
    RL_UNSETSTATE(RL_STATE_METANEXT);

  return k;
}
warning: parse error {
  int k;

  if (key == ESC)
    RL_SETSTATE(RL_STATE_METANEXT);
  RL_SETSTATE(RL_STATE_MOREINPUT);
  k = rl_read_key ();
  RL_UNSETSTATE(RL_STATE_MOREINPUT);
  if (key == ESC)
    RL_UNSETSTATE(RL_STATE_METANEXT);

  return k;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.c:652
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.c:668
parsing error 
{
  int nkey, r;

  /* For now */
  /* The first time this context is used, we want to read input and dispatch
     on it.  When traversing the chain of contexts back `up', we want to use
     the value from the next context down.  We're simulating recursion using
     a chain of contexts. */
  if ((cxt->flags & KSEQ_DISPATCHED) == 0)
    {
      nkey = _rl_subseq_getchar (cxt->okey);
      if (nkey < 0)
	{
	  _rl_abort_internal ();
	  return -1;
	}
      r = _rl_dispatch_subseq (nkey, cxt->dmap, cxt->subseq_arg);
      cxt->flags |= KSEQ_DISPATCHED;
    }
  else
    r = cxt->childval;

  /* For now */
  if (r != -3)	/* don't do this if we indicate there will be other matches */
    r = _rl_subseq_result (r, cxt->oldmap, cxt->okey, (cxt->flags & KSEQ_SUBSEQ));

  RL_CHECK_SIGNALS ();
  if (r == 0)			/* success! */
    {
      _rl_keyseq_chain_dispose ();
      RL_UNSETSTATE (RL_STATE_MULTIKEY);
      return r;
    }

  if (r != -3)			/* magic value that says we added to the chain */
    _rl_kscxt = cxt->ocxt;
  if (_rl_kscxt)
    _rl_kscxt->childval = r;
  if (r != -3)
    _rl_keyseq_cxt_dispose (cxt);

  return r;
}
warning: parse error {
  int nkey, r;

  /* For now */
  /* The first time this context is used, we want to read input and dispatch
     on it.  When traversing the chain of contexts back `up', we want to use
     the value from the next context down.  We're simulating recursion using
     a chain of contexts. */
  if ((cxt->flags & KSEQ_DISPATCHED) == 0)
    {
      nkey = _rl_subseq_getchar (cxt->okey);
      if (nkey < 0)
	{
	  _rl_abort_internal ();
	  return -1;
	}
      r = _rl_dispatch_subseq (nkey, cxt->dmap, cxt->subseq_arg);
      cxt->flags |= KSEQ_DISPATCHED;
    }
  else
    r = cxt->childval;

  /* For now */
  if (r != -3)	/* don't do this if we indicate there will be other matches */
    r = _rl_subseq_result (r, cxt->oldmap, cxt->okey, (cxt->flags & KSEQ_SUBSEQ));

  RL_CHECK_SIGNALS ();
  if (r == 0)			/* success! */
    {
      _rl_keyseq_chain_dispose ();
      RL_UNSETSTATE (RL_STATE_MULTIKEY);
      return r;
    }

  if (r != -3)			/* magic value that says we added to the chain */
    _rl_kscxt = cxt->ocxt;
  if (_rl_kscxt)
    _rl_kscxt->childval = r;
  if (r != -3)
    _rl_keyseq_cxt_dispose (cxt);

  return r;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.c:670
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.c:719
parsing error 
{
  _rl_dispatching_keymap = map;
  return _rl_dispatch_subseq (key, map, 0);
}
warning: parse error {
  _rl_dispatching_keymap = map;
  return _rl_dispatch_subseq (key, map, 0);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.c:722
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.c:728
parsing error 
{
  int r, newkey;
  char *macro;
  rl_command_func_t *func;
#if defined (READLINE_CALLBACKS)
  _rl_keyseq_cxt *cxt;
#endif

  if (META_CHAR (key) && _rl_convert_meta_chars_to_ascii)
    {
      if (map[ESC].type == ISKMAP)
	{
	  if (RL_ISSTATE (RL_STATE_MACRODEF))
	    _rl_add_macro_char (ESC);
	  map = FUNCTION_TO_KEYMAP (map, ESC);
	  key = UNMETA (key);
	  rl_key_sequence_length += 2;
	  return (_rl_dispatch (key, map));
	}
      else
	rl_ding ();
      return 0;
    }

  if (RL_ISSTATE (RL_STATE_MACRODEF))
    _rl_add_macro_char (key);

  r = 0;
  switch (map[key].type)
    {
    case ISFUNC:
      func = map[key].function;
      if (func)
	{
	  /* Special case rl_do_lowercase_version (). */
	  if (func == rl_do_lowercase_version)
	    return (_rl_dispatch (_rl_to_lower (key), map));

	  rl_executing_keymap = map;

	  rl_dispatching = 1;
	  RL_SETSTATE(RL_STATE_DISPATCHING);
	  (*map[key].function)(rl_numeric_arg * rl_arg_sign, key);
	  RL_UNSETSTATE(RL_STATE_DISPATCHING);
	  rl_dispatching = 0;

	  /* If we have input pending, then the last command was a prefix
	     command.  Don't change the state of rl_last_func.  Otherwise,
	     remember the last command executed in this variable. */
	  if (rl_pending_input == 0 && map[key].function != rl_digit_argument)
	    rl_last_func = map[key].function;

	  RL_CHECK_SIGNALS ();
	}
      else if (map[ANYOTHERKEY].function)
	{
	  /* OK, there's no function bound in this map, but there is a
	     shadow function that was overridden when the current keymap
	     was created.  Return -2 to note  that. */
	  _rl_unget_char  (key);
	  return -2;
	}
      else if (got_subseq)
	{
	  /* Return -1 to note that we're in a subsequence, but  we don't
	     have a matching key, nor was one overridden.  This means
	     we need to back up the recursion chain and find the last
	     subsequence that is bound to a function. */
	  _rl_unget_char (key);
	  return -1;
	}
      else
	{
#if defined (READLINE_CALLBACKS)
	  RL_UNSETSTATE (RL_STATE_MULTIKEY);
	  _rl_keyseq_chain_dispose ();
#endif
	  _rl_abort_internal ();
	  return -1;
	}
      break;

    case ISKMAP:
      if (map[key].function != 0)
	{
#if defined (VI_MODE)
	  /* The only way this test will be true is if a subsequence has been
	     bound starting with ESC, generally the arrow keys.  What we do is
	     check whether there's input in the queue, which there generally
	     will be if an arrow key has been pressed, and, if there's not,
	     just dispatch to (what we assume is) rl_vi_movement_mode right
	     away.  This is essentially an input test with a zero timeout. */
	  if (rl_editing_mode == vi_mode && key == ESC && map == vi_insertion_keymap
	      && _rl_input_queued (0) == 0)
	    return (_rl_dispatch (ANYOTHERKEY, FUNCTION_TO_KEYMAP (map, key)));
#endif

	  rl_key_sequence_length++;
	  _rl_dispatching_keymap = FUNCTION_TO_KEYMAP (map, key);

	  /* Allocate new context here.  Use linked contexts (linked through
	     cxt->ocxt) to simulate recursion */
#if defined (READLINE_CALLBACKS)
	  if (RL_ISSTATE (RL_STATE_CALLBACK))
	    {
	      /* Return 0 only the first time, to indicate success to
		 _rl_callback_read_char.  The rest of the time, we're called
		 from _rl_dispatch_callback, so we return -3 to indicate
		 special handling is necessary. */
	      r = RL_ISSTATE (RL_STATE_MULTIKEY) ? -3 : 0;
	      cxt = _rl_keyseq_cxt_alloc ();

	      if (got_subseq)
		cxt->flags |= KSEQ_SUBSEQ;
	      cxt->okey = key;
	      cxt->oldmap = map;
	      cxt->dmap = _rl_dispatching_keymap;
	      cxt->subseq_arg = got_subseq || cxt->dmap[ANYOTHERKEY].function;

	      RL_SETSTATE (RL_STATE_MULTIKEY);
	      _rl_kscxt = cxt;

	      return r;		/* don't indicate immediate success */
	    }
#endif

	  newkey = _rl_subseq_getchar (key);
	  if (newkey < 0)
	    {
	      _rl_abort_internal ();
	      return -1;
	    }

	  r = _rl_dispatch_subseq (newkey, _rl_dispatching_keymap, got_subseq || map[ANYOTHERKEY].function);
	  return _rl_subseq_result (r, map, key, got_subseq);
	}
      else
	{
	  _rl_abort_internal ();
	  return -1;
	}
      break;

    case ISMACR:
      if (map[key].function != 0)
	{
	  macro = savestring ((char *)map[key].function);
	  _rl_with_macro_input (macro);
	  return 0;
	}
      break;
    }
#if defined (VI_MODE)
  if (rl_editing_mode == vi_mode && _rl_keymap == vi_movement_keymap &&
      key != ANYOTHERKEY &&
      _rl_vi_textmod_command (key))
    _rl_vi_set_last (key, rl_numeric_arg, rl_arg_sign);
#endif

  return (r);
}
warning: parse error {
  int r, newkey;
  char *macro;
  rl_command_func_t *func;
#if defined (READLINE_CALLBACKS)
  _rl_keyseq_cxt *cxt;
#endif

  if (META_CHAR (key) && _rl_convert_meta_chars_to_ascii)
    {
      if (map[ESC].type == ISKMAP)
	{
	  if (RL_ISSTATE (RL_STATE_MACRODEF))
	    _rl_add_macro_char (ESC);
	  map = FUNCTION_TO_KEYMAP (map, ESC);
	  key = UNMETA (key);
	  rl_key_sequence_length += 2;
	  return (_rl_dispatch (key, map));
	}
      else
	rl_ding ();
      return 0;
    }

  if (RL_ISSTATE (RL_STATE_MACRODEF))
    _rl_add_macro_char (key);

  r = 0;
  switch (map[key].type)
    {
    case ISFUNC:
      func = map[key].function;
      if (func)
	{
	  /* Special case rl_do_lowercase_version (). */
	  if (func == rl_do_lowercase_version)
	    return (_rl_dispatch (_rl_to_lower (key), map));

	  rl_executing_keymap = map;

	  rl_dispatching = 1;
	  RL_SETSTATE(RL_STATE_DISPATCHING);
	  (*map[key].function)(rl_numeric_arg * rl_arg_sign, key);
	  RL_UNSETSTATE(RL_STATE_DISPATCHING);
	  rl_dispatching = 0;

	  /* If we have input pending, then the last command was a prefix
	     command.  Don't change the state of rl_last_func.  Otherwise,
	     remember the last command executed in this variable. */
	  if (rl_pending_input == 0 && map[key].function != rl_digit_argument)
	    rl_last_func = map[key].function;

	  RL_CHECK_SIGNALS ();
	}
      else if (map[ANYOTHERKEY].function)
	{
	  /* OK, there's no function bound in this map, but there is a
	     shadow function that was overridden when the current keymap
	     was created.  Return -2 to note  that. */
	  _rl_unget_char  (key);
	  return -2;
	}
      else if (got_subseq)
	{
	  /* Return -1 to note that we're in a subsequence, but  we don't
	     have a matching key, nor was one overridden.  This means
	     we need to back up the recursion chain and find the last
	     subsequence that is bound to a function. */
	  _rl_unget_char (key);
	  return -1;
	}
      else
	{
#if defined (READLINE_CALLBACKS)
	  RL_UNSETSTATE (RL_STATE_MULTIKEY);
	  _rl_keyseq_chain_dispose ();
#endif
	  _rl_abort_internal ();
	  return -1;
	}
      break;

    case ISKMAP:
      if (map[key].function != 0)
	{
#if defined (VI_MODE)
	  /* The only way this test will be true is if a subsequence has been
	     bound starting with ESC, generally the arrow keys.  What we do is
	     check whether there's input in the queue, which there generally
	     will be if an arrow key has been pressed, and, if there's not,
	     just dispatch to (what we assume is) rl_vi_movement_mode right
	     away.  This is essentially an input test with a zero timeout. */
	  if (rl_editing_mode == vi_mode && key == ESC && map == vi_insertion_keymap
	      && _rl_input_queued (0) == 0)
	    return (_rl_dispatch (ANYOTHERKEY, FUNCTION_TO_KEYMAP (map, key)));
#endif

	  rl_key_sequence_length++;
	  _rl_dispatching_keymap = FUNCTION_TO_KEYMAP (map, key);

	  /* Allocate new context here.  Use linked contexts (linked through
	     cxt->ocxt) to simulate recursion */
#if defined (READLINE_CALLBACKS)
	  if (RL_ISSTATE (RL_STATE_CALLBACK))
	    {
	      /* Return 0 only the first time, to indicate success to
		 _rl_callback_read_char.  The rest of the time, we're called
		 from _rl_dispatch_callback, so we return -3 to indicate
		 special handling is necessary. */
	      r = RL_ISSTATE (RL_STATE_MULTIKEY) ? -3 : 0;
	      cxt = _rl_keyseq_cxt_alloc ();

	      if (got_subseq)
		cxt->flags |= KSEQ_SUBSEQ;
	      cxt->okey = key;
	      cxt->oldmap = map;
	      cxt->dmap = _rl_dispatching_keymap;
	      cxt->subseq_arg = got_subseq || cxt->dmap[ANYOTHERKEY].function;

	      RL_SETSTATE (RL_STATE_MULTIKEY);
	      _rl_kscxt = cxt;

	      return r;		/* don't indicate immediate success */
	    }
#endif

	  newkey = _rl_subseq_getchar (key);
	  if (newkey < 0)
	    {
	      _rl_abort_internal ();
	      return -1;
	    }

	  r = _rl_dispatch_subseq (newkey, _rl_dispatching_keymap, got_subseq || map[ANYOTHERKEY].function);
	  return _rl_subseq_result (r, map, key, got_subseq);
	}
      else
	{
	  _rl_abort_internal ();
	  return -1;
	}
      break;

    case ISMACR:
      if (map[key].function != 0)
	{
	  macro = savestring ((char *)map[key].function);
	  _rl_with_macro_input (macro);
	  return 0;
	}
      break;
    }
#if defined (VI_MODE)
  if (rl_editing_mode == vi_mode && _rl_keymap == vi_movement_keymap &&
      key != ANYOTHERKEY &&
      _rl_vi_textmod_command (key))
    _rl_vi_set_last (key, rl_numeric_arg, rl_arg_sign);
#endif

  return (r);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.c:732
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.c:895
parsing error 
{
  Keymap m;
  int type, nt;
  rl_command_func_t *func, *nf;

  if (r == -2)
    /* We didn't match anything, and the keymap we're indexed into
       shadowed a function previously bound to that prefix.  Call
       the function.  The recursive call to _rl_dispatch_subseq has
       already taken care of pushing any necessary input back onto
       the input queue with _rl_unget_char. */
    {
      m = _rl_dispatching_keymap;
      type = m[ANYOTHERKEY].type;
      func = m[ANYOTHERKEY].function;
      if (type == ISFUNC && func == rl_do_lowercase_version)
	r = _rl_dispatch (_rl_to_lower (key), map);
      else if (type == ISFUNC && func == rl_insert)
	{
	  /* If the function that was shadowed was self-insert, we
	     somehow need a keymap with map[key].func == self-insert.
	     Let's use this one. */
	  nt = m[key].type;
	  nf = m[key].function;

	  m[key].type = type;
	  m[key].function = func;
	  r = _rl_dispatch (key, m);
	  m[key].type = nt;
	  m[key].function = nf;
	}
      else
	r = _rl_dispatch (ANYOTHERKEY, m);
    }
  else if (r && map[ANYOTHERKEY].function)
    {
      /* We didn't match (r is probably -1), so return something to
	 tell the caller that it should try ANYOTHERKEY for an
	 overridden function. */
      _rl_unget_char (key);
      _rl_dispatching_keymap = map;
      return -2;
    }
  else if (r && got_subseq)
    {
      /* OK, back up the chain. */
      _rl_unget_char (key);
      _rl_dispatching_keymap = map;
      return -1;
    }

  return r;
}
warning: parse error {
  Keymap m;
  int type, nt;
  rl_command_func_t *func, *nf;

  if (r == -2)
    /* We didn't match anything, and the keymap we're indexed into
       shadowed a function previously bound to that prefix.  Call
       the function.  The recursive call to _rl_dispatch_subseq has
       already taken care of pushing any necessary input back onto
       the input queue with _rl_unget_char. */
    {
      m = _rl_dispatching_keymap;
      type = m[ANYOTHERKEY].type;
      func = m[ANYOTHERKEY].function;
      if (type == ISFUNC && func == rl_do_lowercase_version)
	r = _rl_dispatch (_rl_to_lower (key), map);
      else if (type == ISFUNC && func == rl_insert)
	{
	  /* If the function that was shadowed was self-insert, we
	     somehow need a keymap with map[key].func == self-insert.
	     Let's use this one. */
	  nt = m[key].type;
	  nf = m[key].function;

	  m[key].type = type;
	  m[key].function = func;
	  r = _rl_dispatch (key, m);
	  m[key].type = nt;
	  m[key].function = nf;
	}
      else
	r = _rl_dispatch (ANYOTHERKEY, m);
    }
  else if (r && map[ANYOTHERKEY].function)
    {
      /* We didn't match (r is probably -1), so return something to
	 tell the caller that it should try ANYOTHERKEY for an
	 overridden function. */
      _rl_unget_char (key);
      _rl_dispatching_keymap = map;
      return -2;
    }
  else if (r && got_subseq)
    {
      /* OK, back up the chain. */
      _rl_unget_char (key);
      _rl_dispatching_keymap = map;
      return -1;
    }

  return r;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.c:899
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.c:1,128
parsing error 
{
  Keymap xkeymap;

  xkeymap = _rl_keymap;
  _rl_keymap = map;

#if defined (__MSDOS__)
  rl_bind_keyseq_if_unbound ("\033[0A", rl_get_previous_history);
  rl_bind_keyseq_if_unbound ("\033[0B", rl_backward_char);
  rl_bind_keyseq_if_unbound ("\033[0C", rl_forward_char);
  rl_bind_keyseq_if_unbound ("\033[0D", rl_get_next_history);
#endif

  rl_bind_keyseq_if_unbound ("\033[A", rl_get_previous_history);
  rl_bind_keyseq_if_unbound ("\033[B", rl_get_next_history);
  rl_bind_keyseq_if_unbound ("\033[C", rl_forward_char);
  rl_bind_keyseq_if_unbound ("\033[D", rl_backward_char);
  rl_bind_keyseq_if_unbound ("\033[H", rl_beg_of_line);
  rl_bind_keyseq_if_unbound ("\033[F", rl_end_of_line);

  rl_bind_keyseq_if_unbound ("\033OA", rl_get_previous_history);
  rl_bind_keyseq_if_unbound ("\033OB", rl_get_next_history);
  rl_bind_keyseq_if_unbound ("\033OC", rl_forward_char);
  rl_bind_keyseq_if_unbound ("\033OD", rl_backward_char);
  rl_bind_keyseq_if_unbound ("\033OH", rl_beg_of_line);
  rl_bind_keyseq_if_unbound ("\033OF", rl_end_of_line);

#if defined (__MINGW32__)
  rl_bind_keyseq_if_unbound ("\340H", rl_get_previous_history);
  rl_bind_keyseq_if_unbound ("\340P", rl_get_next_history);
  rl_bind_keyseq_if_unbound ("\340M", rl_forward_char);
  rl_bind_keyseq_if_unbound ("\340K", rl_backward_char);
#endif

  _rl_keymap = xkeymap;
}
warning: parse error {
  Keymap xkeymap;

  xkeymap = _rl_keymap;
  _rl_keymap = map;

#if defined (__MSDOS__)
  rl_bind_keyseq_if_unbound ("\033[0A", rl_get_previous_history);
  rl_bind_keyseq_if_unbound ("\033[0B", rl_backward_char);
  rl_bind_keyseq_if_unbound ("\033[0C", rl_forward_char);
  rl_bind_keyseq_if_unbound ("\033[0D", rl_get_next_history);
#endif

  rl_bind_keyseq_if_unbound ("\033[A", rl_get_previous_history);
  rl_bind_keyseq_if_unbound ("\033[B", rl_get_next_history);
  rl_bind_keyseq_if_unbound ("\033[C", rl_forward_char);
  rl_bind_keyseq_if_unbound ("\033[D", rl_backward_char);
  rl_bind_keyseq_if_unbound ("\033[H", rl_beg_of_line);
  rl_bind_keyseq_if_unbound ("\033[F", rl_end_of_line);

  rl_bind_keyseq_if_unbound ("\033OA", rl_get_previous_history);
  rl_bind_keyseq_if_unbound ("\033OB", rl_get_next_history);
  rl_bind_keyseq_if_unbound ("\033OC", rl_forward_char);
  rl_bind_keyseq_if_unbound ("\033OD", rl_backward_char);
  rl_bind_keyseq_if_unbound ("\033OH", rl_beg_of_line);
  rl_bind_keyseq_if_unbound ("\033OF", rl_end_of_line);

#if defined (__MINGW32__)
  rl_bind_keyseq_if_unbound ("\340H", rl_get_previous_history);
  rl_bind_keyseq_if_unbound ("\340P", rl_get_next_history);
  rl_bind_keyseq_if_unbound ("\340M", rl_forward_char);
  rl_bind_keyseq_if_unbound ("\340K", rl_backward_char);
#endif

  _rl_keymap = xkeymap;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.c:1,130
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.c:1,192
parsing error 
{
  if (sp == 0)
    return -1;

  sp->point = rl_point;
  sp->end = rl_end;
  sp->mark = rl_mark;
  sp->buffer = rl_line_buffer;
  sp->buflen = rl_line_buffer_len;
  sp->ul = rl_undo_list;
  sp->prompt = rl_prompt;

  sp->rlstate = rl_readline_state;
  sp->done = rl_done;
  sp->kmap = _rl_keymap;

  sp->lastfunc = rl_last_func;
  sp->insmode = rl_insert_mode;
  sp->edmode = rl_editing_mode;
  sp->kseqlen = rl_key_sequence_length;
  sp->inf = rl_instream;
  sp->outf = rl_outstream;
  sp->pendingin = rl_pending_input;
  sp->macro = rl_executing_macro;

  sp->catchsigs = rl_catch_signals;
  sp->catchsigwinch = rl_catch_sigwinch;

  return (0);
}
warning: parse error {
  if (sp == 0)
    return -1;

  sp->point = rl_point;
  sp->end = rl_end;
  sp->mark = rl_mark;
  sp->buffer = rl_line_buffer;
  sp->buflen = rl_line_buffer_len;
  sp->ul = rl_undo_list;
  sp->prompt = rl_prompt;

  sp->rlstate = rl_readline_state;
  sp->done = rl_done;
  sp->kmap = _rl_keymap;

  sp->lastfunc = rl_last_func;
  sp->insmode = rl_insert_mode;
  sp->edmode = rl_editing_mode;
  sp->kseqlen = rl_key_sequence_length;
  sp->inf = rl_instream;
  sp->outf = rl_outstream;
  sp->pendingin = rl_pending_input;
  sp->macro = rl_executing_macro;

  sp->catchsigs = rl_catch_signals;
  sp->catchsigwinch = rl_catch_sigwinch;

  return (0);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.c:1,194
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.c:1,226
parsing error 
{
  if (sp == 0)
    return -1;

  rl_point = sp->point;
  rl_end = sp->end;
  rl_mark = sp->mark;
  the_line = rl_line_buffer = sp->buffer;
  rl_line_buffer_len = sp->buflen;
  rl_undo_list = sp->ul;
  rl_prompt = sp->prompt;

  rl_readline_state = sp->rlstate;
  rl_done = sp->done;
  _rl_keymap = sp->kmap;

  rl_last_func = sp->lastfunc;
  rl_insert_mode = sp->insmode;
  rl_editing_mode = sp->edmode;
  rl_key_sequence_length = sp->kseqlen;
  rl_instream = sp->inf;
  rl_outstream = sp->outf;
  rl_pending_input = sp->pendingin;
  rl_executing_macro = sp->macro;

  rl_catch_signals = sp->catchsigs;
  rl_catch_sigwinch = sp->catchsigwinch;

  return (0);
}
warning: parse error {
  if (sp == 0)
    return -1;

  rl_point = sp->point;
  rl_end = sp->end;
  rl_mark = sp->mark;
  the_line = rl_line_buffer = sp->buffer;
  rl_line_buffer_len = sp->buflen;
  rl_undo_list = sp->ul;
  rl_prompt = sp->prompt;

  rl_readline_state = sp->rlstate;
  rl_done = sp->done;
  _rl_keymap = sp->kmap;

  rl_last_func = sp->lastfunc;
  rl_insert_mode = sp->insmode;
  rl_editing_mode = sp->edmode;
  rl_key_sequence_length = sp->kseqlen;
  rl_instream = sp->inf;
  rl_outstream = sp->outf;
  rl_pending_input = sp->pendingin;
  rl_executing_macro = sp->macro;

  rl_catch_signals = sp->catchsigs;
  rl_catch_sigwinch = sp->catchsigwinch;

  return (0);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.c:1,228
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\rltty.c...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\rldefs.h...skip
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\rltty.h...
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\rlwinsize.h...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\rlprivate.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\rltty.c:77
parsing error 
{
#if defined (TIOCGWINSZ)
  struct winsize w;

  if (ioctl (tty, TIOCGWINSZ, &w) == 0)
      (void) ioctl (tty, TIOCSWINSZ, &w);
#endif /* TIOCGWINSZ */
}
warning: parse error {
#if defined (TIOCGWINSZ)
  struct winsize w;

  if (ioctl (tty, TIOCGWINSZ, &w) == 0)
      (void) ioctl (tty, TIOCSWINSZ, &w);
#endif /* TIOCGWINSZ */
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\rltty.c:79
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\rltty.c:582
parsing error 
{
  _rl_echoing_p = 1;
}
warning: parse error {
  _rl_echoing_p = 1;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\rltty.c:584
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\rltty.c:708
parsing error 
{
#if defined (__MINGW32__)
  return 0;
#else /* !__MING32__ */

  int fildes = fileno (rl_outstream);
#if defined (TIOCSTART)
#if defined (apollo)
  ioctl (&fildes, TIOCSTART, 0);
#else
  ioctl (fildes, TIOCSTART, 0);
#endif /* apollo */

#else /* !TIOCSTART */
#  if defined (TERMIOS_TTY_DRIVER)
#    if defined (__ksr1__)
  if (ksrflow)
    {
      ksrflow = 0;
      tcflow (fildes, TCOON);
    }
#    else /* !ksr1 */
  tcflow (fildes, TCOON);		/* Simulate a ^Q. */
#    endif /* !ksr1 */
#  else /* !TERMIOS_TTY_DRIVER */
#    if defined (TCXONC)
  ioctl (fildes, TCXONC, TCOON);
#    endif /* TCXONC */
#  endif /* !TERMIOS_TTY_DRIVER */
#endif /* !TIOCSTART */

  return 0;
#endif /* !__MINGW32__ */
}
warning: parse error {
#if defined (__MINGW32__)
  return 0;
#else /* !__MING32__ */

  int fildes = fileno (rl_outstream);
#if defined (TIOCSTART)
#if defined (apollo)
  ioctl (&fildes, TIOCSTART, 0);
#else
  ioctl (fildes, TIOCSTART, 0);
#endif /* apollo */

#else /* !TIOCSTART */
#  if defined (TERMIOS_TTY_DRIVER)
#    if defined (__ksr1__)
  if (ksrflow)
    {
      ksrflow = 0;
      tcflow (fildes, TCOON);
    }
#    else /* !ksr1 */
  tcflow (fildes, TCOON);		/* Simulate a ^Q. */
#    endif /* !ksr1 */
#  else /* !TERMIOS_TTY_DRIVER */
#    if defined (TCXONC)
  ioctl (fildes, TCXONC, TCOON);
#    endif /* TCXONC */
#  endif /* !TERMIOS_TTY_DRIVER */
#endif /* !TIOCSTART */

  return 0;
#endif /* !__MINGW32__ */
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\rltty.c:710
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\rltty.c:746
parsing error 
{
#if defined (__MINGW32__)
  return 0;
#else

  int fildes = fileno (rl_instream);

#if defined (TIOCSTOP)
# if defined (apollo)
  ioctl (&fildes, TIOCSTOP, 0);
# else
  ioctl (fildes, TIOCSTOP, 0);
# endif /* apollo */
#else /* !TIOCSTOP */
# if defined (TERMIOS_TTY_DRIVER)
#  if defined (__ksr1__)
  ksrflow = 1;
#  endif /* ksr1 */
  tcflow (fildes, TCOOFF);
# else
#   if defined (TCXONC)
  ioctl (fildes, TCXONC, TCOON);
#   endif /* TCXONC */
# endif /* !TERMIOS_TTY_DRIVER */
#endif /* !TIOCSTOP */

  return 0;
#endif /* !__MINGW32__ */
}
warning: parse error {
#if defined (__MINGW32__)
  return 0;
#else

  int fildes = fileno (rl_instream);

#if defined (TIOCSTOP)
# if defined (apollo)
  ioctl (&fildes, TIOCSTOP, 0);
# else
  ioctl (fildes, TIOCSTOP, 0);
# endif /* apollo */
#else /* !TIOCSTOP */
# if defined (TERMIOS_TTY_DRIVER)
#  if defined (__ksr1__)
  ksrflow = 1;
#  endif /* ksr1 */
  tcflow (fildes, TCOOFF);
# else
#   if defined (TCXONC)
  ioctl (fildes, TCXONC, TCOON);
#   endif /* TCXONC */
# endif /* !TERMIOS_TTY_DRIVER */
#endif /* !TIOCSTOP */

  return 0;
#endif /* !__MINGW32__ */
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\rltty.c:748
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\rltty.c:871
parsing error 
{
#if !defined (NO_TTY_DRIVER)
  TIOTYPE ttybuff;
  int tty;

  tty = fileno (rl_instream);

  if (get_tty_settings (tty, &ttybuff) == 0)
    _rl_bind_tty_special_chars (kmap, ttybuff);
#endif
}
warning: parse error {
#if !defined (NO_TTY_DRIVER)
  TIOTYPE ttybuff;
  int tty;

  tty = fileno (rl_instream);

  if (get_tty_settings (tty, &ttybuff) == 0)
    _rl_bind_tty_special_chars (kmap, ttybuff);
#endif
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\rltty.c:873
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\rltty.c:888
parsing error 
{
  rltty_set_default_bindings (kmap);
}
warning: parse error {
  rltty_set_default_bindings (kmap);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\rltty.c:890
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\rltty.c:899
parsing error 
{
  /* Don't bother before we've saved the tty special chars at least once. */
  if (RL_ISSTATE(RL_STATE_TTYCSAVED) == 0)
    return;

  RESET_SPECIAL (_rl_tty_chars.t_erase);
  RESET_SPECIAL (_rl_tty_chars.t_kill);

#  if defined (VLNEXT) && defined (TERMIOS_TTY_DRIVER)
  RESET_SPECIAL (_rl_tty_chars.t_lnext);
#  endif /* VLNEXT && TERMIOS_TTY_DRIVER */

#  if defined (VWERASE) && defined (TERMIOS_TTY_DRIVER)
  RESET_SPECIAL (_rl_tty_chars.t_werase);
#  endif /* VWERASE && TERMIOS_TTY_DRIVER */
}
warning: parse error {
  /* Don't bother before we've saved the tty special chars at least once. */
  if (RL_ISSTATE(RL_STATE_TTYCSAVED) == 0)
    return;

  RESET_SPECIAL (_rl_tty_chars.t_erase);
  RESET_SPECIAL (_rl_tty_chars.t_kill);

#  if defined (VLNEXT) && defined (TERMIOS_TTY_DRIVER)
  RESET_SPECIAL (_rl_tty_chars.t_lnext);
#  endif /* VLNEXT && TERMIOS_TTY_DRIVER */

#  if defined (VWERASE) && defined (TERMIOS_TTY_DRIVER)
  RESET_SPECIAL (_rl_tty_chars.t_werase);
#  endif /* VWERASE && TERMIOS_TTY_DRIVER */
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\rltty.c:901
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\savestring.c...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\xmalloc.h...skip
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\savestring.c:34
parsing error 
{
  char *ret;

  ret = (char *)xmalloc (strlen (s) + 1);
  strcpy (ret, s);
  return ret;
}
warning: parse error {
  char *ret;

  ret = (char *)xmalloc (strlen (s) + 1);
  strcpy (ret, s);
  return ret;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\savestring.c:35
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\search.c...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\rldefs.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\rlmbutil.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\history.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\rlprivate.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\xmalloc.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\search.c:88
parsing error 
{
  _rl_replace_text (entry->line, 0, rl_end);
  _rl_fix_point (1);
#if defined (VI_MODE)
  if (rl_editing_mode == vi_mode)
    /* POSIX.2 says that the `U' command doesn't affect the copy of any
       command lines to the edit line.  We're going to implement that by
       making the undo list start after the matching line is copied to the
       current editing buffer. */
    rl_free_undo_list ();
#endif

  if (_rl_saved_line_for_history)
    _rl_free_history_entry (_rl_saved_line_for_history);
  _rl_saved_line_for_history = (HIST_ENTRY *)NULL;
}
warning: parse error {
  _rl_replace_text (entry->line, 0, rl_end);
  _rl_fix_point (1);
#if defined (VI_MODE)
  if (rl_editing_mode == vi_mode)
    /* POSIX.2 says that the `U' command doesn't affect the copy of any
       command lines to the edit line.  We're going to implement that by
       making the undo list start after the matching line is copied to the
       current editing buffer. */
    rl_free_undo_list ();
#endif

  if (_rl_saved_line_for_history)
    _rl_free_history_entry (_rl_saved_line_for_history);
  _rl_saved_line_for_history = (HIST_ENTRY *)NULL;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\search.c:90
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\search.c:113
parsing error 
{
  int ret, old;

  if (pos < 0)
    return -1;

  old = where_history ();
  if (history_set_pos (pos) == 0)
    return -1;

  RL_SETSTATE(RL_STATE_SEARCH);
  if (*string == '^')
    ret = history_search_prefix (string + 1, dir);
  else
    ret = history_search (string, dir);
  RL_UNSETSTATE(RL_STATE_SEARCH);

  if (ret != -1)
    ret = where_history ();

  history_set_pos (old);
  return (ret);
}
warning: parse error {
  int ret, old;

  if (pos < 0)
    return -1;

  old = where_history ();
  if (history_set_pos (pos) == 0)
    return -1;

  RL_SETSTATE(RL_STATE_SEARCH);
  if (*string == '^')
    ret = history_search_prefix (string + 1, dir);
  else
    ret = history_search (string, dir);
  RL_UNSETSTATE(RL_STATE_SEARCH);

  if (ret != -1)
    ret = where_history ();

  history_set_pos (old);
  return (ret);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\search.c:116
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\search.c:144
parsing error 
{
  int oldpos, pos;
  HIST_ENTRY *entry;

  if (string == 0 || *string == '\0' || noninc_history_pos < 0)
    {
      rl_ding ();
      return 0;
    }

  pos = noninc_search_from_pos (string, noninc_history_pos + dir, dir);
  if (pos == -1)
    {
      /* Search failed, current history position unchanged. */
      rl_maybe_unsave_line ();
      rl_clear_message ();
      rl_point = 0;
      rl_ding ();
      return 0;
    }

  noninc_history_pos = pos;

  oldpos = where_history ();
  history_set_pos (noninc_history_pos);
  entry = current_history ();
#if defined (VI_MODE)
  if (rl_editing_mode != vi_mode)
#endif
    history_set_pos (oldpos);

  make_history_line_current (entry);

  rl_point = 0;
  rl_mark = rl_end;

  rl_clear_message ();
  return 1;
}
warning: parse error {
  int oldpos, pos;
  HIST_ENTRY *entry;

  if (string == 0 || *string == '\0' || noninc_history_pos < 0)
    {
      rl_ding ();
      return 0;
    }

  pos = noninc_search_from_pos (string, noninc_history_pos + dir, dir);
  if (pos == -1)
    {
      /* Search failed, current history position unchanged. */
      rl_maybe_unsave_line ();
      rl_clear_message ();
      rl_point = 0;
      rl_ding ();
      return 0;
    }

  noninc_history_pos = pos;

  oldpos = where_history ();
  history_set_pos (noninc_history_pos);
  entry = current_history ();
#if defined (VI_MODE)
  if (rl_editing_mode != vi_mode)
#endif
    history_set_pos (oldpos);

  make_history_line_current (entry);

  rl_point = 0;
  rl_mark = rl_end;

  rl_clear_message ();
  return 1;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\search.c:147
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\search.c:188
parsing error 
{
  _rl_search_cxt *cxt;
  char *p;

  cxt = _rl_scxt_alloc (RL_SEARCH_NSEARCH, 0);
  if (dir < 0)
    cxt->sflags |= SF_REVERSE;		/* not strictly needed */

  cxt->direction = dir;
  cxt->history_pos = cxt->save_line;

  rl_maybe_save_line ();

  /* Clear the undo list, since reading the search string should create its
     own undo list, and the whole list will end up being freed when we
     finish reading the search string. */
  rl_undo_list = 0;

  /* Use the line buffer to read the search string. */
  rl_line_buffer[0] = 0;
  rl_end = rl_point = 0;

  p = _rl_make_prompt_for_search (pchar ? pchar : ':');
  rl_message ("%s", p, 0);
  xfree (p);

  RL_SETSTATE(RL_STATE_NSEARCH);

  _rl_nscxt = cxt;

  return cxt;
}
warning: parse error {
  _rl_search_cxt *cxt;
  char *p;

  cxt = _rl_scxt_alloc (RL_SEARCH_NSEARCH, 0);
  if (dir < 0)
    cxt->sflags |= SF_REVERSE;		/* not strictly needed */

  cxt->direction = dir;
  cxt->history_pos = cxt->save_line;

  rl_maybe_save_line ();

  /* Clear the undo list, since reading the search string should create its
     own undo list, and the whole list will end up being freed when we
     finish reading the search string. */
  rl_undo_list = 0;

  /* Use the line buffer to read the search string. */
  rl_line_buffer[0] = 0;
  rl_end = rl_point = 0;

  p = _rl_make_prompt_for_search (pchar ? pchar : ':');
  rl_message ("%s", p, 0);
  xfree (p);

  RL_SETSTATE(RL_STATE_NSEARCH);

  _rl_nscxt = cxt;

  return cxt;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\search.c:190
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\search.c:224
parsing error 
{
  _rl_scxt_dispose (cxt, 0);
  _rl_nscxt = 0;

  RL_UNSETSTATE(RL_STATE_NSEARCH);

  return (r != 1);
}
warning: parse error {
  _rl_scxt_dispose (cxt, 0);
  _rl_nscxt = 0;

  RL_UNSETSTATE(RL_STATE_NSEARCH);

  return (r != 1);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\search.c:227
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\search.c:237
parsing error 
{
  rl_maybe_unsave_line ();
  rl_clear_message ();
  rl_point = cxt->save_point;
  rl_mark = cxt->save_mark;
  rl_restore_prompt ();

  RL_UNSETSTATE (RL_STATE_NSEARCH);
}
warning: parse error {
  rl_maybe_unsave_line ();
  rl_clear_message ();
  rl_point = cxt->save_point;
  rl_mark = cxt->save_mark;
  rl_restore_prompt ();

  RL_UNSETSTATE (RL_STATE_NSEARCH);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\search.c:239
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\search.c:253
parsing error 
{
  switch (c)
    {
    case CTRL('W'):
      rl_unix_word_rubout (1, c);
      break;

    case CTRL('U'):
      rl_unix_line_discard (1, c);
      break;

    case RETURN:
    case NEWLINE:
      return 0;

    case CTRL('H'):
    case RUBOUT:
      if (rl_point == 0)
	{
	  _rl_nsearch_abort (cxt);
	  return -1;
	}
      _rl_rubout_char (1, c);
      break;

    case CTRL('C'):
    case CTRL('G'):
      rl_ding ();
      _rl_nsearch_abort (cxt);
      return -1;

    default:
#if defined (HANDLE_MULTIBYTE)
      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
	rl_insert_text (cxt->mb);
      else
#endif
	_rl_insert_char (1, c);
      break;
    }

  (*rl_redisplay_function) ();
  return 1;
}
warning: parse error {
  switch (c)
    {
    case CTRL('W'):
      rl_unix_word_rubout (1, c);
      break;

    case CTRL('U'):
      rl_unix_line_discard (1, c);
      break;

    case RETURN:
    case NEWLINE:
      return 0;

    case CTRL('H'):
    case RUBOUT:
      if (rl_point == 0)
	{
	  _rl_nsearch_abort (cxt);
	  return -1;
	}
      _rl_rubout_char (1, c);
      break;

    case CTRL('C'):
    case CTRL('G'):
      rl_ding ();
      _rl_nsearch_abort (cxt);
      return -1;

    default:
#if defined (HANDLE_MULTIBYTE)
      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
	rl_insert_text (cxt->mb);
      else
#endif
	_rl_insert_char (1, c);
      break;
    }

  (*rl_redisplay_function) ();
  return 1;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\search.c:256
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\search.c:306
parsing error 
{
  rl_mark = cxt->save_mark;

  /* If rl_point == 0, we want to re-use the previous search string and
     start from the saved history position.  If there's no previous search
     string, punt. */
  if (rl_point == 0)
    {
      if (noninc_search_string == 0)
	{
	  rl_ding ();
	  rl_restore_prompt ();
	  RL_UNSETSTATE (RL_STATE_NSEARCH);
	  return -1;
	}
    }
  else
    {
      /* We want to start the search from the current history position. */
      noninc_history_pos = cxt->save_line;
      FREE (noninc_search_string);
      noninc_search_string = savestring (rl_line_buffer);

      /* If we don't want the subsequent undo list generated by the search
	 matching a history line to include the contents of the search string,
	 we need to clear rl_line_buffer here.  For now, we just clear the
	 undo list generated by reading the search string.  (If the search
	 fails, the old undo list will be restored by rl_maybe_unsave_line.) */
      rl_free_undo_list ();
    }

  rl_restore_prompt ();
  return (noninc_dosearch (noninc_search_string, cxt->direction));
}
warning: parse error {
  rl_mark = cxt->save_mark;

  /* If rl_point == 0, we want to re-use the previous search string and
     start from the saved history position.  If there's no previous search
     string, punt. */
  if (rl_point == 0)
    {
      if (noninc_search_string == 0)
	{
	  rl_ding ();
	  rl_restore_prompt ();
	  RL_UNSETSTATE (RL_STATE_NSEARCH);
	  return -1;
	}
    }
  else
    {
      /* We want to start the search from the current history position. */
      noninc_history_pos = cxt->save_line;
      FREE (noninc_search_string);
      noninc_search_string = savestring (rl_line_buffer);

      /* If we don't want the subsequent undo list generated by the search
	 matching a history line to include the contents of the search string,
	 we need to clear rl_line_buffer here.  For now, we just clear the
	 undo list generated by reading the search string.  (If the search
	 fails, the old undo list will be restored by rl_maybe_unsave_line.) */
      rl_free_undo_list ();
    }

  rl_restore_prompt ();
  return (noninc_dosearch (noninc_search_string, cxt->direction));
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\search.c:308
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\search.c:349
parsing error 
{
  _rl_search_cxt *cxt;
  int c, r;

  cxt = _rl_nsearch_init (dir, pchar);

  if (RL_ISSTATE (RL_STATE_CALLBACK))
    return (0);

  /* Read the search string. */
  r = 0;
  while (1)
    {
      c = _rl_search_getchar (cxt);

      if (c == 0)
	break;

      r = _rl_nsearch_dispatch (cxt, c);
      if (r < 0)
        return 1;
      else if (r == 0)
	break;        
    }

  r = _rl_nsearch_dosearch (cxt);
  return ((r >= 0) ? _rl_nsearch_cleanup (cxt, r) : (r != 1));
}
warning: parse error {
  _rl_search_cxt *cxt;
  int c, r;

  cxt = _rl_nsearch_init (dir, pchar);

  if (RL_ISSTATE (RL_STATE_CALLBACK))
    return (0);

  /* Read the search string. */
  r = 0;
  while (1)
    {
      c = _rl_search_getchar (cxt);

      if (c == 0)
	break;

      r = _rl_nsearch_dispatch (cxt, c);
      if (r < 0)
        return 1;
      else if (r == 0)
	break;        
    }

  r = _rl_nsearch_dosearch (cxt);
  return ((r >= 0) ? _rl_nsearch_cleanup (cxt, r) : (r != 1));
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\search.c:352
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\search.c:384
parsing error 
{
  return noninc_search (1, (key == '?') ? '?' : 0);
}
warning: parse error {
  return noninc_search (1, (key == '?') ? '?' : 0);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\search.c:386
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\search.c:393
parsing error 
{
  return noninc_search (-1, (key == '/') ? '/' : 0);
}
warning: parse error {
  return noninc_search (-1, (key == '/') ? '/' : 0);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\search.c:395
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\search.c:402
parsing error 
{
  int r;

  if (!noninc_search_string)
    {
      rl_ding ();
      return (-1);
    }
  r = noninc_dosearch (noninc_search_string, 1);
  return (r != 1);
}
warning: parse error {
  int r;

  if (!noninc_search_string)
    {
      rl_ding ();
      return (-1);
    }
  r = noninc_dosearch (noninc_search_string, 1);
  return (r != 1);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\search.c:404
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\search.c:419
parsing error 
{
  int r;

  if (!noninc_search_string)
    {
      rl_ding ();
      return (-1);
    }
  r = noninc_dosearch (noninc_search_string, -1);
  return (r != 1);
}
warning: parse error {
  int r;

  if (!noninc_search_string)
    {
      rl_ding ();
      return (-1);
    }
  r = noninc_dosearch (noninc_search_string, -1);
  return (r != 1);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\search.c:421
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\search.c:435
parsing error 
{
  int c, r;

  c = _rl_search_getchar (cxt);
  r = _rl_nsearch_dispatch (cxt, c);
  if (r != 0)
    return 1;

  r = _rl_nsearch_dosearch (cxt);
  return ((r >= 0) ? _rl_nsearch_cleanup (cxt, r) : (r != 1));
}
warning: parse error {
  int c, r;

  c = _rl_search_getchar (cxt);
  r = _rl_nsearch_dispatch (cxt, c);
  if (r != 0)
    return 1;

  r = _rl_nsearch_dosearch (cxt);
  return ((r >= 0) ? _rl_nsearch_cleanup (cxt, r) : (r != 1));
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\search.c:437
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\search.c:451
parsing error 
{
  HIST_ENTRY *temp;
  int ret, oldpos;

  rl_maybe_save_line ();
  temp = (HIST_ENTRY *)NULL;

  /* Search COUNT times through the history for a line whose prefix
     matches history_search_string.  When this loop finishes, TEMP,
     if non-null, is the history line to copy into the line buffer. */
  while (count)
    {
      ret = noninc_search_from_pos (history_search_string, rl_history_search_pos + dir, dir);
      if (ret == -1)
	break;

      /* Get the history entry we found. */
      rl_history_search_pos = ret;
      oldpos = where_history ();
      history_set_pos (rl_history_search_pos);
      temp = current_history ();
      history_set_pos (oldpos);

      /* Don't find multiple instances of the same line. */
      if (prev_line_found && STREQ (prev_line_found, temp->line))
        continue;
      prev_line_found = temp->line;
      count--;
    }

  /* If we didn't find anything at all, return. */
  if (temp == 0)
    {
      rl_maybe_unsave_line ();
      rl_ding ();
      /* If you don't want the saved history line (last match) to show up
         in the line buffer after the search fails, change the #if 0 to
         #if 1 */
#if 0
      if (rl_point > rl_history_search_len)
        {
          rl_point = rl_end = rl_history_search_len;
          rl_line_buffer[rl_end] = '\0';
          rl_mark = 0;
        }
#else
      rl_point = rl_history_search_len;	/* rl_maybe_unsave_line changes it */
      rl_mark = rl_end;
#endif
      return 1;
    }

  /* Copy the line we found into the current line buffer. */
  make_history_line_current (temp);

  rl_point = rl_history_search_len;
  rl_mark = rl_end;

  return 0;
}
warning: parse error {
  HIST_ENTRY *temp;
  int ret, oldpos;

  rl_maybe_save_line ();
  temp = (HIST_ENTRY *)NULL;

  /* Search COUNT times through the history for a line whose prefix
     matches history_search_string.  When this loop finishes, TEMP,
     if non-null, is the history line to copy into the line buffer. */
  while (count)
    {
      ret = noninc_search_from_pos (history_search_string, rl_history_search_pos + dir, dir);
      if (ret == -1)
	break;

      /* Get the history entry we found. */
      rl_history_search_pos = ret;
      oldpos = where_history ();
      history_set_pos (rl_history_search_pos);
      temp = current_history ();
      history_set_pos (oldpos);

      /* Don't find multiple instances of the same line. */
      if (prev_line_found && STREQ (prev_line_found, temp->line))
        continue;
      prev_line_found = temp->line;
      count--;
    }

  /* If we didn't find anything at all, return. */
  if (temp == 0)
    {
      rl_maybe_unsave_line ();
      rl_ding ();
      /* If you don't want the saved history line (last match) to show up
         in the line buffer after the search fails, change the #if 0 to
         #if 1 */
#if 0
      if (rl_point > rl_history_search_len)
        {
          rl_point = rl_end = rl_history_search_len;
          rl_line_buffer[rl_end] = '\0';
          rl_mark = 0;
        }
#else
      rl_point = rl_history_search_len;	/* rl_maybe_unsave_line changes it */
      rl_mark = rl_end;
#endif
      return 1;
    }

  /* Copy the line we found into the current line buffer. */
  make_history_line_current (temp);

  rl_point = rl_history_search_len;
  rl_mark = rl_end;

  return 0;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\search.c:453
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\search.c:538
parsing error 
{
  if (count == 0)
    return (0);

  if (rl_last_func != rl_history_search_forward &&
      rl_last_func != rl_history_search_backward)
    rl_history_search_reinit ();

  if (rl_history_search_len == 0)
    return (rl_get_next_history (count, ignore));
  return (rl_history_search_internal (abs (count), (count > 0) ? 1 : -1));
}
warning: parse error {
  if (count == 0)
    return (0);

  if (rl_last_func != rl_history_search_forward &&
      rl_last_func != rl_history_search_backward)
    rl_history_search_reinit ();

  if (rl_history_search_len == 0)
    return (rl_get_next_history (count, ignore));
  return (rl_history_search_internal (abs (count), (count > 0) ? 1 : -1));
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\search.c:540
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\search.c:557
parsing error 
{
  if (count == 0)
    return (0);

  if (rl_last_func != rl_history_search_forward &&
      rl_last_func != rl_history_search_backward)
    rl_history_search_reinit ();

  if (rl_history_search_len == 0)
    return (rl_get_previous_history (count, ignore));
  return (rl_history_search_internal (abs (count), (count > 0) ? -1 : 1));
}
warning: parse error {
  if (count == 0)
    return (0);

  if (rl_last_func != rl_history_search_forward &&
      rl_last_func != rl_history_search_backward)
    rl_history_search_reinit ();

  if (rl_history_search_len == 0)
    return (rl_get_previous_history (count, ignore));
  return (rl_history_search_internal (abs (count), (count > 0) ? -1 : 1));
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\search.c:559
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\shell.c...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\rlstdc.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\rlshell.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\xmalloc.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\shell.c:93
parsing error 
{
  register int c;
  char *result, *r, *s;

  result = (char *)xmalloc (3 + (4 * strlen (string)));
  r = result;
  *r++ = '\'';

  for (s = string; s && (c = *s); s++)
    {
      *r++ = c;

      if (c == '\'')
	{
	  *r++ = '\\';	/* insert escaped single quote */
	  *r++ = '\'';
	  *r++ = '\'';	/* start new quoted string */
	}
    }

  *r++ = '\'';
  *r = '\0';

  return (result);
}
warning: parse error {
  register int c;
  char *result, *r, *s;

  result = (char *)xmalloc (3 + (4 * strlen (string)));
  r = result;
  *r++ = '\'';

  for (s = string; s && (c = *s); s++)
    {
      *r++ = c;

      if (c == '\'')
	{
	  *r++ = '\\';	/* insert escaped single quote */
	  *r++ = '\'';
	  *r++ = '\'';	/* start new quoted string */
	}
    }

  *r++ = '\'';
  *r = '\0';

  return (result);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\shell.c:95
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\shell.c:124
parsing error 
{
  char *b;

#if defined (HAVE_SETENV)
  b = (char *)xmalloc (INT_STRLEN_BOUND (int) + 1);
  sprintf (b, "%d", lines);
  setenv ("LINES", b, 1);
  xfree (b);

  b = (char *)xmalloc (INT_STRLEN_BOUND (int) + 1);
  sprintf (b, "%d", cols);
  setenv ("COLUMNS", b, 1);
  xfree (b);
#else /* !HAVE_SETENV */
#  if defined (HAVE_PUTENV)
  b = (char *)xmalloc (INT_STRLEN_BOUND (int) + sizeof ("LINES=") + 1);
  sprintf (b, "LINES=%d", lines);
  putenv (b);

  b = (char *)xmalloc (INT_STRLEN_BOUND (int) + sizeof ("COLUMNS=") + 1);
  sprintf (b, "COLUMNS=%d", cols);
  putenv (b);
#  endif /* HAVE_PUTENV */
#endif /* !HAVE_SETENV */
}
warning: parse error {
  char *b;

#if defined (HAVE_SETENV)
  b = (char *)xmalloc (INT_STRLEN_BOUND (int) + 1);
  sprintf (b, "%d", lines);
  setenv ("LINES", b, 1);
  xfree (b);

  b = (char *)xmalloc (INT_STRLEN_BOUND (int) + 1);
  sprintf (b, "%d", cols);
  setenv ("COLUMNS", b, 1);
  xfree (b);
#else /* !HAVE_SETENV */
#  if defined (HAVE_PUTENV)
  b = (char *)xmalloc (INT_STRLEN_BOUND (int) + sizeof ("LINES=") + 1);
  sprintf (b, "LINES=%d", lines);
  putenv (b);

  b = (char *)xmalloc (INT_STRLEN_BOUND (int) + sizeof ("COLUMNS=") + 1);
  sprintf (b, "COLUMNS=%d", cols);
  putenv (b);
#  endif /* HAVE_PUTENV */
#endif /* !HAVE_SETENV */
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\shell.c:126
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\shell.c:154
parsing error 
{
  return ((char *)getenv (varname));
}
warning: parse error {
  return ((char *)getenv (varname));
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\shell.c:155
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\shell.c:181
parsing error 
{
#if defined (HAVE_FCNTL)
  int flags, bflags;

  if ((flags = fcntl (fd, F_GETFL, 0)) < 0)
    return -1;

  bflags = 0;

#ifdef O_NONBLOCK
  bflags |= O_NONBLOCK;
#endif

#ifdef O_NDELAY
  bflags |= O_NDELAY;
#endif

  if (flags & bflags)
    {
      flags &= ~bflags;
      return (fcntl (fd, F_SETFL, flags));
    }
#endif

  return 0;
}
warning: parse error {
#if defined (HAVE_FCNTL)
  int flags, bflags;

  if ((flags = fcntl (fd, F_GETFL, 0)) < 0)
    return -1;

  bflags = 0;

#ifdef O_NONBLOCK
  bflags |= O_NONBLOCK;
#endif

#ifdef O_NDELAY
  bflags |= O_NDELAY;
#endif

  if (flags & bflags)
    {
      flags &= ~bflags;
      return (fcntl (fd, F_SETFL, flags));
    }
#endif

  return 0;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\shell.c:183
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\signals.c...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\rldefs.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\history.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\rlprivate.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\signals.c:133
parsing error 
{
  _rl_caught_signal = 0;	/* XXX */

  _rl_handle_signal (sig);
  SIGHANDLER_RETURN;
}
warning: parse error {
  _rl_caught_signal = 0;	/* XXX */

  _rl_handle_signal (sig);
  SIGHANDLER_RETURN;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\signals.c:135
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\signals.c:143
parsing error 
{
  if (_rl_interrupt_immediately || RL_ISSTATE(RL_STATE_CALLBACK))
    {
      _rl_interrupt_immediately = 0;
      _rl_handle_signal (sig);
    }
  else
    _rl_caught_signal = sig;

  SIGHANDLER_RETURN;
}
warning: parse error {
  if (_rl_interrupt_immediately || RL_ISSTATE(RL_STATE_CALLBACK))
    {
      _rl_interrupt_immediately = 0;
      _rl_handle_signal (sig);
    }
  else
    _rl_caught_signal = sig;

  SIGHANDLER_RETURN;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\signals.c:145
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\signals.c:158
parsing error 
{
#if defined (HAVE_POSIX_SIGNALS)
  sigset_t set;
#else /* !HAVE_POSIX_SIGNALS */
#  if defined (HAVE_BSD_SIGNALS)
  long omask;
#  else /* !HAVE_BSD_SIGNALS */
  sighandler_cxt dummy_cxt;	/* needed for rl_set_sighandler call */
#  endif /* !HAVE_BSD_SIGNALS */
#endif /* !HAVE_POSIX_SIGNALS */

  RL_SETSTATE(RL_STATE_SIGHANDLER);

#if !defined (HAVE_BSD_SIGNALS) && !defined (HAVE_POSIX_SIGNALS)
  /* Since the signal will not be blocked while we are in the signal
     handler, ignore it until rl_clear_signals resets the catcher. */
#  if defined (SIGALRM)
  if (sig == SIGINT || sig == SIGALRM)
#  else
  if (sig == SIGINT)
#  endif
    rl_set_sighandler (sig, SIG_IGN, &dummy_cxt);
#endif /* !HAVE_BSD_SIGNALS && !HAVE_POSIX_SIGNALS */

  switch (sig)
    {
    case SIGINT:
      _rl_reset_completion_state ();
      rl_free_line_state ();
      /* FALLTHROUGH */

    case SIGTERM:
#if defined (SIGTSTP)
    case SIGTSTP:
    case SIGTTOU:
    case SIGTTIN:
#endif /* SIGTSTP */
#if defined (SIGALRM)
    case SIGALRM:
#endif
#if defined (SIGQUIT)
    case SIGQUIT:
#endif
      rl_echo_signal_char (sig);
      rl_cleanup_after_signal ();

#if defined (HAVE_POSIX_SIGNALS)
      sigemptyset (&set);
      sigprocmask (SIG_BLOCK, (sigset_t *)NULL, &set);
      sigdelset (&set, sig);
#else /* !HAVE_POSIX_SIGNALS */
#  if defined (HAVE_BSD_SIGNALS)
      omask = sigblock (0);
#  endif /* HAVE_BSD_SIGNALS */
#endif /* !HAVE_POSIX_SIGNALS */

#if defined (__EMX__)
      signal (sig, SIG_ACK);
#endif

#if defined (HAVE_KILL)
      kill (getpid (), sig);
#else
      raise (sig);		/* assume we have raise */
#endif

      /* Let the signal that we just sent through.  */
#if defined (HAVE_POSIX_SIGNALS)
      sigprocmask (SIG_SETMASK, &set, (sigset_t *)NULL);
#else /* !HAVE_POSIX_SIGNALS */
#  if defined (HAVE_BSD_SIGNALS)
      sigsetmask (omask & ~(sigmask (sig)));
#  endif /* HAVE_BSD_SIGNALS */
#endif /* !HAVE_POSIX_SIGNALS */

      rl_reset_after_signal ();
    }

  RL_UNSETSTATE(RL_STATE_SIGHANDLER);
  SIGHANDLER_RETURN;
}
warning: parse error {
#if defined (HAVE_POSIX_SIGNALS)
  sigset_t set;
#else /* !HAVE_POSIX_SIGNALS */
#  if defined (HAVE_BSD_SIGNALS)
  long omask;
#  else /* !HAVE_BSD_SIGNALS */
  sighandler_cxt dummy_cxt;	/* needed for rl_set_sighandler call */
#  endif /* !HAVE_BSD_SIGNALS */
#endif /* !HAVE_POSIX_SIGNALS */

  RL_SETSTATE(RL_STATE_SIGHANDLER);

#if !defined (HAVE_BSD_SIGNALS) && !defined (HAVE_POSIX_SIGNALS)
  /* Since the signal will not be blocked while we are in the signal
     handler, ignore it until rl_clear_signals resets the catcher. */
#  if defined (SIGALRM)
  if (sig == SIGINT || sig == SIGALRM)
#  else
  if (sig == SIGINT)
#  endif
    rl_set_sighandler (sig, SIG_IGN, &dummy_cxt);
#endif /* !HAVE_BSD_SIGNALS && !HAVE_POSIX_SIGNALS */

  switch (sig)
    {
    case SIGINT:
      _rl_reset_completion_state ();
      rl_free_line_state ();
      /* FALLTHROUGH */

    case SIGTERM:
#if defined (SIGTSTP)
    case SIGTSTP:
    case SIGTTOU:
    case SIGTTIN:
#endif /* SIGTSTP */
#if defined (SIGALRM)
    case SIGALRM:
#endif
#if defined (SIGQUIT)
    case SIGQUIT:
#endif
      rl_echo_signal_char (sig);
      rl_cleanup_after_signal ();

#if defined (HAVE_POSIX_SIGNALS)
      sigemptyset (&set);
      sigprocmask (SIG_BLOCK, (sigset_t *)NULL, &set);
      sigdelset (&set, sig);
#else /* !HAVE_POSIX_SIGNALS */
#  if defined (HAVE_BSD_SIGNALS)
      omask = sigblock (0);
#  endif /* HAVE_BSD_SIGNALS */
#endif /* !HAVE_POSIX_SIGNALS */

#if defined (__EMX__)
      signal (sig, SIG_ACK);
#endif

#if defined (HAVE_KILL)
      kill (getpid (), sig);
#else
      raise (sig);		/* assume we have raise */
#endif

      /* Let the signal that we just sent through.  */
#if defined (HAVE_POSIX_SIGNALS)
      sigprocmask (SIG_SETMASK, &set, (sigset_t *)NULL);
#else /* !HAVE_POSIX_SIGNALS */
#  if defined (HAVE_BSD_SIGNALS)
      sigsetmask (omask & ~(sigmask (sig)));
#  endif /* HAVE_BSD_SIGNALS */
#endif /* !HAVE_POSIX_SIGNALS */

      rl_reset_after_signal ();
    }

  RL_UNSETSTATE(RL_STATE_SIGHANDLER);
  SIGHANDLER_RETURN;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\signals.c:160
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\signals.c:276
parsing error 
{
  oh->sa_handler = signal (sig, nh->sa_handler);
  return 0;
}
warning: parse error {
  oh->sa_handler = signal (sig, nh->sa_handler);
  return 0;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\signals.c:279
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\signals.c:289
parsing error 
{
  sighandler_cxt old_handler;
#if defined (HAVE_POSIX_SIGNALS)
  struct sigaction act;

  act.sa_handler = handler;
#  if defined (SIGWINCH)
  act.sa_flags = (sig == SIGWINCH) ? SA_RESTART : 0;
#  else
  act.sa_flags = 0;
#  endif /* SIGWINCH */
  sigemptyset (&act.sa_mask);
  sigemptyset (&ohandler->sa_mask);
  sigaction (sig, &act, &old_handler);
#else
  old_handler.sa_handler = (SigHandler *)signal (sig, handler);
#endif /* !HAVE_POSIX_SIGNALS */

  /* XXX -- assume we have memcpy */
  /* If rl_set_signals is called twice in a row, don't set the old handler to
     rl_signal_handler, because that would cause infinite recursion. */
  if (handler != rl_signal_handler || old_handler.sa_handler != rl_signal_handler)
    memcpy (ohandler, &old_handler, sizeof (sighandler_cxt));

  return (ohandler->sa_handler);
}
warning: parse error {
  sighandler_cxt old_handler;
#if defined (HAVE_POSIX_SIGNALS)
  struct sigaction act;

  act.sa_handler = handler;
#  if defined (SIGWINCH)
  act.sa_flags = (sig == SIGWINCH) ? SA_RESTART : 0;
#  else
  act.sa_flags = 0;
#  endif /* SIGWINCH */
  sigemptyset (&act.sa_mask);
  sigemptyset (&ohandler->sa_mask);
  sigaction (sig, &act, &old_handler);
#else
  old_handler.sa_handler = (SigHandler *)signal (sig, handler);
#endif /* !HAVE_POSIX_SIGNALS */

  /* XXX -- assume we have memcpy */
  /* If rl_set_signals is called twice in a row, don't set the old handler to
     rl_signal_handler, because that would cause infinite recursion. */
  if (handler != rl_signal_handler || old_handler.sa_handler != rl_signal_handler)
    memcpy (ohandler, &old_handler, sizeof (sighandler_cxt));

  return (ohandler->sa_handler);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\signals.c:293
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\signals.c:321
parsing error 
{
  sighandler_cxt dummy;
  SigHandler *oh;

  sigemptyset (&dummy.sa_mask);
  oh = rl_set_sighandler (sig, handler, ohandler);
  if (oh == (SigHandler *)SIG_IGN)
    rl_sigaction (sig, ohandler, &dummy);
}
warning: parse error {
  sighandler_cxt dummy;
  SigHandler *oh;

  sigemptyset (&dummy.sa_mask);
  oh = rl_set_sighandler (sig, handler, ohandler);
  if (oh == (SigHandler *)SIG_IGN)
    rl_sigaction (sig, ohandler, &dummy);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\signals.c:325
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\signals.c:637
parsing error 
{
  char cstr[3];
  int cslen, c;

  if (_rl_echoctl == 0 || _rl_echo_control_chars == 0)
    return;

  switch (sig)
    {
    case SIGINT:  c = _rl_intr_char; break;
#if defined (SIGQUIT)
    case SIGQUIT: c = _rl_quit_char; break;
#endif
#if defined (SIGTSTP)
    case SIGTSTP: c = _rl_susp_char; break;
#endif
    default: return;
    }

  if (CTRL_CHAR (c) || c == RUBOUT)
    {
      cstr[0] = '^';
      cstr[1] = CTRL_CHAR (c) ? UNCTRL (c) : '?';
      cstr[cslen = 2] = '\0';
    }
  else
    {
      cstr[0] = c;
      cstr[cslen = 1] = '\0';
    }

  _rl_output_some_chars (cstr, cslen);
}
warning: parse error {
  char cstr[3];
  int cslen, c;

  if (_rl_echoctl == 0 || _rl_echo_control_chars == 0)
    return;

  switch (sig)
    {
    case SIGINT:  c = _rl_intr_char; break;
#if defined (SIGQUIT)
    case SIGQUIT: c = _rl_quit_char; break;
#endif
#if defined (SIGTSTP)
    case SIGTSTP: c = _rl_susp_char; break;
#endif
    default: return;
    }

  if (CTRL_CHAR (c) || c == RUBOUT)
    {
      cstr[0] = '^';
      cstr[1] = CTRL_CHAR (c) ? UNCTRL (c) : '?';
      cstr[cslen = 2] = '\0';
    }
  else
    {
      cstr[0] = c;
      cstr[cslen = 1] = '\0';
    }

  _rl_output_some_chars (cstr, cslen);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\signals.c:639
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\terminal.c...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\posixstat.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\rldefs.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\rltty.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\tcap.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\history.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\rlprivate.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\rlshell.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\xmalloc.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\terminal.c:224
parsing error 
{
  char *ss;
#if defined (TIOCGWINSZ)
  struct winsize window_size;
#endif /* TIOCGWINSZ */
  int wr, wc;

  wr = wc = -1;
#if defined (TIOCGWINSZ)
  if (ioctl (tty, TIOCGWINSZ, &window_size) == 0)
    {
      wc = (int) window_size.ws_col;
      wr = (int) window_size.ws_row;
    }
#endif /* TIOCGWINSZ */

#if defined (__EMX__)
  _emx_get_screensize (&wc, &wr);
#elif defined (__MINGW32__)
  _win_get_screensize (&wc, &wr);
#endif

  if (ignore_env || rl_prefer_env_winsize == 0)
    {
      _rl_screenwidth = wc;
      _rl_screenheight = wr;
    }
  else
    _rl_screenwidth = _rl_screenheight = -1;

  /* Environment variable COLUMNS overrides setting of "co" if IGNORE_ENV
     is unset.  If we prefer the environment, check it first before
     assigning the value returned by the kernel. */
  if (_rl_screenwidth <= 0)
    {
      if (ignore_env == 0 && (ss = sh_get_env_value ("COLUMNS")))
	_rl_screenwidth = atoi (ss);

      if (_rl_screenwidth <= 0)
        _rl_screenwidth = wc;

#if !defined (__DJGPP__)
      if (_rl_screenwidth <= 0 && term_string_buffer)
	_rl_screenwidth = tgetnum ("co");
#endif
    }

  /* Environment variable LINES overrides setting of "li" if IGNORE_ENV
     is unset. */
  if (_rl_screenheight <= 0)
    {
      if (ignore_env == 0 && (ss = sh_get_env_value ("LINES")))
	_rl_screenheight = atoi (ss);

      if (_rl_screenheight <= 0)
        _rl_screenheight = wr;

#if !defined (__DJGPP__)
      if (_rl_screenheight <= 0 && term_string_buffer)
	_rl_screenheight = tgetnum ("li");
#endif
    }

  /* If all else fails, default to 80x24 terminal. */
  if (_rl_screenwidth <= 1)
    _rl_screenwidth = 80;

  if (_rl_screenheight <= 0)
    _rl_screenheight = 24;

  /* If we're being compiled as part of bash, set the environment
     variables $LINES and $COLUMNS to new values.  Otherwise, just
     do a pair of putenv () or setenv () calls. */
  sh_set_lines_and_columns (_rl_screenheight, _rl_screenwidth);

  if (_rl_term_autowrap == 0)
    _rl_screenwidth--;

  _rl_screenchars = _rl_screenwidth * _rl_screenheight;
}
warning: parse error {
  char *ss;
#if defined (TIOCGWINSZ)
  struct winsize window_size;
#endif /* TIOCGWINSZ */
  int wr, wc;

  wr = wc = -1;
#if defined (TIOCGWINSZ)
  if (ioctl (tty, TIOCGWINSZ, &window_size) == 0)
    {
      wc = (int) window_size.ws_col;
      wr = (int) window_size.ws_row;
    }
#endif /* TIOCGWINSZ */

#if defined (__EMX__)
  _emx_get_screensize (&wc, &wr);
#elif defined (__MINGW32__)
  _win_get_screensize (&wc, &wr);
#endif

  if (ignore_env || rl_prefer_env_winsize == 0)
    {
      _rl_screenwidth = wc;
      _rl_screenheight = wr;
    }
  else
    _rl_screenwidth = _rl_screenheight = -1;

  /* Environment variable COLUMNS overrides setting of "co" if IGNORE_ENV
     is unset.  If we prefer the environment, check it first before
     assigning the value returned by the kernel. */
  if (_rl_screenwidth <= 0)
    {
      if (ignore_env == 0 && (ss = sh_get_env_value ("COLUMNS")))
	_rl_screenwidth = atoi (ss);

      if (_rl_screenwidth <= 0)
        _rl_screenwidth = wc;

#if !defined (__DJGPP__)
      if (_rl_screenwidth <= 0 && term_string_buffer)
	_rl_screenwidth = tgetnum ("co");
#endif
    }

  /* Environment variable LINES overrides setting of "li" if IGNORE_ENV
     is unset. */
  if (_rl_screenheight <= 0)
    {
      if (ignore_env == 0 && (ss = sh_get_env_value ("LINES")))
	_rl_screenheight = atoi (ss);

      if (_rl_screenheight <= 0)
        _rl_screenheight = wr;

#if !defined (__DJGPP__)
      if (_rl_screenheight <= 0 && term_string_buffer)
	_rl_screenheight = tgetnum ("li");
#endif
    }

  /* If all else fails, default to 80x24 terminal. */
  if (_rl_screenwidth <= 1)
    _rl_screenwidth = 80;

  if (_rl_screenheight <= 0)
    _rl_screenheight = 24;

  /* If we're being compiled as part of bash, set the environment
     variables $LINES and $COLUMNS to new values.  Otherwise, just
     do a pair of putenv () or setenv () calls. */
  sh_set_lines_and_columns (_rl_screenheight, _rl_screenwidth);

  if (_rl_term_autowrap == 0)
    _rl_screenwidth--;

  _rl_screenchars = _rl_screenwidth * _rl_screenheight;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\terminal.c:226
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\terminal.c:308
parsing error 
{
  if (_rl_term_autowrap == -1)
    _rl_init_terminal_io (rl_terminal_name);

  if (rows > 0)
    _rl_screenheight = rows;
  if (cols > 0)
    {
      _rl_screenwidth = cols;
      if (_rl_term_autowrap == 0)
	_rl_screenwidth--;
    }

  if (rows > 0 || cols > 0)
    _rl_screenchars = _rl_screenwidth * _rl_screenheight;
}
warning: parse error {
  if (_rl_term_autowrap == -1)
    _rl_init_terminal_io (rl_terminal_name);

  if (rows > 0)
    _rl_screenheight = rows;
  if (cols > 0)
    {
      _rl_screenwidth = cols;
      if (_rl_term_autowrap == 0)
	_rl_screenwidth--;
    }

  if (rows > 0 || cols > 0)
    _rl_screenchars = _rl_screenwidth * _rl_screenheight;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\terminal.c:310
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\terminal.c:328
parsing error 
{
  _rl_set_screen_size (rows, cols);
}
warning: parse error {
  _rl_set_screen_size (rows, cols);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\terminal.c:330
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\terminal.c:335
parsing error 
{
  if (rows)
    *rows = _rl_screenheight;
  if (cols)
    *cols = _rl_screenwidth;
}
warning: parse error {
  if (rows)
    *rows = _rl_screenheight;
  if (cols)
    *cols = _rl_screenwidth;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\terminal.c:337
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\terminal.c:408
parsing error 
{
#if !defined (__DJGPP__)	/* XXX - doesn't DJGPP have a termcap library? */
  register int i;

  for (i = 0; i < NUM_TC_STRINGS; i++)
    *(tc_strings[i].tc_value) = tgetstr ((char *)tc_strings[i].tc_var, bp);
#endif
  tcap_initialized = 1;
}
warning: parse error {
#if !defined (__DJGPP__)	/* XXX - doesn't DJGPP have a termcap library? */
  register int i;

  for (i = 0; i < NUM_TC_STRINGS; i++)
    *(tc_strings[i].tc_value) = tgetstr ((char *)tc_strings[i].tc_var, bp);
#endif
  tcap_initialized = 1;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\terminal.c:410
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\terminal.c:422
parsing error 
{
  const char *term;
  char *buffer;
  int tty, tgetent_ret;

  term = terminal_name ? terminal_name : sh_get_env_value ("TERM");
  _rl_term_clrpag = _rl_term_cr = _rl_term_clreol = (char *)NULL;
  tty = rl_instream ? fileno (rl_instream) : 0;

  if (term == 0)
    term = "dumb";

  /* I've separated this out for later work on not calling tgetent at all
     if the calling application has supplied a custom redisplay function,
     (and possibly if the application has supplied a custom input function). */
  if (CUSTOM_REDISPLAY_FUNC())
    {
      tgetent_ret = -1;
    }
  else
    {
      if (term_string_buffer == 0)
	term_string_buffer = (char *)xmalloc(2032);

      if (term_buffer == 0)
	term_buffer = (char *)xmalloc(4080);

      buffer = term_string_buffer;

      tgetent_ret = tgetent (term_buffer, term);
    }

  if (tgetent_ret <= 0)
    {
      FREE (term_string_buffer);
      FREE (term_buffer);
      buffer = term_buffer = term_string_buffer = (char *)NULL;

      _rl_term_autowrap = 0;	/* used by _rl_get_screen_size */

      /* Allow calling application to set default height and width, using
	 rl_set_screen_size */
      if (_rl_screenwidth <= 0 || _rl_screenheight <= 0)
	{
#if defined (__EMX__)
	  _emx_get_screensize (&_rl_screenwidth, &_rl_screenheight);
	  _rl_screenwidth--;
#else /* !__EMX__ */
	  _rl_get_screen_size (tty, 0);
#endif /* !__EMX__ */
	}

      /* Defaults. */
      if (_rl_screenwidth <= 0 || _rl_screenheight <= 0)
        {
	  _rl_screenwidth = 79;
	  _rl_screenheight = 24;
        }

      /* Everything below here is used by the redisplay code (tputs). */
      _rl_screenchars = _rl_screenwidth * _rl_screenheight;
      _rl_term_cr = "\r";
      _rl_term_im = _rl_term_ei = _rl_term_ic = _rl_term_IC = (char *)NULL;
      _rl_term_up = _rl_term_dc = _rl_term_DC = _rl_visible_bell = (char *)NULL;
      _rl_term_ku = _rl_term_kd = _rl_term_kl = _rl_term_kr = (char *)NULL;
      _rl_term_kh = _rl_term_kH = _rl_term_kI = _rl_term_kD = (char *)NULL;
      _rl_term_ks = _rl_term_ke = _rl_term_at7 = (char *)NULL;
      _rl_term_mm = _rl_term_mo = (char *)NULL;
      _rl_term_ve = _rl_term_vs = (char *)NULL;
      _rl_term_forward_char = (char *)NULL;
      _rl_terminal_can_insert = term_has_meta = 0;

      /* Reasonable defaults for tgoto().  Readline currently only uses
         tgoto if _rl_term_IC or _rl_term_DC is defined, but just in case we
         change that later... */
      PC = '\0';
      BC = _rl_term_backspace = "\b";
      UP = _rl_term_up;

      return 0;
    }

  get_term_capabilities (&buffer);

  /* Set up the variables that the termcap library expects the application
     to provide. */
  PC = _rl_term_pc ? *_rl_term_pc : 0;
  BC = _rl_term_backspace;
  UP = _rl_term_up;

  if (!_rl_term_cr)
    _rl_term_cr = "\r";

  _rl_term_autowrap = tgetflag ("am") && tgetflag ("xn");

  /* Allow calling application to set default height and width, using
     rl_set_screen_size */
  if (_rl_screenwidth <= 0 || _rl_screenheight <= 0)
    _rl_get_screen_size (tty, 0);

  /* "An application program can assume that the terminal can do
      character insertion if *any one of* the capabilities `IC',
      `im', `ic' or `ip' is provided."  But we can't do anything if
      only `ip' is provided, so... */
  _rl_terminal_can_insert = (_rl_term_IC || _rl_term_im || _rl_term_ic);

  /* Check to see if this terminal has a meta key and clear the capability
     variables if there is none. */
  term_has_meta = tgetflag ("km") != 0;
  if (term_has_meta == 0)
    _rl_term_mm = _rl_term_mo = (char *)NULL;

  /* Attempt to find and bind the arrow keys.  Do not override already
     bound keys in an overzealous attempt, however. */

  bind_termcap_arrow_keys (emacs_standard_keymap);

#if defined (VI_MODE)
  bind_termcap_arrow_keys (vi_movement_keymap);
  bind_termcap_arrow_keys (vi_insertion_keymap);
#endif /* VI_MODE */

  return 0;
}
warning: parse error {
  const char *term;
  char *buffer;
  int tty, tgetent_ret;

  term = terminal_name ? terminal_name : sh_get_env_value ("TERM");
  _rl_term_clrpag = _rl_term_cr = _rl_term_clreol = (char *)NULL;
  tty = rl_instream ? fileno (rl_instream) : 0;

  if (term == 0)
    term = "dumb";

  /* I've separated this out for later work on not calling tgetent at all
     if the calling application has supplied a custom redisplay function,
     (and possibly if the application has supplied a custom input function). */
  if (CUSTOM_REDISPLAY_FUNC())
    {
      tgetent_ret = -1;
    }
  else
    {
      if (term_string_buffer == 0)
	term_string_buffer = (char *)xmalloc(2032);

      if (term_buffer == 0)
	term_buffer = (char *)xmalloc(4080);

      buffer = term_string_buffer;

      tgetent_ret = tgetent (term_buffer, term);
    }

  if (tgetent_ret <= 0)
    {
      FREE (term_string_buffer);
      FREE (term_buffer);
      buffer = term_buffer = term_string_buffer = (char *)NULL;

      _rl_term_autowrap = 0;	/* used by _rl_get_screen_size */

      /* Allow calling application to set default height and width, using
	 rl_set_screen_size */
      if (_rl_screenwidth <= 0 || _rl_screenheight <= 0)
	{
#if defined (__EMX__)
	  _emx_get_screensize (&_rl_screenwidth, &_rl_screenheight);
	  _rl_screenwidth--;
#else /* !__EMX__ */
	  _rl_get_screen_size (tty, 0);
#endif /* !__EMX__ */
	}

      /* Defaults. */
      if (_rl_screenwidth <= 0 || _rl_screenheight <= 0)
        {
	  _rl_screenwidth = 79;
	  _rl_screenheight = 24;
        }

      /* Everything below here is used by the redisplay code (tputs). */
      _rl_screenchars = _rl_screenwidth * _rl_screenheight;
      _rl_term_cr = "\r";
      _rl_term_im = _rl_term_ei = _rl_term_ic = _rl_term_IC = (char *)NULL;
      _rl_term_up = _rl_term_dc = _rl_term_DC = _rl_visible_bell = (char *)NULL;
      _rl_term_ku = _rl_term_kd = _rl_term_kl = _rl_term_kr = (char *)NULL;
      _rl_term_kh = _rl_term_kH = _rl_term_kI = _rl_term_kD = (char *)NULL;
      _rl_term_ks = _rl_term_ke = _rl_term_at7 = (char *)NULL;
      _rl_term_mm = _rl_term_mo = (char *)NULL;
      _rl_term_ve = _rl_term_vs = (char *)NULL;
      _rl_term_forward_char = (char *)NULL;
      _rl_terminal_can_insert = term_has_meta = 0;

      /* Reasonable defaults for tgoto().  Readline currently only uses
         tgoto if _rl_term_IC or _rl_term_DC is defined, but just in case we
         change that later... */
      PC = '\0';
      BC = _rl_term_backspace = "\b";
      UP = _rl_term_up;

      return 0;
    }

  get_term_capabilities (&buffer);

  /* Set up the variables that the termcap library expects the application
     to provide. */
  PC = _rl_term_pc ? *_rl_term_pc : 0;
  BC = _rl_term_backspace;
  UP = _rl_term_up;

  if (!_rl_term_cr)
    _rl_term_cr = "\r";

  _rl_term_autowrap = tgetflag ("am") && tgetflag ("xn");

  /* Allow calling application to set default height and width, using
     rl_set_screen_size */
  if (_rl_screenwidth <= 0 || _rl_screenheight <= 0)
    _rl_get_screen_size (tty, 0);

  /* "An application program can assume that the terminal can do
      character insertion if *any one of* the capabilities `IC',
      `im', `ic' or `ip' is provided."  But we can't do anything if
      only `ip' is provided, so... */
  _rl_terminal_can_insert = (_rl_term_IC || _rl_term_im || _rl_term_ic);

  /* Check to see if this terminal has a meta key and clear the capability
     variables if there is none. */
  term_has_meta = tgetflag ("km") != 0;
  if (term_has_meta == 0)
    _rl_term_mm = _rl_term_mo = (char *)NULL;

  /* Attempt to find and bind the arrow keys.  Do not override already
     bound keys in an overzealous attempt, however. */

  bind_termcap_arrow_keys (emacs_standard_keymap);

#if defined (VI_MODE)
  bind_termcap_arrow_keys (vi_movement_keymap);
  bind_termcap_arrow_keys (vi_insertion_keymap);
#endif /* VI_MODE */

  return 0;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\terminal.c:423
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\terminal.c:550
parsing error 
{
  Keymap xkeymap;

  xkeymap = _rl_keymap;
  _rl_keymap = map;

  rl_bind_keyseq_if_unbound (_rl_term_ku, rl_get_previous_history);
  rl_bind_keyseq_if_unbound (_rl_term_kd, rl_get_next_history);
  rl_bind_keyseq_if_unbound (_rl_term_kr, rl_forward_char);
  rl_bind_keyseq_if_unbound (_rl_term_kl, rl_backward_char);

  rl_bind_keyseq_if_unbound (_rl_term_kh, rl_beg_of_line);	/* Home */
  rl_bind_keyseq_if_unbound (_rl_term_at7, rl_end_of_line);	/* End */

  rl_bind_keyseq_if_unbound (_rl_term_kD, rl_delete);

  _rl_keymap = xkeymap;
}
warning: parse error {
  Keymap xkeymap;

  xkeymap = _rl_keymap;
  _rl_keymap = map;

  rl_bind_keyseq_if_unbound (_rl_term_ku, rl_get_previous_history);
  rl_bind_keyseq_if_unbound (_rl_term_kd, rl_get_next_history);
  rl_bind_keyseq_if_unbound (_rl_term_kr, rl_forward_char);
  rl_bind_keyseq_if_unbound (_rl_term_kl, rl_backward_char);

  rl_bind_keyseq_if_unbound (_rl_term_kh, rl_beg_of_line);	/* Home */
  rl_bind_keyseq_if_unbound (_rl_term_at7, rl_end_of_line);	/* End */

  rl_bind_keyseq_if_unbound (_rl_term_kD, rl_delete);

  _rl_keymap = xkeymap;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\terminal.c:552
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\terminal.c:573
parsing error 
{
  register int i;

  if (tcap_initialized == 0)
    return ((char *)NULL);
  for (i = 0; i < NUM_TC_STRINGS; i++)
    {
      if (tc_strings[i].tc_var[0] == cap[0] && strcmp (tc_strings[i].tc_var, cap) == 0)
        return *(tc_strings[i].tc_value);
    }
  return ((char *)NULL);
}
warning: parse error {
  register int i;

  if (tcap_initialized == 0)
    return ((char *)NULL);
  for (i = 0; i < NUM_TC_STRINGS; i++)
    {
      if (tc_strings[i].tc_var[0] == cap[0] && strcmp (tc_strings[i].tc_var, cap) == 0)
        return *(tc_strings[i].tc_value);
    }
  return ((char *)NULL);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\terminal.c:574
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\terminal.c:591
parsing error 
{
  _rl_screenwidth = _rl_screenheight = 0;
  _rl_init_terminal_io (terminal_name);
  return 0;
}
warning: parse error {
  _rl_screenwidth = _rl_screenheight = 0;
  _rl_init_terminal_io (terminal_name);
  return 0;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\terminal.c:592
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\terminal.c:608
parsing error 
{
  return putc (c, _rl_out_stream);
}
warning: parse error {
  return putc (c, _rl_out_stream);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\terminal.c:610
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\terminal.c:618
parsing error 
{
  fwrite (string, 1, count, _rl_out_stream);
}
warning: parse error {
  fwrite (string, 1, count, _rl_out_stream);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\terminal.c:620
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\terminal.c:626
parsing error 
{
  register int i;

  if (_rl_term_backspace)
    for (i = 0; i < count; i++)
      tputs (_rl_term_backspace, 1, _rl_output_character_function);
  else
    for (i = 0; i < count; i++)
      putc ('\b', _rl_out_stream);
  return 0;
}
warning: parse error {
  register int i;

  if (_rl_term_backspace)
    for (i = 0; i < count; i++)
      tputs (_rl_term_backspace, 1, _rl_output_character_function);
  else
    for (i = 0; i < count; i++)
      putc ('\b', _rl_out_stream);
  return 0;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\terminal.c:628
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\terminal.c:696
parsing error 
{
#if !defined (__DJGPP__)
  if (on && _rl_term_ks)
    tputs (_rl_term_ks, 1, _rl_output_character_function);
  else if (!on && _rl_term_ke)
    tputs (_rl_term_ke, 1, _rl_output_character_function);
#endif
}
warning: parse error {
#if !defined (__DJGPP__)
  if (on && _rl_term_ks)
    tputs (_rl_term_ks, 1, _rl_output_character_function);
  else if (!on && _rl_term_ke)
    tputs (_rl_term_ke, 1, _rl_output_character_function);
#endif
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\terminal.c:698
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\terminal.c:718
parsing error 
{
  if (_rl_term_ve && _rl_term_vs)
    {
      if (force || im != rl_insert_mode)
	{
	  if (im == RL_IM_OVERWRITE)
	    tputs (_rl_term_vs, 1, _rl_output_character_function);
	  else
	    tputs (_rl_term_ve, 1, _rl_output_character_function);
	}
    }
}
warning: parse error {
  if (_rl_term_ve && _rl_term_vs)
    {
      if (force || im != rl_insert_mode)
	{
	  if (im == RL_IM_OVERWRITE)
	    tputs (_rl_term_vs, 1, _rl_output_character_function);
	  else
	    tputs (_rl_term_ve, 1, _rl_output_character_function);
	}
    }
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\terminal.c:720
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\text.c...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\rldefs.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\rlmbutil.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\history.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\rlprivate.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\rlshell.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\xmalloc.h...skip
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\text.c:85
parsing error 
{
  register int i, l;

  l = (string && *string) ? strlen (string) : 0;
  if (l == 0)
    return 0;

  if (rl_end + l >= rl_line_buffer_len)
    rl_extend_line_buffer (rl_end + l);

  for (i = rl_end; i >= rl_point; i--)
    rl_line_buffer[i + l] = rl_line_buffer[i];
  strncpy (rl_line_buffer + rl_point, string, l);

  /* Remember how to undo this if we aren't undoing something. */
  if (_rl_doing_an_undo == 0)
    {
      /* If possible and desirable, concatenate the undos. */
      if ((l == 1) &&
	  rl_undo_list &&
	  (rl_undo_list->what == UNDO_INSERT) &&
	  (rl_undo_list->end == rl_point) &&
	  (rl_undo_list->end - rl_undo_list->start < 20))
	rl_undo_list->end++;
      else
	rl_add_undo (UNDO_INSERT, rl_point, rl_point + l, (char *)NULL);
    }
  rl_point += l;
  rl_end += l;
  rl_line_buffer[rl_end] = '\0';
  return l;
}
warning: parse error {
  register int i, l;

  l = (string && *string) ? strlen (string) : 0;
  if (l == 0)
    return 0;

  if (rl_end + l >= rl_line_buffer_len)
    rl_extend_line_buffer (rl_end + l);

  for (i = rl_end; i >= rl_point; i--)
    rl_line_buffer[i + l] = rl_line_buffer[i];
  strncpy (rl_line_buffer + rl_point, string, l);

  /* Remember how to undo this if we aren't undoing something. */
  if (_rl_doing_an_undo == 0)
    {
      /* If possible and desirable, concatenate the undos. */
      if ((l == 1) &&
	  rl_undo_list &&
	  (rl_undo_list->what == UNDO_INSERT) &&
	  (rl_undo_list->end == rl_point) &&
	  (rl_undo_list->end - rl_undo_list->start < 20))
	rl_undo_list->end++;
      else
	rl_add_undo (UNDO_INSERT, rl_point, rl_point + l, (char *)NULL);
    }
  rl_point += l;
  rl_end += l;
  rl_line_buffer[rl_end] = '\0';
  return l;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\text.c:86
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\text.c:122
parsing error 
{
  register char *text;
  register int diff, i;

  /* Fix it if the caller is confused. */
  if (from > to)
    SWAP (from, to);

  /* fix boundaries */
  if (to > rl_end)
    {
      to = rl_end;
      if (from > to)
	from = to;
    }
  if (from < 0)
    from = 0;

  text = rl_copy_text (from, to);

  /* Some versions of strncpy() can't handle overlapping arguments. */
  diff = to - from;
  for (i = from; i < rl_end - diff; i++)
    rl_line_buffer[i] = rl_line_buffer[i + diff];

  /* Remember how to undo this delete. */
  if (_rl_doing_an_undo == 0)
    rl_add_undo (UNDO_DELETE, from, to, text);
  else
    xfree (text);

  rl_end -= diff;
  rl_line_buffer[rl_end] = '\0';
  return (diff);
}
warning: parse error {
  register char *text;
  register int diff, i;

  /* Fix it if the caller is confused. */
  if (from > to)
    SWAP (from, to);

  /* fix boundaries */
  if (to > rl_end)
    {
      to = rl_end;
      if (from > to)
	from = to;
    }
  if (from < 0)
    from = 0;

  text = rl_copy_text (from, to);

  /* Some versions of strncpy() can't handle overlapping arguments. */
  diff = to - from;
  for (i = from; i < rl_end - diff; i++)
    rl_line_buffer[i] = rl_line_buffer[i + diff];

  /* Remember how to undo this delete. */
  if (_rl_doing_an_undo == 0)
    rl_add_undo (UNDO_DELETE, from, to, text);
  else
    xfree (text);

  rl_end -= diff;
  rl_line_buffer[rl_end] = '\0';
  return (diff);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\text.c:124
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\text.c:173
parsing error 
{
  _RL_FIX_POINT (rl_point);
  if (fix_mark_too)
    _RL_FIX_POINT (rl_mark);
}
warning: parse error {
  _RL_FIX_POINT (rl_point);
  if (fix_mark_too)
    _RL_FIX_POINT (rl_mark);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\text.c:175
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\text.c:187
parsing error 
{
  int n;

  n = 0;
  rl_begin_undo_group ();
  if (start <= end)
    rl_delete_text (start, end + 1);
  rl_point = start;
  if (*text)
    n = rl_insert_text (text);
  rl_end_undo_group ();

  return n;
}
warning: parse error {
  int n;

  n = 0;
  rl_begin_undo_group ();
  if (start <= end)
    rl_delete_text (start, end + 1);
  rl_point = start;
  if (*text)
    n = rl_insert_text (text);
  rl_end_undo_group ();

  return n;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\text.c:189
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\text.c:208
parsing error 
{
  int len;

  len = strlen (text);
  if (len >= rl_line_buffer_len)
    rl_extend_line_buffer (len);
  strcpy (rl_line_buffer, text);
  rl_end = len;

  if (clear_undo)
    rl_free_undo_list ();

  _rl_fix_point (1);
}
warning: parse error {
  int len;

  len = strlen (text);
  if (len >= rl_line_buffer_len)
    rl_extend_line_buffer (len);
  strcpy (rl_line_buffer, text);
  rl_end = len;

  if (clear_undo)
    rl_free_undo_list ();

  _rl_fix_point (1);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\text.c:210
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\text.c:260
parsing error 
{
  if (count < 0)
    return (rl_backward_byte (-count, key));

  if (count > 0)
    {
      int end, lend;

      end = rl_point + count;
#if defined (VI_MODE)
      lend = rl_end > 0 ? rl_end - (VI_COMMAND_MODE()) : rl_end;
#else
      lend = rl_end;
#endif

      if (end > lend)
	{
	  rl_point = lend;
	  rl_ding ();
	}
      else
	rl_point = end;
    }

  if (rl_end < 0)
    rl_end = 0;

  return 0;
}
warning: parse error {
  if (count < 0)
    return (rl_backward_byte (-count, key));

  if (count > 0)
    {
      int end, lend;

      end = rl_point + count;
#if defined (VI_MODE)
      lend = rl_end > 0 ? rl_end - (VI_COMMAND_MODE()) : rl_end;
#else
      lend = rl_end;
#endif

      if (end > lend)
	{
	  rl_point = lend;
	  rl_ding ();
	}
      else
	rl_point = end;
    }

  if (rl_end < 0)
    rl_end = 0;

  return 0;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\text.c:262
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\text.c:293
parsing error 
{
  int point;

#if defined (HANDLE_MULTIBYTE)
  point = _rl_find_next_mbchar (rl_line_buffer, rl_point, count, MB_FIND_NONZERO);

#if defined (VI_MODE)
  if (point >= rl_end && VI_COMMAND_MODE())
    point = _rl_find_prev_mbchar (rl_line_buffer, rl_end, MB_FIND_NONZERO);
#endif

    if (rl_end < 0)
	rl_end = 0;
#else
  point = rl_point + count;
  if (point > rl_end)
    point = rl_end;
#endif

  return (point);
}
warning: parse error {
  int point;

#if defined (HANDLE_MULTIBYTE)
  point = _rl_find_next_mbchar (rl_line_buffer, rl_point, count, MB_FIND_NONZERO);

#if defined (VI_MODE)
  if (point >= rl_end && VI_COMMAND_MODE())
    point = _rl_find_prev_mbchar (rl_line_buffer, rl_end, MB_FIND_NONZERO);
#endif

    if (rl_end < 0)
	rl_end = 0;
#else
  point = rl_point + count;
  if (point > rl_end)
    point = rl_end;
#endif

  return (point);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\text.c:295
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\text.c:320
parsing error 
{
  int point;

  if (MB_CUR_MAX == 1 || rl_byte_oriented)
    return (rl_forward_byte (count, key));

  if (count < 0)
    return (rl_backward_char (-count, key));

  if (count > 0)
    {
      if (rl_point == rl_end && EMACS_MODE())
	{
	  rl_ding ();
	  return 0;
	}

      point = _rl_forward_char_internal (count);

      if (rl_point == point)
	rl_ding ();

      rl_point = point;
    }

  return 0;
}
warning: parse error {
  int point;

  if (MB_CUR_MAX == 1 || rl_byte_oriented)
    return (rl_forward_byte (count, key));

  if (count < 0)
    return (rl_backward_char (-count, key));

  if (count > 0)
    {
      if (rl_point == rl_end && EMACS_MODE())
	{
	  rl_ding ();
	  return 0;
	}

      point = _rl_forward_char_internal (count);

      if (rl_point == point)
	rl_ding ();

      rl_point = point;
    }

  return 0;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\text.c:322
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\text.c:360
parsing error 
{
  return (rl_forward_char (count, key));
}
warning: parse error {
  return (rl_forward_char (count, key));
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\text.c:362
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\text.c:368
parsing error 
{
  if (count < 0)
    return (rl_forward_byte (-count, key));

  if (count > 0)
    {
      if (rl_point < count)
	{
	  rl_point = 0;
	  rl_ding ();
	}
      else
	rl_point -= count;
    }

  if (rl_point < 0)
    rl_point = 0;

  return 0;
}
warning: parse error {
  if (count < 0)
    return (rl_forward_byte (-count, key));

  if (count > 0)
    {
      if (rl_point < count)
	{
	  rl_point = 0;
	  rl_ding ();
	}
      else
	rl_point -= count;
    }

  if (rl_point < 0)
    rl_point = 0;

  return 0;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\text.c:370
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\text.c:394
parsing error 
{
  int point;

  if (MB_CUR_MAX == 1 || rl_byte_oriented)
    return (rl_backward_byte (count, key));

  if (count < 0)
    return (rl_forward_char (-count, key));

  if (count > 0)
    {
      point = rl_point;

      while (count > 0 && point > 0)
	{
	  point = _rl_find_prev_mbchar (rl_line_buffer, point, MB_FIND_NONZERO);
	  count--;
	}
      if (count > 0)
	{
	  rl_point = 0;
	  rl_ding ();
	}
      else
        rl_point = point;
    }

  return 0;
}
warning: parse error {
  int point;

  if (MB_CUR_MAX == 1 || rl_byte_oriented)
    return (rl_backward_byte (count, key));

  if (count < 0)
    return (rl_forward_char (-count, key));

  if (count > 0)
    {
      point = rl_point;

      while (count > 0 && point > 0)
	{
	  point = _rl_find_prev_mbchar (rl_line_buffer, point, MB_FIND_NONZERO);
	  count--;
	}
      if (count > 0)
	{
	  rl_point = 0;
	  rl_ding ();
	}
      else
        rl_point = point;
    }

  return 0;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\text.c:396
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\text.c:436
parsing error 
{
  return (rl_backward_char (count, key));
}
warning: parse error {
  return (rl_backward_char (count, key));
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\text.c:438
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\text.c:444
parsing error 
{
  rl_point = 0;
  return 0;
}
warning: parse error {
  rl_point = 0;
  return 0;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\text.c:446
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\text.c:453
parsing error 
{
  rl_point = rl_end;
  return 0;
}
warning: parse error {
  rl_point = rl_end;
  return 0;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\text.c:455
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\text.c:462
parsing error 
{
  int c;

  if (count < 0)
    return (rl_backward_word (-count, key));

  while (count)
    {
      if (rl_point == rl_end)
	return 0;

      /* If we are not in a word, move forward until we are in one.
	 Then, move forward until we hit a non-alphabetic character. */
      c = _rl_char_value (rl_line_buffer, rl_point);

      if (_rl_walphabetic (c) == 0)
	{
	  rl_point = MB_NEXTCHAR (rl_line_buffer, rl_point, 1, MB_FIND_NONZERO);
	  while (rl_point < rl_end)
	    {
	      c = _rl_char_value (rl_line_buffer, rl_point);
	      if (_rl_walphabetic (c))
		break;
	      rl_point = MB_NEXTCHAR (rl_line_buffer, rl_point, 1, MB_FIND_NONZERO);
	    }
	}

      if (rl_point == rl_end)
	return 0;

      rl_point = MB_NEXTCHAR (rl_line_buffer, rl_point, 1, MB_FIND_NONZERO);
      while (rl_point < rl_end)
	{
	  c = _rl_char_value (rl_line_buffer, rl_point);
	  if (_rl_walphabetic (c) == 0)
	    break;
	  rl_point = MB_NEXTCHAR (rl_line_buffer, rl_point, 1, MB_FIND_NONZERO);
	}

      --count;
    }

  return 0;
}
warning: parse error {
  int c;

  if (count < 0)
    return (rl_backward_word (-count, key));

  while (count)
    {
      if (rl_point == rl_end)
	return 0;

      /* If we are not in a word, move forward until we are in one.
	 Then, move forward until we hit a non-alphabetic character. */
      c = _rl_char_value (rl_line_buffer, rl_point);

      if (_rl_walphabetic (c) == 0)
	{
	  rl_point = MB_NEXTCHAR (rl_line_buffer, rl_point, 1, MB_FIND_NONZERO);
	  while (rl_point < rl_end)
	    {
	      c = _rl_char_value (rl_line_buffer, rl_point);
	      if (_rl_walphabetic (c))
		break;
	      rl_point = MB_NEXTCHAR (rl_line_buffer, rl_point, 1, MB_FIND_NONZERO);
	    }
	}

      if (rl_point == rl_end)
	return 0;

      rl_point = MB_NEXTCHAR (rl_line_buffer, rl_point, 1, MB_FIND_NONZERO);
      while (rl_point < rl_end)
	{
	  c = _rl_char_value (rl_line_buffer, rl_point);
	  if (_rl_walphabetic (c) == 0)
	    break;
	  rl_point = MB_NEXTCHAR (rl_line_buffer, rl_point, 1, MB_FIND_NONZERO);
	}

      --count;
    }

  return 0;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\text.c:464
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\text.c:511
parsing error 
{
  int c, p;

  if (count < 0)
    return (rl_forward_word (-count, key));

  while (count)
    {
      if (rl_point == 0)
	return 0;

      /* Like rl_forward_word (), except that we look at the characters
	 just before point. */

      p = MB_PREVCHAR (rl_line_buffer, rl_point, MB_FIND_NONZERO);
      c = _rl_char_value (rl_line_buffer, p);

      if (_rl_walphabetic (c) == 0)
	{
	  rl_point = p;
	  while (rl_point > 0)
	    {
	      p = MB_PREVCHAR (rl_line_buffer, rl_point, MB_FIND_NONZERO);
	      c = _rl_char_value (rl_line_buffer, p);
	      if (_rl_walphabetic (c))
		break;
	      rl_point = p;
	    }
	}

      while (rl_point)
	{
	  p = MB_PREVCHAR (rl_line_buffer, rl_point, MB_FIND_NONZERO);
	  c = _rl_char_value (rl_line_buffer, p);	  
	  if (_rl_walphabetic (c) == 0)
	    break;
	  else
	    rl_point = p;
	}

      --count;
    }

  return 0;
}
warning: parse error {
  int c, p;

  if (count < 0)
    return (rl_forward_word (-count, key));

  while (count)
    {
      if (rl_point == 0)
	return 0;

      /* Like rl_forward_word (), except that we look at the characters
	 just before point. */

      p = MB_PREVCHAR (rl_line_buffer, rl_point, MB_FIND_NONZERO);
      c = _rl_char_value (rl_line_buffer, p);

      if (_rl_walphabetic (c) == 0)
	{
	  rl_point = p;
	  while (rl_point > 0)
	    {
	      p = MB_PREVCHAR (rl_line_buffer, rl_point, MB_FIND_NONZERO);
	      c = _rl_char_value (rl_line_buffer, p);
	      if (_rl_walphabetic (c))
		break;
	      rl_point = p;
	    }
	}

      while (rl_point)
	{
	  p = MB_PREVCHAR (rl_line_buffer, rl_point, MB_FIND_NONZERO);
	  c = _rl_char_value (rl_line_buffer, p);	  
	  if (_rl_walphabetic (c) == 0)
	    break;
	  else
	    rl_point = p;
	}

      --count;
    }

  return 0;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\text.c:513
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\text.c:561
parsing error 
{
  int curr_line;

  curr_line = _rl_current_display_line ();

  _rl_move_vert (curr_line);
  _rl_move_cursor_relative (0, rl_line_buffer);   /* XXX is this right */

  _rl_clear_to_eol (0);		/* arg of 0 means to not use spaces */

  rl_forced_update_display ();
  rl_display_fixed = 1;

  return 0;
}
warning: parse error {
  int curr_line;

  curr_line = _rl_current_display_line ();

  _rl_move_vert (curr_line);
  _rl_move_cursor_relative (0, rl_line_buffer);   /* XXX is this right */

  _rl_clear_to_eol (0);		/* arg of 0 means to not use spaces */

  rl_forced_update_display ();
  rl_display_fixed = 1;

  return 0;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\text.c:563
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\text.c:583
parsing error 
{
  if (rl_explicit_arg)
    {
      rl_refresh_line (count, key);
      return 0;
    }

  _rl_clear_screen ();		/* calls termcap function to clear screen */
  rl_forced_update_display ();
  rl_display_fixed = 1;

  return 0;
}
warning: parse error {
  if (rl_explicit_arg)
    {
      rl_refresh_line (count, key);
      return 0;
    }

  _rl_clear_screen ();		/* calls termcap function to clear screen */
  rl_forced_update_display ();
  rl_display_fixed = 1;

  return 0;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\text.c:585
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\text.c:600
parsing error 
{
  int ch;

  RL_SETSTATE (RL_STATE_MOREINPUT);
  do
    ch = rl_read_key ();
  while (ch >= 0x20 && ch < 0x40);
  RL_UNSETSTATE (RL_STATE_MOREINPUT);

  return 0;
}
warning: parse error {
  int ch;

  RL_SETSTATE (RL_STATE_MOREINPUT);
  do
    ch = rl_read_key ();
  while (ch >= 0x20 && ch < 0x40);
  RL_UNSETSTATE (RL_STATE_MOREINPUT);

  return 0;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\text.c:602
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\text.c:615
parsing error 
{
  int ch;

  RL_SETSTATE(RL_STATE_MOREINPUT);
  ch = rl_read_key ();
  RL_UNSETSTATE(RL_STATE_MOREINPUT);

  switch (_rl_to_upper (ch))
    {
    case 'A':
      rl_get_previous_history (count, ch);
      break;

    case 'B':
      rl_get_next_history (count, ch);
      break;

    case 'C':
      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
	rl_forward_char (count, ch);
      else
	rl_forward_byte (count, ch);
      break;

    case 'D':
      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
	rl_backward_char (count, ch);
      else
	rl_backward_byte (count, ch);
      break;

    default:
      rl_ding ();
    }

  return 0;
}
warning: parse error {
  int ch;

  RL_SETSTATE(RL_STATE_MOREINPUT);
  ch = rl_read_key ();
  RL_UNSETSTATE(RL_STATE_MOREINPUT);

  switch (_rl_to_upper (ch))
    {
    case 'A':
      rl_get_previous_history (count, ch);
      break;

    case 'B':
      rl_get_next_history (count, ch);
      break;

    case 'C':
      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
	rl_forward_char (count, ch);
      else
	rl_forward_byte (count, ch);
      break;

    case 'D':
      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
	rl_backward_char (count, ch);
      else
	rl_backward_byte (count, ch);
      break;

    default:
      rl_ding ();
    }

  return 0;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\text.c:617
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\text.c:671
parsing error 
{
  register int i;
  char *string;
#ifdef HANDLE_MULTIBYTE
  int string_size;
  char incoming[MB_LEN_MAX + 1];
  int incoming_length = 0;
  mbstate_t ps_back;
  static int stored_count = 0;
#endif

  if (count <= 0)
    return 0;

#if defined (HANDLE_MULTIBYTE)
  if (MB_CUR_MAX == 1 || rl_byte_oriented)
    {
      incoming[0] = c;
      incoming[1] = '\0';
      incoming_length = 1;
    }
  else
    {
      wchar_t wc;
      size_t ret;

      if (stored_count <= 0)
	stored_count = count;
      else
	count = stored_count;

      ps_back = ps;
      pending_bytes[pending_bytes_length++] = c;
      ret = mbrtowc (&wc, pending_bytes, pending_bytes_length, &ps);

      if (ret == (size_t)-2)
	{
	  /* Bytes too short to compose character, try to wait for next byte.
	     Restore the state of the byte sequence, because in this case the
	     effect of mbstate is undefined. */
	  ps = ps_back;
	  return 1;
	}
      else if (ret == (size_t)-1)
	{
	  /* Invalid byte sequence for the current locale.  Treat first byte
	     as a single character. */
	  incoming[0] = pending_bytes[0];
	  incoming[1] = '\0';
	  incoming_length = 1;
	  pending_bytes_length--;
	  memmove (pending_bytes, pending_bytes + 1, pending_bytes_length);
	  /* Clear the state of the byte sequence, because in this case the
	     effect of mbstate is undefined. */
	  memset (&ps, 0, sizeof (mbstate_t));
	}
      else if (ret == (size_t)0)
	{
	  incoming[0] = '\0';
	  incoming_length = 0;
	  pending_bytes_length--;
	  /* Clear the state of the byte sequence, because in this case the
	     effect of mbstate is undefined. */
	  memset (&ps, 0, sizeof (mbstate_t));
	}
      else
	{
	  /* We successfully read a single multibyte character. */
	  memcpy (incoming, pending_bytes, pending_bytes_length);
	  incoming[pending_bytes_length] = '\0';
	  incoming_length = pending_bytes_length;
	  pending_bytes_length = 0;
	}
    }
#endif /* HANDLE_MULTIBYTE */
	  
  /* If we can optimize, then do it.  But don't let people crash
     readline because of extra large arguments. */
  if (count > 1 && count <= TEXT_COUNT_MAX)
    {
#if defined (HANDLE_MULTIBYTE)
      string_size = count * incoming_length;
      string = (char *)xmalloc (1 + string_size);

      i = 0;
      while (i < string_size)
	{
	  strncpy (string + i, incoming, incoming_length);
	  i += incoming_length;
	}
      incoming_length = 0;
      stored_count = 0;
#else /* !HANDLE_MULTIBYTE */
      string = (char *)xmalloc (1 + count);

      for (i = 0; i < count; i++)
	string[i] = c;
#endif /* !HANDLE_MULTIBYTE */

      string[i] = '\0';
      rl_insert_text (string);
      xfree (string);

      return 0;
    }

  if (count > TEXT_COUNT_MAX)
    {
      int decreaser;
#if defined (HANDLE_MULTIBYTE)
      string_size = incoming_length * TEXT_COUNT_MAX;
      string = (char *)xmalloc (1 + string_size);

      i = 0;
      while (i < string_size)
	{
	  strncpy (string + i, incoming, incoming_length);
	  i += incoming_length;
	}

      while (count)
	{
	  decreaser = (count > TEXT_COUNT_MAX) ? TEXT_COUNT_MAX : count;
	  string[decreaser*incoming_length] = '\0';
	  rl_insert_text (string);
	  count -= decreaser;
	}

      xfree (string);
      incoming_length = 0;
      stored_count = 0;
#else /* !HANDLE_MULTIBYTE */
      char str[TEXT_COUNT_MAX+1];

      for (i = 0; i < TEXT_COUNT_MAX; i++)
	str[i] = c;

      while (count)
	{
	  decreaser = (count > TEXT_COUNT_MAX ? TEXT_COUNT_MAX : count);
	  str[decreaser] = '\0';
	  rl_insert_text (str);
	  count -= decreaser;
	}
#endif /* !HANDLE_MULTIBYTE */

      return 0;
    }

  if (MB_CUR_MAX == 1 || rl_byte_oriented)
    {
      /* We are inserting a single character.
	 If there is pending input, then make a string of all of the
	 pending characters that are bound to rl_insert, and insert
	 them all.  Don't do this if we're current reading input from
	 a macro. */
      if ((RL_ISSTATE (RL_STATE_MACROINPUT) == 0) && _rl_any_typein ())
	_rl_insert_typein (c);
      else
	{
	  /* Inserting a single character. */
	  char str[2];

	  str[1] = '\0';
	  str[0] = c;
	  rl_insert_text (str);
	}
    }
#if defined (HANDLE_MULTIBYTE)
  else
    {
      rl_insert_text (incoming);
      stored_count = 0;
    }
#endif

  return 0;
}
warning: parse error {
  register int i;
  char *string;
#ifdef HANDLE_MULTIBYTE
  int string_size;
  char incoming[MB_LEN_MAX + 1];
  int incoming_length = 0;
  mbstate_t ps_back;
  static int stored_count = 0;
#endif

  if (count <= 0)
    return 0;

#if defined (HANDLE_MULTIBYTE)
  if (MB_CUR_MAX == 1 || rl_byte_oriented)
    {
      incoming[0] = c;
      incoming[1] = '\0';
      incoming_length = 1;
    }
  else
    {
      wchar_t wc;
      size_t ret;

      if (stored_count <= 0)
	stored_count = count;
      else
	count = stored_count;

      ps_back = ps;
      pending_bytes[pending_bytes_length++] = c;
      ret = mbrtowc (&wc, pending_bytes, pending_bytes_length, &ps);

      if (ret == (size_t)-2)
	{
	  /* Bytes too short to compose character, try to wait for next byte.
	     Restore the state of the byte sequence, because in this case the
	     effect of mbstate is undefined. */
	  ps = ps_back;
	  return 1;
	}
      else if (ret == (size_t)-1)
	{
	  /* Invalid byte sequence for the current locale.  Treat first byte
	     as a single character. */
	  incoming[0] = pending_bytes[0];
	  incoming[1] = '\0';
	  incoming_length = 1;
	  pending_bytes_length--;
	  memmove (pending_bytes, pending_bytes + 1, pending_bytes_length);
	  /* Clear the state of the byte sequence, because in this case the
	     effect of mbstate is undefined. */
	  memset (&ps, 0, sizeof (mbstate_t));
	}
      else if (ret == (size_t)0)
	{
	  incoming[0] = '\0';
	  incoming_length = 0;
	  pending_bytes_length--;
	  /* Clear the state of the byte sequence, because in this case the
	     effect of mbstate is undefined. */
	  memset (&ps, 0, sizeof (mbstate_t));
	}
      else
	{
	  /* We successfully read a single multibyte character. */
	  memcpy (incoming, pending_bytes, pending_bytes_length);
	  incoming[pending_bytes_length] = '\0';
	  incoming_length = pending_bytes_length;
	  pending_bytes_length = 0;
	}
    }
#endif /* HANDLE_MULTIBYTE */
	  
  /* If we can optimize, then do it.  But don't let people crash
     readline because of extra large arguments. */
  if (count > 1 && count <= TEXT_COUNT_MAX)
    {
#if defined (HANDLE_MULTIBYTE)
      string_size = count * incoming_length;
      string = (char *)xmalloc (1 + string_size);

      i = 0;
      while (i < string_size)
	{
	  strncpy (string + i, incoming, incoming_length);
	  i += incoming_length;
	}
      incoming_length = 0;
      stored_count = 0;
#else /* !HANDLE_MULTIBYTE */
      string = (char *)xmalloc (1 + count);

      for (i = 0; i < count; i++)
	string[i] = c;
#endif /* !HANDLE_MULTIBYTE */

      string[i] = '\0';
      rl_insert_text (string);
      xfree (string);

      return 0;
    }

  if (count > TEXT_COUNT_MAX)
    {
      int decreaser;
#if defined (HANDLE_MULTIBYTE)
      string_size = incoming_length * TEXT_COUNT_MAX;
      string = (char *)xmalloc (1 + string_size);

      i = 0;
      while (i < string_size)
	{
	  strncpy (string + i, incoming, incoming_length);
	  i += incoming_length;
	}

      while (count)
	{
	  decreaser = (count > TEXT_COUNT_MAX) ? TEXT_COUNT_MAX : count;
	  string[decreaser*incoming_length] = '\0';
	  rl_insert_text (string);
	  count -= decreaser;
	}

      xfree (string);
      incoming_length = 0;
      stored_count = 0;
#else /* !HANDLE_MULTIBYTE */
      char str[TEXT_COUNT_MAX+1];

      for (i = 0; i < TEXT_COUNT_MAX; i++)
	str[i] = c;

      while (count)
	{
	  decreaser = (count > TEXT_COUNT_MAX ? TEXT_COUNT_MAX : count);
	  str[decreaser] = '\0';
	  rl_insert_text (str);
	  count -= decreaser;
	}
#endif /* !HANDLE_MULTIBYTE */

      return 0;
    }

  if (MB_CUR_MAX == 1 || rl_byte_oriented)
    {
      /* We are inserting a single character.
	 If there is pending input, then make a string of all of the
	 pending characters that are bound to rl_insert, and insert
	 them all.  Don't do this if we're current reading input from
	 a macro. */
      if ((RL_ISSTATE (RL_STATE_MACROINPUT) == 0) && _rl_any_typein ())
	_rl_insert_typein (c);
      else
	{
	  /* Inserting a single character. */
	  char str[2];

	  str[1] = '\0';
	  str[0] = c;
	  rl_insert_text (str);
	}
    }
#if defined (HANDLE_MULTIBYTE)
  else
    {
      rl_insert_text (incoming);
      stored_count = 0;
    }
#endif

  return 0;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\text.c:673
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\text.c:856
parsing error 
{
  int i;
#if defined (HANDLE_MULTIBYTE)
  char mbkey[MB_LEN_MAX];
  int k;

  /* Read an entire multibyte character sequence to insert COUNT times. */
  if (count > 0 && MB_CUR_MAX > 1 && rl_byte_oriented == 0)
    k = _rl_read_mbstring (c, mbkey, MB_LEN_MAX);
#endif

  rl_begin_undo_group ();

  for (i = 0; i < count; i++)
    {
#if defined (HANDLE_MULTIBYTE)
      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
	rl_insert_text (mbkey);
      else
#endif
	_rl_insert_char (1, c);

      if (rl_point < rl_end)
	rl_delete (1, c);
    }

  rl_end_undo_group ();

  return 0;
}
warning: parse error {
  int i;
#if defined (HANDLE_MULTIBYTE)
  char mbkey[MB_LEN_MAX];
  int k;

  /* Read an entire multibyte character sequence to insert COUNT times. */
  if (count > 0 && MB_CUR_MAX > 1 && rl_byte_oriented == 0)
    k = _rl_read_mbstring (c, mbkey, MB_LEN_MAX);
#endif

  rl_begin_undo_group ();

  for (i = 0; i < count; i++)
    {
#if defined (HANDLE_MULTIBYTE)
      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
	rl_insert_text (mbkey);
      else
#endif
	_rl_insert_char (1, c);

      if (rl_point < rl_end)
	rl_delete (1, c);
    }

  rl_end_undo_group ();

  return 0;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\text.c:858
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\text.c:890
parsing error 
{
  return (rl_insert_mode == RL_IM_INSERT ? _rl_insert_char (count, c)
  					 : _rl_overwrite_char (count, c));
}
warning: parse error {
  return (rl_insert_mode == RL_IM_INSERT ? _rl_insert_char (count, c)
  					 : _rl_overwrite_char (count, c));
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\text.c:892
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\text.c:899
parsing error 
{
  int c;

  RL_SETSTATE(RL_STATE_MOREINPUT);
  c = rl_read_key ();
  RL_UNSETSTATE(RL_STATE_MOREINPUT);

  if (c < 0)
    return -1;

#if defined (HANDLE_SIGNALS)
  if (RL_ISSTATE (RL_STATE_CALLBACK) == 0)
    _rl_restore_tty_signals ();
#endif

  return (_rl_insert_char (count, c));  
}
warning: parse error {
  int c;

  RL_SETSTATE(RL_STATE_MOREINPUT);
  c = rl_read_key ();
  RL_UNSETSTATE(RL_STATE_MOREINPUT);

  if (c < 0)
    return -1;

#if defined (HANDLE_SIGNALS)
  if (RL_ISSTATE (RL_STATE_CALLBACK) == 0)
    _rl_restore_tty_signals ();
#endif

  return (_rl_insert_char (count, c));  
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\text.c:901
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\text.c:921
parsing error 
{
  int count;

  count = data->count;

  /* Deregister function, let rl_callback_read_char deallocate data */
  _rl_callback_func = 0;
  _rl_want_redisplay = 1;
 
  return _rl_insert_next (count);
}
warning: parse error {
  int count;

  count = data->count;

  /* Deregister function, let rl_callback_read_char deallocate data */
  _rl_callback_func = 0;
  _rl_want_redisplay = 1;
 
  return _rl_insert_next (count);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\text.c:923
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\text.c:937
parsing error 
{
  /* Let's see...should the callback interface futz with signal handling? */
#if defined (HANDLE_SIGNALS)
  if (RL_ISSTATE (RL_STATE_CALLBACK) == 0)
    _rl_disable_tty_signals ();
#endif

#if defined (READLINE_CALLBACKS)
  if (RL_ISSTATE (RL_STATE_CALLBACK))
    {
      _rl_callback_data = _rl_callback_data_alloc (count);
      _rl_callback_func = _rl_insert_next_callback;
      return (0);
    }
#endif
      
  return _rl_insert_next (count);
}
warning: parse error {
  /* Let's see...should the callback interface futz with signal handling? */
#if defined (HANDLE_SIGNALS)
  if (RL_ISSTATE (RL_STATE_CALLBACK) == 0)
    _rl_disable_tty_signals ();
#endif

#if defined (READLINE_CALLBACKS)
  if (RL_ISSTATE (RL_STATE_CALLBACK))
    {
      _rl_callback_data = _rl_callback_data_alloc (count);
      _rl_callback_func = _rl_insert_next_callback;
      return (0);
    }
#endif
      
  return _rl_insert_next (count);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\text.c:939
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\text.c:960
parsing error 
{
  return (_rl_insert_char (count, '\t'));
}
warning: parse error {
  return (_rl_insert_char (count, '\t'));
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\text.c:962
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\text.c:970
parsing error 
{
  rl_done = 1;

  if (_rl_history_preserve_point)
    _rl_history_saved_point = (rl_point == rl_end) ? -1 : rl_point;

  RL_SETSTATE(RL_STATE_DONE);

#if defined (VI_MODE)
  if (rl_editing_mode == vi_mode)
    {
      _rl_vi_done_inserting ();
      if (_rl_vi_textmod_command (_rl_vi_last_command) == 0)	/* XXX */
	_rl_vi_reset_last ();
    }
#endif /* VI_MODE */

  /* If we've been asked to erase empty lines, suppress the final update,
     since _rl_update_final calls rl_crlf(). */
  if (rl_erase_empty_line && rl_point == 0 && rl_end == 0)
    return 0;

  if (_rl_echoing_p)
    _rl_update_final ();
  return 0;
}
warning: parse error {
  rl_done = 1;

  if (_rl_history_preserve_point)
    _rl_history_saved_point = (rl_point == rl_end) ? -1 : rl_point;

  RL_SETSTATE(RL_STATE_DONE);

#if defined (VI_MODE)
  if (rl_editing_mode == vi_mode)
    {
      _rl_vi_done_inserting ();
      if (_rl_vi_textmod_command (_rl_vi_last_command) == 0)	/* XXX */
	_rl_vi_reset_last ();
    }
#endif /* VI_MODE */

  /* If we've been asked to erase empty lines, suppress the final update,
     since _rl_update_final calls rl_crlf(). */
  if (rl_erase_empty_line && rl_point == 0 && rl_end == 0)
    return 0;

  if (_rl_echoing_p)
    _rl_update_final ();
  return 0;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\text.c:972
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\text.c:1,004
parsing error 
{
  return 0;
}
warning: parse error {
  return 0;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\text.c:1,006
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\text.c:1,014
parsing error 
{
  int opoint;
  int i, l;

  if (rl_point == 0)
    {
      rl_ding ();
      return 1;
    }

  opoint = rl_point;

  /* L == number of spaces to insert */
  for (i = l = 0; i < count; i++)
    {
      rl_backward_char (1, key);
      l += rl_character_len (rl_line_buffer[rl_point], rl_point);	/* not exactly right */
    }

  rl_begin_undo_group ();

  if (count > 1 || rl_explicit_arg)
    rl_kill_text (opoint, rl_point);
  else
    rl_delete_text (opoint, rl_point);

  /* Emacs puts point at the beginning of the sequence of spaces. */
  if (rl_point < rl_end)
    {
      opoint = rl_point;
      _rl_insert_char (l, ' ');
      rl_point = opoint;
    }

  rl_end_undo_group ();

  return 0;
}
warning: parse error {
  int opoint;
  int i, l;

  if (rl_point == 0)
    {
      rl_ding ();
      return 1;
    }

  opoint = rl_point;

  /* L == number of spaces to insert */
  for (i = l = 0; i < count; i++)
    {
      rl_backward_char (1, key);
      l += rl_character_len (rl_line_buffer[rl_point], rl_point);	/* not exactly right */
    }

  rl_begin_undo_group ();

  if (count > 1 || rl_explicit_arg)
    rl_kill_text (opoint, rl_point);
  else
    rl_delete_text (opoint, rl_point);

  /* Emacs puts point at the beginning of the sequence of spaces. */
  if (rl_point < rl_end)
    {
      opoint = rl_point;
      _rl_insert_char (l, ' ');
      rl_point = opoint;
    }

  rl_end_undo_group ();

  return 0;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\text.c:1,016
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\text.c:1,057
parsing error 
{
  if (count < 0)
    return (rl_delete (-count, key));

  if (!rl_point)
    {
      rl_ding ();
      return -1;
    }

  if (rl_insert_mode == RL_IM_OVERWRITE)
    return (_rl_overwrite_rubout (count, key));

  return (_rl_rubout_char (count, key));
}
warning: parse error {
  if (count < 0)
    return (rl_delete (-count, key));

  if (!rl_point)
    {
      rl_ding ();
      return -1;
    }

  if (rl_insert_mode == RL_IM_OVERWRITE)
    return (_rl_overwrite_rubout (count, key));

  return (_rl_rubout_char (count, key));
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\text.c:1,059
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\text.c:1,076
parsing error 
{
  int orig_point;
  unsigned char c;

  /* Duplicated code because this is called from other parts of the library. */
  if (count < 0)
    return (rl_delete (-count, key));

  if (rl_point == 0)
    {
      rl_ding ();
      return -1;
    }

  orig_point = rl_point;
  if (count > 1 || rl_explicit_arg)
    {
      rl_backward_char (count, key);
      rl_kill_text (orig_point, rl_point);
    }
  else if (MB_CUR_MAX == 1 || rl_byte_oriented)
    {
      c = rl_line_buffer[--rl_point];
      rl_delete_text (rl_point, orig_point);
      /* The erase-at-end-of-line hack is of questionable merit now. */
      if (rl_point == rl_end && ISPRINT (c) && _rl_last_c_pos)
	{
	  int l;
	  l = rl_character_len (c, rl_point);
	  _rl_erase_at_end_of_line (l);
	}
    }
  else
    {
      rl_point = _rl_find_prev_mbchar (rl_line_buffer, rl_point, MB_FIND_NONZERO);
      rl_delete_text (rl_point, orig_point);
    }

  return 0;
}
warning: parse error {
  int orig_point;
  unsigned char c;

  /* Duplicated code because this is called from other parts of the library. */
  if (count < 0)
    return (rl_delete (-count, key));

  if (rl_point == 0)
    {
      rl_ding ();
      return -1;
    }

  orig_point = rl_point;
  if (count > 1 || rl_explicit_arg)
    {
      rl_backward_char (count, key);
      rl_kill_text (orig_point, rl_point);
    }
  else if (MB_CUR_MAX == 1 || rl_byte_oriented)
    {
      c = rl_line_buffer[--rl_point];
      rl_delete_text (rl_point, orig_point);
      /* The erase-at-end-of-line hack is of questionable merit now. */
      if (rl_point == rl_end && ISPRINT (c) && _rl_last_c_pos)
	{
	  int l;
	  l = rl_character_len (c, rl_point);
	  _rl_erase_at_end_of_line (l);
	}
    }
  else
    {
      rl_point = _rl_find_prev_mbchar (rl_line_buffer, rl_point, MB_FIND_NONZERO);
      rl_delete_text (rl_point, orig_point);
    }

  return 0;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\text.c:1,078
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\text.c:1,122
parsing error 
{
  int xpoint;

  if (count < 0)
    return (_rl_rubout_char (-count, key));

  if (rl_point == rl_end)
    {
      rl_ding ();
      return -1;
    }

  if (count > 1 || rl_explicit_arg)
    {
      xpoint = rl_point;
      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
	rl_forward_char (count, key);
      else
	rl_forward_byte (count, key);

      rl_kill_text (xpoint, rl_point);
      rl_point = xpoint;
    }
  else
    {
      xpoint = MB_NEXTCHAR (rl_line_buffer, rl_point, 1, MB_FIND_NONZERO);
      rl_delete_text (rl_point, xpoint);
    }
  return 0;
}
warning: parse error {
  int xpoint;

  if (count < 0)
    return (_rl_rubout_char (-count, key));

  if (rl_point == rl_end)
    {
      rl_ding ();
      return -1;
    }

  if (count > 1 || rl_explicit_arg)
    {
      xpoint = rl_point;
      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
	rl_forward_char (count, key);
      else
	rl_forward_byte (count, key);

      rl_kill_text (xpoint, rl_point);
      rl_point = xpoint;
    }
  else
    {
      xpoint = MB_NEXTCHAR (rl_line_buffer, rl_point, 1, MB_FIND_NONZERO);
      rl_delete_text (rl_point, xpoint);
    }
  return 0;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\text.c:1,124
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\text.c:1,160
parsing error 
{
  if (rl_end != 0 && rl_point == rl_end)
    return (_rl_rubout_char (count, key));
  else
    return (rl_delete (count, key));
}
warning: parse error {
  if (rl_end != 0 && rl_point == rl_end)
    return (_rl_rubout_char (count, key));
  else
    return (rl_delete (count, key));
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\text.c:1,162
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\text.c:1,171
parsing error 
{
  int start;

  while (rl_point && whitespace (rl_line_buffer[rl_point - 1]))
    rl_point--;

  start = rl_point;

  while (rl_point < rl_end && whitespace (rl_line_buffer[rl_point]))
    rl_point++;

  if (start != rl_point)
    {
      rl_delete_text (start, rl_point);
      rl_point = start;
    }

  if (rl_point < 0)
    rl_point = 0;

  return 0;
}
warning: parse error {
  int start;

  while (rl_point && whitespace (rl_line_buffer[rl_point - 1]))
    rl_point--;

  start = rl_point;

  while (rl_point < rl_end && whitespace (rl_line_buffer[rl_point]))
    rl_point++;

  if (start != rl_point)
    {
      rl_delete_text (start, rl_point);
      rl_point = start;
    }

  if (rl_point < 0)
    rl_point = 0;

  return 0;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\text.c:1,173
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\text.c:1,200
parsing error 
{
  if (rl_end != 0 && rl_point == rl_end)
    return (rl_possible_completions (count, key));
  else
    return (rl_delete (count, key));
}
warning: parse error {
  if (rl_end != 0 && rl_point == rl_end)
    return (rl_possible_completions (count, key));
  else
    return (rl_delete (count, key));
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\text.c:1,202
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\text.c:1,216
parsing error 
{
  char *rl_comment_text;
  int rl_comment_len;

  rl_beg_of_line (1, key);
  rl_comment_text = _rl_comment_begin ? _rl_comment_begin : RL_COMMENT_BEGIN_DEFAULT;

  if (rl_explicit_arg == 0)
    rl_insert_text (rl_comment_text);
  else
    {
      rl_comment_len = strlen (rl_comment_text);
      if (STREQN (rl_comment_text, rl_line_buffer, rl_comment_len))
	rl_delete_text (rl_point, rl_point + rl_comment_len);
      else
	rl_insert_text (rl_comment_text);
    }

  (*rl_redisplay_function) ();
  rl_newline (1, '\n');

  return (0);
}
warning: parse error {
  char *rl_comment_text;
  int rl_comment_len;

  rl_beg_of_line (1, key);
  rl_comment_text = _rl_comment_begin ? _rl_comment_begin : RL_COMMENT_BEGIN_DEFAULT;

  if (rl_explicit_arg == 0)
    rl_insert_text (rl_comment_text);
  else
    {
      rl_comment_len = strlen (rl_comment_text);
      if (STREQN (rl_comment_text, rl_line_buffer, rl_comment_len))
	rl_delete_text (rl_point, rl_point + rl_comment_len);
      else
	rl_insert_text (rl_comment_text);
    }

  (*rl_redisplay_function) ();
  rl_newline (1, '\n');

  return (0);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\text.c:1,218
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\text.c:1,255
parsing error 
{
  return (rl_change_case (count, UpCase));
}
warning: parse error {
  return (rl_change_case (count, UpCase));
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\text.c:1,257
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\text.c:1,263
parsing error 
{
  return (rl_change_case (count, DownCase));
}
warning: parse error {
  return (rl_change_case (count, DownCase));
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\text.c:1,265
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\text.c:1,271
parsing error 
{
 return (rl_change_case (count, CapCase));
}
warning: parse error {
 return (rl_change_case (count, CapCase));
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\text.c:1,273
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\text.c:1,283
parsing error 
{
  int start, next, end;
  int inword, c, nc, nop;
#if defined (HANDLE_MULTIBYTE)
  wchar_t wc, nwc;
  char mb[MB_LEN_MAX+1];
  int mlen;
  size_t m;
  mbstate_t mps;
#endif

  start = rl_point;
  rl_forward_word (count, 0);
  end = rl_point;

  if (op != UpCase && op != DownCase && op != CapCase)
    {
      rl_ding ();
      return -1;
    }

  if (count < 0)
    SWAP (start, end);

#if defined (HANDLE_MULTIBYTE)
  memset (&mps, 0, sizeof (mbstate_t));
#endif

  /* We are going to modify some text, so let's prepare to undo it. */
  rl_modifying (start, end);

  inword = 0;
  while (start < end)
    {
      c = _rl_char_value (rl_line_buffer, start);
      /*  This assumes that the upper and lower case versions are the same width. */
      next = MB_NEXTCHAR (rl_line_buffer, start, 1, MB_FIND_NONZERO);

      if (_rl_walphabetic (c) == 0)
	{
	  inword = 0;
	  start = next;
	  continue;
	}

      if (op == CapCase)
	{
	  nop = inword ? DownCase : UpCase;
	  inword = 1;
	}
      else
	nop = op;
      if (MB_CUR_MAX == 1 || rl_byte_oriented || isascii (c))
	{
	  nc = (nop == UpCase) ? _rl_to_upper (c) : _rl_to_lower (c);
	  rl_line_buffer[start] = nc;
	}
#if defined (HANDLE_MULTIBYTE)
      else
	{
	  m = mbrtowc (&wc, rl_line_buffer + start, end - start, &mps);
	  if (MB_INVALIDCH (m))
	    wc = (wchar_t)rl_line_buffer[start];
	  else if (MB_NULLWCH (m))
	    wc = L'\0';
	  nwc = (nop == UpCase) ? _rl_to_wupper (wc) : _rl_to_wlower (wc);
	  if  (nwc != wc)	/*  just skip unchanged characters */
	    {
	      mlen = wcrtomb (mb, nwc, &mps);
	      if (mlen > 0)
		mb[mlen] = '\0';
	      /* Assume the same width */
	      strncpy (rl_line_buffer + start, mb, mlen);
	    }
	}
#endif

      start = next;
    }

  rl_point = end;
  return 0;
}
warning: parse error {
  int start, next, end;
  int inword, c, nc, nop;
#if defined (HANDLE_MULTIBYTE)
  wchar_t wc, nwc;
  char mb[MB_LEN_MAX+1];
  int mlen;
  size_t m;
  mbstate_t mps;
#endif

  start = rl_point;
  rl_forward_word (count, 0);
  end = rl_point;

  if (op != UpCase && op != DownCase && op != CapCase)
    {
      rl_ding ();
      return -1;
    }

  if (count < 0)
    SWAP (start, end);

#if defined (HANDLE_MULTIBYTE)
  memset (&mps, 0, sizeof (mbstate_t));
#endif

  /* We are going to modify some text, so let's prepare to undo it. */
  rl_modifying (start, end);

  inword = 0;
  while (start < end)
    {
      c = _rl_char_value (rl_line_buffer, start);
      /*  This assumes that the upper and lower case versions are the same width. */
      next = MB_NEXTCHAR (rl_line_buffer, start, 1, MB_FIND_NONZERO);

      if (_rl_walphabetic (c) == 0)
	{
	  inword = 0;
	  start = next;
	  continue;
	}

      if (op == CapCase)
	{
	  nop = inword ? DownCase : UpCase;
	  inword = 1;
	}
      else
	nop = op;
      if (MB_CUR_MAX == 1 || rl_byte_oriented || isascii (c))
	{
	  nc = (nop == UpCase) ? _rl_to_upper (c) : _rl_to_lower (c);
	  rl_line_buffer[start] = nc;
	}
#if defined (HANDLE_MULTIBYTE)
      else
	{
	  m = mbrtowc (&wc, rl_line_buffer + start, end - start, &mps);
	  if (MB_INVALIDCH (m))
	    wc = (wchar_t)rl_line_buffer[start];
	  else if (MB_NULLWCH (m))
	    wc = L'\0';
	  nwc = (nop == UpCase) ? _rl_to_wupper (wc) : _rl_to_wlower (wc);
	  if  (nwc != wc)	/*  just skip unchanged characters */
	    {
	      mlen = wcrtomb (mb, nwc, &mps);
	      if (mlen > 0)
		mb[mlen] = '\0';
	      /* Assume the same width */
	      strncpy (rl_line_buffer + start, mb, mlen);
	    }
	}
#endif

      start = next;
    }

  rl_point = end;
  return 0;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\text.c:1,285
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\text.c:1,378
parsing error 
{
  char *word1, *word2;
  int w1_beg, w1_end, w2_beg, w2_end;
  int orig_point = rl_point;

  if (!count)
    return 0;

  /* Find the two words. */
  rl_forward_word (count, key);
  w2_end = rl_point;
  rl_backward_word (1, key);
  w2_beg = rl_point;
  rl_backward_word (count, key);
  w1_beg = rl_point;
  rl_forward_word (1, key);
  w1_end = rl_point;

  /* Do some check to make sure that there really are two words. */
  if ((w1_beg == w2_beg) || (w2_beg < w1_end))
    {
      rl_ding ();
      rl_point = orig_point;
      return -1;
    }

  /* Get the text of the words. */
  word1 = rl_copy_text (w1_beg, w1_end);
  word2 = rl_copy_text (w2_beg, w2_end);

  /* We are about to do many insertions and deletions.  Remember them
     as one operation. */
  rl_begin_undo_group ();

  /* Do the stuff at word2 first, so that we don't have to worry
     about word1 moving. */
  rl_point = w2_beg;
  rl_delete_text (w2_beg, w2_end);
  rl_insert_text (word1);

  rl_point = w1_beg;
  rl_delete_text (w1_beg, w1_end);
  rl_insert_text (word2);

  /* This is exactly correct since the text before this point has not
     changed in length. */
  rl_point = w2_end;

  /* I think that does it. */
  rl_end_undo_group ();
  xfree (word1);
  xfree (word2);

  return 0;
}
warning: parse error {
  char *word1, *word2;
  int w1_beg, w1_end, w2_beg, w2_end;
  int orig_point = rl_point;

  if (!count)
    return 0;

  /* Find the two words. */
  rl_forward_word (count, key);
  w2_end = rl_point;
  rl_backward_word (1, key);
  w2_beg = rl_point;
  rl_backward_word (count, key);
  w1_beg = rl_point;
  rl_forward_word (1, key);
  w1_end = rl_point;

  /* Do some check to make sure that there really are two words. */
  if ((w1_beg == w2_beg) || (w2_beg < w1_end))
    {
      rl_ding ();
      rl_point = orig_point;
      return -1;
    }

  /* Get the text of the words. */
  word1 = rl_copy_text (w1_beg, w1_end);
  word2 = rl_copy_text (w2_beg, w2_end);

  /* We are about to do many insertions and deletions.  Remember them
     as one operation. */
  rl_begin_undo_group ();

  /* Do the stuff at word2 first, so that we don't have to worry
     about word1 moving. */
  rl_point = w2_beg;
  rl_delete_text (w2_beg, w2_end);
  rl_insert_text (word1);

  rl_point = w1_beg;
  rl_delete_text (w1_beg, w1_end);
  rl_insert_text (word2);

  /* This is exactly correct since the text before this point has not
     changed in length. */
  rl_point = w2_end;

  /* I think that does it. */
  rl_end_undo_group ();
  xfree (word1);
  xfree (word2);

  return 0;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\text.c:1,380
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\text.c:1,439
parsing error 
{
#if defined (HANDLE_MULTIBYTE)
  char *dummy;
  int i;
#else
  char dummy[2];
#endif
  int char_length, prev_point;

  if (count == 0)
    return 0;

  if (!rl_point || rl_end < 2)
    {
      rl_ding ();
      return -1;
    }

  rl_begin_undo_group ();

  if (rl_point == rl_end)
    {
      rl_point = MB_PREVCHAR (rl_line_buffer, rl_point, MB_FIND_NONZERO);
      count = 1;
    }

  prev_point = rl_point;
  rl_point = MB_PREVCHAR (rl_line_buffer, rl_point, MB_FIND_NONZERO);

#if defined (HANDLE_MULTIBYTE)
  char_length = prev_point - rl_point;
  dummy = (char *)xmalloc (char_length + 1);
  for (i = 0; i < char_length; i++)
    dummy[i] = rl_line_buffer[rl_point + i];
  dummy[i] = '\0';
#else
  dummy[0] = rl_line_buffer[rl_point];
  dummy[char_length = 1] = '\0';
#endif

  rl_delete_text (rl_point, rl_point + char_length);

  rl_point = _rl_find_next_mbchar (rl_line_buffer, rl_point, count, MB_FIND_NONZERO);

  _rl_fix_point (0);
  rl_insert_text (dummy);
  rl_end_undo_group ();

#if defined (HANDLE_MULTIBYTE)
  xfree (dummy);
#endif

  return 0;
}
warning: parse error {
#if defined (HANDLE_MULTIBYTE)
  char *dummy;
  int i;
#else
  char dummy[2];
#endif
  int char_length, prev_point;

  if (count == 0)
    return 0;

  if (!rl_point || rl_end < 2)
    {
      rl_ding ();
      return -1;
    }

  rl_begin_undo_group ();

  if (rl_point == rl_end)
    {
      rl_point = MB_PREVCHAR (rl_line_buffer, rl_point, MB_FIND_NONZERO);
      count = 1;
    }

  prev_point = rl_point;
  rl_point = MB_PREVCHAR (rl_line_buffer, rl_point, MB_FIND_NONZERO);

#if defined (HANDLE_MULTIBYTE)
  char_length = prev_point - rl_point;
  dummy = (char *)xmalloc (char_length + 1);
  for (i = 0; i < char_length; i++)
    dummy[i] = rl_line_buffer[rl_point + i];
  dummy[i] = '\0';
#else
  dummy[0] = rl_line_buffer[rl_point];
  dummy[char_length = 1] = '\0';
#endif

  rl_delete_text (rl_point, rl_point + char_length);

  rl_point = _rl_find_next_mbchar (rl_line_buffer, rl_point, count, MB_FIND_NONZERO);

  _rl_fix_point (0);
  rl_insert_text (dummy);
  rl_end_undo_group ();

#if defined (HANDLE_MULTIBYTE)
  xfree (dummy);
#endif

  return 0;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\text.c:1,441
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\text.c:1,504
parsing error 
{
  int pos, inc;
#if defined (HANDLE_MULTIBYTE)
  int prepos;
#endif

  if (dir == 0)
    return -1;

  pos = rl_point;
  inc = (dir < 0) ? -1 : 1;
  while (count)
    {
      if ((dir < 0 && pos <= 0) || (dir > 0 && pos >= rl_end))
	{
	  rl_ding ();
	  return -1;
	}

#if defined (HANDLE_MULTIBYTE)
      pos = (inc > 0) ? _rl_find_next_mbchar (rl_line_buffer, pos, 1, MB_FIND_ANY)
		      : _rl_find_prev_mbchar (rl_line_buffer, pos, MB_FIND_ANY);
#else
      pos += inc;
#endif
      do
	{
#if defined (HANDLE_MULTIBYTE)
	  if (_rl_is_mbchar_matched (rl_line_buffer, pos, rl_end, smbchar, len))
#else
	  if (rl_line_buffer[pos] == schar)
#endif
	    {
	      count--;
	      if (dir < 0)
	        rl_point = (dir == BTO) ? _rl_find_next_mbchar (rl_line_buffer, pos, 1, MB_FIND_ANY)
					: pos;
	      else
		rl_point = (dir == FTO) ? _rl_find_prev_mbchar (rl_line_buffer, pos, MB_FIND_ANY)
					: pos;
	      break;
	    }
#if defined (HANDLE_MULTIBYTE)
	  prepos = pos;
#endif
	}
#if defined (HANDLE_MULTIBYTE)
      while ((dir < 0) ? (pos = _rl_find_prev_mbchar (rl_line_buffer, pos, MB_FIND_ANY)) != prepos
		       : (pos = _rl_find_next_mbchar (rl_line_buffer, pos, 1, MB_FIND_ANY)) != prepos);
#else
      while ((dir < 0) ? pos-- : ++pos < rl_end);
#endif
    }
  return (0);
}
warning: parse error {
  int pos, inc;
#if defined (HANDLE_MULTIBYTE)
  int prepos;
#endif

  if (dir == 0)
    return -1;

  pos = rl_point;
  inc = (dir < 0) ? -1 : 1;
  while (count)
    {
      if ((dir < 0 && pos <= 0) || (dir > 0 && pos >= rl_end))
	{
	  rl_ding ();
	  return -1;
	}

#if defined (HANDLE_MULTIBYTE)
      pos = (inc > 0) ? _rl_find_next_mbchar (rl_line_buffer, pos, 1, MB_FIND_ANY)
		      : _rl_find_prev_mbchar (rl_line_buffer, pos, MB_FIND_ANY);
#else
      pos += inc;
#endif
      do
	{
#if defined (HANDLE_MULTIBYTE)
	  if (_rl_is_mbchar_matched (rl_line_buffer, pos, rl_end, smbchar, len))
#else
	  if (rl_line_buffer[pos] == schar)
#endif
	    {
	      count--;
	      if (dir < 0)
	        rl_point = (dir == BTO) ? _rl_find_next_mbchar (rl_line_buffer, pos, 1, MB_FIND_ANY)
					: pos;
	      else
		rl_point = (dir == FTO) ? _rl_find_prev_mbchar (rl_line_buffer, pos, MB_FIND_ANY)
					: pos;
	      break;
	    }
#if defined (HANDLE_MULTIBYTE)
	  prepos = pos;
#endif
	}
#if defined (HANDLE_MULTIBYTE)
      while ((dir < 0) ? (pos = _rl_find_prev_mbchar (rl_line_buffer, pos, MB_FIND_ANY)) != prepos
		       : (pos = _rl_find_next_mbchar (rl_line_buffer, pos, 1, MB_FIND_ANY)) != prepos);
#else
      while ((dir < 0) ? pos-- : ++pos < rl_end);
#endif
    }
  return (0);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\text.c:1,512
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\text.c:1,574
parsing error 
{
  char mbchar[MB_LEN_MAX];
  int mb_len;

  mb_len = _rl_read_mbchar (mbchar, MB_LEN_MAX);

  if (mb_len <= 0)
    return -1;

  if (count < 0)
    return (_rl_char_search_internal (-count, bdir, mbchar, mb_len));
  else
    return (_rl_char_search_internal (count, fdir, mbchar, mb_len));
}
warning: parse error {
  char mbchar[MB_LEN_MAX];
  int mb_len;

  mb_len = _rl_read_mbchar (mbchar, MB_LEN_MAX);

  if (mb_len <= 0)
    return -1;

  if (count < 0)
    return (_rl_char_search_internal (-count, bdir, mbchar, mb_len));
  else
    return (_rl_char_search_internal (count, fdir, mbchar, mb_len));
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\text.c:1,576
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\text.c:1,613
parsing error 
{
  _rl_callback_func = 0;
  _rl_want_redisplay = 1;

  return (_rl_char_search (data->count, data->i1, data->i2));
}
warning: parse error {
  _rl_callback_func = 0;
  _rl_want_redisplay = 1;

  return (_rl_char_search (data->count, data->i1, data->i2));
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\text.c:1,615
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\text.c:1,624
parsing error 
{
#if defined (READLINE_CALLBACKS)
  if (RL_ISSTATE (RL_STATE_CALLBACK))
    {
      _rl_callback_data = _rl_callback_data_alloc (count);
      _rl_callback_data->i1 = FFIND;
      _rl_callback_data->i2 = BFIND;
      _rl_callback_func = _rl_char_search_callback;
      return (0);
    }
#endif
  
  return (_rl_char_search (count, FFIND, BFIND));
}
warning: parse error {
#if defined (READLINE_CALLBACKS)
  if (RL_ISSTATE (RL_STATE_CALLBACK))
    {
      _rl_callback_data = _rl_callback_data_alloc (count);
      _rl_callback_data->i1 = FFIND;
      _rl_callback_data->i2 = BFIND;
      _rl_callback_func = _rl_char_search_callback;
      return (0);
    }
#endif
  
  return (_rl_char_search (count, FFIND, BFIND));
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\text.c:1,626
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\text.c:1,642
parsing error 
{
#if defined (READLINE_CALLBACKS)
  if (RL_ISSTATE (RL_STATE_CALLBACK))
    {
      _rl_callback_data = _rl_callback_data_alloc (count);
      _rl_callback_data->i1 = BFIND;
      _rl_callback_data->i2 = FFIND;
      _rl_callback_func = _rl_char_search_callback;
      return (0);
    }
#endif

  return (_rl_char_search (count, BFIND, FFIND));
}
warning: parse error {
#if defined (READLINE_CALLBACKS)
  if (RL_ISSTATE (RL_STATE_CALLBACK))
    {
      _rl_callback_data = _rl_callback_data_alloc (count);
      _rl_callback_data->i1 = BFIND;
      _rl_callback_data->i2 = FFIND;
      _rl_callback_func = _rl_char_search_callback;
      return (0);
    }
#endif

  return (_rl_char_search (count, BFIND, FFIND));
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\text.c:1,644
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\text.c:1,667
parsing error 
{
  if (position > rl_end)
    return -1;

  rl_mark = position;
  return 0;
}
warning: parse error {
  if (position > rl_end)
    return -1;

  rl_mark = position;
  return 0;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\text.c:1,669
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\text.c:1,679
parsing error 
{
  return (_rl_set_mark_at_pos (rl_explicit_arg ? count : rl_point));
}
warning: parse error {
  return (_rl_set_mark_at_pos (rl_explicit_arg ? count : rl_point));
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\text.c:1,681
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\text.c:1,687
parsing error 
{
  if (rl_mark > rl_end)
    rl_mark = -1;

  if (rl_mark == -1)
    {
      rl_ding ();
      return -1;
    }
  else
    SWAP (rl_point, rl_mark);

  return 0;
}
warning: parse error {
  if (rl_mark > rl_end)
    rl_mark = -1;

  if (rl_mark == -1)
    {
      rl_ding ();
      return -1;
    }
  else
    SWAP (rl_point, rl_mark);

  return 0;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\text.c:1,689
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\tilde.c...
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\tilde.h...
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\tilde.c:129
parsing error 
{
  register int i, j, string_len;
  register char **prefixes;

  prefixes = tilde_additional_prefixes;

  string_len = strlen (string);
  *len = 0;

  if (*string == '\0' || *string == '~')
    return (0);

  if (prefixes)
    {
      for (i = 0; i < string_len; i++)
	{
	  for (j = 0; prefixes[j]; j++)
	    {
	      if (strncmp (string + i, prefixes[j], strlen (prefixes[j])) == 0)
		{
		  *len = strlen (prefixes[j]) - 1;
		  return (i + *len);
		}
	    }
	}
    }
  return (string_len);
}
warning: parse error {
  register int i, j, string_len;
  register char **prefixes;

  prefixes = tilde_additional_prefixes;

  string_len = strlen (string);
  *len = 0;

  if (*string == '\0' || *string == '~')
    return (0);

  if (prefixes)
    {
      for (i = 0; i < string_len; i++)
	{
	  for (j = 0; prefixes[j]; j++)
	    {
	      if (strncmp (string + i, prefixes[j], strlen (prefixes[j])) == 0)
		{
		  *len = strlen (prefixes[j]) - 1;
		  return (i + *len);
		}
	    }
	}
    }
  return (string_len);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\tilde.c:131
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\tilde.c:164
parsing error 
{
  register int i, j, string_len;
  register char **suffixes;

  suffixes = tilde_additional_suffixes;
  string_len = strlen (string);

  for (i = 0; i < string_len; i++)
    {
#if defined (__MSDOS__)
      if (string[i] == '/' || string[i] == '\\' /* || !string[i] */)
#else
      if (string[i] == '/' /* || !string[i] */)
#endif
	break;

      for (j = 0; suffixes && suffixes[j]; j++)
	{
	  if (strncmp (string + i, suffixes[j], strlen (suffixes[j])) == 0)
	    return (i);
	}
    }
  return (i);
}
warning: parse error {
  register int i, j, string_len;
  register char **suffixes;

  suffixes = tilde_additional_suffixes;
  string_len = strlen (string);

  for (i = 0; i < string_len; i++)
    {
#if defined (__MSDOS__)
      if (string[i] == '/' || string[i] == '\\' /* || !string[i] */)
#else
      if (string[i] == '/' /* || !string[i] */)
#endif
	break;

      for (j = 0; suffixes && suffixes[j]; j++)
	{
	  if (strncmp (string + i, suffixes[j], strlen (suffixes[j])) == 0)
	    return (i);
	}
    }
  return (i);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\tilde.c:165
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\tilde.c:193
parsing error 
{
  char *result;
  int result_size, result_index;

  result_index = result_size = 0;
  if (result = strchr (string, '~'))
    result = (char *)xmalloc (result_size = (strlen (string) + 16));
  else
    result = (char *)xmalloc (result_size = (strlen (string) + 1));

  /* Scan through STRING expanding tildes as we come to them. */
  while (1)
    {
      register int start, end;
      char *tilde_word, *expansion;
      int len;

      /* Make START point to the tilde which starts the expansion. */
      start = tilde_find_prefix (string, &len);

      /* Copy the skipped text into the result. */
      if ((result_index + start + 1) > result_size)
	result = (char *)xrealloc (result, 1 + (result_size += (start + 20)));

      strncpy (result + result_index, string, start);
      result_index += start;

      /* Advance STRING to the starting tilde. */
      string += start;

      /* Make END be the index of one after the last character of the
	 username. */
      end = tilde_find_suffix (string);

      /* If both START and END are zero, we are all done. */
      if (!start && !end)
	break;

      /* Expand the entire tilde word, and copy it into RESULT. */
      tilde_word = (char *)xmalloc (1 + end);
      strncpy (tilde_word, string, end);
      tilde_word[end] = '\0';
      string += end;

      expansion = tilde_expand_word (tilde_word);
      xfree (tilde_word);

      len = strlen (expansion);
#ifdef __CYGWIN__
      /* Fix for Cygwin to prevent ~user/xxx from expanding to //xxx when
	 $HOME for `user' is /.  On cygwin, // denotes a network drive. */
      if (len > 1 || *expansion != '/' || *string != '/')
#endif
	{
	  if ((result_index + len + 1) > result_size)
	    result = (char *)xrealloc (result, 1 + (result_size += (len + 20)));

	  strcpy (result + result_index, expansion);
	  result_index += len;
	}
      xfree (expansion);
    }

  result[result_index] = '\0';

  return (result);
}
warning: parse error {
  char *result;
  int result_size, result_index;

  result_index = result_size = 0;
  if (result = strchr (string, '~'))
    result = (char *)xmalloc (result_size = (strlen (string) + 16));
  else
    result = (char *)xmalloc (result_size = (strlen (string) + 1));

  /* Scan through STRING expanding tildes as we come to them. */
  while (1)
    {
      register int start, end;
      char *tilde_word, *expansion;
      int len;

      /* Make START point to the tilde which starts the expansion. */
      start = tilde_find_prefix (string, &len);

      /* Copy the skipped text into the result. */
      if ((result_index + start + 1) > result_size)
	result = (char *)xrealloc (result, 1 + (result_size += (start + 20)));

      strncpy (result + result_index, string, start);
      result_index += start;

      /* Advance STRING to the starting tilde. */
      string += start;

      /* Make END be the index of one after the last character of the
	 username. */
      end = tilde_find_suffix (string);

      /* If both START and END are zero, we are all done. */
      if (!start && !end)
	break;

      /* Expand the entire tilde word, and copy it into RESULT. */
      tilde_word = (char *)xmalloc (1 + end);
      strncpy (tilde_word, string, end);
      tilde_word[end] = '\0';
      string += end;

      expansion = tilde_expand_word (tilde_word);
      xfree (tilde_word);

      len = strlen (expansion);
#ifdef __CYGWIN__
      /* Fix for Cygwin to prevent ~user/xxx from expanding to //xxx when
	 $HOME for `user' is /.  On cygwin, // denotes a network drive. */
      if (len > 1 || *expansion != '/' || *string != '/')
#endif
	{
	  if ((result_index + len + 1) > result_size)
	    result = (char *)xrealloc (result, 1 + (result_size += (len + 20)));

	  strcpy (result + result_index, expansion);
	  result_index += len;
	}
      xfree (expansion);
    }

  result[result_index] = '\0';

  return (result);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\tilde.c:194
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\tilde.c:267
parsing error 
{
  char *ret;
  int i;

  ret = (char *)xmalloc (strlen (fname));
#if defined (__MSDOS__)
  for (i = 1; fname[i] && fname[i] != '/' && fname[i] != '\\'; i++)
#else
  for (i = 1; fname[i] && fname[i] != '/'; i++)
#endif
    ret[i - 1] = fname[i];
  ret[i - 1] = '\0';
  if (lenp)
    *lenp = i;
  return ret;
}
warning: parse error {
  char *ret;
  int i;

  ret = (char *)xmalloc (strlen (fname));
#if defined (__MSDOS__)
  for (i = 1; fname[i] && fname[i] != '/' && fname[i] != '\\'; i++)
#else
  for (i = 1; fname[i] && fname[i] != '/'; i++)
#endif
    ret[i - 1] = fname[i];
  ret[i - 1] = '\0';
  if (lenp)
    *lenp = i;
  return ret;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\tilde.c:269
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\tilde.c:322
parsing error 
{
  char *ret;
  int plen, slen;

  plen = (prefix && *prefix) ? strlen (prefix) : 0;
  slen = strlen (suffix + suffind);
  ret = (char *)xmalloc (plen + slen + 1);
  if (plen)
    strcpy (ret, prefix);
  strcpy (ret + plen, suffix + suffind);
  return ret;
}
warning: parse error {
  char *ret;
  int plen, slen;

  plen = (prefix && *prefix) ? strlen (prefix) : 0;
  slen = strlen (suffix + suffind);
  ret = (char *)xmalloc (plen + slen + 1);
  if (plen)
    strcpy (ret, prefix);
  strcpy (ret + plen, suffix + suffind);
  return ret;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\tilde.c:326
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\tilde.c:344
parsing error 
{
  char *dirname, *expansion, *username;
  int user_len;
  struct passwd *user_entry;

  if (filename == 0)
    return ((char *)NULL);

  if (*filename != '~')
    return (savestring (filename));

  /* A leading `~/' or a bare `~' is *always* translated to the value of
     $HOME or the home directory of the current user, regardless of any
     preexpansion hook. */
  if (filename[1] == '\0' || filename[1] == '/')
    {
      /* Prefix $HOME to the rest of the string. */
      expansion = sh_get_env_value ("HOME");

      /* If there is no HOME variable, look up the directory in
	 the password database. */
      if (expansion == 0)
	expansion = sh_get_home_dir ();

      return (glue_prefix_and_suffix (expansion, filename, 1));
    }

  username = isolate_tilde_prefix (filename, &user_len);

  if (tilde_expansion_preexpansion_hook)
    {
      expansion = (*tilde_expansion_preexpansion_hook) (username);
      if (expansion)
	{
	  dirname = glue_prefix_and_suffix (expansion, filename, user_len);
	  xfree (username);
	  xfree (expansion);
	  return (dirname);
	}
    }

  /* No preexpansion hook, or the preexpansion hook failed.  Look in the
     password database. */
  dirname = (char *)NULL;
#if defined (HAVE_GETPWNAM)
  user_entry = getpwnam (username);
#else
  user_entry = 0;
#endif
  if (user_entry == 0)
    {
      /* If the calling program has a special syntax for expanding tildes,
	 and we couldn't find a standard expansion, then let them try. */
      if (tilde_expansion_failure_hook)
	{
	  expansion = (*tilde_expansion_failure_hook) (username);
	  if (expansion)
	    {
	      dirname = glue_prefix_and_suffix (expansion, filename, user_len);
	      xfree (expansion);
	    }
	}
      /* If we don't have a failure hook, or if the failure hook did not
	 expand the tilde, return a copy of what we were passed. */
      if (dirname == 0)
	dirname = savestring (filename);
    }
#if defined (HAVE_GETPWENT)
  else
    dirname = glue_prefix_and_suffix (user_entry->pw_dir, filename, user_len);
#endif

  xfree (username);
#if defined (HAVE_GETPWENT)
  endpwent ();
#endif
  return (dirname);
}
warning: parse error {
  char *dirname, *expansion, *username;
  int user_len;
  struct passwd *user_entry;

  if (filename == 0)
    return ((char *)NULL);

  if (*filename != '~')
    return (savestring (filename));

  /* A leading `~/' or a bare `~' is *always* translated to the value of
     $HOME or the home directory of the current user, regardless of any
     preexpansion hook. */
  if (filename[1] == '\0' || filename[1] == '/')
    {
      /* Prefix $HOME to the rest of the string. */
      expansion = sh_get_env_value ("HOME");

      /* If there is no HOME variable, look up the directory in
	 the password database. */
      if (expansion == 0)
	expansion = sh_get_home_dir ();

      return (glue_prefix_and_suffix (expansion, filename, 1));
    }

  username = isolate_tilde_prefix (filename, &user_len);

  if (tilde_expansion_preexpansion_hook)
    {
      expansion = (*tilde_expansion_preexpansion_hook) (username);
      if (expansion)
	{
	  dirname = glue_prefix_and_suffix (expansion, filename, user_len);
	  xfree (username);
	  xfree (expansion);
	  return (dirname);
	}
    }

  /* No preexpansion hook, or the preexpansion hook failed.  Look in the
     password database. */
  dirname = (char *)NULL;
#if defined (HAVE_GETPWNAM)
  user_entry = getpwnam (username);
#else
  user_entry = 0;
#endif
  if (user_entry == 0)
    {
      /* If the calling program has a special syntax for expanding tildes,
	 and we couldn't find a standard expansion, then let them try. */
      if (tilde_expansion_failure_hook)
	{
	  expansion = (*tilde_expansion_failure_hook) (username);
	  if (expansion)
	    {
	      dirname = glue_prefix_and_suffix (expansion, filename, user_len);
	      xfree (expansion);
	    }
	}
      /* If we don't have a failure hook, or if the failure hook did not
	 expand the tilde, return a copy of what we were passed. */
      if (dirname == 0)
	dirname = savestring (filename);
    }
#if defined (HAVE_GETPWENT)
  else
    dirname = glue_prefix_and_suffix (user_entry->pw_dir, filename, user_len);
#endif

  xfree (username);
#if defined (HAVE_GETPWENT)
  endpwent ();
#endif
  return (dirname);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\tilde.c:345
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\undo.c...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\rldefs.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\history.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\rlprivate.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\xmalloc.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\undo.c:72
parsing error 
{
  UNDO_LIST *temp;

  temp = (UNDO_LIST *)xmalloc (sizeof (UNDO_LIST));
  temp->what = what;
  temp->start = start;
  temp->end = end;
  temp->text = text;

  temp->next = (UNDO_LIST *)NULL;
  return temp;
}
warning: parse error {
  UNDO_LIST *temp;

  temp = (UNDO_LIST *)xmalloc (sizeof (UNDO_LIST));
  temp->what = what;
  temp->start = start;
  temp->end = end;
  temp->text = text;

  temp->next = (UNDO_LIST *)NULL;
  return temp;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\undo.c:76
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\undo.c:92
parsing error 
{
  UNDO_LIST *temp;

  temp = alloc_undo_entry (what, start, end, text);
  temp->next = rl_undo_list;
  rl_undo_list = temp;
}
warning: parse error {
  UNDO_LIST *temp;

  temp = alloc_undo_entry (what, start, end, text);
  temp->next = rl_undo_list;
  rl_undo_list = temp;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\undo.c:96
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\undo.c:126
parsing error 
{
  UNDO_LIST *new;

  new = alloc_undo_entry (entry->what, entry->start, entry->end, (char *)NULL);
  new->text = entry->text ? savestring (entry->text) : 0;
  return new;
}
warning: parse error {
  UNDO_LIST *new;

  new = alloc_undo_entry (entry->what, entry->start, entry->end, (char *)NULL);
  new->text = entry->text ? savestring (entry->text) : 0;
  return new;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\undo.c:128
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\undo.c:137
parsing error 
{
  UNDO_LIST *list, *new, *roving, *c;

  if (head == 0)
    return head;

  list = head;
  new = 0;
  while (list)
    {
      c = _rl_copy_undo_entry (list);
      if (new == 0)
	roving = new = c;
      else
	{
	  roving->next = c;
	  roving = roving->next;
	}
      list = list->next;
    }

  roving->next = 0;
  return new;
}
warning: parse error {
  UNDO_LIST *list, *new, *roving, *c;

  if (head == 0)
    return head;

  list = head;
  new = 0;
  while (list)
    {
      c = _rl_copy_undo_entry (list);
      if (new == 0)
	roving = new = c;
      else
	{
	  roving->next = c;
	  roving = roving->next;
	}
      list = list->next;
    }

  roving->next = 0;
  return new;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\undo.c:139
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\undo.c:236
parsing error 
{
  UNDO_LIST *rl;

  for (rl = rl_undo_list; rl; rl = rl->next)
    {
      if (rl->what == type)
	{
	  rl->start = start;
	  rl->end = end;
	  return 0;
	}
    }
  return 1;
}
warning: parse error {
  UNDO_LIST *rl;

  for (rl = rl_undo_list; rl; rl = rl->next)
    {
      if (rl->what == type)
	{
	  rl->start = start;
	  rl->end = end;
	  return 0;
	}
    }
  return 1;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\undo.c:238
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\undo.c:273
parsing error 
{
  if (start > end)
    {
      SWAP (start, end);
    }

  if (start != end)
    {
      char *temp = rl_copy_text (start, end);
      rl_begin_undo_group ();
      rl_add_undo (UNDO_DELETE, start, end, temp);
      rl_add_undo (UNDO_INSERT, start, end, (char *)NULL);
      rl_end_undo_group ();
    }
  return 0;
}
warning: parse error {
  if (start > end)
    {
      SWAP (start, end);
    }

  if (start != end)
    {
      char *temp = rl_copy_text (start, end);
      rl_begin_undo_group ();
      rl_add_undo (UNDO_DELETE, start, end, temp);
      rl_add_undo (UNDO_INSERT, start, end, (char *)NULL);
      rl_end_undo_group ();
    }
  return 0;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\undo.c:275
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\undo.c:294
parsing error 
{
  if (rl_undo_list == 0)
    rl_ding ();
  else
    {
      while (rl_undo_list)
	rl_do_undo ();
#if defined (VI_MODE)
      if (rl_editing_mode == vi_mode)
	rl_point = rl_mark = 0;		/* rl_end should be set correctly */
#endif
    }
    
  return 0;
}
warning: parse error {
  if (rl_undo_list == 0)
    rl_ding ();
  else
    {
      while (rl_undo_list)
	rl_do_undo ();
#if defined (VI_MODE)
      if (rl_editing_mode == vi_mode)
	rl_point = rl_mark = 0;		/* rl_end should be set correctly */
#endif
    }
    
  return 0;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\undo.c:296
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\undo.c:314
parsing error 
{
  if (count < 0)
    return 0;	/* Nothing to do. */

  while (count)
    {
      if (rl_do_undo ())
	count--;
      else
	{
	  rl_ding ();
	  break;
	}
    }
  return 0;
}
warning: parse error {
  if (count < 0)
    return 0;	/* Nothing to do. */

  while (count)
    {
      if (rl_do_undo ())
	count--;
      else
	{
	  rl_ding ();
	  break;
	}
    }
  return 0;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\undo.c:316
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\util.c...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\posixjmp.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\rldefs.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\rlmbutil.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\rlprivate.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\xmalloc.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\util.c:72
parsing error 
{
  if (ALPHABETIC (c))
    return (1);

  return (_rl_allow_pathname_alphabetic_chars &&
	    strchr (pathname_alphabetic_chars, c) != NULL);
}
warning: parse error {
  if (ALPHABETIC (c))
    return (1);

  return (_rl_allow_pathname_alphabetic_chars &&
	    strchr (pathname_alphabetic_chars, c) != NULL);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\util.c:74
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\util.c:116
parsing error 
{
  return (_rl_abort_internal ());
}
warning: parse error {
  return (_rl_abort_internal ());
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\util.c:118
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\util.c:123
parsing error 
{
  return 0;
}
warning: parse error {
  return 0;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\util.c:125
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\util.c:130
parsing error 
{
#if defined (TIOCSTAT)
  ioctl (1, TIOCSTAT, (char *)0);
  rl_refresh_line (count, key);
#else
  rl_ding ();
#endif
  return 0;
}
warning: parse error {
#if defined (TIOCSTAT)
  ioctl (1, TIOCSTAT, (char *)0);
  rl_refresh_line (count, key);
#else
  rl_ding ();
#endif
  return 0;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\util.c:132
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\util.c:145
parsing error 
{
  register int length;
  char *copy;

  /* Fix it if the caller is confused. */
  if (from > to)
    SWAP (from, to);

  length = to - from;
  copy = (char *)xmalloc (1 + length);
  strncpy (copy, rl_line_buffer + from, length);
  copy[length] = '\0';
  return (copy);
}
warning: parse error {
  register int length;
  char *copy;

  /* Fix it if the caller is confused. */
  if (from > to)
    SWAP (from, to);

  length = to - from;
  copy = (char *)xmalloc (1 + length);
  strncpy (copy, rl_line_buffer + from, length);
  copy[length] = '\0';
  return (copy);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\util.c:147
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\util.c:165
parsing error 
{
  while (len >= rl_line_buffer_len)
    {
      rl_line_buffer_len += DEFAULT_BUFFER_SIZE;
      rl_line_buffer = (char *)xrealloc (rl_line_buffer, rl_line_buffer_len);
    }

  _rl_set_the_line ();
}
warning: parse error {
  while (len >= rl_line_buffer_len)
    {
      rl_line_buffer_len += DEFAULT_BUFFER_SIZE;
      rl_line_buffer = (char *)xrealloc (rl_line_buffer, rl_line_buffer_len);
    }

  _rl_set_the_line ();
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\util.c:167
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\util.c:180
parsing error 
{
  register int start, end;
  char *homedir, *temp;
  int len;

  end = rl_point;
  start = end - 1;

  if (rl_point == rl_end && rl_line_buffer[rl_point] == '~')
    {
      homedir = tilde_expand ("~");
      _rl_replace_text (homedir, start, end);
      xfree (homedir);
      return (0);
    }
  else if (rl_line_buffer[start] != '~')
    {
      for (; !whitespace (rl_line_buffer[start]) && start >= 0; start--)
        ;
      start++;
    }

  end = start;
  do
    end++;
  while (whitespace (rl_line_buffer[end]) == 0 && end < rl_end);

  if (whitespace (rl_line_buffer[end]) || end >= rl_end)
    end--;

  /* If the first character of the current word is a tilde, perform
     tilde expansion and insert the result.  If not a tilde, do
     nothing. */
  if (rl_line_buffer[start] == '~')
    {
      len = end - start + 1;
      temp = (char *)xmalloc (len + 1);
      strncpy (temp, rl_line_buffer + start, len);
      temp[len] = '\0';
      homedir = tilde_expand (temp);
      xfree (temp);

      _rl_replace_text (homedir, start, end);
      xfree (homedir);
    }

  return (0);
}
warning: parse error {
  register int start, end;
  char *homedir, *temp;
  int len;

  end = rl_point;
  start = end - 1;

  if (rl_point == rl_end && rl_line_buffer[rl_point] == '~')
    {
      homedir = tilde_expand ("~");
      _rl_replace_text (homedir, start, end);
      xfree (homedir);
      return (0);
    }
  else if (rl_line_buffer[start] != '~')
    {
      for (; !whitespace (rl_line_buffer[start]) && start >= 0; start--)
        ;
      start++;
    }

  end = start;
  do
    end++;
  while (whitespace (rl_line_buffer[end]) == 0 && end < rl_end);

  if (whitespace (rl_line_buffer[end]) || end >= rl_end)
    end--;

  /* If the first character of the current word is a tilde, perform
     tilde expansion and insert the result.  If not a tilde, do
     nothing. */
  if (rl_line_buffer[start] == '~')
    {
      len = end - start + 1;
      temp = (char *)xmalloc (len + 1);
      strncpy (temp, rl_line_buffer + start, len);
      temp[len] = '\0';
      homedir = tilde_expand (temp);
      xfree (temp);

      _rl_replace_text (homedir, start, end);
      xfree (homedir);
    }

  return (0);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\util.c:182
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\util.c:292
parsing error 
{
  fprintf (stderr, "readline: ");
  fprintf (stderr, format, arg1, arg2);
  fprintf (stderr, "\n");

  rl_forced_update_display ();
}
warning: parse error {
  fprintf (stderr, "readline: ");
  fprintf (stderr, format, arg1, arg2);
  fprintf (stderr, "\n");

  rl_forced_update_display ();
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\util.c:294
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\util.c:303
parsing error 
{
  fprintf (stderr, "readline: ");
  fprintf (stderr, format, arg1, arg2);
  fprintf (stderr, "\n");
}
warning: parse error {
  fprintf (stderr, "readline: ");
  fprintf (stderr, format, arg1, arg2);
  fprintf (stderr, "\n");
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\util.c:305
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\util.c:321
parsing error 
{
  register int i, l, len;

  for (i = 0, l = strlen (s2), len = strlen (s1); (len - i) >= l; i++)
    if (_rl_strnicmp (s1 + i, s2, l) == 0)
      return ((char *) (s1 + i));
  return ((char *)NULL);
}
warning: parse error {
  register int i, l, len;

  for (i = 0, l = strlen (s2), len = strlen (s1); (len - i) >= l; i++)
    if (_rl_strnicmp (s1 + i, s2, l) == 0)
      return ((char *) (s1 + i));
  return ((char *)NULL);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\util.c:323
parsing error 
_rl_strpbrk (string1, string2)
warning: parse error _rl_strpbrk (string1, string2)Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\util.c:336
parsing error 
{
  register const char *scan;
#if defined (HANDLE_MULTIBYTE)
  mbstate_t ps;
  register int i, v;

  memset (&ps, 0, sizeof (mbstate_t));
#endif

  for (; *string1; string1++)
    {
      for (scan = string2; *scan; scan++)
	{
	  if (*string1 == *scan)
	    return ((char *)string1);
	}
#if defined (HANDLE_MULTIBYTE)
      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
	{
	  v = _rl_get_char_len (string1, &ps);
	  if (v > 1)
	    string1 += v - 1;	/* -1 to account for auto-increment in loop */
	}
#endif
    }
  return ((char *)NULL);
}
warning: parse error {
  register const char *scan;
#if defined (HANDLE_MULTIBYTE)
  mbstate_t ps;
  register int i, v;

  memset (&ps, 0, sizeof (mbstate_t));
#endif

  for (; *string1; string1++)
    {
      for (scan = string2; *scan; scan++)
	{
	  if (*string1 == *scan)
	    return ((char *)string1);
	}
#if defined (HANDLE_MULTIBYTE)
      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
	{
	  v = _rl_get_char_len (string1, &ps);
	  if (v > 1)
	    string1 += v - 1;	/* -1 to account for auto-increment in loop */
	}
#endif
    }
  return ((char *)NULL);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\util.c:338
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\util.c:371
parsing error 
{
  register char *s1, *s2;
  int d;

  if (count <= 0 || (string1 == string2))
    return 0;

  s1 = string1;
  s2 = string2;
  do
    {
      d = _rl_to_lower (*s1) - _rl_to_lower (*s2);	/* XXX - cast to unsigned char? */
      if (d != 0)
	return d;
      if (*s1++ == '\0')
        break;
      s2++;
    }
  while (--count != 0)

  return (0);
}
warning: parse error {
  register char *s1, *s2;
  int d;

  if (count <= 0 || (string1 == string2))
    return 0;

  s1 = string1;
  s2 = string2;
  do
    {
      d = _rl_to_lower (*s1) - _rl_to_lower (*s2);	/* XXX - cast to unsigned char? */
      if (d != 0)
	return d;
      if (*s1++ == '\0')
        break;
      s2++;
    }
  while (--count != 0)

  return (0);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\util.c:374
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\util.c:399
parsing error 
{
  register char *s1, *s2;
  int d;

  s1 = string1;
  s2 = string2;

  if (s1 == s2)
    return 0;

  while ((d = _rl_to_lower (*s1) - _rl_to_lower (*s2)) == 0)
    {
      if (*s1++ == '\0')
        return 0;
      s2++;
    }

  return (d);
}
warning: parse error {
  register char *s1, *s2;
  int d;

  s1 = string1;
  s2 = string2;

  if (s1 == s2)
    return 0;

  while ((d = _rl_to_lower (*s1) - _rl_to_lower (*s2)) == 0)
    {
      if (*s1++ == '\0')
        return 0;
      s2++;
    }

  return (d);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\util.c:401
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\util.c:424
parsing error 
{
#if defined (HAVE_STRCOLL)
  return (strcoll (*s1, *s2));
#else
  int result;

  result = **s1 - **s2;
  if (result == 0)
    result = strcmp (*s1, *s2);

  return result;
#endif
}
warning: parse error {
#if defined (HAVE_STRCOLL)
  return (strcoll (*s1, *s2));
#else
  int result;

  result = **s1 - **s2;
  if (result == 0)
    result = strcmp (*s1, *s2);

  return result;
#endif
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\util.c:426
parsing error 
FUNCTION_FOR_MACRO (_rl_digit_p)
warning: parse error FUNCTION_FOR_MACRO (_rl_digit_p)Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\util.c:443
parsing error 
FUNCTION_FOR_MACRO (_rl_digit_p)
warning: parse error FUNCTION_FOR_MACRO (_rl_digit_p)Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\util.c:443
parsing error 
FUNCTION_FOR_MACRO (_rl_digit_value)
warning: parse error FUNCTION_FOR_MACRO (_rl_digit_value)Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\util.c:444
parsing error 
FUNCTION_FOR_MACRO (_rl_digit_value)
warning: parse error FUNCTION_FOR_MACRO (_rl_digit_value)Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\util.c:444
parsing error 
FUNCTION_FOR_MACRO (_rl_lowercase_p)
warning: parse error FUNCTION_FOR_MACRO (_rl_lowercase_p)Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\util.c:445
parsing error 
FUNCTION_FOR_MACRO (_rl_lowercase_p)
warning: parse error FUNCTION_FOR_MACRO (_rl_lowercase_p)Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\util.c:445
parsing error 
FUNCTION_FOR_MACRO (_rl_pure_alphabetic)
warning: parse error FUNCTION_FOR_MACRO (_rl_pure_alphabetic)Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\util.c:446
parsing error 
FUNCTION_FOR_MACRO (_rl_pure_alphabetic)
warning: parse error FUNCTION_FOR_MACRO (_rl_pure_alphabetic)Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\util.c:446
parsing error 
FUNCTION_FOR_MACRO (_rl_to_lower)
warning: parse error FUNCTION_FOR_MACRO (_rl_to_lower)Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\util.c:447
parsing error 
FUNCTION_FOR_MACRO (_rl_to_lower)
warning: parse error FUNCTION_FOR_MACRO (_rl_to_lower)Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\util.c:447
parsing error 
FUNCTION_FOR_MACRO (_rl_to_upper)
warning: parse error FUNCTION_FOR_MACRO (_rl_to_upper)Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\util.c:448
parsing error 
FUNCTION_FOR_MACRO (_rl_to_upper)
warning: parse error FUNCTION_FOR_MACRO (_rl_to_upper)Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\util.c:448
parsing error 
FUNCTION_FOR_MACRO (_rl_uppercase_p)
warning: parse error FUNCTION_FOR_MACRO (_rl_uppercase_p)Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\util.c:449
parsing error 
FUNCTION_FOR_MACRO (_rl_uppercase_p)
warning: parse error FUNCTION_FOR_MACRO (_rl_uppercase_p)Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\util.c:449
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\util.c:454
parsing error 
{
  if (mem)
    free (mem);
}
warning: parse error {
  if (mem)
    free (mem);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\util.c:456
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\util.c:466
parsing error 
{
  return (strcpy ((char *)xmalloc (1 + (int)strlen (s)), (s)));
}
warning: parse error {
  return (strcpy ((char *)xmalloc (1 + (int)strlen (s)), (s)));
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\util.c:467
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\vi_keymap.c...skip
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\vi_mode.c...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\rlconf.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\rldefs.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\rlmbutil.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\history.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\rlprivate.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\xmalloc.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\vi_mode.c:165
parsing error 
{
  _rl_vi_last_command = key;
  _rl_vi_last_repeat = repeat;
  _rl_vi_last_arg_sign = sign;
}
warning: parse error {
  _rl_vi_last_command = key;
  _rl_vi_last_repeat = repeat;
  _rl_vi_last_arg_sign = sign;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\vi_mode.c:167
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\vi_mode.c:176
parsing error 
{
  _rl_vi_set_last (key, repeat, sign);
  rl_vi_insertion_mode (1, key);
}
warning: parse error {
  _rl_vi_set_last (key, repeat, sign);
  rl_vi_insertion_mode (1, key);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\vi_mode.c:178
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\vi_mode.c:185
parsing error 
{
  return (member (c, vi_textmod));
}
warning: parse error {
  return (member (c, vi_textmod));
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\vi_mode.c:187
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\vi_mode.c:192
parsing error 
{
  rl_begin_undo_group ();
  while (count--)
    rl_insert_text (vi_insert_buffer);
  rl_end_undo_group ();
}
warning: parse error {
  rl_begin_undo_group ();
  while (count--)
    rl_insert_text (vi_insert_buffer);
  rl_end_undo_group ();
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\vi_mode.c:194
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\vi_mode.c:205
parsing error 
{
  int r;

  if (!rl_explicit_arg)
    {
      rl_numeric_arg = _rl_vi_last_repeat;
      rl_arg_sign = _rl_vi_last_arg_sign;
    }

  r = 0;
  vi_redoing = 1;
  /* If we're redoing an insert with `i', stuff in the inserted text
     and do not go into insertion mode. */
  if (_rl_vi_last_command == 'i' && vi_insert_buffer && *vi_insert_buffer)
    {
      _rl_vi_stuff_insert (count);
      /* And back up point over the last character inserted. */
      if (rl_point > 0)
	_rl_vi_backup ();
    }
  /* Ditto for redoing an insert with `I', but move to the beginning of the
     line like the `I' command does. */
  else if (_rl_vi_last_command == 'I' && vi_insert_buffer && *vi_insert_buffer)
    {
      rl_beg_of_line (1, 'I');
      _rl_vi_stuff_insert (count);
      if (rl_point > 0)
	_rl_vi_backup ();
    }
  /* Ditto for redoing an insert with `a', but move forward a character first
     like the `a' command does. */
  else if (_rl_vi_last_command == 'a' && vi_insert_buffer && *vi_insert_buffer)
    {
      _rl_vi_append_forward ('a');
      _rl_vi_stuff_insert (count);
      if (rl_point > 0)
	_rl_vi_backup ();
    }
  /* Ditto for redoing an insert with `A', but move to the end of the line
     like the `A' command does. */
  else if (_rl_vi_last_command == 'A' && vi_insert_buffer && *vi_insert_buffer)
    {
      rl_end_of_line (1, 'A');
      _rl_vi_stuff_insert (count);
      if (rl_point > 0)
	_rl_vi_backup ();
    }
  else
    r = _rl_dispatch (_rl_vi_last_command, _rl_keymap);
  vi_redoing = 0;

  return (r);
}
warning: parse error {
  int r;

  if (!rl_explicit_arg)
    {
      rl_numeric_arg = _rl_vi_last_repeat;
      rl_arg_sign = _rl_vi_last_arg_sign;
    }

  r = 0;
  vi_redoing = 1;
  /* If we're redoing an insert with `i', stuff in the inserted text
     and do not go into insertion mode. */
  if (_rl_vi_last_command == 'i' && vi_insert_buffer && *vi_insert_buffer)
    {
      _rl_vi_stuff_insert (count);
      /* And back up point over the last character inserted. */
      if (rl_point > 0)
	_rl_vi_backup ();
    }
  /* Ditto for redoing an insert with `I', but move to the beginning of the
     line like the `I' command does. */
  else if (_rl_vi_last_command == 'I' && vi_insert_buffer && *vi_insert_buffer)
    {
      rl_beg_of_line (1, 'I');
      _rl_vi_stuff_insert (count);
      if (rl_point > 0)
	_rl_vi_backup ();
    }
  /* Ditto for redoing an insert with `a', but move forward a character first
     like the `a' command does. */
  else if (_rl_vi_last_command == 'a' && vi_insert_buffer && *vi_insert_buffer)
    {
      _rl_vi_append_forward ('a');
      _rl_vi_stuff_insert (count);
      if (rl_point > 0)
	_rl_vi_backup ();
    }
  /* Ditto for redoing an insert with `A', but move to the end of the line
     like the `A' command does. */
  else if (_rl_vi_last_command == 'A' && vi_insert_buffer && *vi_insert_buffer)
    {
      rl_end_of_line (1, 'A');
      _rl_vi_stuff_insert (count);
      if (rl_point > 0)
	_rl_vi_backup ();
    }
  else
    r = _rl_dispatch (_rl_vi_last_command, _rl_keymap);
  vi_redoing = 0;

  return (r);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\vi_mode.c:207
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\vi_mode.c:263
parsing error 
{
  return (rl_undo_command (count, key));
}
warning: parse error {
  return (rl_undo_command (count, key));
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\vi_mode.c:265
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\vi_mode.c:271
parsing error 
{
  /* Readline thinks that the first word on a line is the 0th, while vi
     thinks the first word on a line is the 1st.  Compensate. */
  if (rl_explicit_arg)
    rl_yank_nth_arg (count - 1, 0);
  else
    rl_yank_nth_arg ('$', 0);

  return (0);
}
warning: parse error {
  /* Readline thinks that the first word on a line is the 0th, while vi
     thinks the first word on a line is the 1st.  Compensate. */
  if (rl_explicit_arg)
    rl_yank_nth_arg (count - 1, 0);
  else
    rl_yank_nth_arg ('$', 0);

  return (0);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\vi_mode.c:273
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\vi_mode.c:287
parsing error 
{
  int wanted;

  /* Giving an argument of n means we want the nth command in the history
     file.  The command number is interpreted the same way that the bash
     `history' command does it -- that is, giving an argument count of 450
     to this command would get the command listed as number 450 in the
     output of `history'. */
  if (rl_explicit_arg)
    {
      wanted = history_base + where_history () - count;
      if (wanted <= 0)
        rl_beginning_of_history (0, 0);
      else
        rl_get_previous_history (wanted, c);
    }
  else
    rl_beginning_of_history (count, 0);
  return (0);
}
warning: parse error {
  int wanted;

  /* Giving an argument of n means we want the nth command in the history
     file.  The command number is interpreted the same way that the bash
     `history' command does it -- that is, giving an argument count of 450
     to this command would get the command listed as number 450 in the
     output of `history'. */
  if (rl_explicit_arg)
    {
      wanted = history_base + where_history () - count;
      if (wanted <= 0)
        rl_beginning_of_history (0, 0);
      else
        rl_get_previous_history (wanted, c);
    }
  else
    rl_beginning_of_history (count, 0);
  return (0);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\vi_mode.c:289
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\vi_mode.c:312
parsing error 
{
  switch (key)
    {
    case 'n':
      rl_noninc_reverse_search_again (count, key);
      break;

    case 'N':
      rl_noninc_forward_search_again (count, key);
      break;
    }
  return (0);
}
warning: parse error {
  switch (key)
    {
    case 'n':
      rl_noninc_reverse_search_again (count, key);
      break;

    case 'N':
      rl_noninc_forward_search_again (count, key);
      break;
    }
  return (0);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\vi_mode.c:314
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\vi_mode.c:330
parsing error 
{
  switch (key)
    {
    case '?':
      _rl_free_saved_history_line ();
      rl_noninc_forward_search (count, key);
      break;

    case '/':
      _rl_free_saved_history_line ();
      rl_noninc_reverse_search (count, key);
      break;

    default:
      rl_ding ();
      break;
    }
  return (0);
}
warning: parse error {
  switch (key)
    {
    case '?':
      _rl_free_saved_history_line ();
      rl_noninc_forward_search (count, key);
      break;

    case '/':
      _rl_free_saved_history_line ();
      rl_noninc_reverse_search (count, key);
      break;

    default:
      rl_ding ();
      break;
    }
  return (0);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\vi_mode.c:332
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\vi_mode.c:354
parsing error 
{
  if ((rl_point < rl_end) && (!whitespace (rl_line_buffer[rl_point])))
    {
      if (!whitespace (rl_line_buffer[rl_point + 1]))
	rl_vi_end_word (1, 'E');
      rl_point++;
    }

  if (key == '*')
    rl_complete_internal ('*');	/* Expansion and replacement. */
  else if (key == '=')
    rl_complete_internal ('?');	/* List possible completions. */
  else if (key == '\\')
    rl_complete_internal (TAB);	/* Standard Readline completion. */
  else
    rl_complete (0, key);

  if (key == '*' || key == '\\')
    rl_vi_start_inserting (key, 1, rl_arg_sign);

  return (0);
}
warning: parse error {
  if ((rl_point < rl_end) && (!whitespace (rl_line_buffer[rl_point])))
    {
      if (!whitespace (rl_line_buffer[rl_point + 1]))
	rl_vi_end_word (1, 'E');
      rl_point++;
    }

  if (key == '*')
    rl_complete_internal ('*');	/* Expansion and replacement. */
  else if (key == '=')
    rl_complete_internal ('?');	/* List possible completions. */
  else if (key == '\\')
    rl_complete_internal (TAB);	/* Standard Readline completion. */
  else
    rl_complete (0, key);

  if (key == '*' || key == '\\')
    rl_vi_start_inserting (key, 1, rl_arg_sign);

  return (0);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\vi_mode.c:356
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\vi_mode.c:381
parsing error 
{
  rl_tilde_expand (0, key);
  rl_vi_start_inserting (key, 1, rl_arg_sign);
  return (0);
}
warning: parse error {
  rl_tilde_expand (0, key);
  rl_vi_start_inserting (key, 1, rl_arg_sign);
  return (0);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\vi_mode.c:383
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\vi_mode.c:391
parsing error 
{
  if (count < 0)
    return (rl_vi_next_word (-count, key));

  if (rl_point == 0)
    {
      rl_ding ();
      return (0);
    }

  if (_rl_uppercase_p (key))
    rl_vi_bWord (count, key);
  else
    rl_vi_bword (count, key);

  return (0);
}
warning: parse error {
  if (count < 0)
    return (rl_vi_next_word (-count, key));

  if (rl_point == 0)
    {
      rl_ding ();
      return (0);
    }

  if (_rl_uppercase_p (key))
    rl_vi_bWord (count, key);
  else
    rl_vi_bword (count, key);

  return (0);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\vi_mode.c:393
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\vi_mode.c:413
parsing error 
{
  if (count < 0)
    return (rl_vi_prev_word (-count, key));

  if (rl_point >= (rl_end - 1))
    {
      rl_ding ();
      return (0);
    }

  if (_rl_uppercase_p (key))
    rl_vi_fWord (count, key);
  else
    rl_vi_fword (count, key);
  return (0);
}
warning: parse error {
  if (count < 0)
    return (rl_vi_prev_word (-count, key));

  if (rl_point >= (rl_end - 1))
    {
      rl_ding ();
      return (0);
    }

  if (_rl_uppercase_p (key))
    rl_vi_fWord (count, key);
  else
    rl_vi_fword (count, key);
  return (0);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\vi_mode.c:415
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\vi_mode.c:434
parsing error 
{
  if (count < 0)
    {
      rl_ding ();
      return -1;
    }

  if (_rl_uppercase_p (key))
    rl_vi_eWord (count, key);
  else
    rl_vi_eword (count, key);
  return (0);
}
warning: parse error {
  if (count < 0)
    {
      rl_ding ();
      return -1;
    }

  if (_rl_uppercase_p (key))
    rl_vi_eWord (count, key);
  else
    rl_vi_eword (count, key);
  return (0);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\vi_mode.c:436
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\vi_mode.c:452
parsing error 
{
  while (count-- && rl_point < (rl_end - 1))
    {
      /* Skip until whitespace. */
      while (!whitespace (rl_line_buffer[rl_point]) && rl_point < rl_end)
	rl_point++;

      /* Now skip whitespace. */
      while (whitespace (rl_line_buffer[rl_point]) && rl_point < rl_end)
	rl_point++;
    }
  return (0);
}
warning: parse error {
  while (count-- && rl_point < (rl_end - 1))
    {
      /* Skip until whitespace. */
      while (!whitespace (rl_line_buffer[rl_point]) && rl_point < rl_end)
	rl_point++;

      /* Now skip whitespace. */
      while (whitespace (rl_line_buffer[rl_point]) && rl_point < rl_end)
	rl_point++;
    }
  return (0);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\vi_mode.c:454
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\vi_mode.c:469
parsing error 
{
  while (count-- && rl_point > 0)
    {
      /* If we are at the start of a word, move back to whitespace so
	 we will go back to the start of the previous word. */
      if (!whitespace (rl_line_buffer[rl_point]) &&
	  whitespace (rl_line_buffer[rl_point - 1]))
	rl_point--;

      while (rl_point > 0 && whitespace (rl_line_buffer[rl_point]))
	rl_point--;

      if (rl_point > 0)
	{
	  while (--rl_point >= 0 && !whitespace (rl_line_buffer[rl_point]));
	  rl_point++;
	}
    }
  return (0);
}
warning: parse error {
  while (count-- && rl_point > 0)
    {
      /* If we are at the start of a word, move back to whitespace so
	 we will go back to the start of the previous word. */
      if (!whitespace (rl_line_buffer[rl_point]) &&
	  whitespace (rl_line_buffer[rl_point - 1]))
	rl_point--;

      while (rl_point > 0 && whitespace (rl_line_buffer[rl_point]))
	rl_point--;

      if (rl_point > 0)
	{
	  while (--rl_point >= 0 && !whitespace (rl_line_buffer[rl_point]));
	  rl_point++;
	}
    }
  return (0);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\vi_mode.c:471
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\vi_mode.c:493
parsing error 
{
  while (count-- && rl_point < (rl_end - 1))
    {
      if (!whitespace (rl_line_buffer[rl_point]))
	rl_point++;

      /* Move to the next non-whitespace character (to the start of the
	 next word). */
      while (rl_point < rl_end && whitespace (rl_line_buffer[rl_point]))
	rl_point++;

      if (rl_point && rl_point < rl_end)
	{
	  /* Skip whitespace. */
	  while (rl_point < rl_end && whitespace (rl_line_buffer[rl_point]))
	    rl_point++;

	  /* Skip until whitespace. */
	  while (rl_point < rl_end && !whitespace (rl_line_buffer[rl_point]))
	    rl_point++;

	  /* Move back to the last character of the word. */
	  rl_point--;
	}
    }
  return (0);
}
warning: parse error {
  while (count-- && rl_point < (rl_end - 1))
    {
      if (!whitespace (rl_line_buffer[rl_point]))
	rl_point++;

      /* Move to the next non-whitespace character (to the start of the
	 next word). */
      while (rl_point < rl_end && whitespace (rl_line_buffer[rl_point]))
	rl_point++;

      if (rl_point && rl_point < rl_end)
	{
	  /* Skip whitespace. */
	  while (rl_point < rl_end && whitespace (rl_line_buffer[rl_point]))
	    rl_point++;

	  /* Skip until whitespace. */
	  while (rl_point < rl_end && !whitespace (rl_line_buffer[rl_point]))
	    rl_point++;

	  /* Move back to the last character of the word. */
	  rl_point--;
	}
    }
  return (0);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\vi_mode.c:495
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\vi_mode.c:524
parsing error 
{
  while (count-- && rl_point < (rl_end - 1))
    {
      /* Move to white space (really non-identifer). */
      if (_rl_isident (rl_line_buffer[rl_point]))
	{
	  while (_rl_isident (rl_line_buffer[rl_point]) && rl_point < rl_end)
	    rl_point++;
	}
      else /* if (!whitespace (rl_line_buffer[rl_point])) */
	{
	  while (!_rl_isident (rl_line_buffer[rl_point]) &&
		 !whitespace (rl_line_buffer[rl_point]) && rl_point < rl_end)
	    rl_point++;
	}

      /* Move past whitespace. */
      while (whitespace (rl_line_buffer[rl_point]) && rl_point < rl_end)
	rl_point++;
    }
  return (0);
}
warning: parse error {
  while (count-- && rl_point < (rl_end - 1))
    {
      /* Move to white space (really non-identifer). */
      if (_rl_isident (rl_line_buffer[rl_point]))
	{
	  while (_rl_isident (rl_line_buffer[rl_point]) && rl_point < rl_end)
	    rl_point++;
	}
      else /* if (!whitespace (rl_line_buffer[rl_point])) */
	{
	  while (!_rl_isident (rl_line_buffer[rl_point]) &&
		 !whitespace (rl_line_buffer[rl_point]) && rl_point < rl_end)
	    rl_point++;
	}

      /* Move past whitespace. */
      while (whitespace (rl_line_buffer[rl_point]) && rl_point < rl_end)
	rl_point++;
    }
  return (0);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\vi_mode.c:526
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\vi_mode.c:550
parsing error 
{
  while (count-- && rl_point > 0)
    {
      int last_is_ident;

      /* If we are at the start of a word, move back to whitespace
	 so we will go back to the start of the previous word. */
      if (!whitespace (rl_line_buffer[rl_point]) &&
	  whitespace (rl_line_buffer[rl_point - 1]))
	rl_point--;

      /* If this character and the previous character are `opposite', move
	 back so we don't get messed up by the rl_point++ down there in
	 the while loop.  Without this code, words like `l;' screw up the
	 function. */
      last_is_ident = _rl_isident (rl_line_buffer[rl_point - 1]);
      if ((_rl_isident (rl_line_buffer[rl_point]) && !last_is_ident) ||
	  (!_rl_isident (rl_line_buffer[rl_point]) && last_is_ident))
	rl_point--;

      while (rl_point > 0 && whitespace (rl_line_buffer[rl_point]))
	rl_point--;

      if (rl_point > 0)
	{
	  if (_rl_isident (rl_line_buffer[rl_point]))
	    while (--rl_point >= 0 && _rl_isident (rl_line_buffer[rl_point]));
	  else
	    while (--rl_point >= 0 && !_rl_isident (rl_line_buffer[rl_point]) &&
		   !whitespace (rl_line_buffer[rl_point]));
	  rl_point++;
	}
    }
  return (0);
}
warning: parse error {
  while (count-- && rl_point > 0)
    {
      int last_is_ident;

      /* If we are at the start of a word, move back to whitespace
	 so we will go back to the start of the previous word. */
      if (!whitespace (rl_line_buffer[rl_point]) &&
	  whitespace (rl_line_buffer[rl_point - 1]))
	rl_point--;

      /* If this character and the previous character are `opposite', move
	 back so we don't get messed up by the rl_point++ down there in
	 the while loop.  Without this code, words like `l;' screw up the
	 function. */
      last_is_ident = _rl_isident (rl_line_buffer[rl_point - 1]);
      if ((_rl_isident (rl_line_buffer[rl_point]) && !last_is_ident) ||
	  (!_rl_isident (rl_line_buffer[rl_point]) && last_is_ident))
	rl_point--;

      while (rl_point > 0 && whitespace (rl_line_buffer[rl_point]))
	rl_point--;

      if (rl_point > 0)
	{
	  if (_rl_isident (rl_line_buffer[rl_point]))
	    while (--rl_point >= 0 && _rl_isident (rl_line_buffer[rl_point]));
	  else
	    while (--rl_point >= 0 && !_rl_isident (rl_line_buffer[rl_point]) &&
		   !whitespace (rl_line_buffer[rl_point]));
	  rl_point++;
	}
    }
  return (0);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\vi_mode.c:552
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\vi_mode.c:589
parsing error 
{
  while (count-- && rl_point < rl_end - 1)
    {
      if (!whitespace (rl_line_buffer[rl_point]))
	rl_point++;

      while (rl_point < rl_end && whitespace (rl_line_buffer[rl_point]))
	rl_point++;

      if (rl_point < rl_end)
	{
	  if (_rl_isident (rl_line_buffer[rl_point]))
	    while (++rl_point < rl_end && _rl_isident (rl_line_buffer[rl_point]));
	  else
	    while (++rl_point < rl_end && !_rl_isident (rl_line_buffer[rl_point])
		   && !whitespace (rl_line_buffer[rl_point]));
	}
      rl_point--;
    }
  return (0);
}
warning: parse error {
  while (count-- && rl_point < rl_end - 1)
    {
      if (!whitespace (rl_line_buffer[rl_point]))
	rl_point++;

      while (rl_point < rl_end && whitespace (rl_line_buffer[rl_point]))
	rl_point++;

      if (rl_point < rl_end)
	{
	  if (_rl_isident (rl_line_buffer[rl_point]))
	    while (++rl_point < rl_end && _rl_isident (rl_line_buffer[rl_point]));
	  else
	    while (++rl_point < rl_end && !_rl_isident (rl_line_buffer[rl_point])
		   && !whitespace (rl_line_buffer[rl_point]));
	}
      rl_point--;
    }
  return (0);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\vi_mode.c:591
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\vi_mode.c:614
parsing error 
{
  rl_beg_of_line (1, key);
  rl_vi_insert_mode (1, key);
  return (0);
}
warning: parse error {
  rl_beg_of_line (1, key);
  rl_vi_insert_mode (1, key);
  return (0);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\vi_mode.c:616
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\vi_mode.c:623
parsing error 
{
  int point;

  if (rl_point < rl_end)
    {
      if (MB_CUR_MAX == 1 || rl_byte_oriented)
	rl_point++;
      else
	{
	  point = rl_point;
#if 0
	  rl_forward_char (1, key);
#else
	  rl_point = _rl_forward_char_internal (1);
#endif
	  if (point == rl_point)
	    rl_point = rl_end;
	}
    }
}
warning: parse error {
  int point;

  if (rl_point < rl_end)
    {
      if (MB_CUR_MAX == 1 || rl_byte_oriented)
	rl_point++;
      else
	{
	  point = rl_point;
#if 0
	  rl_forward_char (1, key);
#else
	  rl_point = _rl_forward_char_internal (1);
#endif
	  if (point == rl_point)
	    rl_point = rl_end;
	}
    }
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\vi_mode.c:625
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\vi_mode.c:647
parsing error 
{
  _rl_vi_append_forward (key);
  rl_vi_start_inserting (key, 1, rl_arg_sign);
  return (0);
}
warning: parse error {
  _rl_vi_append_forward (key);
  rl_vi_start_inserting (key, 1, rl_arg_sign);
  return (0);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\vi_mode.c:649
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\vi_mode.c:656
parsing error 
{
  rl_end_of_line (1, key);
  rl_vi_append_mode (1, key);
  return (0);
}
warning: parse error {
  rl_end_of_line (1, key);
  rl_vi_append_mode (1, key);
  return (0);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\vi_mode.c:658
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\vi_mode.c:666
parsing error 
{
  return (rl_newline (1, '\n'));
}
warning: parse error {
  return (rl_newline (1, '\n'));
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\vi_mode.c:668
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\vi_mode.c:677
parsing error 
{
  _rl_keymap = vi_insertion_keymap;
  _rl_vi_last_key_before_insert = key;
  return (0);
}
warning: parse error {
  _rl_keymap = vi_insertion_keymap;
  _rl_vi_last_key_before_insert = key;
  return (0);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\vi_mode.c:679
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\vi_mode.c:686
parsing error 
{
  rl_vi_start_inserting (key, 1, rl_arg_sign);
  return (0);
}
warning: parse error {
  rl_vi_start_inserting (key, 1, rl_arg_sign);
  return (0);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\vi_mode.c:688
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\vi_mode.c:694
parsing error 
{
  int len, start, end;

  if (up == 0 || up->what != UNDO_INSERT)
    {
      if (vi_insert_buffer_size >= 1)
	vi_insert_buffer[0] = '\0';
      return;
    }

  start = up->start;
  end = up->end;
  len = end - start + 1;
  if (len >= vi_insert_buffer_size)
    {
      vi_insert_buffer_size += (len + 32) - (len % 32);
      vi_insert_buffer = (char *)xrealloc (vi_insert_buffer, vi_insert_buffer_size);
    }
  strncpy (vi_insert_buffer, rl_line_buffer + start, len - 1);
  vi_insert_buffer[len-1] = '\0';
}
warning: parse error {
  int len, start, end;

  if (up == 0 || up->what != UNDO_INSERT)
    {
      if (vi_insert_buffer_size >= 1)
	vi_insert_buffer[0] = '\0';
      return;
    }

  start = up->start;
  end = up->end;
  len = end - start + 1;
  if (len >= vi_insert_buffer_size)
    {
      vi_insert_buffer_size += (len + 32) - (len % 32);
      vi_insert_buffer = (char *)xrealloc (vi_insert_buffer, vi_insert_buffer_size);
    }
  strncpy (vi_insert_buffer, rl_line_buffer + start, len - 1);
  vi_insert_buffer[len-1] = '\0';
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\vi_mode.c:696
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\vi_mode.c:751
parsing error 
{
  if (rl_point > 0)
    rl_backward_char (1, key);

  _rl_keymap = vi_movement_keymap;
  _rl_vi_done_inserting ();

  /* This is how POSIX.2 says `U' should behave -- everything up until the
     first time you go into command mode should not be undone. */
  if (RL_ISSTATE (RL_STATE_VICMDONCE) == 0)
    rl_free_undo_list ();

  RL_SETSTATE (RL_STATE_VICMDONCE);
  return (0);
}
warning: parse error {
  if (rl_point > 0)
    rl_backward_char (1, key);

  _rl_keymap = vi_movement_keymap;
  _rl_vi_done_inserting ();

  /* This is how POSIX.2 says `U' should behave -- everything up until the
     first time you go into command mode should not be undone. */
  if (RL_ISSTATE (RL_STATE_VICMDONCE) == 0)
    rl_free_undo_list ();

  RL_SETSTATE (RL_STATE_VICMDONCE);
  return (0);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\vi_mode.c:753
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\vi_mode.c:770
parsing error 
{
  if (c == '0' && rl_numeric_arg == 1 && !rl_explicit_arg)
    return (rl_beg_of_line (1, c));
  else
    return (rl_digit_argument (count, c));
}
warning: parse error {
  if (c == '0' && rl_numeric_arg == 1 && !rl_explicit_arg)
    return (rl_beg_of_line (1, c));
  else
    return (rl_digit_argument (count, c));
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\vi_mode.c:772
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\vi_mode.c:782
parsing error 
{
  wchar_t wc;
  char mb[MB_LEN_MAX+1];
  int mlen, p;
  size_t m;
  mbstate_t ps;

  memset (&ps, 0, sizeof (mbstate_t));
  if (_rl_adjust_point (rl_line_buffer, rl_point, &ps) > 0)
    count--;
  while (count-- && rl_point < rl_end)
    {
      m = mbrtowc (&wc, rl_line_buffer + rl_point, rl_end - rl_point, &ps);
      if (MB_INVALIDCH (m))
	wc = (wchar_t)rl_line_buffer[rl_point];
      else if (MB_NULLWCH (m))
	wc = L'\0';
      if (iswupper (wc))
	wc = towlower (wc);
      else if (iswlower (wc))
	wc = towupper (wc);
      else
	{
	  /* Just skip over chars neither upper nor lower case */
	  rl_forward_char (1, 0);
	  continue;
	}

      /* Vi is kind of strange here. */
      if (wc)
	{
	  p = rl_point;
	  mlen = wcrtomb (mb, wc, &ps);
	  if (mlen >= 0)
	    mb[mlen] = '\0';
	  rl_begin_undo_group ();
	  rl_vi_delete (1, 0);
	  if (rl_point < p)	/* Did we retreat at EOL? */
	    rl_point++;	/* XXX - should we advance more than 1 for mbchar? */
	  rl_insert_text (mb);
	  rl_end_undo_group ();
	  rl_vi_check ();
	}
      else
	rl_forward_char (1, 0);
    }

  return 0;
}
warning: parse error {
  wchar_t wc;
  char mb[MB_LEN_MAX+1];
  int mlen, p;
  size_t m;
  mbstate_t ps;

  memset (&ps, 0, sizeof (mbstate_t));
  if (_rl_adjust_point (rl_line_buffer, rl_point, &ps) > 0)
    count--;
  while (count-- && rl_point < rl_end)
    {
      m = mbrtowc (&wc, rl_line_buffer + rl_point, rl_end - rl_point, &ps);
      if (MB_INVALIDCH (m))
	wc = (wchar_t)rl_line_buffer[rl_point];
      else if (MB_NULLWCH (m))
	wc = L'\0';
      if (iswupper (wc))
	wc = towlower (wc);
      else if (iswlower (wc))
	wc = towupper (wc);
      else
	{
	  /* Just skip over chars neither upper nor lower case */
	  rl_forward_char (1, 0);
	  continue;
	}

      /* Vi is kind of strange here. */
      if (wc)
	{
	  p = rl_point;
	  mlen = wcrtomb (mb, wc, &ps);
	  if (mlen >= 0)
	    mb[mlen] = '\0';
	  rl_begin_undo_group ();
	  rl_vi_delete (1, 0);
	  if (rl_point < p)	/* Did we retreat at EOL? */
	    rl_point++;	/* XXX - should we advance more than 1 for mbchar? */
	  rl_insert_text (mb);
	  rl_end_undo_group ();
	  rl_vi_check ();
	}
      else
	rl_forward_char (1, 0);
    }

  return 0;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\vi_mode.c:784
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\vi_mode.c:836
parsing error 
{
  int c, p;

  /* Don't try this on an empty line. */
  if (rl_point >= rl_end)
    return (0);

  c = 0;
#if defined (HANDLE_MULTIBYTE)
  if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
    return (_rl_vi_change_mbchar_case (count));
#endif

  while (count-- && rl_point < rl_end)
    {
      if (_rl_uppercase_p (rl_line_buffer[rl_point]))
	c = _rl_to_lower (rl_line_buffer[rl_point]);
      else if (_rl_lowercase_p (rl_line_buffer[rl_point]))
	c = _rl_to_upper (rl_line_buffer[rl_point]);
      else
	{
	  /* Just skip over characters neither upper nor lower case. */
	  rl_forward_char (1, c);
	  continue;
	}

      /* Vi is kind of strange here. */
      if (c)
	{
	  p = rl_point;
	  rl_begin_undo_group ();
	  rl_vi_delete (1, c);
	  if (rl_point < p)	/* Did we retreat at EOL? */
	    rl_point++;
	  _rl_insert_char (1, c);
	  rl_end_undo_group ();
	  rl_vi_check ();
	}
      else
	rl_forward_char (1, c);
    }
  return (0);
}
warning: parse error {
  int c, p;

  /* Don't try this on an empty line. */
  if (rl_point >= rl_end)
    return (0);

  c = 0;
#if defined (HANDLE_MULTIBYTE)
  if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
    return (_rl_vi_change_mbchar_case (count));
#endif

  while (count-- && rl_point < rl_end)
    {
      if (_rl_uppercase_p (rl_line_buffer[rl_point]))
	c = _rl_to_lower (rl_line_buffer[rl_point]);
      else if (_rl_lowercase_p (rl_line_buffer[rl_point]))
	c = _rl_to_upper (rl_line_buffer[rl_point]);
      else
	{
	  /* Just skip over characters neither upper nor lower case. */
	  rl_forward_char (1, c);
	  continue;
	}

      /* Vi is kind of strange here. */
      if (c)
	{
	  p = rl_point;
	  rl_begin_undo_group ();
	  rl_vi_delete (1, c);
	  if (rl_point < p)	/* Did we retreat at EOL? */
	    rl_point++;
	  _rl_insert_char (1, c);
	  rl_end_undo_group ();
	  rl_vi_check ();
	}
      else
	rl_forward_char (1, c);
    }
  return (0);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\vi_mode.c:838
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\vi_mode.c:883
parsing error 
{
  if (!_rl_uppercase_p (key) && (rl_point + 1 <= rl_end))
    rl_point = _rl_find_next_mbchar (rl_line_buffer, rl_point, 1, MB_FIND_NONZERO);

  while (count--)
    rl_yank (1, key);

  rl_backward_char (1, key);
  return (0);
}
warning: parse error {
  if (!_rl_uppercase_p (key) && (rl_point + 1 <= rl_end))
    rl_point = _rl_find_next_mbchar (rl_line_buffer, rl_point, 1, MB_FIND_NONZERO);

  while (count--)
    rl_yank (1, key);

  rl_backward_char (1, key);
  return (0);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\vi_mode.c:885
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\vi_mode.c:919
parsing error 
{
  if (count > rl_end)
    rl_end_of_line (1, key);
  else
    rl_point = count - 1;
  return (0);
}
warning: parse error {
  if (count > rl_end)
    rl_end_of_line (1, key);
  else
    rl_point = count - 1;
  return (0);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\vi_mode.c:921
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\vi_mode.c:933
parsing error 
{
  int key;

  key = c;
  if (c >= 0 && _rl_keymap[c].type == ISFUNC && _rl_keymap[c].function == rl_universal_argument)
    {
      rl_numeric_arg *= 4;
      return 1;
    }

  c = UNMETA (c);

  if (_rl_digit_p (c))
    {
      if (rl_explicit_arg)
	rl_numeric_arg = (rl_numeric_arg * 10) + _rl_digit_value (c);
      else
	rl_numeric_arg = _rl_digit_value (c);
      rl_explicit_arg = 1;
      return 1;		/* keep going */
    }
  else
    {
      rl_clear_message ();
      rl_stuff_char (key);
      return 0;		/* done */
    }
}
warning: parse error {
  int key;

  key = c;
  if (c >= 0 && _rl_keymap[c].type == ISFUNC && _rl_keymap[c].function == rl_universal_argument)
    {
      rl_numeric_arg *= 4;
      return 1;
    }

  c = UNMETA (c);

  if (_rl_digit_p (c))
    {
      if (rl_explicit_arg)
	rl_numeric_arg = (rl_numeric_arg * 10) + _rl_digit_value (c);
      else
	rl_numeric_arg = _rl_digit_value (c);
      rl_explicit_arg = 1;
      return 1;		/* keep going */
    }
  else
    {
      rl_clear_message ();
      rl_stuff_char (key);
      return 0;		/* done */
    }
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\vi_mode.c:935
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\vi_mode.c:989
parsing error 
{
  m->op = op;
  m->state = m->flags = 0;
  m->ncxt = 0;
  m->numeric_arg = -1;
  m->start = rl_point;
  m->end = rl_end;
  m->key = key;
  m->motion = -1;
}
warning: parse error {
  m->op = op;
  m->state = m->flags = 0;
  m->ncxt = 0;
  m->numeric_arg = -1;
  m->start = rl_point;
  m->end = rl_end;
  m->key = key;
  m->motion = -1;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\vi_mode.c:992
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\vi_mode.c:1,004
parsing error 
{
  _rl_vimotion_cxt *m;

  m = xmalloc (sizeof (_rl_vimotion_cxt));
  _rl_mvcxt_init (m, op, key);
  return m;
}
warning: parse error {
  _rl_vimotion_cxt *m;

  m = xmalloc (sizeof (_rl_vimotion_cxt));
  _rl_mvcxt_init (m, op, key);
  return m;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\vi_mode.c:1,006
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\vi_mode.c:1,015
parsing error 
{
  xfree (m);
}
warning: parse error {
  xfree (m);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\vi_mode.c:1,017
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\vi_mode.c:1,022
parsing error 
{
  int c, save, r;
  int old_end;

  _rl_vi_last_motion = c = m->motion;

  /* Append a blank character temporarily so that the motion routines
     work right at the end of the line. */
  old_end = rl_end;
  rl_line_buffer[rl_end++] = ' ';
  rl_line_buffer[rl_end] = '\0';

  _rl_dispatch (c, _rl_keymap);

  /* Remove the blank that we added. */
  rl_end = old_end;
  rl_line_buffer[rl_end] = '\0';
  if (rl_point > rl_end)
    rl_point = rl_end;

  /* No change in position means the command failed. */
  if (rl_mark == rl_point)
    return (-1);

  /* rl_vi_f[wW]ord () leaves the cursor on the first character of the next
     word.  If we are not at the end of the line, and we are on a
     non-whitespace character, move back one (presumably to whitespace). */
  if ((_rl_to_upper (c) == 'W') && rl_point < rl_end && rl_point > rl_mark &&
      !whitespace (rl_line_buffer[rl_point]))
    rl_point--;

  /* If cw or cW, back up to the end of a word, so the behaviour of ce
     or cE is the actual result.  Brute-force, no subtlety. */
  if (m->key == 'c' && rl_point >= rl_mark && (_rl_to_upper (c) == 'W'))
    {
      /* Don't move farther back than where we started. */
      while (rl_point > rl_mark && whitespace (rl_line_buffer[rl_point]))
	rl_point--;

      /* Posix.2 says that if cw or cW moves the cursor towards the end of
	 the line, the character under the cursor should be deleted. */
      if (rl_point == rl_mark)
	rl_point++;
      else
	{
	  /* Move past the end of the word so that the kill doesn't
	     remove the last letter of the previous word.  Only do this
	     if we are not at the end of the line. */
	  if (rl_point >= 0 && rl_point < (rl_end - 1) && !whitespace (rl_line_buffer[rl_point]))
	    rl_point++;
	}
    }

  if (rl_mark < rl_point)
    SWAP (rl_point, rl_mark);

#if defined (READLINE_CALLBACKS)
  if (RL_ISSTATE (RL_STATE_CALLBACK))
    (*rl_redisplay_function)();		/* make sure motion is displayed */
#endif

  r = vidomove_dispatch (m);

  return (r);
}
warning: parse error {
  int c, save, r;
  int old_end;

  _rl_vi_last_motion = c = m->motion;

  /* Append a blank character temporarily so that the motion routines
     work right at the end of the line. */
  old_end = rl_end;
  rl_line_buffer[rl_end++] = ' ';
  rl_line_buffer[rl_end] = '\0';

  _rl_dispatch (c, _rl_keymap);

  /* Remove the blank that we added. */
  rl_end = old_end;
  rl_line_buffer[rl_end] = '\0';
  if (rl_point > rl_end)
    rl_point = rl_end;

  /* No change in position means the command failed. */
  if (rl_mark == rl_point)
    return (-1);

  /* rl_vi_f[wW]ord () leaves the cursor on the first character of the next
     word.  If we are not at the end of the line, and we are on a
     non-whitespace character, move back one (presumably to whitespace). */
  if ((_rl_to_upper (c) == 'W') && rl_point < rl_end && rl_point > rl_mark &&
      !whitespace (rl_line_buffer[rl_point]))
    rl_point--;

  /* If cw or cW, back up to the end of a word, so the behaviour of ce
     or cE is the actual result.  Brute-force, no subtlety. */
  if (m->key == 'c' && rl_point >= rl_mark && (_rl_to_upper (c) == 'W'))
    {
      /* Don't move farther back than where we started. */
      while (rl_point > rl_mark && whitespace (rl_line_buffer[rl_point]))
	rl_point--;

      /* Posix.2 says that if cw or cW moves the cursor towards the end of
	 the line, the character under the cursor should be deleted. */
      if (rl_point == rl_mark)
	rl_point++;
      else
	{
	  /* Move past the end of the word so that the kill doesn't
	     remove the last letter of the previous word.  Only do this
	     if we are not at the end of the line. */
	  if (rl_point >= 0 && rl_point < (rl_end - 1) && !whitespace (rl_line_buffer[rl_point]))
	    rl_point++;
	}
    }

  if (rl_mark < rl_point)
    SWAP (rl_point, rl_mark);

#if defined (READLINE_CALLBACKS)
  if (RL_ISSTATE (RL_STATE_CALLBACK))
    (*rl_redisplay_function)();		/* make sure motion is displayed */
#endif

  r = vidomove_dispatch (m);

  return (r);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\vi_mode.c:1,024
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\vi_mode.c:1,093
parsing error 
{
  int c, save;

  c = m->motion;

  if (member (c, vi_motion))
    {
#if defined (READLINE_CALLBACKS)
      /* If we just read a vi-mode motion command numeric argument, turn off
	 the `reading numeric arg' state */
      if (RL_ISSTATE (RL_STATE_CALLBACK) && RL_VIMOVENUMARG())
	RL_UNSETSTATE (RL_STATE_NUMERICARG);
#endif
      /* Should do everything, including turning off RL_STATE_VIMOTION */
      return (rl_domove_motion_callback (m));
    }
  else if (m->key == c && (m->key == 'd' || m->key == 'y' || m->key == 'c'))
    {
      rl_mark = rl_end;
      rl_beg_of_line (1, c);
      _rl_vi_last_motion = c;
      RL_UNSETSTATE (RL_STATE_VIMOTION);
      return (0);
    }
#if defined (READLINE_CALLBACKS)
  /* XXX - these need to handle rl_universal_argument bindings */
  /* Reading vi motion char continuing numeric argument */
  else if (_rl_digit_p (c) && RL_ISSTATE (RL_STATE_CALLBACK) && RL_VIMOVENUMARG())
    {
      return (_rl_vi_arg_dispatch (c));
    }
  /* Readine vi motion char starting numeric argument */
  else if (_rl_digit_p (c) && RL_ISSTATE (RL_STATE_CALLBACK) && RL_ISSTATE (RL_STATE_VIMOTION) && (RL_ISSTATE (RL_STATE_NUMERICARG) == 0))
    {
      RL_SETSTATE (RL_STATE_NUMERICARG);
      return (_rl_vi_arg_dispatch (c));
    }
#endif
  else if (_rl_digit_p (c))
    {
      /* This code path taken when not in callback mode */
      save = rl_numeric_arg;
      rl_numeric_arg = _rl_digit_value (c);
      rl_explicit_arg = 1;
      RL_SETSTATE (RL_STATE_NUMERICARG);
      rl_digit_loop1 ();
      rl_numeric_arg *= save;
      c = rl_vi_domove_getchar (m);
      if (c < 0)
	{
	  m->motion = 0;
	  return -1;
	}
      m->motion = c;
      return (rl_domove_motion_callback (m));
    }
  else
    {
      RL_UNSETSTATE (RL_STATE_VIMOTION);
      RL_UNSETSTATE (RL_STATE_NUMERICARG);
      return (1);
    }
}
warning: parse error {
  int c, save;

  c = m->motion;

  if (member (c, vi_motion))
    {
#if defined (READLINE_CALLBACKS)
      /* If we just read a vi-mode motion command numeric argument, turn off
	 the `reading numeric arg' state */
      if (RL_ISSTATE (RL_STATE_CALLBACK) && RL_VIMOVENUMARG())
	RL_UNSETSTATE (RL_STATE_NUMERICARG);
#endif
      /* Should do everything, including turning off RL_STATE_VIMOTION */
      return (rl_domove_motion_callback (m));
    }
  else if (m->key == c && (m->key == 'd' || m->key == 'y' || m->key == 'c'))
    {
      rl_mark = rl_end;
      rl_beg_of_line (1, c);
      _rl_vi_last_motion = c;
      RL_UNSETSTATE (RL_STATE_VIMOTION);
      return (0);
    }
#if defined (READLINE_CALLBACKS)
  /* XXX - these need to handle rl_universal_argument bindings */
  /* Reading vi motion char continuing numeric argument */
  else if (_rl_digit_p (c) && RL_ISSTATE (RL_STATE_CALLBACK) && RL_VIMOVENUMARG())
    {
      return (_rl_vi_arg_dispatch (c));
    }
  /* Readine vi motion char starting numeric argument */
  else if (_rl_digit_p (c) && RL_ISSTATE (RL_STATE_CALLBACK) && RL_ISSTATE (RL_STATE_VIMOTION) && (RL_ISSTATE (RL_STATE_NUMERICARG) == 0))
    {
      RL_SETSTATE (RL_STATE_NUMERICARG);
      return (_rl_vi_arg_dispatch (c));
    }
#endif
  else if (_rl_digit_p (c))
    {
      /* This code path taken when not in callback mode */
      save = rl_numeric_arg;
      rl_numeric_arg = _rl_digit_value (c);
      rl_explicit_arg = 1;
      RL_SETSTATE (RL_STATE_NUMERICARG);
      rl_digit_loop1 ();
      rl_numeric_arg *= save;
      c = rl_vi_domove_getchar (m);
      if (c < 0)
	{
	  m->motion = 0;
	  return -1;
	}
      m->motion = c;
      return (rl_domove_motion_callback (m));
    }
  else
    {
      RL_UNSETSTATE (RL_STATE_VIMOTION);
      RL_UNSETSTATE (RL_STATE_NUMERICARG);
      return (1);
    }
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\vi_mode.c:1,095
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\vi_mode.c:1,160
parsing error 
{
  int c;

  RL_SETSTATE(RL_STATE_MOREINPUT);
  c = rl_read_key ();
  RL_UNSETSTATE(RL_STATE_MOREINPUT);

  return c;
}
warning: parse error {
  int c;

  RL_SETSTATE(RL_STATE_MOREINPUT);
  c = rl_read_key ();
  RL_UNSETSTATE(RL_STATE_MOREINPUT);

  return c;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\vi_mode.c:1,162
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\vi_mode.c:1,174
parsing error 
{
  int c, r;

  m->motion = c = rl_vi_domove_getchar (m);
  /* XXX - what to do if this returns -1?  Should we return 1 for eof to
     callback code? */
  r = rl_domove_read_callback (m);

  return ((r == 0) ? r : 1);	/* normalize return values */
}
warning: parse error {
  int c, r;

  m->motion = c = rl_vi_domove_getchar (m);
  /* XXX - what to do if this returns -1?  Should we return 1 for eof to
     callback code? */
  r = rl_domove_read_callback (m);

  return ((r == 0) ? r : 1);	/* normalize return values */
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\vi_mode.c:1,176
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\vi_mode.c:1,190
parsing error 
{
  int r;
  _rl_vimotion_cxt *m;

  m = _rl_vimvcxt;
  *ignore = m->motion = rl_vi_domove_getchar (m);

  if (m->motion < 0)
    {
      m->motion = 0;
      return -1;
    }

  return (rl_domove_read_callback (m));
}
warning: parse error {
  int r;
  _rl_vimotion_cxt *m;

  m = _rl_vimvcxt;
  *ignore = m->motion = rl_vi_domove_getchar (m);

  if (m->motion < 0)
    {
      m->motion = 0;
      return -1;
    }

  return (rl_domove_read_callback (m));
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\vi_mode.c:1,192
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\vi_mode.c:1,209
parsing error 
{
  /* These are the motion commands that do not require adjusting the
     mark. */
  if (((strchr (" l|h^0bBFT`", m->motion) == 0) && (rl_point >= m->start)) &&
      (rl_mark < rl_end))
    rl_mark++;

  rl_kill_text (rl_point, rl_mark);
  return (0);
}
warning: parse error {
  /* These are the motion commands that do not require adjusting the
     mark. */
  if (((strchr (" l|h^0bBFT`", m->motion) == 0) && (rl_point >= m->start)) &&
      (rl_mark < rl_end))
    rl_mark++;

  rl_kill_text (rl_point, rl_mark);
  return (0);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\vi_mode.c:1,211
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\vi_mode.c:1,223
parsing error 
{
  int c, r;

  _rl_vimvcxt = _rl_mvcxt_alloc (VIM_DELETE, key);
  _rl_vimvcxt->start = rl_point;

  rl_mark = rl_point;
  if (_rl_uppercase_p (key))
    {
      _rl_vimvcxt->motion = '$';
      r = rl_domove_motion_callback (_rl_vimvcxt);
    }
  else if (vi_redoing)
    {
      _rl_vimvcxt->motion = _rl_vi_last_motion;
      r = rl_domove_motion_callback (_rl_vimvcxt);
    }
#if defined (READLINE_CALLBACKS)
  else if (RL_ISSTATE (RL_STATE_CALLBACK))
    {
      RL_SETSTATE (RL_STATE_VIMOTION);
      return (0);
    }
#endif
  else
    r = rl_vi_domove (key, &c);

  if (r < 0)
    {
      rl_ding ();
      r = -1;
    }

  _rl_mvcxt_dispose (_rl_vimvcxt);
  _rl_vimvcxt = 0;

  return r;
}
warning: parse error {
  int c, r;

  _rl_vimvcxt = _rl_mvcxt_alloc (VIM_DELETE, key);
  _rl_vimvcxt->start = rl_point;

  rl_mark = rl_point;
  if (_rl_uppercase_p (key))
    {
      _rl_vimvcxt->motion = '$';
      r = rl_domove_motion_callback (_rl_vimvcxt);
    }
  else if (vi_redoing)
    {
      _rl_vimvcxt->motion = _rl_vi_last_motion;
      r = rl_domove_motion_callback (_rl_vimvcxt);
    }
#if defined (READLINE_CALLBACKS)
  else if (RL_ISSTATE (RL_STATE_CALLBACK))
    {
      RL_SETSTATE (RL_STATE_VIMOTION);
      return (0);
    }
#endif
  else
    r = rl_vi_domove (key, &c);

  if (r < 0)
    {
      rl_ding ();
      r = -1;
    }

  _rl_mvcxt_dispose (_rl_vimvcxt);
  _rl_vimvcxt = 0;

  return r;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\vi_mode.c:1,225
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\vi_mode.c:1,265
parsing error 
{
  /* These are the motion commands that do not require adjusting the
     mark.  c[wW] are handled by special-case code in rl_vi_domove(),
     and already leave the mark at the correct location. */
  if (((strchr (" l|hwW^0bBFT`", m->motion) == 0) && (rl_point >= m->start)) &&
      (rl_mark < rl_end))
    rl_mark++;

  /* The cursor never moves with c[wW]. */
  if ((_rl_to_upper (m->motion) == 'W') && rl_point < m->start)
    rl_point = m->start;

  if (vi_redoing)
    {
      if (vi_insert_buffer && *vi_insert_buffer)
	rl_begin_undo_group ();
      rl_delete_text (rl_point, rl_mark);
      if (vi_insert_buffer && *vi_insert_buffer)
	{
	  rl_insert_text (vi_insert_buffer);
	  rl_end_undo_group ();
	}
    }
  else
    {
      rl_begin_undo_group ();		/* to make the `u' command work */
      rl_kill_text (rl_point, rl_mark);
      /* `C' does not save the text inserted for undoing or redoing. */
      if (_rl_uppercase_p (m->key) == 0)
	_rl_vi_doing_insert = 1;
      /* XXX -- TODO -- use m->numericarg? */
      rl_vi_start_inserting (m->key, rl_numeric_arg, rl_arg_sign);
    }

  return (0);
}
warning: parse error {
  /* These are the motion commands that do not require adjusting the
     mark.  c[wW] are handled by special-case code in rl_vi_domove(),
     and already leave the mark at the correct location. */
  if (((strchr (" l|hwW^0bBFT`", m->motion) == 0) && (rl_point >= m->start)) &&
      (rl_mark < rl_end))
    rl_mark++;

  /* The cursor never moves with c[wW]. */
  if ((_rl_to_upper (m->motion) == 'W') && rl_point < m->start)
    rl_point = m->start;

  if (vi_redoing)
    {
      if (vi_insert_buffer && *vi_insert_buffer)
	rl_begin_undo_group ();
      rl_delete_text (rl_point, rl_mark);
      if (vi_insert_buffer && *vi_insert_buffer)
	{
	  rl_insert_text (vi_insert_buffer);
	  rl_end_undo_group ();
	}
    }
  else
    {
      rl_begin_undo_group ();		/* to make the `u' command work */
      rl_kill_text (rl_point, rl_mark);
      /* `C' does not save the text inserted for undoing or redoing. */
      if (_rl_uppercase_p (m->key) == 0)
	_rl_vi_doing_insert = 1;
      /* XXX -- TODO -- use m->numericarg? */
      rl_vi_start_inserting (m->key, rl_numeric_arg, rl_arg_sign);
    }

  return (0);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\vi_mode.c:1,267
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\vi_mode.c:1,305
parsing error 
{
  int c, r;

  _rl_vimvcxt = _rl_mvcxt_alloc (VIM_CHANGE, key);
  _rl_vimvcxt->start = rl_point;

  rl_mark = rl_point;
  if (_rl_uppercase_p (key))
    {
      _rl_vimvcxt->motion = '$';
      r = rl_domove_motion_callback (_rl_vimvcxt);
    }
  else if (vi_redoing)
    {
      _rl_vimvcxt->motion = _rl_vi_last_motion;
      r = rl_domove_motion_callback (_rl_vimvcxt);
    }
#if defined (READLINE_CALLBACKS)
  else if (RL_ISSTATE (RL_STATE_CALLBACK))
    {
      RL_SETSTATE (RL_STATE_VIMOTION);
      return (0);
    }
#endif
  else
    r = rl_vi_domove (key, &c);

  if (r < 0)
    {
      rl_ding ();
      r = -1;	/* normalize return value */
    }

  _rl_mvcxt_dispose (_rl_vimvcxt);
  _rl_vimvcxt = 0;

  return r;
}
warning: parse error {
  int c, r;

  _rl_vimvcxt = _rl_mvcxt_alloc (VIM_CHANGE, key);
  _rl_vimvcxt->start = rl_point;

  rl_mark = rl_point;
  if (_rl_uppercase_p (key))
    {
      _rl_vimvcxt->motion = '$';
      r = rl_domove_motion_callback (_rl_vimvcxt);
    }
  else if (vi_redoing)
    {
      _rl_vimvcxt->motion = _rl_vi_last_motion;
      r = rl_domove_motion_callback (_rl_vimvcxt);
    }
#if defined (READLINE_CALLBACKS)
  else if (RL_ISSTATE (RL_STATE_CALLBACK))
    {
      RL_SETSTATE (RL_STATE_VIMOTION);
      return (0);
    }
#endif
  else
    r = rl_vi_domove (key, &c);

  if (r < 0)
    {
      rl_ding ();
      r = -1;	/* normalize return value */
    }

  _rl_mvcxt_dispose (_rl_vimvcxt);
  _rl_vimvcxt = 0;

  return r;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\vi_mode.c:1,307
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\vi_mode.c:1,347
parsing error 
{
  /* These are the motion commands that do not require adjusting the
     mark. */
  if (((strchr (" l|h^0%bBFT`", m->motion) == 0) && (rl_point >= m->start)) &&
      (rl_mark < rl_end))
    rl_mark++;

  rl_begin_undo_group ();
  rl_kill_text (rl_point, rl_mark);
  rl_end_undo_group ();
  rl_do_undo ();
  rl_point = m->start;

  return (0);
}
warning: parse error {
  /* These are the motion commands that do not require adjusting the
     mark. */
  if (((strchr (" l|h^0%bBFT`", m->motion) == 0) && (rl_point >= m->start)) &&
      (rl_mark < rl_end))
    rl_mark++;

  rl_begin_undo_group ();
  rl_kill_text (rl_point, rl_mark);
  rl_end_undo_group ();
  rl_do_undo ();
  rl_point = m->start;

  return (0);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\vi_mode.c:1,349
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\vi_mode.c:1,366
parsing error 
{
  int c, r;

  _rl_vimvcxt = _rl_mvcxt_alloc (VIM_YANK, key);
  _rl_vimvcxt->start = rl_point;

  rl_mark = rl_point;
  if (_rl_uppercase_p (key))
    {
      _rl_vimvcxt->motion = '$';
      r = rl_domove_motion_callback (_rl_vimvcxt);
    }
#if defined (READLINE_CALLBACKS)
  else if (RL_ISSTATE (RL_STATE_CALLBACK))
    {
      RL_SETSTATE (RL_STATE_VIMOTION);
      return (0);
    }
#endif
  else
    r = rl_vi_domove (key, &c);

  if (r < 0)
    {
      rl_ding ();
      r = -1;
    }

  _rl_mvcxt_dispose (_rl_vimvcxt);
  _rl_vimvcxt = 0;

  return r;
}
warning: parse error {
  int c, r;

  _rl_vimvcxt = _rl_mvcxt_alloc (VIM_YANK, key);
  _rl_vimvcxt->start = rl_point;

  rl_mark = rl_point;
  if (_rl_uppercase_p (key))
    {
      _rl_vimvcxt->motion = '$';
      r = rl_domove_motion_callback (_rl_vimvcxt);
    }
#if defined (READLINE_CALLBACKS)
  else if (RL_ISSTATE (RL_STATE_CALLBACK))
    {
      RL_SETSTATE (RL_STATE_VIMOTION);
      return (0);
    }
#endif
  else
    r = rl_vi_domove (key, &c);

  if (r < 0)
    {
      rl_ding ();
      r = -1;
    }

  _rl_mvcxt_dispose (_rl_vimvcxt);
  _rl_vimvcxt = 0;

  return r;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\vi_mode.c:1,368
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\vi_mode.c:1,403
parsing error 
{
  int r;

  switch (m->op)
    {
    case VIM_DELETE:
      r = vi_delete_dispatch (m);
      break;
    case VIM_CHANGE:
      r = vi_change_dispatch (m);
      break;
    case VIM_YANK:
      r = vi_yank_dispatch (m);
      break;
    default:
      _rl_errmsg ("vidomove_dispatch: unknown operator %d", m->op);
      r = 1;
      break;
    }

  RL_UNSETSTATE (RL_STATE_VIMOTION);
  return r;
}
warning: parse error {
  int r;

  switch (m->op)
    {
    case VIM_DELETE:
      r = vi_delete_dispatch (m);
      break;
    case VIM_CHANGE:
      r = vi_change_dispatch (m);
      break;
    case VIM_YANK:
      r = vi_yank_dispatch (m);
      break;
    default:
      _rl_errmsg ("vidomove_dispatch: unknown operator %d", m->op);
      r = 1;
      break;
    }

  RL_UNSETSTATE (RL_STATE_VIMOTION);
  return r;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\vi_mode.c:1,405
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\vi_mode.c:1,430
parsing error 
{
  int opoint;

  if (count < 0)
    return (rl_vi_delete (-count, key));

  if (rl_point == 0)
    {
      rl_ding ();
      return -1;
    }

  opoint = rl_point;
  if (count > 1 && MB_CUR_MAX > 1 && rl_byte_oriented == 0)
    rl_backward_char (count, key);
  else if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
    rl_point = _rl_find_prev_mbchar (rl_line_buffer, rl_point, MB_FIND_NONZERO);
  else
    rl_point -= count;

  if (rl_point < 0)
    rl_point = 0;

  rl_kill_text (rl_point, opoint);
  
  return (0);
}
warning: parse error {
  int opoint;

  if (count < 0)
    return (rl_vi_delete (-count, key));

  if (rl_point == 0)
    {
      rl_ding ();
      return -1;
    }

  opoint = rl_point;
  if (count > 1 && MB_CUR_MAX > 1 && rl_byte_oriented == 0)
    rl_backward_char (count, key);
  else if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
    rl_point = _rl_find_prev_mbchar (rl_line_buffer, rl_point, MB_FIND_NONZERO);
  else
    rl_point -= count;

  if (rl_point < 0)
    rl_point = 0;

  rl_kill_text (rl_point, opoint);
  
  return (0);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\vi_mode.c:1,432
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\vi_mode.c:1,461
parsing error 
{
  int end;

  if (count < 0)
    return (rl_vi_rubout (-count, key));

  if (rl_end == 0)
    {
      rl_ding ();
      return -1;
    }

  if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
    end = _rl_find_next_mbchar (rl_line_buffer, rl_point, count, MB_FIND_NONZERO);
  else
    end = rl_point + count;

  if (end >= rl_end)
    end = rl_end;

  rl_kill_text (rl_point, end);
  
  if (rl_point > 0 && rl_point == rl_end)
    rl_backward_char (1, key);

  return (0);
}
warning: parse error {
  int end;

  if (count < 0)
    return (rl_vi_rubout (-count, key));

  if (rl_end == 0)
    {
      rl_ding ();
      return -1;
    }

  if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
    end = _rl_find_next_mbchar (rl_line_buffer, rl_point, count, MB_FIND_NONZERO);
  else
    end = rl_point + count;

  if (end >= rl_end)
    end = rl_end;

  rl_kill_text (rl_point, end);
  
  if (rl_point > 0 && rl_point == rl_end)
    rl_backward_char (1, key);

  return (0);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\vi_mode.c:1,463
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\vi_mode.c:1,492
parsing error 
{
  rl_beg_of_line (1, key);
  while (rl_point < rl_end && whitespace (rl_line_buffer[rl_point]))
    rl_point++;
  return (0);
}
warning: parse error {
  rl_beg_of_line (1, key);
  while (rl_point < rl_end && whitespace (rl_line_buffer[rl_point]))
    rl_point++;
  return (0);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\vi_mode.c:1,494
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\vi_mode.c:1,502
parsing error 
{
  return (rl_vi_back_to_indent (1, key));
}
warning: parse error {
  return (rl_vi_back_to_indent (1, key));
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\vi_mode.c:1,504
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\vi_mode.c:1,512
parsing error 
{
  int c;
#if defined (HANDLE_MULTIBYTE)
  c = _rl_vi_last_search_mblen = _rl_read_mbchar (_rl_vi_last_search_mbchar, MB_LEN_MAX);
#else
  RL_SETSTATE(RL_STATE_MOREINPUT);
  c = rl_read_key ();
  RL_UNSETSTATE(RL_STATE_MOREINPUT);
#endif

  if (c <= 0)
    return -1;

#if !defined (HANDLE_MULTIBYTE)
  _rl_vi_last_search_char = c;
#endif

  _rl_callback_func = 0;
  _rl_want_redisplay = 1;

#if defined (HANDLE_MULTIBYTE)
  return (_rl_char_search_internal (data->count, _rl_cs_dir, _rl_vi_last_search_mbchar, _rl_vi_last_search_mblen));
#else
  return (_rl_char_search_internal (data->count, _rl_cs_dir, _rl_vi_last_search_char));
#endif  
}
warning: parse error {
  int c;
#if defined (HANDLE_MULTIBYTE)
  c = _rl_vi_last_search_mblen = _rl_read_mbchar (_rl_vi_last_search_mbchar, MB_LEN_MAX);
#else
  RL_SETSTATE(RL_STATE_MOREINPUT);
  c = rl_read_key ();
  RL_UNSETSTATE(RL_STATE_MOREINPUT);
#endif

  if (c <= 0)
    return -1;

#if !defined (HANDLE_MULTIBYTE)
  _rl_vi_last_search_char = c;
#endif

  _rl_callback_func = 0;
  _rl_want_redisplay = 1;

#if defined (HANDLE_MULTIBYTE)
  return (_rl_char_search_internal (data->count, _rl_cs_dir, _rl_vi_last_search_mbchar, _rl_vi_last_search_mblen));
#else
  return (_rl_char_search_internal (data->count, _rl_cs_dir, _rl_vi_last_search_char));
#endif  
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\vi_mode.c:1,514
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\vi_mode.c:1,543
parsing error 
{
  int c;
#if defined (HANDLE_MULTIBYTE)
  static char *target;
  static int tlen;
#else
  static char target;
#endif

  if (key == ';' || key == ',')
    {
      if (_rl_cs_orig_dir == 0)
	return -1;
#if defined (HANDLE_MULTIBYTE)
      if (_rl_vi_last_search_mblen == 0)
	return -1;
#else
      if (_rl_vi_last_search_char == 0)
	return -1;
#endif
      _rl_cs_dir = (key == ';') ? _rl_cs_orig_dir : -_rl_cs_orig_dir;
    }
  else
    {
      switch (key)
	{
	case 't':
	  _rl_cs_orig_dir = _rl_cs_dir = FTO;
	  break;

	case 'T':
	  _rl_cs_orig_dir = _rl_cs_dir = BTO;
	  break;

	case 'f':
	  _rl_cs_orig_dir = _rl_cs_dir = FFIND;
	  break;

	case 'F':
	  _rl_cs_orig_dir = _rl_cs_dir = BFIND;
	  break;
	}

      if (vi_redoing)
	{
	  /* set target and tlen below */
	}
#if defined (READLINE_CALLBACKS)
      else if (RL_ISSTATE (RL_STATE_CALLBACK))
	{
	  _rl_callback_data = _rl_callback_data_alloc (count);
	  _rl_callback_data->i1 = _rl_cs_dir;
	  _rl_callback_func = _rl_vi_callback_char_search;
	  return (0);
	}
#endif
      else
	{
#if defined (HANDLE_MULTIBYTE)
	  c = _rl_read_mbchar (_rl_vi_last_search_mbchar, MB_LEN_MAX);
	  if (c <= 0)
	    return -1;
	  _rl_vi_last_search_mblen = c;
#else
	  RL_SETSTATE(RL_STATE_MOREINPUT);
	  c = rl_read_key ();
	  RL_UNSETSTATE(RL_STATE_MOREINPUT);
	  if (c < 0)
	    return -1;
	  _rl_vi_last_search_char = c;
#endif
	}
    }

#if defined (HANDLE_MULTIBYTE)
  target = _rl_vi_last_search_mbchar;
  tlen = _rl_vi_last_search_mblen;
#else
  target = _rl_vi_last_search_char;
#endif

#if defined (HANDLE_MULTIBYTE)
  return (_rl_char_search_internal (count, _rl_cs_dir, target, tlen));
#else
  return (_rl_char_search_internal (count, _rl_cs_dir, target));
#endif
}
warning: parse error {
  int c;
#if defined (HANDLE_MULTIBYTE)
  static char *target;
  static int tlen;
#else
  static char target;
#endif

  if (key == ';' || key == ',')
    {
      if (_rl_cs_orig_dir == 0)
	return -1;
#if defined (HANDLE_MULTIBYTE)
      if (_rl_vi_last_search_mblen == 0)
	return -1;
#else
      if (_rl_vi_last_search_char == 0)
	return -1;
#endif
      _rl_cs_dir = (key == ';') ? _rl_cs_orig_dir : -_rl_cs_orig_dir;
    }
  else
    {
      switch (key)
	{
	case 't':
	  _rl_cs_orig_dir = _rl_cs_dir = FTO;
	  break;

	case 'T':
	  _rl_cs_orig_dir = _rl_cs_dir = BTO;
	  break;

	case 'f':
	  _rl_cs_orig_dir = _rl_cs_dir = FFIND;
	  break;

	case 'F':
	  _rl_cs_orig_dir = _rl_cs_dir = BFIND;
	  break;
	}

      if (vi_redoing)
	{
	  /* set target and tlen below */
	}
#if defined (READLINE_CALLBACKS)
      else if (RL_ISSTATE (RL_STATE_CALLBACK))
	{
	  _rl_callback_data = _rl_callback_data_alloc (count);
	  _rl_callback_data->i1 = _rl_cs_dir;
	  _rl_callback_func = _rl_vi_callback_char_search;
	  return (0);
	}
#endif
      else
	{
#if defined (HANDLE_MULTIBYTE)
	  c = _rl_read_mbchar (_rl_vi_last_search_mbchar, MB_LEN_MAX);
	  if (c <= 0)
	    return -1;
	  _rl_vi_last_search_mblen = c;
#else
	  RL_SETSTATE(RL_STATE_MOREINPUT);
	  c = rl_read_key ();
	  RL_UNSETSTATE(RL_STATE_MOREINPUT);
	  if (c < 0)
	    return -1;
	  _rl_vi_last_search_char = c;
#endif
	}
    }

#if defined (HANDLE_MULTIBYTE)
  target = _rl_vi_last_search_mbchar;
  tlen = _rl_vi_last_search_mblen;
#else
  target = _rl_vi_last_search_char;
#endif

#if defined (HANDLE_MULTIBYTE)
  return (_rl_char_search_internal (count, _rl_cs_dir, target, tlen));
#else
  return (_rl_char_search_internal (count, _rl_cs_dir, target));
#endif
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\vi_mode.c:1,545
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\vi_mode.c:1,635
parsing error 
{
  int count = 1, brack, pos, tmp, pre;

  pos = rl_point;
  if ((brack = rl_vi_bracktype (rl_line_buffer[rl_point])) == 0)
    {
      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
	{
	  while ((brack = rl_vi_bracktype (rl_line_buffer[rl_point])) == 0)
	    {
	      pre = rl_point;
	      rl_forward_char (1, key);
	      if (pre == rl_point)
		break;
	    }
	}
      else
	while ((brack = rl_vi_bracktype (rl_line_buffer[rl_point])) == 0 &&
		rl_point < rl_end - 1)
	  rl_forward_char (1, key);

      if (brack <= 0)
	{
	  rl_point = pos;
	  rl_ding ();
	  return -1;
	}
    }

  pos = rl_point;

  if (brack < 0)
    {
      while (count)
	{
	  tmp = pos;
	  if (MB_CUR_MAX == 1 || rl_byte_oriented)
	    pos--;
	  else
	    {
	      pos = _rl_find_prev_mbchar (rl_line_buffer, pos, MB_FIND_ANY);
	      if (tmp == pos)
		pos--;
	    }
	  if (pos >= 0)
	    {
	      int b = rl_vi_bracktype (rl_line_buffer[pos]);
	      if (b == -brack)
		count--;
	      else if (b == brack)
		count++;
	    }
	  else
	    {
	      rl_ding ();
	      return -1;
	    }
	}
    }
  else
    {			/* brack > 0 */
      while (count)
	{
	  if (MB_CUR_MAX == 1 || rl_byte_oriented)
	    pos++;
	  else
	    pos = _rl_find_next_mbchar (rl_line_buffer, pos, 1, MB_FIND_ANY);

	  if (pos < rl_end)
	    {
	      int b = rl_vi_bracktype (rl_line_buffer[pos]);
	      if (b == -brack)
		count--;
	      else if (b == brack)
		count++;
	    }
	  else
	    {
	      rl_ding ();
	      return -1;
	    }
	}
    }
  rl_point = pos;
  return (0);
}
warning: parse error {
  int count = 1, brack, pos, tmp, pre;

  pos = rl_point;
  if ((brack = rl_vi_bracktype (rl_line_buffer[rl_point])) == 0)
    {
      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
	{
	  while ((brack = rl_vi_bracktype (rl_line_buffer[rl_point])) == 0)
	    {
	      pre = rl_point;
	      rl_forward_char (1, key);
	      if (pre == rl_point)
		break;
	    }
	}
      else
	while ((brack = rl_vi_bracktype (rl_line_buffer[rl_point])) == 0 &&
		rl_point < rl_end - 1)
	  rl_forward_char (1, key);

      if (brack <= 0)
	{
	  rl_point = pos;
	  rl_ding ();
	  return -1;
	}
    }

  pos = rl_point;

  if (brack < 0)
    {
      while (count)
	{
	  tmp = pos;
	  if (MB_CUR_MAX == 1 || rl_byte_oriented)
	    pos--;
	  else
	    {
	      pos = _rl_find_prev_mbchar (rl_line_buffer, pos, MB_FIND_ANY);
	      if (tmp == pos)
		pos--;
	    }
	  if (pos >= 0)
	    {
	      int b = rl_vi_bracktype (rl_line_buffer[pos]);
	      if (b == -brack)
		count--;
	      else if (b == brack)
		count++;
	    }
	  else
	    {
	      rl_ding ();
	      return -1;
	    }
	}
    }
  else
    {			/* brack > 0 */
      while (count)
	{
	  if (MB_CUR_MAX == 1 || rl_byte_oriented)
	    pos++;
	  else
	    pos = _rl_find_next_mbchar (rl_line_buffer, pos, 1, MB_FIND_ANY);

	  if (pos < rl_end)
	    {
	      int b = rl_vi_bracktype (rl_line_buffer[pos]);
	      if (b == -brack)
		count--;
	      else if (b == brack)
		count++;
	    }
	  else
	    {
	      rl_ding ();
	      return -1;
	    }
	}
    }
  rl_point = pos;
  return (0);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\vi_mode.c:1,637
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\vi_mode.c:1,725
parsing error 
{
  switch (c)
    {
    case '(': return  1;
    case ')': return -1;
    case '[': return  2;
    case ']': return -2;
    case '{': return  3;
    case '}': return -3;
    default:  return  0;
    }
}
warning: parse error {
  switch (c)
    {
    case '(': return  1;
    case ')': return -1;
    case '[': return  2;
    case ']': return -2;
    case '{': return  3;
    case '}': return -3;
    default:  return  0;
    }
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\vi_mode.c:1,727
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\vi_mode.c:1,741
parsing error 
{
  int p;

  if (c == '\033' || c == CTRL ('C'))
    return -1;

  rl_begin_undo_group ();
  while (count-- && rl_point < rl_end)
    {
      p = rl_point;
      rl_vi_delete (1, c);
      if (rl_point < p)		/* Did we retreat at EOL? */
	rl_point++;
#if defined (HANDLE_MULTIBYTE)
      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
	rl_insert_text (mb);
      else
#endif
	_rl_insert_char (1, c);
    }

  /* The cursor shall be left on the last character changed. */
  rl_backward_char (1, c);

  rl_end_undo_group ();

  return (0);
}
warning: parse error {
  int p;

  if (c == '\033' || c == CTRL ('C'))
    return -1;

  rl_begin_undo_group ();
  while (count-- && rl_point < rl_end)
    {
      p = rl_point;
      rl_vi_delete (1, c);
      if (rl_point < p)		/* Did we retreat at EOL? */
	rl_point++;
#if defined (HANDLE_MULTIBYTE)
      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
	rl_insert_text (mb);
      else
#endif
	_rl_insert_char (1, c);
    }

  /* The cursor shall be left on the last character changed. */
  rl_backward_char (1, c);

  rl_end_undo_group ();

  return (0);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\vi_mode.c:1,744
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\vi_mode.c:1,774
parsing error 
{
  int c;

  RL_SETSTATE(RL_STATE_MOREINPUT);
  c = rl_read_key ();
  RL_UNSETSTATE(RL_STATE_MOREINPUT);

  if (c < 0)
    return -1;

#if defined (HANDLE_MULTIBYTE)
  if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
    c = _rl_read_mbstring (c, mb, mlen);
#endif

  return c;
}
warning: parse error {
  int c;

  RL_SETSTATE(RL_STATE_MOREINPUT);
  c = rl_read_key ();
  RL_UNSETSTATE(RL_STATE_MOREINPUT);

  if (c < 0)
    return -1;

#if defined (HANDLE_MULTIBYTE)
  if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
    c = _rl_read_mbstring (c, mb, mlen);
#endif

  return c;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\vi_mode.c:1,777
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\vi_mode.c:1,797
parsing error 
{
  int c;
  char mb[MB_LEN_MAX];

  _rl_vi_last_replacement = c = _rl_vi_callback_getchar (mb, MB_LEN_MAX);

  if (c < 0)
    return -1;

  _rl_callback_func = 0;
  _rl_want_redisplay = 1;

  return (_rl_vi_change_char (data->count, c, mb));
}
warning: parse error {
  int c;
  char mb[MB_LEN_MAX];

  _rl_vi_last_replacement = c = _rl_vi_callback_getchar (mb, MB_LEN_MAX);

  if (c < 0)
    return -1;

  _rl_callback_func = 0;
  _rl_want_redisplay = 1;

  return (_rl_vi_change_char (data->count, c, mb));
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\vi_mode.c:1,799
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\vi_mode.c:1,816
parsing error 
{
  int c;
  char mb[MB_LEN_MAX];

  if (vi_redoing)
    {
      c = _rl_vi_last_replacement;
      mb[0] = c;
      mb[1] = '\0';
    }
#if defined (READLINE_CALLBACKS)
  else if (RL_ISSTATE (RL_STATE_CALLBACK))
    {
      _rl_callback_data = _rl_callback_data_alloc (count);
      _rl_callback_func = _rl_vi_callback_change_char;
      return (0);
    }
#endif
  else
    _rl_vi_last_replacement = c = _rl_vi_callback_getchar (mb, MB_LEN_MAX);

  if (c < 0)
    return -1;

  return (_rl_vi_change_char (count, c, mb));
}
warning: parse error {
  int c;
  char mb[MB_LEN_MAX];

  if (vi_redoing)
    {
      c = _rl_vi_last_replacement;
      mb[0] = c;
      mb[1] = '\0';
    }
#if defined (READLINE_CALLBACKS)
  else if (RL_ISSTATE (RL_STATE_CALLBACK))
    {
      _rl_callback_data = _rl_callback_data_alloc (count);
      _rl_callback_func = _rl_vi_callback_change_char;
      return (0);
    }
#endif
  else
    _rl_vi_last_replacement = c = _rl_vi_callback_getchar (mb, MB_LEN_MAX);

  if (c < 0)
    return -1;

  return (_rl_vi_change_char (count, c, mb));
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\vi_mode.c:1,818
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\vi_mode.c:1,846
parsing error 
{
  /* If we are redoing, rl_vi_change_to will stuff the last motion char */
  if (vi_redoing == 0)
    rl_stuff_char ((key == 'S') ? 'c' : 'l');	/* `S' == `cc', `s' == `cl' */

  return (rl_vi_change_to (count, 'c'));
}
warning: parse error {
  /* If we are redoing, rl_vi_change_to will stuff the last motion char */
  if (vi_redoing == 0)
    rl_stuff_char ((key == 'S') ? 'c' : 'l');	/* `S' == `cc', `s' == `cl' */

  return (rl_vi_change_to (count, 'c'));
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\vi_mode.c:1,848
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\vi_mode.c:1,857
parsing error 
{
  if (_rl_vi_doing_insert == 0)
    {
      _rl_vi_doing_insert = 1;
      rl_begin_undo_group ();
    }

  if (count > 0)
    {
      _rl_overwrite_char (count, key);
      vi_replace_count += count;
    }

  return (0);
}
warning: parse error {
  if (_rl_vi_doing_insert == 0)
    {
      _rl_vi_doing_insert = 1;
      rl_begin_undo_group ();
    }

  if (count > 0)
    {
      _rl_overwrite_char (count, key);
      vi_replace_count += count;
    }

  return (0);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\vi_mode.c:1,859
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\vi_mode.c:1,876
parsing error 
{
  int i, s;

  for (i = 0; i < count; i++)
    {
      if (vi_replace_count == 0)
	{
	  rl_ding ();
	  break;
	}
      s = rl_point;

      if (rl_do_undo ())
	vi_replace_count--;

      if (rl_point == s)
	rl_backward_char (1, key);
    }

  if (vi_replace_count == 0 && _rl_vi_doing_insert)
    {
      rl_end_undo_group ();
      rl_do_undo ();
      _rl_vi_doing_insert = 0;
    }
  return (0);
}
warning: parse error {
  int i, s;

  for (i = 0; i < count; i++)
    {
      if (vi_replace_count == 0)
	{
	  rl_ding ();
	  break;
	}
      s = rl_point;

      if (rl_do_undo ())
	vi_replace_count--;

      if (rl_point == s)
	rl_backward_char (1, key);
    }

  if (vi_replace_count == 0 && _rl_vi_doing_insert)
    {
      rl_end_undo_group ();
      rl_do_undo ();
      _rl_vi_doing_insert = 0;
    }
  return (0);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\vi_mode.c:1,878
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\vi_mode.c:1,907
parsing error 
{
  int i;

  vi_replace_count = 0;

  if (!vi_replace_map)
    {
      vi_replace_map = rl_make_bare_keymap ();

      for (i = ' '; i < KEYMAP_SIZE; i++)
	vi_replace_map[i].function = rl_vi_overstrike;

      vi_replace_map[RUBOUT].function = rl_vi_overstrike_delete;
      vi_replace_map[ESC].function = rl_vi_movement_mode;
      vi_replace_map[RETURN].function = rl_newline;
      vi_replace_map[NEWLINE].function = rl_newline;

      /* If the normal vi insertion keymap has ^H bound to erase, do the
	 same here.  Probably should remove the assignment to RUBOUT up
	 there, but I don't think it will make a difference in real life. */
      if (vi_insertion_keymap[CTRL ('H')].type == ISFUNC &&
	  vi_insertion_keymap[CTRL ('H')].function == rl_rubout)
	vi_replace_map[CTRL ('H')].function = rl_vi_overstrike_delete;

    }
  _rl_keymap = vi_replace_map;
  return (0);
}
warning: parse error {
  int i;

  vi_replace_count = 0;

  if (!vi_replace_map)
    {
      vi_replace_map = rl_make_bare_keymap ();

      for (i = ' '; i < KEYMAP_SIZE; i++)
	vi_replace_map[i].function = rl_vi_overstrike;

      vi_replace_map[RUBOUT].function = rl_vi_overstrike_delete;
      vi_replace_map[ESC].function = rl_vi_movement_mode;
      vi_replace_map[RETURN].function = rl_newline;
      vi_replace_map[NEWLINE].function = rl_newline;

      /* If the normal vi insertion keymap has ^H bound to erase, do the
	 same here.  Probably should remove the assignment to RUBOUT up
	 there, but I don't think it will make a difference in real life. */
      if (vi_insertion_keymap[CTRL ('H')].type == ISFUNC &&
	  vi_insertion_keymap[CTRL ('H')].function == rl_rubout)
	vi_replace_map[CTRL ('H')].function = rl_vi_overstrike_delete;

    }
  _rl_keymap = vi_replace_map;
  return (0);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\vi_mode.c:1,909
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\vi_mode.c:1,988
parsing error 
{
  _rl_callback_func = 0;
  _rl_want_redisplay = 1;

  return (_rl_vi_set_mark ());
}
warning: parse error {
  _rl_callback_func = 0;
  _rl_want_redisplay = 1;

  return (_rl_vi_set_mark ());
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\vi_mode.c:1,990
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\vi_mode.c:1,999
parsing error 
{
#if defined (READLINE_CALLBACKS)
  if (RL_ISSTATE (RL_STATE_CALLBACK))
    {
      _rl_callback_data = 0;
      _rl_callback_func = _rl_vi_callback_set_mark;
      return (0);
    }
#endif

  return (_rl_vi_set_mark ());
}
warning: parse error {
#if defined (READLINE_CALLBACKS)
  if (RL_ISSTATE (RL_STATE_CALLBACK))
    {
      _rl_callback_data = 0;
      _rl_callback_func = _rl_vi_callback_set_mark;
      return (0);
    }
#endif

  return (_rl_vi_set_mark ());
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\vi_mode.c:2,001
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\vi_mode.c:2,046
parsing error 
{
  _rl_callback_func = 0;
  _rl_want_redisplay = 1;

  return (_rl_vi_goto_mark ());
}
warning: parse error {
  _rl_callback_func = 0;
  _rl_want_redisplay = 1;

  return (_rl_vi_goto_mark ());
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\vi_mode.c:2,048
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\vi_mode.c:2,057
parsing error 
{
#if defined (READLINE_CALLBACKS)
  if (RL_ISSTATE (RL_STATE_CALLBACK))
    {
      _rl_callback_data = 0;
      _rl_callback_func = _rl_vi_callback_goto_mark;
      return (0);
    }
#endif

  return (_rl_vi_goto_mark ());
}
warning: parse error {
#if defined (READLINE_CALLBACKS)
  if (RL_ISSTATE (RL_STATE_CALLBACK))
    {
      _rl_callback_data = 0;
      _rl_callback_func = _rl_vi_callback_goto_mark;
      return (0);
    }
#endif

  return (_rl_vi_goto_mark ());
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\vi_mode.c:2,059
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\xfree.c...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\xmalloc.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\xfree.c:45
parsing error 
{
  if (string)
    free (string);
}
warning: parse error {
  if (string)
    free (string);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\xfree.c:47
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\xmalloc.c...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\xmalloc.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\xmalloc.c:45
parsing error 
{
  fprintf (stderr, "%s: out of virtual memory\n", fname);
  exit (2);
}
warning: parse error {
  fprintf (stderr, "%s: out of virtual memory\n", fname);
  exit (2);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\xmalloc.c:47
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\xmalloc.c:56
parsing error 
{
  PTR_T temp;

  temp = malloc (bytes);
  if (temp == 0)
    memory_error_and_abort ("xmalloc");
  return (temp);
}
warning: parse error {
  PTR_T temp;

  temp = malloc (bytes);
  if (temp == 0)
    memory_error_and_abort ("xmalloc");
  return (temp);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\xmalloc.c:58
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\xmalloc.c:68
parsing error 
{
  PTR_T temp;

  temp = pointer ? realloc (pointer, bytes) : malloc (bytes);

  if (temp == 0)
    memory_error_and_abort ("xrealloc");
  return (temp);
}
warning: parse error {
  PTR_T temp;

  temp = pointer ? realloc (pointer, bytes) : malloc (bytes);

  if (temp == 0)
    memory_error_and_abort ("xrealloc");
  return (temp);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\xmalloc.c:71
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\casemod.c...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\stdc.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\bashansi.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\bashintl.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\bashtypes.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\xmalloc.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\shmbutil.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\chartypes.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\glob\strmatch.h...skip
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\casemod.c:98
parsing error 
{
  int start, next, end;
  int inword, c, nc, nop, match, usewords;
  char *ret, *s;
  wchar_t wc;
#if defined (HANDLE_MULTIBYTE)
  wchar_t nwc;
  char mb[MB_LEN_MAX+1];
  int mlen;
  size_t m;
  mbstate_t state;
#endif

  if (string == 0 || *string == 0)
    {
      ret = (char *)xmalloc (1);
      ret[0] = '\0';
      return ret;
    }

#if defined (HANDLE_MULTIBYTE)
  memset (&state, 0, sizeof (mbstate_t));
#endif

  start = 0;
  end = strlen (string);

  ret = (char *)xmalloc (end + 1);
  strcpy (ret, string);

  /* See if we are supposed to split on alphanumerics and operate on each word */
  usewords = (flags & CASE_USEWORDS);
  flags &= ~CASE_USEWORDS;

  inword = 0;
  while (start < end)
    {
      wc = cval (ret, start);

      if (iswalnum (wc) == 0)
	{
	  inword = 0;
	  ADVANCE_CHAR (ret, end, start);
	  continue;
	}

      if (pat)
	{
	  next = start;
	  ADVANCE_CHAR (ret, end, next);
	  s = substring (ret, start, next);
	  match = strmatch (pat, s, FNM_EXTMATCH) != FNM_NOMATCH;
	  free (s);
	  if (match == 0)
            {
              start = next;
              inword = 1;
              continue;
            }
	}

      /* XXX - for now, the toggling operators work on the individual
	 words in the string, breaking on alphanumerics.  Should I
	 leave the capitalization operators to do that also? */
      if (flags == CASE_CAPITALIZE)
	{
	  if (usewords)
	    nop = inword ? CASE_LOWER : CASE_UPPER;
	  else
	    nop = (start > 0) ? CASE_LOWER : CASE_UPPER;
	  inword = 1;
	}
      else if (flags == CASE_UNCAP)
	{
	  if (usewords)
	    nop = inword ? CASE_UPPER : CASE_LOWER;
	  else
	    nop = (start > 0) ? CASE_UPPER : CASE_LOWER;
	  inword = 1;
	}
      else if (flags == CASE_UPFIRST)
 	{
 	  if (usewords)
	    nop = inword ? CASE_NOOP : CASE_UPPER;
	  else
	    nop = (start > 0) ? CASE_NOOP : CASE_UPPER;
 	  inword = 1;
 	}
      else if (flags == CASE_LOWFIRST)
 	{
 	  if (usewords)
	    nop = inword ? CASE_NOOP : CASE_LOWER;
	  else
	    nop = (start > 0) ? CASE_NOOP : CASE_LOWER;
 	  inword = 1;
 	}
      else if (flags == CASE_TOGGLE)
	{
	  nop = inword ? CASE_NOOP : CASE_TOGGLE;
	  inword = 1;
	}
      else
	nop = flags;

      if (MB_CUR_MAX == 1 || isascii (wc))
	{
	  switch (nop)
	  {
	  default:
	  case CASE_NOOP:  nc = wc; break;
	  case CASE_UPPER:  nc = TOUPPER (wc); break;
	  case CASE_LOWER:  nc = TOLOWER (wc); break;
	  case CASE_TOGGLEALL:
	  case CASE_TOGGLE: nc = TOGGLE (wc); break;
	  }
	  ret[start] = nc;
	}
#if defined (HANDLE_MULTIBYTE)
      else
	{
	  m = mbrtowc (&wc, string + start, end - start, &state);
	  if (MB_INVALIDCH (m))
	    wc = (wchar_t)string[start];
	  else if (MB_NULLWCH (m))
	    wc = L'\0';
	  switch (nop)
	  {
	  default:
	  case CASE_NOOP:  nwc = wc; break;
	  case CASE_UPPER:  nwc = TOUPPER (wc); break;
	  case CASE_LOWER:  nwc = TOLOWER (wc); break;
	  case CASE_TOGGLEALL:
	  case CASE_TOGGLE: nwc = TOGGLE (wc); break;
	  }
	  if  (nwc != wc)	/*  just skip unchanged characters */
	    {
	      mlen = wcrtomb (mb, nwc, &state);
	      if (mlen > 0)
		mb[mlen] = '\0';
	      /* Assume the same width */
	      strncpy (ret + start, mb, mlen);
	    }
	}
#endif

      /*  This assumes that the upper and lower case versions are the same width. */
      ADVANCE_CHAR (ret, end, start);
    }

  return ret;
}
warning: parse error {
  int start, next, end;
  int inword, c, nc, nop, match, usewords;
  char *ret, *s;
  wchar_t wc;
#if defined (HANDLE_MULTIBYTE)
  wchar_t nwc;
  char mb[MB_LEN_MAX+1];
  int mlen;
  size_t m;
  mbstate_t state;
#endif

  if (string == 0 || *string == 0)
    {
      ret = (char *)xmalloc (1);
      ret[0] = '\0';
      return ret;
    }

#if defined (HANDLE_MULTIBYTE)
  memset (&state, 0, sizeof (mbstate_t));
#endif

  start = 0;
  end = strlen (string);

  ret = (char *)xmalloc (end + 1);
  strcpy (ret, string);

  /* See if we are supposed to split on alphanumerics and operate on each word */
  usewords = (flags & CASE_USEWORDS);
  flags &= ~CASE_USEWORDS;

  inword = 0;
  while (start < end)
    {
      wc = cval (ret, start);

      if (iswalnum (wc) == 0)
	{
	  inword = 0;
	  ADVANCE_CHAR (ret, end, start);
	  continue;
	}

      if (pat)
	{
	  next = start;
	  ADVANCE_CHAR (ret, end, next);
	  s = substring (ret, start, next);
	  match = strmatch (pat, s, FNM_EXTMATCH) != FNM_NOMATCH;
	  free (s);
	  if (match == 0)
            {
              start = next;
              inword = 1;
              continue;
            }
	}

      /* XXX - for now, the toggling operators work on the individual
	 words in the string, breaking on alphanumerics.  Should I
	 leave the capitalization operators to do that also? */
      if (flags == CASE_CAPITALIZE)
	{
	  if (usewords)
	    nop = inword ? CASE_LOWER : CASE_UPPER;
	  else
	    nop = (start > 0) ? CASE_LOWER : CASE_UPPER;
	  inword = 1;
	}
      else if (flags == CASE_UNCAP)
	{
	  if (usewords)
	    nop = inword ? CASE_UPPER : CASE_LOWER;
	  else
	    nop = (start > 0) ? CASE_UPPER : CASE_LOWER;
	  inword = 1;
	}
      else if (flags == CASE_UPFIRST)
 	{
 	  if (usewords)
	    nop = inword ? CASE_NOOP : CASE_UPPER;
	  else
	    nop = (start > 0) ? CASE_NOOP : CASE_UPPER;
 	  inword = 1;
 	}
      else if (flags == CASE_LOWFIRST)
 	{
 	  if (usewords)
	    nop = inword ? CASE_NOOP : CASE_LOWER;
	  else
	    nop = (start > 0) ? CASE_NOOP : CASE_LOWER;
 	  inword = 1;
 	}
      else if (flags == CASE_TOGGLE)
	{
	  nop = inword ? CASE_NOOP : CASE_TOGGLE;
	  inword = 1;
	}
      else
	nop = flags;

      if (MB_CUR_MAX == 1 || isascii (wc))
	{
	  switch (nop)
	  {
	  default:
	  case CASE_NOOP:  nc = wc; break;
	  case CASE_UPPER:  nc = TOUPPER (wc); break;
	  case CASE_LOWER:  nc = TOLOWER (wc); break;
	  case CASE_TOGGLEALL:
	  case CASE_TOGGLE: nc = TOGGLE (wc); break;
	  }
	  ret[start] = nc;
	}
#if defined (HANDLE_MULTIBYTE)
      else
	{
	  m = mbrtowc (&wc, string + start, end - start, &state);
	  if (MB_INVALIDCH (m))
	    wc = (wchar_t)string[start];
	  else if (MB_NULLWCH (m))
	    wc = L'\0';
	  switch (nop)
	  {
	  default:
	  case CASE_NOOP:  nwc = wc; break;
	  case CASE_UPPER:  nwc = TOUPPER (wc); break;
	  case CASE_LOWER:  nwc = TOLOWER (wc); break;
	  case CASE_TOGGLEALL:
	  case CASE_TOGGLE: nwc = TOGGLE (wc); break;
	  }
	  if  (nwc != wc)	/*  just skip unchanged characters */
	    {
	      mlen = wcrtomb (mb, nwc, &state);
	      if (mlen > 0)
		mb[mlen] = '\0';
	      /* Assume the same width */
	      strncpy (ret + start, mb, mlen);
	    }
	}
#endif

      /*  This assumes that the upper and lower case versions are the same width. */
      ADVANCE_CHAR (ret, end, start);
    }

  return ret;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\casemod.c:101
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\clktck.c...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\bashtypes.h...skip
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\clock.c...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\posixtime.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\stdc.h...skip
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\dprintf.c...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\stdc.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\dprintf.c:43
parsing error 
va_dcl
#endif
{
  FILE *fp;
  int fd2, rc, r2;
  va_list args;

  if ((fd2 = dup(fd)) < 0)
    return -1;
  fp = fdopen (fd2, "w");
  if (fp == 0)
    {
      close (fd2);
      return -1;
    }

  SH_VA_START (args, format);
  rc = vfprintf (fp, format, args);
  fflush (fp);
  va_end (args);

  r2 = fclose (fp);	/* check here */

  return rc;
}
warning: parse error va_dcl
#endif
{
  FILE *fp;
  int fd2, rc, r2;
  va_list args;

  if ((fd2 = dup(fd)) < 0)
    return -1;
  fp = fdopen (fd2, "w");
  if (fp == 0)
    {
      close (fd2);
      return -1;
    }

  SH_VA_START (args, format);
  rc = vfprintf (fp, format, args);
  fflush (fp);
  va_end (args);

  r2 = fclose (fp);	/* check here */

  return rc;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\dprintf.c:46
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\eaccess.c...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\bashtypes.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\bashansi.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\posixstat.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\filecntl.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\shell.h...skip
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\eaccess.c:63
parsing error 
{
  if (path[0] == '/' && path[1] == 'd' && strncmp (path, "/dev/fd/", 8) == 0)
    return 1;
  else if (STREQN (path, "/dev/std", 8))
    {
      if (STREQ (path+8, "in") || STREQ (path+8, "out") || STREQ (path+8, "err"))
	return 1;
      else
	return 0;
    }
  else
    return 0;
}
warning: parse error {
  if (path[0] == '/' && path[1] == 'd' && strncmp (path, "/dev/fd/", 8) == 0)
    return 1;
  else if (STREQN (path, "/dev/std", 8))
    {
      if (STREQ (path+8, "in") || STREQ (path+8, "out") || STREQ (path+8, "err"))
	return 1;
      else
	return 0;
    }
  else
    return 0;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\eaccess.c:64
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\eaccess.c:82
parsing error 
{
  if (*path == '\0')
    {
      errno = ENOENT;
      return (-1);
    }
  if (path[0] == '/' && path[1] == 'd' && strncmp (path, "/dev/fd/", 8) == 0)
    {
#if !defined (HAVE_DEV_FD)
      intmax_t fd;
      int r;

      if (legal_number (path + 8, &fd) && fd == (int)fd)
        {
          r = fstat ((int)fd, finfo);
          if (r == 0 || errno != EBADF)
            return (r);
        }
      errno = ENOENT;
      return (-1);
#else
  /* If HAVE_DEV_FD is defined, DEV_FD_PREFIX is defined also, and has a
     trailing slash.  Make sure /dev/fd/xx really uses DEV_FD_PREFIX/xx.
     On most systems, with the notable exception of linux, this is
     effectively a no-op. */
      char pbuf[32];
      strcpy (pbuf, DEV_FD_PREFIX);
      strcat (pbuf, path + 8);
      return (stat (pbuf, finfo));
#endif /* !HAVE_DEV_FD */
    }
#if !defined (HAVE_DEV_STDIN)
  else if (STREQN (path, "/dev/std", 8))
    {
      if (STREQ (path+8, "in"))
	return (fstat (0, finfo));
      else if (STREQ (path+8, "out"))
	return (fstat (1, finfo));
      else if (STREQ (path+8, "err"))
	return (fstat (2, finfo));
      else
	return (stat (path, finfo));
    }
#endif /* !HAVE_DEV_STDIN */
  return (stat (path, finfo));
}
warning: parse error {
  if (*path == '\0')
    {
      errno = ENOENT;
      return (-1);
    }
  if (path[0] == '/' && path[1] == 'd' && strncmp (path, "/dev/fd/", 8) == 0)
    {
#if !defined (HAVE_DEV_FD)
      intmax_t fd;
      int r;

      if (legal_number (path + 8, &fd) && fd == (int)fd)
        {
          r = fstat ((int)fd, finfo);
          if (r == 0 || errno != EBADF)
            return (r);
        }
      errno = ENOENT;
      return (-1);
#else
  /* If HAVE_DEV_FD is defined, DEV_FD_PREFIX is defined also, and has a
     trailing slash.  Make sure /dev/fd/xx really uses DEV_FD_PREFIX/xx.
     On most systems, with the notable exception of linux, this is
     effectively a no-op. */
      char pbuf[32];
      strcpy (pbuf, DEV_FD_PREFIX);
      strcat (pbuf, path + 8);
      return (stat (pbuf, finfo));
#endif /* !HAVE_DEV_FD */
    }
#if !defined (HAVE_DEV_STDIN)
  else if (STREQN (path, "/dev/std", 8))
    {
      if (STREQ (path+8, "in"))
	return (fstat (0, finfo));
      else if (STREQ (path+8, "out"))
	return (fstat (1, finfo));
      else if (STREQ (path+8, "err"))
	return (fstat (2, finfo));
      else
	return (stat (path, finfo));
    }
#endif /* !HAVE_DEV_STDIN */
  return (stat (path, finfo));
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\eaccess.c:84
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\eaccess.c:135
parsing error 
{
  struct stat st;

  if (sh_stat (path, &st) < 0)
    return (-1);

  if (current_user.euid == 0)
    {
      /* Root can read or write any file. */
      if ((mode & X_OK) == 0)
	return (0);

      /* Root can execute any file that has any one of the execute
	 bits set. */
      if (st.st_mode & S_IXUGO)
	return (0);
    }

  if (st.st_uid == current_user.euid)	/* owner */
    mode <<= 6;
  else if (group_member (st.st_gid))
    mode <<= 3;

  if (st.st_mode & mode)
    return (0);

  errno = EACCES;
  return (-1);
}
warning: parse error {
  struct stat st;

  if (sh_stat (path, &st) < 0)
    return (-1);

  if (current_user.euid == 0)
    {
      /* Root can read or write any file. */
      if ((mode & X_OK) == 0)
	return (0);

      /* Root can execute any file that has any one of the execute
	 bits set. */
      if (st.st_mode & S_IXUGO)
	return (0);
    }

  if (st.st_uid == current_user.euid)	/* owner */
    mode <<= 6;
  else if (group_member (st.st_gid))
    mode <<= 3;

  if (st.st_mode & mode)
    return (0);

  errno = EACCES;
  return (-1);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\eaccess.c:138
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\eaccess.c:197
parsing error 
{
  int ret;

  if (path_is_devfd (path))
    return (sh_stataccess (path, mode));

#if defined (HAVE_FACCESSAT) && defined (AT_EACCESS)
  return (faccessat (AT_FDCWD, path, mode, AT_EACCESS));
#elif defined (HAVE_EACCESS)		/* FreeBSD */
  ret = eaccess (path, mode);	/* XXX -- not always correct for X_OK */
#  if defined (__FreeBSD__)
  if (ret == 0 && current_user.euid == 0 && mode == X_OK)
    return (sh_stataccess (path, mode));
#  endif
  return ret;
#elif defined (EFF_ONLY_OK)		/* SVR4(?), SVR4.2 */
  return access (path, mode|EFF_ONLY_OK);
#else
  if (mode == F_OK)
    return (sh_stataccess (path, mode));
    
#  if HAVE_DECL_SETREGID
  if (current_user.uid != current_user.euid || current_user.gid != current_user.egid)
    return (sh_euidaccess (path, mode));
#  endif

  if (current_user.uid == current_user.euid && current_user.gid == current_user.egid)
    {
      ret = access (path, mode);
#if defined (__FreeBSD__) || defined (SOLARIS)
      if (ret == 0 && current_user.euid == 0 && mode == X_OK)
	return (sh_stataccess (path, mode));
#endif
      return ret;
      
    }

  return (sh_stataccess (path, mode));
#endif
}
warning: parse error {
  int ret;

  if (path_is_devfd (path))
    return (sh_stataccess (path, mode));

#if defined (HAVE_FACCESSAT) && defined (AT_EACCESS)
  return (faccessat (AT_FDCWD, path, mode, AT_EACCESS));
#elif defined (HAVE_EACCESS)		/* FreeBSD */
  ret = eaccess (path, mode);	/* XXX -- not always correct for X_OK */
#  if defined (__FreeBSD__)
  if (ret == 0 && current_user.euid == 0 && mode == X_OK)
    return (sh_stataccess (path, mode));
#  endif
  return ret;
#elif defined (EFF_ONLY_OK)		/* SVR4(?), SVR4.2 */
  return access (path, mode|EFF_ONLY_OK);
#else
  if (mode == F_OK)
    return (sh_stataccess (path, mode));
    
#  if HAVE_DECL_SETREGID
  if (current_user.uid != current_user.euid || current_user.gid != current_user.egid)
    return (sh_euidaccess (path, mode));
#  endif

  if (current_user.uid == current_user.euid && current_user.gid == current_user.egid)
    {
      ret = access (path, mode);
#if defined (__FreeBSD__) || defined (SOLARIS)
      if (ret == 0 && current_user.euid == 0 && mode == X_OK)
	return (sh_stataccess (path, mode));
#endif
      return ret;
      
    }

  return (sh_stataccess (path, mode));
#endif
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\eaccess.c:200
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\fmtullong.c...
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\fmtulong.c...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\bashansi.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\chartypes.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\bashintl.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\stdc.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\typemax.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\fmtulong.c:84
parsing error 
{
  char *p;
  int sign;
  LONG si;

  if (base == 0)
    base = 10;

  if (base < 2 || base > 64)
    {
#if 1
      strncpy (buf, _("invalid base"), len - 1);
      buf[len] = '\0';
      errno = EINVAL;
      return (p = buf);
#else
      base = 10;
#endif
    }

  sign = 0;
  if ((flags & FL_UNSIGNED) == 0 && (LONG)ui < 0)
    {
      ui = -ui;
      sign = '-';
    }

  p = buf + len - 2;
  p[1] = '\0';

  /* handle common cases explicitly */
  switch (base)
    {
    case 10:
      if (ui < 10)
	{
	  *p-- = TOCHAR (ui);
	  break;
	}
      /* Favor signed arithmetic over unsigned arithmetic; it is faster on
	 many machines. */
      if ((LONG)ui < 0)
	{
	  *p-- = TOCHAR (ui % 10);
	  si = ui / 10;
	}
      else
        si = ui;
      do
	*p-- = TOCHAR (si % 10);
      while (si /= 10);
      break;

    case 8:
      do
	*p-- = TOCHAR (ui & 7);
      while (ui >>= 3);
      break;

    case 16:
      do
	*p-- = (flags & FL_HEXUPPER) ? X_digs[ui & 15] : x_digs[ui & 15];
      while (ui >>= 4);
      break;

    case 2:
      do
	*p-- = TOCHAR (ui & 1);
      while (ui >>= 1);
      break;

    default:
      do
	*p-- = FMTCHAR (ui % base);
      while (ui /= base);
      break;
    }

  if ((flags & FL_PREFIX) && (base == 8 || base == 16))
    {
      if (base == 16)
	{
	  *p-- = (flags & FL_HEXUPPER) ? 'X' : 'x';
	  *p-- = '0';
	}
      else if (p[1] != '0')
	*p-- = '0';
    }
  else if ((flags & FL_ADDBASE) && base != 10)
    {
      *p-- = '#';
      *p-- = TOCHAR (base % 10);
      if (base > 10)
        *p-- = TOCHAR (base / 10);
    }

  if (sign)
    *p-- = '-';

  return (p + 1);
}
warning: parse error {
  char *p;
  int sign;
  LONG si;

  if (base == 0)
    base = 10;

  if (base < 2 || base > 64)
    {
#if 1
      strncpy (buf, _("invalid base"), len - 1);
      buf[len] = '\0';
      errno = EINVAL;
      return (p = buf);
#else
      base = 10;
#endif
    }

  sign = 0;
  if ((flags & FL_UNSIGNED) == 0 && (LONG)ui < 0)
    {
      ui = -ui;
      sign = '-';
    }

  p = buf + len - 2;
  p[1] = '\0';

  /* handle common cases explicitly */
  switch (base)
    {
    case 10:
      if (ui < 10)
	{
	  *p-- = TOCHAR (ui);
	  break;
	}
      /* Favor signed arithmetic over unsigned arithmetic; it is faster on
	 many machines. */
      if ((LONG)ui < 0)
	{
	  *p-- = TOCHAR (ui % 10);
	  si = ui / 10;
	}
      else
        si = ui;
      do
	*p-- = TOCHAR (si % 10);
      while (si /= 10);
      break;

    case 8:
      do
	*p-- = TOCHAR (ui & 7);
      while (ui >>= 3);
      break;

    case 16:
      do
	*p-- = (flags & FL_HEXUPPER) ? X_digs[ui & 15] : x_digs[ui & 15];
      while (ui >>= 4);
      break;

    case 2:
      do
	*p-- = TOCHAR (ui & 1);
      while (ui >>= 1);
      break;

    default:
      do
	*p-- = FMTCHAR (ui % base);
      while (ui /= base);
      break;
    }

  if ((flags & FL_PREFIX) && (base == 8 || base == 16))
    {
      if (base == 16)
	{
	  *p-- = (flags & FL_HEXUPPER) ? 'X' : 'x';
	  *p-- = '0';
	}
      else if (p[1] != '0')
	*p-- = '0';
    }
  else if ((flags & FL_ADDBASE) && base != 10)
    {
      *p-- = '#';
      *p-- = TOCHAR (base % 10);
      if (base > 10)
        *p-- = TOCHAR (base / 10);
    }

  if (sign)
    *p-- = '-';

  return (p + 1);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\fmtulong.c:90
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\fmtulong.c...skip
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\fmtumax.c...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\fmtulong.c...skip
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\fnxform.c...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\bashansi.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\bashtypes.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\stdc.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\bashintl.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\xmalloc.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\fnxform.c:187
parsing error 
{
  return string;
}
warning: parse error {
  return string;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\fnxform.c:189
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\fnxform.c:194
parsing error 
{
  return string;
}
warning: parse error {
  return string;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\fnxform.c:196
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\fpurge.c...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\stdc.h...skip
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\getcwd.c...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\bashtypes.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\posixdir.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\posixstat.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\maxpath.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\memalloc.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\bashansi.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\xmalloc.h...skip
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\getenv.c...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\bashansi.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\shell.h...skip
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\inet_aton.c...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\bashansi.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\stdc.h...skip
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\input_avail.c...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\bashansi.h...skip
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\posixselect.h...
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\input_avail.c:62
parsing error 
{
  int result, chars_avail;
#if defined(HAVE_SELECT)
  fd_set readfds, exceptfds;
  struct timeval timeout;
#endif

  if (fd < 0)
    return -1;

  chars_avail = 0;

#if defined (HAVE_SELECT)
  FD_ZERO (&readfds);
  FD_ZERO (&exceptfds);
  FD_SET (fd, &readfds);
  FD_SET (fd, &exceptfds);
  timeout.tv_sec = 0;
  timeout.tv_usec = 0;
  result = select (fd + 1, &readfds, (fd_set *)NULL, &exceptfds, &timeout);
  return ((result <= 0) ? 0 : 1);

#endif

  result = -1;
#if defined (FIONREAD)
  errno = 0;
  result = ioctl (fd, FIONREAD, &chars_avail);
  if (result == -1 && errno == EIO)
    return -1;
  return (chars_avail);
#endif

  return 0;
}
warning: parse error {
  int result, chars_avail;
#if defined(HAVE_SELECT)
  fd_set readfds, exceptfds;
  struct timeval timeout;
#endif

  if (fd < 0)
    return -1;

  chars_avail = 0;

#if defined (HAVE_SELECT)
  FD_ZERO (&readfds);
  FD_ZERO (&exceptfds);
  FD_SET (fd, &readfds);
  FD_SET (fd, &exceptfds);
  timeout.tv_sec = 0;
  timeout.tv_usec = 0;
  result = select (fd + 1, &readfds, (fd_set *)NULL, &exceptfds, &timeout);
  return ((result <= 0) ? 0 : 1);

#endif

  result = -1;
#if defined (FIONREAD)
  errno = 0;
  result = ioctl (fd, FIONREAD, &chars_avail);
  if (result == -1 && errno == EIO)
    return -1;
  return (chars_avail);
#endif

  return 0;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\input_avail.c:64
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\itos.c...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\bashansi.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\shell.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\itos.c:33
parsing error 
{
  return (fmtumax (i, 10, buf, len, 0));
}
warning: parse error {
  return (fmtumax (i, 10, buf, len, 0));
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\itos.c:37
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\itos.c:44
parsing error 
{
  char *p, lbuf[INT_STRLEN_BOUND(intmax_t) + 1];

  p = fmtumax (i, 10, lbuf, sizeof(lbuf), 0);
  return (savestring (p));
}
warning: parse error {
  char *p, lbuf[INT_STRLEN_BOUND(intmax_t) + 1];

  p = fmtumax (i, 10, lbuf, sizeof(lbuf), 0);
  return (savestring (p));
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\itos.c:46
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\itos.c:54
parsing error 
{
  return (fmtumax (i, 10, buf, len, FL_UNSIGNED));
}
warning: parse error {
  return (fmtumax (i, 10, buf, len, FL_UNSIGNED));
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\itos.c:58
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\itos.c:65
parsing error 
{
  char *p, lbuf[INT_STRLEN_BOUND(uintmax_t) + 1];

  p = fmtumax (i, 10, lbuf, sizeof(lbuf), FL_UNSIGNED);
  return (savestring (p));
}
warning: parse error {
  char *p, lbuf[INT_STRLEN_BOUND(uintmax_t) + 1];

  p = fmtumax (i, 10, lbuf, sizeof(lbuf), FL_UNSIGNED);
  return (savestring (p));
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\itos.c:67
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\mailstat.c...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\bashtypes.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\posixstat.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\posixdir.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\bashansi.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\maxpath.h...skip
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\mailstat.c:56
parsing error 
{
  static struct stat st_new_last, st_ret_last;
  struct stat st_ret, st_tmp;
  DIR *dd;
  struct dirent *fn;
  char dir[PATH_MAX * 2], file[PATH_MAX * 2];
  int i, l;
  time_t atime, mtime;

  atime = mtime = 0;

  /* First see if it's a directory. */
  if ((i = stat(path, st)) != 0 || S_ISDIR(st->st_mode) == 0)
    return i;

  if (strlen(path) > sizeof(dir) - 5)
    {
#ifdef ENAMETOOLONG
      errno = ENAMETOOLONG;
#else
      errno = EINVAL;
#endif
      return -1;
    }

  st_ret = *st;
  st_ret.st_nlink = 1;
  st_ret.st_size  = 0;
#ifdef HAVE_STRUCT_STAT_ST_BLOCKS
  st_ret.st_blocks  = 0;
#else
  st_ret.st_nlink = 0;
#endif
  st_ret.st_mode  &= ~S_IFDIR;
  st_ret.st_mode  |= S_IFREG;

  /* See if cur/ is present */
  sprintf(dir, "%s/cur", path);
  if (stat(dir, &st_tmp) || S_ISDIR(st_tmp.st_mode) == 0)
    return 0;
  st_ret.st_atime = st_tmp.st_atime;

  /* See if tmp/ is present */
  sprintf(dir, "%s/tmp", path);
  if (stat(dir, &st_tmp) || S_ISDIR(st_tmp.st_mode) == 0)
    return 0;
  st_ret.st_mtime = st_tmp.st_mtime;

  /* And new/ */
  sprintf(dir, "%s/new", path);
  if (stat(dir, &st_tmp) || S_ISDIR(st_tmp.st_mode) == 0)
    return 0;
  st_ret.st_mtime = st_tmp.st_mtime;

  /* Optimization - if new/ didn't change, nothing else did. */
  if (st_tmp.st_dev == st_new_last.st_dev &&
      st_tmp.st_ino == st_new_last.st_ino &&
      st_tmp.st_atime == st_new_last.st_atime &&
      st_tmp.st_mtime == st_new_last.st_mtime)
    {
      *st = st_ret_last;
      return 0;
    }
  st_new_last = st_tmp;

  /* Loop over new/ and cur/ */
  for (i = 0; i < 2; i++)
    {
      sprintf(dir, "%s/%s", path, i ? "cur" : "new");
      sprintf(file, "%s/", dir);
      l = strlen(file);
      if ((dd = opendir(dir)) == NULL)
	return 0;
      while ((fn = readdir(dd)) != NULL)
	{
	  if (fn->d_name[0] == '.' || strlen(fn->d_name) + l >= sizeof(file))
	    continue;
	  strcpy(file + l, fn->d_name);
	  if (stat(file, &st_tmp) != 0)
	    continue;
	  st_ret.st_size += st_tmp.st_size;
#ifdef HAVE_STRUCT_STAT_ST_BLOCKS
	  st_ret.st_blocks++;
#else
	  st_ret.st_nlink++;
#endif
	  if (st_tmp.st_atime != st_tmp.st_mtime && st_tmp.st_atime > atime)
	    atime = st_tmp.st_atime;
	  if (st_tmp.st_mtime > mtime)
	    mtime = st_tmp.st_mtime;
	}
      closedir(dd);
    }

/*  if (atime) */	/* Set atime even if cur/ is empty */
      st_ret.st_atime = atime;
    if (mtime)
      st_ret.st_mtime = mtime;

    *st = st_ret_last = st_ret;
    return 0;
}
warning: parse error {
  static struct stat st_new_last, st_ret_last;
  struct stat st_ret, st_tmp;
  DIR *dd;
  struct dirent *fn;
  char dir[PATH_MAX * 2], file[PATH_MAX * 2];
  int i, l;
  time_t atime, mtime;

  atime = mtime = 0;

  /* First see if it's a directory. */
  if ((i = stat(path, st)) != 0 || S_ISDIR(st->st_mode) == 0)
    return i;

  if (strlen(path) > sizeof(dir) - 5)
    {
#ifdef ENAMETOOLONG
      errno = ENAMETOOLONG;
#else
      errno = EINVAL;
#endif
      return -1;
    }

  st_ret = *st;
  st_ret.st_nlink = 1;
  st_ret.st_size  = 0;
#ifdef HAVE_STRUCT_STAT_ST_BLOCKS
  st_ret.st_blocks  = 0;
#else
  st_ret.st_nlink = 0;
#endif
  st_ret.st_mode  &= ~S_IFDIR;
  st_ret.st_mode  |= S_IFREG;

  /* See if cur/ is present */
  sprintf(dir, "%s/cur", path);
  if (stat(dir, &st_tmp) || S_ISDIR(st_tmp.st_mode) == 0)
    return 0;
  st_ret.st_atime = st_tmp.st_atime;

  /* See if tmp/ is present */
  sprintf(dir, "%s/tmp", path);
  if (stat(dir, &st_tmp) || S_ISDIR(st_tmp.st_mode) == 0)
    return 0;
  st_ret.st_mtime = st_tmp.st_mtime;

  /* And new/ */
  sprintf(dir, "%s/new", path);
  if (stat(dir, &st_tmp) || S_ISDIR(st_tmp.st_mode) == 0)
    return 0;
  st_ret.st_mtime = st_tmp.st_mtime;

  /* Optimization - if new/ didn't change, nothing else did. */
  if (st_tmp.st_dev == st_new_last.st_dev &&
      st_tmp.st_ino == st_new_last.st_ino &&
      st_tmp.st_atime == st_new_last.st_atime &&
      st_tmp.st_mtime == st_new_last.st_mtime)
    {
      *st = st_ret_last;
      return 0;
    }
  st_new_last = st_tmp;

  /* Loop over new/ and cur/ */
  for (i = 0; i < 2; i++)
    {
      sprintf(dir, "%s/%s", path, i ? "cur" : "new");
      sprintf(file, "%s/", dir);
      l = strlen(file);
      if ((dd = opendir(dir)) == NULL)
	return 0;
      while ((fn = readdir(dd)) != NULL)
	{
	  if (fn->d_name[0] == '.' || strlen(fn->d_name) + l >= sizeof(file))
	    continue;
	  strcpy(file + l, fn->d_name);
	  if (stat(file, &st_tmp) != 0)
	    continue;
	  st_ret.st_size += st_tmp.st_size;
#ifdef HAVE_STRUCT_STAT_ST_BLOCKS
	  st_ret.st_blocks++;
#else
	  st_ret.st_nlink++;
#endif
	  if (st_tmp.st_atime != st_tmp.st_mtime && st_tmp.st_atime > atime)
	    atime = st_tmp.st_atime;
	  if (st_tmp.st_mtime > mtime)
	    mtime = st_tmp.st_mtime;
	}
      closedir(dd);
    }

/*  if (atime) */	/* Set atime even if cur/ is empty */
      st_ret.st_atime = atime;
    if (mtime)
      st_ret.st_mtime = mtime;

    *st = st_ret_last = st_ret;
    return 0;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\mailstat.c:58
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\makepath.c...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\bashansi.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\shell.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\tilde\tilde.h...skip
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\makepath.c:71
parsing error 
{
  int dirlen, pathlen;
  char *ret, *xpath, *xdir, *r, *s;

  if (path == 0 || *path == '\0')
    {
      if (flags & MP_DOCWD)
	{
	  xpath = get_working_directory ("sh_makepath");
	  if (xpath == 0)
	    {
	      ret = get_string_value ("PWD");
	      if (ret)
		xpath = savestring (ret);
	    }
	  if (xpath == 0)
	    MAKEDOT();
	  else
	    pathlen = strlen (xpath);
	}
      else
	MAKEDOT();
    }
  else if ((flags & MP_IGNDOT) && path[0] == '.' && (path[1] == '\0' ||
						     path[1] == '/' && path[2] == '\0'))
    {
      xpath = nullpath;
      pathlen = 0;
    }
  else
    {
      xpath = ((flags & MP_DOTILDE) && *path == '~') ? bash_tilde_expand (path, 0) : (char *)path;
      pathlen = strlen (xpath);
    }

  xdir = (char *)dir;
  dirlen = strlen (xdir);
  if ((flags & MP_RMDOT) && dir[0] == '.' && dir[1] == '/')
    {
      xdir += 2;
      dirlen -= 2;
    }

  r = ret = (char *)xmalloc (2 + dirlen + pathlen);
  s = xpath;
  while (*s)
    *r++ = *s++;
  if (s > xpath && s[-1] != '/')
    *r++ = '/';      
  s = xdir;
  while (*r++ = *s++)
    ;
  if (xpath != path && xpath != nullpath)
    free (xpath);
  return (ret);
}
warning: parse error {
  int dirlen, pathlen;
  char *ret, *xpath, *xdir, *r, *s;

  if (path == 0 || *path == '\0')
    {
      if (flags & MP_DOCWD)
	{
	  xpath = get_working_directory ("sh_makepath");
	  if (xpath == 0)
	    {
	      ret = get_string_value ("PWD");
	      if (ret)
		xpath = savestring (ret);
	    }
	  if (xpath == 0)
	    MAKEDOT();
	  else
	    pathlen = strlen (xpath);
	}
      else
	MAKEDOT();
    }
  else if ((flags & MP_IGNDOT) && path[0] == '.' && (path[1] == '\0' ||
						     path[1] == '/' && path[2] == '\0'))
    {
      xpath = nullpath;
      pathlen = 0;
    }
  else
    {
      xpath = ((flags & MP_DOTILDE) && *path == '~') ? bash_tilde_expand (path, 0) : (char *)path;
      pathlen = strlen (xpath);
    }

  xdir = (char *)dir;
  dirlen = strlen (xdir);
  if ((flags & MP_RMDOT) && dir[0] == '.' && dir[1] == '/')
    {
      xdir += 2;
      dirlen -= 2;
    }

  r = ret = (char *)xmalloc (2 + dirlen + pathlen);
  s = xpath;
  while (*s)
    *r++ = *s++;
  if (s > xpath && s[-1] != '/')
    *r++ = '/';      
  s = xdir;
  while (*r++ = *s++)
    ;
  if (xpath != path && xpath != nullpath)
    free (xpath);
  return (ret);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\makepath.c:73
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\mbscasecmp.c...
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\mbschr.c...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\bashansi.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\shmbutil.h...skip
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\mbschr.c:41
parsing error 
{
#if HANDLE_MULTIBYTE
  char *pos;
  mbstate_t state;
  size_t strlength, mblength;

  /* The locale encodings with said weird property are BIG5, BIG5-HKSCS,
     GBK, GB18030, SHIFT_JIS, and JOHAB.  They exhibit the problem only
     when c >= 0x30.  We can therefore use the faster bytewise search if
     c <= 0x30. */
  if ((unsigned char)c >= '0' && MB_CUR_MAX > 1)
    {
      pos = (char *)s;
      memset (&state, '\0', sizeof(mbstate_t));
      strlength = strlen (s);

      while (strlength > 0)
	{
	  mblength = mbrlen (pos, strlength, &state);
	  if (mblength == (size_t)-2 || mblength == (size_t)-1 || mblength == (size_t)0)
	    mblength = 1;

	  if (mblength == 1 && c == (unsigned char)*pos)
	    return pos;

	  strlength -= mblength;
	  pos += mblength;
	}

      return ((char *)NULL);
    }
  else
#endif
  return (strchr (s, c));
}
warning: parse error {
#if HANDLE_MULTIBYTE
  char *pos;
  mbstate_t state;
  size_t strlength, mblength;

  /* The locale encodings with said weird property are BIG5, BIG5-HKSCS,
     GBK, GB18030, SHIFT_JIS, and JOHAB.  They exhibit the problem only
     when c >= 0x30.  We can therefore use the faster bytewise search if
     c <= 0x30. */
  if ((unsigned char)c >= '0' && MB_CUR_MAX > 1)
    {
      pos = (char *)s;
      memset (&state, '\0', sizeof(mbstate_t));
      strlength = strlen (s);

      while (strlength > 0)
	{
	  mblength = mbrlen (pos, strlength, &state);
	  if (mblength == (size_t)-2 || mblength == (size_t)-1 || mblength == (size_t)0)
	    mblength = 1;

	  if (mblength == 1 && c == (unsigned char)*pos)
	    return pos;

	  strlength -= mblength;
	  pos += mblength;
	}

      return ((char *)NULL);
    }
  else
#endif
  return (strchr (s, c));
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\mbschr.c:44
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\mbscmp.c...
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\memset.c...
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\mktime.c...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\bashansi.h...skip
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\mktime.c:116
parsing error 
{
  struct tm *l = localtime (t);
  if (! l)
    return 0;
  *tp = *l;
  return tp;
}
warning: parse error {
  struct tm *l = localtime (t);
  if (! l)
    return 0;
  *tp = *l;
  return tp;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\mktime.c:118
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\mktime.c:133
parsing error 
{
  /* Compute intervening leap days correctly even if year is negative.
     Take care to avoid int overflow.  time_t overflow is OK, since
     only the low order bits of the correct time_t answer are needed.
     Don't convert to time_t until after all divisions are done, since
     time_t might be unsigned.  */
  int a4 = (year >> 2) + (TM_YEAR_BASE >> 2) - ! (year & 3);
  int b4 = (tp->tm_year >> 2) + (TM_YEAR_BASE >> 2) - ! (tp->tm_year & 3);
  int a100 = a4 / 25 - (a4 % 25 < 0);
  int b100 = b4 / 25 - (b4 % 25 < 0);
  int a400 = a100 >> 2;
  int b400 = b100 >> 2;
  int intervening_leap_days = (a4 - b4) - (a100 - b100) + (a400 - b400);
  time_t years = year - (time_t) tp->tm_year;
  time_t days = (365 * years + intervening_leap_days
		 + (yday - tp->tm_yday));
  return (60 * (60 * (24 * days + (hour - tp->tm_hour))
		+ (min - tp->tm_min))
	  + (sec - tp->tm_sec));
}
warning: parse error {
  /* Compute intervening leap days correctly even if year is negative.
     Take care to avoid int overflow.  time_t overflow is OK, since
     only the low order bits of the correct time_t answer are needed.
     Don't convert to time_t until after all divisions are done, since
     time_t might be unsigned.  */
  int a4 = (year >> 2) + (TM_YEAR_BASE >> 2) - ! (year & 3);
  int b4 = (tp->tm_year >> 2) + (TM_YEAR_BASE >> 2) - ! (tp->tm_year & 3);
  int a100 = a4 / 25 - (a4 % 25 < 0);
  int b100 = b4 / 25 - (b4 % 25 < 0);
  int a400 = a100 >> 2;
  int b400 = b100 >> 2;
  int intervening_leap_days = (a4 - b4) - (a100 - b100) + (a400 - b400);
  time_t years = year - (time_t) tp->tm_year;
  time_t days = (365 * years + intervening_leap_days
		 + (yday - tp->tm_yday));
  return (60 * (60 * (24 * days + (hour - tp->tm_hour))
		+ (min - tp->tm_min))
	  + (sec - tp->tm_sec));
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\mktime.c:136
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\mktime.c:162
parsing error 
{
#ifdef _LIBC
  /* POSIX.1 8.1.1 requires that whenever mktime() is called, the
     time zone names contained in the external variable `tzname' shall
     be set as if the tzset() function had been called.  */
  __tzset ();
#endif

  return __mktime_internal (tp, my_localtime_r, &localtime_offset);
}
warning: parse error {
#ifdef _LIBC
  /* POSIX.1 8.1.1 requires that whenever mktime() is called, the
     time zone names contained in the external variable `tzname' shall
     be set as if the tzset() function had been called.  */
  __tzset ();
#endif

  return __mktime_internal (tp, my_localtime_r, &localtime_offset);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\mktime.c:164
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\mktime.c:181
parsing error 
{
  time_t t, dt, t0;
  struct tm tm;

  /* The maximum number of probes (calls to CONVERT) should be enough
     to handle any combinations of time zone rule changes, solar time,
     and leap seconds.  Posix.1 prohibits leap seconds, but some hosts
     have them anyway.  */
  int remaining_probes = 4;

  /* Time requested.  Copy it in case CONVERT modifies *TP; this can
     occur if TP is localtime's returned value and CONVERT is localtime.  */
  int sec = tp->tm_sec;
  int min = tp->tm_min;
  int hour = tp->tm_hour;
  int mday = tp->tm_mday;
  int mon = tp->tm_mon;
  int year_requested = tp->tm_year;
  int isdst = tp->tm_isdst;

  /* Ensure that mon is in range, and set year accordingly.  */
  int mon_remainder = mon % 12;
  int negative_mon_remainder = mon_remainder < 0;
  int mon_years = mon / 12 - negative_mon_remainder;
  int year = year_requested + mon_years;

  /* The other values need not be in range:
     the remaining code handles minor overflows correctly,
     assuming int and time_t arithmetic wraps around.
     Major overflows are caught at the end.  */

  /* Calculate day of year from year, month, and day of month.
     The result need not be in range.  */
  int yday = ((__mon_yday[__isleap (year + TM_YEAR_BASE)]
	       [mon_remainder + 12 * negative_mon_remainder])
	      + mday - 1);

#if LEAP_SECONDS_POSSIBLE
  /* Handle out-of-range seconds specially,
     since ydhms_tm_diff assumes every minute has 60 seconds.  */
  int sec_requested = sec;
  if (sec < 0)
    sec = 0;
  if (59 < sec)
    sec = 59;
#endif

  /* Invert CONVERT by probing.  First assume the same offset as last time.
     Then repeatedly use the error to improve the guess.  */

  tm.tm_year = EPOCH_YEAR - TM_YEAR_BASE;
  tm.tm_yday = tm.tm_hour = tm.tm_min = tm.tm_sec = 0;
  t0 = ydhms_tm_diff (year, yday, hour, min, sec, &tm);

  for (t = t0 + *offset;
       (dt = ydhms_tm_diff (year, yday, hour, min, sec, (*convert) (&t, &tm)));
       t += dt)
    if (--remaining_probes == 0)
      return -1;

  /* Check whether tm.tm_isdst has the requested value, if any.  */
  if (0 <= isdst && 0 <= tm.tm_isdst)
    {
      int dst_diff = (isdst != 0) - (tm.tm_isdst != 0);
      if (dst_diff)
	{
	  /* Move two hours in the direction indicated by the disagreement,
	     probe some more, and switch to a new time if found.
	     The largest known fallback due to daylight savings is two hours:
	     once, in Newfoundland, 1988-10-30 02:00 -> 00:00.  */
	  time_t ot = t - 2 * 60 * 60 * dst_diff;
	  while (--remaining_probes != 0)
	    {
	      struct tm otm;
	      if (! (dt = ydhms_tm_diff (year, yday, hour, min, sec,
					 (*convert) (&ot, &otm))))
		{
		  t = ot;
		  tm = otm;
		  break;
		}
	      if ((ot += dt) == t)
		break;  /* Avoid a redundant probe.  */
	    }
	}
    }

  *offset = t - t0;

#if LEAP_SECONDS_POSSIBLE
  if (sec_requested != tm.tm_sec)
    {
      /* Adjust time to reflect the tm_sec requested, not the normalized value.
	 Also, repair any damage from a false match due to a leap second.  */
      t += sec_requested - sec + (sec == 0 && tm.tm_sec == 60);
      (*convert) (&t, &tm);
    }
#endif

  if (TIME_T_MAX / INT_MAX / 366 / 24 / 60 / 60 < 3)
    {
      /* time_t isn't large enough to rule out overflows in ydhms_tm_diff,
	 so check for major overflows.  A gross check suffices,
	 since if t has overflowed, it is off by a multiple of
	 TIME_T_MAX - TIME_T_MIN + 1.  So ignore any component of
	 the difference that is bounded by a small value.  */

      double dyear = (double) year_requested + mon_years - tm.tm_year;
      double dday = 366 * dyear + mday;
      double dsec = 60 * (60 * (24 * dday + hour) + min) + sec_requested;

      if (TIME_T_MAX / 3 - TIME_T_MIN / 3 < (dsec < 0 ? - dsec : dsec))
	return -1;
    }

  *tp = tm;
  return t;
}
warning: parse error {
  time_t t, dt, t0;
  struct tm tm;

  /* The maximum number of probes (calls to CONVERT) should be enough
     to handle any combinations of time zone rule changes, solar time,
     and leap seconds.  Posix.1 prohibits leap seconds, but some hosts
     have them anyway.  */
  int remaining_probes = 4;

  /* Time requested.  Copy it in case CONVERT modifies *TP; this can
     occur if TP is localtime's returned value and CONVERT is localtime.  */
  int sec = tp->tm_sec;
  int min = tp->tm_min;
  int hour = tp->tm_hour;
  int mday = tp->tm_mday;
  int mon = tp->tm_mon;
  int year_requested = tp->tm_year;
  int isdst = tp->tm_isdst;

  /* Ensure that mon is in range, and set year accordingly.  */
  int mon_remainder = mon % 12;
  int negative_mon_remainder = mon_remainder < 0;
  int mon_years = mon / 12 - negative_mon_remainder;
  int year = year_requested + mon_years;

  /* The other values need not be in range:
     the remaining code handles minor overflows correctly,
     assuming int and time_t arithmetic wraps around.
     Major overflows are caught at the end.  */

  /* Calculate day of year from year, month, and day of month.
     The result need not be in range.  */
  int yday = ((__mon_yday[__isleap (year + TM_YEAR_BASE)]
	       [mon_remainder + 12 * negative_mon_remainder])
	      + mday - 1);

#if LEAP_SECONDS_POSSIBLE
  /* Handle out-of-range seconds specially,
     since ydhms_tm_diff assumes every minute has 60 seconds.  */
  int sec_requested = sec;
  if (sec < 0)
    sec = 0;
  if (59 < sec)
    sec = 59;
#endif

  /* Invert CONVERT by probing.  First assume the same offset as last time.
     Then repeatedly use the error to improve the guess.  */

  tm.tm_year = EPOCH_YEAR - TM_YEAR_BASE;
  tm.tm_yday = tm.tm_hour = tm.tm_min = tm.tm_sec = 0;
  t0 = ydhms_tm_diff (year, yday, hour, min, sec, &tm);

  for (t = t0 + *offset;
       (dt = ydhms_tm_diff (year, yday, hour, min, sec, (*convert) (&t, &tm)));
       t += dt)
    if (--remaining_probes == 0)
      return -1;

  /* Check whether tm.tm_isdst has the requested value, if any.  */
  if (0 <= isdst && 0 <= tm.tm_isdst)
    {
      int dst_diff = (isdst != 0) - (tm.tm_isdst != 0);
      if (dst_diff)
	{
	  /* Move two hours in the direction indicated by the disagreement,
	     probe some more, and switch to a new time if found.
	     The largest known fallback due to daylight savings is two hours:
	     once, in Newfoundland, 1988-10-30 02:00 -> 00:00.  */
	  time_t ot = t - 2 * 60 * 60 * dst_diff;
	  while (--remaining_probes != 0)
	    {
	      struct tm otm;
	      if (! (dt = ydhms_tm_diff (year, yday, hour, min, sec,
					 (*convert) (&ot, &otm))))
		{
		  t = ot;
		  tm = otm;
		  break;
		}
	      if ((ot += dt) == t)
		break;  /* Avoid a redundant probe.  */
	    }
	}
    }

  *offset = t - t0;

#if LEAP_SECONDS_POSSIBLE
  if (sec_requested != tm.tm_sec)
    {
      /* Adjust time to reflect the tm_sec requested, not the normalized value.
	 Also, repair any damage from a false match due to a leap second.  */
      t += sec_requested - sec + (sec == 0 && tm.tm_sec == 60);
      (*convert) (&t, &tm);
    }
#endif

  if (TIME_T_MAX / INT_MAX / 366 / 24 / 60 / 60 < 3)
    {
      /* time_t isn't large enough to rule out overflows in ydhms_tm_diff,
	 so check for major overflows.  A gross check suffices,
	 since if t has overflowed, it is off by a multiple of
	 TIME_T_MAX - TIME_T_MIN + 1.  So ignore any component of
	 the difference that is bounded by a small value.  */

      double dyear = (double) year_requested + mon_years - tm.tm_year;
      double dday = 366 * dyear + mday;
      double dsec = 60 * (60 * (24 * dday + hour) + min) + sec_requested;

      if (TIME_T_MAX / 3 - TIME_T_MIN / 3 < (dsec < 0 ? - dsec : dsec))
	return -1;
    }

  *tp = tm;
  return t;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\mktime.c:185
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\netconn.c...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\bashtypes.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\posixstat.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\filecntl.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\netconn.c:44
parsing error 
{
#if defined (HAVE_GETPEERNAME) && !defined (SVR4_2) && !defined (__BEOS__)
  int rv;
  socklen_t l;
  struct sockaddr sa;

  l = sizeof(sa);
  rv = getpeername(fd, &sa, &l);
  /* Posix.2 says getpeername can return these errors. */
  return ((rv < 0 && (errno == ENOTSOCK || errno == ENOTCONN || errno == EINVAL)) ? 0 : 1);
#else /* !HAVE_GETPEERNAME || SVR4_2 || __BEOS__ */
#  if defined (SVR4) || defined (SVR4_2)
  /* Sockets on SVR4 and SVR4.2 are character special (streams) devices. */
  struct stat sb;

  if (isatty (fd))
    return (0);
  if (fstat (fd, &sb) < 0)
    return (0);
#    if defined (S_ISFIFO)
  if (S_ISFIFO (sb.st_mode))
    return (0);
#    endif /* S_ISFIFO */
  return (S_ISCHR (sb.st_mode));
#  else /* !SVR4 && !SVR4_2 */
#    if defined (S_ISSOCK) && !defined (__BEOS__)
  struct stat sb;

  if (fstat (fd, &sb) < 0)
    return (0);
  return (S_ISSOCK (sb.st_mode));
#    else /* !S_ISSOCK || __BEOS__ */
  return (0);
#    endif /* !S_ISSOCK || __BEOS__ */
#  endif /* !SVR4 && !SVR4_2 */
#endif /* !HAVE_GETPEERNAME || SVR4_2 || __BEOS__ */
}
warning: parse error {
#if defined (HAVE_GETPEERNAME) && !defined (SVR4_2) && !defined (__BEOS__)
  int rv;
  socklen_t l;
  struct sockaddr sa;

  l = sizeof(sa);
  rv = getpeername(fd, &sa, &l);
  /* Posix.2 says getpeername can return these errors. */
  return ((rv < 0 && (errno == ENOTSOCK || errno == ENOTCONN || errno == EINVAL)) ? 0 : 1);
#else /* !HAVE_GETPEERNAME || SVR4_2 || __BEOS__ */
#  if defined (SVR4) || defined (SVR4_2)
  /* Sockets on SVR4 and SVR4.2 are character special (streams) devices. */
  struct stat sb;

  if (isatty (fd))
    return (0);
  if (fstat (fd, &sb) < 0)
    return (0);
#    if defined (S_ISFIFO)
  if (S_ISFIFO (sb.st_mode))
    return (0);
#    endif /* S_ISFIFO */
  return (S_ISCHR (sb.st_mode));
#  else /* !SVR4 && !SVR4_2 */
#    if defined (S_ISSOCK) && !defined (__BEOS__)
  struct stat sb;

  if (fstat (fd, &sb) < 0)
    return (0);
  return (S_ISSOCK (sb.st_mode));
#    else /* !S_ISSOCK || __BEOS__ */
  return (0);
#    endif /* !S_ISSOCK || __BEOS__ */
#  endif /* !SVR4 && !SVR4_2 */
#endif /* !HAVE_GETPEERNAME || SVR4_2 || __BEOS__ */
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\netconn.c:46
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\netopen.c...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\bashansi.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\bashintl.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\shell.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\xmalloc.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\netopen.c:343
parsing error 
{
  internal_error (_("network operations not supported"));
  return -1;
}
warning: parse error {
  internal_error (_("network operations not supported"));
  return -1;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\netopen.c:345
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\oslib.c...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\bashtypes.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\posixstat.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\filecntl.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\bashansi.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\chartypes.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\shell.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\oslib.c:57
parsing error 
{
  register char *s;

  for (s = string; s && *s; s++)
    if (*s == c)
      return (s);

  return ((char *) NULL);
}
warning: parse error {
  register char *s;

  for (s = string; s && *s; s++)
    if (*s == c)
      return (s);

  return ((char *) NULL);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\oslib.c:60
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\oslib.c:71
parsing error 
{
  register char *s, *t;

  for (s = string, t = (char *)NULL; s && *s; s++)
    if (*s == c)
      t = s;
  return (t);
}
warning: parse error {
  register char *s, *t;

  for (s = string, t = (char *)NULL; s && *s; s++)
    if (*s == c)
      t = s;
  return (t);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\oslib.c:74
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\oslib.c:88
parsing error 
{
  int saved_errno, r;

  /* If FD1 is not a valid file descriptor, then return immediately with
     an error. */
  if (fcntl (fd1, F_GETFL, 0) == -1)
    return (-1);

  if (fd2 < 0 || fd2 >= getdtablesize ())
    {
      errno = EBADF;
      return (-1);
    }

  if (fd1 == fd2)
    return (0);

  saved_errno = errno;

  (void) close (fd2);
  r = fcntl (fd1, F_DUPFD, fd2);

  if (r >= 0)
    errno = saved_errno;
  else
    if (errno == EINVAL)
      errno = EBADF;

  /* Force the new file descriptor to remain open across exec () calls. */
  SET_OPEN_ON_EXEC (fd2);
  return (r);
}
warning: parse error {
  int saved_errno, r;

  /* If FD1 is not a valid file descriptor, then return immediately with
     an error. */
  if (fcntl (fd1, F_GETFL, 0) == -1)
    return (-1);

  if (fd2 < 0 || fd2 >= getdtablesize ())
    {
      errno = EBADF;
      return (-1);
    }

  if (fd1 == fd2)
    return (0);

  saved_errno = errno;

  (void) close (fd2);
  r = fcntl (fd1, F_DUPFD, fd2);

  if (r >= 0)
    errno = saved_errno;
  else
    if (errno == EINVAL)
      errno = EBADF;

  /* Force the new file descriptor to remain open across exec () calls. */
  SET_OPEN_ON_EXEC (fd2);
  return (r);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\oslib.c:90
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\oslib.c:169
parsing error 
{
  FASTCOPY (s, d, n);
}
warning: parse error {
  FASTCOPY (s, d, n);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\oslib.c:172
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\oslib.c:182
parsing error 
{
  register int i;
  register char *r;

  for (i = 0, r = s; i < n; i++)
    *r++ = '\0';
}
warning: parse error {
  register int i;
  register char *r;

  for (i = 0, r = s; i < n; i++)
    *r++ = '\0';
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\oslib.c:185
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\oslib.c:215
parsing error 
{
  strncpy (name, "unknown", namelen);
  name[namelen] = '\0';
  return 0;
}
warning: parse error {
  strncpy (name, "unknown", namelen);
  name[namelen] = '\0';
  return 0;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\oslib.c:218
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\oslib.c:228
parsing error 
{
  return (kill (-pgrp, sig));
}
warning: parse error {
  return (kill (-pgrp, sig));
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\oslib.c:231
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\pathcanon.c...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\bashtypes.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\posixstat.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\filecntl.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\bashansi.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\chartypes.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\shell.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\pathcanon.c:75
parsing error 
{
  int l;
  struct stat sb;

  /* This should leave errno set to the correct value. */
  errno = 0;
  l = stat (path, &sb) == 0 && S_ISDIR (sb.st_mode);
#if defined (__CYGWIN__)
  if (l == 0)
    l = _is_cygdrive (path);
#endif
  return l;
}
warning: parse error {
  int l;
  struct stat sb;

  /* This should leave errno set to the correct value. */
  errno = 0;
  l = stat (path, &sb) == 0 && S_ISDIR (sb.st_mode);
#if defined (__CYGWIN__)
  if (l == 0)
    l = _is_cygdrive (path);
#endif
  return l;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\pathcanon.c:77
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\pathcanon.c:104
parsing error 
{
  char stub_char;
  char *result, *p, *q, *base, *dotdot;
  int rooted, double_slash_path;

  /* The result cannot be larger than the input PATH. */
  result = (flags & PATH_NOALLOC) ? path : savestring (path);

  /* POSIX.2 says to leave a leading `//' alone.  On cygwin, we skip over any
     leading `x:' (dos drive name). */
  if (rooted = ROOTEDPATH(path))
    {
      stub_char = DIRSEP;
#if defined (__CYGWIN__)
      base = (ISALPHA((unsigned char)result[0]) && result[1] == ':') ? result + 3 : result + 1;
#else
      base = result + 1;
#endif
      double_slash_path = DOUBLE_SLASH (path);
      base += double_slash_path;
    }
  else
    {
      stub_char = '.';
#if defined (__CYGWIN__)
      base = (ISALPHA((unsigned char)result[0]) && result[1] == ':') ? result + 2 : result;
#else
      base = result;
#endif
      double_slash_path = 0;
    }

  /*
   * invariants:
   *	  base points to the portion of the path we want to modify
   *      p points at beginning of path element we're considering.
   *      q points just past the last path element we wrote (no slash).
   *      dotdot points just past the point where .. cannot backtrack
   *	  any further (no slash).
   */
  p = q = dotdot = base;

  while (*p)
    {
      if (ISDIRSEP(p[0])) /* null element */
	p++;
      else if(p[0] == '.' && PATHSEP(p[1]))	/* . and ./ */
	p += 1; 	/* don't count the separator in case it is nul */
      else if (p[0] == '.' && p[1] == '.' && PATHSEP(p[2])) /* .. and ../ */
	{
	  p += 2; /* skip `..' */
	  if (q > dotdot)	/* can backtrack */
	    {
	      if (flags & PATH_CHECKDOTDOT)
		{
		  char c;

		  /* Make sure what we have so far corresponds to a valid
		     path before we chop some of it off. */
		  c = *q;
		  *q = '\0';
		  if (_path_isdir (result) == 0)
		    {
		      if ((flags & PATH_NOALLOC) == 0)
			free (result);
		      return ((char *)NULL);
		    }
		  *q = c;
		}

	      while (--q > dotdot && ISDIRSEP(*q) == 0)
		;
	    }
	  else if (rooted == 0)
	    {
	      /* /.. is / but ./../ is .. */
	      if (q != base)
		*q++ = DIRSEP;
	      *q++ = '.';
	      *q++ = '.';
	      dotdot = q;
	    }
	}
      else	/* real path element */
	{
	  /* add separator if not at start of work portion of result */
	  if (q != base)
	    *q++ = DIRSEP;
	  while (*p && (ISDIRSEP(*p) == 0))
	    *q++ = *p++;
	  /* Check here for a valid directory with _path_isdir. */
	  if (flags & PATH_CHECKEXISTS)
	    {
	      char c;

	      /* Make sure what we have so far corresponds to a valid
		 path before we chop some of it off. */
	      c = *q;
	      *q = '\0';
	      if (_path_isdir (result) == 0)
		{
		  if ((flags & PATH_NOALLOC) == 0)
		    free (result);
		  return ((char *)NULL);
		}
	      *q = c;
	    }
	}
    }

  /* Empty string is really ``.'' or `/', depending on what we started with. */
  if (q == result)
    *q++ = stub_char;
  *q = '\0';

  /* If the result starts with `//', but the original path does not, we
     can turn the // into /.  Because of how we set `base', this should never
     be true, but it's a sanity check. */
  if (DOUBLE_SLASH(result) && double_slash_path == 0)
    {
      if (result[2] == '\0')	/* short-circuit for bare `//' */
	result[1] = '\0';
      else
	strcpy (result, result + 1);
    }

  return (result);
}
warning: parse error {
  char stub_char;
  char *result, *p, *q, *base, *dotdot;
  int rooted, double_slash_path;

  /* The result cannot be larger than the input PATH. */
  result = (flags & PATH_NOALLOC) ? path : savestring (path);

  /* POSIX.2 says to leave a leading `//' alone.  On cygwin, we skip over any
     leading `x:' (dos drive name). */
  if (rooted = ROOTEDPATH(path))
    {
      stub_char = DIRSEP;
#if defined (__CYGWIN__)
      base = (ISALPHA((unsigned char)result[0]) && result[1] == ':') ? result + 3 : result + 1;
#else
      base = result + 1;
#endif
      double_slash_path = DOUBLE_SLASH (path);
      base += double_slash_path;
    }
  else
    {
      stub_char = '.';
#if defined (__CYGWIN__)
      base = (ISALPHA((unsigned char)result[0]) && result[1] == ':') ? result + 2 : result;
#else
      base = result;
#endif
      double_slash_path = 0;
    }

  /*
   * invariants:
   *	  base points to the portion of the path we want to modify
   *      p points at beginning of path element we're considering.
   *      q points just past the last path element we wrote (no slash).
   *      dotdot points just past the point where .. cannot backtrack
   *	  any further (no slash).
   */
  p = q = dotdot = base;

  while (*p)
    {
      if (ISDIRSEP(p[0])) /* null element */
	p++;
      else if(p[0] == '.' && PATHSEP(p[1]))	/* . and ./ */
	p += 1; 	/* don't count the separator in case it is nul */
      else if (p[0] == '.' && p[1] == '.' && PATHSEP(p[2])) /* .. and ../ */
	{
	  p += 2; /* skip `..' */
	  if (q > dotdot)	/* can backtrack */
	    {
	      if (flags & PATH_CHECKDOTDOT)
		{
		  char c;

		  /* Make sure what we have so far corresponds to a valid
		     path before we chop some of it off. */
		  c = *q;
		  *q = '\0';
		  if (_path_isdir (result) == 0)
		    {
		      if ((flags & PATH_NOALLOC) == 0)
			free (result);
		      return ((char *)NULL);
		    }
		  *q = c;
		}

	      while (--q > dotdot && ISDIRSEP(*q) == 0)
		;
	    }
	  else if (rooted == 0)
	    {
	      /* /.. is / but ./../ is .. */
	      if (q != base)
		*q++ = DIRSEP;
	      *q++ = '.';
	      *q++ = '.';
	      dotdot = q;
	    }
	}
      else	/* real path element */
	{
	  /* add separator if not at start of work portion of result */
	  if (q != base)
	    *q++ = DIRSEP;
	  while (*p && (ISDIRSEP(*p) == 0))
	    *q++ = *p++;
	  /* Check here for a valid directory with _path_isdir. */
	  if (flags & PATH_CHECKEXISTS)
	    {
	      char c;

	      /* Make sure what we have so far corresponds to a valid
		 path before we chop some of it off. */
	      c = *q;
	      *q = '\0';
	      if (_path_isdir (result) == 0)
		{
		  if ((flags & PATH_NOALLOC) == 0)
		    free (result);
		  return ((char *)NULL);
		}
	      *q = c;
	    }
	}
    }

  /* Empty string is really ``.'' or `/', depending on what we started with. */
  if (q == result)
    *q++ = stub_char;
  *q = '\0';

  /* If the result starts with `//', but the original path does not, we
     can turn the // into /.  Because of how we set `base', this should never
     be true, but it's a sanity check. */
  if (DOUBLE_SLASH(result) && double_slash_path == 0)
    {
      if (result[2] == '\0')	/* short-circuit for bare `//' */
	result[1] = '\0';
      else
	strcpy (result, result + 1);
    }

  return (result);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\pathcanon.c:107
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\pathphys.c...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\bashtypes.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\posixstat.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\filecntl.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\bashansi.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\chartypes.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\shell.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\pathphys.c:52
parsing error 
{
#ifdef HAVE_READLINK
  return readlink (path, buf, bufsiz);
#else
  errno = EINVAL;
  return -1;
#endif
}
warning: parse error {
#ifdef HAVE_READLINK
  return readlink (path, buf, bufsiz);
#else
  errno = EINVAL;
  return -1;
#endif
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\pathphys.c:56
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\pathphys.c:75
parsing error 
{
  char tbuf[PATH_MAX+1], linkbuf[PATH_MAX+1];
  char *result, *p, *q, *qsave, *qbase, *workpath;
  int double_slash_path, linklen, nlink;

  linklen = strlen (path);

#if 0
  /* First sanity check -- punt immediately if the name is too long. */
  if (linklen >= PATH_MAX)
    return (savestring (path));
#endif

  nlink = 0;
  q = result = (char *)xmalloc (PATH_MAX + 1);

  /* Even if we get something longer than PATH_MAX, we might be able to
     shorten it, so we try. */
  if (linklen >= PATH_MAX)
    workpath = savestring (path);
  else
    {
      workpath = (char *)xmalloc (PATH_MAX + 1);
      strcpy (workpath, path);
    }

  /* This always gets an absolute pathname. */

  /* POSIX.2 says to leave a leading `//' alone.  On cygwin, we skip over any
     leading `x:' (dos drive name). */
#if defined (__CYGWIN__)
  qbase = (ISALPHA((unsigned char)workpath[0]) && workpath[1] == ':') ? workpath + 3 : workpath + 1;
#else
  qbase = workpath + 1;
#endif
  double_slash_path = DOUBLE_SLASH (workpath);
  qbase += double_slash_path;

  for (p = workpath; p < qbase; )
    *q++ = *p++;
  qbase = q;

  /*
   * invariants:
   *	  qbase points to the portion of the result path we want to modify
   *      p points at beginning of path element we're considering.
   *      q points just past the last path element we wrote (no slash).
   *
   * XXX -- need to fix error checking for too-long pathnames
   */

  while (*p)
    {
      if (ISDIRSEP(p[0])) /* null element */
	p++;
      else if(p[0] == '.' && PATHSEP(p[1]))	/* . and ./ */
	p += 1; 	/* don't count the separator in case it is nul */
      else if (p[0] == '.' && p[1] == '.' && PATHSEP(p[2])) /* .. and ../ */
	{
	  p += 2; /* skip `..' */
	  if (q > qbase)
	    {
	      while (--q > qbase && ISDIRSEP(*q) == 0)
		;
	    }
	}
      else	/* real path element */
	{
	  /* add separator if not at start of work portion of result */
	  qsave = q;
	  if (q != qbase)
	    *q++ = DIRSEP;
	  while (*p && (ISDIRSEP(*p) == 0))
	    {
	      if (q - result >= PATH_MAX)
		{
#ifdef ENAMETOOLONG
		  errno = ENAMETOOLONG;
#else
		  errno = EINVAL;
#endif
		  goto error;
		}
		
	      *q++ = *p++;
	    }

	  *q = '\0';

	  linklen = _path_readlink (result, linkbuf, PATH_MAX);
	  if (linklen < 0)	/* if errno == EINVAL, it's not a symlink */
	    {
	      if (errno != EINVAL)
		goto error;
	      continue;
	    }

	  /* It's a symlink, and the value is in LINKBUF. */
	  nlink++;
	  if (nlink > MAXSYMLINKS)
	    {
#ifdef ELOOP
	      errno = ELOOP;
#else
	      errno = EINVAL;
#endif
error:
	      free (result);
	      free (workpath);
	      return ((char *)NULL);
	    }

	  linkbuf[linklen] = '\0';

	  /* If the new path length would overrun PATH_MAX, punt now. */
	  if ((strlen (p) + linklen + 2) >= PATH_MAX)
	    {
#ifdef ENAMETOOLONG
	      errno = ENAMETOOLONG;
#else
	      errno = EINVAL;
#endif
	      goto error;
	    }

	  /* Form the new pathname by copying the link value to a temporary
	     buffer and appending the rest of `workpath'.  Reset p to point
	     to the start of the rest of the path.  If the link value is an
	     absolute pathname, reset p, q, and qbase.  If not, reset p
	     and q. */
	  strcpy (tbuf, linkbuf);
	  tbuf[linklen] = '/';
	  strcpy (tbuf + linklen, p);
	  strcpy (workpath, tbuf);

	  if (ABSPATH(linkbuf))
	    {
	      q = result;
	      /* Duplicating some code here... */
#if defined (__CYGWIN__)
	      qbase = (ISALPHA((unsigned char)workpath[0]) && workpath[1] == ':') ? workpath + 3 : workpath + 1;
#else
	      qbase = workpath + 1;
#endif
	      double_slash_path = DOUBLE_SLASH (workpath);
	      qbase += double_slash_path;
    
	      for (p = workpath; p < qbase; )
		*q++ = *p++;
	      qbase = q;
	    }
	  else
	    {
	      p = workpath;
	      q = qsave;
	    }
	}
    }

  *q = '\0';
  free (workpath);

  /* If the result starts with `//', but the original path does not, we
     can turn the // into /.  Because of how we set `qbase', this should never
     be true, but it's a sanity check. */
  if (DOUBLE_SLASH(result) && double_slash_path == 0)
    {
      if (result[2] == '\0')	/* short-circuit for bare `//' */
	result[1] = '\0';
      else
	strcpy (result, result + 1);
    }

  return (result);
}
warning: parse error {
  char tbuf[PATH_MAX+1], linkbuf[PATH_MAX+1];
  char *result, *p, *q, *qsave, *qbase, *workpath;
  int double_slash_path, linklen, nlink;

  linklen = strlen (path);

#if 0
  /* First sanity check -- punt immediately if the name is too long. */
  if (linklen >= PATH_MAX)
    return (savestring (path));
#endif

  nlink = 0;
  q = result = (char *)xmalloc (PATH_MAX + 1);

  /* Even if we get something longer than PATH_MAX, we might be able to
     shorten it, so we try. */
  if (linklen >= PATH_MAX)
    workpath = savestring (path);
  else
    {
      workpath = (char *)xmalloc (PATH_MAX + 1);
      strcpy (workpath, path);
    }

  /* This always gets an absolute pathname. */

  /* POSIX.2 says to leave a leading `//' alone.  On cygwin, we skip over any
     leading `x:' (dos drive name). */
#if defined (__CYGWIN__)
  qbase = (ISALPHA((unsigned char)workpath[0]) && workpath[1] == ':') ? workpath + 3 : workpath + 1;
#else
  qbase = workpath + 1;
#endif
  double_slash_path = DOUBLE_SLASH (workpath);
  qbase += double_slash_path;

  for (p = workpath; p < qbase; )
    *q++ = *p++;
  qbase = q;

  /*
   * invariants:
   *	  qbase points to the portion of the result path we want to modify
   *      p points at beginning of path element we're considering.
   *      q points just past the last path element we wrote (no slash).
   *
   * XXX -- need to fix error checking for too-long pathnames
   */

  while (*p)
    {
      if (ISDIRSEP(p[0])) /* null element */
	p++;
      else if(p[0] == '.' && PATHSEP(p[1]))	/* . and ./ */
	p += 1; 	/* don't count the separator in case it is nul */
      else if (p[0] == '.' && p[1] == '.' && PATHSEP(p[2])) /* .. and ../ */
	{
	  p += 2; /* skip `..' */
	  if (q > qbase)
	    {
	      while (--q > qbase && ISDIRSEP(*q) == 0)
		;
	    }
	}
      else	/* real path element */
	{
	  /* add separator if not at start of work portion of result */
	  qsave = q;
	  if (q != qbase)
	    *q++ = DIRSEP;
	  while (*p && (ISDIRSEP(*p) == 0))
	    {
	      if (q - result >= PATH_MAX)
		{
#ifdef ENAMETOOLONG
		  errno = ENAMETOOLONG;
#else
		  errno = EINVAL;
#endif
		  goto error;
		}
		
	      *q++ = *p++;
	    }

	  *q = '\0';

	  linklen = _path_readlink (result, linkbuf, PATH_MAX);
	  if (linklen < 0)	/* if errno == EINVAL, it's not a symlink */
	    {
	      if (errno != EINVAL)
		goto error;
	      continue;
	    }

	  /* It's a symlink, and the value is in LINKBUF. */
	  nlink++;
	  if (nlink > MAXSYMLINKS)
	    {
#ifdef ELOOP
	      errno = ELOOP;
#else
	      errno = EINVAL;
#endif
error:
	      free (result);
	      free (workpath);
	      return ((char *)NULL);
	    }

	  linkbuf[linklen] = '\0';

	  /* If the new path length would overrun PATH_MAX, punt now. */
	  if ((strlen (p) + linklen + 2) >= PATH_MAX)
	    {
#ifdef ENAMETOOLONG
	      errno = ENAMETOOLONG;
#else
	      errno = EINVAL;
#endif
	      goto error;
	    }

	  /* Form the new pathname by copying the link value to a temporary
	     buffer and appending the rest of `workpath'.  Reset p to point
	     to the start of the rest of the path.  If the link value is an
	     absolute pathname, reset p, q, and qbase.  If not, reset p
	     and q. */
	  strcpy (tbuf, linkbuf);
	  tbuf[linklen] = '/';
	  strcpy (tbuf + linklen, p);
	  strcpy (workpath, tbuf);

	  if (ABSPATH(linkbuf))
	    {
	      q = result;
	      /* Duplicating some code here... */
#if defined (__CYGWIN__)
	      qbase = (ISALPHA((unsigned char)workpath[0]) && workpath[1] == ':') ? workpath + 3 : workpath + 1;
#else
	      qbase = workpath + 1;
#endif
	      double_slash_path = DOUBLE_SLASH (workpath);
	      qbase += double_slash_path;
    
	      for (p = workpath; p < qbase; )
		*q++ = *p++;
	      qbase = q;
	    }
	  else
	    {
	      p = workpath;
	      q = qsave;
	    }
	}
    }

  *q = '\0';
  free (workpath);

  /* If the result starts with `//', but the original path does not, we
     can turn the // into /.  Because of how we set `qbase', this should never
     be true, but it's a sanity check. */
  if (DOUBLE_SLASH(result) && double_slash_path == 0)
    {
      if (result[2] == '\0')	/* short-circuit for bare `//' */
	result[1] = '\0';
      else
	strcpy (result, result + 1);
    }

  return (result);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\pathphys.c:78
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\pathphys.c:256
parsing error 
{
  char *tdir, *wd;

  if (pathname == 0 || *pathname == '\0')
    {
      errno = (pathname == 0) ? EINVAL : ENOENT;
      return ((char *)NULL);
    }

  if (ABSPATH (pathname) == 0)
    {
      wd = get_working_directory ("sh_realpath");
      if (wd == 0)
	return ((char *)NULL);
      tdir = sh_makepath ((char *)pathname, wd, 0);
      free (wd);
    }
  else
    tdir = savestring (pathname);

  wd = sh_physpath (tdir, 0);
  free (tdir);

  if (resolved == 0)
    return (wd);

  if (wd)
    {
      strncpy (resolved, wd, PATH_MAX - 1);
      resolved[PATH_MAX - 1] = '\0';
      free (wd);
      return resolved;
    }
  else
    {
      resolved[0] = '\0';
      return wd;
    }
}
warning: parse error {
  char *tdir, *wd;

  if (pathname == 0 || *pathname == '\0')
    {
      errno = (pathname == 0) ? EINVAL : ENOENT;
      return ((char *)NULL);
    }

  if (ABSPATH (pathname) == 0)
    {
      wd = get_working_directory ("sh_realpath");
      if (wd == 0)
	return ((char *)NULL);
      tdir = sh_makepath ((char *)pathname, wd, 0);
      free (wd);
    }
  else
    tdir = savestring (pathname);

  wd = sh_physpath (tdir, 0);
  free (tdir);

  if (resolved == 0)
    return (wd);

  if (wd)
    {
      strncpy (resolved, wd, PATH_MAX - 1);
      resolved[PATH_MAX - 1] = '\0';
      free (wd);
      return resolved;
    }
  else
    {
      resolved[0] = '\0';
      return wd;
    }
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\pathphys.c:258
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\rename.c...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\bashtypes.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\posixstat.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\stdc.h...skip
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\rename.c:43
parsing error 
{
  struct stat fb, tb;

  if (stat (from, &fb) < 0)
    return -1;  

  if (stat (to, &tb) < 0)
    {
      if (errno != ENOENT)
	return -1;
    }
  else
    {
      if (fb.st_dev == tb.st_dev && fb.st_ino == tb.st_ino)
        return 0;		/* same file */
      if (unlink (to) < 0 && errno != ENOENT)
        return -1;
    }

  if (link (from, to) < 0)
    return (-1);

  if (unlink (from) < 0 && errno != ENOENT)
    {
      int e = errno;
      unlink (to);
      errno = e;
      return (-1);
    }

  return (0);
}
warning: parse error {
  struct stat fb, tb;

  if (stat (from, &fb) < 0)
    return -1;  

  if (stat (to, &tb) < 0)
    {
      if (errno != ENOENT)
	return -1;
    }
  else
    {
      if (fb.st_dev == tb.st_dev && fb.st_ino == tb.st_ino)
        return 0;		/* same file */
      if (unlink (to) < 0 && errno != ENOENT)
        return -1;
    }

  if (link (from, to) < 0)
    return (-1);

  if (unlink (from) < 0 && errno != ENOENT)
    {
      int e = errno;
      unlink (to);
      errno = e;
      return (-1);
    }

  return (0);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\rename.c:44
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\setlinebuf.c...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\xmalloc.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\setlinebuf.c:35
parsing error 
{
  char *local_linebuf;

#if !defined (HAVE_SETLINEBUF) && !defined (HAVE_SETVBUF)
  return (0);
#endif

#if defined (USING_BASH_MALLOC)
  local_linebuf = (char *)xmalloc (LBUF_BUFSIZE);
#else
  local_linebuf = (char *)NULL;
#endif

#if defined (HAVE_SETVBUF)

#  if defined (SETVBUF_REVERSED)
  return (setvbuf (stream, _IOLBF, local_linebuf, LBUF_BUFSIZE));
#  else /* !SETVBUF_REVERSED */
  return (setvbuf (stream, local_linebuf, _IOLBF, LBUF_BUFSIZE));
#  endif /* !SETVBUF_REVERSED */
# else /* !HAVE_SETVBUF */

  setlinebuf (stream);
  return (0);

#endif /* !HAVE_SETVBUF */
}
warning: parse error {
  char *local_linebuf;

#if !defined (HAVE_SETLINEBUF) && !defined (HAVE_SETVBUF)
  return (0);
#endif

#if defined (USING_BASH_MALLOC)
  local_linebuf = (char *)xmalloc (LBUF_BUFSIZE);
#else
  local_linebuf = (char *)NULL;
#endif

#if defined (HAVE_SETVBUF)

#  if defined (SETVBUF_REVERSED)
  return (setvbuf (stream, _IOLBF, local_linebuf, LBUF_BUFSIZE));
#  else /* !SETVBUF_REVERSED */
  return (setvbuf (stream, local_linebuf, _IOLBF, LBUF_BUFSIZE));
#  endif /* !SETVBUF_REVERSED */
# else /* !HAVE_SETVBUF */

  setlinebuf (stream);
  return (0);

#endif /* !HAVE_SETVBUF */
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\setlinebuf.c:37
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\shmatch.c...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\bashansi.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\shell.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\externs.h...skip
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\shmbchar.c...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\shmbutil.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\shmbchar.h...skip
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\shquote.c...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\syntax.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\xmalloc.h...skip
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\shquote.c:45
parsing error 
{
  register int c;
  char *result, *r;
  const char *s;

  result = (char *)xmalloc (3 + (4 * strlen (string)));
  r = result;
  *r++ = '\'';

  for (s = string; s && (c = *s); s++)
    {
      *r++ = c;

      if (c == '\'')
	{
	  *r++ = '\\';	/* insert escaped single quote */
	  *r++ = '\'';
	  *r++ = '\'';	/* start new quoted string */
	}
    }

  *r++ = '\'';
  *r = '\0';

  return (result);
}
warning: parse error {
  register int c;
  char *result, *r;
  const char *s;

  result = (char *)xmalloc (3 + (4 * strlen (string)));
  r = result;
  *r++ = '\'';

  for (s = string; s && (c = *s); s++)
    {
      *r++ = c;

      if (c == '\'')
	{
	  *r++ = '\\';	/* insert escaped single quote */
	  *r++ = '\'';
	  *r++ = '\'';	/* start new quoted string */
	}
    }

  *r++ = '\'';
  *r = '\0';

  return (result);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\shquote.c:46
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\shquote.c:76
parsing error 
{
  register unsigned char c;
  char *result, *r;
  const char *s;

  result = (char *)xmalloc (3 + (2 * strlen (string)));
  r = result;
  *r++ = '"';

  for (s = string; s && (c = *s); s++)
    {
      /* Backslash-newline disappears within double quotes, so don't add one. */
      if ((sh_syntaxtab[c] & CBSDQUOTE) && c != '\n')
	*r++ = '\\';
      else if (c == CTLESC || c == CTLNUL)
	*r++ = CTLESC;		/* could be '\\'? */

      *r++ = c;
    }

  *r++ = '"';
  *r = '\0';

  return (result);
}
warning: parse error {
  register unsigned char c;
  char *result, *r;
  const char *s;

  result = (char *)xmalloc (3 + (2 * strlen (string)));
  r = result;
  *r++ = '"';

  for (s = string; s && (c = *s); s++)
    {
      /* Backslash-newline disappears within double quotes, so don't add one. */
      if ((sh_syntaxtab[c] & CBSDQUOTE) && c != '\n')
	*r++ = '\\';
      else if (c == CTLESC || c == CTLNUL)
	*r++ = CTLESC;		/* could be '\\'? */

      *r++ = c;
    }

  *r++ = '"';
  *r = '\0';

  return (result);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\shquote.c:77
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\shquote.c:107
parsing error 
{
  char *r, *ret;
  int rlen;

  rlen = (flags == 0) ? slen + 3 : (2 * slen) + 1;
  ret = r = (char *)xmalloc (rlen);
  
  *r++ = '"';
  while (*s)
    {
      if (flags && *s == '"')
	*r++ = '\\';
      *r++ = *s++;
    }
  *r++ = '"';
  *r = '\0';

  return ret;
}
warning: parse error {
  char *r, *ret;
  int rlen;

  rlen = (flags == 0) ? slen + 3 : (2 * slen) + 1;
  ret = r = (char *)xmalloc (rlen);
  
  *r++ = '"';
  while (*s)
    {
      if (flags && *s == '"')
	*r++ = '\\';
      *r++ = *s++;
    }
  *r++ = '"';
  *r = '\0';

  return ret;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\shquote.c:109
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\shquote.c:133
parsing error 
{
  register int c, pass_next;
  char *result, *r, *s;

  r = result = (char *)xmalloc (strlen (string) + 1);

  for (pass_next = 0, s = string; s && (c = *s); s++)
    {
      if (pass_next)
	{
	  *r++ = c;
	  pass_next = 0;
	  continue;
	}
      if (c == '\\' && (sh_syntaxtab[(unsigned char) s[1]] & CBSDQUOTE))
	{
	  pass_next = 1;
	  continue;
	}
      *r++ = c;
    }

  *r = '\0';
  return result;
}
warning: parse error {
  register int c, pass_next;
  char *result, *r, *s;

  r = result = (char *)xmalloc (strlen (string) + 1);

  for (pass_next = 0, s = string; s && (c = *s); s++)
    {
      if (pass_next)
	{
	  *r++ = c;
	  pass_next = 0;
	  continue;
	}
      if (c == '\\' && (sh_syntaxtab[(unsigned char) s[1]] & CBSDQUOTE))
	{
	  pass_next = 1;
	  continue;
	}
      *r++ = c;
    }

  *r = '\0';
  return result;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\shquote.c:135
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\shquote.c:168
parsing error 
{
  int c;
  char *result, *r, *s;

  result = (char *)xmalloc (2 * strlen (string) + 1);

  for (r = result, s = string; s && (c = *s); s++)
    {
      switch (c)
	{
	case ' ': case '\t': case '\n':		/* IFS white space */
	case '\'': case '"': case '\\':		/* quoting chars */
	case '|': case '&': case ';':		/* shell metacharacters */
	case '(': case ')': case '<': case '>':
	case '!': case '{': case '}':		/* reserved words */
	case '*': case '[': case '?': case ']':	/* globbing chars */
	case '^':
	case '$': case '`':			/* expansion chars */
	case ',':				/* brace expansion */
	  *r++ = '\\';
	  *r++ = c;
	  break;
#if 0
	case '~':				/* tilde expansion */
	  if (s == string || s[-1] == '=' || s[-1] == ':')
	    *r++ = '\\';
	  *r++ = c;
	  break;

	case CTLESC: case CTLNUL:		/* internal quoting characters */
	  *r++ = CTLESC;			/* could be '\\'? */
	  *r++ = c;
	  break;
#endif

	case '#':				/* comment char */
	  if (s == string)
	    *r++ = '\\';
	  /* FALLTHROUGH */
	default:
	  *r++ = c;
	  break;
	}
    }

  *r = '\0';
  return (result);
}
warning: parse error {
  int c;
  char *result, *r, *s;

  result = (char *)xmalloc (2 * strlen (string) + 1);

  for (r = result, s = string; s && (c = *s); s++)
    {
      switch (c)
	{
	case ' ': case '\t': case '\n':		/* IFS white space */
	case '\'': case '"': case '\\':		/* quoting chars */
	case '|': case '&': case ';':		/* shell metacharacters */
	case '(': case ')': case '<': case '>':
	case '!': case '{': case '}':		/* reserved words */
	case '*': case '[': case '?': case ']':	/* globbing chars */
	case '^':
	case '$': case '`':			/* expansion chars */
	case ',':				/* brace expansion */
	  *r++ = '\\';
	  *r++ = c;
	  break;
#if 0
	case '~':				/* tilde expansion */
	  if (s == string || s[-1] == '=' || s[-1] == ':')
	    *r++ = '\\';
	  *r++ = c;
	  break;

	case CTLESC: case CTLNUL:		/* internal quoting characters */
	  *r++ = CTLESC;			/* could be '\\'? */
	  *r++ = c;
	  break;
#endif

	case '#':				/* comment char */
	  if (s == string)
	    *r++ = '\\';
	  /* FALLTHROUGH */
	default:
	  *r++ = c;
	  break;
	}
    }

  *r = '\0';
  return (result);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\shquote.c:170
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\shquote.c:248
parsing error 
{
  char *s;

  for (s = string; s && *s; s++)
    {
      switch (*s)
	{
	case ' ': case '\t': case '\n':		/* IFS white space */
	case '\'': case '"': case '\\':		/* quoting chars */
	case '|': case '&': case ';':		/* shell metacharacters */
	case '(': case ')': case '<': case '>':
	case '!': case '{': case '}':		/* reserved words */
	case '*': case '[': case '?': case ']':	/* globbing chars */
	case '^':
	case '$': case '`':			/* expansion chars */
	  return (1);
	case '~':				/* tilde expansion */
	  if (s == string || s[-1] == '=' || s[-1] == ':')
	    return (1);
	  break;
	case '#':
	  if (s == string)			/* comment char */
	    return (1);
	  /* FALLTHROUGH */
	default:
	  break;
	}
    }

  return (0);
}
warning: parse error {
  char *s;

  for (s = string; s && *s; s++)
    {
      switch (*s)
	{
	case ' ': case '\t': case '\n':		/* IFS white space */
	case '\'': case '"': case '\\':		/* quoting chars */
	case '|': case '&': case ';':		/* shell metacharacters */
	case '(': case ')': case '<': case '>':
	case '!': case '{': case '}':		/* reserved words */
	case '*': case '[': case '?': case ']':	/* globbing chars */
	case '^':
	case '$': case '`':			/* expansion chars */
	  return (1);
	case '~':				/* tilde expansion */
	  if (s == string || s[-1] == '=' || s[-1] == ':')
	    return (1);
	  break;
	case '#':
	  if (s == string)			/* comment char */
	    return (1);
	  /* FALLTHROUGH */
	default:
	  break;
	}
    }

  return (0);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\shquote.c:250
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\shtty.c...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\shtty.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\shtty.c:37
parsing error 
{
#ifdef TERMIOS_TTY_DRIVER
  return tcgetattr(fd, ttp);
#else
#  ifdef TERMIO_TTY_DRIVER
  return ioctl(fd, TCGETA, ttp);
#  else
  return ioctl(fd, TIOCGETP, ttp);
#  endif
#endif
}
warning: parse error {
#ifdef TERMIOS_TTY_DRIVER
  return tcgetattr(fd, ttp);
#else
#  ifdef TERMIO_TTY_DRIVER
  return ioctl(fd, TCGETA, ttp);
#  else
  return ioctl(fd, TIOCGETP, ttp);
#  endif
#endif
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\shtty.c:40
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\shtty.c:53
parsing error 
{
#ifdef TERMIOS_TTY_DRIVER
  return tcsetattr(fd, TCSADRAIN, ttp);
#else
#  ifdef TERMIO_TTY_DRIVER
  return ioctl(fd, TCSETAW, ttp);
#  else
  return ioctl(fd, TIOCSETN, ttp);
#  endif
#endif
}
warning: parse error {
#ifdef TERMIOS_TTY_DRIVER
  return tcsetattr(fd, TCSADRAIN, ttp);
#else
#  ifdef TERMIO_TTY_DRIVER
  return ioctl(fd, TCSETAW, ttp);
#  else
  return ioctl(fd, TIOCSETN, ttp);
#  endif
#endif
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\shtty.c:56
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\shtty.c:90
parsing error 
{
  if (ttsaved == 0)
    return ((TTYSTRUCT *)0);
  if (fd == 0)
    return &ttin;
  else if (fd == 1)
    return &ttout;
  else
    return ((TTYSTRUCT *)0);
}
warning: parse error {
  if (ttsaved == 0)
    return ((TTYSTRUCT *)0);
  if (fd == 0)
    return &ttin;
  else if (fd == 1)
    return &ttout;
  else
    return ((TTYSTRUCT *)0);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\shtty.c:92
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\shtty.c:108
parsing error 
{
#if defined (TERMIOS_TTY_DRIVER) || defined (TERMIO_TTY_DRIVER)

  /* XXX - might not want this -- it disables erase and kill processing. */
  ttp->c_lflag &= ~ICANON;

  ttp->c_lflag |= ISIG;
#  ifdef IEXTEN
  ttp->c_lflag |= IEXTEN;
#  endif

  ttp->c_iflag |= ICRNL;	/* make sure we get CR->NL on input */
  ttp->c_iflag &= ~INLCR;	/* but no NL->CR */

#  ifdef OPOST
  ttp->c_oflag |= OPOST;
#  endif
#  ifdef ONLCR
  ttp->c_oflag |= ONLCR;
#  endif
#  ifdef OCRNL
  ttp->c_oflag &= ~OCRNL;
#  endif
#  ifdef ONOCR
  ttp->c_oflag &= ~ONOCR;
#  endif
#  ifdef ONLRET
  ttp->c_oflag &= ~ONLRET;
#  endif

  ttp->c_cc[VMIN] = 1;
  ttp->c_cc[VTIME] = 0;

#else

  ttp->sg_flags |= CBREAK;

#endif

  return 0;
}
warning: parse error {
#if defined (TERMIOS_TTY_DRIVER) || defined (TERMIO_TTY_DRIVER)

  /* XXX - might not want this -- it disables erase and kill processing. */
  ttp->c_lflag &= ~ICANON;

  ttp->c_lflag |= ISIG;
#  ifdef IEXTEN
  ttp->c_lflag |= IEXTEN;
#  endif

  ttp->c_iflag |= ICRNL;	/* make sure we get CR->NL on input */
  ttp->c_iflag &= ~INLCR;	/* but no NL->CR */

#  ifdef OPOST
  ttp->c_oflag |= OPOST;
#  endif
#  ifdef ONLCR
  ttp->c_oflag |= ONLCR;
#  endif
#  ifdef OCRNL
  ttp->c_oflag &= ~OCRNL;
#  endif
#  ifdef ONOCR
  ttp->c_oflag &= ~ONOCR;
#  endif
#  ifdef ONLRET
  ttp->c_oflag &= ~ONLRET;
#  endif

  ttp->c_cc[VMIN] = 1;
  ttp->c_cc[VTIME] = 0;

#else

  ttp->sg_flags |= CBREAK;

#endif

  return 0;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\shtty.c:110
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\shtty.c:154
parsing error 
{
  if (tt_setonechar(ttp) < 0)
    return -1;
  return (ttsetattr (fd, ttp));
}
warning: parse error {
  if (tt_setonechar(ttp) < 0)
    return -1;
  return (ttsetattr (fd, ttp));
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\shtty.c:157
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\shtty.c:180
parsing error 
{
#if defined (TERMIOS_TTY_DRIVER) || defined (TERMIO_TTY_DRIVER)
  ttp->c_lflag &= ~(ECHO|ECHOK|ECHONL);
#else
  ttp->sg_flags &= ~ECHO;
#endif

  return 0;
}
warning: parse error {
#if defined (TERMIOS_TTY_DRIVER) || defined (TERMIO_TTY_DRIVER)
  ttp->c_lflag &= ~(ECHO|ECHOK|ECHONL);
#else
  ttp->sg_flags &= ~ECHO;
#endif

  return 0;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\shtty.c:182
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\shtty.c:194
parsing error 
{
  if (tt_setnoecho (ttp) < 0)
    return -1;
  return (ttsetattr (fd, ttp));
}
warning: parse error {
  if (tt_setnoecho (ttp) < 0)
    return -1;
  return (ttsetattr (fd, ttp));
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\shtty.c:197
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\shtty.c:220
parsing error 
{
#if defined (TERMIOS_TTY_DRIVER) || defined (TERMIO_TTY_DRIVER)
  ttp->c_iflag &= ~ISTRIP;
  ttp->c_cflag |= CS8;
  ttp->c_cflag &= ~PARENB;
#else
  ttp->sg_flags |= ANYP;
#endif

  return 0;
}
warning: parse error {
#if defined (TERMIOS_TTY_DRIVER) || defined (TERMIO_TTY_DRIVER)
  ttp->c_iflag &= ~ISTRIP;
  ttp->c_cflag |= CS8;
  ttp->c_cflag &= ~PARENB;
#else
  ttp->sg_flags |= ANYP;
#endif

  return 0;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\shtty.c:222
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\shtty.c:236
parsing error 
{
  if (tt_seteightbit (ttp) < 0)
    return -1;
  return (ttsetattr (fd, ttp));
}
warning: parse error {
  if (tt_seteightbit (ttp) < 0)
    return -1;
  return (ttsetattr (fd, ttp));
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\shtty.c:239
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\shtty.c:262
parsing error 
{
#if defined (TERMIOS_TTY_DRIVER) || defined (TERMIO_TTY_DRIVER)
  ttp->c_lflag &= ~ICANON;
#endif

  return 0;
}
warning: parse error {
#if defined (TERMIOS_TTY_DRIVER) || defined (TERMIO_TTY_DRIVER)
  ttp->c_lflag &= ~ICANON;
#endif

  return 0;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\shtty.c:264
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\shtty.c:274
parsing error 
{
  if (tt_setnocanon (ttp) < 0)
    return -1;
  return (ttsetattr (fd, ttp));
}
warning: parse error {
  if (tt_setnocanon (ttp) < 0)
    return -1;
  return (ttsetattr (fd, ttp));
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\shtty.c:277
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\shtty.c:300
parsing error 
{
  if (tt_setonechar (ttp) < 0)
    return -1;
  return (tt_setnoecho (ttp));
}
warning: parse error {
  if (tt_setonechar (ttp) < 0)
    return -1;
  return (tt_setnoecho (ttp));
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\shtty.c:302
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\shtty.c:311
parsing error 
{
  if (tt_setcbreak (ttp) < 0)
    return -1;
  return (ttsetattr (fd, ttp));
}
warning: parse error {
  if (tt_setcbreak (ttp) < 0)
    return -1;
  return (ttsetattr (fd, ttp));
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\shtty.c:314
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\snprintf.c...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\bashtypes.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\bashansi.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\chartypes.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\typemax.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\stdc.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\shmbutil.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\snprintf.c:453
parsing error 
{ 
  double P;

  /* handle common cases with fast switch statement. */
  switch (n)
    {
    case -3:	return .001;
    case -2:	return .01;
    case -1:	return .1;
    case 0:	return 1.;
    case 1:	return 10.;
    case 2:	return 100.;
    case 3:	return 1000.;
    }

  if (n < 0)
    {
      P = .0001;
      for (n += 4; n < 0; n++)
	P /= 10.;
    }
  else
    {
      P = 10000.;
      for (n -= 4; n > 0; n--)
	P *= 10.;
    }

  return P;
}
warning: parse error { 
  double P;

  /* handle common cases with fast switch statement. */
  switch (n)
    {
    case -3:	return .001;
    case -2:	return .01;
    case -1:	return .1;
    case 0:	return 1.;
    case 1:	return 10.;
    case 2:	return 100.;
    case 3:	return 1000.;
    }

  if (n < 0)
    {
      P = .0001;
      for (n += 4; n < 0; n++)
	P /= 10.;
    }
  else
    {
      P = 10000.;
      for (n -= 4; n > 0; n--)
	P *= 10.;
    }

  return P;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\snprintf.c:455
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\snprintf.c:497
parsing error 
{ 
  int i = 0;
  double result = 1.;

  if (r < 0.)
    r = -r;

  if (r < 1.)
    {
      while (result >= r)
	{
	  result /= 10.;
	  i++;
	}
      return (-i);
    }
  else
    {
      while (result <= r)
	{
	  result *= 10.;
	  i++;
	}
      return (i - 1);
    }
}
warning: parse error { 
  int i = 0;
  double result = 1.;

  if (r < 0.)
    r = -r;

  if (r < 1.)
    {
      while (result >= r)
	{
	  result /= 10.;
	  i++;
	}
      return (-i);
    }
  else
    {
      while (result <= r)
	{
	  result *= 10.;
	  i++;
	}
      return (i - 1);
    }
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\snprintf.c:499
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\snprintf.c:532
parsing error 
{ 
  int j;
  double i, s, p;
  double real_integral = 0.;

  /* take care of the obvious */
  /* equal to zero ? */
  if (real == 0.)
    {
      *ip = 0.;
      return (0.);
    }

  /* negative number ? */
  if (real < 0.)
    real = -real;

  /* a fraction ? */
  if ( real < 1.)
    {
      *ip = 0.;
      return real;
    }

  /* the real work :-) */
  for (j = log_10(real); j >= 0; j--)
    {
      p = pow_10(j);
      s = (real - real_integral)/p;
      i = 0.;
      while (i + 1. <= s)
	i++;
      real_integral += i*p;
    }
  *ip = real_integral;
  return (real - real_integral);
}
warning: parse error { 
  int j;
  double i, s, p;
  double real_integral = 0.;

  /* take care of the obvious */
  /* equal to zero ? */
  if (real == 0.)
    {
      *ip = 0.;
      return (0.);
    }

  /* negative number ? */
  if (real < 0.)
    real = -real;

  /* a fraction ? */
  if ( real < 1.)
    {
      *ip = 0.;
      return real;
    }

  /* the real work :-) */
  for (j = log_10(real); j >= 0; j--)
    {
      p = pow_10(j);
      s = (real - real_integral)/p;
      i = 0.;
      while (i + 1. <= s)
	i++;
      real_integral += i*p;
    }
  *ip = real_integral;
  return (real - real_integral);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\snprintf.c:535
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\snprintf.c:581
parsing error 
{
  register int i, j;
  double ip, fp; /* integer and fraction part */
  double fraction;
  int digits = MAX_INT - 1;
  static char integral_part[MAX_INT];
  static char fraction_part[MAX_FRACT];
  double sign;
  int ch;

  /* taking care of the obvious case: 0.0 */
  if (number == 0.)
    { 
      integral_part[0] = '0';
      integral_part[1] = '\0';
      /* The fractional part has to take the precision into account */
      for (ch = 0; ch < precision-1; ch++)
 	fraction_part[ch] = '0';
      fraction_part[ch] = '0';
      fraction_part[ch+1] = '\0';
      if (fract)
	*fract = fraction_part;
      return integral_part;
    }

  /* for negative numbers */
  if ((sign = number) < 0.)
    {
      number = -number;
      digits--; /* sign consume one digit */
    }

  fraction = integral(number, &ip);
  number = ip;

  /* do the integral part */
  if (ip == 0.)
    {
      integral_part[0] = '0';
      i = 1;
    }
  else
    {
      for ( i = 0; i < digits && number != 0.; ++i)
	{
	  number /= base;
	  fp = integral(number, &ip);
	  ch = (int)((fp + PRECISION)*base); /* force to round */
	  integral_part[i] = (ch <= 9) ? ch + '0' : ch + 'a' - 10;
	  if (! ISXDIGIT((unsigned char)integral_part[i]))
	    break;	/* bail out overflow !! */
	  number = ip;
	 }
    }
     
  /* Oh No !! out of bound, ho well fill it up ! */
  if (number != 0.)
    for (i = 0; i < digits; ++i)
      integral_part[i] = '9';

  /* put the sign ? */
  if (sign < 0.)
    integral_part[i++] = '-';

  integral_part[i] = '\0';

  /* reverse every thing */
  for ( i--, j = 0; j < i; j++, i--)
    SWAP_INT(integral_part[i], integral_part[j]);  

  /* the fractional part */
  for (i=0, fp=fraction; precision > 0 && i < MAX_FRACT ; i++, precision--)
    {
      fraction_part[i] = (int)((fp + PRECISION)*10. + '0');
      if (! DIGIT(fraction_part[i])) /* underflow ? */
	break;
      fp = (fp*10.0) - (double)(long)((fp + PRECISION)*10.);
    }
  fraction_part[i] = '\0';

  if (fract != (char **)0)
    *fract = fraction_part;

  return integral_part;
}
warning: parse error {
  register int i, j;
  double ip, fp; /* integer and fraction part */
  double fraction;
  int digits = MAX_INT - 1;
  static char integral_part[MAX_INT];
  static char fraction_part[MAX_FRACT];
  double sign;
  int ch;

  /* taking care of the obvious case: 0.0 */
  if (number == 0.)
    { 
      integral_part[0] = '0';
      integral_part[1] = '\0';
      /* The fractional part has to take the precision into account */
      for (ch = 0; ch < precision-1; ch++)
 	fraction_part[ch] = '0';
      fraction_part[ch] = '0';
      fraction_part[ch+1] = '\0';
      if (fract)
	*fract = fraction_part;
      return integral_part;
    }

  /* for negative numbers */
  if ((sign = number) < 0.)
    {
      number = -number;
      digits--; /* sign consume one digit */
    }

  fraction = integral(number, &ip);
  number = ip;

  /* do the integral part */
  if (ip == 0.)
    {
      integral_part[0] = '0';
      i = 1;
    }
  else
    {
      for ( i = 0; i < digits && number != 0.; ++i)
	{
	  number /= base;
	  fp = integral(number, &ip);
	  ch = (int)((fp + PRECISION)*base); /* force to round */
	  integral_part[i] = (ch <= 9) ? ch + '0' : ch + 'a' - 10;
	  if (! ISXDIGIT((unsigned char)integral_part[i]))
	    break;	/* bail out overflow !! */
	  number = ip;
	 }
    }
     
  /* Oh No !! out of bound, ho well fill it up ! */
  if (number != 0.)
    for (i = 0; i < digits; ++i)
      integral_part[i] = '9';

  /* put the sign ? */
  if (sign < 0.)
    integral_part[i++] = '-';

  integral_part[i] = '\0';

  /* reverse every thing */
  for ( i--, j = 0; j < i; j++, i--)
    SWAP_INT(integral_part[i], integral_part[j]);  

  /* the fractional part */
  for (i=0, fp=fraction; precision > 0 && i < MAX_FRACT ; i++, precision--)
    {
      fraction_part[i] = (int)((fp + PRECISION)*10. + '0');
      if (! DIGIT(fraction_part[i])) /* underflow ? */
	break;
      fp = (fp*10.0) - (double)(long)((fp + PRECISION)*10.);
    }
  fraction_part[i] = '\0';

  if (fract != (char **)0)
    *fract = fraction_part;

  return integral_part;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\snprintf.c:585
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\snprintf.c:676
parsing error 
{
  char *tmp, *t;
  long sd;
  int flags;

  /* An explicit precision turns off the zero-padding flag. */
  if ((p->flags & PF_ZEROPAD) && p->precision >= 0 && (p->flags & PF_DOT))
    p->flags &= ~PF_ZEROPAD;

  sd = d;	/* signed for ' ' padding in base 10 */
  flags = 0;
  flags = (*p->pf == 'x' || *p->pf == 'X' || *p->pf == 'o' || *p->pf == 'u' || *p->pf == 'U') ? FL_UNSIGNED : 0;
  if (*p->pf == 'X')
    flags |= FL_HEXUPPER;

  tmp = fmtulong (d, base, intbuf, sizeof(intbuf), flags);
  t = 0;
  if ((p->flags & PF_THOUSANDS))
    {
      GETLOCALEDATA(decpoint, thoussep, grouping);
      if (grouping && (t = groupnum (tmp)))
        tmp = t;
    }

  p->width -= strlen(tmp);
  PAD_RIGHT(p);

  if ((p->flags & PF_DOT) && p->precision > 0)
    {
      p->precision -= strlen(tmp);
      PAD_ZERO(p);
    }

  switch (base)
    {
    case 10:
      PUT_PLUS(sd, p, 0);
      PUT_SPACE(sd, p, 0);
      break;
    case 8:
      if (p->flags & PF_ALTFORM)
	PUT_CHAR('0', p);
      break;
    case 16:
      if (p->flags & PF_ALTFORM)
	{
	  PUT_CHAR('0', p);
	  PUT_CHAR(*p->pf, p);
	}
      break;
    }

  while (*tmp)
    {
      PUT_CHAR(*tmp, p);
      tmp++;
    }

  PAD_LEFT(p);
  FREE (t);
}
warning: parse error {
  char *tmp, *t;
  long sd;
  int flags;

  /* An explicit precision turns off the zero-padding flag. */
  if ((p->flags & PF_ZEROPAD) && p->precision >= 0 && (p->flags & PF_DOT))
    p->flags &= ~PF_ZEROPAD;

  sd = d;	/* signed for ' ' padding in base 10 */
  flags = 0;
  flags = (*p->pf == 'x' || *p->pf == 'X' || *p->pf == 'o' || *p->pf == 'u' || *p->pf == 'U') ? FL_UNSIGNED : 0;
  if (*p->pf == 'X')
    flags |= FL_HEXUPPER;

  tmp = fmtulong (d, base, intbuf, sizeof(intbuf), flags);
  t = 0;
  if ((p->flags & PF_THOUSANDS))
    {
      GETLOCALEDATA(decpoint, thoussep, grouping);
      if (grouping && (t = groupnum (tmp)))
        tmp = t;
    }

  p->width -= strlen(tmp);
  PAD_RIGHT(p);

  if ((p->flags & PF_DOT) && p->precision > 0)
    {
      p->precision -= strlen(tmp);
      PAD_ZERO(p);
    }

  switch (base)
    {
    case 10:
      PUT_PLUS(sd, p, 0);
      PUT_SPACE(sd, p, 0);
      break;
    case 8:
      if (p->flags & PF_ALTFORM)
	PUT_CHAR('0', p);
      break;
    case 16:
      if (p->flags & PF_ALTFORM)
	{
	  PUT_CHAR('0', p);
	  PUT_CHAR(*p->pf, p);
	}
      break;
    }

  while (*tmp)
    {
      PUT_CHAR(*tmp, p);
      tmp++;
    }

  PAD_LEFT(p);
  FREE (t);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\snprintf.c:680
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\snprintf.c:814
parsing error 
{
  char *tmp;

  tmp = fmtulong(d, 16, intbuf, sizeof(intbuf), 0);
  p->width -= strlen(tmp);
  PAD_RIGHT(p);

  /* prefix '0x' for pointers */
  PUT_CHAR('0', p);
  PUT_CHAR('x', p);

  while (*tmp)
    {
      PUT_CHAR(*tmp, p);
      tmp++;
    }

  PAD_LEFT(p);
}
warning: parse error {
  char *tmp;

  tmp = fmtulong(d, 16, intbuf, sizeof(intbuf), 0);
  p->width -= strlen(tmp);
  PAD_RIGHT(p);

  /* prefix '0x' for pointers */
  PUT_CHAR('0', p);
  PUT_CHAR('x', p);

  while (*tmp)
    {
      PUT_CHAR(*tmp, p);
      tmp++;
    }

  PAD_LEFT(p);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\snprintf.c:817
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\snprintf.c:839
parsing error 
{
  size_t len;

  len = strlen(tmp);
  if (p->precision != NOT_FOUND) /* the smallest number */
    len = (len < p->precision ? len : p->precision);
  p->width -= len;

  PUT_STRING (tmp, len, p);
}
warning: parse error {
  size_t len;

  len = strlen(tmp);
  if (p->precision != NOT_FOUND) /* the smallest number */
    len = (len < p->precision ? len : p->precision);
  p->width -= len;

  PUT_STRING (tmp, len, p);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\snprintf.c:842
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\snprintf.c:925
parsing error 
{
#ifdef DBL_MAX
  if (d < DBL_MIN)
    return -1;
  else if (d > DBL_MAX)
    return 1;
  else
#endif
    return 0;
}
warning: parse error {
#ifdef DBL_MAX
  if (d < DBL_MIN)
    return -1;
  else if (d > DBL_MAX)
    return 1;
  else
#endif
    return 0;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\snprintf.c:927
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\snprintf.c:941
parsing error 
{
  return 0;
}
warning: parse error {
  return 0;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\snprintf.c:943
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\snprintf.c:952
parsing error 
{
  int i;
  char *tmp;
  char *big, *small;

  i = (mode == 1) ? isinf(d) : isnan(d);
  if (i == 0)
    return 0;
  big = (mode == 1) ? "INF" : "NAN";
  small = (mode == 1) ? "inf" : "nan";

  tmp = (*p->pf == 'F' || *p->pf == 'G' || *p->pf == 'E') ? big : small;

  if (i < 0)
    PUT_CHAR('-', p);

  while (*tmp)
    {
      PUT_CHAR (*tmp, p);
      tmp++;
    }

  return 1;
}
warning: parse error {
  int i;
  char *tmp;
  char *big, *small;

  i = (mode == 1) ? isinf(d) : isnan(d);
  if (i == 0)
    return 0;
  big = (mode == 1) ? "INF" : "NAN";
  small = (mode == 1) ? "inf" : "nan";

  tmp = (*p->pf == 'F' || *p->pf == 'G' || *p->pf == 'E') ? big : small;

  if (i < 0)
    PUT_CHAR('-', p);

  while (*tmp)
    {
      PUT_CHAR (*tmp, p);
      tmp++;
    }

  return 1;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\snprintf.c:956
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\snprintf.c:983
parsing error 
{
  char *tmp, *tmp2, *t;
  int i;

  if (d != 0 && (chkinfnan(p, d, 1) || chkinfnan(p, d, 2)))
    return;	/* already printed nan or inf */

  GETLOCALEDATA(decpoint, thoussep, grouping);
  DEF_PREC(p);
  d = ROUND(d, p);
  tmp = dtoa(d, p->precision, &tmp2);
  t = 0;
  if ((p->flags & PF_THOUSANDS) && grouping && (t = groupnum (tmp)))
    tmp = t;

  if ((*p->pf == 'g' || *p->pf == 'G') && (p->flags & PF_ALTFORM) == 0)
    {
      /* smash the trailing zeros unless altform */
      for (i = strlen(tmp2) - 1; i >= 0 && tmp2[i] == '0'; i--)
        tmp2[i] = '\0'; 
      if (tmp2[0] == '\0')
	p->precision = 0;
    }

  /* calculate the padding. 1 for the dot */
  p->width = p->width -
	    ((d > 0. && p->justify == RIGHT) ? 1:0) -
	    ((p->flags & PF_SPACE) ? 1:0) -
	    strlen(tmp) - p->precision -
	    ((p->precision != 0 || (p->flags & PF_ALTFORM)) ? 1 : 0);	/* radix char */
  PAD_RIGHT(p);  
  PUT_PLUS(d, p, 0.);
  PUT_SPACE(d, p, 0.);

  while (*tmp)
    {
      PUT_CHAR(*tmp, p);	/* the integral */
      tmp++;
    }
  FREE (t);

  if (p->precision != 0 || (p->flags & PF_ALTFORM))
    PUT_CHAR(decpoint, p);  /* put the '.' */

  for (; *tmp2; tmp2++)
    PUT_CHAR(*tmp2, p); /* the fraction */
  
  PAD_LEFT(p);
}
warning: parse error {
  char *tmp, *tmp2, *t;
  int i;

  if (d != 0 && (chkinfnan(p, d, 1) || chkinfnan(p, d, 2)))
    return;	/* already printed nan or inf */

  GETLOCALEDATA(decpoint, thoussep, grouping);
  DEF_PREC(p);
  d = ROUND(d, p);
  tmp = dtoa(d, p->precision, &tmp2);
  t = 0;
  if ((p->flags & PF_THOUSANDS) && grouping && (t = groupnum (tmp)))
    tmp = t;

  if ((*p->pf == 'g' || *p->pf == 'G') && (p->flags & PF_ALTFORM) == 0)
    {
      /* smash the trailing zeros unless altform */
      for (i = strlen(tmp2) - 1; i >= 0 && tmp2[i] == '0'; i--)
        tmp2[i] = '\0'; 
      if (tmp2[0] == '\0')
	p->precision = 0;
    }

  /* calculate the padding. 1 for the dot */
  p->width = p->width -
	    ((d > 0. && p->justify == RIGHT) ? 1:0) -
	    ((p->flags & PF_SPACE) ? 1:0) -
	    strlen(tmp) - p->precision -
	    ((p->precision != 0 || (p->flags & PF_ALTFORM)) ? 1 : 0);	/* radix char */
  PAD_RIGHT(p);  
  PUT_PLUS(d, p, 0.);
  PUT_SPACE(d, p, 0.);

  while (*tmp)
    {
      PUT_CHAR(*tmp, p);	/* the integral */
      tmp++;
    }
  FREE (t);

  if (p->precision != 0 || (p->flags & PF_ALTFORM))
    PUT_CHAR(decpoint, p);  /* put the '.' */

  for (; *tmp2; tmp2++)
    PUT_CHAR(*tmp2, p); /* the fraction */
  
  PAD_LEFT(p);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\snprintf.c:986
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\snprintf.c:1,038
parsing error 
{
  char *tmp, *tmp2;
  int j, i;

  if (d != 0 && (chkinfnan(p, d, 1) || chkinfnan(p, d, 2)))
    return;	/* already printed nan or inf */

  GETLOCALEDATA(decpoint, thoussep, grouping);
  DEF_PREC(p);
  if (d == 0.)
    j = 0;
  else
    {
      j = log_10(d);
      d = d / pow_10(j);  /* get the Mantissa */
      d = ROUND(d, p);		  
    }
  tmp = dtoa(d, p->precision, &tmp2);

  /* 1 for unit, 1 for the '.', 1 for 'e|E',
   * 1 for '+|-', 2 for 'exp' */
  /* calculate how much padding need */
  p->width = p->width - 
	     ((d > 0. && p->justify == RIGHT) ? 1:0) -
	     ((p->flags & PF_SPACE) ? 1:0) - p->precision - 6;

  PAD_RIGHT(p);
  PUT_PLUS(d, p, 0.);
  PUT_SPACE(d, p, 0.);

  while (*tmp)
    {
      PUT_CHAR(*tmp, p);
      tmp++;
    }

  if (p->precision != 0 || (p->flags & PF_ALTFORM))
      PUT_CHAR(decpoint, p);  /* the '.' */

  if ((*p->pf == 'g' || *p->pf == 'G') && (p->flags & PF_ALTFORM) == 0)
    /* smash the trailing zeros unless altform */
    for (i = strlen(tmp2) - 1; i >= 0 && tmp2[i] == '0'; i--)
      tmp2[i] = '\0'; 

  for (; *tmp2; tmp2++)
    PUT_CHAR(*tmp2, p); /* the fraction */

  /* the exponent put the 'e|E' */
  if (*p->pf == 'g' || *p->pf == 'e')
    PUT_CHAR('e', p);
  else
    PUT_CHAR('E', p);

  /* the sign of the exp */
  if (j >= 0)
    PUT_CHAR('+', p);
  else
    {
      PUT_CHAR('-', p);
      j = -j;
    }

   tmp = itoa(j);
   /* pad out to at least two spaces.  pad with `0' if the exponent is a
      single digit. */
   if (j <= 9)
     PUT_CHAR('0', p);

   /* the exponent */
   while (*tmp)
     {
       PUT_CHAR(*tmp, p);
       tmp++;
     }

   PAD_LEFT(p);
}
warning: parse error {
  char *tmp, *tmp2;
  int j, i;

  if (d != 0 && (chkinfnan(p, d, 1) || chkinfnan(p, d, 2)))
    return;	/* already printed nan or inf */

  GETLOCALEDATA(decpoint, thoussep, grouping);
  DEF_PREC(p);
  if (d == 0.)
    j = 0;
  else
    {
      j = log_10(d);
      d = d / pow_10(j);  /* get the Mantissa */
      d = ROUND(d, p);		  
    }
  tmp = dtoa(d, p->precision, &tmp2);

  /* 1 for unit, 1 for the '.', 1 for 'e|E',
   * 1 for '+|-', 2 for 'exp' */
  /* calculate how much padding need */
  p->width = p->width - 
	     ((d > 0. && p->justify == RIGHT) ? 1:0) -
	     ((p->flags & PF_SPACE) ? 1:0) - p->precision - 6;

  PAD_RIGHT(p);
  PUT_PLUS(d, p, 0.);
  PUT_SPACE(d, p, 0.);

  while (*tmp)
    {
      PUT_CHAR(*tmp, p);
      tmp++;
    }

  if (p->precision != 0 || (p->flags & PF_ALTFORM))
      PUT_CHAR(decpoint, p);  /* the '.' */

  if ((*p->pf == 'g' || *p->pf == 'G') && (p->flags & PF_ALTFORM) == 0)
    /* smash the trailing zeros unless altform */
    for (i = strlen(tmp2) - 1; i >= 0 && tmp2[i] == '0'; i--)
      tmp2[i] = '\0'; 

  for (; *tmp2; tmp2++)
    PUT_CHAR(*tmp2, p); /* the fraction */

  /* the exponent put the 'e|E' */
  if (*p->pf == 'g' || *p->pf == 'e')
    PUT_CHAR('e', p);
  else
    PUT_CHAR('E', p);

  /* the sign of the exp */
  if (j >= 0)
    PUT_CHAR('+', p);
  else
    {
      PUT_CHAR('-', p);
      j = -j;
    }

   tmp = itoa(j);
   /* pad out to at least two spaces.  pad with `0' if the exponent is a
      single digit. */
   if (j <= 9)
     PUT_CHAR('0', p);

   /* the exponent */
   while (*tmp)
     {
       PUT_CHAR(*tmp, p);
       tmp++;
     }

   PAD_LEFT(p);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\snprintf.c:1,041
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\snprintf.c:1,124
parsing error 
{
  char *se, *ret, *re, *g;
  int len, slen;

  if (grouping == 0 || *grouping <= 0 || *grouping == CHAR_MAX)
    return ((char *)NULL);

  /* find min grouping to size returned string */
  for (len = *grouping, g = grouping; *g; g++)
      if (*g > 0 && *g < len)
	len = *g;

  slen = strlen (s);
  len = slen / len + 1;
  ret = (char *)xmalloc (slen + len + 1);
  re = ret + slen + len;
  *re = '\0';

  g = grouping;
  se = s + slen;
  len = *g;

  while (se > s)
    {
      *--re = *--se;

      /* handle `-' inserted by numtoa() and the fmtu* family here. */
      if (se > s && se[-1] == '-')
	continue;

      /* begin new group. */
      if (--len == 0 && se > s)
	{
	  *--re = thoussep;
	  len = *++g;		/* was g++, but that uses first char twice (glibc bug, too) */
	  if (*g == '\0')
	    len = *--g;		/* use previous grouping */
	  else if (*g == CHAR_MAX)
	    {
	      do
	        *--re = *--se;
	      while (se > s);
	      break;
	    }
	}
    }

  if (re > ret)
#ifdef HAVE_MEMMOVE
    memmove (ret, re, strlen (re) + 1);
#else
    strcpy (ret, re);
#endif
   
  return ret;
}
warning: parse error {
  char *se, *ret, *re, *g;
  int len, slen;

  if (grouping == 0 || *grouping <= 0 || *grouping == CHAR_MAX)
    return ((char *)NULL);

  /* find min grouping to size returned string */
  for (len = *grouping, g = grouping; *g; g++)
      if (*g > 0 && *g < len)
	len = *g;

  slen = strlen (s);
  len = slen / len + 1;
  ret = (char *)xmalloc (slen + len + 1);
  re = ret + slen + len;
  *re = '\0';

  g = grouping;
  se = s + slen;
  len = *g;

  while (se > s)
    {
      *--re = *--se;

      /* handle `-' inserted by numtoa() and the fmtu* family here. */
      if (se > s && se[-1] == '-')
	continue;

      /* begin new group. */
      if (--len == 0 && se > s)
	{
	  *--re = thoussep;
	  len = *++g;		/* was g++, but that uses first char twice (glibc bug, too) */
	  if (*g == '\0')
	    len = *--g;		/* use previous grouping */
	  else if (*g == CHAR_MAX)
	    {
	      do
	        *--re = *--se;
	      while (se > s);
	      break;
	    }
	}
    }

  if (re > ret)
#ifdef HAVE_MEMMOVE
    memmove (ret, re, strlen (re) + 1);
#else
    strcpy (ret, re);
#endif
   
  return ret;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\snprintf.c:1,126
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\snprintf.c:1,185
parsing error 
{
  p->flags &= PF_ALLOCBUF;		/* preserve PF_ALLOCBUF flag */
  p->precision = p->width = NOT_FOUND;
  p->justify = NOT_FOUND;
  p->pad = ' ';
}
warning: parse error {
  p->flags &= PF_ALLOCBUF;		/* preserve PF_ALLOCBUF flag */
  p->precision = p->width = NOT_FOUND;
  p->justify = NOT_FOUND;
  p->pad = ' ';
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\snprintf.c:1,187
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\snprintf.c:1,195
parsing error 
{
  p->length = length - 1; /* leave room for '\0' */
  p->holder = p->base = string;
  p->pf = format;
  p->counter = 0;
  p->flags = (mode == PFM_AS) ? PF_ALLOCBUF : 0;
}
warning: parse error {
  p->length = length - 1; /* leave room for '\0' */
  p->holder = p->base = string;
  p->pf = format;
  p->counter = 0;
  p->flags = (mode == PFM_AS) ? PF_ALLOCBUF : 0;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\snprintf.c:1,201
warning: parse error STAR_ARGS(data)Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\snprintf.c:1,387
warning: parse error STAR_ARGS(data)Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\snprintf.c:1,387
warning: parse error d = GETDOUBLE(data);Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\snprintf.c:1,388
warning: parse error STAR_ARGS(data)Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\snprintf.c:1,395
warning: parse error STAR_ARGS(data)Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\snprintf.c:1,395
warning: parse error d = GETDOUBLE(data);Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\snprintf.c:1,397
warning: parse error STAR_ARGS(data)Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\snprintf.c:1,421
warning: parse error STAR_ARGS(data)Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\snprintf.c:1,421
warning: parse error d = GETDOUBLE(data);Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\snprintf.c:1,422
warning: parse error STAR_ARGS(data)Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\snprintf.c:1,440
warning: parse error STAR_ARGS(data)Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\snprintf.c:1,440
warning: parse error ul = GETUNSIGNED(data);Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\snprintf.c:1,450
warning: parse error STAR_ARGS(data)Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\snprintf.c:1,460
warning: parse error STAR_ARGS(data)Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\snprintf.c:1,460
warning: parse error ul = GETSIGNED(data);Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\snprintf.c:1,470
warning: parse error STAR_ARGS(data)Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\snprintf.c:1,476
warning: parse error STAR_ARGS(data)Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\snprintf.c:1,476
warning: parse error ul = GETUNSIGNED(data);Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\snprintf.c:1,486
warning: parse error STAR_ARGS(data)Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\snprintf.c:1,493
warning: parse error STAR_ARGS(data)Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\snprintf.c:1,493
warning: parse error ul = GETUNSIGNED(data);Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\snprintf.c:1,503
warning: parse error STAR_ARGS(data)Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\snprintf.c:1,509
warning: parse error STAR_ARGS(data)Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\snprintf.c:1,509
warning: parse error ul = (unsigned long)GETARG (void *);Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\snprintf.c:1,510
warning: parse error STAR_ARGS(data)Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\snprintf.c:1,520
warning: parse error STAR_ARGS(data)Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\snprintf.c:1,520
warning: parse error ul = GETARG (int);Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\snprintf.c:1,530
warning: parse error STAR_ARGS(data)Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\snprintf.c:1,541
warning: parse error STAR_ARGS(data)Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\snprintf.c:1,541
warning: parse error s = GETARG (char *);Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\snprintf.c:1,551
warning: parse error if (data->flags & PF_LONGINT)
		  *(GETARG (long *)) = data->counter;Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\snprintf.c:1,562
warning: parse error else if (data->flags & PF_SHORTINT)
		  *(GETARG (short *)) = data->counter;Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\snprintf.c:1,564
warning: parse error else
		  *(GETARG (int *)) = data->counter;Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\snprintf.c:1,566
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\snprintf.c:1,627
parsing error 
{
  register char *x;
  char fmtbuf[FALLBACK_FMTSIZE], obuf[FALLBACK_BASE];
  int fl;

  fl = fe - fs + 1;
  strncpy (fmtbuf, fs, fl);
  fmtbuf[fl] = '\0';

  if ((data->flags & PF_STAR_W) && (data->flags & PF_STAR_P))
    sprintf (obuf, fmtbuf, data->width, data->precision, d);
  else if (data->flags & PF_STAR_W)
    sprintf (obuf, fmtbuf, data->width, d);
  else if (data->flags & PF_STAR_P)
    sprintf (obuf, fmtbuf, data->precision, d);
  else
    sprintf (obuf, fmtbuf, d);

  for (x = obuf; *x; x++)
    PUT_CHAR (*x, data);    
}
warning: parse error {
  register char *x;
  char fmtbuf[FALLBACK_FMTSIZE], obuf[FALLBACK_BASE];
  int fl;

  fl = fe - fs + 1;
  strncpy (fmtbuf, fs, fl);
  fmtbuf[fl] = '\0';

  if ((data->flags & PF_STAR_W) && (data->flags & PF_STAR_P))
    sprintf (obuf, fmtbuf, data->width, data->precision, d);
  else if (data->flags & PF_STAR_W)
    sprintf (obuf, fmtbuf, data->width, d);
  else if (data->flags & PF_STAR_P)
    sprintf (obuf, fmtbuf, data->precision, d);
  else
    sprintf (obuf, fmtbuf, d);

  for (x = obuf; *x; x++)
    PUT_CHAR (*x, data);    
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\snprintf.c:1,631
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\snprintf.c:1,679
parsing error 
va_dcl
#endif
{
  struct DATA data;
  int rval;
  va_list args;

  SH_VA_START(args, format);

  if (string == 0 && length != 0)
    return 0;
  init_data (&data, string, length, format, PFM_SN);
  rval = vsnprintf_internal (&data, string, length, format, args);

  va_end(args);

  return rval;
}
warning: parse error va_dcl
#endif
{
  struct DATA data;
  int rval;
  va_list args;

  SH_VA_START(args, format);

  if (string == 0 && length != 0)
    return 0;
  init_data (&data, string, length, format, PFM_SN);
  rval = vsnprintf_internal (&data, string, length, format, args);

  va_end(args);

  return rval;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\snprintf.c:1,683
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\snprintf.c:1,731
parsing error 
va_dcl
#endif
{
  int rval;
  va_list args;

  SH_VA_START(args, format);

  rval = vasprintf (stringp, format, args);

  va_end(args);

  return rval;
}
warning: parse error va_dcl
#endif
{
  int rval;
  va_list args;

  SH_VA_START(args, format);

  rval = vasprintf (stringp, format, args);

  va_end(args);

  return rval;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\snprintf.c:1,734
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\spell.c...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\bashtypes.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\posixdir.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\posixstat.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\bashansi.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\maxpath.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\stdc.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\spell.c:62
parsing error 
{
  char *op, *np, *p;
  char guess[PATH_MAX + 1], best[PATH_MAX + 1];

  op = oldname;
  np = newname;
  for (;;)
    {
      while (*op == '/')    /* Skip slashes */
	*np++ = *op++;
      *np = '\0';

      if (*op == '\0')    /* Exact or corrected */
	{
	  /* `.' is rarely the right thing. */
	  if (oldname[1] == '\0' && newname[1] == '\0' &&
		oldname[0] != '.' && newname[0] == '.')
	    return -1;
	  return strcmp(oldname, newname) != 0;
	}

      /* Copy next component into guess */
      for (p = guess; *op != '/' && *op != '\0'; op++)
	if (p < guess + PATH_MAX)
	  *p++ = *op;
      *p = '\0';

      if (mindist(newname, guess, best) >= 3)
	return -1;  /* Hopeless */

      /*
       *  Add to end of newname
       */
      for (p = best; *np = *p++; np++)
	;
    }
}
warning: parse error {
  char *op, *np, *p;
  char guess[PATH_MAX + 1], best[PATH_MAX + 1];

  op = oldname;
  np = newname;
  for (;;)
    {
      while (*op == '/')    /* Skip slashes */
	*np++ = *op++;
      *np = '\0';

      if (*op == '\0')    /* Exact or corrected */
	{
	  /* `.' is rarely the right thing. */
	  if (oldname[1] == '\0' && newname[1] == '\0' &&
		oldname[0] != '.' && newname[0] == '.')
	    return -1;
	  return strcmp(oldname, newname) != 0;
	}

      /* Copy next component into guess */
      for (p = guess; *op != '/' && *op != '\0'; op++)
	if (p < guess + PATH_MAX)
	  *p++ = *op;
      *p = '\0';

      if (mindist(newname, guess, best) >= 3)
	return -1;  /* Hopeless */

      /*
       *  Add to end of newname
       */
      for (p = best; *np = *p++; np++)
	;
    }
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\spell.c:65
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\spell.c:107
parsing error 
{
  DIR *fd;
  struct dirent *dp;
  int dist, x;

  dist = 3;    /* Worst distance */
  if (*dir == '\0')
    dir = ".";

  if ((fd = opendir(dir)) == NULL)
    return dist;

  while ((dp = readdir(fd)) != NULL)
    {
      /*
       *  Look for a better guess.  If the new guess is as
       *  good as the current one, we take it.  This way,
       *  any single character match will be a better match
       *  than ".".
       */
      x = spdist(dp->d_name, guess);
      if (x <= dist && x != 3)
	{
	  strcpy(best, dp->d_name);
	  dist = x;
	  if (dist == 0)    /* Exact match */
	    break;
	}
    }
  (void)closedir(fd);

  /* Don't return `.' */
  if (best[0] == '.' && best[1] == '\0')
    dist = 3;
  return dist;
}
warning: parse error {
  DIR *fd;
  struct dirent *dp;
  int dist, x;

  dist = 3;    /* Worst distance */
  if (*dir == '\0')
    dir = ".";

  if ((fd = opendir(dir)) == NULL)
    return dist;

  while ((dp = readdir(fd)) != NULL)
    {
      /*
       *  Look for a better guess.  If the new guess is as
       *  good as the current one, we take it.  This way,
       *  any single character match will be a better match
       *  than ".".
       */
      x = spdist(dp->d_name, guess);
      if (x <= dist && x != 3)
	{
	  strcpy(best, dp->d_name);
	  dist = x;
	  if (dist == 0)    /* Exact match */
	    break;
	}
    }
  (void)closedir(fd);

  /* Don't return `.' */
  if (best[0] == '.' && best[1] == '\0')
    dist = 3;
  return dist;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\spell.c:111
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\spell.c:158
parsing error 
{
  while (*cur == *new)
    {
      if (*cur == '\0')
	return 0;    /* Exact match */
      cur++;
      new++;
    }

  if (*cur)
    {
      if (*new)
	{
	  if (cur[1] && new[1] && cur[0] == new[1] && cur[1] == new[0] && strcmp (cur + 2, new + 2) == 0)
	    return 1;  /* Transposition */

	  if (strcmp (cur + 1, new + 1) == 0)
	    return 2;  /* One character mismatch */
	}

      if (strcmp(&cur[1], &new[0]) == 0)
	return 2;    /* Extra character */
    }

  if (*new && strcmp(cur, new + 1) == 0)
    return 2;      /* Missing character */

  return 3;
}
warning: parse error {
  while (*cur == *new)
    {
      if (*cur == '\0')
	return 0;    /* Exact match */
      cur++;
      new++;
    }

  if (*cur)
    {
      if (*new)
	{
	  if (cur[1] && new[1] && cur[0] == new[1] && cur[1] == new[0] && strcmp (cur + 2, new + 2) == 0)
	    return 1;  /* Transposition */

	  if (strcmp (cur + 1, new + 1) == 0)
	    return 2;  /* One character mismatch */
	}

      if (strcmp(&cur[1], &new[0]) == 0)
	return 2;    /* Extra character */
    }

  if (*new && strcmp(cur, new + 1) == 0)
    return 2;      /* Missing character */

  return 3;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\spell.c:160
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\spell.c:191
parsing error 
{
  int n;
  char *guess;

  n = (strlen (dirname) * 3 + 1) / 2 + 1;
  guess = (char *)malloc (n);
  if (guess == 0)
    return 0;

  switch (spname (dirname, guess))
    {
    case -1:
    default:
      free (guess);
      return (char *)NULL;
    case 0:
    case 1:
      return guess;
    }
}
warning: parse error {
  int n;
  char *guess;

  n = (strlen (dirname) * 3 + 1) / 2 + 1;
  guess = (char *)malloc (n);
  if (guess == 0)
    return 0;

  switch (spname (dirname, guess))
    {
    case -1:
    default:
      free (guess);
      return (char *)NULL;
    case 0:
    case 1:
      return guess;
    }
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\spell.c:193
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\strcasecmp.c...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\stdc.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\bashansi.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\chartypes.h...skip
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\strcasecmp.c:33
parsing error 
{
  register const char *s1;
  register const char *s2;
  register int r;

  if (count <= 0 || (string1 == string2))
    return 0;

  s1 = string1;
  s2 = string2;
  do
    {
      if ((r = TOLOWER ((unsigned char) *s1) - TOLOWER ((unsigned char) *s2)) != 0)
	return r;
      if (*s1++ == '\0')
	break;
      s2++;
    }
  while (--count != 0);

  return (0);
}
warning: parse error {
  register const char *s1;
  register const char *s2;
  register int r;

  if (count <= 0 || (string1 == string2))
    return 0;

  s1 = string1;
  s2 = string2;
  do
    {
      if ((r = TOLOWER ((unsigned char) *s1) - TOLOWER ((unsigned char) *s2)) != 0)
	return r;
      if (*s1++ == '\0')
	break;
      s2++;
    }
  while (--count != 0);

  return (0);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\strcasecmp.c:36
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\strcasecmp.c:62
parsing error 
{
  register const char *s1;
  register const char *s2;
  register int r;

  s1 = string1;
  s2 = string2;

  if (s1 == s2)
    return (0);

  while ((r = TOLOWER ((unsigned char)*s1) - TOLOWER ((unsigned char)*s2)) == 0)
    {
      if (*s1++ == '\0')
	return 0;
      s2++;
    }

  return (r);
}
warning: parse error {
  register const char *s1;
  register const char *s2;
  register int r;

  s1 = string1;
  s2 = string2;

  if (s1 == s2)
    return (0);

  while ((r = TOLOWER ((unsigned char)*s1) - TOLOWER ((unsigned char)*s2)) == 0)
    {
      if (*s1++ == '\0')
	return 0;
      s2++;
    }

  return (r);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\strcasecmp.c:64
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\strcasestr.c...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\bashansi.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\chartypes.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\stdc.h...skip
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\strcasestr.c:34
parsing error 
{
  register int i, l, len, c;

  c = TOLOWER ((unsigned char)s2[0]);
  len = strlen (s1);
  l = strlen (s2);
  for (i = 0; (len - i) >= l; i++)
    if ((TOLOWER ((unsigned char)s1[i]) == c) && (strncasecmp (s1 + i, s2, l) == 0))
      return ((char *)s1 + i);
  return ((char *)0);
}
warning: parse error {
  register int i, l, len, c;

  c = TOLOWER ((unsigned char)s2[0]);
  len = strlen (s1);
  l = strlen (s2);
  for (i = 0; (len - i) >= l; i++)
    if ((TOLOWER ((unsigned char)s1[i]) == c) && (strncasecmp (s1 + i, s2, l) == 0))
      return ((char *)s1 + i);
  return ((char *)0);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\strcasestr.c:36
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\strchrnul.c...
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\strchrnul.c:32
parsing error 
{
  const unsigned char *char_ptr;
  const longword *longword_ptr;
  longword repeated_one;
  longword repeated_c;
  unsigned char c;

  c = (unsigned char) c_in;
  if (c == 0)		/* find final null byte */
    return (char *)(s ? (s + strlen (s)) : s);

  /* Handle the first few bytes by reading one byte at a time.
     Do this until CHAR_PTR is aligned on a longword boundary.  */
  for (char_ptr = (const unsigned char *) s;
       (size_t) char_ptr % sizeof (longword) != 0;
       ++char_ptr)
    if (!*char_ptr || *char_ptr == c)
      return (char *) char_ptr;

  longword_ptr = (const longword *) char_ptr;

  /* All these elucidatory comments refer to 4-byte longwords,
     but the theory applies equally well to any size longwords.  */

  /* Compute auxiliary longword values:
     repeated_one is a value which has a 1 in every byte.
     repeated_c has c in every byte.  */
  repeated_one = 0x01010101;
  repeated_c = c | (c << 8);
  repeated_c |= repeated_c << 16;
  if (0xffffffffU < (longword) -1)
    {
      repeated_one |= repeated_one << 31 << 1;
      repeated_c |= repeated_c << 31 << 1;
      if (8 < sizeof (longword))
        {
          size_t i;

          for (i = 64; i < sizeof (longword) * 8; i *= 2)
            {
              repeated_one |= repeated_one << i;
              repeated_c |= repeated_c << i;
            }
        }
    }

  /* Instead of the traditional loop which tests each byte, we will
     test a longword at a time.  The tricky part is testing if *any of
     the four* bytes in the longword in question are equal to NUL or
     c.  We first use an xor with repeated_c.  This reduces the task
     to testing whether *any of the four* bytes in longword1 or
     longword2 is zero.

     Let's consider longword1.  We compute tmp =
       ((longword1 - repeated_one) & ~longword1) & (repeated_one << 7).
     That is, we perform the following operations:
       1. Subtract repeated_one.
       2. & ~longword1.
       3. & a mask consisting of 0x80 in every byte.
     Consider what happens in each byte:
       - If a byte of longword1 is zero, step 1 and 2 transform it into 0xff,
         and step 3 transforms it into 0x80.  A carry can also be propagated
         to more significant bytes.
       - If a byte of longword1 is nonzero, let its lowest 1 bit be at
         position k (0 <= k <= 7); so the lowest k bits are 0.  After step 1,
         the byte ends in a single bit of value 0 and k bits of value 1.
         After step 2, the result is just k bits of value 1: 2^k - 1.  After
         step 3, the result is 0.  And no carry is produced.
     So, if longword1 has only non-zero bytes, tmp is zero.
     Whereas if longword1 has a zero byte, call j the position of the least
     significant zero byte.  Then the result has a zero at positions 0, ...,
     j-1 and a 0x80 at position j.  We cannot predict the result at the more
     significant bytes (positions j+1..3), but it does not matter since we
     already have a non-zero bit at position 8*j+7.

     The test whether any byte in longword1 or longword2 is zero is equivalent
     to testing whether tmp1 is nonzero or tmp2 is nonzero.  We can combine
     this into a single test, whether (tmp1 | tmp2) is nonzero.

     This test can read more than one byte beyond the end of a string,
     depending on where the terminating NUL is encountered.  However,
     this is considered safe since the initialization phase ensured
     that the read will be aligned, therefore, the read will not cross
     page boundaries and will not cause a fault.  */

  while (1)
    {
      longword longword1 = *longword_ptr ^ repeated_c;
      longword longword2 = *longword_ptr;

      if (((((longword1 - repeated_one) & ~longword1)
            | ((longword2 - repeated_one) & ~longword2))
           & (repeated_one << 7)) != 0)
        break;
      longword_ptr++;
    }

  char_ptr = (const unsigned char *) longword_ptr;

  /* At this point, we know that one of the sizeof (longword) bytes
     starting at char_ptr is == 0 or == c.  On little-endian machines,
     we could determine the first such byte without any further memory
     accesses, just by looking at the tmp result from the last loop
     iteration.  But this does not work on big-endian machines.
     Choose code that works in both cases.  */

  char_ptr = (unsigned char *) longword_ptr;
  while (*char_ptr && (*char_ptr != c))
    char_ptr++;
  return (char *) char_ptr;
}
warning: parse error {
  const unsigned char *char_ptr;
  const longword *longword_ptr;
  longword repeated_one;
  longword repeated_c;
  unsigned char c;

  c = (unsigned char) c_in;
  if (c == 0)		/* find final null byte */
    return (char *)(s ? (s + strlen (s)) : s);

  /* Handle the first few bytes by reading one byte at a time.
     Do this until CHAR_PTR is aligned on a longword boundary.  */
  for (char_ptr = (const unsigned char *) s;
       (size_t) char_ptr % sizeof (longword) != 0;
       ++char_ptr)
    if (!*char_ptr || *char_ptr == c)
      return (char *) char_ptr;

  longword_ptr = (const longword *) char_ptr;

  /* All these elucidatory comments refer to 4-byte longwords,
     but the theory applies equally well to any size longwords.  */

  /* Compute auxiliary longword values:
     repeated_one is a value which has a 1 in every byte.
     repeated_c has c in every byte.  */
  repeated_one = 0x01010101;
  repeated_c = c | (c << 8);
  repeated_c |= repeated_c << 16;
  if (0xffffffffU < (longword) -1)
    {
      repeated_one |= repeated_one << 31 << 1;
      repeated_c |= repeated_c << 31 << 1;
      if (8 < sizeof (longword))
        {
          size_t i;

          for (i = 64; i < sizeof (longword) * 8; i *= 2)
            {
              repeated_one |= repeated_one << i;
              repeated_c |= repeated_c << i;
            }
        }
    }

  /* Instead of the traditional loop which tests each byte, we will
     test a longword at a time.  The tricky part is testing if *any of
     the four* bytes in the longword in question are equal to NUL or
     c.  We first use an xor with repeated_c.  This reduces the task
     to testing whether *any of the four* bytes in longword1 or
     longword2 is zero.

     Let's consider longword1.  We compute tmp =
       ((longword1 - repeated_one) & ~longword1) & (repeated_one << 7).
     That is, we perform the following operations:
       1. Subtract repeated_one.
       2. & ~longword1.
       3. & a mask consisting of 0x80 in every byte.
     Consider what happens in each byte:
       - If a byte of longword1 is zero, step 1 and 2 transform it into 0xff,
         and step 3 transforms it into 0x80.  A carry can also be propagated
         to more significant bytes.
       - If a byte of longword1 is nonzero, let its lowest 1 bit be at
         position k (0 <= k <= 7); so the lowest k bits are 0.  After step 1,
         the byte ends in a single bit of value 0 and k bits of value 1.
         After step 2, the result is just k bits of value 1: 2^k - 1.  After
         step 3, the result is 0.  And no carry is produced.
     So, if longword1 has only non-zero bytes, tmp is zero.
     Whereas if longword1 has a zero byte, call j the position of the least
     significant zero byte.  Then the result has a zero at positions 0, ...,
     j-1 and a 0x80 at position j.  We cannot predict the result at the more
     significant bytes (positions j+1..3), but it does not matter since we
     already have a non-zero bit at position 8*j+7.

     The test whether any byte in longword1 or longword2 is zero is equivalent
     to testing whether tmp1 is nonzero or tmp2 is nonzero.  We can combine
     this into a single test, whether (tmp1 | tmp2) is nonzero.

     This test can read more than one byte beyond the end of a string,
     depending on where the terminating NUL is encountered.  However,
     this is considered safe since the initialization phase ensured
     that the read will be aligned, therefore, the read will not cross
     page boundaries and will not cause a fault.  */

  while (1)
    {
      longword longword1 = *longword_ptr ^ repeated_c;
      longword longword2 = *longword_ptr;

      if (((((longword1 - repeated_one) & ~longword1)
            | ((longword2 - repeated_one) & ~longword2))
           & (repeated_one << 7)) != 0)
        break;
      longword_ptr++;
    }

  char_ptr = (const unsigned char *) longword_ptr;

  /* At this point, we know that one of the sizeof (longword) bytes
     starting at char_ptr is == 0 or == c.  On little-endian machines,
     we could determine the first such byte without any further memory
     accesses, just by looking at the tmp result from the last loop
     iteration.  But this does not work on big-endian machines.
     Choose code that works in both cases.  */

  char_ptr = (unsigned char *) longword_ptr;
  while (*char_ptr && (*char_ptr != c))
    char_ptr++;
  return (char *) char_ptr;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\strchrnul.c:34
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\strerror.c...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\bashtypes.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\shell.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\strerror.c:52
parsing error 
{
  static char emsg[40];
#if defined (HAVE_SYS_ERRLIST)
  extern int sys_nerr;
  extern char *sys_errlist[];

  if (e > 0 && e < sys_nerr)
    return (sys_errlist[e]);
  else
#endif /* HAVE_SYS_ERRLIST */
    {
      char *z;

      z = itos (e);
      strcpy (emsg, errbase);
      strcat (emsg, z);
      free (z);
      return (&emsg[0]);
    }
}
warning: parse error {
  static char emsg[40];
#if defined (HAVE_SYS_ERRLIST)
  extern int sys_nerr;
  extern char *sys_errlist[];

  if (e > 0 && e < sys_nerr)
    return (sys_errlist[e]);
  else
#endif /* HAVE_SYS_ERRLIST */
    {
      char *z;

      z = itos (e);
      strcpy (emsg, errbase);
      strcat (emsg, z);
      free (z);
      return (&emsg[0]);
    }
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\strerror.c:54
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\strftime.c...
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\stringlist.c...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\bashansi.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\shell.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\stringlist.c:40
parsing error 
{
  STRINGLIST *ret;
  register int i;

  ret = (STRINGLIST *)xmalloc (sizeof (STRINGLIST));
  if (n)
    {
      ret->list = strvec_create (n+1);
      ret->list_size = n;
      for (i = 0; i < n; i++)
	ret->list[i] = (char *)NULL;
    }
  else
    {
      ret->list = (char **)NULL;
      ret->list_size = 0;
    }
  ret->list_len = 0;
  return ret;
}
warning: parse error {
  STRINGLIST *ret;
  register int i;

  ret = (STRINGLIST *)xmalloc (sizeof (STRINGLIST));
  if (n)
    {
      ret->list = strvec_create (n+1);
      ret->list_size = n;
      for (i = 0; i < n; i++)
	ret->list[i] = (char *)NULL;
    }
  else
    {
      ret->list = (char **)NULL;
      ret->list_size = 0;
    }
  ret->list_len = 0;
  return ret;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\stringlist.c:42
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\stringlist.c:64
parsing error 
{
  register int i;

  if (sl == 0)
    return (sl = strlist_create (n));

  if (n > sl->list_size)
    {
      sl->list = strvec_resize (sl->list, n + 1);
      for (i = sl->list_size; i <= n; i++)
	sl->list[i] = (char *)NULL;
      sl->list_size = n;
    }
  return sl;
}
warning: parse error {
  register int i;

  if (sl == 0)
    return (sl = strlist_create (n));

  if (n > sl->list_size)
    {
      sl->list = strvec_resize (sl->list, n + 1);
      for (i = sl->list_size; i <= n; i++)
	sl->list[i] = (char *)NULL;
      sl->list_size = n;
    }
  return sl;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\stringlist.c:67
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\stringlist.c:84
parsing error 
{
  if (sl == 0 || sl->list == 0)
    return;
  strvec_flush (sl->list);
  sl->list_len = 0;
}
warning: parse error {
  if (sl == 0 || sl->list == 0)
    return;
  strvec_flush (sl->list);
  sl->list_len = 0;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\stringlist.c:86
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\stringlist.c:94
parsing error 
{
  if (sl == 0)
    return;
  if (sl->list)
    strvec_dispose (sl->list);
  free (sl);
}
warning: parse error {
  if (sl == 0)
    return;
  if (sl->list)
    strvec_dispose (sl->list);
  free (sl);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\stringlist.c:96
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\stringlist.c:105
parsing error 
{
  int r;

  if (sl == 0 || sl->list == 0 || sl->list_len == 0)
    return 0;

  r = strvec_remove (sl->list, s);
  if (r)
    sl->list_len--;
  return r;
}
warning: parse error {
  int r;

  if (sl == 0 || sl->list == 0 || sl->list_len == 0)
    return 0;

  r = strvec_remove (sl->list, s);
  if (r)
    sl->list_len--;
  return r;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\stringlist.c:108
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\stringlist.c:121
parsing error 
{
  STRINGLIST *new;
  register int i;

  if (sl == 0)
    return ((STRINGLIST *)0);
  new = strlist_create (sl->list_size);
  /* I'd like to use strvec_copy, but that doesn't copy everything. */
  if (sl->list)
    {
      for (i = 0; i < sl->list_size; i++)
	new->list[i] = STRDUP (sl->list[i]);
    }
  new->list_size = sl->list_size;
  new->list_len = sl->list_len;
  /* just being careful */
  if (new->list)
    new->list[new->list_len] = (char *)NULL;
  return new;
}
warning: parse error {
  STRINGLIST *new;
  register int i;

  if (sl == 0)
    return ((STRINGLIST *)0);
  new = strlist_create (sl->list_size);
  /* I'd like to use strvec_copy, but that doesn't copy everything. */
  if (sl->list)
    {
      for (i = 0; i < sl->list_size; i++)
	new->list[i] = STRDUP (sl->list[i]);
    }
  new->list_size = sl->list_size;
  new->list_len = sl->list_len;
  /* just being careful */
  if (new->list)
    new->list[new->list_len] = (char *)NULL;
  return new;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\stringlist.c:123
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\stringlist.c:147
parsing error 
{
  STRINGLIST *sl;
  int i, n, l1, l2;

  l1 = m1 ? m1->list_len : 0;
  l2 = m2 ? m2->list_len : 0;

  sl = strlist_create (l1 + l2 + 1);
  for (i = n = 0; i < l1; i++, n++)
    sl->list[n] = STRDUP (m1->list[i]);
  for (i = 0; i < l2; i++, n++)
    sl->list[n] = STRDUP (m2->list[i]);
  sl->list_len = n;
  sl->list[n] = (char *)NULL;
  return (sl);
}
warning: parse error {
  STRINGLIST *sl;
  int i, n, l1, l2;

  l1 = m1 ? m1->list_len : 0;
  l2 = m2 ? m2->list_len : 0;

  sl = strlist_create (l1 + l2 + 1);
  for (i = n = 0; i < l1; i++, n++)
    sl->list[n] = STRDUP (m1->list[i]);
  for (i = 0; i < l2; i++, n++)
    sl->list[n] = STRDUP (m2->list[i]);
  sl->list_len = n;
  sl->list[n] = (char *)NULL;
  return (sl);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\stringlist.c:149
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\stringlist.c:168
parsing error 
{
  register int i, n, len1, len2;

  if (m1 == 0)
    return (m2 ? strlist_copy (m2) : (STRINGLIST *)0);

  len1 = m1->list_len;
  len2 = m2 ? m2->list_len : 0;

  if (len2)
    {
      m1 = strlist_resize (m1, len1 + len2 + 1);
      for (i = 0, n = len1; i < len2; i++, n++)
	m1->list[n] = STRDUP (m2->list[i]);
      m1->list[n] = (char *)NULL;
      m1->list_len = n;
    }

  return m1;
}
warning: parse error {
  register int i, n, len1, len2;

  if (m1 == 0)
    return (m2 ? strlist_copy (m2) : (STRINGLIST *)0);

  len1 = m1->list_len;
  len2 = m2 ? m2->list_len : 0;

  if (len2)
    {
      m1 = strlist_resize (m1, len1 + len2 + 1);
      for (i = 0, n = len1; i < len2; i++, n++)
	m1->list[n] = STRDUP (m2->list[i]);
      m1->list[n] = (char *)NULL;
      m1->list_len = n;
    }

  return m1;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\stringlist.c:170
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\stringlist.c:192
parsing error 
{
  int plen, slen, tlen, llen, i;
  char *t;

  if (sl == 0 || sl->list == 0 || sl->list_len == 0)
    return sl;

  plen = STRLEN (prefix);
  slen = STRLEN (suffix);

  if (plen == 0 && slen == 0)
    return (sl);

  for (i = 0; i < sl->list_len; i++)
    {
      llen = STRLEN (sl->list[i]);
      tlen = plen + llen + slen + 1;
      t = (char *)xmalloc (tlen + 1);
      if (plen)
	strcpy (t, prefix);
      strcpy (t + plen, sl->list[i]);
      if (slen)
	strcpy (t + plen + llen, suffix);
      free (sl->list[i]);
      sl->list[i] = t;
    }

  return (sl);	 
}
warning: parse error {
  int plen, slen, tlen, llen, i;
  char *t;

  if (sl == 0 || sl->list == 0 || sl->list_len == 0)
    return sl;

  plen = STRLEN (prefix);
  slen = STRLEN (suffix);

  if (plen == 0 && slen == 0)
    return (sl);

  for (i = 0; i < sl->list_len; i++)
    {
      llen = STRLEN (sl->list[i]);
      tlen = plen + llen + slen + 1;
      t = (char *)xmalloc (tlen + 1);
      if (plen)
	strcpy (t, prefix);
      strcpy (t + plen, sl->list[i]);
      if (slen)
	strcpy (t + plen + llen, suffix);
      free (sl->list[i]);
      sl->list[i] = t;
    }

  return (sl);	 
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\stringlist.c:195
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\stringlist.c:226
parsing error 
{
  register int i;

  if (sl == 0)
    return;
  for (i = 0; i < sl->list_len; i++)
    printf ("%s%s\n", prefix ? prefix : "", sl->list[i]);
}
warning: parse error {
  register int i;

  if (sl == 0)
    return;
  for (i = 0; i < sl->list_len; i++)
    printf ("%s%s\n", prefix ? prefix : "", sl->list[i]);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\stringlist.c:229
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\stringlist.c:239
parsing error 
{
  register int i;

  if (sl == 0)
    return;
  for (i = 0; i < sl->list_len; i++)
    if ((*func)(sl->list[i]) < 0)
      break;
}
warning: parse error {
  register int i;

  if (sl == 0)
    return;
  for (i = 0; i < sl->list_len; i++)
    if ((*func)(sl->list[i]) < 0)
      break;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\stringlist.c:242
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\stringlist.c:253
parsing error 
{
  if (sl == 0 || sl->list_len == 0 || sl->list == 0)
    return;
  strvec_sort (sl->list);
}
warning: parse error {
  if (sl == 0 || sl->list_len == 0 || sl->list == 0)
    return;
  strvec_sort (sl->list);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\stringlist.c:255
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\stringlist.c:262
parsing error 
{
  STRINGLIST *ret;
  int slen, len;

  if (list == 0)
    {
      if (ip)
        *ip = 0;
      return ((STRINGLIST *)0);
    }
  slen = list_length (list);
  ret = (STRINGLIST *)xmalloc (sizeof (STRINGLIST));
  ret->list = strvec_from_word_list (list, alloc, starting_index, &len);
  ret->list_size = slen + starting_index;
  ret->list_len = len;
  if (ip)
    *ip = len;
  return ret;
}
warning: parse error {
  STRINGLIST *ret;
  int slen, len;

  if (list == 0)
    {
      if (ip)
        *ip = 0;
      return ((STRINGLIST *)0);
    }
  slen = list_length (list);
  ret = (STRINGLIST *)xmalloc (sizeof (STRINGLIST));
  ret->list = strvec_from_word_list (list, alloc, starting_index, &len);
  ret->list_size = slen + starting_index;
  ret->list_len = len;
  if (ip)
    *ip = len;
  return ret;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\stringlist.c:265
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\stringlist.c:286
parsing error 
{
  WORD_LIST *list;

  if (sl == 0 || sl->list == 0)
    return ((WORD_LIST *)NULL);

  list = strvec_to_word_list (sl->list, alloc, starting_index);
  return list;
}
warning: parse error {
  WORD_LIST *list;

  if (sl == 0 || sl->list == 0)
    return ((WORD_LIST *)NULL);

  list = strvec_to_word_list (sl->list, alloc, starting_index);
  return list;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\stringlist.c:289
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\stringvec.c...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\bashtypes.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\bashansi.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\chartypes.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\shell.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\stringvec.c:37
parsing error 
{
  return ((char **)xmalloc ((n) * sizeof (char *)));
}
warning: parse error {
  return ((char **)xmalloc ((n) * sizeof (char *)));
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\stringvec.c:39
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\stringvec.c:44
parsing error 
{
  return ((char **)xrealloc (array, nsize * sizeof (char *)));
}
warning: parse error {
  return ((char **)xrealloc (array, nsize * sizeof (char *)));
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\stringvec.c:47
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\stringvec.c:53
parsing error 
{
  register int i;

  for (i = 0; array[i]; i++);
  return (i);
}
warning: parse error {
  register int i;

  for (i = 0; array[i]; i++);
  return (i);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\stringvec.c:55
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\stringvec.c:64
parsing error 
{
  register int i;

  if (array == 0)
    return;

  for (i = 0; array[i]; i++)
    free (array[i]);
}
warning: parse error {
  register int i;

  if (array == 0)
    return;

  for (i = 0; array[i]; i++)
    free (array[i]);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\stringvec.c:66
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\stringvec.c:77
parsing error 
{
  if (array == 0)
    return;

  strvec_flush (array);
  free (array);
}
warning: parse error {
  if (array == 0)
    return;

  strvec_flush (array);
  free (array);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\stringvec.c:79
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\stringvec.c:88
parsing error 
{
  register int i, j;
  char *x;

  if (array == 0)
    return 0;

  for (i = 0; array[i]; i++)
    if (STREQ (name, array[i]))
      {
	x = array[i];
	for (j = i; array[j]; j++)
	  array[j] = array[j + 1];
	free (x);
	return 1;
      }
  return 0;
}
warning: parse error {
  register int i, j;
  char *x;

  if (array == 0)
    return 0;

  for (i = 0; array[i]; i++)
    if (STREQ (name, array[i]))
      {
	x = array[i];
	for (j = i; array[j]; j++)
	  array[j] = array[j + 1];
	free (x);
	return 1;
      }
  return 0;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\stringvec.c:90
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\stringvec.c:128
parsing error 
{
  register int i;
  int len;
  char **ret;

  len = strvec_len (array);

  ret = (char **)xmalloc ((len + 1) * sizeof (char *));
  for (i = 0; array[i]; i++)
    ret[i] = savestring (array[i]);
  ret[i] = (char *)NULL;

  return (ret);
}
warning: parse error {
  register int i;
  int len;
  char **ret;

  len = strvec_len (array);

  ret = (char **)xmalloc ((len + 1) * sizeof (char *));
  for (i = 0; array[i]; i++)
    ret[i] = savestring (array[i]);
  ret[i] = (char *)NULL;

  return (ret);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\stringvec.c:130
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\stringvec.c:148
parsing error 
{
#if defined (HAVE_STRCOLL)
   return (strcoll (*s1, *s2));
#else /* !HAVE_STRCOLL */
  int result;

  if ((result = **s1 - **s2) == 0)
    result = strcmp (*s1, *s2);

  return (result);
#endif /* !HAVE_STRCOLL */
}
warning: parse error {
#if defined (HAVE_STRCOLL)
   return (strcoll (*s1, *s2));
#else /* !HAVE_STRCOLL */
  int result;

  if ((result = **s1 - **s2) == 0)
    result = strcmp (*s1, *s2);

  return (result);
#endif /* !HAVE_STRCOLL */
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\stringvec.c:150
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\stringvec.c:165
parsing error 
{
  qsort (array, strvec_len (array), sizeof (char *), (QSFUNC *)strvec_strcmp);
}
warning: parse error {
  qsort (array, strvec_len (array), sizeof (char *), (QSFUNC *)strvec_strcmp);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\stringvec.c:167
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\stringvec.c:180
parsing error 
{
  int count;
  char **array;

  count = list_length (list);
  array = (char **)xmalloc ((1 + count + starting_index) * sizeof (char *));

  for (count = 0; count < starting_index; count++)
    array[count] = (char *)NULL;
  for (count = starting_index; list; count++, list = list->next)
    array[count] = alloc ? savestring (list->word->word) : list->word->word;
  array[count] = (char *)NULL;

  if (ip)
    *ip = count;
  return (array);
}
warning: parse error {
  int count;
  char **array;

  count = list_length (list);
  array = (char **)xmalloc ((1 + count + starting_index) * sizeof (char *));

  for (count = 0; count < starting_index; count++)
    array[count] = (char *)NULL;
  for (count = starting_index; list; count++, list = list->next)
    array[count] = alloc ? savestring (list->word->word) : list->word->word;
  array[count] = (char *)NULL;

  if (ip)
    *ip = count;
  return (array);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\stringvec.c:183
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\stringvec.c:207
parsing error 
{
  WORD_LIST *list;
  WORD_DESC *w;
  int i, count;

  if (array == 0 || array[0] == 0)
    return (WORD_LIST *)NULL;

  for (count = 0; array[count]; count++)
    ;

  for (i = starting_index, list = (WORD_LIST *)NULL; i < count; i++)
    {
      w = make_bare_word (alloc ? array[i] : "");
      if (alloc == 0)
	{
	  free (w->word);
	  w->word = array[i];
	}
      list = make_word_list (w, list);
    }
  return (REVERSE_LIST (list, WORD_LIST *));
}
warning: parse error {
  WORD_LIST *list;
  WORD_DESC *w;
  int i, count;

  if (array == 0 || array[0] == 0)
    return (WORD_LIST *)NULL;

  for (count = 0; array[count]; count++)
    ;

  for (i = starting_index, list = (WORD_LIST *)NULL; i < count; i++)
    {
      w = make_bare_word (alloc ? array[i] : "");
      if (alloc == 0)
	{
	  free (w->word);
	  w->word = array[i];
	}
      list = make_word_list (w, list);
    }
  return (REVERSE_LIST (list, WORD_LIST *));
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\stringvec.c:210
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\strnlen.c...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\stdc.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\strnlen.c:38
parsing error 
{
  register const char *e;
  size_t n;

  for (e = s, n = 0; *e && n < maxlen; e++, n++)
    ;
  return n;
}
warning: parse error {
  register const char *e;
  size_t n;

  for (e = s, n = 0; *e && n < maxlen; e++, n++)
    ;
  return n;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\strnlen.c:41
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\strpbrk.c...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\stdc.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\strpbrk.c:34
parsing error 
{
  while (*s != '\0')
    {
      const char *a = accept;
      while (*a != '\0')
	if (*a++ == *s)
	  return (char *) s;
      ++s;
    }

  return 0;
}
warning: parse error {
  while (*s != '\0')
    {
      const char *a = accept;
      while (*a != '\0')
	if (*a++ == *s)
	  return (char *) s;
      ++s;
    }

  return 0;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\strpbrk.c:37
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\strstr.c...
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\strtod.c...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\chartypes.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\bashansi.h...skip
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\strtod.c:56
parsing error 
{
  register const char *s;
  short sign;

  /* The number so far.  */
  double num;

  int got_dot;			/* Found a decimal point.  */
  int got_digit;		/* Seen any digits.  */

  /* The exponent of the number.  */
  long int exponent;

  if (nptr == NULL)
    {
      errno = EINVAL;
      goto noconv;
    }

  s = nptr;

  /* Eat whitespace.  */
  while (ISSPACE ((unsigned char)*s))
    ++s;

  /* Get the sign.  */
  sign = *s == '-' ? -1 : 1;
  if (*s == '-' || *s == '+')
    ++s;

  num = 0.0;
  got_dot = 0;
  got_digit = 0;
  exponent = 0;
  for (;; ++s)
    {
      if (DIGIT (*s))
	{
	  got_digit = 1;

	  /* Make sure that multiplication by 10 will not overflow.  */
	  if (num > DBL_MAX * 0.1)
	    /* The value of the digit doesn't matter, since we have already
	       gotten as many digits as can be represented in a `double'.
	       This doesn't necessarily mean the result will overflow.
	       The exponent may reduce it to within range.

	       We just need to record that there was another
	       digit so that we can multiply by 10 later.  */
	    ++exponent;
	  else
	    num = (num * 10.0) + (*s - '0');

	  /* Keep track of the number of digits after the decimal point.
	     If we just divided by 10 here, we would lose precision.  */
	  if (got_dot)
	    --exponent;
	}
      else if (!got_dot && *s == '.')
	/* Record that we have found the decimal point.  */
	got_dot = 1;
      else
	/* Any other character terminates the number.  */
	break;
    }

  if (!got_digit)
    goto noconv;

  if (TOLOWER ((unsigned char)*s) == 'e')
    {
      /* Get the exponent specified after the `e' or `E'.  */
      int save = errno;
      char *end;
      long int exp;

      errno = 0;
      ++s;
      exp = strtol (s, &end, 10);
      if (errno == ERANGE)
	{
	  /* The exponent overflowed a `long int'.  It is probably a safe
	     assumption that an exponent that cannot be represented by
	     a `long int' exceeds the limits of a `double'.  */
	  if (endptr != NULL)
	    *endptr = end;
	  if (exp < 0)
	    goto underflow;
	  else
	    goto overflow;
	}
      else if (end == s)
	/* There was no exponent.  Reset END to point to
	   the 'e' or 'E', so *ENDPTR will be set there.  */
	end = (char *) s - 1;
      errno = save;
      s = end;
      exponent += exp;
    }

  if (endptr != NULL)
    *endptr = (char *) s;

  if (num == 0.0)
    return 0.0;

  /* Multiply NUM by 10 to the EXPONENT power,
     checking for overflow and underflow.  */

  if (exponent < 0)
    {
      if (num < DBL_MIN * pow (10.0, (double) -exponent))
	goto underflow;
    }
  else if (exponent > 0)
    {
      if (num > DBL_MAX * pow (10.0, (double) -exponent))
	goto overflow;
    }

  num *= pow (10.0, (double) exponent);

  return num * sign;

overflow:
  /* Return an overflow error.  */
  errno = ERANGE;
  return HUGE_VAL * sign;

underflow:
  /* Return an underflow error.  */
  if (endptr != NULL)
    *endptr = (char *) nptr;
  errno = ERANGE;
  return 0.0;

noconv:
  /* There was no number.  */
  if (endptr != NULL)
    *endptr = (char *) nptr;
  return 0.0;
}
warning: parse error {
  register const char *s;
  short sign;

  /* The number so far.  */
  double num;

  int got_dot;			/* Found a decimal point.  */
  int got_digit;		/* Seen any digits.  */

  /* The exponent of the number.  */
  long int exponent;

  if (nptr == NULL)
    {
      errno = EINVAL;
      goto noconv;
    }

  s = nptr;

  /* Eat whitespace.  */
  while (ISSPACE ((unsigned char)*s))
    ++s;

  /* Get the sign.  */
  sign = *s == '-' ? -1 : 1;
  if (*s == '-' || *s == '+')
    ++s;

  num = 0.0;
  got_dot = 0;
  got_digit = 0;
  exponent = 0;
  for (;; ++s)
    {
      if (DIGIT (*s))
	{
	  got_digit = 1;

	  /* Make sure that multiplication by 10 will not overflow.  */
	  if (num > DBL_MAX * 0.1)
	    /* The value of the digit doesn't matter, since we have already
	       gotten as many digits as can be represented in a `double'.
	       This doesn't necessarily mean the result will overflow.
	       The exponent may reduce it to within range.

	       We just need to record that there was another
	       digit so that we can multiply by 10 later.  */
	    ++exponent;
	  else
	    num = (num * 10.0) + (*s - '0');

	  /* Keep track of the number of digits after the decimal point.
	     If we just divided by 10 here, we would lose precision.  */
	  if (got_dot)
	    --exponent;
	}
      else if (!got_dot && *s == '.')
	/* Record that we have found the decimal point.  */
	got_dot = 1;
      else
	/* Any other character terminates the number.  */
	break;
    }

  if (!got_digit)
    goto noconv;

  if (TOLOWER ((unsigned char)*s) == 'e')
    {
      /* Get the exponent specified after the `e' or `E'.  */
      int save = errno;
      char *end;
      long int exp;

      errno = 0;
      ++s;
      exp = strtol (s, &end, 10);
      if (errno == ERANGE)
	{
	  /* The exponent overflowed a `long int'.  It is probably a safe
	     assumption that an exponent that cannot be represented by
	     a `long int' exceeds the limits of a `double'.  */
	  if (endptr != NULL)
	    *endptr = end;
	  if (exp < 0)
	    goto underflow;
	  else
	    goto overflow;
	}
      else if (end == s)
	/* There was no exponent.  Reset END to point to
	   the 'e' or 'E', so *ENDPTR will be set there.  */
	end = (char *) s - 1;
      errno = save;
      s = end;
      exponent += exp;
    }

  if (endptr != NULL)
    *endptr = (char *) s;

  if (num == 0.0)
    return 0.0;

  /* Multiply NUM by 10 to the EXPONENT power,
     checking for overflow and underflow.  */

  if (exponent < 0)
    {
      if (num < DBL_MIN * pow (10.0, (double) -exponent))
	goto underflow;
    }
  else if (exponent > 0)
    {
      if (num > DBL_MAX * pow (10.0, (double) -exponent))
	goto overflow;
    }

  num *= pow (10.0, (double) exponent);

  return num * sign;

overflow:
  /* Return an overflow error.  */
  errno = ERANGE;
  return HUGE_VAL * sign;

underflow:
  /* Return an underflow error.  */
  if (endptr != NULL)
    *endptr = (char *) nptr;
  errno = ERANGE;
  return 0.0;

noconv:
  /* There was no number.  */
  if (endptr != NULL)
    *endptr = (char *) nptr;
  return 0.0;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\strtod.c:58
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\strtoimax.c...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\stdc.h...skip
parsing error 
"this configure-time declaration test was not run"
#endif
#if !HAVE_DECL_STRTOL
extern long strtol __P((const char *, char **, int));
warning: parse error "this configure-time declaration test was not run"
#endif
#if !HAVE_DECL_STRTOL
extern long strtol __P((const char *, char **, int));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\strtoimax.c:45
parsing error 
"this configure-time declaration test was not run"
#endif
#if !HAVE_DECL_STRTOLL && HAVE_LONG_LONG
extern long long strtoll __P((const char *, char **, int));
#endif

#ifdef strtoimax
#undef strtoimax
#endif

intmax_t
strtoimax (ptr, endptr, base)
     const char *ptr;
warning: parse error "this configure-time declaration test was not run"
#endif
#if !HAVE_DECL_STRTOLL && HAVE_LONG_LONG
extern long long strtoll __P((const char *, char **, int));
#endif

#ifdef strtoimax
#undef strtoimax
#endif

intmax_t
strtoimax (ptr, endptr, base)
     const char *ptr;Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\strtoimax.c:52
parsing error 
{
#if HAVE_LONG_LONG
  verify(size_is_that_of_long_or_long_long,
	 (sizeof (intmax_t) == sizeof (long) ||
	  sizeof (intmax_t) == sizeof (long long)));

  if (sizeof (intmax_t) != sizeof (long))
    return (strtoll (ptr, endptr, base));
#else
  verify (size_is_that_of_long, sizeof (intmax_t) == sizeof (long));
#endif

  return (strtol (ptr, endptr, base));
}
warning: parse error {
#if HAVE_LONG_LONG
  verify(size_is_that_of_long_or_long_long,
	 (sizeof (intmax_t) == sizeof (long) ||
	  sizeof (intmax_t) == sizeof (long long)));

  if (sizeof (intmax_t) != sizeof (long))
    return (strtoll (ptr, endptr, base));
#else
  verify (size_is_that_of_long, sizeof (intmax_t) == sizeof (long));
#endif

  return (strtol (ptr, endptr, base));
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\strtoimax.c:67
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\strtol.c...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\chartypes.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\typemax.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\stdc.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\bashansi.h...skip
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\strtol.c:94
parsing error 
{
  int negative;
  register unsigned LONG int cutoff;
  register unsigned int cutlim;
  register unsigned LONG int i;
  register const char *s;
  register unsigned char c;
  const char *save, *end;
  int overflow;

  if (base < 0 || base == 1 || base > 36)
    {
      __set_errno (EINVAL);
      return 0;
    }

  save = s = nptr;

  /* Skip white space.  */
  while (ISSPACE ((unsigned char)*s))
    ++s;
  if (*s == '\0')
    goto noconv;

  /* Check for a sign.  */
  if (*s == '-' || *s == '+')
    {
      negative = (*s == '-');
      ++s;
    }
  else
    negative = 0;

  /* Recognize number prefix and if BASE is zero, figure it out ourselves.  */
  if (*s == '0')
    {
      if ((base == 0 || base == 16) && TOUPPER ((unsigned char) s[1]) == 'X')
	{
	  s += 2;
	  base = 16;
	}
      else if (base == 0)
	base = 8;
    }
  else if (base == 0)
    base = 10;

  /* Save the pointer so we can check later if anything happened.  */
  save = s;

  end = NULL;

  cutoff = STRTOL_ULONG_MAX / (unsigned LONG int) base;
  cutlim = STRTOL_ULONG_MAX % (unsigned LONG int) base;

  overflow = 0;
  i = 0;
  c = *s;
  if (sizeof (long int) != sizeof (LONG int))
    {
      unsigned long int j = 0;
      unsigned long int jmax = ULONG_MAX / base;

      for (;c != '\0'; c = *++s)
	{
	  if (s == end)
	    break;
	  if (DIGIT (c))
	    c -= '0';
	  else if (ISALPHA (c))
	    c = TOUPPER (c) - 'A' + 10;
	  else
	    break;

	  if ((int) c >= base)
	    break;
	  /* Note that we never can have an overflow.  */
	  else if (j >= jmax)
	    {
	      /* We have an overflow.  Now use the long representation.  */
	      i = (unsigned LONG int) j;
	      goto use_long;
	    }
	  else
	    j = j * (unsigned long int) base + c;
	}

      i = (unsigned LONG int) j;
    }
  else
    for (;c != '\0'; c = *++s)
      {
	if (s == end)
	  break;
	if (DIGIT (c))
	  c -= '0';
	else if (ISALPHA (c))
	  c = TOUPPER (c) - 'A' + 10;
	else
	  break;
	if ((int) c >= base)
	  break;
	/* Check for overflow.  */
	if (i > cutoff || (i == cutoff && c > cutlim))
	  overflow = 1;
	else
	  {
	  use_long:
	    i *= (unsigned LONG int) base;
	    i += c;
	  }
      }

  /* Check if anything actually happened.  */
  if (s == save)
    goto noconv;

  /* Store in ENDPTR the address of one character
     past the last character we converted.  */
  if (endptr != NULL)
    *endptr = (char *) s;

#if !UNSIGNED
  /* Check for a value that is within the range of
     `unsigned LONG int', but outside the range of `LONG int'.  */
  if (overflow == 0
      && i > (negative
	      ? -((unsigned LONG int) (STRTOL_LONG_MIN + 1)) + 1
	      : (unsigned LONG int) STRTOL_LONG_MAX))
    overflow = 1;
#endif

  if (overflow)
    {
      __set_errno (ERANGE);
#if UNSIGNED
      return STRTOL_ULONG_MAX;
#else
      return negative ? STRTOL_LONG_MIN : STRTOL_LONG_MAX;
#endif
    }

  /* Return the result of the appropriate sign.  */
  return negative ? -i : i;

noconv:
  /* We must handle a special case here: the base is 0 or 16 and the
     first two characters are '0' and 'x', but the rest are no
     hexadecimal digits.  This is no error case.  We return 0 and
     ENDPTR points to the `x`.  */
  if (endptr != NULL)
    {
      if (save - nptr >= 2 && TOUPPER ((unsigned char) save[-1]) == 'X' && save[-2] == '0')
	*endptr = (char *) &save[-1];
      else
	/*  There was no number to convert.  */
	*endptr = (char *) nptr;
    }

  return 0L;
}
warning: parse error {
  int negative;
  register unsigned LONG int cutoff;
  register unsigned int cutlim;
  register unsigned LONG int i;
  register const char *s;
  register unsigned char c;
  const char *save, *end;
  int overflow;

  if (base < 0 || base == 1 || base > 36)
    {
      __set_errno (EINVAL);
      return 0;
    }

  save = s = nptr;

  /* Skip white space.  */
  while (ISSPACE ((unsigned char)*s))
    ++s;
  if (*s == '\0')
    goto noconv;

  /* Check for a sign.  */
  if (*s == '-' || *s == '+')
    {
      negative = (*s == '-');
      ++s;
    }
  else
    negative = 0;

  /* Recognize number prefix and if BASE is zero, figure it out ourselves.  */
  if (*s == '0')
    {
      if ((base == 0 || base == 16) && TOUPPER ((unsigned char) s[1]) == 'X')
	{
	  s += 2;
	  base = 16;
	}
      else if (base == 0)
	base = 8;
    }
  else if (base == 0)
    base = 10;

  /* Save the pointer so we can check later if anything happened.  */
  save = s;

  end = NULL;

  cutoff = STRTOL_ULONG_MAX / (unsigned LONG int) base;
  cutlim = STRTOL_ULONG_MAX % (unsigned LONG int) base;

  overflow = 0;
  i = 0;
  c = *s;
  if (sizeof (long int) != sizeof (LONG int))
    {
      unsigned long int j = 0;
      unsigned long int jmax = ULONG_MAX / base;

      for (;c != '\0'; c = *++s)
	{
	  if (s == end)
	    break;
	  if (DIGIT (c))
	    c -= '0';
	  else if (ISALPHA (c))
	    c = TOUPPER (c) - 'A' + 10;
	  else
	    break;

	  if ((int) c >= base)
	    break;
	  /* Note that we never can have an overflow.  */
	  else if (j >= jmax)
	    {
	      /* We have an overflow.  Now use the long representation.  */
	      i = (unsigned LONG int) j;
	      goto use_long;
	    }
	  else
	    j = j * (unsigned long int) base + c;
	}

      i = (unsigned LONG int) j;
    }
  else
    for (;c != '\0'; c = *++s)
      {
	if (s == end)
	  break;
	if (DIGIT (c))
	  c -= '0';
	else if (ISALPHA (c))
	  c = TOUPPER (c) - 'A' + 10;
	else
	  break;
	if ((int) c >= base)
	  break;
	/* Check for overflow.  */
	if (i > cutoff || (i == cutoff && c > cutlim))
	  overflow = 1;
	else
	  {
	  use_long:
	    i *= (unsigned LONG int) base;
	    i += c;
	  }
      }

  /* Check if anything actually happened.  */
  if (s == save)
    goto noconv;

  /* Store in ENDPTR the address of one character
     past the last character we converted.  */
  if (endptr != NULL)
    *endptr = (char *) s;

#if !UNSIGNED
  /* Check for a value that is within the range of
     `unsigned LONG int', but outside the range of `LONG int'.  */
  if (overflow == 0
      && i > (negative
	      ? -((unsigned LONG int) (STRTOL_LONG_MIN + 1)) + 1
	      : (unsigned LONG int) STRTOL_LONG_MAX))
    overflow = 1;
#endif

  if (overflow)
    {
      __set_errno (ERANGE);
#if UNSIGNED
      return STRTOL_ULONG_MAX;
#else
      return negative ? STRTOL_LONG_MIN : STRTOL_LONG_MAX;
#endif
    }

  /* Return the result of the appropriate sign.  */
  return negative ? -i : i;

noconv:
  /* We must handle a special case here: the base is 0 or 16 and the
     first two characters are '0' and 'x', but the rest are no
     hexadecimal digits.  This is no error case.  We return 0 and
     ENDPTR points to the `x`.  */
  if (endptr != NULL)
    {
      if (save - nptr >= 2 && TOUPPER ((unsigned char) save[-1]) == 'X' && save[-2] == '0')
	*endptr = (char *) &save[-1];
      else
	/*  There was no number to convert.  */
	*endptr = (char *) nptr;
    }

  return 0L;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\strtol.c:97
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\strtoll.c...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\strtol.c...skip
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\strtoul.c...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\strtol.c...skip
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\strtoull.c...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\strtol.c...skip
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\strtoumax.c...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\stdc.h...skip
parsing error 
"this configure-time declaration test was not run"
#endif
#if !HAVE_DECL_STRTOUL
extern unsigned long strtoul __P((const char *, char **, int));
warning: parse error "this configure-time declaration test was not run"
#endif
#if !HAVE_DECL_STRTOUL
extern unsigned long strtoul __P((const char *, char **, int));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\strtoumax.c:45
parsing error 
"this configure-time declaration test was not run"
#endif
#if !HAVE_DECL_STRTOULL && HAVE_UNSIGNED_LONG_LONG
extern unsigned long long strtoull __P((const char *, char **, int));
#endif

#ifdef strtoumax
#undef strtoumax
#endif

uintmax_t
strtoumax (ptr, endptr, base)
     const char *ptr;
warning: parse error "this configure-time declaration test was not run"
#endif
#if !HAVE_DECL_STRTOULL && HAVE_UNSIGNED_LONG_LONG
extern unsigned long long strtoull __P((const char *, char **, int));
#endif

#ifdef strtoumax
#undef strtoumax
#endif

uintmax_t
strtoumax (ptr, endptr, base)
     const char *ptr;Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\strtoumax.c:52
parsing error 
{
#if HAVE_UNSIGNED_LONG_LONG
  verify (size_is_that_of_unsigned_long_or_unsigned_long_long,
	  (sizeof (uintmax_t) == sizeof (unsigned long) ||
	   sizeof (uintmax_t) == sizeof (unsigned long long)));

  if (sizeof (uintmax_t) != sizeof (unsigned long))
    return (strtoull (ptr, endptr, base));
#else
  verify (size_is_that_of_unsigned_long, sizeof (uintmax_t) == sizeof (unsigned long));
#endif

  return (strtoul (ptr, endptr, base));
}
warning: parse error {
#if HAVE_UNSIGNED_LONG_LONG
  verify (size_is_that_of_unsigned_long_or_unsigned_long_long,
	  (sizeof (uintmax_t) == sizeof (unsigned long) ||
	   sizeof (uintmax_t) == sizeof (unsigned long long)));

  if (sizeof (uintmax_t) != sizeof (unsigned long))
    return (strtoull (ptr, endptr, base));
#else
  verify (size_is_that_of_unsigned_long, sizeof (uintmax_t) == sizeof (unsigned long));
#endif

  return (strtoul (ptr, endptr, base));
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\strtoumax.c:67
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\strtrans.c...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\bashansi.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\chartypes.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\shell.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\strtrans.c:48
parsing error 
{
  int c, temp;
  char *ret, *r, *s;
  unsigned long v;

  if (string == 0 || *string == '\0')
    return ((char *)NULL);

#if defined (HANDLE_MULTIBYTE)
  ret = (char *)xmalloc (4*len + 1);
#else
  ret = (char *)xmalloc (2*len + 1);	/* 2*len for possible CTLESC */
#endif
  for (r = ret, s = string; s && *s; )
    {
      c = *s++;
      if (c != '\\' || *s == '\0')
	*r++ = c;
      else
	{
	  switch (c = *s++)
	    {
#if defined (__STDC__)
	    case 'a': c = '\a'; break;
	    case 'v': c = '\v'; break;
#else
	    case 'a': c = '\007'; break;
	    case 'v': c = (int) 0x0B; break;
#endif
	    case 'b': c = '\b'; break;
	    case 'e': case 'E':		/* ESC -- non-ANSI */
	      c = ESC; break;
	    case 'f': c = '\f'; break;
	    case 'n': c = '\n'; break;
	    case 'r': c = '\r'; break;
	    case 't': c = '\t'; break;
	    case '1': case '2': case '3':
	    case '4': case '5': case '6':
	    case '7':
#if 1
	      if (flags & 1)
		{
		  *r++ = '\\';
		  break;
		}
	    /*FALLTHROUGH*/
#endif
	    case '0':
	      /* If (FLAGS & 1), we're translating a string for echo -e (or
		 the equivalent xpg_echo option), so we obey the SUSv3/
		 POSIX-2001 requirement and accept 0-3 octal digits after
		 a leading `0'. */
	      temp = 2 + ((flags & 1) && (c == '0'));
	      for (c -= '0'; ISOCTAL (*s) && temp--; s++)
		c = (c * 8) + OCTVALUE (*s);
	      c &= 0xFF;
	      break;
	    case 'x':			/* Hex digit -- non-ANSI */
	      if ((flags & 2) && *s == '{')
		{
		  flags |= 16;		/* internal flag value */
		  s++;
		}
	      /* Consume at least two hex characters */
	      for (temp = 2, c = 0; ISXDIGIT ((unsigned char)*s) && temp--; s++)
		c = (c * 16) + HEXVALUE (*s);
	      /* DGK says that after a `\x{' ksh93 consumes ISXDIGIT chars
		 until a non-xdigit or `}', so potentially more than two
		 chars are consumed. */
	      if (flags & 16)
		{
		  for ( ; ISXDIGIT ((unsigned char)*s); s++)
		    c = (c * 16) + HEXVALUE (*s);
		  flags &= ~16;
		  if (*s == '}')
		    s++;
	        }
	      /* \x followed by non-hex digits is passed through unchanged */
	      else if (temp == 2)
		{
		  *r++ = '\\';
		  c = 'x';
		}
	      c &= 0xFF;
	      break;
#if defined (HANDLE_MULTIBYTE)
	    case 'u':
	    case 'U':
	      temp = (c == 'u') ? 4 : 8;	/* \uNNNN \UNNNNNNNN */
	      for (v = 0; ISXDIGIT ((unsigned char)*s) && temp--; s++)
		v = (v * 16) + HEXVALUE (*s);
	      if (temp == ((c == 'u') ? 4 : 8))
		{
		  *r++ = '\\';	/* c remains unchanged */
		  break;
		}
	      else if (v <= UCHAR_MAX)
		{
		  c = v;
		  break;
		}
	      else
		{
		  temp = u32cconv (v, r);
		  r += temp;
		  continue;
		}
#endif
	    case '\\':
	      break;
	    case '\'': case '"': case '?':
	      if (flags & 1)
		*r++ = '\\';
	      break;
	    case 'c':
	      if (sawc)
		{
		  *sawc = 1;
		  *r = '\0';
		  if (rlen)
		    *rlen = r - ret;
		  return ret;
		}
	      else if ((flags & 1) == 0 && *s == 0)
		;		/* pass \c through */
	      else if ((flags & 1) == 0 && (c = *s))
		{
		  s++;
		  if ((flags & 2) && c == '\\' && c == *s)
		    s++;	/* Posix requires $'\c\\' do backslash escaping */
		  c = TOCTRL(c);
		  break;
		}
		/*FALLTHROUGH*/
	    default:
		if ((flags & 4) == 0)
		  *r++ = '\\';
		break;
	    }
	  if ((flags & 2) && (c == CTLESC || c == CTLNUL))
	    *r++ = CTLESC;
	  *r++ = c;
	}
    }
  *r = '\0';
  if (rlen)
    *rlen = r - ret;
  return ret;
}
warning: parse error {
  int c, temp;
  char *ret, *r, *s;
  unsigned long v;

  if (string == 0 || *string == '\0')
    return ((char *)NULL);

#if defined (HANDLE_MULTIBYTE)
  ret = (char *)xmalloc (4*len + 1);
#else
  ret = (char *)xmalloc (2*len + 1);	/* 2*len for possible CTLESC */
#endif
  for (r = ret, s = string; s && *s; )
    {
      c = *s++;
      if (c != '\\' || *s == '\0')
	*r++ = c;
      else
	{
	  switch (c = *s++)
	    {
#if defined (__STDC__)
	    case 'a': c = '\a'; break;
	    case 'v': c = '\v'; break;
#else
	    case 'a': c = '\007'; break;
	    case 'v': c = (int) 0x0B; break;
#endif
	    case 'b': c = '\b'; break;
	    case 'e': case 'E':		/* ESC -- non-ANSI */
	      c = ESC; break;
	    case 'f': c = '\f'; break;
	    case 'n': c = '\n'; break;
	    case 'r': c = '\r'; break;
	    case 't': c = '\t'; break;
	    case '1': case '2': case '3':
	    case '4': case '5': case '6':
	    case '7':
#if 1
	      if (flags & 1)
		{
		  *r++ = '\\';
		  break;
		}
	    /*FALLTHROUGH*/
#endif
	    case '0':
	      /* If (FLAGS & 1), we're translating a string for echo -e (or
		 the equivalent xpg_echo option), so we obey the SUSv3/
		 POSIX-2001 requirement and accept 0-3 octal digits after
		 a leading `0'. */
	      temp = 2 + ((flags & 1) && (c == '0'));
	      for (c -= '0'; ISOCTAL (*s) && temp--; s++)
		c = (c * 8) + OCTVALUE (*s);
	      c &= 0xFF;
	      break;
	    case 'x':			/* Hex digit -- non-ANSI */
	      if ((flags & 2) && *s == '{')
		{
		  flags |= 16;		/* internal flag value */
		  s++;
		}
	      /* Consume at least two hex characters */
	      for (temp = 2, c = 0; ISXDIGIT ((unsigned char)*s) && temp--; s++)
		c = (c * 16) + HEXVALUE (*s);
	      /* DGK says that after a `\x{' ksh93 consumes ISXDIGIT chars
		 until a non-xdigit or `}', so potentially more than two
		 chars are consumed. */
	      if (flags & 16)
		{
		  for ( ; ISXDIGIT ((unsigned char)*s); s++)
		    c = (c * 16) + HEXVALUE (*s);
		  flags &= ~16;
		  if (*s == '}')
		    s++;
	        }
	      /* \x followed by non-hex digits is passed through unchanged */
	      else if (temp == 2)
		{
		  *r++ = '\\';
		  c = 'x';
		}
	      c &= 0xFF;
	      break;
#if defined (HANDLE_MULTIBYTE)
	    case 'u':
	    case 'U':
	      temp = (c == 'u') ? 4 : 8;	/* \uNNNN \UNNNNNNNN */
	      for (v = 0; ISXDIGIT ((unsigned char)*s) && temp--; s++)
		v = (v * 16) + HEXVALUE (*s);
	      if (temp == ((c == 'u') ? 4 : 8))
		{
		  *r++ = '\\';	/* c remains unchanged */
		  break;
		}
	      else if (v <= UCHAR_MAX)
		{
		  c = v;
		  break;
		}
	      else
		{
		  temp = u32cconv (v, r);
		  r += temp;
		  continue;
		}
#endif
	    case '\\':
	      break;
	    case '\'': case '"': case '?':
	      if (flags & 1)
		*r++ = '\\';
	      break;
	    case 'c':
	      if (sawc)
		{
		  *sawc = 1;
		  *r = '\0';
		  if (rlen)
		    *rlen = r - ret;
		  return ret;
		}
	      else if ((flags & 1) == 0 && *s == 0)
		;		/* pass \c through */
	      else if ((flags & 1) == 0 && (c = *s))
		{
		  s++;
		  if ((flags & 2) && c == '\\' && c == *s)
		    s++;	/* Posix requires $'\c\\' do backslash escaping */
		  c = TOCTRL(c);
		  break;
		}
		/*FALLTHROUGH*/
	    default:
		if ((flags & 4) == 0)
		  *r++ = '\\';
		break;
	    }
	  if ((flags & 2) && (c == CTLESC || c == CTLNUL))
	    *r++ = CTLESC;
	  *r++ = c;
	}
    }
  *r = '\0';
  if (rlen)
    *rlen = r - ret;
  return ret;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\strtrans.c:51
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\strtrans.c:204
parsing error 
{
  char *r, *ret, *s;
  int l, rsize;
  unsigned char c;

  if (str == 0 || *str == 0)
    return ((char *)0);

  l = strlen (str);
  rsize = 4 * l + 4;
  r = ret = (char *)xmalloc (rsize);

  *r++ = '$';
  *r++ = '\'';

  for (s = str, l = 0; *s; s++)
    {
      c = *s;
      l = 1;		/* 1 == add backslash; 0 == no backslash */
      switch (c)
	{
	case ESC: c = 'E'; break;
#ifdef __STDC__
	case '\a': c = 'a'; break;
	case '\v': c = 'v'; break;
#else
	case '\007': c = 'a'; break;
	case 0x0b: c = 'v'; break;
#endif

	case '\b': c = 'b'; break;
	case '\f': c = 'f'; break;
	case '\n': c = 'n'; break;
	case '\r': c = 'r'; break;
	case '\t': c = 't'; break;
	case '\\':
	case '\'':
	  break;
	default:
	  if (ISPRINT (c) == 0)
	    {
	      *r++ = '\\';
	      *r++ = TOCHAR ((c >> 6) & 07);
	      *r++ = TOCHAR ((c >> 3) & 07);
	      *r++ = TOCHAR (c & 07);
	      continue;
	    }
	  l = 0;
	  break;
	}
      if (l)
	*r++ = '\\';
      *r++ = c;
    }

  *r++ = '\'';
  *r = '\0';
  if (rlen)
    *rlen = r - ret;
  return ret;
}
warning: parse error {
  char *r, *ret, *s;
  int l, rsize;
  unsigned char c;

  if (str == 0 || *str == 0)
    return ((char *)0);

  l = strlen (str);
  rsize = 4 * l + 4;
  r = ret = (char *)xmalloc (rsize);

  *r++ = '$';
  *r++ = '\'';

  for (s = str, l = 0; *s; s++)
    {
      c = *s;
      l = 1;		/* 1 == add backslash; 0 == no backslash */
      switch (c)
	{
	case ESC: c = 'E'; break;
#ifdef __STDC__
	case '\a': c = 'a'; break;
	case '\v': c = 'v'; break;
#else
	case '\007': c = 'a'; break;
	case 0x0b: c = 'v'; break;
#endif

	case '\b': c = 'b'; break;
	case '\f': c = 'f'; break;
	case '\n': c = 'n'; break;
	case '\r': c = 'r'; break;
	case '\t': c = 't'; break;
	case '\\':
	case '\'':
	  break;
	default:
	  if (ISPRINT (c) == 0)
	    {
	      *r++ = '\\';
	      *r++ = TOCHAR ((c >> 6) & 07);
	      *r++ = TOCHAR ((c >> 3) & 07);
	      *r++ = TOCHAR (c & 07);
	      continue;
	    }
	  l = 0;
	  break;
	}
      if (l)
	*r++ = '\\';
      *r++ = c;
    }

  *r++ = '\'';
  *r = '\0';
  if (rlen)
    *rlen = r - ret;
  return ret;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\strtrans.c:207
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\strtrans.c:272
parsing error 
{
  const char *s;
  unsigned char c;

  if (string == 0)
    return 0;

  for (s = string; c = *s; s++)
    if (ISPRINT (c) == 0)
      return 1;

  return 0;
}
warning: parse error {
  const char *s;
  unsigned char c;

  if (string == 0)
    return 0;

  for (s = string; c = *s; s++)
    if (ISPRINT (c) == 0)
      return 1;

  return 0;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\strtrans.c:273
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\strtrans.c:290
parsing error 
{
  char *temp, *t;
  int len, tlen;

  temp = (char *)xmalloc (end - start + 1);
  for (tlen = 0, len = start; len < end; )
    temp[tlen++] = string[len++];
  temp[tlen] = '\0';

  if (*temp)
    {
      t = ansicstr (temp, tlen, 2, (int *)NULL, lenp);
      free (temp);
      return (t);
    }
  else
    {
      if (lenp)
	*lenp = 0;
      return (temp);
    }
}
warning: parse error {
  char *temp, *t;
  int len, tlen;

  temp = (char *)xmalloc (end - start + 1);
  for (tlen = 0, len = start; len < end; )
    temp[tlen++] = string[len++];
  temp[tlen] = '\0';

  if (*temp)
    {
      t = ansicstr (temp, tlen, 2, (int *)NULL, lenp);
      free (temp);
      return (t);
    }
  else
    {
      if (lenp)
	*lenp = 0;
      return (temp);
    }
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\strtrans.c:293
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\times.c...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\posixtime.h...skip
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\systimes.h...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\stdc.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\times.c:38
parsing error 
{
	clock_t rv;
	static long clk_tck = -1;

#if defined (HAVE_GETRUSAGE)
	struct timeval tv;
	struct rusage ru;

	if (clk_tck == -1)
		clk_tck = get_clk_tck();

	if (getrusage(RUSAGE_SELF, &ru) < 0)
		return ((clock_t)-1);
	tms->tms_utime = CONVTCK(ru.ru_utime);
	tms->tms_stime = CONVTCK(ru.ru_stime);

	if (getrusage(RUSAGE_CHILDREN, &ru) < 0)
		return ((clock_t)-1);
	tms->tms_cutime = CONVTCK(ru.ru_utime);
	tms->tms_cstime = CONVTCK(ru.ru_stime);

	if (gettimeofday(&tv, (struct timezone *) 0) < 0)
		return ((clock_t)-1);
	rv = (clock_t)(CONVTCK(tv));
#else /* !HAVE_GETRUSAGE */
	if (clk_tck == -1)
		clk_tck = get_clk_tck();

	/* We can't do anything. */
	tms->tms_utime = tms->tms_stime = (clock_t)0;
	tms->tms_cutime = tms->tms_cstime = (clock_t)0;

	rv = (clock_t)time((time_t *)0) * clk_tck;
# endif /* HAVE_GETRUSAGE */

	return rv;
}
warning: parse error {
	clock_t rv;
	static long clk_tck = -1;

#if defined (HAVE_GETRUSAGE)
	struct timeval tv;
	struct rusage ru;

	if (clk_tck == -1)
		clk_tck = get_clk_tck();

	if (getrusage(RUSAGE_SELF, &ru) < 0)
		return ((clock_t)-1);
	tms->tms_utime = CONVTCK(ru.ru_utime);
	tms->tms_stime = CONVTCK(ru.ru_stime);

	if (getrusage(RUSAGE_CHILDREN, &ru) < 0)
		return ((clock_t)-1);
	tms->tms_cutime = CONVTCK(ru.ru_utime);
	tms->tms_cstime = CONVTCK(ru.ru_stime);

	if (gettimeofday(&tv, (struct timezone *) 0) < 0)
		return ((clock_t)-1);
	rv = (clock_t)(CONVTCK(tv));
#else /* !HAVE_GETRUSAGE */
	if (clk_tck == -1)
		clk_tck = get_clk_tck();

	/* We can't do anything. */
	tms->tms_utime = tms->tms_stime = (clock_t)0;
	tms->tms_cutime = tms->tms_cstime = (clock_t)0;

	rv = (clock_t)time((time_t *)0) * clk_tck;
# endif /* HAVE_GETRUSAGE */

	return rv;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\times.c:40
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\timeval.c...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\posixtime.h...skip
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\tmpfile.c...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\bashtypes.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\posixstat.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\posixtime.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\filecntl.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\shell.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\tmpfile.c:88
parsing error 
{
  char *tdir;

  tdir = (flags & MT_USETMPDIR) ? get_string_value ("TMPDIR") : (char *)NULL;
  if (tdir && (file_iswdir (tdir) == 0 || strlen (tdir) > PATH_MAX))
    tdir = 0;

  if (tdir == 0)
    tdir = get_sys_tmpdir ();

#if defined (HAVE_PATHCONF) && defined (_PC_NAME_MAX)
  if (tmpnamelen == -1)
    tmpnamelen = pathconf (tdir, _PC_NAME_MAX);
#else
  tmpnamelen = 0;
#endif

  return tdir;
}
warning: parse error {
  char *tdir;

  tdir = (flags & MT_USETMPDIR) ? get_string_value ("TMPDIR") : (char *)NULL;
  if (tdir && (file_iswdir (tdir) == 0 || strlen (tdir) > PATH_MAX))
    tdir = 0;

  if (tdir == 0)
    tdir = get_sys_tmpdir ();

#if defined (HAVE_PATHCONF) && defined (_PC_NAME_MAX)
  if (tmpnamelen == -1)
    tmpnamelen = pathconf (tdir, _PC_NAME_MAX);
#else
  tmpnamelen = 0;
#endif

  return tdir;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\tmpfile.c:90
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\tmpfile.c:111
parsing error 
{
  char *filename, *tdir, *lroot;
  struct stat sb;
  int r, tdlen;

  filename = (char *)xmalloc (PATH_MAX + 1);
  tdir = get_tmpdir (flags);
  tdlen = strlen (tdir);

  lroot = nameroot ? nameroot : DEFAULT_NAMEROOT;

#ifdef USE_MKTEMP
  sprintf (filename, "%s/%s.XXXXXX", tdir, lroot);
  if (mktemp (filename) == 0)
    {
      free (filename);
      filename = NULL;
    }
#else  /* !USE_MKTEMP */
  while (1)
    {
      filenum = (filenum << 1) ^
		(unsigned long) time ((time_t *)0) ^
		(unsigned long) dollar_dollar_pid ^
		(unsigned long) ((flags & MT_USERANDOM) ? get_random_number () : ntmpfiles++);
      sprintf (filename, "%s/%s-%lu", tdir, lroot, filenum);
      if (tmpnamelen > 0 && tmpnamelen < 32)
	filename[tdlen + 1 + tmpnamelen] = '\0';
#  ifdef HAVE_LSTAT
      r = lstat (filename, &sb);
#  else
      r = stat (filename, &sb);
#  endif
      if (r < 0 && errno == ENOENT)
	break;
    }
#endif /* !USE_MKTEMP */

  return filename;
}
warning: parse error {
  char *filename, *tdir, *lroot;
  struct stat sb;
  int r, tdlen;

  filename = (char *)xmalloc (PATH_MAX + 1);
  tdir = get_tmpdir (flags);
  tdlen = strlen (tdir);

  lroot = nameroot ? nameroot : DEFAULT_NAMEROOT;

#ifdef USE_MKTEMP
  sprintf (filename, "%s/%s.XXXXXX", tdir, lroot);
  if (mktemp (filename) == 0)
    {
      free (filename);
      filename = NULL;
    }
#else  /* !USE_MKTEMP */
  while (1)
    {
      filenum = (filenum << 1) ^
		(unsigned long) time ((time_t *)0) ^
		(unsigned long) dollar_dollar_pid ^
		(unsigned long) ((flags & MT_USERANDOM) ? get_random_number () : ntmpfiles++);
      sprintf (filename, "%s/%s-%lu", tdir, lroot, filenum);
      if (tmpnamelen > 0 && tmpnamelen < 32)
	filename[tdlen + 1 + tmpnamelen] = '\0';
#  ifdef HAVE_LSTAT
      r = lstat (filename, &sb);
#  else
      r = stat (filename, &sb);
#  endif
      if (r < 0 && errno == ENOENT)
	break;
    }
#endif /* !USE_MKTEMP */

  return filename;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\tmpfile.c:114
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\tmpfile.c:156
parsing error 
{
  char *filename, *tdir, *lroot;
  int fd, tdlen;

  filename = (char *)xmalloc (PATH_MAX + 1);
  tdir = get_tmpdir (flags);
  tdlen = strlen (tdir);

  lroot = nameroot ? nameroot : DEFAULT_NAMEROOT;

#ifdef USE_MKSTEMP
  sprintf (filename, "%s/%s.XXXXXX", tdir, lroot);
  fd = mkstemp (filename);
  if (fd < 0 || namep == 0)
    {
      free (filename);
      filename = NULL;
    }
  if (namep)
    *namep = filename;
  return fd;
#else /* !USE_MKSTEMP */
  do
    {
      filenum = (filenum << 1) ^
		(unsigned long) time ((time_t *)0) ^
		(unsigned long) dollar_dollar_pid ^
		(unsigned long) ((flags & MT_USERANDOM) ? get_random_number () : ntmpfiles++);
      sprintf (filename, "%s/%s-%lu", tdir, lroot, filenum);
      if (tmpnamelen > 0 && tmpnamelen < 32)
	filename[tdlen + 1 + tmpnamelen] = '\0';
      fd = open (filename, BASEOPENFLAGS | ((flags & MT_READWRITE) ? O_RDWR : O_WRONLY), 0600);
    }
  while (fd < 0 && errno == EEXIST);

  if (namep)
    *namep = filename;
  else
    free (filename);

  return fd;
#endif /* !USE_MKSTEMP */
}
warning: parse error {
  char *filename, *tdir, *lroot;
  int fd, tdlen;

  filename = (char *)xmalloc (PATH_MAX + 1);
  tdir = get_tmpdir (flags);
  tdlen = strlen (tdir);

  lroot = nameroot ? nameroot : DEFAULT_NAMEROOT;

#ifdef USE_MKSTEMP
  sprintf (filename, "%s/%s.XXXXXX", tdir, lroot);
  fd = mkstemp (filename);
  if (fd < 0 || namep == 0)
    {
      free (filename);
      filename = NULL;
    }
  if (namep)
    *namep = filename;
  return fd;
#else /* !USE_MKSTEMP */
  do
    {
      filenum = (filenum << 1) ^
		(unsigned long) time ((time_t *)0) ^
		(unsigned long) dollar_dollar_pid ^
		(unsigned long) ((flags & MT_USERANDOM) ? get_random_number () : ntmpfiles++);
      sprintf (filename, "%s/%s-%lu", tdir, lroot, filenum);
      if (tmpnamelen > 0 && tmpnamelen < 32)
	filename[tdlen + 1 + tmpnamelen] = '\0';
      fd = open (filename, BASEOPENFLAGS | ((flags & MT_READWRITE) ? O_RDWR : O_WRONLY), 0600);
    }
  while (fd < 0 && errno == EEXIST);

  if (namep)
    *namep = filename;
  else
    free (filename);

  return fd;
#endif /* !USE_MKSTEMP */
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\tmpfile.c:160
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\tmpfile.c:205
parsing error 
{
  int fd;
  FILE *fp;

  fd = sh_mktmpfd (nameroot, flags, namep);
  if (fd < 0)
    return ((FILE *)NULL);
  fp = fdopen (fd, (flags & MT_READWRITE) ? "w+" : "w");
  if (fp == 0)
    close (fd);
  return fp;
}
warning: parse error {
  int fd;
  FILE *fp;

  fd = sh_mktmpfd (nameroot, flags, namep);
  if (fd < 0)
    return ((FILE *)NULL);
  fp = fdopen (fd, (flags & MT_READWRITE) ? "w+" : "w");
  if (fp == 0)
    close (fd);
  return fp;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\tmpfile.c:209
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\uconvert.c...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\bashtypes.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\chartypes.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\shell.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\uconvert.c:67
parsing error 
{
  int n, mult;
  long ipart, upart;
  char *p;

  ipart = upart = 0;
  mult = 1;

  if (s && (*s == '-' || *s == '+'))
    {
      mult = (*s == '-') ? -1 : 1;
      p = s + 1;
    }
  else
    p = s;

  for ( ; p && *p; p++)
    {
      if (*p == DECIMAL)		/* decimal point */
	break;
      if (DIGIT(*p) == 0)
	RETURN(0);
      ipart = (ipart * 10) + (*p - '0');
    }

  if (p == 0 || *p == 0)	/* callers ensure p can never be 0; this is to shut up clang */
    RETURN(1);

  if (*p == DECIMAL)
    p++;

  /* Look for up to six digits past a decimal point. */
  for (n = 0; n < 6 && p[n]; n++)
    {
      if (DIGIT(p[n]) == 0)
	RETURN(0);
      upart = (upart * 10) + (p[n] - '0');
    }

  /* Now convert to millionths */
  upart *= multiplier[n];

  if (n == 6 && p[6] >= '5' && p[6] <= '9')
    upart++;			/* round up 1 */

  RETURN(1);
}
warning: parse error {
  int n, mult;
  long ipart, upart;
  char *p;

  ipart = upart = 0;
  mult = 1;

  if (s && (*s == '-' || *s == '+'))
    {
      mult = (*s == '-') ? -1 : 1;
      p = s + 1;
    }
  else
    p = s;

  for ( ; p && *p; p++)
    {
      if (*p == DECIMAL)		/* decimal point */
	break;
      if (DIGIT(*p) == 0)
	RETURN(0);
      ipart = (ipart * 10) + (*p - '0');
    }

  if (p == 0 || *p == 0)	/* callers ensure p can never be 0; this is to shut up clang */
    RETURN(1);

  if (*p == DECIMAL)
    p++;

  /* Look for up to six digits past a decimal point. */
  for (n = 0; n < 6 && p[n]; n++)
    {
      if (DIGIT(p[n]) == 0)
	RETURN(0);
      upart = (upart * 10) + (p[n] - '0');
    }

  /* Now convert to millionths */
  upart *= multiplier[n];

  if (n == 6 && p[6] >= '5' && p[6] <= '9')
    upart++;			/* round up 1 */

  RETURN(1);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\uconvert.c:70
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\ufuncs.c...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\bashtypes.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\ufuncs.c:65
parsing error 
{
  if (secs == 0 && usecs == 0)
    return (alarm (0));

  if (secs == 0 || usecs >= 500000)
    {
      secs++;
      usecs = 0;
    }
  return (alarm (secs));
}
warning: parse error {
  if (secs == 0 && usecs == 0)
    return (alarm (0));

  if (secs == 0 || usecs >= 500000)
    {
      secs++;
      usecs = 0;
    }
  return (alarm (secs));
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\ufuncs.c:67
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\ufuncs.c:97
parsing error 
{
  if (usec >= 500000)	/* round */
   sec++;
  return (sleep(sec));
}
warning: parse error {
  if (usec >= 500000)	/* round */
   sec++;
  return (sleep(sec));
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\ufuncs.c:99
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\unicode.c...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\stdc.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\bashansi.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\xmalloc.h...skip
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\vprint.c...
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\wcsdup.c...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\stdc.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\bashansi.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\xmalloc.h...skip
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\wcswidth.c...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\stdc.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\bashansi.h...skip
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\winsize.c...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\stdc.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\bashtypes.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\winsize.c:74
parsing error 
{
#if defined (TIOCGWINSZ)
  struct winsize win;
  int tty;

  tty = input_tty ();
  if (tty >= 0 && (ioctl (tty, TIOCGWINSZ, &win) == 0) &&
      win.ws_row > 0 && win.ws_col > 0)
    {
      sh_set_lines_and_columns (win.ws_row, win.ws_col);
#if defined (READLINE)
      rl_set_screen_size (win.ws_row, win.ws_col);
      if (rp)
	*rp = win.ws_row;
      if (cp)
	*cp = win.ws_col;
#endif
    }
#endif
}
warning: parse error {
#if defined (TIOCGWINSZ)
  struct winsize win;
  int tty;

  tty = input_tty ();
  if (tty >= 0 && (ioctl (tty, TIOCGWINSZ, &win) == 0) &&
      win.ws_row > 0 && win.ws_col > 0)
    {
      sh_set_lines_and_columns (win.ws_row, win.ws_col);
#if defined (READLINE)
      rl_set_screen_size (win.ws_row, win.ws_col);
      if (rp)
	*rp = win.ws_row;
      if (cp)
	*cp = win.ws_col;
#endif
    }
#endif
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\winsize.c:77
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\zcatfd.c...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\stdc.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\zcatfd.c:43
parsing error 
{
  ssize_t nr;
  int rval;
  char lbuf[128];

  rval = 0;
  while (1)
    {
      nr = zread (fd, lbuf, sizeof (lbuf));
      if (nr == 0)
	break;
      else if (nr < 0)
	{
	  rval = -1;
	  break;
	}
      else if (zwrite (ofd, lbuf, nr) < 0)
	{
	  rval = -1;
	  break;
	}
    }

  return rval;
}
warning: parse error {
  ssize_t nr;
  int rval;
  char lbuf[128];

  rval = 0;
  while (1)
    {
      nr = zread (fd, lbuf, sizeof (lbuf));
      if (nr == 0)
	break;
      else if (nr < 0)
	{
	  rval = -1;
	  break;
	}
      else if (zwrite (ofd, lbuf, nr) < 0)
	{
	  rval = -1;
	  break;
	}
    }

  return rval;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\zcatfd.c:46
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\zgetline.c...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\xmalloc.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\zgetline.c:61
parsing error 
{
  int nr, retval;
  char *line, c;

  if (lineptr == 0 || n == 0 || (*lineptr == 0 && *n != 0))
    return -1;

  nr = 0;
  line = *lineptr;
  
  while (1)
    {
      retval = unbuffered_read ? zread (fd, &c, 1) : zreadc(fd, &c);

      if (retval <= 0)
	{
	  if (line && nr > 0)
	    line[nr] = '\0';
	  break;
	}

      if (nr + 2 >= *n)
	{
	  size_t new_size;

	  new_size = (*n == 0) ? GET_LINE_INITIAL_ALLOCATION : *n * 2;
	  line = (*n >= new_size) ? NULL : xrealloc (*lineptr, new_size);

	  if (line)
	    {
	      *lineptr = line;
	      *n = new_size;
	    }
	  else
	    {
	      if (*n > 0)
		{
		  (*lineptr)[*n - 1] = '\0';
		  nr = *n - 2;
		}
	      break;
	    }
	}

      line[nr] = c;
      nr++;

      if (c == '\n')
	{
	  line[nr] = '\0';
	  break;
	}
    }

  return nr - 1;
}
warning: parse error {
  int nr, retval;
  char *line, c;

  if (lineptr == 0 || n == 0 || (*lineptr == 0 && *n != 0))
    return -1;

  nr = 0;
  line = *lineptr;
  
  while (1)
    {
      retval = unbuffered_read ? zread (fd, &c, 1) : zreadc(fd, &c);

      if (retval <= 0)
	{
	  if (line && nr > 0)
	    line[nr] = '\0';
	  break;
	}

      if (nr + 2 >= *n)
	{
	  size_t new_size;

	  new_size = (*n == 0) ? GET_LINE_INITIAL_ALLOCATION : *n * 2;
	  line = (*n >= new_size) ? NULL : xrealloc (*lineptr, new_size);

	  if (line)
	    {
	      *lineptr = line;
	      *n = new_size;
	    }
	  else
	    {
	      if (*n > 0)
		{
		  (*lineptr)[*n - 1] = '\0';
		  nr = *n - 2;
		}
	      break;
	    }
	}

      line[nr] = c;
      nr++;

      if (c == '\n')
	{
	  line[nr] = '\0';
	  break;
	}
    }

  return nr - 1;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\zgetline.c:66
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\zmapfd.c...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\bashansi.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\command.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\general.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\zmapfd.c:44
parsing error 
{
  ssize_t nr;
  int rval;
  char lbuf[128];
  char *result;
  int rsize, rind;

  rval = 0;
  result = (char *)xmalloc (rsize = 64);
  rind = 0;

  while (1)
    {
      nr = zread (fd, lbuf, sizeof (lbuf));
      if (nr == 0)
	{
	  rval = rind;
	  break;
	}
      else if (nr < 0)
	{
	  rval = -1;
	  free (result);
	  if (ostr)
	    *ostr = (char *)NULL;
	  break;
	}

      RESIZE_MALLOCED_BUFFER (result, rind, nr, rsize, 128);
      memcpy (result+rind, lbuf, nr);
      rind += nr;
    }

  RESIZE_MALLOCED_BUFFER (result, rind, 1, rsize, 128);
  result[rind] = '\0';

  if (ostr)
    *ostr = result;
  else
    free (result);

  return rval;
}
warning: parse error {
  ssize_t nr;
  int rval;
  char lbuf[128];
  char *result;
  int rsize, rind;

  rval = 0;
  result = (char *)xmalloc (rsize = 64);
  rind = 0;

  while (1)
    {
      nr = zread (fd, lbuf, sizeof (lbuf));
      if (nr == 0)
	{
	  rval = rind;
	  break;
	}
      else if (nr < 0)
	{
	  rval = -1;
	  free (result);
	  if (ostr)
	    *ostr = (char *)NULL;
	  break;
	}

      RESIZE_MALLOCED_BUFFER (result, rind, nr, rsize, 128);
      memcpy (result+rind, lbuf, nr);
      rind += nr;
    }

  RESIZE_MALLOCED_BUFFER (result, rind, 1, rsize, 128);
  result[rind] = '\0';

  if (ostr)
    *ostr = result;
  else
    free (result);

  return rval;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\zmapfd.c:48
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\zread.c...
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\zread.c:42
parsing error 
{
  ssize_t r;

  while ((r = read (fd, buf, len)) < 0 && errno == EINTR)
    ;
  return r;
}
warning: parse error {
  ssize_t r;

  while ((r = read (fd, buf, len)) < 0 && errno == EINTR)
    ;
  return r;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\zread.c:46
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\zread.c:63
parsing error 
{
  ssize_t r;
  int nintr;

  for (nintr = 0; ; )
    {
      r = read (fd, buf, len);
      if (r >= 0)
	return r;
      if (r == -1 && errno == EINTR)
	{
	  if (++nintr >= NUM_INTR)
	    return -1;
	  continue;
	}
      return r;
    }
}
warning: parse error {
  ssize_t r;
  int nintr;

  for (nintr = 0; ; )
    {
      r = read (fd, buf, len);
      if (r >= 0)
	return r;
      if (r == -1 && errno == EINTR)
	{
	  if (++nintr >= NUM_INTR)
	    return -1;
	  continue;
	}
      return r;
    }
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\zread.c:67
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\zread.c:88
parsing error 
{
  return (read (fd, buf, len));
}
warning: parse error {
  return (read (fd, buf, len));
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\zread.c:92
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\zread.c:104
parsing error 
{
  ssize_t nr;

  if (lind == lused || lused == 0)
    {
      nr = zread (fd, lbuf, sizeof (lbuf));
      lind = 0;
      if (nr <= 0)
	{
	  lused = 0;
	  return nr;
	}
      lused = nr;
    }
  if (cp)
    *cp = lbuf[lind++];
  return 1;
}
warning: parse error {
  ssize_t nr;

  if (lind == lused || lused == 0)
    {
      nr = zread (fd, lbuf, sizeof (lbuf));
      lind = 0;
      if (nr <= 0)
	{
	  lused = 0;
	  return nr;
	}
      lused = nr;
    }
  if (cp)
    *cp = lbuf[lind++];
  return 1;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\zread.c:107
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\zread.c:129
parsing error 
{
  ssize_t nr;

  if (lind == lused || lused == 0)
    {
      nr = zreadintr (fd, lbuf, sizeof (lbuf));
      lind = 0;
      if (nr <= 0)
	{
	  lused = 0;
	  return nr;
	}
      lused = nr;
    }
  if (cp)
    *cp = lbuf[lind++];
  return 1;
}
warning: parse error {
  ssize_t nr;

  if (lind == lused || lused == 0)
    {
      nr = zreadintr (fd, lbuf, sizeof (lbuf));
      lind = 0;
      if (nr <= 0)
	{
	  lused = 0;
	  return nr;
	}
      lused = nr;
    }
  if (cp)
    *cp = lbuf[lind++];
  return 1;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\zread.c:132
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\zread.c:160
parsing error 
{
  off_t off;
  int r;

  off = lused - lind;
  r = 0;
  if (off > 0)
    r = lseek (fd, -off, SEEK_CUR);

  if (r >= 0)
    lused = lind = 0;
}
warning: parse error {
  off_t off;
  int r;

  off = lused - lind;
  r = 0;
  if (off > 0)
    r = lseek (fd, -off, SEEK_CUR);

  if (r >= 0)
    lused = lind = 0;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\zread.c:162
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\zwrite.c...
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\zwrite.c:39
parsing error 
{
  int n, i, nt;

  for (n = nb, nt = 0;;)
    {
      i = write (fd, buf, n);
      if (i > 0)
	{
	  n -= i;
	  if (n <= 0)
	    return nb;
	  buf += i;
	}
      else if (i == 0)
	{
	  if (++nt > 3)
	    return (nb - n);
	}
      else if (errno != EINTR)
	return -1;
    }
}
warning: parse error {
  int n, i, nt;

  for (n = nb, nt = 0;;)
    {
      i = write (fd, buf, n);
      if (i > 0)
	{
	  n -= i;
	  if (n <= 0)
	    return nb;
	  buf += i;
	}
      else if (i == 0)
	{
	  if (++nt > 3)
	    return (nb - n);
	}
      else if (errno != EINTR)
	return -1;
    }
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\sh\zwrite.c:43
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\termcap\termcap.c...
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\termcap\ltcap.h...
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\termcap\termcap.c:118
parsing error 
{
  register char *tem = malloc (size);

  if (!tem)
    memory_out ();
  return tem;
}
warning: parse error {
  register char *tem = malloc (size);

  if (!tem)
    memory_out ();
  return tem;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\termcap\termcap.c:120
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\termcap\termcap.c:129
parsing error 
{
  register char *tem = realloc (ptr, size);

  if (!tem)
    memory_out ();
  return tem;
}
warning: parse error {
  register char *tem = realloc (ptr, size);

  if (!tem)
    memory_out ();
  return tem;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\termcap\termcap.c:132
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\termcap\termcap.c:154
parsing error 
{
  for (; *bp; bp++)
    if (bp[0] == ':'
	&& bp[1] == cap[0]
	&& bp[2] == cap[1])
      return &bp[4];
  return NULL;
}
warning: parse error {
  for (; *bp; bp++)
    if (bp[0] == ':'
	&& bp[1] == cap[0]
	&& bp[2] == cap[1])
      return &bp[4];
  return NULL;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\termcap\termcap.c:156
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\termcap\termcap.c:167
parsing error 
{
  register char *ptr = find_capability (term_entry, cap);
  if (!ptr || ptr[-1] != '#')
    return -1;
  return atoi (ptr);
}
warning: parse error {
  register char *ptr = find_capability (term_entry, cap);
  if (!ptr || ptr[-1] != '#')
    return -1;
  return atoi (ptr);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\termcap\termcap.c:169
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\termcap\termcap.c:178
parsing error 
{
  register char *ptr = find_capability (term_entry, cap);
  return ptr && ptr[-1] == ':';
}
warning: parse error {
  register char *ptr = find_capability (term_entry, cap);
  return ptr && ptr[-1] == ':';
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\termcap\termcap.c:180
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\termcap\termcap.c:192
parsing error 
{
  register char *ptr = find_capability (term_entry, cap);
  if (!ptr || (ptr[-1] != '=' && ptr[-1] != '~'))
    return NULL;
  return tgetst1 (ptr, area);
}
warning: parse error {
  register char *ptr = find_capability (term_entry, cap);
  if (!ptr || (ptr[-1] != '=' && ptr[-1] != '~'))
    return NULL;
  return tgetst1 (ptr, area);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\termcap\termcap.c:195
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\termcap\termcap.c:220
parsing error 
{
  register char *p, *r;
  register int c;
  register int size;
  char *ret;
  register int c1;

  if (!ptr)
    return NULL;

  /* `ret' gets address of where to store the string.  */
  if (!area)
    {
      /* Compute size of block needed (may overestimate).  */
      p = ptr;
      while ((c = *p++) && c != ':' && c != '\n')
	;
      ret = (char *) xmalloc (p - ptr + 1);
    }
  else
    ret = *area;

  /* Copy the string value, stopping at null or colon.
     Also process ^ and \ abbreviations.  */
  p = ptr;
  r = ret;
  while ((c = *p++) && c != ':' && c != '\n')
    {
      if (c == '^')
	{
	  c = *p++;
	  if (c == '?')
	    c = 0177;
	  else
	    c &= 037;
	}
      else if (c == '\\')
	{
	  c = *p++;
	  if (c >= '0' && c <= '7')
	    {
	      c -= '0';
	      size = 0;

	      while (++size < 3 && (c1 = *p) >= '0' && c1 <= '7')
		{
		  c *= 8;
		  c += c1 - '0';
		  p++;
		}
	    }
	  else if (c >= 0100 && c < 0200)
	    {
	      c1 = esctab[(c & ~040) - 0100];
	      if (c1 != ' ')
		c = c1;
	    }
	}
      *r++ = c;
    }
  *r = '\0';
  /* Update *AREA.  */
  if (area)
    *area = r + 1;
  return ret;
}
warning: parse error {
  register char *p, *r;
  register int c;
  register int size;
  char *ret;
  register int c1;

  if (!ptr)
    return NULL;

  /* `ret' gets address of where to store the string.  */
  if (!area)
    {
      /* Compute size of block needed (may overestimate).  */
      p = ptr;
      while ((c = *p++) && c != ':' && c != '\n')
	;
      ret = (char *) xmalloc (p - ptr + 1);
    }
  else
    ret = *area;

  /* Copy the string value, stopping at null or colon.
     Also process ^ and \ abbreviations.  */
  p = ptr;
  r = ret;
  while ((c = *p++) && c != ':' && c != '\n')
    {
      if (c == '^')
	{
	  c = *p++;
	  if (c == '?')
	    c = 0177;
	  else
	    c &= 037;
	}
      else if (c == '\\')
	{
	  c = *p++;
	  if (c >= '0' && c <= '7')
	    {
	      c -= '0';
	      size = 0;

	      while (++size < 3 && (c1 = *p) >= '0' && c1 <= '7')
		{
		  c *= 8;
		  c += c1 - '0';
		  p++;
		}
	    }
	  else if (c >= 0100 && c < 0200)
	    {
	      c1 = esctab[(c & ~040) - 0100];
	      if (c1 != ' ')
		c = c1;
	    }
	}
      *r++ = c;
    }
  *r = '\0';
  /* Update *AREA.  */
  if (area)
    *area = r + 1;
  return ret;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\termcap\termcap.c:223
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\termcap\termcap.c:313
parsing error 
{
  register int padcount = 0;
  register int speed;

#ifdef emacs
  extern baud_rate;
  speed = baud_rate;
  /* For quite high speeds, convert to the smaller
     units to avoid overflow.  */
  if (speed > 10000)
    speed = - speed / 100;
#else
  if (ospeed == 0)
    speed = tputs_baud_rate;
  else if (ospeed > 0 && ospeed < (sizeof speeds / sizeof speeds[0]))
    speed = speeds[ospeed];
  else
    speed = 0;
#endif

  if (!str)
    return;

  while (*str >= '0' && *str <= '9')
    {
      padcount += *str++ - '0';
      padcount *= 10;
    }
  if (*str == '.')
    {
      str++;
      padcount += *str++ - '0';
    }
  if (*str == '*')
    {
      str++;
      padcount *= nlines;
    }
  while (*str)
    (*outfun) (*str++);

  /* PADCOUNT is now in units of tenths of msec.
     SPEED is measured in characters per 10 seconds
     or in characters per .1 seconds (if negative).
     We use the smaller units for larger speeds to avoid overflow.  */
  padcount *= speed;
  padcount += 500;
  padcount /= 1000;
  if (speed < 0)
    padcount = -padcount;
  else
    {
      padcount += 50;
      padcount /= 100;
    }

  while (padcount-- > 0)
    (*outfun) (PC);
}
warning: parse error {
  register int padcount = 0;
  register int speed;

#ifdef emacs
  extern baud_rate;
  speed = baud_rate;
  /* For quite high speeds, convert to the smaller
     units to avoid overflow.  */
  if (speed > 10000)
    speed = - speed / 100;
#else
  if (ospeed == 0)
    speed = tputs_baud_rate;
  else if (ospeed > 0 && ospeed < (sizeof speeds / sizeof speeds[0]))
    speed = speeds[ospeed];
  else
    speed = 0;
#endif

  if (!str)
    return;

  while (*str >= '0' && *str <= '9')
    {
      padcount += *str++ - '0';
      padcount *= 10;
    }
  if (*str == '.')
    {
      str++;
      padcount += *str++ - '0';
    }
  if (*str == '*')
    {
      str++;
      padcount *= nlines;
    }
  while (*str)
    (*outfun) (*str++);

  /* PADCOUNT is now in units of tenths of msec.
     SPEED is measured in characters per 10 seconds
     or in characters per .1 seconds (if negative).
     We use the smaller units for larger speeds to avoid overflow.  */
  padcount *= speed;
  padcount += 500;
  padcount /= 1000;
  if (speed < 0)
    padcount = -padcount;
  else
    {
      padcount += 50;
      padcount /= 100;
    }

  while (padcount-- > 0)
    (*outfun) (PC);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\termcap\termcap.c:317
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\termcap\termcap.c:449
parsing error 
{
  register char *termcap_name;
  register int fd;
  struct buffer buf;
  register char *bp1;
  char *bp2;
  char *term;
  int malloc_size = 0;
  register int c;
  char *tcenv;			/* TERMCAP value, if it contains :tc=.  */
  char *indirect = NULL;	/* Terminal type in :tc= in TERMCAP value.  */
  int filep;

#ifdef INTERNAL_TERMINAL
  /* For the internal terminal we don't want to read any termcap file,
     so fake it.  */
  if (!strcmp (name, "internal"))
    {
      term = INTERNAL_TERMINAL;
      if (!bp)
	{
	  malloc_size = 1 + strlen (term);
	  bp = (char *) xmalloc (malloc_size);
	}
      strcpy (bp, term);
      goto ret;
    }
#endif /* INTERNAL_TERMINAL */

  /* For compatibility with programs like `less' that want to
     put data in the termcap buffer themselves as a fallback.  */
  if (bp)
    term_entry = bp;

  termcap_name = getenv ("TERMCAP");
  if (termcap_name && *termcap_name == '\0')
    termcap_name = NULL;
#if 0
#if defined (MSDOS) && !defined (TEST)
  if (termcap_name && (*termcap_name == '\\'
		       || *termcap_name == '/'
		       || termcap_name[1] == ':'))
    dostounix_filename(termcap_name);
#endif
#endif

  filep = termcap_name && valid_filename_p (termcap_name);

  /* If termcap_name is non-null and starts with / (in the un*x case, that is),
     it is a file name to use instead of /etc/termcap.
     If it is non-null and does not start with /,
     it is the entry itself, but only if
     the name the caller requested matches the TERM variable.  */

  if (termcap_name && !filep && !strcmp (name, getenv ("TERM")))
    {
      indirect = tgetst1 (find_capability (termcap_name, "tc"), (char **) 0);
      if (!indirect)
	{
	  if (!bp)
	    bp = termcap_name;
	  else
	    strcpy (bp, termcap_name);
	  goto ret;
	}
      else
	{			/* It has tc=.  Need to read /etc/termcap.  */
	  tcenv = termcap_name;
 	  termcap_name = NULL;
	}
    }

  if (!termcap_name || !filep)
    termcap_name = TERMCAP_FILE;

  /* Here we know we must search a file and termcap_name has its name.  */

#ifdef MSDOS
  fd = open (termcap_name, O_RDONLY|O_TEXT, 0);
#else
  fd = open (termcap_name, O_RDONLY, 0);
#endif
  if (fd < 0)
    return -1;

  buf.size = BUFSIZE;
  /* Add 1 to size to ensure room for terminating null.  */
  buf.beg = (char *) xmalloc (buf.size + 1);
  term = indirect ? indirect : name;

  if (!bp)
    {
      malloc_size = indirect ? strlen (tcenv) + 1 : buf.size;
      bp = (char *) xmalloc (malloc_size);
    }
  bp1 = bp;

  if (indirect)
    /* Copy the data from the environment variable.  */
    {
      strcpy (bp, tcenv);
      bp1 += strlen (tcenv);
    }

  while (term)
    {
      /* Scan the file, reading it via buf, till find start of main entry.  */
      if (scan_file (term, fd, &buf) == 0)
	{
	  close (fd);
	  free (buf.beg);
	  if (malloc_size)
	    free (bp);
	  return 0;
	}

      /* Free old `term' if appropriate.  */
      if (term != name)
	free (term);

      /* If BP is malloc'd by us, make sure it is big enough.  */
      if (malloc_size)
	{
	  malloc_size = bp1 - bp + buf.size;
	  termcap_name = (char *) xrealloc (bp, malloc_size);
	  bp1 += termcap_name - bp;
	  bp = termcap_name;
	}

      bp2 = bp1;

      /* Copy the line of the entry from buf into bp.  */
      termcap_name = buf.ptr;
      while ((*bp1++ = c = *termcap_name++) && c != '\n')
	/* Drop out any \ newline sequence.  */
	if (c == '\\' && *termcap_name == '\n')
	  {
	    bp1--;
	    termcap_name++;
	  }
      *bp1 = '\0';

      /* Does this entry refer to another terminal type's entry?
	 If something is found, copy it into heap and null-terminate it.  */
      term = tgetst1 (find_capability (bp2, "tc"), (char **) 0);
    }

  close (fd);
  free (buf.beg);

  if (malloc_size)
    bp = (char *) xrealloc (bp, bp1 - bp + 1);

 ret:
  term_entry = bp;
  return 1;
}
warning: parse error {
  register char *termcap_name;
  register int fd;
  struct buffer buf;
  register char *bp1;
  char *bp2;
  char *term;
  int malloc_size = 0;
  register int c;
  char *tcenv;			/* TERMCAP value, if it contains :tc=.  */
  char *indirect = NULL;	/* Terminal type in :tc= in TERMCAP value.  */
  int filep;

#ifdef INTERNAL_TERMINAL
  /* For the internal terminal we don't want to read any termcap file,
     so fake it.  */
  if (!strcmp (name, "internal"))
    {
      term = INTERNAL_TERMINAL;
      if (!bp)
	{
	  malloc_size = 1 + strlen (term);
	  bp = (char *) xmalloc (malloc_size);
	}
      strcpy (bp, term);
      goto ret;
    }
#endif /* INTERNAL_TERMINAL */

  /* For compatibility with programs like `less' that want to
     put data in the termcap buffer themselves as a fallback.  */
  if (bp)
    term_entry = bp;

  termcap_name = getenv ("TERMCAP");
  if (termcap_name && *termcap_name == '\0')
    termcap_name = NULL;
#if 0
#if defined (MSDOS) && !defined (TEST)
  if (termcap_name && (*termcap_name == '\\'
		       || *termcap_name == '/'
		       || termcap_name[1] == ':'))
    dostounix_filename(termcap_name);
#endif
#endif

  filep = termcap_name && valid_filename_p (termcap_name);

  /* If termcap_name is non-null and starts with / (in the un*x case, that is),
     it is a file name to use instead of /etc/termcap.
     If it is non-null and does not start with /,
     it is the entry itself, but only if
     the name the caller requested matches the TERM variable.  */

  if (termcap_name && !filep && !strcmp (name, getenv ("TERM")))
    {
      indirect = tgetst1 (find_capability (termcap_name, "tc"), (char **) 0);
      if (!indirect)
	{
	  if (!bp)
	    bp = termcap_name;
	  else
	    strcpy (bp, termcap_name);
	  goto ret;
	}
      else
	{			/* It has tc=.  Need to read /etc/termcap.  */
	  tcenv = termcap_name;
 	  termcap_name = NULL;
	}
    }

  if (!termcap_name || !filep)
    termcap_name = TERMCAP_FILE;

  /* Here we know we must search a file and termcap_name has its name.  */

#ifdef MSDOS
  fd = open (termcap_name, O_RDONLY|O_TEXT, 0);
#else
  fd = open (termcap_name, O_RDONLY, 0);
#endif
  if (fd < 0)
    return -1;

  buf.size = BUFSIZE;
  /* Add 1 to size to ensure room for terminating null.  */
  buf.beg = (char *) xmalloc (buf.size + 1);
  term = indirect ? indirect : name;

  if (!bp)
    {
      malloc_size = indirect ? strlen (tcenv) + 1 : buf.size;
      bp = (char *) xmalloc (malloc_size);
    }
  bp1 = bp;

  if (indirect)
    /* Copy the data from the environment variable.  */
    {
      strcpy (bp, tcenv);
      bp1 += strlen (tcenv);
    }

  while (term)
    {
      /* Scan the file, reading it via buf, till find start of main entry.  */
      if (scan_file (term, fd, &buf) == 0)
	{
	  close (fd);
	  free (buf.beg);
	  if (malloc_size)
	    free (bp);
	  return 0;
	}

      /* Free old `term' if appropriate.  */
      if (term != name)
	free (term);

      /* If BP is malloc'd by us, make sure it is big enough.  */
      if (malloc_size)
	{
	  malloc_size = bp1 - bp + buf.size;
	  termcap_name = (char *) xrealloc (bp, malloc_size);
	  bp1 += termcap_name - bp;
	  bp = termcap_name;
	}

      bp2 = bp1;

      /* Copy the line of the entry from buf into bp.  */
      termcap_name = buf.ptr;
      while ((*bp1++ = c = *termcap_name++) && c != '\n')
	/* Drop out any \ newline sequence.  */
	if (c == '\\' && *termcap_name == '\n')
	  {
	    bp1--;
	    termcap_name++;
	  }
      *bp1 = '\0';

      /* Does this entry refer to another terminal type's entry?
	 If something is found, copy it into heap and null-terminate it.  */
      term = tgetst1 (find_capability (bp2, "tc"), (char **) 0);
    }

  close (fd);
  free (buf.beg);

  if (malloc_size)
    bp = (char *) xrealloc (bp, bp1 - bp + 1);

 ret:
  term_entry = bp;
  return 1;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\termcap\termcap.c:451
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\termcap\termcap.c:616
parsing error 
{
  register char *end;

  bufp->ptr = bufp->beg;
  bufp->full = 0;
  bufp->ateof = 0;
  *bufp->ptr = '\0';

  lseek (fd, 0L, 0);

  while (!bufp->ateof)
    {
      /* Read a line into the buffer.  */
      end = NULL;
      do
	{
	  /* if it is continued, append another line to it,
	     until a non-continued line ends.  */
	  end = gobble_line (fd, bufp, end);
	}
      while (!bufp->ateof && end[-2] == '\\');

      if (*bufp->ptr != '#'
	  && name_match (bufp->ptr, str))
	return 1;

      /* Discard the line just processed.  */
      bufp->ptr = end;
    }
  return 0;
}
warning: parse error {
  register char *end;

  bufp->ptr = bufp->beg;
  bufp->full = 0;
  bufp->ateof = 0;
  *bufp->ptr = '\0';

  lseek (fd, 0L, 0);

  while (!bufp->ateof)
    {
      /* Read a line into the buffer.  */
      end = NULL;
      do
	{
	  /* if it is continued, append another line to it,
	     until a non-continued line ends.  */
	  end = gobble_line (fd, bufp, end);
	}
      while (!bufp->ateof && end[-2] == '\\');

      if (*bufp->ptr != '#'
	  && name_match (bufp->ptr, str))
	return 1;

      /* Discard the line just processed.  */
      bufp->ptr = end;
    }
  return 0;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\termcap\termcap.c:620
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\termcap\termcap.c:656
parsing error 
{
  register char *tem;

  if (!compare_contin (line, name))
    return 1;
  /* This line starts an entry.  Is it the right one?  */
  for (tem = line; *tem && *tem != '\n' && *tem != ':'; tem++)
    if (*tem == '|' && !compare_contin (tem + 1, name))
      return 1;

  return 0;
}
warning: parse error {
  register char *tem;

  if (!compare_contin (line, name))
    return 1;
  /* This line starts an entry.  Is it the right one?  */
  for (tem = line; *tem && *tem != '\n' && *tem != ':'; tem++)
    if (*tem == '|' && !compare_contin (tem + 1, name))
      return 1;

  return 0;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\termcap\termcap.c:658
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\termcap\termcap.c:672
parsing error 
{
  register int c1, c2;
  while (1)
    {
      c1 = *str1++;
      c2 = *str2++;
      while (c1 == '\\' && *str1 == '\n')
	{
	  str1++;
	  while ((c1 = *str1++) == ' ' || c1 == '\t');
	}
      if (c2 == '\0')
	{
	  /* End of type being looked up.  */
	  if (c1 == '|' || c1 == ':')
	    /* If end of name in data base, we win.  */
	    return 0;
	  else
	    return 1;
        }
      else if (c1 != c2)
	return 1;
    }
}
warning: parse error {
  register int c1, c2;
  while (1)
    {
      c1 = *str1++;
      c2 = *str2++;
      while (c1 == '\\' && *str1 == '\n')
	{
	  str1++;
	  while ((c1 = *str1++) == ' ' || c1 == '\t');
	}
      if (c2 == '\0')
	{
	  /* End of type being looked up.  */
	  if (c1 == '|' || c1 == ':')
	    /* If end of name in data base, we win.  */
	    return 0;
	  else
	    return 1;
        }
      else if (c1 != c2)
	return 1;
    }
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\termcap\termcap.c:674
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\termcap\termcap.c:713
parsing error 
{
  register char *end;
  register int nread;
  register char *buf = bufp->beg;
  register char *tem;

  if (!append_end)
    append_end = bufp->ptr;

  while (1)
    {
      end = append_end;
      while (*end && *end != '\n') end++;
      if (*end)
        break;
      if (bufp->ateof)
	return buf + bufp->full;
      if (bufp->ptr == buf)
	{
	  if (bufp->full == bufp->size)
	    {
	      bufp->size *= 2;
	      /* Add 1 to size to ensure room for terminating null.  */
	      tem = (char *) xrealloc (buf, bufp->size + 1);
	      bufp->ptr = (bufp->ptr - buf) + tem;
	      append_end = (append_end - buf) + tem;
	      bufp->beg = buf = tem;
	    }
	}
      else
	{
	  append_end -= bufp->ptr - buf;
	  bcopy (bufp->ptr, buf, bufp->full -= bufp->ptr - buf);
	  bufp->ptr = buf;
	}
      if (!(nread = read (fd, buf + bufp->full, bufp->size - bufp->full)))
	bufp->ateof = 1;
      bufp->full += nread;
      buf[bufp->full] = '\0';
    }
  return end + 1;
}
warning: parse error {
  register char *end;
  register int nread;
  register char *buf = bufp->beg;
  register char *tem;

  if (!append_end)
    append_end = bufp->ptr;

  while (1)
    {
      end = append_end;
      while (*end && *end != '\n') end++;
      if (*end)
        break;
      if (bufp->ateof)
	return buf + bufp->full;
      if (bufp->ptr == buf)
	{
	  if (bufp->full == bufp->size)
	    {
	      bufp->size *= 2;
	      /* Add 1 to size to ensure room for terminating null.  */
	      tem = (char *) xrealloc (buf, bufp->size + 1);
	      bufp->ptr = (bufp->ptr - buf) + tem;
	      append_end = (append_end - buf) + tem;
	      bufp->beg = buf = tem;
	    }
	}
      else
	{
	  append_end -= bufp->ptr - buf;
	  bcopy (bufp->ptr, buf, bufp->full -= bufp->ptr - buf);
	  bufp->ptr = buf;
	}
      if (!(nread = read (fd, buf + bufp->full, bufp->size - bufp->full)))
	bufp->ateof = 1;
      bufp->full += nread;
      buf[bufp->full] = '\0';
    }
  return end + 1;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\termcap\termcap.c:717
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\termcap\tparam.c...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\termcap\ltcap.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\termcap\tparam.c:72
parsing error 
{
  register char *tem = malloc (size);

  if (!tem)
    memory_out ();
  return tem;
}
warning: parse error {
  register char *tem = malloc (size);

  if (!tem)
    memory_out ();
  return tem;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\termcap\tparam.c:74
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\termcap\tparam.c:83
parsing error 
{
  register char *tem = realloc (ptr, size);

  if (!tem)
    memory_out ();
  return tem;
}
warning: parse error {
  register char *tem = realloc (ptr, size);

  if (!tem)
    memory_out ();
  return tem;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\termcap\tparam.c:86
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\termcap\tparam.c:111
parsing error 
{
  int arg[4];

  arg[0] = arg0;
  arg[1] = arg1;
  arg[2] = arg2;
  arg[3] = arg3;
  return tparam1 (string, outstring, len, NULL, NULL, arg);
}
warning: parse error {
  int arg[4];

  arg[0] = arg0;
  arg[1] = arg1;
  arg[2] = arg2;
  arg[3] = arg3;
  return tparam1 (string, outstring, len, NULL, NULL, arg);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\termcap\tparam.c:116
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\termcap\tparam.c:133
parsing error 
{
  int args[2];
  if (!cm)
    return NULL;
  args[0] = vpos;
  args[1] = hpos;
  return tparam1 (cm, tgoto_buf, 50, UP, BC, args);
}
warning: parse error {
  int args[2];
  if (!cm)
    return NULL;
  args[0] = vpos;
  args[1] = hpos;
  return tparam1 (cm, tgoto_buf, 50, UP, BC, args);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\termcap\tparam.c:136
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\termcap\tparam.c:146
parsing error 
{
  register int c;
  register char *p = string;
  register char *op = outstring;
  char *outend;
  int outlen = 0;

  register int tem;
  int *old_argp = argp;
  int doleft = 0;
  int doup = 0;

  outend = outstring + len;

  while (1)
    {
      /* If the buffer might be too short, make it bigger.  */
      if (op + 5 >= outend)
	{
	  register char *new;
	  if (outlen == 0)
	    {
	      outlen = len + 40;
	      new = (char *) xmalloc (outlen);
	      outend += 40;
	      bcopy (outstring, new, op - outstring);
	    }
	  else
	    {
	      outend += outlen;
	      outlen *= 2;
	      new = (char *) xrealloc (outstring, outlen);
	    }
	  op += new - outstring;
	  outend += new - outstring;
	  outstring = new;
	}
      c = *p++;
      if (!c)
	break;
      if (c == '%')
	{
	  c = *p++;
	  tem = *argp;
	  switch (c)
	    {
	    case 'd':		/* %d means output in decimal.  */
	      if (tem < 10)
		goto onedigit;
	      if (tem < 100)
		goto twodigit;
	    case '3':		/* %3 means output in decimal, 3 digits.  */
	      if (tem > 999)
		{
		  *op++ = tem / 1000 + '0';
		  tem %= 1000;
		}
	      *op++ = tem / 100 + '0';
	    case '2':		/* %2 means output in decimal, 2 digits.  */
	    twodigit:
	      tem %= 100;
	      *op++ = tem / 10 + '0';
	    onedigit:
	      *op++ = tem % 10 + '0';
	      argp++;
	      break;

	    case 'C':
	      /* For c-100: print quotient of value by 96, if nonzero,
		 then do like %+.  */
	      if (tem >= 96)
		{
		  *op++ = tem / 96;
		  tem %= 96;
		}
	    case '+':		/* %+x means add character code of char x.  */
	      tem += *p++;
	    case '.':		/* %. means output as character.  */
	      if (left)
		{
		  /* If want to forbid output of 0 and \n and \t,
		     and this is one of them, increment it.  */
		  while (tem == 0 || tem == '\n' || tem == '\t')
		    {
		      tem++;
		      if (argp == old_argp)
			doup++, outend -= strlen (up);
		      else
			doleft++, outend -= strlen (left);
		    }
		}
	      *op++ = tem ? tem : 0200;
	    case 'f':		/* %f means discard next arg.  */
	      argp++;
	      break;

	    case 'b':		/* %b means back up one arg (and re-use it).  */
	      argp--;
	      break;

	    case 'r':		/* %r means interchange following two args.  */
	      argp[0] = argp[1];
	      argp[1] = tem;
	      old_argp++;
	      break;

	    case '>':		/* %>xy means if arg is > char code of x, */
	      if (argp[0] > *p++) /* then add char code of y to the arg, */
		argp[0] += *p;	/* and in any case don't output.  */
	      p++;		/* Leave the arg to be output later.  */
	      break;

	    case 'a':		/* %a means arithmetic.  */
	      /* Next character says what operation.
		 Add or subtract either a constant or some other arg.  */
	      /* First following character is + to add or - to subtract
		 or = to assign.  */
	      /* Next following char is 'p' and an arg spec
		 (0100 plus position of that arg relative to this one)
		 or 'c' and a constant stored in a character.  */
	      tem = p[2] & 0177;
	      if (p[1] == 'p')
		tem = argp[tem - 0100];
	      if (p[0] == '-')
		argp[0] -= tem;
	      else if (p[0] == '+')
		argp[0] += tem;
	      else if (p[0] == '*')
		argp[0] *= tem;
	      else if (p[0] == '/')
		argp[0] /= tem;
	      else
		argp[0] = tem;

	      p += 3;
	      break;

	    case 'i':		/* %i means add one to arg, */
	      argp[0] ++;	/* and leave it to be output later.  */
	      argp[1] ++;	/* Increment the following arg, too!  */
	      break;

	    case '%':		/* %% means output %; no arg.  */
	      goto ordinary;

	    case 'n':		/* %n means xor each of next two args with 140.  */
	      argp[0] ^= 0140;
	      argp[1] ^= 0140;
	      break;

	    case 'm':		/* %m means xor each of next two args with 177.  */
	      argp[0] ^= 0177;
	      argp[1] ^= 0177;
	      break;

	    case 'B':		/* %B means express arg as BCD char code.  */
	      argp[0] += 6 * (tem / 10);
	      break;

	    case 'D':		/* %D means weird Delta Data transformation.  */
	      argp[0] -= 2 * (tem % 16);
	      break;
	    }
	}
      else
	/* Ordinary character in the argument string.  */
      ordinary:
	*op++ = c;
    }
  *op = 0;
  while (doup-- > 0)
    strcat (op, up);
  while (doleft-- > 0)
    strcat (op, left);
  return outstring;
}
warning: parse error {
  register int c;
  register char *p = string;
  register char *op = outstring;
  char *outend;
  int outlen = 0;

  register int tem;
  int *old_argp = argp;
  int doleft = 0;
  int doup = 0;

  outend = outstring + len;

  while (1)
    {
      /* If the buffer might be too short, make it bigger.  */
      if (op + 5 >= outend)
	{
	  register char *new;
	  if (outlen == 0)
	    {
	      outlen = len + 40;
	      new = (char *) xmalloc (outlen);
	      outend += 40;
	      bcopy (outstring, new, op - outstring);
	    }
	  else
	    {
	      outend += outlen;
	      outlen *= 2;
	      new = (char *) xrealloc (outstring, outlen);
	    }
	  op += new - outstring;
	  outend += new - outstring;
	  outstring = new;
	}
      c = *p++;
      if (!c)
	break;
      if (c == '%')
	{
	  c = *p++;
	  tem = *argp;
	  switch (c)
	    {
	    case 'd':		/* %d means output in decimal.  */
	      if (tem < 10)
		goto onedigit;
	      if (tem < 100)
		goto twodigit;
	    case '3':		/* %3 means output in decimal, 3 digits.  */
	      if (tem > 999)
		{
		  *op++ = tem / 1000 + '0';
		  tem %= 1000;
		}
	      *op++ = tem / 100 + '0';
	    case '2':		/* %2 means output in decimal, 2 digits.  */
	    twodigit:
	      tem %= 100;
	      *op++ = tem / 10 + '0';
	    onedigit:
	      *op++ = tem % 10 + '0';
	      argp++;
	      break;

	    case 'C':
	      /* For c-100: print quotient of value by 96, if nonzero,
		 then do like %+.  */
	      if (tem >= 96)
		{
		  *op++ = tem / 96;
		  tem %= 96;
		}
	    case '+':		/* %+x means add character code of char x.  */
	      tem += *p++;
	    case '.':		/* %. means output as character.  */
	      if (left)
		{
		  /* If want to forbid output of 0 and \n and \t,
		     and this is one of them, increment it.  */
		  while (tem == 0 || tem == '\n' || tem == '\t')
		    {
		      tem++;
		      if (argp == old_argp)
			doup++, outend -= strlen (up);
		      else
			doleft++, outend -= strlen (left);
		    }
		}
	      *op++ = tem ? tem : 0200;
	    case 'f':		/* %f means discard next arg.  */
	      argp++;
	      break;

	    case 'b':		/* %b means back up one arg (and re-use it).  */
	      argp--;
	      break;

	    case 'r':		/* %r means interchange following two args.  */
	      argp[0] = argp[1];
	      argp[1] = tem;
	      old_argp++;
	      break;

	    case '>':		/* %>xy means if arg is > char code of x, */
	      if (argp[0] > *p++) /* then add char code of y to the arg, */
		argp[0] += *p;	/* and in any case don't output.  */
	      p++;		/* Leave the arg to be output later.  */
	      break;

	    case 'a':		/* %a means arithmetic.  */
	      /* Next character says what operation.
		 Add or subtract either a constant or some other arg.  */
	      /* First following character is + to add or - to subtract
		 or = to assign.  */
	      /* Next following char is 'p' and an arg spec
		 (0100 plus position of that arg relative to this one)
		 or 'c' and a constant stored in a character.  */
	      tem = p[2] & 0177;
	      if (p[1] == 'p')
		tem = argp[tem - 0100];
	      if (p[0] == '-')
		argp[0] -= tem;
	      else if (p[0] == '+')
		argp[0] += tem;
	      else if (p[0] == '*')
		argp[0] *= tem;
	      else if (p[0] == '/')
		argp[0] /= tem;
	      else
		argp[0] = tem;

	      p += 3;
	      break;

	    case 'i':		/* %i means add one to arg, */
	      argp[0] ++;	/* and leave it to be output later.  */
	      argp[1] ++;	/* Increment the following arg, too!  */
	      break;

	    case '%':		/* %% means output %; no arg.  */
	      goto ordinary;

	    case 'n':		/* %n means xor each of next two args with 140.  */
	      argp[0] ^= 0140;
	      argp[1] ^= 0140;
	      break;

	    case 'm':		/* %m means xor each of next two args with 177.  */
	      argp[0] ^= 0177;
	      argp[1] ^= 0177;
	      break;

	    case 'B':		/* %B means express arg as BCD char code.  */
	      argp[0] += 6 * (tem / 10);
	      break;

	    case 'D':		/* %D means weird Delta Data transformation.  */
	      argp[0] -= 2 * (tem % 16);
	      break;
	    }
	}
      else
	/* Ordinary character in the argument string.  */
      ordinary:
	*op++ = c;
    }
  *op = 0;
  while (doup-- > 0)
    strcat (op, up);
  while (doleft-- > 0)
    strcat (op, left);
  return outstring;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\termcap\tparam.c:152
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\termcap\version.c...
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\tilde\shell.c...
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\tilde\shell.c:52
parsing error 
{
  return ((char *)getenv (varname));
}
warning: parse error {
  return ((char *)getenv (varname));
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\tilde\shell.c:54
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\tilde\tilde.c...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\tilde\tilde.h...skip
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\tilde\tilde.c:129
parsing error 
{
  register int i, j, string_len;
  register char **prefixes;

  prefixes = tilde_additional_prefixes;

  string_len = strlen (string);
  *len = 0;

  if (*string == '\0' || *string == '~')
    return (0);

  if (prefixes)
    {
      for (i = 0; i < string_len; i++)
	{
	  for (j = 0; prefixes[j]; j++)
	    {
	      if (strncmp (string + i, prefixes[j], strlen (prefixes[j])) == 0)
		{
		  *len = strlen (prefixes[j]) - 1;
		  return (i + *len);
		}
	    }
	}
    }
  return (string_len);
}
warning: parse error {
  register int i, j, string_len;
  register char **prefixes;

  prefixes = tilde_additional_prefixes;

  string_len = strlen (string);
  *len = 0;

  if (*string == '\0' || *string == '~')
    return (0);

  if (prefixes)
    {
      for (i = 0; i < string_len; i++)
	{
	  for (j = 0; prefixes[j]; j++)
	    {
	      if (strncmp (string + i, prefixes[j], strlen (prefixes[j])) == 0)
		{
		  *len = strlen (prefixes[j]) - 1;
		  return (i + *len);
		}
	    }
	}
    }
  return (string_len);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\tilde\tilde.c:131
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\tilde\tilde.c:164
parsing error 
{
  register int i, j, string_len;
  register char **suffixes;

  suffixes = tilde_additional_suffixes;
  string_len = strlen (string);

  for (i = 0; i < string_len; i++)
    {
#if defined (__MSDOS__)
      if (string[i] == '/' || string[i] == '\\' /* || !string[i] */)
#else
      if (string[i] == '/' /* || !string[i] */)
#endif
	break;

      for (j = 0; suffixes && suffixes[j]; j++)
	{
	  if (strncmp (string + i, suffixes[j], strlen (suffixes[j])) == 0)
	    return (i);
	}
    }
  return (i);
}
warning: parse error {
  register int i, j, string_len;
  register char **suffixes;

  suffixes = tilde_additional_suffixes;
  string_len = strlen (string);

  for (i = 0; i < string_len; i++)
    {
#if defined (__MSDOS__)
      if (string[i] == '/' || string[i] == '\\' /* || !string[i] */)
#else
      if (string[i] == '/' /* || !string[i] */)
#endif
	break;

      for (j = 0; suffixes && suffixes[j]; j++)
	{
	  if (strncmp (string + i, suffixes[j], strlen (suffixes[j])) == 0)
	    return (i);
	}
    }
  return (i);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\tilde\tilde.c:165
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\tilde\tilde.c:193
parsing error 
{
  char *result;
  int result_size, result_index;

  result_index = result_size = 0;
  if (result = strchr (string, '~'))
    result = (char *)xmalloc (result_size = (strlen (string) + 16));
  else
    result = (char *)xmalloc (result_size = (strlen (string) + 1));

  /* Scan through STRING expanding tildes as we come to them. */
  while (1)
    {
      register int start, end;
      char *tilde_word, *expansion;
      int len;

      /* Make START point to the tilde which starts the expansion. */
      start = tilde_find_prefix (string, &len);

      /* Copy the skipped text into the result. */
      if ((result_index + start + 1) > result_size)
	result = (char *)xrealloc (result, 1 + (result_size += (start + 20)));

      strncpy (result + result_index, string, start);
      result_index += start;

      /* Advance STRING to the starting tilde. */
      string += start;

      /* Make END be the index of one after the last character of the
	 username. */
      end = tilde_find_suffix (string);

      /* If both START and END are zero, we are all done. */
      if (!start && !end)
	break;

      /* Expand the entire tilde word, and copy it into RESULT. */
      tilde_word = (char *)xmalloc (1 + end);
      strncpy (tilde_word, string, end);
      tilde_word[end] = '\0';
      string += end;

      expansion = tilde_expand_word (tilde_word);
      xfree (tilde_word);

      len = strlen (expansion);
#ifdef __CYGWIN__
      /* Fix for Cygwin to prevent ~user/xxx from expanding to //xxx when
	 $HOME for `user' is /.  On cygwin, // denotes a network drive. */
      if (len > 1 || *expansion != '/' || *string != '/')
#endif
	{
	  if ((result_index + len + 1) > result_size)
	    result = (char *)xrealloc (result, 1 + (result_size += (len + 20)));

	  strcpy (result + result_index, expansion);
	  result_index += len;
	}
      xfree (expansion);
    }

  result[result_index] = '\0';

  return (result);
}
warning: parse error {
  char *result;
  int result_size, result_index;

  result_index = result_size = 0;
  if (result = strchr (string, '~'))
    result = (char *)xmalloc (result_size = (strlen (string) + 16));
  else
    result = (char *)xmalloc (result_size = (strlen (string) + 1));

  /* Scan through STRING expanding tildes as we come to them. */
  while (1)
    {
      register int start, end;
      char *tilde_word, *expansion;
      int len;

      /* Make START point to the tilde which starts the expansion. */
      start = tilde_find_prefix (string, &len);

      /* Copy the skipped text into the result. */
      if ((result_index + start + 1) > result_size)
	result = (char *)xrealloc (result, 1 + (result_size += (start + 20)));

      strncpy (result + result_index, string, start);
      result_index += start;

      /* Advance STRING to the starting tilde. */
      string += start;

      /* Make END be the index of one after the last character of the
	 username. */
      end = tilde_find_suffix (string);

      /* If both START and END are zero, we are all done. */
      if (!start && !end)
	break;

      /* Expand the entire tilde word, and copy it into RESULT. */
      tilde_word = (char *)xmalloc (1 + end);
      strncpy (tilde_word, string, end);
      tilde_word[end] = '\0';
      string += end;

      expansion = tilde_expand_word (tilde_word);
      xfree (tilde_word);

      len = strlen (expansion);
#ifdef __CYGWIN__
      /* Fix for Cygwin to prevent ~user/xxx from expanding to //xxx when
	 $HOME for `user' is /.  On cygwin, // denotes a network drive. */
      if (len > 1 || *expansion != '/' || *string != '/')
#endif
	{
	  if ((result_index + len + 1) > result_size)
	    result = (char *)xrealloc (result, 1 + (result_size += (len + 20)));

	  strcpy (result + result_index, expansion);
	  result_index += len;
	}
      xfree (expansion);
    }

  result[result_index] = '\0';

  return (result);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\tilde\tilde.c:194
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\tilde\tilde.c:267
parsing error 
{
  char *ret;
  int i;

  ret = (char *)xmalloc (strlen (fname));
#if defined (__MSDOS__)
  for (i = 1; fname[i] && fname[i] != '/' && fname[i] != '\\'; i++)
#else
  for (i = 1; fname[i] && fname[i] != '/'; i++)
#endif
    ret[i - 1] = fname[i];
  ret[i - 1] = '\0';
  if (lenp)
    *lenp = i;
  return ret;
}
warning: parse error {
  char *ret;
  int i;

  ret = (char *)xmalloc (strlen (fname));
#if defined (__MSDOS__)
  for (i = 1; fname[i] && fname[i] != '/' && fname[i] != '\\'; i++)
#else
  for (i = 1; fname[i] && fname[i] != '/'; i++)
#endif
    ret[i - 1] = fname[i];
  ret[i - 1] = '\0';
  if (lenp)
    *lenp = i;
  return ret;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\tilde\tilde.c:269
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\tilde\tilde.c:322
parsing error 
{
  char *ret;
  int plen, slen;

  plen = (prefix && *prefix) ? strlen (prefix) : 0;
  slen = strlen (suffix + suffind);
  ret = (char *)xmalloc (plen + slen + 1);
  if (plen)
    strcpy (ret, prefix);
  strcpy (ret + plen, suffix + suffind);
  return ret;
}
warning: parse error {
  char *ret;
  int plen, slen;

  plen = (prefix && *prefix) ? strlen (prefix) : 0;
  slen = strlen (suffix + suffind);
  ret = (char *)xmalloc (plen + slen + 1);
  if (plen)
    strcpy (ret, prefix);
  strcpy (ret + plen, suffix + suffind);
  return ret;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\tilde\tilde.c:326
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\tilde\tilde.c:344
parsing error 
{
  char *dirname, *expansion, *username;
  int user_len;
  struct passwd *user_entry;

  if (filename == 0)
    return ((char *)NULL);

  if (*filename != '~')
    return (savestring (filename));

  /* A leading `~/' or a bare `~' is *always* translated to the value of
     $HOME or the home directory of the current user, regardless of any
     preexpansion hook. */
  if (filename[1] == '\0' || filename[1] == '/')
    {
      /* Prefix $HOME to the rest of the string. */
      expansion = sh_get_env_value ("HOME");

      /* If there is no HOME variable, look up the directory in
	 the password database. */
      if (expansion == 0)
	expansion = sh_get_home_dir ();

      return (glue_prefix_and_suffix (expansion, filename, 1));
    }

  username = isolate_tilde_prefix (filename, &user_len);

  if (tilde_expansion_preexpansion_hook)
    {
      expansion = (*tilde_expansion_preexpansion_hook) (username);
      if (expansion)
	{
	  dirname = glue_prefix_and_suffix (expansion, filename, user_len);
	  xfree (username);
	  xfree (expansion);
	  return (dirname);
	}
    }

  /* No preexpansion hook, or the preexpansion hook failed.  Look in the
     password database. */
  dirname = (char *)NULL;
#if defined (HAVE_GETPWNAM)
  user_entry = getpwnam (username);
#else
  user_entry = 0;
#endif
  if (user_entry == 0)
    {
      /* If the calling program has a special syntax for expanding tildes,
	 and we couldn't find a standard expansion, then let them try. */
      if (tilde_expansion_failure_hook)
	{
	  expansion = (*tilde_expansion_failure_hook) (username);
	  if (expansion)
	    {
	      dirname = glue_prefix_and_suffix (expansion, filename, user_len);
	      xfree (expansion);
	    }
	}
      /* If we don't have a failure hook, or if the failure hook did not
	 expand the tilde, return a copy of what we were passed. */
      if (dirname == 0)
	dirname = savestring (filename);
    }
#if defined (HAVE_GETPWENT)
  else
    dirname = glue_prefix_and_suffix (user_entry->pw_dir, filename, user_len);
#endif

  xfree (username);
#if defined (HAVE_GETPWENT)
  endpwent ();
#endif
  return (dirname);
}
warning: parse error {
  char *dirname, *expansion, *username;
  int user_len;
  struct passwd *user_entry;

  if (filename == 0)
    return ((char *)NULL);

  if (*filename != '~')
    return (savestring (filename));

  /* A leading `~/' or a bare `~' is *always* translated to the value of
     $HOME or the home directory of the current user, regardless of any
     preexpansion hook. */
  if (filename[1] == '\0' || filename[1] == '/')
    {
      /* Prefix $HOME to the rest of the string. */
      expansion = sh_get_env_value ("HOME");

      /* If there is no HOME variable, look up the directory in
	 the password database. */
      if (expansion == 0)
	expansion = sh_get_home_dir ();

      return (glue_prefix_and_suffix (expansion, filename, 1));
    }

  username = isolate_tilde_prefix (filename, &user_len);

  if (tilde_expansion_preexpansion_hook)
    {
      expansion = (*tilde_expansion_preexpansion_hook) (username);
      if (expansion)
	{
	  dirname = glue_prefix_and_suffix (expansion, filename, user_len);
	  xfree (username);
	  xfree (expansion);
	  return (dirname);
	}
    }

  /* No preexpansion hook, or the preexpansion hook failed.  Look in the
     password database. */
  dirname = (char *)NULL;
#if defined (HAVE_GETPWNAM)
  user_entry = getpwnam (username);
#else
  user_entry = 0;
#endif
  if (user_entry == 0)
    {
      /* If the calling program has a special syntax for expanding tildes,
	 and we couldn't find a standard expansion, then let them try. */
      if (tilde_expansion_failure_hook)
	{
	  expansion = (*tilde_expansion_failure_hook) (username);
	  if (expansion)
	    {
	      dirname = glue_prefix_and_suffix (expansion, filename, user_len);
	      xfree (expansion);
	    }
	}
      /* If we don't have a failure hook, or if the failure hook did not
	 expand the tilde, return a copy of what we were passed. */
      if (dirname == 0)
	dirname = savestring (filename);
    }
#if defined (HAVE_GETPWENT)
  else
    dirname = glue_prefix_and_suffix (user_entry->pw_dir, filename, user_len);
#endif

  xfree (username);
#if defined (HAVE_GETPWENT)
  endpwent ();
#endif
  return (dirname);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\tilde\tilde.c:345
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\list.c...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\shell.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\list.c:63
parsing error 
{
  register GENERIC_LIST *next, *prev;

  for (prev = (GENERIC_LIST *)NULL; list; )
    {
      next = list->next;
      list->next = prev;
      prev = list;
      list = next;
    }
  return (prev);
}
warning: parse error {
  register GENERIC_LIST *next, *prev;

  for (prev = (GENERIC_LIST *)NULL; list; )
    {
      next = list->next;
      list->next = prev;
      prev = list;
      list = next;
    }
  return (prev);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\list.c:65
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\list.c:80
parsing error 
{
  register int i;

  for (i = 0; list; list = list->next, i++);
  return (i);
}
warning: parse error {
  register int i;

  for (i = 0; list; list = list->next, i++);
  return (i);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\list.c:82
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\list.c:91
parsing error 
{
  register GENERIC_LIST *t_head;

  if (head == 0)
    return (tail);

  for (t_head = head; t_head->next; t_head = t_head->next)
    ;
  t_head->next = tail;
  return (head);
}
warning: parse error {
  register GENERIC_LIST *t_head;

  if (head == 0)
    return (tail);

  for (t_head = head; t_head->next; t_head = t_head->next)
    ;
  t_head->next = tail;
  return (head);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\list.c:93
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\locale.c...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\bashtypes.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\bashintl.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\bashansi.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\chartypes.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\shell.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\input.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\locale.c:148
parsing error 
{
  int r;
  char *x;

  x = "";
  errno = 0;
  if (var[0] == 'T' && var[10] == 0)		/* TEXTDOMAIN */
    {
      FREE (default_domain);
      default_domain = value ? savestring (value) : (char *)NULL;
#if 0
      /* Don't want to override the shell's textdomain as the default */
      textdomain (default_domain);
#endif
      return (1);
    }
  else if (var[0] == 'T')			/* TEXTDOMAINDIR */
    {
      FREE (default_dir);
      default_dir = value ? savestring (value) : (char *)NULL;
      if (default_domain && *default_domain)
	bindtextdomain (default_domain, default_dir);
      return (1);
    }

  /* var[0] == 'L' && var[1] == 'C' && var[2] == '_' */

  else if (var[3] == 'A')			/* LC_ALL */
    {
      FREE (lc_all);
      if (value)
	lc_all = savestring (value);
      else
	{
	  lc_all = (char *)xmalloc (1);
	  lc_all[0] = '\0';
	}
#if defined (HAVE_SETLOCALE)
      r = *lc_all ? ((x = setlocale (LC_ALL, lc_all)) != 0) : reset_locale_vars ();
      if (x == 0)
	{
	  if (errno == 0)
	    internal_warning(_("setlocale: LC_ALL: cannot change locale (%s)"), lc_all);
	  else
	    internal_warning(_("setlocale: LC_ALL: cannot change locale (%s): %s"), lc_all, strerror (errno));
	}
      locale_setblanks ();
      return r;
#else
      return (1);
#endif
    }

#if defined (HAVE_SETLOCALE)
  else if (var[3] == 'C' && var[4] == 'T')	/* LC_CTYPE */
    {
#  if defined (LC_CTYPE)
      if (lc_all == 0 || *lc_all == '\0')
	{
	  x = setlocale (LC_CTYPE, get_locale_var ("LC_CTYPE"));
	  locale_setblanks ();
	}
#  endif
    }
  else if (var[3] == 'C' && var[4] == 'O')	/* LC_COLLATE */
    {
#  if defined (LC_COLLATE)
      if (lc_all == 0 || *lc_all == '\0')
	x = setlocale (LC_COLLATE, get_locale_var ("LC_COLLATE"));
#  endif /* LC_COLLATE */
    }
  else if (var[3] == 'M' && var[4] == 'E')	/* LC_MESSAGES */
    {
#  if defined (LC_MESSAGES)
      if (lc_all == 0 || *lc_all == '\0')
	x = setlocale (LC_MESSAGES, get_locale_var ("LC_MESSAGES"));
#  endif /* LC_MESSAGES */
    }
  else if (var[3] == 'N' && var[4] == 'U')	/* LC_NUMERIC */
    {
#  if defined (LC_NUMERIC)
      if (lc_all == 0 || *lc_all == '\0')
	x = setlocale (LC_NUMERIC, get_locale_var ("LC_NUMERIC"));
#  endif /* LC_NUMERIC */
    }
  else if (var[3] == 'T' && var[4] == 'I')	/* LC_TIME */
    {
#  if defined (LC_TIME)
      if (lc_all == 0 || *lc_all == '\0')
	x = setlocale (LC_TIME, get_locale_var ("LC_TIME"));
#  endif /* LC_TIME */
    }
#endif /* HAVE_SETLOCALE */
  
  if (x == 0)
    {
      if (errno == 0)
	internal_warning(_("setlocale: %s: cannot change locale (%s)"), var, get_locale_var (var));
      else
	internal_warning(_("setlocale: %s: cannot change locale (%s): %s"), var, get_locale_var (var), strerror (errno));
    }

  return (x != 0);
}
warning: parse error {
  int r;
  char *x;

  x = "";
  errno = 0;
  if (var[0] == 'T' && var[10] == 0)		/* TEXTDOMAIN */
    {
      FREE (default_domain);
      default_domain = value ? savestring (value) : (char *)NULL;
#if 0
      /* Don't want to override the shell's textdomain as the default */
      textdomain (default_domain);
#endif
      return (1);
    }
  else if (var[0] == 'T')			/* TEXTDOMAINDIR */
    {
      FREE (default_dir);
      default_dir = value ? savestring (value) : (char *)NULL;
      if (default_domain && *default_domain)
	bindtextdomain (default_domain, default_dir);
      return (1);
    }

  /* var[0] == 'L' && var[1] == 'C' && var[2] == '_' */

  else if (var[3] == 'A')			/* LC_ALL */
    {
      FREE (lc_all);
      if (value)
	lc_all = savestring (value);
      else
	{
	  lc_all = (char *)xmalloc (1);
	  lc_all[0] = '\0';
	}
#if defined (HAVE_SETLOCALE)
      r = *lc_all ? ((x = setlocale (LC_ALL, lc_all)) != 0) : reset_locale_vars ();
      if (x == 0)
	{
	  if (errno == 0)
	    internal_warning(_("setlocale: LC_ALL: cannot change locale (%s)"), lc_all);
	  else
	    internal_warning(_("setlocale: LC_ALL: cannot change locale (%s): %s"), lc_all, strerror (errno));
	}
      locale_setblanks ();
      return r;
#else
      return (1);
#endif
    }

#if defined (HAVE_SETLOCALE)
  else if (var[3] == 'C' && var[4] == 'T')	/* LC_CTYPE */
    {
#  if defined (LC_CTYPE)
      if (lc_all == 0 || *lc_all == '\0')
	{
	  x = setlocale (LC_CTYPE, get_locale_var ("LC_CTYPE"));
	  locale_setblanks ();
	}
#  endif
    }
  else if (var[3] == 'C' && var[4] == 'O')	/* LC_COLLATE */
    {
#  if defined (LC_COLLATE)
      if (lc_all == 0 || *lc_all == '\0')
	x = setlocale (LC_COLLATE, get_locale_var ("LC_COLLATE"));
#  endif /* LC_COLLATE */
    }
  else if (var[3] == 'M' && var[4] == 'E')	/* LC_MESSAGES */
    {
#  if defined (LC_MESSAGES)
      if (lc_all == 0 || *lc_all == '\0')
	x = setlocale (LC_MESSAGES, get_locale_var ("LC_MESSAGES"));
#  endif /* LC_MESSAGES */
    }
  else if (var[3] == 'N' && var[4] == 'U')	/* LC_NUMERIC */
    {
#  if defined (LC_NUMERIC)
      if (lc_all == 0 || *lc_all == '\0')
	x = setlocale (LC_NUMERIC, get_locale_var ("LC_NUMERIC"));
#  endif /* LC_NUMERIC */
    }
  else if (var[3] == 'T' && var[4] == 'I')	/* LC_TIME */
    {
#  if defined (LC_TIME)
      if (lc_all == 0 || *lc_all == '\0')
	x = setlocale (LC_TIME, get_locale_var ("LC_TIME"));
#  endif /* LC_TIME */
    }
#endif /* HAVE_SETLOCALE */
  
  if (x == 0)
    {
      if (errno == 0)
	internal_warning(_("setlocale: %s: cannot change locale (%s)"), var, get_locale_var (var));
      else
	internal_warning(_("setlocale: %s: cannot change locale (%s): %s"), var, get_locale_var (var), strerror (errno));
    }

  return (x != 0);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\locale.c:150
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\locale.c:259
parsing error 
{
  FREE (lang);
  if (value)
    lang = savestring (value);
  else
    {
      lang = (char *)xmalloc (1);
      lang[0] = '\0';
    }
    
  return ((lc_all == 0 || *lc_all == 0) ? reset_locale_vars () : 0);
}
warning: parse error {
  FREE (lang);
  if (value)
    lang = savestring (value);
  else
    {
      lang = (char *)xmalloc (1);
      lang[0] = '\0';
    }
    
  return ((lc_all == 0 || *lc_all == 0) ? reset_locale_vars () : 0);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\locale.c:261
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\locale.c:292
parsing error 
{
  char *locale;

  locale = lc_all;

  if (locale == 0 || *locale == 0)
    locale = get_string_value (var);	/* XXX - mem leak? */
  if (locale == 0 || *locale == 0)
    locale = lang;
  if (locale == 0 || *locale == 0)
#if 0
    locale = default_locale;	/* system-dependent; not really portable.  should it be "C"? */
#else
    locale = "";
#endif
  return (locale);
}
warning: parse error {
  char *locale;

  locale = lc_all;

  if (locale == 0 || *locale == 0)
    locale = get_string_value (var);	/* XXX - mem leak? */
  if (locale == 0 || *locale == 0)
    locale = lang;
  if (locale == 0 || *locale == 0)
#if 0
    locale = default_locale;	/* system-dependent; not really portable.  should it be "C"? */
#else
    locale = "";
#endif
  return (locale);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\locale.c:294
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\locale.c:352
parsing error 
{
  char *locale, *t;
  char *translated;
  int tlen;

  /* Don't try to translate null strings. */
  if (string == 0 || *string == 0)
    {
      if (lenp)
	*lenp = 0;
      return ((char *)NULL);
    }

  locale = get_locale_var ("LC_MESSAGES");

  /* If we don't have setlocale() or the current locale is `C' or `POSIX',
     just return the string.  If we don't have gettext(), there's no use
     doing anything else. */
  if (locale == 0 || locale[0] == '\0' ||
      (locale[0] == 'C' && locale[1] == '\0') || STREQ (locale, "POSIX"))
    {
      t = (char *)xmalloc (len + 1);
      strcpy (t, string);
      if (lenp)
	*lenp = len;
      return (t);
    }

  /* Now try to translate it. */
  if (default_domain && *default_domain)
    translated = dgettext (default_domain, string);
  else
    translated = string;

  if (translated == string)	/* gettext returns its argument if untranslatable */
    {
      t = (char *)xmalloc (len + 1);
      strcpy (t, string);
      if (lenp)
	*lenp = len;
    }
  else
    {
      tlen = strlen (translated);
      t = (char *)xmalloc (tlen + 1);
      strcpy (t, translated);
      if (lenp)
	*lenp = tlen;
    }
  return (t);
}
warning: parse error {
  char *locale, *t;
  char *translated;
  int tlen;

  /* Don't try to translate null strings. */
  if (string == 0 || *string == 0)
    {
      if (lenp)
	*lenp = 0;
      return ((char *)NULL);
    }

  locale = get_locale_var ("LC_MESSAGES");

  /* If we don't have setlocale() or the current locale is `C' or `POSIX',
     just return the string.  If we don't have gettext(), there's no use
     doing anything else. */
  if (locale == 0 || locale[0] == '\0' ||
      (locale[0] == 'C' && locale[1] == '\0') || STREQ (locale, "POSIX"))
    {
      t = (char *)xmalloc (len + 1);
      strcpy (t, string);
      if (lenp)
	*lenp = len;
      return (t);
    }

  /* Now try to translate it. */
  if (default_domain && *default_domain)
    translated = dgettext (default_domain, string);
  else
    translated = string;

  if (translated == string)	/* gettext returns its argument if untranslatable */
    {
      t = (char *)xmalloc (len + 1);
      strcpy (t, string);
      if (lenp)
	*lenp = len;
    }
  else
    {
      tlen = strlen (translated);
      t = (char *)xmalloc (tlen + 1);
      strcpy (t, translated);
      if (lenp)
	*lenp = tlen;
    }
  return (t);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\locale.c:355
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\locale.c:410
parsing error 
{
  register int c, len;
  char *result, *r, *s;

  for (len = 0, s = string; s && *s; s++)
    {
      len++;
      if (*s == '"' || *s == '\\')
	len++;
      else if (*s == '\n')
	len += 5;
    }
  
  r = result = (char *)xmalloc (len + 3);
  *r++ = '"';

  for (s = string; s && (c = *s); s++)
    {
      if (c == '\n')	/* <NL> -> \n"<NL>" */
	{
	  *r++ = '\\';
	  *r++ = 'n';
	  *r++ = '"';
	  *r++ = '\n';
	  *r++ = '"';
	  if (foundnlp)
	    *foundnlp = 1;
	  continue;
	}
      if (c == '"' || c == '\\')
	*r++ = '\\';
      *r++ = c;
    }

  *r++ = '"';
  *r++ = '\0';

  return result;
}
warning: parse error {
  register int c, len;
  char *result, *r, *s;

  for (len = 0, s = string; s && *s; s++)
    {
      len++;
      if (*s == '"' || *s == '\\')
	len++;
      else if (*s == '\n')
	len += 5;
    }
  
  r = result = (char *)xmalloc (len + 3);
  *r++ = '"';

  for (s = string; s && (c = *s); s++)
    {
      if (c == '\n')	/* <NL> -> \n"<NL>" */
	{
	  *r++ = '\\';
	  *r++ = 'n';
	  *r++ = '"';
	  *r++ = '\n';
	  *r++ = '"';
	  if (foundnlp)
	    *foundnlp = 1;
	  continue;
	}
      if (c == '"' || c == '\\')
	*r++ = '\\';
      *r++ = c;
    }

  *r++ = '"';
  *r++ = '\0';

  return result;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\locale.c:413
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\locale.c:461
parsing error 
{
  int len, tlen, foundnl;
  char *temp, *t, *t2;

  temp = (char *)xmalloc (end - start + 1);
  for (tlen = 0, len = start; len < end; )
    temp[tlen++] = string[len++];
  temp[tlen] = '\0';

  /* If we're just dumping translatable strings, don't do anything with the
     string itself, but if we're dumping in `po' file format, convert it into
     a form more palatable to gettext(3) and friends by quoting `"' and `\'
     with backslashes and converting <NL> into `\n"<NL>"'.  If we find a
     newline in TEMP, we first output a `msgid ""' line and then the
     translated string; otherwise we output the `msgid' and translated
     string all on one line. */
  if (dump_translatable_strings)
    {
      if (dump_po_strings)
	{
	  foundnl = 0;
	  t = mk_msgstr (temp, &foundnl);
	  t2 = foundnl ? "\"\"\n" : "";

	  printf ("#: %s:%d\nmsgid %s%s\nmsgstr \"\"\n",
			yy_input_name (), lineno, t2, t);
	  free (t);
	}
      else
	printf ("\"%s\"\n", temp);

      if (lenp)
	*lenp = tlen;
      return (temp);
    }
  else if (*temp)
    {
      t = localetrans (temp, tlen, &len);
      free (temp);
      if (lenp)
	*lenp = len;
      return (t);
    }
  else
    {
      if (lenp)
	*lenp = 0;
      return (temp);
    }
}
warning: parse error {
  int len, tlen, foundnl;
  char *temp, *t, *t2;

  temp = (char *)xmalloc (end - start + 1);
  for (tlen = 0, len = start; len < end; )
    temp[tlen++] = string[len++];
  temp[tlen] = '\0';

  /* If we're just dumping translatable strings, don't do anything with the
     string itself, but if we're dumping in `po' file format, convert it into
     a form more palatable to gettext(3) and friends by quoting `"' and `\'
     with backslashes and converting <NL> into `\n"<NL>"'.  If we find a
     newline in TEMP, we first output a `msgid ""' line and then the
     translated string; otherwise we output the `msgid' and translated
     string all on one line. */
  if (dump_translatable_strings)
    {
      if (dump_po_strings)
	{
	  foundnl = 0;
	  t = mk_msgstr (temp, &foundnl);
	  t2 = foundnl ? "\"\"\n" : "";

	  printf ("#: %s:%d\nmsgid %s%s\nmsgstr \"\"\n",
			yy_input_name (), lineno, t2, t);
	  free (t);
	}
      else
	printf ("\"%s\"\n", temp);

      if (lenp)
	*lenp = tlen;
      return (temp);
    }
  else if (*temp)
    {
      t = localetrans (temp, tlen, &len);
      free (temp);
      if (lenp)
	*lenp = len;
      return (t);
    }
  else
    {
      if (lenp)
	*lenp = 0;
      return (temp);
    }
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\locale.c:464
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\mailcheck.c...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\bashtypes.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\posixstat.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\posixtime.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\bashansi.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\bashintl.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\shell.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\execute_cmd.h...skip
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\mailcheck.h...
parsing error 
extern int time_to_check_mail __P((void));
warning: parse error extern int time_to_check_mail __P((void));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\mailcheck.h:25
parsing error 
extern void reset_mail_timer __P((void));
warning: parse error extern void reset_mail_timer __P((void));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\mailcheck.h:26
parsing error 
extern void reset_mail_files __P((void));
warning: parse error extern void reset_mail_files __P((void));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\mailcheck.h:27
parsing error 
extern void free_mail_files __P((void));
warning: parse error extern void free_mail_files __P((void));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\mailcheck.h:28
parsing error 
extern char *make_default_mailpath __P((void));
warning: parse error extern char *make_default_mailpath __P((void));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\mailcheck.h:29
parsing error 
extern void remember_mail_dates __P((void));
warning: parse error extern void remember_mail_dates __P((void));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\mailcheck.h:30
parsing error 
extern void init_mail_dates __P((void));
warning: parse error extern void init_mail_dates __P((void));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\mailcheck.h:31
parsing error 
extern void check_mail __P((void));
warning: parse error extern void check_mail __P((void));Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\mailcheck.h:32
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\tilde\tilde.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\mailcheck.c:115
parsing error 
{
  register int i;

  for (i = 0; i < mailfiles_count; i++)
    if (STREQ (mailfiles[i]->name, file))
      return i;

  return -1;
}
warning: parse error {
  register int i;

  for (i = 0; i < mailfiles_count; i++)
    if (STREQ (mailfiles[i]->name, file))
      return i;

  return -1;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\mailcheck.c:117
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\mailcheck.c:147
parsing error 
{
  mailfiles[i]->access_time = mailfiles[i]->mod_time = last_time_mail_checked ? last_time_mail_checked : shell_start_time;
  mailfiles[i]->file_size = 0;
  mailfiles[i]->flags = 0;
}
warning: parse error {
  mailfiles[i]->access_time = mailfiles[i]->mod_time = last_time_mail_checked ? last_time_mail_checked : shell_start_time;
  mailfiles[i]->file_size = 0;
  mailfiles[i]->flags = 0;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\mailcheck.c:149
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\mailcheck.c:156
parsing error 
{
  char *file;
  struct stat finfo;

  file = mailfiles[i]->name;
  if (mailstat (file, &finfo) == 0)
    UPDATE_MAIL_FILE (i, finfo);
  else
    RESET_MAIL_FILE (i);
}
warning: parse error {
  char *file;
  struct stat finfo;

  file = mailfiles[i]->name;
  if (mailstat (file, &finfo) == 0)
    UPDATE_MAIL_FILE (i, finfo);
  else
    RESET_MAIL_FILE (i);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\mailcheck.c:158
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\mailcheck.c:172
parsing error 
{
  struct stat finfo;
  char *filename;
  int i;

  filename = full_pathname (file);
  i = find_mail_file (filename);
  if (i >= 0)
    {
      if (mailstat (filename, &finfo) == 0)
	UPDATE_MAIL_FILE (i, finfo);

      free (filename);
      return i;
    }

  i = mailfiles_count++;
  mailfiles = (FILEINFO **)xrealloc
		(mailfiles, mailfiles_count * sizeof (FILEINFO *));

  mailfiles[i] = alloc_mail_file (filename, msg);
  init_mail_file (i);

  return i;
}
warning: parse error {
  struct stat finfo;
  char *filename;
  int i;

  filename = full_pathname (file);
  i = find_mail_file (filename);
  if (i >= 0)
    {
      if (mailstat (filename, &finfo) == 0)
	UPDATE_MAIL_FILE (i, finfo);

      free (filename);
      return i;
    }

  i = mailfiles_count++;
  mailfiles = (FILEINFO **)xrealloc
		(mailfiles, mailfiles_count * sizeof (FILEINFO *));

  mailfiles[i] = alloc_mail_file (filename, msg);
  init_mail_file (i);

  return i;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\mailcheck.c:174
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\mailcheck.c:211
parsing error 
{
  FILEINFO *mf;

  mf = (FILEINFO *)xmalloc (sizeof (FILEINFO));
  mf->name = filename;
  mf->msg = msg ? savestring (msg) : (char *)NULL;
  mf->flags = 0;

  return mf;
}
warning: parse error {
  FILEINFO *mf;

  mf = (FILEINFO *)xmalloc (sizeof (FILEINFO));
  mf->name = filename;
  mf->msg = msg ? savestring (msg) : (char *)NULL;
  mf->flags = 0;

  return mf;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\mailcheck.c:213
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\mailcheck.c:225
parsing error 
{
  free (mf->name);
  FREE (mf->msg);
  free (mf);
}
warning: parse error {
  free (mf->name);
  FREE (mf->msg);
  free (mf);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\mailcheck.c:227
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\mailcheck.c:260
parsing error 
{
  time_t mtime;
  struct stat finfo;
  char *file;

  file = mailfiles[i]->name;
  mtime = mailfiles[i]->mod_time;

  if ((mailstat (file, &finfo) == 0) && (finfo.st_size > 0))
    return (mtime < finfo.st_mtime);

  if (finfo.st_size == 0 && mailfiles[i]->file_size > 0)
    UPDATE_MAIL_FILE (i, finfo);

  return (0);
}
warning: parse error {
  time_t mtime;
  struct stat finfo;
  char *file;

  file = mailfiles[i]->name;
  mtime = mailfiles[i]->mod_time;

  if ((mailstat (file, &finfo) == 0) && (finfo.st_size > 0))
    return (mtime < finfo.st_mtime);

  if (finfo.st_size == 0 && mailfiles[i]->file_size > 0)
    UPDATE_MAIL_FILE (i, finfo);

  return (0);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\mailcheck.c:262
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\mailcheck.c:281
parsing error 
{
  time_t atime;
  struct stat finfo;
  char *file;

  file = mailfiles[i]->name;
  atime = mailfiles[i]->access_time;

  if ((mailstat (file, &finfo) == 0) && (finfo.st_size > 0))
    return (atime < finfo.st_atime);

  return (0);
}
warning: parse error {
  time_t atime;
  struct stat finfo;
  char *file;

  file = mailfiles[i]->name;
  atime = mailfiles[i]->access_time;

  if ((mailstat (file, &finfo) == 0) && (finfo.st_size > 0))
    return (atime < finfo.st_atime);

  return (0);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\mailcheck.c:283
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\mailcheck.c:299
parsing error 
{
  off_t size;
  struct stat finfo;
  char *file;

  file = mailfiles[i]->name;
  size = mailfiles[i]->file_size;

  return ((mailstat (file, &finfo) == 0) && (finfo.st_size > size));
}
warning: parse error {
  off_t size;
  struct stat finfo;
  char *file;

  file = mailfiles[i]->name;
  size = mailfiles[i]->file_size;

  return ((mailstat (file, &finfo) == 0) && (finfo.st_size > size));
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\mailcheck.c:301
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\mailcheck.c:316
parsing error 
{
  char *s;
  int pass_next;

  for (s = str, pass_next = 0; s && *s; s++)
    {
      if (pass_next)
	{
	  pass_next = 0;
	  continue;
	}
      if (*s == '\\')
	{
	  pass_next++;
	  continue;
	}
      if (*s == '?' || *s == '%')
	return s;
    }
  return ((char *)NULL);
}
warning: parse error {
  char *s;
  int pass_next;

  for (s = str, pass_next = 0; s && *s; s++)
    {
      if (pass_next)
	{
	  pass_next = 0;
	  continue;
	}
      if (*s == '\\')
	{
	  pass_next++;
	  continue;
	}
      if (*s == '?' || *s == '%')
	return s;
    }
  return ((char *)NULL);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\mailcheck.c:318
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\make_cmd.c...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\bashtypes.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\filecntl.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\bashansi.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\bashintl.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\parser.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\syntax.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\command.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\general.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\error.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\flags.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\make_cmd.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\dispose_cmd.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\subst.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\input.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\ocache.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\externs.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\jobs.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\shmbutil.h...skip
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\make_cmd.c:93
parsing error 
{
  WORD_DESC *temp;

  temp = alloc_word_desc ();

  if (*string)
    temp->word = savestring (string);
  else
    {
      temp->word = (char *)xmalloc (1);
      temp->word[0] = '\0';
    }

  return (temp);
}
warning: parse error {
  WORD_DESC *temp;

  temp = alloc_word_desc ();

  if (*string)
    temp->word = savestring (string);
  else
    {
      temp->word = (char *)xmalloc (1);
      temp->word[0] = '\0';
    }

  return (temp);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\make_cmd.c:94
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\make_cmd.c:111
parsing error 
{
  register int i;
  size_t slen;
  DECLARE_MBSTATE;

  i = 0;
  slen = strlen (string);
  while (i < slen)
    {
      switch (string[i])
	{
	case '$':
	  w->flags |= W_HASDOLLAR;
	  break;
	case '\\':
	  break;	/* continue the loop */
	case '\'':
	case '`':
	case '"':
	  w->flags |= W_QUOTED;
	  break;
	}

      ADVANCE_CHAR (string, slen, i);
    }

  return (w);
}
warning: parse error {
  register int i;
  size_t slen;
  DECLARE_MBSTATE;

  i = 0;
  slen = strlen (string);
  while (i < slen)
    {
      switch (string[i])
	{
	case '$':
	  w->flags |= W_HASDOLLAR;
	  break;
	case '\\':
	  break;	/* continue the loop */
	case '\'':
	case '`':
	case '"':
	  w->flags |= W_QUOTED;
	  break;
	}

      ADVANCE_CHAR (string, slen, i);
    }

  return (w);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\make_cmd.c:114
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\make_cmd.c:145
parsing error 
{
  WORD_DESC *temp;

  temp = make_bare_word (string);
  return (make_word_flags (temp, string));
}
warning: parse error {
  WORD_DESC *temp;

  temp = make_bare_word (string);
  return (make_word_flags (temp, string));
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\make_cmd.c:146
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\make_cmd.c:154
parsing error 
{
  char tokenizer[2];

  tokenizer[0] = token;
  tokenizer[1] = '\0';

  return (make_word (tokenizer));
}
warning: parse error {
  char tokenizer[2];

  tokenizer[0] = token;
  tokenizer[1] = '\0';

  return (make_word (tokenizer));
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\make_cmd.c:156
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\make_cmd.c:166
parsing error 
{
  WORD_LIST *temp;

  ocache_alloc (wlcache, WORD_LIST, temp);

  temp->word = word;
  temp->next = wlink;
  return (temp);
}
warning: parse error {
  WORD_LIST *temp;

  ocache_alloc (wlcache, WORD_LIST, temp);

  temp->word = word;
  temp->next = wlink;
  return (temp);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\make_cmd.c:169
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\make_cmd.c:180
parsing error 
{
  COMMAND *temp;

  temp = (COMMAND *)xmalloc (sizeof (COMMAND));
  temp->type = type;
  temp->value.Simple = pointer;
  temp->value.Simple->flags = temp->flags = 0;
  temp->redirects = (REDIRECT *)NULL;
  return (temp);
}
warning: parse error {
  COMMAND *temp;

  temp = (COMMAND *)xmalloc (sizeof (COMMAND));
  temp->type = type;
  temp->value.Simple = pointer;
  temp->value.Simple->flags = temp->flags = 0;
  temp->redirects = (REDIRECT *)NULL;
  return (temp);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\make_cmd.c:183
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\make_cmd.c:195
parsing error 
{
  CONNECTION *temp;

  temp = (CONNECTION *)xmalloc (sizeof (CONNECTION));
  temp->connector = connector;
  temp->first = com1;
  temp->second = com2;
  return (make_command (cm_connection, (SIMPLE_COM *)temp));
}
warning: parse error {
  CONNECTION *temp;

  temp = (CONNECTION *)xmalloc (sizeof (CONNECTION));
  temp->connector = connector;
  temp->first = com1;
  temp->second = com2;
  return (make_command (cm_connection, (SIMPLE_COM *)temp));
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\make_cmd.c:198
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\make_cmd.c:209
parsing error 
{
  FOR_COM *temp;

  temp = (FOR_COM *)xmalloc (sizeof (FOR_COM));
  temp->flags = 0;
  temp->name = name;
  temp->line = lineno;
  temp->map_list = map_list;
  temp->action = action;
  return (make_command (type, (SIMPLE_COM *)temp));
}
warning: parse error {
  FOR_COM *temp;

  temp = (FOR_COM *)xmalloc (sizeof (FOR_COM));
  temp->flags = 0;
  temp->name = name;
  temp->line = lineno;
  temp->map_list = map_list;
  temp->action = action;
  return (make_command (type, (SIMPLE_COM *)temp));
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\make_cmd.c:215
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\make_cmd.c:228
parsing error 
{
  return (make_for_or_select (cm_for, name, map_list, action, lineno));
}
warning: parse error {
  return (make_for_or_select (cm_for, name, map_list, action, lineno));
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\make_cmd.c:233
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\make_cmd.c:238
parsing error 
{
#if defined (SELECT_COMMAND)
  return (make_for_or_select (cm_select, name, map_list, action, lineno));
#else
  last_command_exit_value = 2;
  return ((COMMAND *)NULL);
#endif
}
warning: parse error {
#if defined (SELECT_COMMAND)
  return (make_for_or_select (cm_select, name, map_list, action, lineno));
#else
  last_command_exit_value = 2;
  return ((COMMAND *)NULL);
#endif
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\make_cmd.c:243
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\make_cmd.c:274
parsing error 
{
#if defined (ARITH_FOR_COMMAND)
  ARITH_FOR_COM *temp;
  WORD_LIST *init, *test, *step;
  char *s, *t, *start;
  int nsemi;

  init = test = step = (WORD_LIST *)NULL;
  /* Parse the string into the three component sub-expressions. */
  start = t = s = exprs->word->word;
  for (nsemi = 0; ;)
    {
      /* skip whitespace at the start of each sub-expression. */
      while (whitespace (*s))
	s++;
      start = s;
      /* skip to the semicolon or EOS */
      while (*s && *s != ';')
	s++;

      t = (s > start) ? substring (start, 0, s - start) : (char *)NULL;

      nsemi++;
      switch (nsemi)
	{
	case 1:
	  init = make_arith_for_expr (t);
	  break;
	case 2:
	  test = make_arith_for_expr (t);
	  break;
	case 3:
	  step = make_arith_for_expr (t);
	  break;
	}

      FREE (t);
      if (*s == '\0')
	break;
      s++;	/* skip over semicolon */
    }

  if (nsemi != 3)
    {
      if (nsemi < 3)
	parser_error (lineno, _("syntax error: arithmetic expression required"));
      else
	parser_error (lineno, _("syntax error: `;' unexpected"));
      parser_error (lineno, _("syntax error: `((%s))'"), exprs->word->word);
      last_command_exit_value = 2;
      return ((COMMAND *)NULL);
    }

  temp = (ARITH_FOR_COM *)xmalloc (sizeof (ARITH_FOR_COM));
  temp->flags = 0;
  temp->line = lineno;
  temp->init = init ? init : make_arith_for_expr ("1");
  temp->test = test ? test : make_arith_for_expr ("1");
  temp->step = step ? step : make_arith_for_expr ("1");
  temp->action = action;

  dispose_words (exprs);
  return (make_command (cm_arith_for, (SIMPLE_COM *)temp));
#else
  dispose_words (exprs);
  last_command_exit_value = 2;
  return ((COMMAND *)NULL);
#endif /* ARITH_FOR_COMMAND */
}
warning: parse error {
#if defined (ARITH_FOR_COMMAND)
  ARITH_FOR_COM *temp;
  WORD_LIST *init, *test, *step;
  char *s, *t, *start;
  int nsemi;

  init = test = step = (WORD_LIST *)NULL;
  /* Parse the string into the three component sub-expressions. */
  start = t = s = exprs->word->word;
  for (nsemi = 0; ;)
    {
      /* skip whitespace at the start of each sub-expression. */
      while (whitespace (*s))
	s++;
      start = s;
      /* skip to the semicolon or EOS */
      while (*s && *s != ';')
	s++;

      t = (s > start) ? substring (start, 0, s - start) : (char *)NULL;

      nsemi++;
      switch (nsemi)
	{
	case 1:
	  init = make_arith_for_expr (t);
	  break;
	case 2:
	  test = make_arith_for_expr (t);
	  break;
	case 3:
	  step = make_arith_for_expr (t);
	  break;
	}

      FREE (t);
      if (*s == '\0')
	break;
      s++;	/* skip over semicolon */
    }

  if (nsemi != 3)
    {
      if (nsemi < 3)
	parser_error (lineno, _("syntax error: arithmetic expression required"));
      else
	parser_error (lineno, _("syntax error: `;' unexpected"));
      parser_error (lineno, _("syntax error: `((%s))'"), exprs->word->word);
      last_command_exit_value = 2;
      return ((COMMAND *)NULL);
    }

  temp = (ARITH_FOR_COM *)xmalloc (sizeof (ARITH_FOR_COM));
  temp->flags = 0;
  temp->line = lineno;
  temp->init = init ? init : make_arith_for_expr ("1");
  temp->test = test ? test : make_arith_for_expr ("1");
  temp->step = step ? step : make_arith_for_expr ("1");
  temp->action = action;

  dispose_words (exprs);
  return (make_command (cm_arith_for, (SIMPLE_COM *)temp));
#else
  dispose_words (exprs);
  last_command_exit_value = 2;
  return ((COMMAND *)NULL);
#endif /* ARITH_FOR_COMMAND */
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\make_cmd.c:278
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\make_cmd.c:349
parsing error 
{
  GROUP_COM *temp;

  temp = (GROUP_COM *)xmalloc (sizeof (GROUP_COM));
  temp->command = command;
  return (make_command (cm_group, (SIMPLE_COM *)temp));
}
warning: parse error {
  GROUP_COM *temp;

  temp = (GROUP_COM *)xmalloc (sizeof (GROUP_COM));
  temp->command = command;
  return (make_command (cm_group, (SIMPLE_COM *)temp));
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\make_cmd.c:351
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\make_cmd.c:360
parsing error 
{
  CASE_COM *temp;

  temp = (CASE_COM *)xmalloc (sizeof (CASE_COM));
  temp->flags = 0;
  temp->line = lineno;
  temp->word = word;
  temp->clauses = REVERSE_LIST (clauses, PATTERN_LIST *);
  return (make_command (cm_case, (SIMPLE_COM *)temp));
}
warning: parse error {
  CASE_COM *temp;

  temp = (CASE_COM *)xmalloc (sizeof (CASE_COM));
  temp->flags = 0;
  temp->line = lineno;
  temp->word = word;
  temp->clauses = REVERSE_LIST (clauses, PATTERN_LIST *);
  return (make_command (cm_case, (SIMPLE_COM *)temp));
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\make_cmd.c:364
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\make_cmd.c:376
parsing error 
{
  PATTERN_LIST *temp;

  temp = (PATTERN_LIST *)xmalloc (sizeof (PATTERN_LIST));
  temp->patterns = REVERSE_LIST (patterns, WORD_LIST *);
  temp->action = action;
  temp->next = NULL;
  temp->flags = 0;
  return (temp);
}
warning: parse error {
  PATTERN_LIST *temp;

  temp = (PATTERN_LIST *)xmalloc (sizeof (PATTERN_LIST));
  temp->patterns = REVERSE_LIST (patterns, WORD_LIST *);
  temp->action = action;
  temp->next = NULL;
  temp->flags = 0;
  return (temp);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\make_cmd.c:379
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\make_cmd.c:391
parsing error 
{
  IF_COM *temp;

  temp = (IF_COM *)xmalloc (sizeof (IF_COM));
  temp->flags = 0;
  temp->test = test;
  temp->true_case = true_case;
  temp->false_case = false_case;
  return (make_command (cm_if, (SIMPLE_COM *)temp));
}
warning: parse error {
  IF_COM *temp;

  temp = (IF_COM *)xmalloc (sizeof (IF_COM));
  temp->flags = 0;
  temp->test = test;
  temp->true_case = true_case;
  temp->false_case = false_case;
  return (make_command (cm_if, (SIMPLE_COM *)temp));
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\make_cmd.c:393
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\make_cmd.c:405
parsing error 
{
  WHILE_COM *temp;

  temp = (WHILE_COM *)xmalloc (sizeof (WHILE_COM));
  temp->flags = 0;
  temp->test = test;
  temp->action = action;
  return (make_command (which, (SIMPLE_COM *)temp));
}
warning: parse error {
  WHILE_COM *temp;

  temp = (WHILE_COM *)xmalloc (sizeof (WHILE_COM));
  temp->flags = 0;
  temp->test = test;
  temp->action = action;
  return (make_command (which, (SIMPLE_COM *)temp));
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\make_cmd.c:408
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\make_cmd.c:419
parsing error 
{
  return (make_until_or_while (cm_while, test, action));
}
warning: parse error {
  return (make_until_or_while (cm_while, test, action));
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\make_cmd.c:421
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\make_cmd.c:426
parsing error 
{
  return (make_until_or_while (cm_until, test, action));
}
warning: parse error {
  return (make_until_or_while (cm_until, test, action));
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\make_cmd.c:428
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\make_cmd.c:433
parsing error 
{
#if defined (DPAREN_ARITHMETIC)
  COMMAND *command;
  ARITH_COM *temp;

  command = (COMMAND *)xmalloc (sizeof (COMMAND));
  command->value.Arith = temp = (ARITH_COM *)xmalloc (sizeof (ARITH_COM));

  temp->flags = 0;
  temp->line = line_number;
  temp->exp = exp;

  command->type = cm_arith;
  command->redirects = (REDIRECT *)NULL;
  command->flags = 0;

  return (command);
#else
  last_command_exit_value = 2;
  return ((COMMAND *)NULL);
#endif
}
warning: parse error {
#if defined (DPAREN_ARITHMETIC)
  COMMAND *command;
  ARITH_COM *temp;

  command = (COMMAND *)xmalloc (sizeof (COMMAND));
  command->value.Arith = temp = (ARITH_COM *)xmalloc (sizeof (ARITH_COM));

  temp->flags = 0;
  temp->line = line_number;
  temp->exp = exp;

  command->type = cm_arith;
  command->redirects = (REDIRECT *)NULL;
  command->flags = 0;

  return (command);
#else
  last_command_exit_value = 2;
  return ((COMMAND *)NULL);
#endif
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\make_cmd.c:435
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\make_cmd.c:480
parsing error 
{
#if defined (COND_COMMAND)
  COMMAND *command;

  command = (COMMAND *)xmalloc (sizeof (COMMAND));
  command->value.Cond = cond_node;

  command->type = cm_cond;
  command->redirects = (REDIRECT *)NULL;
  command->flags = 0;
  command->line = cond_node ? cond_node->line : 0;

  return (command);
#else
  last_command_exit_value = 2;
  return ((COMMAND *)NULL);
#endif
}
warning: parse error {
#if defined (COND_COMMAND)
  COMMAND *command;

  command = (COMMAND *)xmalloc (sizeof (COMMAND));
  command->value.Cond = cond_node;

  command->type = cm_cond;
  command->redirects = (REDIRECT *)NULL;
  command->flags = 0;
  command->line = cond_node ? cond_node->line : 0;

  return (command);
#else
  last_command_exit_value = 2;
  return ((COMMAND *)NULL);
#endif
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\make_cmd.c:482
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\make_cmd.c:525
parsing error 
{
  /* If we are starting from scratch, then make the initial command
     structure.  Also note that we have to fill in all the slots, since
     malloc doesn't return zeroed space. */
  if (command == 0)
    {
      command = make_bare_simple_command ();
      parser_state |= PST_REDIRLIST;
    }

  if (element.word)
    {
      command->value.Simple->words = make_word_list (element.word, command->value.Simple->words);
      parser_state &= ~PST_REDIRLIST;
    }
  else if (element.redirect)
    {
      REDIRECT *r = element.redirect;
      /* Due to the way <> is implemented, there may be more than a single
	 redirection in element.redirect.  We just follow the chain as far
	 as it goes, and hook onto the end. */
      while (r->next)
	r = r->next;
      r->next = command->value.Simple->redirects;
      command->value.Simple->redirects = element.redirect;
    }

  return (command);
}
warning: parse error {
  /* If we are starting from scratch, then make the initial command
     structure.  Also note that we have to fill in all the slots, since
     malloc doesn't return zeroed space. */
  if (command == 0)
    {
      command = make_bare_simple_command ();
      parser_state |= PST_REDIRLIST;
    }

  if (element.word)
    {
      command->value.Simple->words = make_word_list (element.word, command->value.Simple->words);
      parser_state &= ~PST_REDIRLIST;
    }
  else if (element.redirect)
    {
      REDIRECT *r = element.redirect;
      /* Due to the way <> is implemented, there may be more than a single
	 redirection in element.redirect.  We just follow the chain as far
	 as it goes, and hook onto the end. */
      while (r->next)
	r = r->next;
      r->next = command->value.Simple->redirects;
      command->value.Simple->redirects = element.redirect;
    }

  return (command);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\make_cmd.c:528
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\make_cmd.c:564
parsing error 
{
  int kill_leading, redir_len;
  char *redir_word, *document, *full_line;
  int document_index, document_size, delim_unquoted;

  if (temp->instruction != r_deblank_reading_until &&
      temp->instruction != r_reading_until)
    {
      internal_error (_("make_here_document: bad instruction type %d"), temp->instruction);
      return;
    }

  kill_leading = temp->instruction == r_deblank_reading_until;

  document = (char *)NULL;
  document_index = document_size = 0;

  /* Quote removal is the only expansion performed on the delimiter
     for here documents, making it an extremely special case. */
  redir_word = string_quote_removal (temp->redirectee.filename->word, 0);

  /* redirection_expand will return NULL if the expansion results in
     multiple words or no words.  Check for that here, and just abort
     this here document if it does. */
  if (redir_word)
    redir_len = strlen (redir_word);
  else
    {
      temp->here_doc_eof = (char *)xmalloc (1);
      temp->here_doc_eof[0] = '\0';
      goto document_done;
    }

  free (temp->redirectee.filename->word);
  temp->here_doc_eof = redir_word;

  /* Read lines from wherever lines are coming from.
     For each line read, if kill_leading, then kill the
     leading tab characters.
     If the line matches redir_word exactly, then we have
     manufactured the document.  Otherwise, add the line to the
     list of lines in the document. */

  /* If the here-document delimiter was quoted, the lines should
     be read verbatim from the input.  If it was not quoted, we
     need to perform backslash-quoted newline removal. */
  delim_unquoted = (temp->redirectee.filename->flags & W_QUOTED) == 0;
  while (full_line = read_secondary_line (delim_unquoted))
    {
      register char *line;
      int len;

      line = full_line;
      line_number++;

      /* If set -v is in effect, echo the line read.  read_secondary_line/
	 read_a_line leaves the newline at the end, so don't print another. */
      if (echo_input_at_read)
	fprintf (stderr, "%s", line);

      if (kill_leading && *line)
	{
	  /* Hack:  To be compatible with some Bourne shells, we
	     check the word before stripping the whitespace.  This
	     is a hack, though. */
	  if (STREQN (line, redir_word, redir_len) && line[redir_len] == '\n')
	    goto document_done;

	  while (*line == '\t')
	    line++;
	}

      if (*line == 0)
	continue;

      if (STREQN (line, redir_word, redir_len) && line[redir_len] == '\n')
	goto document_done;

      len = strlen (line);
      if (len + document_index >= document_size)
	{
	  document_size = document_size ? 2 * (document_size + len) : len + 2;
	  document = (char *)xrealloc (document, document_size);
	}

      /* len is guaranteed to be > 0 because of the check for line
	 being an empty string before the call to strlen. */
      FASTCOPY (line, document + document_index, len);
      document_index += len;
    }

  if (full_line == 0)
    internal_warning (_("here-document at line %d delimited by end-of-file (wanted `%s')"), lineno, redir_word);

document_done:
  if (document)
    document[document_index] = '\0';
  else
    {
      document = (char *)xmalloc (1);
      document[0] = '\0';
    }
  temp->redirectee.filename->word = document;
}
warning: parse error {
  int kill_leading, redir_len;
  char *redir_word, *document, *full_line;
  int document_index, document_size, delim_unquoted;

  if (temp->instruction != r_deblank_reading_until &&
      temp->instruction != r_reading_until)
    {
      internal_error (_("make_here_document: bad instruction type %d"), temp->instruction);
      return;
    }

  kill_leading = temp->instruction == r_deblank_reading_until;

  document = (char *)NULL;
  document_index = document_size = 0;

  /* Quote removal is the only expansion performed on the delimiter
     for here documents, making it an extremely special case. */
  redir_word = string_quote_removal (temp->redirectee.filename->word, 0);

  /* redirection_expand will return NULL if the expansion results in
     multiple words or no words.  Check for that here, and just abort
     this here document if it does. */
  if (redir_word)
    redir_len = strlen (redir_word);
  else
    {
      temp->here_doc_eof = (char *)xmalloc (1);
      temp->here_doc_eof[0] = '\0';
      goto document_done;
    }

  free (temp->redirectee.filename->word);
  temp->here_doc_eof = redir_word;

  /* Read lines from wherever lines are coming from.
     For each line read, if kill_leading, then kill the
     leading tab characters.
     If the line matches redir_word exactly, then we have
     manufactured the document.  Otherwise, add the line to the
     list of lines in the document. */

  /* If the here-document delimiter was quoted, the lines should
     be read verbatim from the input.  If it was not quoted, we
     need to perform backslash-quoted newline removal. */
  delim_unquoted = (temp->redirectee.filename->flags & W_QUOTED) == 0;
  while (full_line = read_secondary_line (delim_unquoted))
    {
      register char *line;
      int len;

      line = full_line;
      line_number++;

      /* If set -v is in effect, echo the line read.  read_secondary_line/
	 read_a_line leaves the newline at the end, so don't print another. */
      if (echo_input_at_read)
	fprintf (stderr, "%s", line);

      if (kill_leading && *line)
	{
	  /* Hack:  To be compatible with some Bourne shells, we
	     check the word before stripping the whitespace.  This
	     is a hack, though. */
	  if (STREQN (line, redir_word, redir_len) && line[redir_len] == '\n')
	    goto document_done;

	  while (*line == '\t')
	    line++;
	}

      if (*line == 0)
	continue;

      if (STREQN (line, redir_word, redir_len) && line[redir_len] == '\n')
	goto document_done;

      len = strlen (line);
      if (len + document_index >= document_size)
	{
	  document_size = document_size ? 2 * (document_size + len) : len + 2;
	  document = (char *)xrealloc (document, document_size);
	}

      /* len is guaranteed to be > 0 because of the check for line
	 being an empty string before the call to strlen. */
      FASTCOPY (line, document + document_index, len);
      document_index += len;
    }

  if (full_line == 0)
    internal_warning (_("here-document at line %d delimited by end-of-file (wanted `%s')"), lineno, redir_word);

document_done:
  if (document)
    document[document_index] = '\0';
  else
    {
      document = (char *)xmalloc (1);
      document[0] = '\0';
    }
  temp->redirectee.filename->word = document;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\make_cmd.c:567
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\make_cmd.c:676
parsing error 
{
  REDIRECT *temp;
  WORD_DESC *w;
  int wlen;
  intmax_t lfd;

  temp = (REDIRECT *)xmalloc (sizeof (REDIRECT));

  /* First do the common cases. */
  temp->redirector = source;
  temp->redirectee = dest_and_filename;
  temp->instruction = instruction;
  temp->flags = 0;
  temp->rflags = flags;
  temp->next = (REDIRECT *)NULL;

  switch (instruction)
    {

    case r_output_direction:		/* >foo */
    case r_output_force:		/* >| foo */
    case r_err_and_out:			/* &>filename */
      temp->flags = O_TRUNC | O_WRONLY | O_CREAT;
      break;

    case r_appending_to:		/* >>foo */
    case r_append_err_and_out:		/* &>> filename */
      temp->flags = O_APPEND | O_WRONLY | O_CREAT;
      break;

    case r_input_direction:		/* <foo */
    case r_inputa_direction:		/* foo & makes this. */
      temp->flags = O_RDONLY;
      break;

    case r_input_output:		/* <>foo */
      temp->flags = O_RDWR | O_CREAT;
      break;

    case r_deblank_reading_until: 	/* <<-foo */
    case r_reading_until:		/* << foo */
    case r_reading_string:		/* <<< foo */
    case r_close_this:			/* <&- */
    case r_duplicating_input:		/* 1<&2 */
    case r_duplicating_output:		/* 1>&2 */
      break;

    /* the parser doesn't pass these. */
    case r_move_input:			/* 1<&2- */
    case r_move_output:			/* 1>&2- */
    case r_move_input_word:		/* 1<&$foo- */
    case r_move_output_word:		/* 1>&$foo- */
      break;

    /* The way the lexer works we have to do this here. */
    case r_duplicating_input_word:	/* 1<&$foo */
    case r_duplicating_output_word:	/* 1>&$foo */
      w = dest_and_filename.filename;
      wlen = strlen (w->word) - 1;
      if (w->word[wlen] == '-')		/* Yuck */
        {
          w->word[wlen] = '\0';
	  if (all_digits (w->word) && legal_number (w->word, &lfd) && lfd == (int)lfd)
	    {
	      dispose_word (w);
	      temp->instruction = (instruction == r_duplicating_input_word) ? r_move_input : r_move_output;
	      temp->redirectee.dest = lfd;
	    }
	  else
	    temp->instruction = (instruction == r_duplicating_input_word) ? r_move_input_word : r_move_output_word;
        }
          
      break;

    default:
      programming_error (_("make_redirection: redirection instruction `%d' out of range"), instruction);
      abort ();
      break;
    }
  return (temp);
}
warning: parse error {
  REDIRECT *temp;
  WORD_DESC *w;
  int wlen;
  intmax_t lfd;

  temp = (REDIRECT *)xmalloc (sizeof (REDIRECT));

  /* First do the common cases. */
  temp->redirector = source;
  temp->redirectee = dest_and_filename;
  temp->instruction = instruction;
  temp->flags = 0;
  temp->rflags = flags;
  temp->next = (REDIRECT *)NULL;

  switch (instruction)
    {

    case r_output_direction:		/* >foo */
    case r_output_force:		/* >| foo */
    case r_err_and_out:			/* &>filename */
      temp->flags = O_TRUNC | O_WRONLY | O_CREAT;
      break;

    case r_appending_to:		/* >>foo */
    case r_append_err_and_out:		/* &>> filename */
      temp->flags = O_APPEND | O_WRONLY | O_CREAT;
      break;

    case r_input_direction:		/* <foo */
    case r_inputa_direction:		/* foo & makes this. */
      temp->flags = O_RDONLY;
      break;

    case r_input_output:		/* <>foo */
      temp->flags = O_RDWR | O_CREAT;
      break;

    case r_deblank_reading_until: 	/* <<-foo */
    case r_reading_until:		/* << foo */
    case r_reading_string:		/* <<< foo */
    case r_close_this:			/* <&- */
    case r_duplicating_input:		/* 1<&2 */
    case r_duplicating_output:		/* 1>&2 */
      break;

    /* the parser doesn't pass these. */
    case r_move_input:			/* 1<&2- */
    case r_move_output:			/* 1>&2- */
    case r_move_input_word:		/* 1<&$foo- */
    case r_move_output_word:		/* 1>&$foo- */
      break;

    /* The way the lexer works we have to do this here. */
    case r_duplicating_input_word:	/* 1<&$foo */
    case r_duplicating_output_word:	/* 1>&$foo */
      w = dest_and_filename.filename;
      wlen = strlen (w->word) - 1;
      if (w->word[wlen] == '-')		/* Yuck */
        {
          w->word[wlen] = '\0';
	  if (all_digits (w->word) && legal_number (w->word, &lfd) && lfd == (int)lfd)
	    {
	      dispose_word (w);
	      temp->instruction = (instruction == r_duplicating_input_word) ? r_move_input : r_move_output;
	      temp->redirectee.dest = lfd;
	    }
	  else
	    temp->instruction = (instruction == r_duplicating_input_word) ? r_move_input_word : r_move_output_word;
        }
          
      break;

    default:
      programming_error (_("make_redirection: redirection instruction `%d' out of range"), instruction);
      abort ();
      break;
    }
  return (temp);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\make_cmd.c:681
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\make_cmd.c:764
parsing error 
{
  FUNCTION_DEF *temp;
#if defined (ARRAY_VARS)
  SHELL_VAR *bash_source_v;
  ARRAY *bash_source_a;
#endif

  temp = (FUNCTION_DEF *)xmalloc (sizeof (FUNCTION_DEF));
  temp->command = command;
  temp->name = name;
  temp->line = lineno;
  temp->flags = 0;
  command->line = lstart;

  /* Information used primarily for debugging. */
  temp->source_file = 0;
#if defined (ARRAY_VARS)
  GET_ARRAY_FROM_VAR ("BASH_SOURCE", bash_source_v, bash_source_a);
  if (bash_source_a && array_num_elements (bash_source_a) > 0)
    temp->source_file = array_reference (bash_source_a, 0);
#endif
#if defined (DEBUGGER)
  bind_function_def (name->word, temp);
#endif

  temp->source_file = 0;
  return (make_command (cm_function_def, (SIMPLE_COM *)temp));
}
warning: parse error {
  FUNCTION_DEF *temp;
#if defined (ARRAY_VARS)
  SHELL_VAR *bash_source_v;
  ARRAY *bash_source_a;
#endif

  temp = (FUNCTION_DEF *)xmalloc (sizeof (FUNCTION_DEF));
  temp->command = command;
  temp->name = name;
  temp->line = lineno;
  temp->flags = 0;
  command->line = lstart;

  /* Information used primarily for debugging. */
  temp->source_file = 0;
#if defined (ARRAY_VARS)
  GET_ARRAY_FROM_VAR ("BASH_SOURCE", bash_source_v, bash_source_a);
  if (bash_source_a && array_num_elements (bash_source_a) > 0)
    temp->source_file = array_reference (bash_source_a, 0);
#endif
#if defined (DEBUGGER)
  bind_function_def (name->word, temp);
#endif

  temp->source_file = 0;
  return (make_command (cm_function_def, (SIMPLE_COM *)temp));
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\make_cmd.c:768
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\make_cmd.c:798
parsing error 
{
  SUBSHELL_COM *temp;

  temp = (SUBSHELL_COM *)xmalloc (sizeof (SUBSHELL_COM));
  temp->command = command;
  temp->flags = CMD_WANT_SUBSHELL;
  return (make_command (cm_subshell, (SIMPLE_COM *)temp));
}
warning: parse error {
  SUBSHELL_COM *temp;

  temp = (SUBSHELL_COM *)xmalloc (sizeof (SUBSHELL_COM));
  temp->command = command;
  temp->flags = CMD_WANT_SUBSHELL;
  return (make_command (cm_subshell, (SIMPLE_COM *)temp));
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\make_cmd.c:800
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\make_cmd.c:810
parsing error 
{
  COPROC_COM *temp;

  temp = (COPROC_COM *)xmalloc (sizeof (COPROC_COM));
  temp->name = savestring (name);
  temp->command = command;
  temp->flags = CMD_WANT_SUBSHELL|CMD_COPROC_SUBSHELL;
  return (make_command (cm_coproc, (SIMPLE_COM *)temp));
}
warning: parse error {
  COPROC_COM *temp;

  temp = (COPROC_COM *)xmalloc (sizeof (COPROC_COM));
  temp->name = savestring (name);
  temp->command = command;
  temp->flags = CMD_WANT_SUBSHELL|CMD_COPROC_SUBSHELL;
  return (make_command (cm_coproc, (SIMPLE_COM *)temp));
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\make_cmd.c:813
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\make_cmd.c:827
parsing error 
{
  if (command->type != cm_simple)
    command_error ("clean_simple_command", CMDERR_BADTYPE, command->type, 0);
  else
    {
      command->value.Simple->words =
	REVERSE_LIST (command->value.Simple->words, WORD_LIST *);
      command->value.Simple->redirects =
	REVERSE_LIST (command->value.Simple->redirects, REDIRECT *);
    }

  parser_state &= ~PST_REDIRLIST;
  return (command);
}
warning: parse error {
  if (command->type != cm_simple)
    command_error ("clean_simple_command", CMDERR_BADTYPE, command->type, 0);
  else
    {
      command->value.Simple->words =
	REVERSE_LIST (command->value.Simple->words, WORD_LIST *);
      command->value.Simple->redirects =
	REVERSE_LIST (command->value.Simple->redirects, REDIRECT *);
    }

  parser_state &= ~PST_REDIRLIST;
  return (command);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\make_cmd.c:829
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\make_cmd.c:854
parsing error 
{
  COMMAND *t, *t1, *t2;

  t1 = command;
  t = command->value.Connection->second;

  if (!t || (command->flags & CMD_WANT_SUBSHELL) ||
      command->value.Connection->connector != ';')
    {
      t = command_connect (command, command2, connector);
      return t;
    }

  /* This is just defensive programming.  The Yacc precedence rules
     will generally hand this function a command where t points directly
     to the command we want (e.g. given a ; b ; c ; d &, t1 will point
     to the `a ; b ; c' list and t will be the `d').  We only want to do
     this if the list is not being executed as a unit in the background
     with `( ... )', so we have to check for CMD_WANT_SUBSHELL.  That's
     the only way to tell. */
  while (((t->flags & CMD_WANT_SUBSHELL) == 0) && t->type == cm_connection &&
	 t->value.Connection->connector == ';')
    {
      t1 = t;
      t = t->value.Connection->second;
    }
  /* Now we have t pointing to the last command in the list, and
     t1->value.Connection->second == t. */
  t2 = command_connect (t, command2, connector);
  t1->value.Connection->second = t2;
  return command;
}
warning: parse error {
  COMMAND *t, *t1, *t2;

  t1 = command;
  t = command->value.Connection->second;

  if (!t || (command->flags & CMD_WANT_SUBSHELL) ||
      command->value.Connection->connector != ';')
    {
      t = command_connect (command, command2, connector);
      return t;
    }

  /* This is just defensive programming.  The Yacc precedence rules
     will generally hand this function a command where t points directly
     to the command we want (e.g. given a ; b ; c ; d &, t1 will point
     to the `a ; b ; c' list and t will be the `d').  We only want to do
     this if the list is not being executed as a unit in the background
     with `( ... )', so we have to check for CMD_WANT_SUBSHELL.  That's
     the only way to tell. */
  while (((t->flags & CMD_WANT_SUBSHELL) == 0) && t->type == cm_connection &&
	 t->value.Connection->connector == ';')
    {
      t1 = t;
      t = t->value.Connection->second;
    }
  /* Now we have t pointing to the last command in the list, and
     t1->value.Connection->second == t. */
  t2 = command_connect (t, command2, connector);
  t1->value.Connection->second = t2;
  return command;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\make_cmd.c:857
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\mksyntax.c...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\bashansi.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\chartypes.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\syntax.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\bashtypes.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\mksyntax.c:108
parsing error 
{
  static char xbuf[16];

  if (i == ' ')
    return "SPC";
  else if (ISPRINT (i))
    {
      xbuf[0] = i;
      xbuf[1] = '\0';
      return (xbuf);
    }
  else if (i == CTLESC)
    return "CTLESC";
  else if (i == CTLNUL)
    return "CTLNUL";
  else if (i == '\033')		/* ASCII */
    return "ESC";

  xbuf[0] = '\\';
  xbuf[2] = '\0';
    
  switch (i)
    {
#ifdef __STDC__
    case '\a': xbuf[1] = 'a'; break;
    case '\v': xbuf[1] = 'v'; break;
#else
    case '\007': xbuf[1] = 'a'; break;
    case 0x0B: xbuf[1] = 'v'; break;
#endif
    case '\b': xbuf[1] = 'b'; break;
    case '\f': xbuf[1] = 'f'; break;
    case '\n': xbuf[1] = 'n'; break;
    case '\r': xbuf[1] = 'r'; break;
    case '\t': xbuf[1] = 't'; break;
    default: sprintf (xbuf, "%d", i); break;
    }

  return xbuf;	
}
warning: parse error {
  static char xbuf[16];

  if (i == ' ')
    return "SPC";
  else if (ISPRINT (i))
    {
      xbuf[0] = i;
      xbuf[1] = '\0';
      return (xbuf);
    }
  else if (i == CTLESC)
    return "CTLESC";
  else if (i == CTLNUL)
    return "CTLNUL";
  else if (i == '\033')		/* ASCII */
    return "ESC";

  xbuf[0] = '\\';
  xbuf[2] = '\0';
    
  switch (i)
    {
#ifdef __STDC__
    case '\a': xbuf[1] = 'a'; break;
    case '\v': xbuf[1] = 'v'; break;
#else
    case '\007': xbuf[1] = 'a'; break;
    case 0x0B: xbuf[1] = 'v'; break;
#endif
    case '\b': xbuf[1] = 'b'; break;
    case '\f': xbuf[1] = 'f'; break;
    case '\n': xbuf[1] = 'n'; break;
    case '\r': xbuf[1] = 'r'; break;
    case '\t': xbuf[1] = 't'; break;
    default: sprintf (xbuf, "%d", i); break;
    }

  return xbuf;	
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\mksyntax.c:110
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\mksyntax.c:152
parsing error 
{
  int i;

  for (i = 0; i < N_WFLAGS; i++)
    if (f == wordflags[i].flag)
      return (wordflags[i].fstr);
  return ((char *)NULL);
}
warning: parse error {
  int i;

  for (i = 0; i < N_WFLAGS; i++)
    if (f == wordflags[i].flag)
      return (wordflags[i].fstr);
  return ((char *)NULL);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\mksyntax.c:154
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\mksyntax.c:164
parsing error 
{
  char *s, *fstr;
  unsigned char uc;

  for (s = str; s && *s; s++)
    {
      uc = *s;

      if (debug)
	{
	  fstr = getcstr (flag);
	  fprintf(stderr, "added %s for character %s\n", fstr, cdesc(uc));
	}
	
      lsyntax[uc] |= flag;
    }
}
warning: parse error {
  char *s, *fstr;
  unsigned char uc;

  for (s = str; s && *s; s++)
    {
      uc = *s;

      if (debug)
	{
	  fstr = getcstr (flag);
	  fprintf(stderr, "added %s for character %s\n", fstr, cdesc(uc));
	}
	
      lsyntax[uc] |= flag;
    }
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\mksyntax.c:167
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\mksyntax.c:186
parsing error 
{
  char *fstr;

  if (debug)
    {
      fstr = getcstr (flag);
      fprintf (stderr, "added %s for character %s\n", fstr, cdesc(c));
    }
  lsyntax[c] |= flag;
}
warning: parse error {
  char *fstr;

  if (debug)
    {
      fstr = getcstr (flag);
      fprintf (stderr, "added %s for character %s\n", fstr, cdesc(c));
    }
  lsyntax[c] |= flag;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\mksyntax.c:189
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\mksyntax.c:255
parsing error 
{
  int xflags, first, i;

  xflags = lsyntax[ind];
  first = 1;

  if (xflags == 0)
    fputs (wordflags[0].fstr, fp);
  else
    {
      for (i = 1; i < N_WFLAGS; i++)
	if (xflags & wordflags[i].flag)
	  {
	    if (first)
	      first = 0;
	    else
	      putc ('|', fp);
	    fputs (wordflags[i].fstr, fp);
  	  }
    }
}
warning: parse error {
  int xflags, first, i;

  xflags = lsyntax[ind];
  first = 1;

  if (xflags == 0)
    fputs (wordflags[0].fstr, fp);
  else
    {
      for (i = 1; i < N_WFLAGS; i++)
	if (xflags & wordflags[i].flag)
	  {
	    if (first)
	      first = 0;
	    else
	      putc ('|', fp);
	    fputs (wordflags[i].fstr, fp);
  	  }
    }
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\mksyntax.c:258
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\mksyntax.c:281
parsing error 
{
  fputs ("\t\t/* ", fp);

  fprintf (fp, "%s", cdesc(i));
      
  fputs (" */", fp);
}
warning: parse error {
  fputs ("\t\t/* ", fp);

  fprintf (fp, "%s", cdesc(i));
      
  fputs (" */", fp);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\mksyntax.c:284
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\mksyntax.c:293
parsing error 
{
  int i;

  fprintf (fp, "int sh_syntabsiz = %d;\n", SYNSIZE);
  fprintf (fp, "int sh_syntaxtab[%d] = {\n", SYNSIZE);

  for (i = 0; i < SYNSIZE; i++)
    {
      putc ('\t', fp);
      dump_lflags (fp, i);
      putc (',', fp);
      wcomment (fp, i);
      putc ('\n', fp);
    }

  fprintf (fp, "};\n");
}
warning: parse error {
  int i;

  fprintf (fp, "int sh_syntabsiz = %d;\n", SYNSIZE);
  fprintf (fp, "int sh_syntaxtab[%d] = {\n", SYNSIZE);

  for (i = 0; i < SYNSIZE; i++)
    {
      putc ('\t', fp);
      dump_lflags (fp, i);
      putc (',', fp);
      wcomment (fp, i);
      putc ('\n', fp);
    }

  fprintf (fp, "};\n");
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\mksyntax.c:295
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\mksyntax.c:314
parsing error 
{
  int opt, i;
  char *filename;
  FILE *fp;

  if ((progname = strrchr (argv[0], '/')) == 0)
    progname = argv[0];
  else
    progname++;

  filename = (char *)NULL;
  debug = 0;

  while ((opt = getopt (argc, argv, "do:")) != EOF)
    {
      switch (opt)
	{
	case 'd':
	  debug = 1;
	  break;
	case 'o':
	  filename = optarg;
	  break;
	default:
	  usage();
	}
    }

  argc -= optind;
  argv += optind;

  if (filename)
    {
      fp = fopen (filename, "w");
      if (fp == 0)
	{
	  fprintf (stderr, "%s: %s: cannot open: %s\n", progname, filename, strerror(errno));
	  exit (1);
	}
    }
  else
    {
      filename = "stdout";
      fp = stdout;
    }


  for (i = 0; i < SYNSIZE; i++)
    lsyntax[i] = CWORD;

  load_lsyntax ();

  fprintf (fp, "%s\n", preamble);
  fprintf (fp, "%s\n", includes);

  dump_lsyntax (fp);

  if (fp != stdout)
    fclose (fp);
  exit (0);
}
warning: parse error {
  int opt, i;
  char *filename;
  FILE *fp;

  if ((progname = strrchr (argv[0], '/')) == 0)
    progname = argv[0];
  else
    progname++;

  filename = (char *)NULL;
  debug = 0;

  while ((opt = getopt (argc, argv, "do:")) != EOF)
    {
      switch (opt)
	{
	case 'd':
	  debug = 1;
	  break;
	case 'o':
	  filename = optarg;
	  break;
	default:
	  usage();
	}
    }

  argc -= optind;
  argv += optind;

  if (filename)
    {
      fp = fopen (filename, "w");
      if (fp == 0)
	{
	  fprintf (stderr, "%s: %s: cannot open: %s\n", progname, filename, strerror(errno));
	  exit (1);
	}
    }
  else
    {
      filename = "stdout";
      fp = stdout;
    }


  for (i = 0; i < SYNSIZE; i++)
    lsyntax[i] = CWORD;

  load_lsyntax ();

  fprintf (fp, "%s\n", preamble);
  fprintf (fp, "%s\n", includes);

  dump_lsyntax (fp);

  if (fp != stdout)
    fclose (fp);
  exit (0);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\mksyntax.c:317
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\mksyntax.c:398
parsing error 
{
  static char emsg[40];
#if defined (HAVE_SYS_ERRLIST)
  extern int sys_nerr;
  extern char *sys_errlist[];

  if (e > 0 && e < sys_nerr)
    return (sys_errlist[e]);
  else
#endif /* HAVE_SYS_ERRLIST */
    {
      sprintf (emsg, "Unknown system error %d", e);
      return (&emsg[0]);
    }
}
warning: parse error {
  static char emsg[40];
#if defined (HAVE_SYS_ERRLIST)
  extern int sys_nerr;
  extern char *sys_errlist[];

  if (e > 0 && e < sys_nerr)
    return (sys_errlist[e]);
  else
#endif /* HAVE_SYS_ERRLIST */
    {
      sprintf (emsg, "Unknown system error %d", e);
      return (&emsg[0]);
    }
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\mksyntax.c:400
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\nojobs.c...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\bashtypes.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\filecntl.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\shtty.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\bashintl.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\shell.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\jobs.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\execute_cmd.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\nojobs.c:185
parsing error 
{
  register int i;

  for (i = 0; i < pid_list_size; i++)
    if (pid_list[i].pid == pid)
      return (i);

  return (NO_PID);
}
warning: parse error {
  register int i;

  for (i = 0; i < pid_list_size; i++)
    if (pid_list[i].pid == pid)
      return (i);

  return (NO_PID);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\nojobs.c:187
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\nojobs.c:200
parsing error 
{
  int i;

  i = find_index_by_pid (pid);
  if (i == NO_PID)
    return (PROC_BAD);
  if (pid_list[i].flags & PROC_RUNNING)
    return (PROC_STILL_ALIVE);
  return (pid_list[i].status);
}
warning: parse error {
  int i;

  i = find_index_by_pid (pid);
  if (i == NO_PID)
    return (PROC_BAD);
  if (pid_list[i].flags & PROC_RUNNING)
    return (PROC_STILL_ALIVE);
  return (pid_list[i].status);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\nojobs.c:202
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\nojobs.c:214
parsing error 
{
  if (WIFSIGNALED (status))
    return (128 + WTERMSIG (status));
  else
    return (WEXITSTATUS (status));
}
warning: parse error {
  if (WIFSIGNALED (status))
    return (128 + WTERMSIG (status));
  else
    return (WEXITSTATUS (status));
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\nojobs.c:216
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\nojobs.c:226
parsing error 
{
  int i;

  i = find_index_by_pid (pid);
  if (i == NO_PID)
    return (0);
  if (pid_list[i].flags & PROC_RUNNING)
    return (0);
  return (get_termsig ((WAIT)pid_list[i].status));
}
warning: parse error {
  int i;

  i = find_index_by_pid (pid);
  if (i == NO_PID)
    return (0);
  if (pid_list[i].flags & PROC_RUNNING)
    return (0);
  return (get_termsig ((WAIT)pid_list[i].status));
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\nojobs.c:228
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\nojobs.c:243
parsing error 
{
  if (WIFSTOPPED (status) == 0 && WIFSIGNALED (status))
    return (WTERMSIG (status));
  else
    return (0);
}
warning: parse error {
  if (WIFSTOPPED (status) == 0 && WIFSIGNALED (status))
    return (WTERMSIG (status));
  else
    return (0);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\nojobs.c:245
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\nojobs.c:254
parsing error 
{
  int slot;

#if defined (COPROCESS_SUPPORT)
  coproc_pidchk (pid, status);
#endif

  slot = find_index_by_pid (pid);
  if (slot == NO_PID)
    return;

  pid_list[slot].status = process_exit_status (status);
  pid_list[slot].flags &= ~PROC_RUNNING;
  if (WIFSIGNALED (status))
    pid_list[slot].flags |= PROC_SIGNALED;
  /* If it's not a background process, mark it as notified so it gets
     cleaned up. */
  if ((pid_list[slot].flags & PROC_ASYNC) == 0)
    pid_list[slot].flags |= PROC_NOTIFIED;
}
warning: parse error {
  int slot;

#if defined (COPROCESS_SUPPORT)
  coproc_pidchk (pid, status);
#endif

  slot = find_index_by_pid (pid);
  if (slot == NO_PID)
    return;

  pid_list[slot].status = process_exit_status (status);
  pid_list[slot].flags &= ~PROC_RUNNING;
  if (WIFSIGNALED (status))
    pid_list[slot].flags |= PROC_SIGNALED;
  /* If it's not a background process, mark it as notified so it gets
     cleaned up. */
  if ((pid_list[slot].flags & PROC_ASYNC) == 0)
    pid_list[slot].flags |= PROC_NOTIFIED;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\nojobs.c:257
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\nojobs.c:280
parsing error 
{
  int slot;

  slot = find_index_by_pid (pid);
  if (slot == NO_PID)
    return;

  pid_list[slot].flags |= flags;
}
warning: parse error {
  int slot;

  slot = find_index_by_pid (pid);
  if (slot == NO_PID)
    return;

  pid_list[slot].flags |= flags;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\nojobs.c:283
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\nojobs.c:295
parsing error 
{
  int slot;

  slot = find_index_by_pid (pid);
  if (slot == NO_PID)
    return;

  pid_list[slot].flags &= ~flags;
}
warning: parse error {
  int slot;

  slot = find_index_by_pid (pid);
  if (slot == NO_PID)
    return;

  pid_list[slot].flags &= ~flags;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\nojobs.c:298
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\nojobs.c:310
parsing error 
{
  int slot;

  slot = find_index_by_pid (pid);
  if (slot == NO_PID)
    return 0;

  return (pid_list[slot].flags);
}
warning: parse error {
  int slot;

  slot = find_index_by_pid (pid);
  if (slot == NO_PID)
    return 0;

  return (pid_list[slot].flags);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\nojobs.c:312
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\nojobs.c:323
parsing error 
{
  int slot;

  slot = find_proc_slot ();

  pid_list[slot].pid = pid;
  pid_list[slot].status = -1;
  pid_list[slot].flags = PROC_RUNNING;
  if (async)
    pid_list[slot].flags |= PROC_ASYNC;
}
warning: parse error {
  int slot;

  slot = find_proc_slot ();

  pid_list[slot].pid = pid;
  pid_list[slot].status = -1;
  pid_list[slot].flags = PROC_RUNNING;
  if (async)
    pid_list[slot].flags |= PROC_ASYNC;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\nojobs.c:326
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\nojobs.c:339
parsing error 
{
  register int i, ndead;

  /* first, count the number of non-running async jobs if FORCE == 0 */
  for (i = ndead = 0; force == 0 && i < pid_list_size; i++)
    {
      if (pid_list[i].pid == NO_PID)
	continue;
      if (((pid_list[i].flags & PROC_RUNNING) == 0) &&
	   (pid_list[i].flags & PROC_ASYNC))
	ndead++;
    }

  if (child_max < 0)
    child_max = getmaxchild ();
  if (child_max < 0)
    child_max = DEFAULT_CHILD_MAX;

  if (force == 0 && ndead <= child_max)
    return;

  /* If FORCE == 0, we just mark as many non-running async jobs as notified
     to bring us under the CHILD_MAX limit. */
  for (i = 0; i < pid_list_size; i++)
    {
      if (pid_list[i].pid == NO_PID)
	continue;
      if (((pid_list[i].flags & PROC_RUNNING) == 0) &&
	   pid_list[i].pid != last_asynchronous_pid)
	{
	  pid_list[i].flags |= PROC_NOTIFIED;
	  if (force == 0 && (pid_list[i].flags & PROC_ASYNC) && --ndead <= child_max)
	    break;
	}
    }
}
warning: parse error {
  register int i, ndead;

  /* first, count the number of non-running async jobs if FORCE == 0 */
  for (i = ndead = 0; force == 0 && i < pid_list_size; i++)
    {
      if (pid_list[i].pid == NO_PID)
	continue;
      if (((pid_list[i].flags & PROC_RUNNING) == 0) &&
	   (pid_list[i].flags & PROC_ASYNC))
	ndead++;
    }

  if (child_max < 0)
    child_max = getmaxchild ();
  if (child_max < 0)
    child_max = DEFAULT_CHILD_MAX;

  if (force == 0 && ndead <= child_max)
    return;

  /* If FORCE == 0, we just mark as many non-running async jobs as notified
     to bring us under the CHILD_MAX limit. */
  for (i = 0; i < pid_list_size; i++)
    {
      if (pid_list[i].pid == NO_PID)
	continue;
      if (((pid_list[i].flags & PROC_RUNNING) == 0) &&
	   pid_list[i].pid != last_asynchronous_pid)
	{
	  pid_list[i].flags |= PROC_NOTIFIED;
	  if (force == 0 && (pid_list[i].flags & PROC_ASYNC) && --ndead <= child_max)
	    break;
	}
    }
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\nojobs.c:341
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\nojobs.c:410
parsing error 
{
  shell_tty = fileno (stderr);

  if (interactive)
    get_tty_state ();
}
warning: parse error {
  shell_tty = fileno (stderr);

  if (interactive)
    get_tty_state ();
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\nojobs.c:412
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\nojobs.c:472
parsing error 
{
  pid_t pid;
  int forksleep;

  /* Discard saved memory. */
  if (command)
    free (command);

  start_pipeline ();

#if defined (BUFFERED_INPUT)
  /* If default_buffered_input is active, we are reading a script.  If
     the command is asynchronous, we have already duplicated /dev/null
     as fd 0, but have not changed the buffered stream corresponding to
     the old fd 0.  We don't want to sync the stream in this case. */
  if (default_buffered_input != -1 && (!async_p || default_buffered_input > 0))
    sync_buffered_stream (default_buffered_input);
#endif /* BUFFERED_INPUT */

  /* Create the child, handle severe errors.  Retry on EAGAIN. */
  forksleep = 1;
  while ((pid = fork ()) < 0 && errno == EAGAIN && forksleep < FORKSLEEP_MAX)
    {
      sys_error ("fork: retry");
#if defined (HAVE_WAITPID)
      /* Posix systems with a non-blocking waitpid () system call available
	 get another chance after zombies are reaped. */
      reap_zombie_children ();
      if (forksleep > 1 && sleep (forksleep) != 0)
        break;
#else
      if (sleep (forksleep) != 0)
	break;
#endif /* HAVE_WAITPID */
      forksleep <<= 1;
    }

  if (pid < 0)
    {
      sys_error ("fork");
      throw_to_top_level ();
    }

  if (pid == 0)
    {
#if defined (BUFFERED_INPUT)
      unset_bash_input (0);
#endif /* BUFFERED_INPUT */

#if defined (HAVE_POSIX_SIGNALS)
      /* Restore top-level signal mask. */
      sigprocmask (SIG_SETMASK, &top_level_mask, (sigset_t *)NULL);
#endif

#if 0
      /* Ignore INT and QUIT in asynchronous children. */
      if (async_p)
	last_asynchronous_pid = getpid ();
#endif

      default_tty_job_signals ();
    }
  else
    {
      /* In the parent. */

      last_made_pid = pid;

      if (async_p)
	last_asynchronous_pid = pid;

      add_pid (pid, async_p);
    }
  return (pid);
}
warning: parse error {
  pid_t pid;
  int forksleep;

  /* Discard saved memory. */
  if (command)
    free (command);

  start_pipeline ();

#if defined (BUFFERED_INPUT)
  /* If default_buffered_input is active, we are reading a script.  If
     the command is asynchronous, we have already duplicated /dev/null
     as fd 0, but have not changed the buffered stream corresponding to
     the old fd 0.  We don't want to sync the stream in this case. */
  if (default_buffered_input != -1 && (!async_p || default_buffered_input > 0))
    sync_buffered_stream (default_buffered_input);
#endif /* BUFFERED_INPUT */

  /* Create the child, handle severe errors.  Retry on EAGAIN. */
  forksleep = 1;
  while ((pid = fork ()) < 0 && errno == EAGAIN && forksleep < FORKSLEEP_MAX)
    {
      sys_error ("fork: retry");
#if defined (HAVE_WAITPID)
      /* Posix systems with a non-blocking waitpid () system call available
	 get another chance after zombies are reaped. */
      reap_zombie_children ();
      if (forksleep > 1 && sleep (forksleep) != 0)
        break;
#else
      if (sleep (forksleep) != 0)
	break;
#endif /* HAVE_WAITPID */
      forksleep <<= 1;
    }

  if (pid < 0)
    {
      sys_error ("fork");
      throw_to_top_level ();
    }

  if (pid == 0)
    {
#if defined (BUFFERED_INPUT)
      unset_bash_input (0);
#endif /* BUFFERED_INPUT */

#if defined (HAVE_POSIX_SIGNALS)
      /* Restore top-level signal mask. */
      sigprocmask (SIG_SETMASK, &top_level_mask, (sigset_t *)NULL);
#endif

#if 0
      /* Ignore INT and QUIT in asynchronous children. */
      if (async_p)
	last_asynchronous_pid = getpid ();
#endif

      default_tty_job_signals ();
    }
  else
    {
      /* In the parent. */

      last_made_pid = pid;

      if (async_p)
	last_asynchronous_pid = pid;

      add_pid (pid, async_p);
    }
  return (pid);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\nojobs.c:475
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\nojobs.c:574
parsing error 
{
  pid_t got_pid;
  WAIT status;
  int pstatus, flags;

  pstatus = find_status_by_pid (pid);

  if (pstatus == PROC_BAD)
    {
      internal_error (_("wait: pid %ld is not a child of this shell"), (long)pid);
      return (127);
    }

  if (pstatus != PROC_STILL_ALIVE)
    {
      if (pstatus > 128)
	last_command_exit_signal = find_termsig_by_pid (pid);
      return (pstatus);
    }

  siginterrupt (SIGINT, 1);
  while ((got_pid = WAITPID (pid, &status, 0)) != pid)
    {
      CHECK_TERMSIG;
      if (got_pid < 0)
	{
	  if (errno != EINTR && errno != ECHILD)
	    {
	      siginterrupt (SIGINT, 0);
	      sys_error ("wait");
	    }
	  break;
	}
      else if (got_pid > 0)
	set_pid_status (got_pid, status);
    }

  if (got_pid > 0)
    {
      set_pid_status (got_pid, status);
      set_pid_flags (got_pid, PROC_NOTIFIED);
    }

  siginterrupt (SIGINT, 0);
  QUIT;

  return (got_pid > 0 ? process_exit_status (status) : -1);
}
warning: parse error {
  pid_t got_pid;
  WAIT status;
  int pstatus, flags;

  pstatus = find_status_by_pid (pid);

  if (pstatus == PROC_BAD)
    {
      internal_error (_("wait: pid %ld is not a child of this shell"), (long)pid);
      return (127);
    }

  if (pstatus != PROC_STILL_ALIVE)
    {
      if (pstatus > 128)
	last_command_exit_signal = find_termsig_by_pid (pid);
      return (pstatus);
    }

  siginterrupt (SIGINT, 1);
  while ((got_pid = WAITPID (pid, &status, 0)) != pid)
    {
      CHECK_TERMSIG;
      if (got_pid < 0)
	{
	  if (errno != EINTR && errno != ECHILD)
	    {
	      siginterrupt (SIGINT, 0);
	      sys_error ("wait");
	    }
	  break;
	}
      else if (got_pid > 0)
	set_pid_status (got_pid, status);
    }

  if (got_pid > 0)
    {
      set_pid_status (got_pid, status);
      set_pid_flags (got_pid, PROC_NOTIFIED);
    }

  siginterrupt (SIGINT, 0);
  QUIT;

  return (got_pid > 0 ? process_exit_status (status) : -1);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\nojobs.c:576
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\nojobs.c:675
parsing error 
{
  SigHandler *sigint_handler;

  /* If we got a SIGINT while in `wait', and SIGINT is trapped, do
     what POSIX.2 says (see builtins/wait.def for more info). */
  if (this_shell_builtin && this_shell_builtin == wait_builtin &&
      signal_is_trapped (SIGINT) &&
      ((sigint_handler = trap_to_sighandler (SIGINT)) == trap_handler))
    {
      last_command_exit_value = EXECUTION_FAILURE;
      restore_sigint_handler ();
      interrupt_immediately = 0;
      trap_handler (SIGINT);	/* set pending_traps[SIGINT] */
      wait_signal_received = SIGINT;
      longjmp (wait_intr_buf, 1);
    }

  if (interrupt_immediately)
    {
      last_command_exit_value = EXECUTION_FAILURE;
      restore_sigint_handler ();
      ADDINTERRUPT;
      QUIT;
    }

  wait_sigint_received = 1;

  SIGRETURN (0);
}
warning: parse error {
  SigHandler *sigint_handler;

  /* If we got a SIGINT while in `wait', and SIGINT is trapped, do
     what POSIX.2 says (see builtins/wait.def for more info). */
  if (this_shell_builtin && this_shell_builtin == wait_builtin &&
      signal_is_trapped (SIGINT) &&
      ((sigint_handler = trap_to_sighandler (SIGINT)) == trap_handler))
    {
      last_command_exit_value = EXECUTION_FAILURE;
      restore_sigint_handler ();
      interrupt_immediately = 0;
      trap_handler (SIGINT);	/* set pending_traps[SIGINT] */
      wait_signal_received = SIGINT;
      longjmp (wait_intr_buf, 1);
    }

  if (interrupt_immediately)
    {
      last_command_exit_value = EXECUTION_FAILURE;
      restore_sigint_handler ();
      ADDINTERRUPT;
      QUIT;
    }

  wait_sigint_received = 1;

  SIGRETURN (0);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\nojobs.c:677
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\nojobs.c:708
parsing error 
{
  static char retcode_name_buffer[64] = { '\0' };
  char *x;

  x = strsignal (s);
  if (x == 0)
    {
      x = retcode_name_buffer;
      sprintf (x, "Signal %d", s);
    }
  return x;
}
warning: parse error {
  static char retcode_name_buffer[64] = { '\0' };
  char *x;

  x = strsignal (s);
  if (x == 0)
    {
      x = retcode_name_buffer;
      sprintf (x, "Signal %d", s);
    }
  return x;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\nojobs.c:710
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\nojobs.c:726
parsing error 
{
  int return_val, pstatus;
  pid_t got_pid;
  WAIT status;

  pstatus = find_status_by_pid (pid);

  if (pstatus == PROC_BAD)
    return (0);

  if (pstatus != PROC_STILL_ALIVE)
    {
      if (pstatus > 128)
	last_command_exit_signal = find_termsig_by_pid (pid);
      return (pstatus);
    }

  /* If we are running a script, ignore SIGINT while we're waiting for
     a child to exit.  The loop below does some of this, but not all. */
  wait_sigint_received = 0;
  if (interactive_shell == 0)
    old_sigint_handler = set_signal_handler (SIGINT, wait_sigint_handler);

  while ((got_pid = WAITPID (-1, &status, 0)) != pid) /* XXX was pid now -1 */
    {
      CHECK_TERMSIG;
      if (got_pid < 0 && errno == ECHILD)
	{
#if !defined (_POSIX_VERSION)
	  status.w_termsig = status.w_retcode = 0;
#else
	  status = 0;
#endif /* _POSIX_VERSION */
	  break;
	}
      else if (got_pid < 0 && errno != EINTR)
	programming_error ("wait_for(%ld): %s", (long)pid, strerror(errno));
      else if (got_pid > 0)
	set_pid_status (got_pid, status);
    }

  if (got_pid > 0)
    set_pid_status (got_pid, status);

#if defined (HAVE_WAITPID)
  if (got_pid >= 0)
    reap_zombie_children ();
#endif /* HAVE_WAITPID */

  if (interactive_shell == 0)
    {
      SigHandler *temp_handler;

      temp_handler = old_sigint_handler;
      restore_sigint_handler ();

      /* If the job exited because of SIGINT, make sure the shell acts as if
	 it had received one also. */
      if (WIFSIGNALED (status) && (WTERMSIG (status) == SIGINT))
	{

	  if (maybe_call_trap_handler (SIGINT) == 0)
	    {
	      if (temp_handler == SIG_DFL)
		termsig_handler (SIGINT);
	      else if (temp_handler != INVALID_SIGNAL_HANDLER && temp_handler != SIG_IGN)
		(*temp_handler) (SIGINT);
	    }
	}
    }

  /* Default return value. */
  /* ``a full 8 bits of status is returned'' */
  return_val = process_exit_status (status);
  last_command_exit_signal = get_termsig (status);

#if !defined (DONT_REPORT_SIGPIPE)
  if ((WIFSTOPPED (status) == 0) && WIFSIGNALED (status) &&
	(WTERMSIG (status) != SIGINT))
#else
  if ((WIFSTOPPED (status) == 0) && WIFSIGNALED (status) &&
	(WTERMSIG (status) != SIGINT) && (WTERMSIG (status) != SIGPIPE))
#endif
    {
      fprintf (stderr, "%s", j_strsignal (WTERMSIG (status)));
      if (WIFCORED (status))
	fprintf (stderr, _(" (core dumped)"));
      fprintf (stderr, "\n");
    }

  if (interactive_shell && subshell_environment == 0)
    {
      if (WIFSIGNALED (status) || WIFSTOPPED (status))
	set_tty_state ();
      else
	get_tty_state ();
    }

  return (return_val);
}
warning: parse error {
  int return_val, pstatus;
  pid_t got_pid;
  WAIT status;

  pstatus = find_status_by_pid (pid);

  if (pstatus == PROC_BAD)
    return (0);

  if (pstatus != PROC_STILL_ALIVE)
    {
      if (pstatus > 128)
	last_command_exit_signal = find_termsig_by_pid (pid);
      return (pstatus);
    }

  /* If we are running a script, ignore SIGINT while we're waiting for
     a child to exit.  The loop below does some of this, but not all. */
  wait_sigint_received = 0;
  if (interactive_shell == 0)
    old_sigint_handler = set_signal_handler (SIGINT, wait_sigint_handler);

  while ((got_pid = WAITPID (-1, &status, 0)) != pid) /* XXX was pid now -1 */
    {
      CHECK_TERMSIG;
      if (got_pid < 0 && errno == ECHILD)
	{
#if !defined (_POSIX_VERSION)
	  status.w_termsig = status.w_retcode = 0;
#else
	  status = 0;
#endif /* _POSIX_VERSION */
	  break;
	}
      else if (got_pid < 0 && errno != EINTR)
	programming_error ("wait_for(%ld): %s", (long)pid, strerror(errno));
      else if (got_pid > 0)
	set_pid_status (got_pid, status);
    }

  if (got_pid > 0)
    set_pid_status (got_pid, status);

#if defined (HAVE_WAITPID)
  if (got_pid >= 0)
    reap_zombie_children ();
#endif /* HAVE_WAITPID */

  if (interactive_shell == 0)
    {
      SigHandler *temp_handler;

      temp_handler = old_sigint_handler;
      restore_sigint_handler ();

      /* If the job exited because of SIGINT, make sure the shell acts as if
	 it had received one also. */
      if (WIFSIGNALED (status) && (WTERMSIG (status) == SIGINT))
	{

	  if (maybe_call_trap_handler (SIGINT) == 0)
	    {
	      if (temp_handler == SIG_DFL)
		termsig_handler (SIGINT);
	      else if (temp_handler != INVALID_SIGNAL_HANDLER && temp_handler != SIG_IGN)
		(*temp_handler) (SIGINT);
	    }
	}
    }

  /* Default return value. */
  /* ``a full 8 bits of status is returned'' */
  return_val = process_exit_status (status);
  last_command_exit_signal = get_termsig (status);

#if !defined (DONT_REPORT_SIGPIPE)
  if ((WIFSTOPPED (status) == 0) && WIFSIGNALED (status) &&
	(WTERMSIG (status) != SIGINT))
#else
  if ((WIFSTOPPED (status) == 0) && WIFSIGNALED (status) &&
	(WTERMSIG (status) != SIGINT) && (WTERMSIG (status) != SIGPIPE))
#endif
    {
      fprintf (stderr, "%s", j_strsignal (WTERMSIG (status)));
      if (WIFCORED (status))
	fprintf (stderr, _(" (core dumped)"));
      fprintf (stderr, "\n");
    }

  if (interactive_shell && subshell_environment == 0)
    {
      if (WIFSIGNALED (status) || WIFSTOPPED (status))
	set_tty_state ();
      else
	get_tty_state ();
    }

  return (return_val);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\nojobs.c:728
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\nojobs.c:832
parsing error 
{
  int result;

  if (pid < -1)
    {
      pid = -pid;
      group = 1;
    }
  result = group ? killpg (pid, signal) : kill (pid, signal);
  return (result);
}
warning: parse error {
  int result;

  if (pid < -1)
    {
      pid = -pid;
      group = 1;
    }
  result = group ? killpg (pid, signal) : kill (pid, signal);
  return (result);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\nojobs.c:835
parsing error 
get_tty_state ()
{
  int tty;

  tty = input_tty ();
  if (tty != -1)
    {
      ttgetattr (tty, &shell_tty_info);
      got_tty_state = 1;
      if (check_window_size)
	get_new_window_size (0, (int *)0, (int *)0);
    }
}
warning: parse error get_tty_state ()
{
  int tty;

  tty = input_tty ();
  if (tty != -1)
    {
      ttgetattr (tty, &shell_tty_info);
      got_tty_state = 1;
      if (check_window_size)
	get_new_window_size (0, (int *)0, (int *)0);
    }
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\nojobs.c:851
parsing error 
give_terminal_to (pgrp, force)
     pid_t pgrp;
warning: parse error give_terminal_to (pgrp, force)
     pid_t pgrp;Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\nojobs.c:882
parsing error 
{
}
warning: parse error {
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\nojobs.c:885
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\nojobs.c:890
parsing error 
{
  already_making_children = 0;
  return 0;
}
warning: parse error {
  already_making_children = 0;
  return 0;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\nojobs.c:893
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\nojobs.c:911
parsing error 
{
  int i;

  i = find_index_by_pid (pid);
  return ((i == NO_PID) ? PROC_BAD : i);
}
warning: parse error {
  int i;

  i = find_index_by_pid (pid);
  return ((i == NO_PID) ? PROC_BAD : i);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\nojobs.c:914
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\nojobs.c:923
parsing error 
{
  fprintf (stderr, "%ld\n", (long) pid);
}
warning: parse error {
  fprintf (stderr, "%ld\n", (long) pid);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\nojobs.c:925
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\pathexp.c...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\bashtypes.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\bashansi.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\shell.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\pathexp.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\flags.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\shmbutil.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\bashintl.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\glob\strmatch.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\pathexp.c:63
parsing error 
{
  register int c;
  char *send;
  int open;

  DECLARE_MBSTATE;

  open = 0;
  send = string + strlen (string);

  while (c = *string++)
    {
      switch (c)
	{
	case '?':
	case '*':
	  return (1);

	case '[':
	  open++;
	  continue;

	case ']':
	  if (open)
	    return (1);
	  continue;

	case '+':
	case '@':
	case '!':
	  if (*string == '(')	/*)*/
	    return (1);
	  continue;

	case CTLESC:
	case '\\':
	  if (*string++ == '\0')
	    return (0);
	}

      /* Advance one fewer byte than an entire multibyte character to
	 account for the auto-increment in the loop above. */
#ifdef HANDLE_MULTIBYTE
      string--;
      ADVANCE_CHAR_P (string, send - string);
      string++;
#else
      ADVANCE_CHAR_P (string, send - string);
#endif
    }
  return (0);
}
warning: parse error {
  register int c;
  char *send;
  int open;

  DECLARE_MBSTATE;

  open = 0;
  send = string + strlen (string);

  while (c = *string++)
    {
      switch (c)
	{
	case '?':
	case '*':
	  return (1);

	case '[':
	  open++;
	  continue;

	case ']':
	  if (open)
	    return (1);
	  continue;

	case '+':
	case '@':
	case '!':
	  if (*string == '(')	/*)*/
	    return (1);
	  continue;

	case CTLESC:
	case '\\':
	  if (*string++ == '\0')
	    return (0);
	}

      /* Advance one fewer byte than an entire multibyte character to
	 account for the auto-increment in the loop above. */
#ifdef HANDLE_MULTIBYTE
      string--;
      ADVANCE_CHAR_P (string, send - string);
      string++;
#else
      ADVANCE_CHAR_P (string, send - string);
#endif
    }
  return (0);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\pathexp.c:65
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\pathexp.c:121
parsing error 
{
  switch (c)
    {
    case '.':
    case '[':
    case '\\':
    case '(':
    case ')':
    case '*':
    case '+':
    case '?':
    case '{':
    case '|':
    case '^':
    case '$':
      return 1;
    default: 
      return 0;
    }
  return (0);
}
warning: parse error {
  switch (c)
    {
    case '.':
    case '[':
    case '\\':
    case '(':
    case ')':
    case '*':
    case '+':
    case '?':
    case '{':
    case '|':
    case '^':
    case '$':
      return 1;
    default: 
      return 0;
    }
  return (0);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\pathexp.c:123
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\pathexp.c:147
parsing error 
{
  switch (*s)
    {
    case '*':
    case '[':
    case ']':
    case '?':
    case '\\':
      return 1;
    case '+':
    case '@':
    case '!':
      if (s[1] == '(')        /*(*/
	return 1;
      break;
    }
  return 0;
}
warning: parse error {
  switch (*s)
    {
    case '*':
    case '[':
    case ']':
    case '?':
    case '\\':
      return 1;
    case '+':
    case '@':
    case '!':
      if (s[1] == '(')        /*(*/
	return 1;
      break;
    }
  return 0;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\pathexp.c:148
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\pathexp.c:179
parsing error 
{
  char *temp;
  register int i, j;

  temp = (char *)xmalloc (strlen (pathname) + 1);

  if ((qflags & QGLOB_CVTNULL) && QUOTED_NULL (pathname))
    {
      temp[0] = '\0';
      return temp;
    }

  for (i = j = 0; pathname[i]; i++)
    {
      if (pathname[i] == CTLESC)
	{
	  if ((qflags & QGLOB_FILENAME) && pathname[i+1] == '/')
	    continue;
	  if ((qflags & QGLOB_REGEXP) && ere_char (pathname[i+1]) == 0)
	    continue;
	  temp[j++] = '\\';
	  i++;
	  if (pathname[i] == '\0')
	    break;
	}
      else if (pathname[i] == '\\')
	{
	  temp[j++] = '\\';
	  i++;
	  if (pathname[i] == '\0')
	    break;
	}
      temp[j++] = pathname[i];
    }
  temp[j] = '\0';

  return (temp);
}
warning: parse error {
  char *temp;
  register int i, j;

  temp = (char *)xmalloc (strlen (pathname) + 1);

  if ((qflags & QGLOB_CVTNULL) && QUOTED_NULL (pathname))
    {
      temp[0] = '\0';
      return temp;
    }

  for (i = j = 0; pathname[i]; i++)
    {
      if (pathname[i] == CTLESC)
	{
	  if ((qflags & QGLOB_FILENAME) && pathname[i+1] == '/')
	    continue;
	  if ((qflags & QGLOB_REGEXP) && ere_char (pathname[i+1]) == 0)
	    continue;
	  temp[j++] = '\\';
	  i++;
	  if (pathname[i] == '\0')
	    break;
	}
      else if (pathname[i] == '\\')
	{
	  temp[j++] = '\\';
	  i++;
	  if (pathname[i] == '\0')
	    break;
	}
      temp[j++] = pathname[i];
    }
  temp[j] = '\0';

  return (temp);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\pathexp.c:181
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\pathexp.c:221
parsing error 
{
  size_t slen;
  char *temp, *s, *t, *send;
  DECLARE_MBSTATE;

  slen = strlen (string);
  send = string + slen;

  temp = (char *)xmalloc (slen * 2 + 1);
  for (t = temp, s = string; *s; )
    {
      if (glob_char_p (s))
	*t++ = '\\';

      /* Copy a single (possibly multibyte) character from s to t,
         incrementing both. */
      COPY_CHAR_P (t, s, send);
    }
  *t = '\0';
  return temp;
}
warning: parse error {
  size_t slen;
  char *temp, *s, *t, *send;
  DECLARE_MBSTATE;

  slen = strlen (string);
  send = string + slen;

  temp = (char *)xmalloc (slen * 2 + 1);
  for (t = temp, s = string; *s; )
    {
      if (glob_char_p (s))
	*t++ = '\\';

      /* Copy a single (possibly multibyte) character from s to t,
         incrementing both. */
      COPY_CHAR_P (t, s, send);
    }
  *t = '\0';
  return temp;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\pathexp.c:223
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\pathexp.c:248
parsing error 
{
#if defined (USE_POSIX_GLOB_LIBRARY)
  register int i;
  char *temp, **results;
  glob_t filenames;
  int glob_flags;

  temp = quote_string_for_globbing (pathname, QGLOB_FILENAME);

  filenames.gl_offs = 0;

#  if defined (GLOB_PERIOD)
  glob_flags = glob_dot_filenames ? GLOB_PERIOD : 0;
#  else
  glob_flags = 0;
#  endif /* !GLOB_PERIOD */

  glob_flags |= (GLOB_ERR | GLOB_DOOFFS);

  i = glob (temp, glob_flags, (posix_glob_errfunc_t *)NULL, &filenames);

  free (temp);

  if (i == GLOB_NOSPACE || i == GLOB_ABORTED)
    return ((char **)NULL);
  else if (i == GLOB_NOMATCH)
    filenames.gl_pathv = (char **)NULL;
  else if (i != 0)		/* other error codes not in POSIX.2 */
    filenames.gl_pathv = (char **)NULL;

  results = filenames.gl_pathv;

  if (results && ((GLOB_FAILED (results)) == 0))
    {
      if (should_ignore_glob_matches ())
	ignore_glob_matches (results);
      if (results && results[0])
	strvec_sort (results);
      else
	{
	  FREE (results);
	  results = (char **)NULL;
	}
    }

  return (results);

#else /* !USE_POSIX_GLOB_LIBRARY */

  char *temp, **results;

  noglob_dot_filenames = glob_dot_filenames == 0;

  temp = quote_string_for_globbing (pathname, QGLOB_FILENAME);
  results = glob_filename (temp, glob_star ? GX_GLOBSTAR : 0);
  free (temp);

  if (results && ((GLOB_FAILED (results)) == 0))
    {
      if (should_ignore_glob_matches ())
	ignore_glob_matches (results);
      if (results && results[0])
	strvec_sort (results);
      else
	{
	  FREE (results);
	  results = (char **)&glob_error_return;
	}
    }

  return (results);
#endif /* !USE_POSIX_GLOB_LIBRARY */
}
warning: parse error {
#if defined (USE_POSIX_GLOB_LIBRARY)
  register int i;
  char *temp, **results;
  glob_t filenames;
  int glob_flags;

  temp = quote_string_for_globbing (pathname, QGLOB_FILENAME);

  filenames.gl_offs = 0;

#  if defined (GLOB_PERIOD)
  glob_flags = glob_dot_filenames ? GLOB_PERIOD : 0;
#  else
  glob_flags = 0;
#  endif /* !GLOB_PERIOD */

  glob_flags |= (GLOB_ERR | GLOB_DOOFFS);

  i = glob (temp, glob_flags, (posix_glob_errfunc_t *)NULL, &filenames);

  free (temp);

  if (i == GLOB_NOSPACE || i == GLOB_ABORTED)
    return ((char **)NULL);
  else if (i == GLOB_NOMATCH)
    filenames.gl_pathv = (char **)NULL;
  else if (i != 0)		/* other error codes not in POSIX.2 */
    filenames.gl_pathv = (char **)NULL;

  results = filenames.gl_pathv;

  if (results && ((GLOB_FAILED (results)) == 0))
    {
      if (should_ignore_glob_matches ())
	ignore_glob_matches (results);
      if (results && results[0])
	strvec_sort (results);
      else
	{
	  FREE (results);
	  results = (char **)NULL;
	}
    }

  return (results);

#else /* !USE_POSIX_GLOB_LIBRARY */

  char *temp, **results;

  noglob_dot_filenames = glob_dot_filenames == 0;

  temp = quote_string_for_globbing (pathname, QGLOB_FILENAME);
  results = glob_filename (temp, glob_star ? GX_GLOBSTAR : 0);
  free (temp);

  if (results && ((GLOB_FAILED (results)) == 0))
    {
      if (should_ignore_glob_matches ())
	ignore_glob_matches (results);
      if (results && results[0])
	strvec_sort (results);
      else
	{
	  FREE (results);
	  results = (char **)&glob_error_return;
	}
    }

  return (results);
#endif /* !USE_POSIX_GLOB_LIBRARY */
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\pathexp.c:249
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\pathexp.c:338
parsing error 
{
  char *v;

  v = get_string_value (name);
  setup_ignore_patterns (&globignore);

  if (globignore.num_ignores)
    glob_dot_filenames = 1;
  else if (v == 0)
    glob_dot_filenames = 0;
}
warning: parse error {
  char *v;

  v = get_string_value (name);
  setup_ignore_patterns (&globignore);

  if (globignore.num_ignores)
    glob_dot_filenames = 1;
  else if (v == 0)
    glob_dot_filenames = 0;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\pathexp.c:340
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\pathexp.c:361
parsing error 
{
  struct ign *p;
  int flags;

  /* . and .. are never matched */
  if (name[0] == '.' && (name[1] == '\0' || (name[1] == '.' && name[2] == '\0')))
    return (0);

  flags = FNM_PATHNAME | FNMATCH_EXTFLAG;
  for (p = globignore.ignores; p->val; p++)
    {
      if (strmatch (p->val, (char *)name, flags) != FNM_NOMATCH)
	return (0);
    }
  return (1);
}
warning: parse error {
  struct ign *p;
  int flags;

  /* . and .. are never matched */
  if (name[0] == '.' && (name[1] == '\0' || (name[1] == '.' && name[2] == '\0')))
    return (0);

  flags = FNM_PATHNAME | FNMATCH_EXTFLAG;
  for (p = globignore.ignores; p->val; p++)
    {
      if (strmatch (p->val, (char *)name, flags) != FNM_NOMATCH)
	return (0);
    }
  return (1);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\pathexp.c:362
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\pathexp.c:386
parsing error 
{
  char **newnames;
  int n, i;

  for (i = 0; names[i]; i++)
    ;
  newnames = strvec_create (i + 1);

  for (n = i = 0; names[i]; i++)
    {
      if ((*name_func) (names[i]))
	newnames[n++] = names[i];
      else
	free (names[i]);
    }

  newnames[n] = (char *)NULL;

  if (n == 0)
    {
      names[0] = (char *)NULL;
      free (newnames);
      return;
    }

  /* Copy the acceptable names from NEWNAMES back to NAMES and set the
     new array end. */
  for (n = 0; newnames[n]; n++)
    names[n] = newnames[n];
  names[n] = (char *)NULL;
  free (newnames);
}
warning: parse error {
  char **newnames;
  int n, i;

  for (i = 0; names[i]; i++)
    ;
  newnames = strvec_create (i + 1);

  for (n = i = 0; names[i]; i++)
    {
      if ((*name_func) (names[i]))
	newnames[n++] = names[i];
      else
	free (names[i]);
    }

  newnames[n] = (char *)NULL;

  if (n == 0)
    {
      names[0] = (char *)NULL;
      free (newnames);
      return;
    }

  /* Copy the acceptable names from NEWNAMES back to NAMES and set the
     new array end. */
  for (n = 0; newnames[n]; n++)
    names[n] = newnames[n];
  names[n] = (char *)NULL;
  free (newnames);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\pathexp.c:389
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\pathexp.c:423
parsing error 
{
  if (globignore.num_ignores == 0)
    return;

  ignore_globbed_names (names, glob_name_is_acceptable);
}
warning: parse error {
  if (globignore.num_ignores == 0)
    return;

  ignore_globbed_names (names, glob_name_is_acceptable);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\pathexp.c:425
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\pathexp.c:433
parsing error 
{
  char *t;
  int n, i;

  if (s == 0)
    return 0;

  i = *ip;
  if (s[i] == 0)
    return 0;

  n = skip_to_delim (s, i, ":", SD_NOJMP|SD_EXTGLOB);
  t = substring (s, i, n);

  if (s[n] == ':')
    n++;  
  *ip = n;  
  return t;
}
warning: parse error {
  char *t;
  int n, i;

  if (s == 0)
    return 0;

  i = *ip;
  if (s[i] == 0)
    return 0;

  n = skip_to_delim (s, i, ":", SD_NOJMP|SD_EXTGLOB);
  t = substring (s, i, n);

  if (s[n] == ':')
    n++;  
  *ip = n;  
  return t;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\pathexp.c:436
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\pathexp.c:457
parsing error 
{
  int numitems, maxitems, ptr;
  char *colon_bit, *this_ignoreval;
  struct ign *p;

  this_ignoreval = get_string_value (ivp->varname);

  /* If nothing has changed then just exit now. */
  if ((this_ignoreval && ivp->last_ignoreval && STREQ (this_ignoreval, ivp->last_ignoreval)) ||
      (!this_ignoreval && !ivp->last_ignoreval))
    return;

  /* Oops.  The ignore variable has changed.  Re-parse it. */
  ivp->num_ignores = 0;

  if (ivp->ignores)
    {
      for (p = ivp->ignores; p->val; p++)
	free(p->val);
      free (ivp->ignores);
      ivp->ignores = (struct ign *)NULL;
    }

  if (ivp->last_ignoreval)
    {
      free (ivp->last_ignoreval);
      ivp->last_ignoreval = (char *)NULL;
    }

  if (this_ignoreval == 0 || *this_ignoreval == '\0')
    return;

  ivp->last_ignoreval = savestring (this_ignoreval);

  numitems = maxitems = ptr = 0;

#if 0
  while (colon_bit = extract_colon_unit (this_ignoreval, &ptr))
#else
  while (colon_bit = split_ignorespec (this_ignoreval, &ptr))
#endif
    {
      if (numitems + 1 >= maxitems)
	{
	  maxitems += 10;
	  ivp->ignores = (struct ign *)xrealloc (ivp->ignores, maxitems * sizeof (struct ign));
	}
      ivp->ignores[numitems].val = colon_bit;
      ivp->ignores[numitems].len = strlen (colon_bit);
      ivp->ignores[numitems].flags = 0;
      if (ivp->item_func)
	(*ivp->item_func) (&ivp->ignores[numitems]);
      numitems++;
    }
  ivp->ignores[numitems].val = (char *)NULL;
  ivp->num_ignores = numitems;
}
warning: parse error {
  int numitems, maxitems, ptr;
  char *colon_bit, *this_ignoreval;
  struct ign *p;

  this_ignoreval = get_string_value (ivp->varname);

  /* If nothing has changed then just exit now. */
  if ((this_ignoreval && ivp->last_ignoreval && STREQ (this_ignoreval, ivp->last_ignoreval)) ||
      (!this_ignoreval && !ivp->last_ignoreval))
    return;

  /* Oops.  The ignore variable has changed.  Re-parse it. */
  ivp->num_ignores = 0;

  if (ivp->ignores)
    {
      for (p = ivp->ignores; p->val; p++)
	free(p->val);
      free (ivp->ignores);
      ivp->ignores = (struct ign *)NULL;
    }

  if (ivp->last_ignoreval)
    {
      free (ivp->last_ignoreval);
      ivp->last_ignoreval = (char *)NULL;
    }

  if (this_ignoreval == 0 || *this_ignoreval == '\0')
    return;

  ivp->last_ignoreval = savestring (this_ignoreval);

  numitems = maxitems = ptr = 0;

#if 0
  while (colon_bit = extract_colon_unit (this_ignoreval, &ptr))
#else
  while (colon_bit = split_ignorespec (this_ignoreval, &ptr))
#endif
    {
      if (numitems + 1 >= maxitems)
	{
	  maxitems += 10;
	  ivp->ignores = (struct ign *)xrealloc (ivp->ignores, maxitems * sizeof (struct ign));
	}
      ivp->ignores[numitems].val = colon_bit;
      ivp->ignores[numitems].len = strlen (colon_bit);
      ivp->ignores[numitems].flags = 0;
      if (ivp->item_func)
	(*ivp->item_func) (&ivp->ignores[numitems]);
      numitems++;
    }
  ivp->ignores[numitems].val = (char *)NULL;
  ivp->num_ignores = numitems;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\pathexp.c:459
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\pcomplete.c...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\bashtypes.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\posixstat.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\bashansi.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\bashintl.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\shell.h...skip
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\pcomplete.h...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\stdc.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\hashlib.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\alias.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\bashline.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\execute_cmd.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\pathexp.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\common.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\glob\glob.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\glob\strmatch.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\rlconf.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\readline.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\readline\history.h...skip
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\pcomplib.c...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\bashansi.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\bashintl.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\shell.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\pcomplete.h...skip
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\print_cmd.c...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\bashansi.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\bashintl.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\shell.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\flags.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\y.tab.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\shmbutil.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\common.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\print_cmd.c:138
parsing error 
{
  command_string_index = 0;
  printf ("%s", make_command_string (command));
}
warning: parse error {
  command_string_index = 0;
  printf ("%s", make_command_string (command));
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\print_cmd.c:140
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\print_cmd.c:150
parsing error 
{
  command_string_index = was_heredoc = 0;
  deferred_heredocs = 0;
  make_command_string_internal (command);
  return (the_printed_command);
}
warning: parse error {
  command_string_index = was_heredoc = 0;
  deferred_heredocs = 0;
  make_command_string_internal (command);
  return (the_printed_command);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\print_cmd.c:152
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\print_cmd.c:161
parsing error 
{
  char s[3];

  if (command == 0)
    cprintf ("");
  else
    {
      if (skip_this_indent)
	skip_this_indent--;
      else
	indent (indentation);

      if (command->flags & CMD_TIME_PIPELINE)
	{
	  cprintf ("time ");
	  if (command->flags & CMD_TIME_POSIX)
	    cprintf ("-p ");
	}

      if (command->flags & CMD_INVERT_RETURN)
	cprintf ("! ");

      switch (command->type)
	{
	case cm_for:
	  print_for_command (command->value.For);
	  break;

#if defined (ARITH_FOR_COMMAND)
	case cm_arith_for:
	  print_arith_for_command (command->value.ArithFor);
	  break;
#endif

#if defined (SELECT_COMMAND)
	case cm_select:
	  print_select_command (command->value.Select);
	  break;
#endif

	case cm_case:
	  print_case_command (command->value.Case);
	  break;

	case cm_while:
	  print_while_command (command->value.While);
	  break;

	case cm_until:
	  print_until_command (command->value.While);
	  break;

	case cm_if:
	  print_if_command (command->value.If);
	  break;

#if defined (DPAREN_ARITHMETIC)
	case cm_arith:
	  print_arith_command (command->value.Arith->exp);
	  break;
#endif

#if defined (COND_COMMAND)
	case cm_cond:
	  print_cond_command (command->value.Cond);
	  break;
#endif

	case cm_simple:
	  print_simple_command (command->value.Simple);
	  break;

	case cm_connection:

	  skip_this_indent++;
	  printing_connection++;
	  make_command_string_internal (command->value.Connection->first);

	  switch (command->value.Connection->connector)
	    {
	    case '&':
	    case '|':
	      {
		char c = command->value.Connection->connector;

		s[0] = ' ';
		s[1] = c;
		s[2] = '\0';
		
		print_deferred_heredocs (s);

		if (c != '&' || command->value.Connection->second)
		  {
		    cprintf (" ");
		    skip_this_indent++;
		  }
	      }
	      break;

	    case AND_AND:
	      print_deferred_heredocs (" && ");
	      if (command->value.Connection->second)
		skip_this_indent++;
	      break;

	    case OR_OR:
	      print_deferred_heredocs (" || ");
	      if (command->value.Connection->second)
		skip_this_indent++;
	      break;

	    case ';':
	      if (deferred_heredocs == 0)
		{
		  if (was_heredoc == 0)
		    cprintf (";");
		  else
		    was_heredoc = 0;
		}
	      else
		print_deferred_heredocs (inside_function_def ? "" : ";");

	      if (inside_function_def)
		cprintf ("\n");
	      else
		{
		  cprintf (" ");
		  if (command->value.Connection->second)
		    skip_this_indent++;
		}
	      break;

	    default:
	      cprintf (_("print_command: bad connector `%d'"),
		       command->value.Connection->connector);
	      break;
	    }

	  make_command_string_internal (command->value.Connection->second);
	  PRINT_DEFERRED_HEREDOCS ("");
	  printing_connection--;	  	  
	  break;

	case cm_function_def:
	  print_function_def (command->value.Function_def);
	  break;

	case cm_group:
	  print_group_command (command->value.Group);
	  break;

	case cm_subshell:
	  cprintf ("( ");
	  skip_this_indent++;
	  make_command_string_internal (command->value.Subshell->command);
	  cprintf (" )");
	  break;

	case cm_coproc:
	  cprintf ("coproc %s ", command->value.Coproc->name);
	  skip_this_indent++;
	  make_command_string_internal (command->value.Coproc->command);
	  break;

	default:
	  command_error ("print_command", CMDERR_BADTYPE, command->type, 0);
	  break;
	}


      if (command->redirects)
	{
	  cprintf (" ");
	  print_redirection_list (command->redirects);
	}
    }
}
warning: parse error {
  char s[3];

  if (command == 0)
    cprintf ("");
  else
    {
      if (skip_this_indent)
	skip_this_indent--;
      else
	indent (indentation);

      if (command->flags & CMD_TIME_PIPELINE)
	{
	  cprintf ("time ");
	  if (command->flags & CMD_TIME_POSIX)
	    cprintf ("-p ");
	}

      if (command->flags & CMD_INVERT_RETURN)
	cprintf ("! ");

      switch (command->type)
	{
	case cm_for:
	  print_for_command (command->value.For);
	  break;

#if defined (ARITH_FOR_COMMAND)
	case cm_arith_for:
	  print_arith_for_command (command->value.ArithFor);
	  break;
#endif

#if defined (SELECT_COMMAND)
	case cm_select:
	  print_select_command (command->value.Select);
	  break;
#endif

	case cm_case:
	  print_case_command (command->value.Case);
	  break;

	case cm_while:
	  print_while_command (command->value.While);
	  break;

	case cm_until:
	  print_until_command (command->value.While);
	  break;

	case cm_if:
	  print_if_command (command->value.If);
	  break;

#if defined (DPAREN_ARITHMETIC)
	case cm_arith:
	  print_arith_command (command->value.Arith->exp);
	  break;
#endif

#if defined (COND_COMMAND)
	case cm_cond:
	  print_cond_command (command->value.Cond);
	  break;
#endif

	case cm_simple:
	  print_simple_command (command->value.Simple);
	  break;

	case cm_connection:

	  skip_this_indent++;
	  printing_connection++;
	  make_command_string_internal (command->value.Connection->first);

	  switch (command->value.Connection->connector)
	    {
	    case '&':
	    case '|':
	      {
		char c = command->value.Connection->connector;

		s[0] = ' ';
		s[1] = c;
		s[2] = '\0';
		
		print_deferred_heredocs (s);

		if (c != '&' || command->value.Connection->second)
		  {
		    cprintf (" ");
		    skip_this_indent++;
		  }
	      }
	      break;

	    case AND_AND:
	      print_deferred_heredocs (" && ");
	      if (command->value.Connection->second)
		skip_this_indent++;
	      break;

	    case OR_OR:
	      print_deferred_heredocs (" || ");
	      if (command->value.Connection->second)
		skip_this_indent++;
	      break;

	    case ';':
	      if (deferred_heredocs == 0)
		{
		  if (was_heredoc == 0)
		    cprintf (";");
		  else
		    was_heredoc = 0;
		}
	      else
		print_deferred_heredocs (inside_function_def ? "" : ";");

	      if (inside_function_def)
		cprintf ("\n");
	      else
		{
		  cprintf (" ");
		  if (command->value.Connection->second)
		    skip_this_indent++;
		}
	      break;

	    default:
	      cprintf (_("print_command: bad connector `%d'"),
		       command->value.Connection->connector);
	      break;
	    }

	  make_command_string_internal (command->value.Connection->second);
	  PRINT_DEFERRED_HEREDOCS ("");
	  printing_connection--;	  	  
	  break;

	case cm_function_def:
	  print_function_def (command->value.Function_def);
	  break;

	case cm_group:
	  print_group_command (command->value.Group);
	  break;

	case cm_subshell:
	  cprintf ("( ");
	  skip_this_indent++;
	  make_command_string_internal (command->value.Subshell->command);
	  cprintf (" )");
	  break;

	case cm_coproc:
	  cprintf ("coproc %s ", command->value.Coproc->name);
	  skip_this_indent++;
	  make_command_string_internal (command->value.Coproc->command);
	  break;

	default:
	  command_error ("print_command", CMDERR_BADTYPE, command->type, 0);
	  break;
	}


      if (command->redirects)
	{
	  cprintf (" ");
	  print_redirection_list (command->redirects);
	}
    }
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\print_cmd.c:163
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\print_cmd.c:342
parsing error 
{
  WORD_LIST *w;

  for (w = list; w; w = w->next)
    (*pfunc) ("%s%s", w->word->word, w->next ? separator : "");
}
warning: parse error {
  WORD_LIST *w;

  for (w = list; w; w = w->next)
    (*pfunc) ("%s%s", w->word->word, w->next ? separator : "");
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\print_cmd.c:346
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\print_cmd.c:354
parsing error 
{
  _print_word_list (list, separator, xprintf);
}
warning: parse error {
  _print_word_list (list, separator, xprintf);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\print_cmd.c:357
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\print_cmd.c:362
parsing error 
{
  if (fd >= 0 && sh_validfd (fd) == 0)
    {
      internal_error (_("xtrace_set: %d: invalid file descriptor"), fd);
      return;
    }
  if (fp == 0)
    {
      internal_error (_("xtrace_set: NULL file pointer"));
      return;
    }
  if (fd >= 0 && fileno (fp) != fd)
    internal_warning (_("xtrace fd (%d) != fileno xtrace fp (%d)"), fd, fileno (fp));
  
  xtrace_fd = fd;
  xtrace_fp = fp;
}
warning: parse error {
  if (fd >= 0 && sh_validfd (fd) == 0)
    {
      internal_error (_("xtrace_set: %d: invalid file descriptor"), fd);
      return;
    }
  if (fp == 0)
    {
      internal_error (_("xtrace_set: NULL file pointer"));
      return;
    }
  if (fd >= 0 && fileno (fp) != fd)
    internal_warning (_("xtrace fd (%d) != fileno xtrace fp (%d)"), fd, fileno (fp));
  
  xtrace_fd = fd;
  xtrace_fp = fp;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\print_cmd.c:365
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\print_cmd.c:405
parsing error 
{
  if (fd == xtrace_fd)
    xtrace_reset ();
}
warning: parse error {
  if (fd == xtrace_fd)
    xtrace_reset ();
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\print_cmd.c:407
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\print_cmd.c:467
parsing error 
{
  char *nval;

  CHECK_XTRACE_FP;

  if (xflags)
    fprintf (xtrace_fp, "%s", indirection_level_string ());

  /* VALUE should not be NULL when this is called. */
  if (*value == '\0' || assign_list)
    nval = value;
  else if (sh_contains_shell_metas (value))
    nval = sh_single_quote (value);
  else if (ansic_shouldquote (value))
    nval = ansic_quote (value, 0, (int *)0);
  else
    nval = value;

  if (assign_list)
    fprintf (xtrace_fp, "%s=(%s)\n", name, nval);
  else
    fprintf (xtrace_fp, "%s=%s\n", name, nval);

  if (nval != value)
    FREE (nval);

  fflush (xtrace_fp);
}
warning: parse error {
  char *nval;

  CHECK_XTRACE_FP;

  if (xflags)
    fprintf (xtrace_fp, "%s", indirection_level_string ());

  /* VALUE should not be NULL when this is called. */
  if (*value == '\0' || assign_list)
    nval = value;
  else if (sh_contains_shell_metas (value))
    nval = sh_single_quote (value);
  else if (ansic_shouldquote (value))
    nval = ansic_quote (value, 0, (int *)0);
  else
    nval = value;

  if (assign_list)
    fprintf (xtrace_fp, "%s=(%s)\n", name, nval);
  else
    fprintf (xtrace_fp, "%s=%s\n", name, nval);

  if (nval != value)
    FREE (nval);

  fflush (xtrace_fp);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\print_cmd.c:470
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\print_cmd.c:501
parsing error 
{
  WORD_LIST *w;
  char *t, *x;

  CHECK_XTRACE_FP;

  if (xtflags)
    fprintf (xtrace_fp, "%s", indirection_level_string ());

  for (w = list; w; w = w->next)
    {
      t = w->word->word;
      if (t == 0 || *t == '\0')
	fprintf (xtrace_fp, "''%s", w->next ? " " : "");
      else if (sh_contains_shell_metas (t))
	{
	  x = sh_single_quote (t);
	  fprintf (xtrace_fp, "%s%s", x, w->next ? " " : "");
	  free (x);
	}
      else if (ansic_shouldquote (t))
	{
	  x = ansic_quote (t, 0, (int *)0);
	  fprintf (xtrace_fp, "%s%s", x, w->next ? " " : "");
	  free (x);
	}
      else
	fprintf (xtrace_fp, "%s%s", t, w->next ? " " : "");
    }
  fprintf (xtrace_fp, "\n");
  fflush (xtrace_fp);
}
warning: parse error {
  WORD_LIST *w;
  char *t, *x;

  CHECK_XTRACE_FP;

  if (xtflags)
    fprintf (xtrace_fp, "%s", indirection_level_string ());

  for (w = list; w; w = w->next)
    {
      t = w->word->word;
      if (t == 0 || *t == '\0')
	fprintf (xtrace_fp, "''%s", w->next ? " " : "");
      else if (sh_contains_shell_metas (t))
	{
	  x = sh_single_quote (t);
	  fprintf (xtrace_fp, "%s%s", x, w->next ? " " : "");
	  free (x);
	}
      else if (ansic_shouldquote (t))
	{
	  x = ansic_quote (t, 0, (int *)0);
	  fprintf (xtrace_fp, "%s%s", x, w->next ? " " : "");
	  free (x);
	}
      else
	fprintf (xtrace_fp, "%s%s", t, w->next ? " " : "");
    }
  fprintf (xtrace_fp, "\n");
  fflush (xtrace_fp);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\print_cmd.c:504
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\print_cmd.c:538
parsing error 
{
  _print_word_list (list, separator, cprintf);
}
warning: parse error {
  _print_word_list (list, separator, cprintf);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\print_cmd.c:541
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\print_cmd.c:546
parsing error 
{
  cprintf ("for %s in ", for_command->name->word);
  command_print_word_list (for_command->map_list, " ");
}
warning: parse error {
  cprintf ("for %s in ", for_command->name->word);
  command_print_word_list (for_command->map_list, " ");
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\print_cmd.c:548
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\print_cmd.c:554
parsing error 
{
  CHECK_XTRACE_FP;
  fprintf (xtrace_fp, "%s", indirection_level_string ());
  fprintf (xtrace_fp, "for %s in ", for_command->name->word);
  xtrace_print_word_list (for_command->map_list, 0);
}
warning: parse error {
  CHECK_XTRACE_FP;
  fprintf (xtrace_fp, "%s", indirection_level_string ());
  fprintf (xtrace_fp, "for %s in ", for_command->name->word);
  xtrace_print_word_list (for_command->map_list, 0);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\print_cmd.c:556
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\print_cmd.c:564
parsing error 
{
  print_for_command_head (for_command);
  cprintf (";");
  newline ("do\n");

  indentation += indentation_amount;
  make_command_string_internal (for_command->action);
  PRINT_DEFERRED_HEREDOCS ("");
  semicolon ();
  indentation -= indentation_amount;

  newline ("done");
}
warning: parse error {
  print_for_command_head (for_command);
  cprintf (";");
  newline ("do\n");

  indentation += indentation_amount;
  make_command_string_internal (for_command->action);
  PRINT_DEFERRED_HEREDOCS ("");
  semicolon ();
  indentation -= indentation_amount;

  newline ("done");
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\print_cmd.c:566
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\print_cmd.c:638
parsing error 
{
  group_command_nesting++;
  cprintf ("{ ");

  if (inside_function_def == 0)
    skip_this_indent++;
  else
    {
      /* This is a group command { ... } inside of a function
	 definition, and should be printed as a multiline group
	 command, using the current indentation. */
      cprintf ("\n");
      indentation += indentation_amount;
    }

  make_command_string_internal (group_command->command);

  if (inside_function_def)
    {
      cprintf ("\n");
      indentation -= indentation_amount;
      indent (indentation);
    }
  else
    {
      semicolon ();
      cprintf (" ");
    }

  cprintf ("}");

  group_command_nesting--;
}
warning: parse error {
  group_command_nesting++;
  cprintf ("{ ");

  if (inside_function_def == 0)
    skip_this_indent++;
  else
    {
      /* This is a group command { ... } inside of a function
	 definition, and should be printed as a multiline group
	 command, using the current indentation. */
      cprintf ("\n");
      indentation += indentation_amount;
    }

  make_command_string_internal (group_command->command);

  if (inside_function_def)
    {
      cprintf ("\n");
      indentation -= indentation_amount;
      indent (indentation);
    }
  else
    {
      semicolon ();
      cprintf (" ");
    }

  cprintf ("}");

  group_command_nesting--;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\print_cmd.c:640
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\print_cmd.c:675
parsing error 
{
  cprintf ("case %s in ", case_command->word->word);
}
warning: parse error {
  cprintf ("case %s in ", case_command->word->word);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\print_cmd.c:677
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\print_cmd.c:682
parsing error 
{
  CHECK_XTRACE_FP;
  fprintf (xtrace_fp, "%s", indirection_level_string ());
  fprintf (xtrace_fp, "case %s in\n", case_command->word->word);
}
warning: parse error {
  CHECK_XTRACE_FP;
  fprintf (xtrace_fp, "%s", indirection_level_string ());
  fprintf (xtrace_fp, "case %s in\n", case_command->word->word);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\print_cmd.c:684
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\print_cmd.c:691
parsing error 
{
  print_case_command_head (case_command);

  if (case_command->clauses)
    print_case_clauses (case_command->clauses);
  newline ("esac");
}
warning: parse error {
  print_case_command_head (case_command);

  if (case_command->clauses)
    print_case_clauses (case_command->clauses);
  newline ("esac");
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\print_cmd.c:693
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\print_cmd.c:702
parsing error 
{
  indentation += indentation_amount;
  while (clauses)
    {
      newline ("");
      command_print_word_list (clauses->patterns, " | ");
      cprintf (")\n");
      indentation += indentation_amount;
      make_command_string_internal (clauses->action);
      indentation -= indentation_amount;
      PRINT_DEFERRED_HEREDOCS ("");
      if (clauses->flags & CASEPAT_FALLTHROUGH)
	newline (";&");
      else if (clauses->flags & CASEPAT_TESTNEXT)
	newline (";;&");
      else
	newline (";;");
      clauses = clauses->next;
    }
  indentation -= indentation_amount;
}
warning: parse error {
  indentation += indentation_amount;
  while (clauses)
    {
      newline ("");
      command_print_word_list (clauses->patterns, " | ");
      cprintf (")\n");
      indentation += indentation_amount;
      make_command_string_internal (clauses->action);
      indentation -= indentation_amount;
      PRINT_DEFERRED_HEREDOCS ("");
      if (clauses->flags & CASEPAT_FALLTHROUGH)
	newline (";&");
      else if (clauses->flags & CASEPAT_TESTNEXT)
	newline (";;&");
      else
	newline (";;");
      clauses = clauses->next;
    }
  indentation -= indentation_amount;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\print_cmd.c:704
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\print_cmd.c:727
parsing error 
{
  print_until_or_while (while_command, "while");
}
warning: parse error {
  print_until_or_while (while_command, "while");
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\print_cmd.c:729
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\print_cmd.c:734
parsing error 
{
  print_until_or_while (while_command, "until");
}
warning: parse error {
  print_until_or_while (while_command, "until");
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\print_cmd.c:736
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\print_cmd.c:741
parsing error 
{
  cprintf ("%s ", which);
  skip_this_indent++;
  make_command_string_internal (while_command->test);
  PRINT_DEFERRED_HEREDOCS ("");
  semicolon ();
  cprintf (" do\n");	/* was newline ("do\n"); */
  indentation += indentation_amount;
  make_command_string_internal (while_command->action);
  PRINT_DEFERRED_HEREDOCS ("");
  indentation -= indentation_amount;
  semicolon ();
  newline ("done");
}
warning: parse error {
  cprintf ("%s ", which);
  skip_this_indent++;
  make_command_string_internal (while_command->test);
  PRINT_DEFERRED_HEREDOCS ("");
  semicolon ();
  cprintf (" do\n");	/* was newline ("do\n"); */
  indentation += indentation_amount;
  make_command_string_internal (while_command->action);
  PRINT_DEFERRED_HEREDOCS ("");
  indentation -= indentation_amount;
  semicolon ();
  newline ("done");
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\print_cmd.c:744
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\print_cmd.c:760
parsing error 
{
  cprintf ("if ");
  skip_this_indent++;
  make_command_string_internal (if_command->test);
  semicolon ();
  cprintf (" then\n");
  indentation += indentation_amount;
  make_command_string_internal (if_command->true_case);
  PRINT_DEFERRED_HEREDOCS ("");
  indentation -= indentation_amount;

  if (if_command->false_case)
    {
      semicolon ();
      newline ("else\n");
      indentation += indentation_amount;
      make_command_string_internal (if_command->false_case);
      PRINT_DEFERRED_HEREDOCS ("");
      indentation -= indentation_amount;
    }
  semicolon ();
  newline ("fi");
}
warning: parse error {
  cprintf ("if ");
  skip_this_indent++;
  make_command_string_internal (if_command->test);
  semicolon ();
  cprintf (" then\n");
  indentation += indentation_amount;
  make_command_string_internal (if_command->true_case);
  PRINT_DEFERRED_HEREDOCS ("");
  indentation -= indentation_amount;

  if (if_command->false_case)
    {
      semicolon ();
      newline ("else\n");
      indentation += indentation_amount;
      make_command_string_internal (if_command->false_case);
      PRINT_DEFERRED_HEREDOCS ("");
      indentation -= indentation_amount;
    }
  semicolon ();
  newline ("fi");
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\print_cmd.c:762
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\print_cmd.c:915
parsing error 
{
  command_print_word_list (simple_command->words, " ");

  if (simple_command->redirects)
    {
      cprintf (" ");
      print_redirection_list (simple_command->redirects);
    }
}
warning: parse error {
  command_print_word_list (simple_command->words, " ");

  if (simple_command->redirects)
    {
      cprintf (" ");
      print_redirection_list (simple_command->redirects);
    }
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\print_cmd.c:917
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\print_cmd.c:928
parsing error 
{
  REDIRECT *hdtail;

  cprintf (" "); 
  for (hdtail = heredocs; hdtail; hdtail = hdtail->next)
    {
      print_redirection (hdtail);
      cprintf ("\n");
    }
  was_heredoc = 1;
}
warning: parse error {
  REDIRECT *hdtail;

  cprintf (" "); 
  for (hdtail = heredocs; hdtail; hdtail = hdtail->next)
    {
      print_redirection (hdtail);
      cprintf ("\n");
    }
  was_heredoc = 1;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\print_cmd.c:930
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\print_cmd.c:950
parsing error 
{
  REDIRECT *hdtail;	

  for (hdtail = deferred_heredocs; hdtail; hdtail = hdtail->next)
    {
      cprintf (" ");
      print_heredoc_header (hdtail);
    }
  if (cstring[0] && (cstring[0] != ';' || cstring[1]))
    cprintf ("%s", cstring); 
  if (deferred_heredocs)
    cprintf ("\n");
  for (hdtail = deferred_heredocs; hdtail; hdtail = hdtail->next)
    {
      print_heredoc_body (hdtail);
      cprintf ("\n");
    }
  if (deferred_heredocs)
    {
      if (cstring && cstring[0] && (cstring[0] != ';' || cstring[1]))
	cprintf (" ");	/* make sure there's at least one space */
      dispose_redirects (deferred_heredocs);
      was_heredoc = 1;
    }
  deferred_heredocs = (REDIRECT *)NULL;
}
warning: parse error {
  REDIRECT *hdtail;	

  for (hdtail = deferred_heredocs; hdtail; hdtail = hdtail->next)
    {
      cprintf (" ");
      print_heredoc_header (hdtail);
    }
  if (cstring[0] && (cstring[0] != ';' || cstring[1]))
    cprintf ("%s", cstring); 
  if (deferred_heredocs)
    cprintf ("\n");
  for (hdtail = deferred_heredocs; hdtail; hdtail = hdtail->next)
    {
      print_heredoc_body (hdtail);
      cprintf ("\n");
    }
  if (deferred_heredocs)
    {
      if (cstring && cstring[0] && (cstring[0] != ';' || cstring[1]))
	cprintf (" ");	/* make sure there's at least one space */
      dispose_redirects (deferred_heredocs);
      was_heredoc = 1;
    }
  deferred_heredocs = (REDIRECT *)NULL;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\print_cmd.c:951
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\print_cmd.c:979
parsing error 
{
  REDIRECT *heredocs, *hdtail, *newredir;

  heredocs = (REDIRECT *)NULL;
  hdtail = heredocs;

  was_heredoc = 0;
  while (redirects)
    {
      /* Defer printing the here documents until we've printed the
	 rest of the redirections. */
      if (redirects->instruction == r_reading_until || redirects->instruction == r_deblank_reading_until)
	{
	  newredir = copy_redirect (redirects);
	  newredir->next = (REDIRECT *)NULL;
	  if (heredocs)
	    {
	      hdtail->next = newredir;
	      hdtail = newredir;
	    }
	  else
	    hdtail = heredocs = newredir;
	}
      else if (redirects->instruction == r_duplicating_output_word && redirects->redirector.dest == 1)
	{
	  /* Temporarily translate it as the execution code does. */
	  redirects->instruction = r_err_and_out;
	  print_redirection (redirects);
	  redirects->instruction = r_duplicating_output_word;
	}
      else
	print_redirection (redirects);

      redirects = redirects->next;
      if (redirects)
	cprintf (" ");
    }

  /* Now that we've printed all the other redirections (on one line),
     print the here documents. */
  if (heredocs && printing_connection)
    deferred_heredocs = heredocs;
  else if (heredocs)
    {
      print_heredocs (heredocs);
      dispose_redirects (heredocs);
    }
}
warning: parse error {
  REDIRECT *heredocs, *hdtail, *newredir;

  heredocs = (REDIRECT *)NULL;
  hdtail = heredocs;

  was_heredoc = 0;
  while (redirects)
    {
      /* Defer printing the here documents until we've printed the
	 rest of the redirections. */
      if (redirects->instruction == r_reading_until || redirects->instruction == r_deblank_reading_until)
	{
	  newredir = copy_redirect (redirects);
	  newredir->next = (REDIRECT *)NULL;
	  if (heredocs)
	    {
	      hdtail->next = newredir;
	      hdtail = newredir;
	    }
	  else
	    hdtail = heredocs = newredir;
	}
      else if (redirects->instruction == r_duplicating_output_word && redirects->redirector.dest == 1)
	{
	  /* Temporarily translate it as the execution code does. */
	  redirects->instruction = r_err_and_out;
	  print_redirection (redirects);
	  redirects->instruction = r_duplicating_output_word;
	}
      else
	print_redirection (redirects);

      redirects = redirects->next;
      if (redirects)
	cprintf (" ");
    }

  /* Now that we've printed all the other redirections (on one line),
     print the here documents. */
  if (heredocs && printing_connection)
    deferred_heredocs = heredocs;
  else if (heredocs)
    {
      print_heredocs (heredocs);
      dispose_redirects (heredocs);
    }
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\print_cmd.c:981
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\print_cmd.c:1,031
parsing error 
{
  int kill_leading;
  char *x;

  kill_leading = redirect->instruction == r_deblank_reading_until;

  /* Here doc header */
  if (redirect->rflags & REDIR_VARASSIGN)
    cprintf ("{%s}", redirect->redirector.filename->word);
  else if (redirect->redirector.dest != 0)
    cprintf ("%d", redirect->redirector.dest);

  /* If the here document delimiter is quoted, single-quote it. */
  if (redirect->redirectee.filename->flags & W_QUOTED)
    {
      x = sh_single_quote (redirect->here_doc_eof);
      cprintf ("<<%s%s", kill_leading ? "-" : "", x);
      free (x);
    }
  else
    cprintf ("<<%s%s", kill_leading ? "-" : "", redirect->here_doc_eof);
}
warning: parse error {
  int kill_leading;
  char *x;

  kill_leading = redirect->instruction == r_deblank_reading_until;

  /* Here doc header */
  if (redirect->rflags & REDIR_VARASSIGN)
    cprintf ("{%s}", redirect->redirector.filename->word);
  else if (redirect->redirector.dest != 0)
    cprintf ("%d", redirect->redirector.dest);

  /* If the here document delimiter is quoted, single-quote it. */
  if (redirect->redirectee.filename->flags & W_QUOTED)
    {
      x = sh_single_quote (redirect->here_doc_eof);
      cprintf ("<<%s%s", kill_leading ? "-" : "", x);
      free (x);
    }
  else
    cprintf ("<<%s%s", kill_leading ? "-" : "", redirect->here_doc_eof);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\print_cmd.c:1,033
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\print_cmd.c:1,057
parsing error 
{
  /* Here doc body */
  cprintf ("%s%s", redirect->redirectee.filename->word, redirect->here_doc_eof);
}
warning: parse error {
  /* Here doc body */
  cprintf ("%s%s", redirect->redirectee.filename->word, redirect->here_doc_eof);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\print_cmd.c:1,059
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\print_cmd.c:1,065
parsing error 
{
  int redirector, redir_fd;
  WORD_DESC *redirectee, *redir_word;

  redirectee = redirect->redirectee.filename;
  redir_fd = redirect->redirectee.dest;

  redir_word = redirect->redirector.filename;
  redirector = redirect->redirector.dest;

  switch (redirect->instruction)
    {
    case r_input_direction:
      if (redirect->rflags & REDIR_VARASSIGN)
	cprintf ("{%s}", redir_word->word);
      else if (redirector != 0)
	cprintf ("%d", redirector);
      cprintf ("< %s", redirectee->word);
      break;

    case r_output_direction:
      if (redirect->rflags & REDIR_VARASSIGN)
	cprintf ("{%s}", redir_word->word);
      else if (redirector != 1)
	cprintf ("%d", redirector);
      cprintf ("> %s", redirectee->word);
      break;

    case r_inputa_direction:	/* Redirection created by the shell. */
      cprintf ("&");
      break;

    case r_output_force:
      if (redirect->rflags & REDIR_VARASSIGN)
	cprintf ("{%s}", redir_word->word);
      else if (redirector != 1)
	cprintf ("%d", redirector);
      cprintf (">|%s", redirectee->word);
      break;

    case r_appending_to:
      if (redirect->rflags & REDIR_VARASSIGN)
	cprintf ("{%s}", redir_word->word);
      else if (redirector != 1)
	cprintf ("%d", redirector);
      cprintf (">> %s", redirectee->word);
      break;

    case r_input_output:
      if (redirect->rflags & REDIR_VARASSIGN)
	cprintf ("{%s}", redir_word->word);
      else if (redirector != 1)
	cprintf ("%d", redirector);
      cprintf ("<> %s", redirectee->word);
      break;

    case r_deblank_reading_until:
    case r_reading_until:
      print_heredoc_header (redirect);
      cprintf ("\n");
      print_heredoc_body (redirect);
      break;

    case r_reading_string:
      if (redirect->rflags & REDIR_VARASSIGN)
	cprintf ("{%s}", redir_word->word);
      else if (redirector != 0)
	cprintf ("%d", redirector);
#if 0
      /* Don't need to check whether or not to requote, since original quotes
         are still intact.  The only thing that has happened is that $'...'
         has been replaced with 'expanded ...'. */
      if (ansic_shouldquote (redirect->redirectee.filename->word))
	{
	  char *x;
	  x = ansic_quote (redirect->redirectee.filename->word, 0, (int *)0);
	  cprintf ("<<< %s", x);
	  free (x);
	}
      else
#endif
	cprintf ("<<< %s", redirect->redirectee.filename->word);
      break;

    case r_duplicating_input:
      if (redirect->rflags & REDIR_VARASSIGN)
	cprintf ("{%s}<&%d", redir_word->word, redir_fd);
      else
	cprintf ("%d<&%d", redirector, redir_fd);
      break;

    case r_duplicating_output:
      if (redirect->rflags & REDIR_VARASSIGN)
	cprintf ("{%s}>&%d", redir_word->word, redir_fd);
      else
	cprintf ("%d>&%d", redirector, redir_fd);
      break;

    case r_duplicating_input_word:
      if (redirect->rflags & REDIR_VARASSIGN)
	cprintf ("{%s}<&%s", redir_word->word, redirectee->word);
      else
	cprintf ("%d<&%s", redirector, redirectee->word);
      break;

    case r_duplicating_output_word:
      if (redirect->rflags & REDIR_VARASSIGN)
	cprintf ("{%s}>&%s", redir_word->word, redirectee->word);
      else
	cprintf ("%d>&%s", redirector, redirectee->word);
      break;

    case r_move_input:
      if (redirect->rflags & REDIR_VARASSIGN)
	cprintf ("{%s}<&%d-", redir_word->word, redir_fd);
      else
	cprintf ("%d<&%d-", redirector, redir_fd);
      break;

    case r_move_output:
      if (redirect->rflags & REDIR_VARASSIGN)
	cprintf ("{%s}>&%d-", redir_word->word, redir_fd);
      else
	cprintf ("%d>&%d-", redirector, redir_fd);
      break;

    case r_move_input_word:
      if (redirect->rflags & REDIR_VARASSIGN)
	cprintf ("{%s}<&%s-", redir_word->word, redirectee->word);
      else
	cprintf ("%d<&%s-", redirector, redirectee->word);
      break;

    case r_move_output_word:
      if (redirect->rflags & REDIR_VARASSIGN)
	cprintf ("{%s}>&%s-", redir_word->word, redirectee->word);
      else
	cprintf ("%d>&%s-", redirector, redirectee->word);
      break;

    case r_close_this:
      if (redirect->rflags & REDIR_VARASSIGN)
	cprintf ("{%s}>&-", redir_word->word);
      else
	cprintf ("%d>&-", redirector);
      break;

    case r_err_and_out:
      cprintf ("&>%s", redirectee->word);
      break;

    case r_append_err_and_out:
      cprintf ("&>>%s", redirectee->word);
      break;
    }
}
warning: parse error {
  int redirector, redir_fd;
  WORD_DESC *redirectee, *redir_word;

  redirectee = redirect->redirectee.filename;
  redir_fd = redirect->redirectee.dest;

  redir_word = redirect->redirector.filename;
  redirector = redirect->redirector.dest;

  switch (redirect->instruction)
    {
    case r_input_direction:
      if (redirect->rflags & REDIR_VARASSIGN)
	cprintf ("{%s}", redir_word->word);
      else if (redirector != 0)
	cprintf ("%d", redirector);
      cprintf ("< %s", redirectee->word);
      break;

    case r_output_direction:
      if (redirect->rflags & REDIR_VARASSIGN)
	cprintf ("{%s}", redir_word->word);
      else if (redirector != 1)
	cprintf ("%d", redirector);
      cprintf ("> %s", redirectee->word);
      break;

    case r_inputa_direction:	/* Redirection created by the shell. */
      cprintf ("&");
      break;

    case r_output_force:
      if (redirect->rflags & REDIR_VARASSIGN)
	cprintf ("{%s}", redir_word->word);
      else if (redirector != 1)
	cprintf ("%d", redirector);
      cprintf (">|%s", redirectee->word);
      break;

    case r_appending_to:
      if (redirect->rflags & REDIR_VARASSIGN)
	cprintf ("{%s}", redir_word->word);
      else if (redirector != 1)
	cprintf ("%d", redirector);
      cprintf (">> %s", redirectee->word);
      break;

    case r_input_output:
      if (redirect->rflags & REDIR_VARASSIGN)
	cprintf ("{%s}", redir_word->word);
      else if (redirector != 1)
	cprintf ("%d", redirector);
      cprintf ("<> %s", redirectee->word);
      break;

    case r_deblank_reading_until:
    case r_reading_until:
      print_heredoc_header (redirect);
      cprintf ("\n");
      print_heredoc_body (redirect);
      break;

    case r_reading_string:
      if (redirect->rflags & REDIR_VARASSIGN)
	cprintf ("{%s}", redir_word->word);
      else if (redirector != 0)
	cprintf ("%d", redirector);
#if 0
      /* Don't need to check whether or not to requote, since original quotes
         are still intact.  The only thing that has happened is that $'...'
         has been replaced with 'expanded ...'. */
      if (ansic_shouldquote (redirect->redirectee.filename->word))
	{
	  char *x;
	  x = ansic_quote (redirect->redirectee.filename->word, 0, (int *)0);
	  cprintf ("<<< %s", x);
	  free (x);
	}
      else
#endif
	cprintf ("<<< %s", redirect->redirectee.filename->word);
      break;

    case r_duplicating_input:
      if (redirect->rflags & REDIR_VARASSIGN)
	cprintf ("{%s}<&%d", redir_word->word, redir_fd);
      else
	cprintf ("%d<&%d", redirector, redir_fd);
      break;

    case r_duplicating_output:
      if (redirect->rflags & REDIR_VARASSIGN)
	cprintf ("{%s}>&%d", redir_word->word, redir_fd);
      else
	cprintf ("%d>&%d", redirector, redir_fd);
      break;

    case r_duplicating_input_word:
      if (redirect->rflags & REDIR_VARASSIGN)
	cprintf ("{%s}<&%s", redir_word->word, redirectee->word);
      else
	cprintf ("%d<&%s", redirector, redirectee->word);
      break;

    case r_duplicating_output_word:
      if (redirect->rflags & REDIR_VARASSIGN)
	cprintf ("{%s}>&%s", redir_word->word, redirectee->word);
      else
	cprintf ("%d>&%s", redirector, redirectee->word);
      break;

    case r_move_input:
      if (redirect->rflags & REDIR_VARASSIGN)
	cprintf ("{%s}<&%d-", redir_word->word, redir_fd);
      else
	cprintf ("%d<&%d-", redirector, redir_fd);
      break;

    case r_move_output:
      if (redirect->rflags & REDIR_VARASSIGN)
	cprintf ("{%s}>&%d-", redir_word->word, redir_fd);
      else
	cprintf ("%d>&%d-", redirector, redir_fd);
      break;

    case r_move_input_word:
      if (redirect->rflags & REDIR_VARASSIGN)
	cprintf ("{%s}<&%s-", redir_word->word, redirectee->word);
      else
	cprintf ("%d<&%s-", redirector, redirectee->word);
      break;

    case r_move_output_word:
      if (redirect->rflags & REDIR_VARASSIGN)
	cprintf ("{%s}>&%s-", redir_word->word, redirectee->word);
      else
	cprintf ("%d>&%s-", redirector, redirectee->word);
      break;

    case r_close_this:
      if (redirect->rflags & REDIR_VARASSIGN)
	cprintf ("{%s}>&-", redir_word->word);
      else
	cprintf ("%d>&-", redirector);
      break;

    case r_err_and_out:
      cprintf ("&>%s", redirectee->word);
      break;

    case r_append_err_and_out:
      cprintf ("&>>%s", redirectee->word);
      break;
    }
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\print_cmd.c:1,067
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\print_cmd.c:1,234
parsing error 
{
  COMMAND *cmdcopy;
  REDIRECT *func_redirects;

  func_redirects = NULL;
  cprintf ("function %s () \n", func->name->word);
  add_unwind_protect (reset_locals, 0);

  indent (indentation);
  cprintf ("{ \n");

  inside_function_def++;
  indentation += indentation_amount;

  cmdcopy = copy_command (func->command);
  if (cmdcopy->type == cm_group)
    {
      func_redirects = cmdcopy->redirects;
      cmdcopy->redirects = (REDIRECT *)NULL;
    }
  make_command_string_internal (cmdcopy->type == cm_group
					? cmdcopy->value.Group->command
					: cmdcopy);

  remove_unwind_protect ();
  indentation -= indentation_amount;
  inside_function_def--;

  if (func_redirects)
    { /* { */
      newline ("} ");
      print_redirection_list (func_redirects);
      cmdcopy->redirects = func_redirects;
    }
  else
    newline ("}");

  dispose_command (cmdcopy);
}
warning: parse error {
  COMMAND *cmdcopy;
  REDIRECT *func_redirects;

  func_redirects = NULL;
  cprintf ("function %s () \n", func->name->word);
  add_unwind_protect (reset_locals, 0);

  indent (indentation);
  cprintf ("{ \n");

  inside_function_def++;
  indentation += indentation_amount;

  cmdcopy = copy_command (func->command);
  if (cmdcopy->type == cm_group)
    {
      func_redirects = cmdcopy->redirects;
      cmdcopy->redirects = (REDIRECT *)NULL;
    }
  make_command_string_internal (cmdcopy->type == cm_group
					? cmdcopy->value.Group->command
					: cmdcopy);

  remove_unwind_protect ();
  indentation -= indentation_amount;
  inside_function_def--;

  if (func_redirects)
    { /* { */
      newline ("} ");
      print_redirection_list (func_redirects);
      cmdcopy->redirects = func_redirects;
    }
  else
    newline ("}");

  dispose_command (cmdcopy);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\print_cmd.c:1,236
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\print_cmd.c:1,283
parsing error 
{
  char *result;
  int old_indent, old_amount;
  COMMAND *cmdcopy;
  REDIRECT *func_redirects;

  old_indent = indentation;
  old_amount = indentation_amount;
  command_string_index = was_heredoc = 0;
  deferred_heredocs = 0;

  if (name && *name)
    cprintf ("%s ", name);

  cprintf ("() ");

  if ((flags & FUNC_MULTILINE) == 0)
    {
      indentation = 1;
      indentation_amount = 0;
    }
  else
    {
      cprintf ("\n");
      indentation += indentation_amount;
    }

  inside_function_def++;

  cprintf ((flags & FUNC_MULTILINE) ? "{ \n" : "{ ");

  cmdcopy = copy_command (command);
  /* Take any redirections specified in the function definition (which should
     apply to the function as a whole) and save them for printing later. */
  func_redirects = (REDIRECT *)NULL;
  if (cmdcopy->type == cm_group)
    {
      func_redirects = cmdcopy->redirects;
      cmdcopy->redirects = (REDIRECT *)NULL;
    }
  make_command_string_internal (cmdcopy->type == cm_group
					? cmdcopy->value.Group->command
					: cmdcopy);

  indentation = old_indent;
  indentation_amount = old_amount;
  inside_function_def--;

  if (func_redirects)
    { /* { */
      newline ("} ");
      print_redirection_list (func_redirects);
      cmdcopy->redirects = func_redirects;
    }
  else
    newline ("}");

  result = the_printed_command;

  if ((flags & FUNC_MULTILINE) == 0)
    {
#if 0
      register int i;
      for (i = 0; result[i]; i++)
	if (result[i] == '\n')
	  {
	    strcpy (result + i, result + i + 1);
	    --i;
	  }
#else
      if (result[2] == '\n')	/* XXX -- experimental */
	strcpy (result + 2, result + 3);
#endif
    }

  dispose_command (cmdcopy);

  if (flags & FUNC_EXTERNAL)
    result = remove_quoted_escapes (result);

  return (result);
}
warning: parse error {
  char *result;
  int old_indent, old_amount;
  COMMAND *cmdcopy;
  REDIRECT *func_redirects;

  old_indent = indentation;
  old_amount = indentation_amount;
  command_string_index = was_heredoc = 0;
  deferred_heredocs = 0;

  if (name && *name)
    cprintf ("%s ", name);

  cprintf ("() ");

  if ((flags & FUNC_MULTILINE) == 0)
    {
      indentation = 1;
      indentation_amount = 0;
    }
  else
    {
      cprintf ("\n");
      indentation += indentation_amount;
    }

  inside_function_def++;

  cprintf ((flags & FUNC_MULTILINE) ? "{ \n" : "{ ");

  cmdcopy = copy_command (command);
  /* Take any redirections specified in the function definition (which should
     apply to the function as a whole) and save them for printing later. */
  func_redirects = (REDIRECT *)NULL;
  if (cmdcopy->type == cm_group)
    {
      func_redirects = cmdcopy->redirects;
      cmdcopy->redirects = (REDIRECT *)NULL;
    }
  make_command_string_internal (cmdcopy->type == cm_group
					? cmdcopy->value.Group->command
					: cmdcopy);

  indentation = old_indent;
  indentation_amount = old_amount;
  inside_function_def--;

  if (func_redirects)
    { /* { */
      newline ("} ");
      print_redirection_list (func_redirects);
      cmdcopy->redirects = func_redirects;
    }
  else
    newline ("}");

  result = the_printed_command;

  if ((flags & FUNC_MULTILINE) == 0)
    {
#if 0
      register int i;
      for (i = 0; result[i]; i++)
	if (result[i] == '\n')
	  {
	    strcpy (result + i, result + i + 1);
	    --i;
	  }
#else
      if (result[2] == '\n')	/* XXX -- experimental */
	strcpy (result + 2, result + 3);
#endif
    }

  dispose_command (cmdcopy);

  if (flags & FUNC_EXTERNAL)
    result = remove_quoted_escapes (result);

  return (result);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\print_cmd.c:1,287
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\print_cmd.c:1,371
parsing error 
{
  cprintf ("\n");
  indent (indentation);
  if (string && *string)
    cprintf ("%s", string);
}
warning: parse error {
  cprintf ("\n");
  indent (indentation);
  if (string && *string)
    cprintf ("%s", string);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\print_cmd.c:1,373
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\print_cmd.c:1,384
parsing error 
{
  register int i;

  RESIZE_MALLOCED_BUFFER (indentation_string, 0, amount, indentation_size, 16);

  for (i = 0; amount > 0; amount--)
    indentation_string[i++] = ' ';
  indentation_string[i] = '\0';
  cprintf (indentation_string);
}
warning: parse error {
  register int i;

  RESIZE_MALLOCED_BUFFER (indentation_string, 0, amount, indentation_size, 16);

  for (i = 0; amount > 0; amount--)
    indentation_string[i++] = ' ';
  indentation_string[i] = '\0';
  cprintf (indentation_string);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\print_cmd.c:1,386
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\print_cmd.c:1,413
parsing error 
va_dcl
#endif
{
  register const char *s;
  char char_arg[2], *argp, intbuf[INT_STRLEN_BOUND (int) + 1];
  int digit_arg, arg_len, c;
  va_list args;

  SH_VA_START (args, control);

  arg_len = strlen (control);
  the_printed_command_resize (arg_len + 1);

  char_arg[1] = '\0';
  s = control;
  while (s && *s)
    {
      c = *s++;
      argp = (char *)NULL;
      if (c != '%' || !*s)
	{
	  char_arg[0] = c;
	  argp = char_arg;
	  arg_len = 1;
	}
      else
	{
	  c = *s++;
	  switch (c)
	    {
	    case '%':
	      char_arg[0] = c;
	      argp = char_arg;
	      arg_len = 1;
	      break;

	    case 's':
	      argp = va_arg (args, char *);
	      arg_len = strlen (argp);
	      break;

	    case 'd':
	      /* Represent an out-of-range file descriptor with an out-of-range
		 integer value.  We can do this because the only use of `%d' in
		 the calls to cprintf is to output a file descriptor number for
		 a redirection. */
	      digit_arg = va_arg (args, int);
	      if (digit_arg < 0)
		{
		  sprintf (intbuf, "%u", (unsigned)-1);
		  argp = intbuf;
		}
	      else
		argp = inttostr (digit_arg, intbuf, sizeof (intbuf));
	      arg_len = strlen (argp);
	      break;

	    case 'c':
	      char_arg[0] = va_arg (args, int);
	      argp = char_arg;
	      arg_len = 1;
	      break;

	    default:
	      programming_error (_("cprintf: `%c': invalid format character"), c);
	      /*NOTREACHED*/
	    }
	}

      if (argp && arg_len)
	{
	  the_printed_command_resize (arg_len + 1);
	  FASTCOPY (argp, the_printed_command + command_string_index, arg_len);
	  command_string_index += arg_len;
	}
    }

  the_printed_command[command_string_index] = '\0';
}
warning: parse error va_dcl
#endif
{
  register const char *s;
  char char_arg[2], *argp, intbuf[INT_STRLEN_BOUND (int) + 1];
  int digit_arg, arg_len, c;
  va_list args;

  SH_VA_START (args, control);

  arg_len = strlen (control);
  the_printed_command_resize (arg_len + 1);

  char_arg[1] = '\0';
  s = control;
  while (s && *s)
    {
      c = *s++;
      argp = (char *)NULL;
      if (c != '%' || !*s)
	{
	  char_arg[0] = c;
	  argp = char_arg;
	  arg_len = 1;
	}
      else
	{
	  c = *s++;
	  switch (c)
	    {
	    case '%':
	      char_arg[0] = c;
	      argp = char_arg;
	      arg_len = 1;
	      break;

	    case 's':
	      argp = va_arg (args, char *);
	      arg_len = strlen (argp);
	      break;

	    case 'd':
	      /* Represent an out-of-range file descriptor with an out-of-range
		 integer value.  We can do this because the only use of `%d' in
		 the calls to cprintf is to output a file descriptor number for
		 a redirection. */
	      digit_arg = va_arg (args, int);
	      if (digit_arg < 0)
		{
		  sprintf (intbuf, "%u", (unsigned)-1);
		  argp = intbuf;
		}
	      else
		argp = inttostr (digit_arg, intbuf, sizeof (intbuf));
	      arg_len = strlen (argp);
	      break;

	    case 'c':
	      char_arg[0] = va_arg (args, int);
	      argp = char_arg;
	      arg_len = 1;
	      break;

	    default:
	      programming_error (_("cprintf: `%c': invalid format character"), c);
	      /*NOTREACHED*/
	    }
	}

      if (argp && arg_len)
	{
	  the_printed_command_resize (arg_len + 1);
	  FASTCOPY (argp, the_printed_command + command_string_index, arg_len);
	  command_string_index += arg_len;
	}
    }

  the_printed_command[command_string_index] = '\0';
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\print_cmd.c:1,414
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\print_cmd.c:1,497
parsing error 
{
  if (the_printed_command == 0)
    {
      the_printed_command_size = (length + PRINTED_COMMAND_INITIAL_SIZE - 1) & ~(PRINTED_COMMAND_INITIAL_SIZE - 1);
      the_printed_command = (char *)xmalloc (the_printed_command_size);
      command_string_index = 0;
    }
  else if ((command_string_index + length) >= the_printed_command_size)
    {
      int new;
      new = command_string_index + length + 1;

      /* Round up to the next multiple of PRINTED_COMMAND_GROW_SIZE. */
      new = (new + PRINTED_COMMAND_GROW_SIZE - 1) & ~(PRINTED_COMMAND_GROW_SIZE - 1);
      the_printed_command_size = new;

      the_printed_command = (char *)xrealloc (the_printed_command, the_printed_command_size);
    }
}
warning: parse error {
  if (the_printed_command == 0)
    {
      the_printed_command_size = (length + PRINTED_COMMAND_INITIAL_SIZE - 1) & ~(PRINTED_COMMAND_INITIAL_SIZE - 1);
      the_printed_command = (char *)xmalloc (the_printed_command_size);
      command_string_index = 0;
    }
  else if ((command_string_index + length) >= the_printed_command_size)
    {
      int new;
      new = command_string_index + length + 1;

      /* Round up to the next multiple of PRINTED_COMMAND_GROW_SIZE. */
      new = (new + PRINTED_COMMAND_GROW_SIZE - 1) & ~(PRINTED_COMMAND_GROW_SIZE - 1);
      the_printed_command_size = new;

      the_printed_command = (char *)xrealloc (the_printed_command, the_printed_command_size);
    }
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\print_cmd.c:1,499
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\print_cmd.c:1,544
parsing error 
{
  printf (format, arg1, arg2, arg3, arg4, arg5);
}
warning: parse error {
  printf (format, arg1, arg2, arg3, arg4, arg5);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\print_cmd.c:1,545
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\redir.c...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\bashtypes.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\filecntl.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\posixstat.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\bashansi.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\bashintl.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\memalloc.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\shell.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\flags.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\execute_cmd.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\redir.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\redir.c:109
parsing error 
{
  char *filename, *allocname;
  int oflags;

  allocname = 0;
  if (temp->rflags & REDIR_VARASSIGN)
    filename = savestring (temp->redirector.filename->word);
  else if (temp->redirector.dest < 0)
    /* This can happen when read_token_word encounters overflow, like in
       exec 4294967297>x */
    filename = _("file descriptor out of range");
#ifdef EBADF
  /* This error can never involve NOCLOBBER */
  else if (error != NOCLOBBER_REDIRECT && temp->redirector.dest >= 0 && error == EBADF)
    {
      /* If we're dealing with two file descriptors, we have to guess about
         which one is invalid; in the cases of r_{duplicating,move}_input and
         r_{duplicating,move}_output we're here because dup2() failed. */
      switch (temp->instruction)
        {
        case r_duplicating_input:
        case r_duplicating_output:
        case r_move_input:
        case r_move_output:
	  filename = allocname = itos (temp->redirectee.dest);
	  break;
	case r_duplicating_input_word:
	  if (temp->redirector.dest == 0)	/* Guess */
	    filename = temp->redirectee.filename->word;	/* XXX */
	  else
	    filename = allocname = itos (temp->redirector.dest);
	  break;
	case r_duplicating_output_word:
	  if (temp->redirector.dest == 1)	/* Guess */
	    filename = temp->redirectee.filename->word;	/* XXX */
	  else
	    filename = allocname = itos (temp->redirector.dest);
	  break;
	default:
	  filename = allocname = itos (temp->redirector.dest);
	  break;
        }
    }
#endif
  else if (expandable_redirection_filename (temp))
    {
expandable_filename:
      if (posixly_correct && interactive_shell == 0)
	{
	  oflags = temp->redirectee.filename->flags;
	  temp->redirectee.filename->flags |= W_NOGLOB;
	}
      filename = allocname = redirection_expand (temp->redirectee.filename);
      if (posixly_correct && interactive_shell == 0)
	temp->redirectee.filename->flags = oflags;
      if (filename == 0)
	filename = temp->redirectee.filename->word;
    }
  else if (temp->redirectee.dest < 0)
    filename = "file descriptor out of range";
  else
    filename = allocname = itos (temp->redirectee.dest);

  switch (error)
    {
    case AMBIGUOUS_REDIRECT:
      internal_error (_("%s: ambiguous redirect"), filename);
      break;

    case NOCLOBBER_REDIRECT:
      internal_error (_("%s: cannot overwrite existing file"), filename);
      break;

#if defined (RESTRICTED_SHELL)
    case RESTRICTED_REDIRECT:
      internal_error (_("%s: restricted: cannot redirect output"), filename);
      break;
#endif /* RESTRICTED_SHELL */

    case HEREDOC_REDIRECT:
      internal_error (_("cannot create temp file for here-document: %s"), strerror (heredoc_errno));
      break;

    case BADVAR_REDIRECT:
      internal_error (_("%s: cannot assign fd to variable"), filename);
      break;

    default:
      internal_error ("%s: %s", filename, strerror (error));
      break;
    }

  FREE (allocname);
}
warning: parse error {
  char *filename, *allocname;
  int oflags;

  allocname = 0;
  if (temp->rflags & REDIR_VARASSIGN)
    filename = savestring (temp->redirector.filename->word);
  else if (temp->redirector.dest < 0)
    /* This can happen when read_token_word encounters overflow, like in
       exec 4294967297>x */
    filename = _("file descriptor out of range");
#ifdef EBADF
  /* This error can never involve NOCLOBBER */
  else if (error != NOCLOBBER_REDIRECT && temp->redirector.dest >= 0 && error == EBADF)
    {
      /* If we're dealing with two file descriptors, we have to guess about
         which one is invalid; in the cases of r_{duplicating,move}_input and
         r_{duplicating,move}_output we're here because dup2() failed. */
      switch (temp->instruction)
        {
        case r_duplicating_input:
        case r_duplicating_output:
        case r_move_input:
        case r_move_output:
	  filename = allocname = itos (temp->redirectee.dest);
	  break;
	case r_duplicating_input_word:
	  if (temp->redirector.dest == 0)	/* Guess */
	    filename = temp->redirectee.filename->word;	/* XXX */
	  else
	    filename = allocname = itos (temp->redirector.dest);
	  break;
	case r_duplicating_output_word:
	  if (temp->redirector.dest == 1)	/* Guess */
	    filename = temp->redirectee.filename->word;	/* XXX */
	  else
	    filename = allocname = itos (temp->redirector.dest);
	  break;
	default:
	  filename = allocname = itos (temp->redirector.dest);
	  break;
        }
    }
#endif
  else if (expandable_redirection_filename (temp))
    {
expandable_filename:
      if (posixly_correct && interactive_shell == 0)
	{
	  oflags = temp->redirectee.filename->flags;
	  temp->redirectee.filename->flags |= W_NOGLOB;
	}
      filename = allocname = redirection_expand (temp->redirectee.filename);
      if (posixly_correct && interactive_shell == 0)
	temp->redirectee.filename->flags = oflags;
      if (filename == 0)
	filename = temp->redirectee.filename->word;
    }
  else if (temp->redirectee.dest < 0)
    filename = "file descriptor out of range";
  else
    filename = allocname = itos (temp->redirectee.dest);

  switch (error)
    {
    case AMBIGUOUS_REDIRECT:
      internal_error (_("%s: ambiguous redirect"), filename);
      break;

    case NOCLOBBER_REDIRECT:
      internal_error (_("%s: cannot overwrite existing file"), filename);
      break;

#if defined (RESTRICTED_SHELL)
    case RESTRICTED_REDIRECT:
      internal_error (_("%s: restricted: cannot redirect output"), filename);
      break;
#endif /* RESTRICTED_SHELL */

    case HEREDOC_REDIRECT:
      internal_error (_("cannot create temp file for here-document: %s"), strerror (heredoc_errno));
      break;

    case BADVAR_REDIRECT:
      internal_error (_("%s: cannot assign fd to variable"), filename);
      break;

    default:
      internal_error ("%s: %s", filename, strerror (error));
      break;
    }

  FREE (allocname);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\redir.c:112
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\redir.c:214
parsing error 
{
  int error;
  REDIRECT *temp;

  if (flags & RX_UNDOABLE)
    {
      if (redirection_undo_list)
	{
	  dispose_redirects (redirection_undo_list);
	  redirection_undo_list = (REDIRECT *)NULL;
	}
      if (exec_redirection_undo_list)
	dispose_exec_redirects ();
    }

  for (temp = list; temp; temp = temp->next)
    {
      error = do_redirection_internal (temp, flags);
      if (error)
	{
	  redirection_error (temp, error);
	  return (error);
	}
    }
  return (0);
}
warning: parse error {
  int error;
  REDIRECT *temp;

  if (flags & RX_UNDOABLE)
    {
      if (redirection_undo_list)
	{
	  dispose_redirects (redirection_undo_list);
	  redirection_undo_list = (REDIRECT *)NULL;
	}
      if (exec_redirection_undo_list)
	dispose_exec_redirects ();
    }

  for (temp = list; temp; temp = temp->next)
    {
      error = do_redirection_internal (temp, flags);
      if (error)
	{
	  redirection_error (temp, error);
	  return (error);
	}
    }
  return (0);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\redir.c:217
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\redir.c:247
parsing error 
{
  switch (redirect->instruction)
    {
    case r_output_direction:
    case r_appending_to:
    case r_input_direction:
    case r_inputa_direction:
    case r_err_and_out:
    case r_append_err_and_out:
    case r_input_output:
    case r_output_force:
    case r_duplicating_input_word:
    case r_duplicating_output_word:
    case r_move_input_word:
    case r_move_output_word:
      return 1;

    default:
      return 0;
    }
}
warning: parse error {
  switch (redirect->instruction)
    {
    case r_output_direction:
    case r_appending_to:
    case r_input_direction:
    case r_inputa_direction:
    case r_err_and_out:
    case r_append_err_and_out:
    case r_input_output:
    case r_output_force:
    case r_duplicating_input_word:
    case r_duplicating_output_word:
    case r_move_input_word:
    case r_move_output_word:
      return 1;

    default:
      return 0;
    }
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\redir.c:249
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\redir.c:274
parsing error 
{
  char *result;
  WORD_LIST *tlist1, *tlist2;
  WORD_DESC *w;

  w = copy_word (word);
  if (posixly_correct)
    w->flags |= W_NOSPLIT;

  tlist1 = make_word_list (w, (WORD_LIST *)NULL);
  expanding_redir = 1;
  tlist2 = expand_words_no_vars (tlist1);
  expanding_redir = 0;
  dispose_words (tlist1);

  if (!tlist2 || tlist2->next)
    {
      /* We expanded to no words, or to more than a single word.
	 Dispose of the word list and return NULL. */
      if (tlist2)
	dispose_words (tlist2);
      return ((char *)NULL);
    }
  result = string_list (tlist2);  /* XXX savestring (tlist2->word->word)? */
  dispose_words (tlist2);
  return (result);
}
warning: parse error {
  char *result;
  WORD_LIST *tlist1, *tlist2;
  WORD_DESC *w;

  w = copy_word (word);
  if (posixly_correct)
    w->flags |= W_NOSPLIT;

  tlist1 = make_word_list (w, (WORD_LIST *)NULL);
  expanding_redir = 1;
  tlist2 = expand_words_no_vars (tlist1);
  expanding_redir = 0;
  dispose_words (tlist1);

  if (!tlist2 || tlist2->next)
    {
      /* We expanded to no words, or to more than a single word.
	 Dispose of the word list and return NULL. */
      if (tlist2)
	dispose_words (tlist2);
      return ((char *)NULL);
    }
  result = string_list (tlist2);  /* XXX savestring (tlist2->word->word)? */
  dispose_words (tlist2);
  return (result);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\redir.c:276
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\redir.c:305
parsing error 
{
  char *herestr;
  int herelen, n, e;

  expanding_redir = 1;
  herestr = expand_string_to_string (redirectee->word, 0);
  expanding_redir = 0;
  herelen = STRLEN (herestr);

  n = write (fd, herestr, herelen);
  if (n == herelen)
    {
      n = write (fd, "\n", 1);
      herelen = 1;
    }
  e = errno;
  FREE (herestr);
  if (n != herelen)
    {
      if (e == 0)
	e = ENOSPC;
      return e;
    }
  return 0;
}
warning: parse error {
  char *herestr;
  int herelen, n, e;

  expanding_redir = 1;
  herestr = expand_string_to_string (redirectee->word, 0);
  expanding_redir = 0;
  herelen = STRLEN (herestr);

  n = write (fd, herestr, herelen);
  if (n == herelen)
    {
      n = write (fd, "\n", 1);
      herelen = 1;
    }
  e = errno;
  FREE (herestr);
  if (n != herelen)
    {
      if (e == 0)
	e = ENOSPC;
      return e;
    }
  return 0;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\redir.c:308
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\redir.c:338
parsing error 
{
  char *document;
  int document_len, fd2;
  FILE *fp;
  register WORD_LIST *t, *tlist;

  /* Expand the text if the word that was specified had
     no quoting.  The text that we expand is treated
     exactly as if it were surrounded by double quotes. */

  if (redirectee->flags & W_QUOTED)
    {
      document = redirectee->word;
      document_len = strlen (document);
      /* Set errno to something reasonable if the write fails. */
      if (write (fd, document, document_len) < document_len)
	{
	  if (errno == 0)
	    errno = ENOSPC;
	  return (errno);
	}
      else
	return 0;
    }

  expanding_redir = 1;
  tlist = expand_string (redirectee->word, Q_HERE_DOCUMENT);
  expanding_redir = 0;

  if (tlist)
    {
      /* Try using buffered I/O (stdio) and writing a word
	 at a time, letting stdio do the work of buffering
	 for us rather than managing our own strings.  Most
	 stdios are not particularly fast, however -- this
	 may need to be reconsidered later. */
      if ((fd2 = dup (fd)) < 0 || (fp = fdopen (fd2, "w")) == NULL)
	{
	  if (fd2 >= 0)
	    close (fd2);
	  return (errno);
	}
      errno = 0;
      for (t = tlist; t; t = t->next)
	{
	  /* This is essentially the body of
	     string_list_internal expanded inline. */
	  document = t->word->word;
	  document_len = strlen (document);
	  if (t != tlist)
	    putc (' ', fp);	/* separator */
	  fwrite (document, document_len, 1, fp);
	  if (ferror (fp))
	    {
	      if (errno == 0)
		errno = ENOSPC;
	      fd2 = errno;
	      fclose(fp);
	      dispose_words (tlist);
	      return (fd2);
	    }
	}
      dispose_words (tlist);
      if (fclose (fp) != 0)
	{
	  if (errno == 0)
	    errno = ENOSPC;
	  return (errno);
	}
    }
  return 0;
}
warning: parse error {
  char *document;
  int document_len, fd2;
  FILE *fp;
  register WORD_LIST *t, *tlist;

  /* Expand the text if the word that was specified had
     no quoting.  The text that we expand is treated
     exactly as if it were surrounded by double quotes. */

  if (redirectee->flags & W_QUOTED)
    {
      document = redirectee->word;
      document_len = strlen (document);
      /* Set errno to something reasonable if the write fails. */
      if (write (fd, document, document_len) < document_len)
	{
	  if (errno == 0)
	    errno = ENOSPC;
	  return (errno);
	}
      else
	return 0;
    }

  expanding_redir = 1;
  tlist = expand_string (redirectee->word, Q_HERE_DOCUMENT);
  expanding_redir = 0;

  if (tlist)
    {
      /* Try using buffered I/O (stdio) and writing a word
	 at a time, letting stdio do the work of buffering
	 for us rather than managing our own strings.  Most
	 stdios are not particularly fast, however -- this
	 may need to be reconsidered later. */
      if ((fd2 = dup (fd)) < 0 || (fp = fdopen (fd2, "w")) == NULL)
	{
	  if (fd2 >= 0)
	    close (fd2);
	  return (errno);
	}
      errno = 0;
      for (t = tlist; t; t = t->next)
	{
	  /* This is essentially the body of
	     string_list_internal expanded inline. */
	  document = t->word->word;
	  document_len = strlen (document);
	  if (t != tlist)
	    putc (' ', fp);	/* separator */
	  fwrite (document, document_len, 1, fp);
	  if (ferror (fp))
	    {
	      if (errno == 0)
		errno = ENOSPC;
	      fd2 = errno;
	      fclose(fp);
	      dispose_words (tlist);
	      return (fd2);
	    }
	}
      dispose_words (tlist);
      if (fclose (fp) != 0)
	{
	  if (errno == 0)
	    errno = ENOSPC;
	  return (errno);
	}
    }
  return 0;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\redir.c:341
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\redir.c:418
parsing error 
{
  char *filename;
  int r, fd, fd2;

  fd = sh_mktmpfd ("sh-thd", MT_USERANDOM|MT_USETMPDIR, &filename);

  /* If we failed for some reason other than the file existing, abort */
  if (fd < 0)
    {
      FREE (filename);
      return (fd);
    }

  errno = r = 0;		/* XXX */
  /* write_here_document returns 0 on success, errno on failure. */
  if (redirectee->word)
    r = (ri != r_reading_string) ? write_here_document (fd, redirectee)
				 : write_here_string (fd, redirectee);

  if (r)
    {
      close (fd);
      unlink (filename);
      free (filename);
      errno = r;
      return (-1);
    }

  /* In an attempt to avoid races, we close the first fd only after opening
     the second. */
  /* Make the document really temporary.  Also make it the input. */
  fd2 = open (filename, O_RDONLY|O_BINARY, 0600);

  if (fd2 < 0)
    {
      r = errno;
      unlink (filename);
      free (filename);
      close (fd);
      errno = r;
      return -1;
    }

  close (fd);
  if (unlink (filename) < 0)
    {
      r = errno;
      close (fd2);
      free (filename);
      errno = r;
      return (-1);
    }

  free (filename);
  return (fd2);
}
warning: parse error {
  char *filename;
  int r, fd, fd2;

  fd = sh_mktmpfd ("sh-thd", MT_USERANDOM|MT_USETMPDIR, &filename);

  /* If we failed for some reason other than the file existing, abort */
  if (fd < 0)
    {
      FREE (filename);
      return (fd);
    }

  errno = r = 0;		/* XXX */
  /* write_here_document returns 0 on success, errno on failure. */
  if (redirectee->word)
    r = (ri != r_reading_string) ? write_here_document (fd, redirectee)
				 : write_here_string (fd, redirectee);

  if (r)
    {
      close (fd);
      unlink (filename);
      free (filename);
      errno = r;
      return (-1);
    }

  /* In an attempt to avoid races, we close the first fd only after opening
     the second. */
  /* Make the document really temporary.  Also make it the input. */
  fd2 = open (filename, O_RDONLY|O_BINARY, 0600);

  if (fd2 < 0)
    {
      r = errno;
      unlink (filename);
      free (filename);
      close (fd);
      errno = r;
      return -1;
    }

  close (fd);
  if (unlink (filename) < 0)
    {
      r = errno;
      close (fd2);
      free (filename);
      errno = r;
      return (-1);
    }

  free (filename);
  return (fd2);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\redir.c:421
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\redir.c:504
parsing error 
{
  int fd;
#if !defined (HAVE_DEV_FD)
  intmax_t lfd;
#endif

  fd = -1;
  switch (spec)
    {
#if !defined (HAVE_DEV_FD)
    case RF_DEVFD:
      if (all_digits (filename+8) && legal_number (filename+8, &lfd) && lfd == (int)lfd)
	{
	  fd = lfd;
	  fd = fcntl (fd, F_DUPFD, SHELL_FD_BASE);
	}
      else
	fd = AMBIGUOUS_REDIRECT;
      break;
#endif

#if !defined (HAVE_DEV_STDIN)
    case RF_DEVSTDIN:
      fd = fcntl (0, F_DUPFD, SHELL_FD_BASE);
      break;
    case RF_DEVSTDOUT:
      fd = fcntl (1, F_DUPFD, SHELL_FD_BASE);
      break;
    case RF_DEVSTDERR:
      fd = fcntl (2, F_DUPFD, SHELL_FD_BASE);
      break;
#endif

#if defined (NETWORK_REDIRECTIONS)
    case RF_DEVTCP:
    case RF_DEVUDP:
#if defined (HAVE_NETWORK)
      fd = netopen (filename);
#else
      internal_warning (_("/dev/(tcp|udp)/host/port not supported without networking"));
      fd = open (filename, flags, mode);
#endif
      break;
#endif /* NETWORK_REDIRECTIONS */
    }

  return fd;
}
warning: parse error {
  int fd;
#if !defined (HAVE_DEV_FD)
  intmax_t lfd;
#endif

  fd = -1;
  switch (spec)
    {
#if !defined (HAVE_DEV_FD)
    case RF_DEVFD:
      if (all_digits (filename+8) && legal_number (filename+8, &lfd) && lfd == (int)lfd)
	{
	  fd = lfd;
	  fd = fcntl (fd, F_DUPFD, SHELL_FD_BASE);
	}
      else
	fd = AMBIGUOUS_REDIRECT;
      break;
#endif

#if !defined (HAVE_DEV_STDIN)
    case RF_DEVSTDIN:
      fd = fcntl (0, F_DUPFD, SHELL_FD_BASE);
      break;
    case RF_DEVSTDOUT:
      fd = fcntl (1, F_DUPFD, SHELL_FD_BASE);
      break;
    case RF_DEVSTDERR:
      fd = fcntl (2, F_DUPFD, SHELL_FD_BASE);
      break;
#endif

#if defined (NETWORK_REDIRECTIONS)
    case RF_DEVTCP:
    case RF_DEVUDP:
#if defined (HAVE_NETWORK)
      fd = netopen (filename);
#else
      internal_warning (_("/dev/(tcp|udp)/host/port not supported without networking"));
      fd = open (filename, flags, mode);
#endif
      break;
#endif /* NETWORK_REDIRECTIONS */
    }

  return fd;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\redir.c:509
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\redir.c:562
parsing error 
{
  int r, fd;
  struct stat finfo, finfo2;

  /* If the file exists and is a regular file, return an error
     immediately. */
  r = stat (filename, &finfo);
  if (r == 0 && (S_ISREG (finfo.st_mode)))
    return (NOCLOBBER_REDIRECT);

  /* If the file was not present (r != 0), make sure we open it
     exclusively so that if it is created before we open it, our open
     will fail.  Make sure that we do not truncate an existing file.
     Note that we don't turn on O_EXCL unless the stat failed -- if
     the file was not a regular file, we leave O_EXCL off. */
  flags &= ~O_TRUNC;
  if (r != 0)
    {
      fd = open (filename, flags|O_EXCL, mode);
      return ((fd < 0 && errno == EEXIST) ? NOCLOBBER_REDIRECT : fd);
    }
  fd = open (filename, flags, mode);

  /* If the open failed, return the file descriptor right away. */
  if (fd < 0)
    return (errno == EEXIST ? NOCLOBBER_REDIRECT : fd);

  /* OK, the open succeeded, but the file may have been changed from a
     non-regular file to a regular file between the stat and the open.
     We are assuming that the O_EXCL open handles the case where FILENAME
     did not exist and is symlinked to an existing file between the stat
     and open. */

  /* If we can open it and fstat the file descriptor, and neither check
     revealed that it was a regular file, and the file has not been replaced,
     return the file descriptor. */
  if ((fstat (fd, &finfo2) == 0) && (S_ISREG (finfo2.st_mode) == 0) &&
      r == 0 && (S_ISREG (finfo.st_mode) == 0) &&
      same_file (filename, filename, &finfo, &finfo2))
    return fd;

  /* The file has been replaced.  badness. */
  close (fd);  
  errno = EEXIST;
  return (NOCLOBBER_REDIRECT);
}
warning: parse error {
  int r, fd;
  struct stat finfo, finfo2;

  /* If the file exists and is a regular file, return an error
     immediately. */
  r = stat (filename, &finfo);
  if (r == 0 && (S_ISREG (finfo.st_mode)))
    return (NOCLOBBER_REDIRECT);

  /* If the file was not present (r != 0), make sure we open it
     exclusively so that if it is created before we open it, our open
     will fail.  Make sure that we do not truncate an existing file.
     Note that we don't turn on O_EXCL unless the stat failed -- if
     the file was not a regular file, we leave O_EXCL off. */
  flags &= ~O_TRUNC;
  if (r != 0)
    {
      fd = open (filename, flags|O_EXCL, mode);
      return ((fd < 0 && errno == EEXIST) ? NOCLOBBER_REDIRECT : fd);
    }
  fd = open (filename, flags, mode);

  /* If the open failed, return the file descriptor right away. */
  if (fd < 0)
    return (errno == EEXIST ? NOCLOBBER_REDIRECT : fd);

  /* OK, the open succeeded, but the file may have been changed from a
     non-regular file to a regular file between the stat and the open.
     We are assuming that the O_EXCL open handles the case where FILENAME
     did not exist and is symlinked to an existing file between the stat
     and open. */

  /* If we can open it and fstat the file descriptor, and neither check
     revealed that it was a regular file, and the file has not been replaced,
     return the file descriptor. */
  if ((fstat (fd, &finfo2) == 0) && (S_ISREG (finfo2.st_mode) == 0) &&
      r == 0 && (S_ISREG (finfo.st_mode) == 0) &&
      same_file (filename, filename, &finfo, &finfo2))
    return fd;

  /* The file has been replaced.  badness. */
  close (fd);  
  errno = EEXIST;
  return (NOCLOBBER_REDIRECT);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\redir.c:566
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\redir.c:614
parsing error 
{
  int fd, r;

  r = find_string_in_alist (filename, _redir_special_filenames, 1);
  if (r >= 0)
    return (redir_special_open (r, filename, flags, mode, ri));

  /* If we are in noclobber mode, you are not allowed to overwrite
     existing files.  Check before opening. */
  if (noclobber && CLOBBERING_REDIRECT (ri))
    {
      fd = noclobber_open (filename, flags, mode, ri);
      if (fd == NOCLOBBER_REDIRECT)
	return (NOCLOBBER_REDIRECT);
    }
  else
    {
      fd = open (filename, flags, mode);
#if defined (AFS)
      if ((fd < 0) && (errno == EACCES))
	{
	  fd = open (filename, flags & ~O_CREAT, mode);
	  errno = EACCES;	/* restore errno */
	}
#endif /* AFS */
    }

  return fd;
}
warning: parse error {
  int fd, r;

  r = find_string_in_alist (filename, _redir_special_filenames, 1);
  if (r >= 0)
    return (redir_special_open (r, filename, flags, mode, ri));

  /* If we are in noclobber mode, you are not allowed to overwrite
     existing files.  Check before opening. */
  if (noclobber && CLOBBERING_REDIRECT (ri))
    {
      fd = noclobber_open (filename, flags, mode, ri);
      if (fd == NOCLOBBER_REDIRECT)
	return (NOCLOBBER_REDIRECT);
    }
  else
    {
      fd = open (filename, flags, mode);
#if defined (AFS)
      if ((fd < 0) && (errno == EACCES))
	{
	  fd = open (filename, flags & ~O_CREAT, mode);
	  errno = EACCES;	/* restore errno */
	}
#endif /* AFS */
    }

  return fd;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\redir.c:618
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\redir.c:649
parsing error 
{
  int clexec;

  clexec = fcntl (fd, F_GETFD, 0);
  if (clexec == -1 || (fd >= SHELL_FD_BASE && clexec == 1))
    return 0;
  return 1;
}
warning: parse error {
  int clexec;

  clexec = fcntl (fd, F_GETFD, 0);
  if (clexec == -1 || (fd >= SHELL_FD_BASE && clexec == 1))
    return 0;
  return 1;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\redir.c:651
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\redir.c:668
parsing error 
{
  WORD_DESC *redirectee;
  int redir_fd, fd, redirector, r, oflags;
  intmax_t lfd;
  char *redirectee_word;
  enum r_instruction ri;
  REDIRECT *new_redirect;
  REDIRECTEE sd;

  redirectee = redirect->redirectee.filename;
  redir_fd = redirect->redirectee.dest;
  redirector = redirect->redirector.dest;
  ri = redirect->instruction;

  if (redirect->flags & RX_INTERNAL)
    flags |= RX_INTERNAL;

  if (TRANSLATE_REDIRECT (ri))
    {
      /* We have [N]>&WORD[-] or [N]<&WORD[-] (or {V}>&WORD[-] or {V}<&WORD-).
         and WORD, then translate the redirection into a new one and 
	 continue. */
      redirectee_word = redirection_expand (redirectee);

      /* XXX - what to do with [N]<&$w- where w is unset or null?  ksh93
	       closes N. */
      if (redirectee_word == 0)
	return (AMBIGUOUS_REDIRECT);
      else if (redirectee_word[0] == '-' && redirectee_word[1] == '\0')
	{
	  sd = redirect->redirector;
	  rd.dest = 0;
	  new_redirect = make_redirection (sd, r_close_this, rd, 0);
	}
      else if (all_digits (redirectee_word))
	{
	  sd = redirect->redirector;
	  if (legal_number (redirectee_word, &lfd) && (int)lfd == lfd)
	    rd.dest = lfd;
	  else
	    rd.dest = -1;	/* XXX */
	  switch (ri)
	    {
	    case r_duplicating_input_word:
	      new_redirect = make_redirection (sd, r_duplicating_input, rd, 0);
	      break;
	    case r_duplicating_output_word:
	      new_redirect = make_redirection (sd, r_duplicating_output, rd, 0);
	      break;
	    case r_move_input_word:
	      new_redirect = make_redirection (sd, r_move_input, rd, 0);
	      break;
	    case r_move_output_word:
	      new_redirect = make_redirection (sd, r_move_output, rd, 0);
	      break;
	    }
	}
      else if (ri == r_duplicating_output_word && (redirect->rflags & REDIR_VARASSIGN) == 0 && redirector == 1)
	{
	  sd = redirect->redirector;
	  rd.filename = make_bare_word (redirectee_word);
	  new_redirect = make_redirection (sd, r_err_and_out, rd, 0);
	}
      else
	{
	  free (redirectee_word);
	  return (AMBIGUOUS_REDIRECT);
	}

      free (redirectee_word);

      /* Set up the variables needed by the rest of the function from the
	 new redirection. */
      if (new_redirect->instruction == r_err_and_out)
	{
	  char *alloca_hack;

	  /* Copy the word without allocating any memory that must be
	     explicitly freed. */
	  redirectee = (WORD_DESC *)alloca (sizeof (WORD_DESC));
	  xbcopy ((char *)new_redirect->redirectee.filename,
		 (char *)redirectee, sizeof (WORD_DESC));

	  alloca_hack = (char *)
	    alloca (1 + strlen (new_redirect->redirectee.filename->word));
	  redirectee->word = alloca_hack;
	  strcpy (redirectee->word, new_redirect->redirectee.filename->word);
	}
      else
	/* It's guaranteed to be an integer, and shouldn't be freed. */
	redirectee = new_redirect->redirectee.filename;

      redir_fd = new_redirect->redirectee.dest;
      redirector = new_redirect->redirector.dest;
      ri = new_redirect->instruction;

      /* Overwrite the flags element of the old redirect with the new value. */
      redirect->flags = new_redirect->flags;
      dispose_redirects (new_redirect);
    }

  switch (ri)
    {
    case r_output_direction:
    case r_appending_to:
    case r_input_direction:
    case r_inputa_direction:
    case r_err_and_out:		/* command &>filename */
    case r_append_err_and_out:	/* command &>> filename */
    case r_input_output:
    case r_output_force:
      if (posixly_correct && interactive_shell == 0)
	{
	  oflags = redirectee->flags;
	  redirectee->flags |= W_NOGLOB;
	}
      redirectee_word = redirection_expand (redirectee);
      if (posixly_correct && interactive_shell == 0)
	redirectee->flags = oflags;

      if (redirectee_word == 0)
	return (AMBIGUOUS_REDIRECT);

#if defined (RESTRICTED_SHELL)
      if (restricted && (WRITE_REDIRECT (ri)))
	{
	  free (redirectee_word);
	  return (RESTRICTED_REDIRECT);
	}
#endif /* RESTRICTED_SHELL */

      fd = redir_open (redirectee_word, redirect->flags, 0666, ri);
      free (redirectee_word);

      if (fd == NOCLOBBER_REDIRECT)
	return (fd);

      if (fd < 0)
	return (errno);

      if (flags & RX_ACTIVE)
	{
	  if (redirect->rflags & REDIR_VARASSIGN)
	    {
	      redirector = fcntl (fd, F_DUPFD, SHELL_FD_BASE);		/* XXX try this for now */
	      r = errno;
	      if (redirector < 0)
		sys_error (_("redirection error: cannot duplicate fd"));
	      REDIRECTION_ERROR (redirector, r, fd);
	    }

	  if (flags & RX_UNDOABLE)
	    {
	      /* Only setup to undo it if the thing to undo is active. */
	      if ((fd != redirector) && (fcntl (redirector, F_GETFD, 0) != -1))
		r = add_undo_redirect (redirector, ri, -1);
	      else
		r = add_undo_close_redirect (redirector);
	      if (r < 0 && (redirect->rflags & REDIR_VARASSIGN))
		close (redirector);
	      REDIRECTION_ERROR (r, errno, fd);
	    }

#if defined (BUFFERED_INPUT)
	  check_bash_input (redirector);
#endif

	  /* Make sure there is no pending output before we change the state
	     of the underlying file descriptor, since the builtins use stdio
	     for output. */
	  if (redirector == 1 && fileno (stdout) == redirector)
	    {
	      fflush (stdout);
	      fpurge (stdout);
	    }
	  else if (redirector == 2 && fileno (stderr) == redirector)
	    {
	      fflush (stderr);
	      fpurge (stderr);
	    }

	  if (redirect->rflags & REDIR_VARASSIGN)
	    {
	      if ((r = redir_varassign (redirect, redirector)) < 0)
		{
		  close (redirector);
		  close (fd);
		  return (r);	/* XXX */
		}
	    }
	  else if ((fd != redirector) && (dup2 (fd, redirector) < 0))
	    return (errno);

#if defined (BUFFERED_INPUT)
	  /* Do not change the buffered stream for an implicit redirection
	     of /dev/null to fd 0 for asynchronous commands without job
	     control (r_inputa_direction). */
	  if (ri == r_input_direction || ri == r_input_output)
	    duplicate_buffered_stream (fd, redirector);
#endif /* BUFFERED_INPUT */

	  /*
	   * If we're remembering, then this is the result of a while, for
	   * or until loop with a loop redirection, or a function/builtin
	   * executing in the parent shell with a redirection.  In the
	   * function/builtin case, we want to set all file descriptors > 2
	   * to be close-on-exec to duplicate the effect of the old
	   * for i = 3 to NOFILE close(i) loop.  In the case of the loops,
	   * both sh and ksh leave the file descriptors open across execs.
	   * The Posix standard mentions only the exec builtin.
	   */
	  if ((flags & RX_CLEXEC) && (redirector > 2))
	    SET_CLOSE_ON_EXEC (redirector);
	}

      if (fd != redirector)
	{
#if defined (BUFFERED_INPUT)
	  if (INPUT_REDIRECT (ri))
	    close_buffered_fd (fd);
	  else
#endif /* !BUFFERED_INPUT */
	    close (fd);		/* Don't close what we just opened! */
	}

      /* If we are hacking both stdout and stderr, do the stderr
	 redirection here.  XXX - handle {var} here? */
      if (ri == r_err_and_out || ri == r_append_err_and_out)
	{
	  if (flags & RX_ACTIVE)
	    {
	      if (flags & RX_UNDOABLE)
		add_undo_redirect (2, ri, -1);
	      if (dup2 (1, 2) < 0)
		return (errno);
	    }
	}
      break;

    case r_reading_until:
    case r_deblank_reading_until:
    case r_reading_string:
      /* REDIRECTEE is a pointer to a WORD_DESC containing the text of
	 the new input.  Place it in a temporary file. */
      if (redirectee)
	{
	  fd = here_document_to_fd (redirectee, ri);

	  if (fd < 0)
	    {
	      heredoc_errno = errno;
	      return (HEREDOC_REDIRECT);
	    }

	  if (redirect->rflags & REDIR_VARASSIGN)
	    {
	      redirector = fcntl (fd, F_DUPFD, SHELL_FD_BASE);		/* XXX try this for now */
	      r = errno;
	      if (redirector < 0)
		sys_error (_("redirection error: cannot duplicate fd"));
	      REDIRECTION_ERROR (redirector, r, fd);
	    }

	  if (flags & RX_ACTIVE)
	    {
	      if (flags & RX_UNDOABLE)
	        {
		  /* Only setup to undo it if the thing to undo is active. */
		  if ((fd != redirector) && (fcntl (redirector, F_GETFD, 0) != -1))
		    r = add_undo_redirect (redirector, ri, -1);
		  else
		    r = add_undo_close_redirect (redirector);
		  if (r < 0 && (redirect->rflags & REDIR_VARASSIGN))
		    close (redirector);
		  REDIRECTION_ERROR (r, errno, fd);
	        }

#if defined (BUFFERED_INPUT)
	      check_bash_input (redirector);
#endif
	      if (redirect->rflags & REDIR_VARASSIGN)
		{
		  if ((r = redir_varassign (redirect, redirector)) < 0)
		    {
		      close (redirector);
		      close (fd);
		      return (r);	/* XXX */
		    }
		}
	      else if (fd != redirector && dup2 (fd, redirector) < 0)
		{
		  r = errno;
		  close (fd);
		  return (r);
		}

#if defined (BUFFERED_INPUT)
	      duplicate_buffered_stream (fd, redirector);
#endif

	      if ((flags & RX_CLEXEC) && (redirector > 2))
		SET_CLOSE_ON_EXEC (redirector);
	    }

	  if (fd != redirector)
#if defined (BUFFERED_INPUT)
	    close_buffered_fd (fd);
#else
	    close (fd);
#endif
	}
      break;

    case r_duplicating_input:
    case r_duplicating_output:
    case r_move_input:
    case r_move_output:
      if ((flags & RX_ACTIVE) && (redirect->rflags & REDIR_VARASSIGN))
        {
	  redirector = fcntl (redir_fd, F_DUPFD, SHELL_FD_BASE);		/* XXX try this for now */
	  r = errno;
	  if (redirector < 0)
	    sys_error (_("redirection error: cannot duplicate fd"));
	  REDIRECTION_ERROR (redirector, r, -1);
        }

      if ((flags & RX_ACTIVE) && (redir_fd != redirector))
	{
	  if (flags & RX_UNDOABLE)
	    {
	      /* Only setup to undo it if the thing to undo is active. */
	      if (fcntl (redirector, F_GETFD, 0) != -1)
		r = add_undo_redirect (redirector, ri, redir_fd);
	      else
		r = add_undo_close_redirect (redirector);
	      if (r < 0 && (redirect->rflags & REDIR_VARASSIGN))
		close (redirector);
	      REDIRECTION_ERROR (r, errno, -1);
	    }
#if defined (BUFFERED_INPUT)
	  check_bash_input (redirector);
#endif
	  if (redirect->rflags & REDIR_VARASSIGN)
	    {
	      if ((r = redir_varassign (redirect, redirector)) < 0)
		{
		  close (redirector);
		  return (r);	/* XXX */
		}
	    }
	  /* This is correct.  2>&1 means dup2 (1, 2); */
	  else if (dup2 (redir_fd, redirector) < 0)
	    return (errno);

#if defined (BUFFERED_INPUT)
	  if (ri == r_duplicating_input || ri == r_move_input)
	    duplicate_buffered_stream (redir_fd, redirector);
#endif /* BUFFERED_INPUT */

	  /* First duplicate the close-on-exec state of redirectee.  dup2
	     leaves the flag unset on the new descriptor, which means it
	     stays open.  Only set the close-on-exec bit for file descriptors
	     greater than 2 in any case, since 0-2 should always be open
	     unless closed by something like `exec 2<&-'.  It should always
	     be safe to set fds > 2 to close-on-exec if they're being used to
	     save file descriptors < 2, since we don't need to preserve the
	     state of the close-on-exec flag for those fds -- they should
	     always be open. */
	  /* if ((already_set || set_unconditionally) && (ok_to_set))
		set_it () */
#if 0
	  if (((fcntl (redir_fd, F_GETFD, 0) == 1) || redir_fd < 2 || (flags & RX_CLEXEC)) &&
	       (redirector > 2))
#else
	  if (((fcntl (redir_fd, F_GETFD, 0) == 1) || (redir_fd < 2 && (flags & RX_INTERNAL)) || (flags & RX_CLEXEC)) &&
	       (redirector > 2))
#endif
	    SET_CLOSE_ON_EXEC (redirector);

	  /* When undoing saving of non-standard file descriptors (>=3) using
	     file descriptors >= SHELL_FD_BASE, we set the saving fd to be
	     close-on-exec and use a flag to decide how to set close-on-exec
	     when the fd is restored. */
	  if ((redirect->flags & RX_INTERNAL) && (redirect->flags & RX_SAVCLEXEC) && redirector >= 3 && redir_fd >= SHELL_FD_BASE)
	    SET_OPEN_ON_EXEC (redirector);
	    
	  /* dup-and-close redirection */
	  if (ri == r_move_input || ri == r_move_output)
	    {
	      xtrace_fdchk (redir_fd);

	      close (redir_fd);
#if defined (COPROCESS_SUPPORT)
	      coproc_fdchk (redir_fd);	/* XXX - loses coproc fds */
#endif
	    }
	}
      break;

    case r_close_this:
      if (flags & RX_ACTIVE)
	{
	  if (redirect->rflags & REDIR_VARASSIGN)
	    {
	      redirector = redir_varvalue (redirect);
	      if (redirector < 0)
		return AMBIGUOUS_REDIRECT;
	    }

	  r = 0;
	  if ((flags & RX_UNDOABLE) && (fcntl (redirector, F_GETFD, 0) != -1))
	    {
	      r = add_undo_redirect (redirector, ri, -1);
	      REDIRECTION_ERROR (r, errno, redirector);
	    }

#if defined (COPROCESS_SUPPORT)
	  coproc_fdchk (redirector);
#endif
	  xtrace_fdchk (redirector);

#if defined (BUFFERED_INPUT)
	  check_bash_input (redirector);
	  close_buffered_fd (redirector);
#else /* !BUFFERED_INPUT */
	  close (redirector);
#endif /* !BUFFERED_INPUT */
	}
      break;

    case r_duplicating_input_word:
    case r_duplicating_output_word:
      break;
    }
  return (0);
}
warning: parse error {
  WORD_DESC *redirectee;
  int redir_fd, fd, redirector, r, oflags;
  intmax_t lfd;
  char *redirectee_word;
  enum r_instruction ri;
  REDIRECT *new_redirect;
  REDIRECTEE sd;

  redirectee = redirect->redirectee.filename;
  redir_fd = redirect->redirectee.dest;
  redirector = redirect->redirector.dest;
  ri = redirect->instruction;

  if (redirect->flags & RX_INTERNAL)
    flags |= RX_INTERNAL;

  if (TRANSLATE_REDIRECT (ri))
    {
      /* We have [N]>&WORD[-] or [N]<&WORD[-] (or {V}>&WORD[-] or {V}<&WORD-).
         and WORD, then translate the redirection into a new one and 
	 continue. */
      redirectee_word = redirection_expand (redirectee);

      /* XXX - what to do with [N]<&$w- where w is unset or null?  ksh93
	       closes N. */
      if (redirectee_word == 0)
	return (AMBIGUOUS_REDIRECT);
      else if (redirectee_word[0] == '-' && redirectee_word[1] == '\0')
	{
	  sd = redirect->redirector;
	  rd.dest = 0;
	  new_redirect = make_redirection (sd, r_close_this, rd, 0);
	}
      else if (all_digits (redirectee_word))
	{
	  sd = redirect->redirector;
	  if (legal_number (redirectee_word, &lfd) && (int)lfd == lfd)
	    rd.dest = lfd;
	  else
	    rd.dest = -1;	/* XXX */
	  switch (ri)
	    {
	    case r_duplicating_input_word:
	      new_redirect = make_redirection (sd, r_duplicating_input, rd, 0);
	      break;
	    case r_duplicating_output_word:
	      new_redirect = make_redirection (sd, r_duplicating_output, rd, 0);
	      break;
	    case r_move_input_word:
	      new_redirect = make_redirection (sd, r_move_input, rd, 0);
	      break;
	    case r_move_output_word:
	      new_redirect = make_redirection (sd, r_move_output, rd, 0);
	      break;
	    }
	}
      else if (ri == r_duplicating_output_word && (redirect->rflags & REDIR_VARASSIGN) == 0 && redirector == 1)
	{
	  sd = redirect->redirector;
	  rd.filename = make_bare_word (redirectee_word);
	  new_redirect = make_redirection (sd, r_err_and_out, rd, 0);
	}
      else
	{
	  free (redirectee_word);
	  return (AMBIGUOUS_REDIRECT);
	}

      free (redirectee_word);

      /* Set up the variables needed by the rest of the function from the
	 new redirection. */
      if (new_redirect->instruction == r_err_and_out)
	{
	  char *alloca_hack;

	  /* Copy the word without allocating any memory that must be
	     explicitly freed. */
	  redirectee = (WORD_DESC *)alloca (sizeof (WORD_DESC));
	  xbcopy ((char *)new_redirect->redirectee.filename,
		 (char *)redirectee, sizeof (WORD_DESC));

	  alloca_hack = (char *)
	    alloca (1 + strlen (new_redirect->redirectee.filename->word));
	  redirectee->word = alloca_hack;
	  strcpy (redirectee->word, new_redirect->redirectee.filename->word);
	}
      else
	/* It's guaranteed to be an integer, and shouldn't be freed. */
	redirectee = new_redirect->redirectee.filename;

      redir_fd = new_redirect->redirectee.dest;
      redirector = new_redirect->redirector.dest;
      ri = new_redirect->instruction;

      /* Overwrite the flags element of the old redirect with the new value. */
      redirect->flags = new_redirect->flags;
      dispose_redirects (new_redirect);
    }

  switch (ri)
    {
    case r_output_direction:
    case r_appending_to:
    case r_input_direction:
    case r_inputa_direction:
    case r_err_and_out:		/* command &>filename */
    case r_append_err_and_out:	/* command &>> filename */
    case r_input_output:
    case r_output_force:
      if (posixly_correct && interactive_shell == 0)
	{
	  oflags = redirectee->flags;
	  redirectee->flags |= W_NOGLOB;
	}
      redirectee_word = redirection_expand (redirectee);
      if (posixly_correct && interactive_shell == 0)
	redirectee->flags = oflags;

      if (redirectee_word == 0)
	return (AMBIGUOUS_REDIRECT);

#if defined (RESTRICTED_SHELL)
      if (restricted && (WRITE_REDIRECT (ri)))
	{
	  free (redirectee_word);
	  return (RESTRICTED_REDIRECT);
	}
#endif /* RESTRICTED_SHELL */

      fd = redir_open (redirectee_word, redirect->flags, 0666, ri);
      free (redirectee_word);

      if (fd == NOCLOBBER_REDIRECT)
	return (fd);

      if (fd < 0)
	return (errno);

      if (flags & RX_ACTIVE)
	{
	  if (redirect->rflags & REDIR_VARASSIGN)
	    {
	      redirector = fcntl (fd, F_DUPFD, SHELL_FD_BASE);		/* XXX try this for now */
	      r = errno;
	      if (redirector < 0)
		sys_error (_("redirection error: cannot duplicate fd"));
	      REDIRECTION_ERROR (redirector, r, fd);
	    }

	  if (flags & RX_UNDOABLE)
	    {
	      /* Only setup to undo it if the thing to undo is active. */
	      if ((fd != redirector) && (fcntl (redirector, F_GETFD, 0) != -1))
		r = add_undo_redirect (redirector, ri, -1);
	      else
		r = add_undo_close_redirect (redirector);
	      if (r < 0 && (redirect->rflags & REDIR_VARASSIGN))
		close (redirector);
	      REDIRECTION_ERROR (r, errno, fd);
	    }

#if defined (BUFFERED_INPUT)
	  check_bash_input (redirector);
#endif

	  /* Make sure there is no pending output before we change the state
	     of the underlying file descriptor, since the builtins use stdio
	     for output. */
	  if (redirector == 1 && fileno (stdout) == redirector)
	    {
	      fflush (stdout);
	      fpurge (stdout);
	    }
	  else if (redirector == 2 && fileno (stderr) == redirector)
	    {
	      fflush (stderr);
	      fpurge (stderr);
	    }

	  if (redirect->rflags & REDIR_VARASSIGN)
	    {
	      if ((r = redir_varassign (redirect, redirector)) < 0)
		{
		  close (redirector);
		  close (fd);
		  return (r);	/* XXX */
		}
	    }
	  else if ((fd != redirector) && (dup2 (fd, redirector) < 0))
	    return (errno);

#if defined (BUFFERED_INPUT)
	  /* Do not change the buffered stream for an implicit redirection
	     of /dev/null to fd 0 for asynchronous commands without job
	     control (r_inputa_direction). */
	  if (ri == r_input_direction || ri == r_input_output)
	    duplicate_buffered_stream (fd, redirector);
#endif /* BUFFERED_INPUT */

	  /*
	   * If we're remembering, then this is the result of a while, for
	   * or until loop with a loop redirection, or a function/builtin
	   * executing in the parent shell with a redirection.  In the
	   * function/builtin case, we want to set all file descriptors > 2
	   * to be close-on-exec to duplicate the effect of the old
	   * for i = 3 to NOFILE close(i) loop.  In the case of the loops,
	   * both sh and ksh leave the file descriptors open across execs.
	   * The Posix standard mentions only the exec builtin.
	   */
	  if ((flags & RX_CLEXEC) && (redirector > 2))
	    SET_CLOSE_ON_EXEC (redirector);
	}

      if (fd != redirector)
	{
#if defined (BUFFERED_INPUT)
	  if (INPUT_REDIRECT (ri))
	    close_buffered_fd (fd);
	  else
#endif /* !BUFFERED_INPUT */
	    close (fd);		/* Don't close what we just opened! */
	}

      /* If we are hacking both stdout and stderr, do the stderr
	 redirection here.  XXX - handle {var} here? */
      if (ri == r_err_and_out || ri == r_append_err_and_out)
	{
	  if (flags & RX_ACTIVE)
	    {
	      if (flags & RX_UNDOABLE)
		add_undo_redirect (2, ri, -1);
	      if (dup2 (1, 2) < 0)
		return (errno);
	    }
	}
      break;

    case r_reading_until:
    case r_deblank_reading_until:
    case r_reading_string:
      /* REDIRECTEE is a pointer to a WORD_DESC containing the text of
	 the new input.  Place it in a temporary file. */
      if (redirectee)
	{
	  fd = here_document_to_fd (redirectee, ri);

	  if (fd < 0)
	    {
	      heredoc_errno = errno;
	      return (HEREDOC_REDIRECT);
	    }

	  if (redirect->rflags & REDIR_VARASSIGN)
	    {
	      redirector = fcntl (fd, F_DUPFD, SHELL_FD_BASE);		/* XXX try this for now */
	      r = errno;
	      if (redirector < 0)
		sys_error (_("redirection error: cannot duplicate fd"));
	      REDIRECTION_ERROR (redirector, r, fd);
	    }

	  if (flags & RX_ACTIVE)
	    {
	      if (flags & RX_UNDOABLE)
	        {
		  /* Only setup to undo it if the thing to undo is active. */
		  if ((fd != redirector) && (fcntl (redirector, F_GETFD, 0) != -1))
		    r = add_undo_redirect (redirector, ri, -1);
		  else
		    r = add_undo_close_redirect (redirector);
		  if (r < 0 && (redirect->rflags & REDIR_VARASSIGN))
		    close (redirector);
		  REDIRECTION_ERROR (r, errno, fd);
	        }

#if defined (BUFFERED_INPUT)
	      check_bash_input (redirector);
#endif
	      if (redirect->rflags & REDIR_VARASSIGN)
		{
		  if ((r = redir_varassign (redirect, redirector)) < 0)
		    {
		      close (redirector);
		      close (fd);
		      return (r);	/* XXX */
		    }
		}
	      else if (fd != redirector && dup2 (fd, redirector) < 0)
		{
		  r = errno;
		  close (fd);
		  return (r);
		}

#if defined (BUFFERED_INPUT)
	      duplicate_buffered_stream (fd, redirector);
#endif

	      if ((flags & RX_CLEXEC) && (redirector > 2))
		SET_CLOSE_ON_EXEC (redirector);
	    }

	  if (fd != redirector)
#if defined (BUFFERED_INPUT)
	    close_buffered_fd (fd);
#else
	    close (fd);
#endif
	}
      break;

    case r_duplicating_input:
    case r_duplicating_output:
    case r_move_input:
    case r_move_output:
      if ((flags & RX_ACTIVE) && (redirect->rflags & REDIR_VARASSIGN))
        {
	  redirector = fcntl (redir_fd, F_DUPFD, SHELL_FD_BASE);		/* XXX try this for now */
	  r = errno;
	  if (redirector < 0)
	    sys_error (_("redirection error: cannot duplicate fd"));
	  REDIRECTION_ERROR (redirector, r, -1);
        }

      if ((flags & RX_ACTIVE) && (redir_fd != redirector))
	{
	  if (flags & RX_UNDOABLE)
	    {
	      /* Only setup to undo it if the thing to undo is active. */
	      if (fcntl (redirector, F_GETFD, 0) != -1)
		r = add_undo_redirect (redirector, ri, redir_fd);
	      else
		r = add_undo_close_redirect (redirector);
	      if (r < 0 && (redirect->rflags & REDIR_VARASSIGN))
		close (redirector);
	      REDIRECTION_ERROR (r, errno, -1);
	    }
#if defined (BUFFERED_INPUT)
	  check_bash_input (redirector);
#endif
	  if (redirect->rflags & REDIR_VARASSIGN)
	    {
	      if ((r = redir_varassign (redirect, redirector)) < 0)
		{
		  close (redirector);
		  return (r);	/* XXX */
		}
	    }
	  /* This is correct.  2>&1 means dup2 (1, 2); */
	  else if (dup2 (redir_fd, redirector) < 0)
	    return (errno);

#if defined (BUFFERED_INPUT)
	  if (ri == r_duplicating_input || ri == r_move_input)
	    duplicate_buffered_stream (redir_fd, redirector);
#endif /* BUFFERED_INPUT */

	  /* First duplicate the close-on-exec state of redirectee.  dup2
	     leaves the flag unset on the new descriptor, which means it
	     stays open.  Only set the close-on-exec bit for file descriptors
	     greater than 2 in any case, since 0-2 should always be open
	     unless closed by something like `exec 2<&-'.  It should always
	     be safe to set fds > 2 to close-on-exec if they're being used to
	     save file descriptors < 2, since we don't need to preserve the
	     state of the close-on-exec flag for those fds -- they should
	     always be open. */
	  /* if ((already_set || set_unconditionally) && (ok_to_set))
		set_it () */
#if 0
	  if (((fcntl (redir_fd, F_GETFD, 0) == 1) || redir_fd < 2 || (flags & RX_CLEXEC)) &&
	       (redirector > 2))
#else
	  if (((fcntl (redir_fd, F_GETFD, 0) == 1) || (redir_fd < 2 && (flags & RX_INTERNAL)) || (flags & RX_CLEXEC)) &&
	       (redirector > 2))
#endif
	    SET_CLOSE_ON_EXEC (redirector);

	  /* When undoing saving of non-standard file descriptors (>=3) using
	     file descriptors >= SHELL_FD_BASE, we set the saving fd to be
	     close-on-exec and use a flag to decide how to set close-on-exec
	     when the fd is restored. */
	  if ((redirect->flags & RX_INTERNAL) && (redirect->flags & RX_SAVCLEXEC) && redirector >= 3 && redir_fd >= SHELL_FD_BASE)
	    SET_OPEN_ON_EXEC (redirector);
	    
	  /* dup-and-close redirection */
	  if (ri == r_move_input || ri == r_move_output)
	    {
	      xtrace_fdchk (redir_fd);

	      close (redir_fd);
#if defined (COPROCESS_SUPPORT)
	      coproc_fdchk (redir_fd);	/* XXX - loses coproc fds */
#endif
	    }
	}
      break;

    case r_close_this:
      if (flags & RX_ACTIVE)
	{
	  if (redirect->rflags & REDIR_VARASSIGN)
	    {
	      redirector = redir_varvalue (redirect);
	      if (redirector < 0)
		return AMBIGUOUS_REDIRECT;
	    }

	  r = 0;
	  if ((flags & RX_UNDOABLE) && (fcntl (redirector, F_GETFD, 0) != -1))
	    {
	      r = add_undo_redirect (redirector, ri, -1);
	      REDIRECTION_ERROR (r, errno, redirector);
	    }

#if defined (COPROCESS_SUPPORT)
	  coproc_fdchk (redirector);
#endif
	  xtrace_fdchk (redirector);

#if defined (BUFFERED_INPUT)
	  check_bash_input (redirector);
	  close_buffered_fd (redirector);
#else /* !BUFFERED_INPUT */
	  close (redirector);
#endif /* !BUFFERED_INPUT */
	}
      break;

    case r_duplicating_input_word:
    case r_duplicating_output_word:
      break;
    }
  return (0);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\redir.c:671
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\redir.c:1,121
parsing error 
{
  int new_fd, clexec_flag;
  REDIRECT *new_redirect, *closer, *dummy_redirect;
  REDIRECTEE sd;

  new_fd = fcntl (fd, F_DUPFD, (fdbase < SHELL_FD_BASE) ? SHELL_FD_BASE : fdbase+1);
  if (new_fd < 0)
    new_fd = fcntl (fd, F_DUPFD, SHELL_FD_BASE);

  if (new_fd < 0)
    {
      sys_error (_("redirection error: cannot duplicate fd"));
      return (-1);
    }

  clexec_flag = fcntl (fd, F_GETFD, 0);

  sd.dest = new_fd;
  rd.dest = 0;
  closer = make_redirection (sd, r_close_this, rd, 0);
  closer->flags |= RX_INTERNAL;
  dummy_redirect = copy_redirects (closer);

  sd.dest = fd;
  rd.dest = new_fd;
  if (fd == 0)
    new_redirect = make_redirection (sd, r_duplicating_input, rd, 0);
  else
    new_redirect = make_redirection (sd, r_duplicating_output, rd, 0);
  new_redirect->flags |= RX_INTERNAL;
  if (clexec_flag == 0 && fd >= 3 && new_fd >= SHELL_FD_BASE)
    new_redirect->flags |= RX_SAVCLEXEC;
  new_redirect->next = closer;

  closer->next = redirection_undo_list;
  redirection_undo_list = new_redirect;

  /* Save redirections that need to be undone even if the undo list
     is thrown away by the `exec' builtin. */
  add_exec_redirect (dummy_redirect);

  /* experimental:  if we're saving a redirection to undo for a file descriptor
     above SHELL_FD_BASE, add a redirection to be undone if the exec builtin
     causes redirections to be discarded.  There needs to be a difference
     between fds that are used to save other fds and then are the target of
     user redirections and fds that are just the target of user redirections.
     We use the close-on-exec flag to tell the difference; fds > SHELL_FD_BASE
     that have the close-on-exec flag set are assumed to be fds used internally
     to save others. */
  if (fd >= SHELL_FD_BASE && ri != r_close_this && clexec_flag)
    {
      sd.dest = fd;
      rd.dest = new_fd;
      new_redirect = make_redirection (sd, r_duplicating_output, rd, 0);
      new_redirect->flags |= RX_INTERNAL;

      add_exec_redirect (new_redirect);
    }

  /* File descriptors used only for saving others should always be
     marked close-on-exec.  Unfortunately, we have to preserve the
     close-on-exec state of the file descriptor we are saving, since
     fcntl (F_DUPFD) sets the new file descriptor to remain open
     across execs.  If, however, the file descriptor whose state we
     are saving is <= 2, we can just set the close-on-exec flag,
     because file descriptors 0-2 should always be open-on-exec,
     and the restore above in do_redirection() will take care of it. */
  if (clexec_flag || fd < 3)
    SET_CLOSE_ON_EXEC (new_fd);
  else if (redirection_undo_list->flags & RX_SAVCLEXEC)
    SET_CLOSE_ON_EXEC (new_fd);

  return (0);
}
warning: parse error {
  int new_fd, clexec_flag;
  REDIRECT *new_redirect, *closer, *dummy_redirect;
  REDIRECTEE sd;

  new_fd = fcntl (fd, F_DUPFD, (fdbase < SHELL_FD_BASE) ? SHELL_FD_BASE : fdbase+1);
  if (new_fd < 0)
    new_fd = fcntl (fd, F_DUPFD, SHELL_FD_BASE);

  if (new_fd < 0)
    {
      sys_error (_("redirection error: cannot duplicate fd"));
      return (-1);
    }

  clexec_flag = fcntl (fd, F_GETFD, 0);

  sd.dest = new_fd;
  rd.dest = 0;
  closer = make_redirection (sd, r_close_this, rd, 0);
  closer->flags |= RX_INTERNAL;
  dummy_redirect = copy_redirects (closer);

  sd.dest = fd;
  rd.dest = new_fd;
  if (fd == 0)
    new_redirect = make_redirection (sd, r_duplicating_input, rd, 0);
  else
    new_redirect = make_redirection (sd, r_duplicating_output, rd, 0);
  new_redirect->flags |= RX_INTERNAL;
  if (clexec_flag == 0 && fd >= 3 && new_fd >= SHELL_FD_BASE)
    new_redirect->flags |= RX_SAVCLEXEC;
  new_redirect->next = closer;

  closer->next = redirection_undo_list;
  redirection_undo_list = new_redirect;

  /* Save redirections that need to be undone even if the undo list
     is thrown away by the `exec' builtin. */
  add_exec_redirect (dummy_redirect);

  /* experimental:  if we're saving a redirection to undo for a file descriptor
     above SHELL_FD_BASE, add a redirection to be undone if the exec builtin
     causes redirections to be discarded.  There needs to be a difference
     between fds that are used to save other fds and then are the target of
     user redirections and fds that are just the target of user redirections.
     We use the close-on-exec flag to tell the difference; fds > SHELL_FD_BASE
     that have the close-on-exec flag set are assumed to be fds used internally
     to save others. */
  if (fd >= SHELL_FD_BASE && ri != r_close_this && clexec_flag)
    {
      sd.dest = fd;
      rd.dest = new_fd;
      new_redirect = make_redirection (sd, r_duplicating_output, rd, 0);
      new_redirect->flags |= RX_INTERNAL;

      add_exec_redirect (new_redirect);
    }

  /* File descriptors used only for saving others should always be
     marked close-on-exec.  Unfortunately, we have to preserve the
     close-on-exec state of the file descriptor we are saving, since
     fcntl (F_DUPFD) sets the new file descriptor to remain open
     across execs.  If, however, the file descriptor whose state we
     are saving is <= 2, we can just set the close-on-exec flag,
     because file descriptors 0-2 should always be open-on-exec,
     and the restore above in do_redirection() will take care of it. */
  if (clexec_flag || fd < 3)
    SET_CLOSE_ON_EXEC (new_fd);
  else if (redirection_undo_list->flags & RX_SAVCLEXEC)
    SET_CLOSE_ON_EXEC (new_fd);

  return (0);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\redir.c:1,125
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\redir.c:1,203
parsing error 
{
  REDIRECT *closer;
  REDIRECTEE sd;

  sd.dest = fd;
  rd.dest = 0;
  closer = make_redirection (sd, r_close_this, rd, 0);
  closer->flags |= RX_INTERNAL;
  closer->next = redirection_undo_list;
  redirection_undo_list = closer;

  return 0;
}
warning: parse error {
  REDIRECT *closer;
  REDIRECTEE sd;

  sd.dest = fd;
  rd.dest = 0;
  closer = make_redirection (sd, r_close_this, rd, 0);
  closer->flags |= RX_INTERNAL;
  closer->next = redirection_undo_list;
  redirection_undo_list = closer;

  return 0;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\redir.c:1,205
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\redir.c:1,220
parsing error 
{
  dummy_redirect->next = exec_redirection_undo_list;
  exec_redirection_undo_list = dummy_redirect;
}
warning: parse error {
  dummy_redirect->next = exec_redirection_undo_list;
  exec_redirection_undo_list = dummy_redirect;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\redir.c:1,222
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\redir.c:1,230
parsing error 
{
  switch (ri)
    {
    case r_input_direction:
    case r_inputa_direction:
    case r_input_output:
    case r_reading_until:
    case r_deblank_reading_until:
    case r_reading_string:
      return (1);
    case r_duplicating_input:
    case r_duplicating_input_word:
    case r_close_this:
      return (redirector == 0);
    case r_output_direction:
    case r_appending_to:
    case r_duplicating_output:
    case r_err_and_out:
    case r_append_err_and_out:
    case r_output_force:
    case r_duplicating_output_word:
      return (0);
    }
  return (0);
}
warning: parse error {
  switch (ri)
    {
    case r_input_direction:
    case r_inputa_direction:
    case r_input_output:
    case r_reading_until:
    case r_deblank_reading_until:
    case r_reading_string:
      return (1);
    case r_duplicating_input:
    case r_duplicating_input_word:
    case r_close_this:
      return (redirector == 0);
    case r_output_direction:
    case r_appending_to:
    case r_duplicating_output:
    case r_err_and_out:
    case r_append_err_and_out:
    case r_output_force:
    case r_duplicating_output_word:
      return (0);
    }
  return (0);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\redir.c:1,233
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\redir.c:1,262
parsing error 
{
  REDIRECT *rp;
  int n;

  for (n = 0, rp = redirs; rp; rp = rp->next)
    if ((rp->rflags & REDIR_VARASSIGN) == 0)
      n += stdin_redirection (rp->instruction, rp->redirector.dest);
  return n;
}
warning: parse error {
  REDIRECT *rp;
  int n;

  for (n = 0, rp = redirs; rp; rp = rp->next)
    if ((rp->rflags & REDIR_VARASSIGN) == 0)
      n += stdin_redirection (rp->instruction, rp->redirector.dest);
  return n;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\redir.c:1,264
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\redir.c:1,276
parsing error 
{
  WORD_DESC *w;
  SHELL_VAR *v;

  w = redir->redirector.filename;
  v = bind_var_to_int (w->word, fd);
  if (v == 0 || readonly_p (v) || noassign_p (v))
    return BADVAR_REDIRECT;

  return 0;
}
warning: parse error {
  WORD_DESC *w;
  SHELL_VAR *v;

  w = redir->redirector.filename;
  v = bind_var_to_int (w->word, fd);
  if (v == 0 || readonly_p (v) || noassign_p (v))
    return BADVAR_REDIRECT;

  return 0;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\redir.c:1,279
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\redir.c:1,292
parsing error 
{
  SHELL_VAR *v;
  char *val;
  intmax_t vmax;
  int i;

  /* XXX - handle set -u here? */
  v = find_variable (redir->redirector.filename->word);
  if (v == 0 || invisible_p (v))
    return -1;

  val = get_variable_value (v);
  if (val == 0 || *val == 0)
    return -1;

  if (legal_number (val, &vmax) < 0)
    return -1;

  i = vmax;	/* integer truncation */
  return i;
}
warning: parse error {
  SHELL_VAR *v;
  char *val;
  intmax_t vmax;
  int i;

  /* XXX - handle set -u here? */
  v = find_variable (redir->redirector.filename->word);
  if (v == 0 || invisible_p (v))
    return -1;

  val = get_variable_value (v);
  if (val == 0 || *val == 0)
    return -1;

  if (legal_number (val, &vmax) < 0)
    return -1;

  i = vmax;	/* integer truncation */
  return i;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\redir.c:1,294
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\shell.c...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\bashtypes.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\posixstat.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\posixtime.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\bashansi.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\filecntl.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\bashintl.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\shell.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\flags.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\trap.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\mailcheck.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\common.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\jobs.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\input.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\execute_cmd.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\findcmd.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\tilde\tilde.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\glob\strmatch.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\shell.c:350
parsing error 
{
  register int i;
  int code, old_errexit_flag;
#if defined (RESTRICTED_SHELL)
  int saverst;
#endif
  volatile int locally_skip_execution;
  volatile int arg_index, top_level_arg_index;
#ifdef __OPENNT
  char **env;

  env = environ;
#endif /* __OPENNT */

  USE_VAR(argc);
  USE_VAR(argv);
  USE_VAR(env);
  USE_VAR(code);
  USE_VAR(old_errexit_flag);
#if defined (RESTRICTED_SHELL)
  USE_VAR(saverst);
#endif

  /* Catch early SIGINTs. */
  code = setjmp (top_level);
  if (code)
    exit (2);

  xtrace_init ();

#if defined (USING_BASH_MALLOC) && defined (DEBUG) && !defined (DISABLE_MALLOC_WRAPPERS)
#  if 1
  malloc_set_register (1);
#  endif
#endif

  check_dev_tty ();

#ifdef __CYGWIN__
  _cygwin32_check_tmp ();
#endif /* __CYGWIN__ */

  /* Wait forever if we are debugging a login shell. */
  while (debugging_login_shell) sleep (3);

  set_default_locale ();

  running_setuid = uidget ();

  if (getenv ("POSIXLY_CORRECT") || getenv ("POSIX_PEDANTIC"))
    posixly_correct = 1;

#if defined (USE_GNU_MALLOC_LIBRARY)
  mcheck (programming_error, (void (*) ())0);
#endif /* USE_GNU_MALLOC_LIBRARY */

  if (setjmp (subshell_top_level))
    {
      argc = subshell_argc;
      argv = subshell_argv;
      env = subshell_envp;
      sourced_env = 0;
    }

  shell_reinitialized = 0;

  /* Initialize `local' variables for all `invocations' of main (). */
  arg_index = 1;
  if (arg_index > argc)
    arg_index = argc;
  command_execution_string = (char *)NULL;
  want_pending_command = locally_skip_execution = read_from_stdin = 0;
  default_input = stdin;
#if defined (BUFFERED_INPUT)
  default_buffered_input = -1;
#endif

  /* Fix for the `infinite process creation' bug when running shell scripts
     from startup files on System V. */
  login_shell = make_login_shell = 0;

  /* If this shell has already been run, then reinitialize it to a
     vanilla state. */
  if (shell_initialized || shell_name)
    {
      /* Make sure that we do not infinitely recurse as a login shell. */
      if (*shell_name == '-')
	shell_name++;

      shell_reinitialize ();
      if (setjmp (top_level))
	exit (2);
    }

  shell_environment = env;
  set_shell_name (argv[0]);
  shell_start_time = NOW;	/* NOW now defined in general.h */

  /* Parse argument flags from the input line. */

  /* Find full word arguments first. */
  arg_index = parse_long_options (argv, arg_index, argc);

  if (want_initial_help)
    {
      show_shell_usage (stdout, 1);
      exit (EXECUTION_SUCCESS);
    }

  if (do_version)
    {
      show_shell_version (1);
      exit (EXECUTION_SUCCESS);
    }

  /* All done with full word options; do standard shell option parsing.*/
  this_command_name = shell_name;	/* for error reporting */
  arg_index = parse_shell_options (argv, arg_index, argc);

  /* If user supplied the "--login" (or -l) flag, then set and invert
     LOGIN_SHELL. */
  if (make_login_shell)
    {
      login_shell++;
      login_shell = -login_shell;
    }

  set_login_shell ("login_shell", login_shell != 0);

  if (dump_po_strings)
    dump_translatable_strings = 1;

  if (dump_translatable_strings)
    read_but_dont_execute = 1;

  if (running_setuid && privileged_mode == 0)
    disable_priv_mode ();

  /* Need to get the argument to a -c option processed in the
     above loop.  The next arg is a command to execute, and the
     following args are $0...$n respectively. */
  if (want_pending_command)
    {
      command_execution_string = argv[arg_index];
      if (command_execution_string == 0)
	{
	  report_error (_("%s: option requires an argument"), "-c");
	  exit (EX_BADUSAGE);
	}
      arg_index++;
    }
  this_command_name = (char *)NULL;

  cmd_init();		/* initialize the command object caches */

  /* First, let the outside world know about our interactive status.
     A shell is interactive if the `-i' flag was given, or if all of
     the following conditions are met:
	no -c command
	no arguments remaining or the -s flag given
	standard input is a terminal
	standard error is a terminal
     Refer to Posix.2, the description of the `sh' utility. */

  if (forced_interactive ||		/* -i flag */
      (!command_execution_string &&	/* No -c command and ... */
       wordexp_only == 0 &&		/* No --wordexp and ... */
       ((arg_index == argc) ||		/*   no remaining args or... */
	read_from_stdin) &&		/*   -s flag with args, and */
       isatty (fileno (stdin)) &&	/* Input is a terminal and */
       isatty (fileno (stderr))))	/* error output is a terminal. */
    init_interactive ();
  else
    init_noninteractive ();

  /*
   * Some systems have the bad habit of starting login shells with lots of open
   * file descriptors.  For instance, most systems that have picked up the
   * pre-4.0 Sun YP code leave a file descriptor open each time you call one
   * of the getpw* functions, and it's set to be open across execs.  That
   * means one for login, one for xterm, one for shelltool, etc.  There are
   * also systems that open persistent FDs to other agents or files as part
   * of process startup; these need to be set to be close-on-exec.
   */
  if (login_shell && interactive_shell)
    {
      for (i = 3; i < 20; i++)
	SET_CLOSE_ON_EXEC (i);
    }

  /* If we're in a strict Posix.2 mode, turn on interactive comments,
     alias expansion in non-interactive shells, and other Posix.2 things. */
  if (posixly_correct)
    {
      bind_variable ("POSIXLY_CORRECT", "y", 0);
      sv_strict_posix ("POSIXLY_CORRECT");
    }

  /* Now we run the shopt_alist and process the options. */
  if (shopt_alist)
    run_shopt_alist ();

  /* From here on in, the shell must be a normal functioning shell.
     Variables from the environment are expected to be set, etc. */
  shell_initialize ();

  set_default_lang ();
  set_default_locale_vars ();

  /*
   * M-x term -> TERM=eterm EMACS=22.1 (term:0.96)	(eterm)
   * M-x shell -> TERM=dumb EMACS=t			(no line editing)
   * M-x terminal -> TERM=emacs-em7955 EMACS=		(line editing)
   */
  if (interactive_shell)
    {
      char *term, *emacs;

      term = get_string_value ("TERM");
      emacs = get_string_value ("EMACS");

      /* Not sure any emacs terminal emulator sets TERM=emacs any more */
      no_line_editing |= term && (STREQ (term, "emacs"));
      no_line_editing |= emacs && emacs[0] == 't' && emacs[1] == '\0' && STREQ (term, "dumb");

      /* running_under_emacs == 2 for `eterm' */
      running_under_emacs = (emacs != 0) || (term && STREQN (term, "emacs", 5));
      running_under_emacs += term && STREQN (term, "eterm", 5) && emacs && strstr (emacs, "term");

      if (running_under_emacs)
	gnu_error_format = 1;
    }

  top_level_arg_index = arg_index;
  old_errexit_flag = exit_immediately_on_error;

  /* Give this shell a place to longjmp to before executing the
     startup files.  This allows users to press C-c to abort the
     lengthy startup. */
  code = setjmp (top_level);
  if (code)
    {
      if (code == EXITPROG || code == ERREXIT)
	exit_shell (last_command_exit_value);
      else
	{
#if defined (JOB_CONTROL)
	  /* Reset job control, since run_startup_files turned it off. */
	  set_job_control (interactive_shell);
#endif
	  /* Reset value of `set -e', since it's turned off before running
	     the startup files. */
	  exit_immediately_on_error += old_errexit_flag;
	  locally_skip_execution++;
	}
    }

  arg_index = top_level_arg_index;

  /* Execute the start-up scripts. */

  if (interactive_shell == 0)
    {
      unbind_variable ("PS1");
      unbind_variable ("PS2");
      interactive = 0;
#if 0
      /* This has already been done by init_noninteractive */
      expand_aliases = posixly_correct;
#endif
    }
  else
    {
      change_flag ('i', FLAG_ON);
      interactive = 1;
    }

#if defined (RESTRICTED_SHELL)
  /* Set restricted_shell based on whether the basename of $0 indicates that
     the shell should be restricted or if the `-r' option was supplied at
     startup. */
  restricted_shell = shell_is_restricted (shell_name);

  /* If the `-r' option is supplied at invocation, make sure that the shell
     is not in restricted mode when running the startup files. */
  saverst = restricted;
  restricted = 0;
#endif

  /* The startup files are run with `set -e' temporarily disabled. */
  if (locally_skip_execution == 0 && running_setuid == 0)
    {
      old_errexit_flag = exit_immediately_on_error;
      exit_immediately_on_error = 0;

      run_startup_files ();
      exit_immediately_on_error += old_errexit_flag;
    }

  /* If we are invoked as `sh', turn on Posix mode. */
  if (act_like_sh)
    {
      bind_variable ("POSIXLY_CORRECT", "y", 0);
      sv_strict_posix ("POSIXLY_CORRECT");
    }

#if defined (RESTRICTED_SHELL)
  /* Turn on the restrictions after executing the startup files.  This
     means that `bash -r' or `set -r' invoked from a startup file will
     turn on the restrictions after the startup files are executed. */
  restricted = saverst || restricted;
  if (shell_reinitialized == 0)
    maybe_make_restricted (shell_name);
#endif /* RESTRICTED_SHELL */

#if defined (WORDEXP_OPTION)
  if (wordexp_only)
    {
      startup_state = 3;
      last_command_exit_value = run_wordexp (argv[arg_index]);
      exit_shell (last_command_exit_value);
    }
#endif

  if (command_execution_string)
    {
      arg_index = bind_args (argv, arg_index, argc, 0);
      startup_state = 2;

      if (debugging_mode)
	start_debugger ();

#if defined (ONESHOT)
      executing = 1;
      run_one_command (command_execution_string);
      exit_shell (last_command_exit_value);
#else /* ONESHOT */
      with_input_from_string (command_execution_string, "-c");
      goto read_and_execute;
#endif /* !ONESHOT */
    }

  /* Get possible input filename and set up default_buffered_input or
     default_input as appropriate. */
  if (arg_index != argc && read_from_stdin == 0)
    {
      open_shell_script (argv[arg_index]);
      arg_index++;
    }
  else if (interactive == 0)
    /* In this mode, bash is reading a script from stdin, which is a
       pipe or redirected file. */
#if defined (BUFFERED_INPUT)
    default_buffered_input = fileno (stdin);	/* == 0 */
#else
    setbuf (default_input, (char *)NULL);
#endif /* !BUFFERED_INPUT */

  set_bash_input ();

  /* Bind remaining args to $1 ... $n */
  arg_index = bind_args (argv, arg_index, argc, 1);

  if (debugging_mode && locally_skip_execution == 0 && running_setuid == 0)
    start_debugger ();

  /* Do the things that should be done only for interactive shells. */
  if (interactive_shell)
    {
      /* Set up for checking for presence of mail. */
      reset_mail_timer ();
      init_mail_dates ();

#if defined (HISTORY)
      /* Initialize the interactive history stuff. */
      bash_initialize_history ();
      /* Don't load the history from the history file if we've already
	 saved some lines in this session (e.g., by putting `history -s xx'
	 into one of the startup files). */
      if (shell_initialized == 0 && history_lines_this_session == 0)
	load_history ();
#endif /* HISTORY */

      /* Initialize terminal state for interactive shells after the
	 .bash_profile and .bashrc are interpreted. */
      get_tty_state ();
    }

#if !defined (ONESHOT)
 read_and_execute:
#endif /* !ONESHOT */

  shell_initialized = 1;

  /* Read commands until exit condition. */
  reader_loop ();
  exit_shell (last_command_exit_value);
}
warning: parse error {
  register int i;
  int code, old_errexit_flag;
#if defined (RESTRICTED_SHELL)
  int saverst;
#endif
  volatile int locally_skip_execution;
  volatile int arg_index, top_level_arg_index;
#ifdef __OPENNT
  char **env;

  env = environ;
#endif /* __OPENNT */

  USE_VAR(argc);
  USE_VAR(argv);
  USE_VAR(env);
  USE_VAR(code);
  USE_VAR(old_errexit_flag);
#if defined (RESTRICTED_SHELL)
  USE_VAR(saverst);
#endif

  /* Catch early SIGINTs. */
  code = setjmp (top_level);
  if (code)
    exit (2);

  xtrace_init ();

#if defined (USING_BASH_MALLOC) && defined (DEBUG) && !defined (DISABLE_MALLOC_WRAPPERS)
#  if 1
  malloc_set_register (1);
#  endif
#endif

  check_dev_tty ();

#ifdef __CYGWIN__
  _cygwin32_check_tmp ();
#endif /* __CYGWIN__ */

  /* Wait forever if we are debugging a login shell. */
  while (debugging_login_shell) sleep (3);

  set_default_locale ();

  running_setuid = uidget ();

  if (getenv ("POSIXLY_CORRECT") || getenv ("POSIX_PEDANTIC"))
    posixly_correct = 1;

#if defined (USE_GNU_MALLOC_LIBRARY)
  mcheck (programming_error, (void (*) ())0);
#endif /* USE_GNU_MALLOC_LIBRARY */

  if (setjmp (subshell_top_level))
    {
      argc = subshell_argc;
      argv = subshell_argv;
      env = subshell_envp;
      sourced_env = 0;
    }

  shell_reinitialized = 0;

  /* Initialize `local' variables for all `invocations' of main (). */
  arg_index = 1;
  if (arg_index > argc)
    arg_index = argc;
  command_execution_string = (char *)NULL;
  want_pending_command = locally_skip_execution = read_from_stdin = 0;
  default_input = stdin;
#if defined (BUFFERED_INPUT)
  default_buffered_input = -1;
#endif

  /* Fix for the `infinite process creation' bug when running shell scripts
     from startup files on System V. */
  login_shell = make_login_shell = 0;

  /* If this shell has already been run, then reinitialize it to a
     vanilla state. */
  if (shell_initialized || shell_name)
    {
      /* Make sure that we do not infinitely recurse as a login shell. */
      if (*shell_name == '-')
	shell_name++;

      shell_reinitialize ();
      if (setjmp (top_level))
	exit (2);
    }

  shell_environment = env;
  set_shell_name (argv[0]);
  shell_start_time = NOW;	/* NOW now defined in general.h */

  /* Parse argument flags from the input line. */

  /* Find full word arguments first. */
  arg_index = parse_long_options (argv, arg_index, argc);

  if (want_initial_help)
    {
      show_shell_usage (stdout, 1);
      exit (EXECUTION_SUCCESS);
    }

  if (do_version)
    {
      show_shell_version (1);
      exit (EXECUTION_SUCCESS);
    }

  /* All done with full word options; do standard shell option parsing.*/
  this_command_name = shell_name;	/* for error reporting */
  arg_index = parse_shell_options (argv, arg_index, argc);

  /* If user supplied the "--login" (or -l) flag, then set and invert
     LOGIN_SHELL. */
  if (make_login_shell)
    {
      login_shell++;
      login_shell = -login_shell;
    }

  set_login_shell ("login_shell", login_shell != 0);

  if (dump_po_strings)
    dump_translatable_strings = 1;

  if (dump_translatable_strings)
    read_but_dont_execute = 1;

  if (running_setuid && privileged_mode == 0)
    disable_priv_mode ();

  /* Need to get the argument to a -c option processed in the
     above loop.  The next arg is a command to execute, and the
     following args are $0...$n respectively. */
  if (want_pending_command)
    {
      command_execution_string = argv[arg_index];
      if (command_execution_string == 0)
	{
	  report_error (_("%s: option requires an argument"), "-c");
	  exit (EX_BADUSAGE);
	}
      arg_index++;
    }
  this_command_name = (char *)NULL;

  cmd_init();		/* initialize the command object caches */

  /* First, let the outside world know about our interactive status.
     A shell is interactive if the `-i' flag was given, or if all of
     the following conditions are met:
	no -c command
	no arguments remaining or the -s flag given
	standard input is a terminal
	standard error is a terminal
     Refer to Posix.2, the description of the `sh' utility. */

  if (forced_interactive ||		/* -i flag */
      (!command_execution_string &&	/* No -c command and ... */
       wordexp_only == 0 &&		/* No --wordexp and ... */
       ((arg_index == argc) ||		/*   no remaining args or... */
	read_from_stdin) &&		/*   -s flag with args, and */
       isatty (fileno (stdin)) &&	/* Input is a terminal and */
       isatty (fileno (stderr))))	/* error output is a terminal. */
    init_interactive ();
  else
    init_noninteractive ();

  /*
   * Some systems have the bad habit of starting login shells with lots of open
   * file descriptors.  For instance, most systems that have picked up the
   * pre-4.0 Sun YP code leave a file descriptor open each time you call one
   * of the getpw* functions, and it's set to be open across execs.  That
   * means one for login, one for xterm, one for shelltool, etc.  There are
   * also systems that open persistent FDs to other agents or files as part
   * of process startup; these need to be set to be close-on-exec.
   */
  if (login_shell && interactive_shell)
    {
      for (i = 3; i < 20; i++)
	SET_CLOSE_ON_EXEC (i);
    }

  /* If we're in a strict Posix.2 mode, turn on interactive comments,
     alias expansion in non-interactive shells, and other Posix.2 things. */
  if (posixly_correct)
    {
      bind_variable ("POSIXLY_CORRECT", "y", 0);
      sv_strict_posix ("POSIXLY_CORRECT");
    }

  /* Now we run the shopt_alist and process the options. */
  if (shopt_alist)
    run_shopt_alist ();

  /* From here on in, the shell must be a normal functioning shell.
     Variables from the environment are expected to be set, etc. */
  shell_initialize ();

  set_default_lang ();
  set_default_locale_vars ();

  /*
   * M-x term -> TERM=eterm EMACS=22.1 (term:0.96)	(eterm)
   * M-x shell -> TERM=dumb EMACS=t			(no line editing)
   * M-x terminal -> TERM=emacs-em7955 EMACS=		(line editing)
   */
  if (interactive_shell)
    {
      char *term, *emacs;

      term = get_string_value ("TERM");
      emacs = get_string_value ("EMACS");

      /* Not sure any emacs terminal emulator sets TERM=emacs any more */
      no_line_editing |= term && (STREQ (term, "emacs"));
      no_line_editing |= emacs && emacs[0] == 't' && emacs[1] == '\0' && STREQ (term, "dumb");

      /* running_under_emacs == 2 for `eterm' */
      running_under_emacs = (emacs != 0) || (term && STREQN (term, "emacs", 5));
      running_under_emacs += term && STREQN (term, "eterm", 5) && emacs && strstr (emacs, "term");

      if (running_under_emacs)
	gnu_error_format = 1;
    }

  top_level_arg_index = arg_index;
  old_errexit_flag = exit_immediately_on_error;

  /* Give this shell a place to longjmp to before executing the
     startup files.  This allows users to press C-c to abort the
     lengthy startup. */
  code = setjmp (top_level);
  if (code)
    {
      if (code == EXITPROG || code == ERREXIT)
	exit_shell (last_command_exit_value);
      else
	{
#if defined (JOB_CONTROL)
	  /* Reset job control, since run_startup_files turned it off. */
	  set_job_control (interactive_shell);
#endif
	  /* Reset value of `set -e', since it's turned off before running
	     the startup files. */
	  exit_immediately_on_error += old_errexit_flag;
	  locally_skip_execution++;
	}
    }

  arg_index = top_level_arg_index;

  /* Execute the start-up scripts. */

  if (interactive_shell == 0)
    {
      unbind_variable ("PS1");
      unbind_variable ("PS2");
      interactive = 0;
#if 0
      /* This has already been done by init_noninteractive */
      expand_aliases = posixly_correct;
#endif
    }
  else
    {
      change_flag ('i', FLAG_ON);
      interactive = 1;
    }

#if defined (RESTRICTED_SHELL)
  /* Set restricted_shell based on whether the basename of $0 indicates that
     the shell should be restricted or if the `-r' option was supplied at
     startup. */
  restricted_shell = shell_is_restricted (shell_name);

  /* If the `-r' option is supplied at invocation, make sure that the shell
     is not in restricted mode when running the startup files. */
  saverst = restricted;
  restricted = 0;
#endif

  /* The startup files are run with `set -e' temporarily disabled. */
  if (locally_skip_execution == 0 && running_setuid == 0)
    {
      old_errexit_flag = exit_immediately_on_error;
      exit_immediately_on_error = 0;

      run_startup_files ();
      exit_immediately_on_error += old_errexit_flag;
    }

  /* If we are invoked as `sh', turn on Posix mode. */
  if (act_like_sh)
    {
      bind_variable ("POSIXLY_CORRECT", "y", 0);
      sv_strict_posix ("POSIXLY_CORRECT");
    }

#if defined (RESTRICTED_SHELL)
  /* Turn on the restrictions after executing the startup files.  This
     means that `bash -r' or `set -r' invoked from a startup file will
     turn on the restrictions after the startup files are executed. */
  restricted = saverst || restricted;
  if (shell_reinitialized == 0)
    maybe_make_restricted (shell_name);
#endif /* RESTRICTED_SHELL */

#if defined (WORDEXP_OPTION)
  if (wordexp_only)
    {
      startup_state = 3;
      last_command_exit_value = run_wordexp (argv[arg_index]);
      exit_shell (last_command_exit_value);
    }
#endif

  if (command_execution_string)
    {
      arg_index = bind_args (argv, arg_index, argc, 0);
      startup_state = 2;

      if (debugging_mode)
	start_debugger ();

#if defined (ONESHOT)
      executing = 1;
      run_one_command (command_execution_string);
      exit_shell (last_command_exit_value);
#else /* ONESHOT */
      with_input_from_string (command_execution_string, "-c");
      goto read_and_execute;
#endif /* !ONESHOT */
    }

  /* Get possible input filename and set up default_buffered_input or
     default_input as appropriate. */
  if (arg_index != argc && read_from_stdin == 0)
    {
      open_shell_script (argv[arg_index]);
      arg_index++;
    }
  else if (interactive == 0)
    /* In this mode, bash is reading a script from stdin, which is a
       pipe or redirected file. */
#if defined (BUFFERED_INPUT)
    default_buffered_input = fileno (stdin);	/* == 0 */
#else
    setbuf (default_input, (char *)NULL);
#endif /* !BUFFERED_INPUT */

  set_bash_input ();

  /* Bind remaining args to $1 ... $n */
  arg_index = bind_args (argv, arg_index, argc, 1);

  if (debugging_mode && locally_skip_execution == 0 && running_setuid == 0)
    start_debugger ();

  /* Do the things that should be done only for interactive shells. */
  if (interactive_shell)
    {
      /* Set up for checking for presence of mail. */
      reset_mail_timer ();
      init_mail_dates ();

#if defined (HISTORY)
      /* Initialize the interactive history stuff. */
      bash_initialize_history ();
      /* Don't load the history from the history file if we've already
	 saved some lines in this session (e.g., by putting `history -s xx'
	 into one of the startup files). */
      if (shell_initialized == 0 && history_lines_this_session == 0)
	load_history ();
#endif /* HISTORY */

      /* Initialize terminal state for interactive shells after the
	 .bash_profile and .bashrc are interpreted. */
      get_tty_state ();
    }

#if !defined (ONESHOT)
 read_and_execute:
#endif /* !ONESHOT */

  shell_initialized = 1;

  /* Read commands until exit condition. */
  reader_loop ();
  exit_shell (last_command_exit_value);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\shell.c:354
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\shell.c:754
parsing error 
{
  int arg_index, longarg, i;
  char *arg_string;

  arg_index = arg_start;
  while ((arg_index != arg_end) && (arg_string = argv[arg_index]) &&
	 (*arg_string == '-'))
    {
      longarg = 0;

      /* Make --login equivalent to -login. */
      if (arg_string[1] == '-' && arg_string[2])
	{
	  longarg = 1;
	  arg_string++;
	}

      for (i = 0; long_args[i].name; i++)
	{
	  if (STREQ (arg_string + 1, long_args[i].name))
	    {
	      if (long_args[i].type == Int)
		*long_args[i].int_value = 1;
	      else if (argv[++arg_index] == 0)
		{
		  report_error (_("%s: option requires an argument"), long_args[i].name);
		  exit (EX_BADUSAGE);
		}
	      else
		*long_args[i].char_value = argv[arg_index];

	      break;
	    }
	}
      if (long_args[i].name == 0)
	{
	  if (longarg)
	    {
	      report_error (_("%s: invalid option"), argv[arg_index]);
	      show_shell_usage (stderr, 0);
	      exit (EX_BADUSAGE);
	    }
	  break;		/* No such argument.  Maybe flag arg. */
	}

      arg_index++;
    }

  return (arg_index);
}
warning: parse error {
  int arg_index, longarg, i;
  char *arg_string;

  arg_index = arg_start;
  while ((arg_index != arg_end) && (arg_string = argv[arg_index]) &&
	 (*arg_string == '-'))
    {
      longarg = 0;

      /* Make --login equivalent to -login. */
      if (arg_string[1] == '-' && arg_string[2])
	{
	  longarg = 1;
	  arg_string++;
	}

      for (i = 0; long_args[i].name; i++)
	{
	  if (STREQ (arg_string + 1, long_args[i].name))
	    {
	      if (long_args[i].type == Int)
		*long_args[i].int_value = 1;
	      else if (argv[++arg_index] == 0)
		{
		  report_error (_("%s: option requires an argument"), long_args[i].name);
		  exit (EX_BADUSAGE);
		}
	      else
		*long_args[i].char_value = argv[arg_index];

	      break;
	    }
	}
      if (long_args[i].name == 0)
	{
	  if (longarg)
	    {
	      report_error (_("%s: invalid option"), argv[arg_index]);
	      show_shell_usage (stderr, 0);
	      exit (EX_BADUSAGE);
	    }
	  break;		/* No such argument.  Maybe flag arg. */
	}

      arg_index++;
    }

  return (arg_index);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\shell.c:757
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\shell.c:809
parsing error 
{
  int arg_index;
  int arg_character, on_or_off, next_arg, i;
  char *o_option, *arg_string;

  arg_index = arg_start;
  while (arg_index != arg_end && (arg_string = argv[arg_index]) &&
	 (*arg_string == '-' || *arg_string == '+'))
    {
      /* There are flag arguments, so parse them. */
      next_arg = arg_index + 1;

      /* A single `-' signals the end of options.  From the 4.3 BSD sh.
	 An option `--' means the same thing; this is the standard
	 getopt(3) meaning. */
      if (arg_string[0] == '-' &&
	   (arg_string[1] == '\0' ||
	     (arg_string[1] == '-' && arg_string[2] == '\0')))
	return (next_arg);

      i = 1;
      on_or_off = arg_string[0];
      while (arg_character = arg_string[i++])
	{
	  switch (arg_character)
	    {
	    case 'c':
	      want_pending_command = 1;
	      break;

	    case 'l':
	      make_login_shell = 1;
	      break;

	    case 's':
	      read_from_stdin = 1;
	      break;

	    case 'o':
	      o_option = argv[next_arg];
	      if (o_option == 0)
		{
		  list_minus_o_opts (-1, (on_or_off == '-') ? 0 : 1);
		  break;
		}
	      if (set_minus_o_option (on_or_off, o_option) != EXECUTION_SUCCESS)
		exit (EX_BADUSAGE);
	      next_arg++;
	      break;

	    case 'O':
	      /* Since some of these can be overridden by the normal
		 interactive/non-interactive shell initialization or
		 initializing posix mode, we save the options and process
		 them after initialization. */
	      o_option = argv[next_arg];
	      if (o_option == 0)
		{
		  shopt_listopt (o_option, (on_or_off == '-') ? 0 : 1);
		  break;
		}
	      add_shopt_to_alist (o_option, on_or_off);
	      next_arg++;
	      break;

	    case 'D':
	      dump_translatable_strings = 1;
	      break;

	    default:
	      if (change_flag (arg_character, on_or_off) == FLAG_ERROR)
		{
		  report_error (_("%c%c: invalid option"), on_or_off, arg_character);
		  show_shell_usage (stderr, 0);
		  exit (EX_BADUSAGE);
		}
	    }
	}
      /* Can't do just a simple increment anymore -- what about
	 "bash -abouo emacs ignoreeof -hP"? */
      arg_index = next_arg;
    }

  return (arg_index);
}
warning: parse error {
  int arg_index;
  int arg_character, on_or_off, next_arg, i;
  char *o_option, *arg_string;

  arg_index = arg_start;
  while (arg_index != arg_end && (arg_string = argv[arg_index]) &&
	 (*arg_string == '-' || *arg_string == '+'))
    {
      /* There are flag arguments, so parse them. */
      next_arg = arg_index + 1;

      /* A single `-' signals the end of options.  From the 4.3 BSD sh.
	 An option `--' means the same thing; this is the standard
	 getopt(3) meaning. */
      if (arg_string[0] == '-' &&
	   (arg_string[1] == '\0' ||
	     (arg_string[1] == '-' && arg_string[2] == '\0')))
	return (next_arg);

      i = 1;
      on_or_off = arg_string[0];
      while (arg_character = arg_string[i++])
	{
	  switch (arg_character)
	    {
	    case 'c':
	      want_pending_command = 1;
	      break;

	    case 'l':
	      make_login_shell = 1;
	      break;

	    case 's':
	      read_from_stdin = 1;
	      break;

	    case 'o':
	      o_option = argv[next_arg];
	      if (o_option == 0)
		{
		  list_minus_o_opts (-1, (on_or_off == '-') ? 0 : 1);
		  break;
		}
	      if (set_minus_o_option (on_or_off, o_option) != EXECUTION_SUCCESS)
		exit (EX_BADUSAGE);
	      next_arg++;
	      break;

	    case 'O':
	      /* Since some of these can be overridden by the normal
		 interactive/non-interactive shell initialization or
		 initializing posix mode, we save the options and process
		 them after initialization. */
	      o_option = argv[next_arg];
	      if (o_option == 0)
		{
		  shopt_listopt (o_option, (on_or_off == '-') ? 0 : 1);
		  break;
		}
	      add_shopt_to_alist (o_option, on_or_off);
	      next_arg++;
	      break;

	    case 'D':
	      dump_translatable_strings = 1;
	      break;

	    default:
	      if (change_flag (arg_character, on_or_off) == FLAG_ERROR)
		{
		  report_error (_("%c%c: invalid option"), on_or_off, arg_character);
		  show_shell_usage (stderr, 0);
		  exit (EX_BADUSAGE);
		}
	    }
	}
      /* Can't do just a simple increment anymore -- what about
	 "bash -abouo emacs ignoreeof -hP"? */
      arg_index = next_arg;
    }

  return (arg_index);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\shell.c:812
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\shell.c:900
parsing error 
{
  fflush (stdout);		/* XXX */
  fflush (stderr);

  /* Do trap[0] if defined.  Allow it to override the exit status
     passed to us. */
  if (signal_is_trapped (0))
    s = run_exit_trap ();

#if defined (PROCESS_SUBSTITUTION)
  unlink_fifo_list ();
#endif /* PROCESS_SUBSTITUTION */

#if defined (HISTORY)
  if (interactive_shell)
    maybe_save_shell_history ();
#endif /* HISTORY */

#if defined (COPROCESS_SUPPORT)
  coproc_flush ();
#endif

#if defined (JOB_CONTROL)
  /* If the user has run `shopt -s huponexit', hangup all jobs when we exit
     an interactive login shell.  ksh does this unconditionally. */
  if (interactive_shell && login_shell && hup_on_exit)
    hangup_all_jobs ();

  /* If this shell is interactive, terminate all stopped jobs and
     restore the original terminal process group.  Don't do this if we're
     in a subshell and calling exit_shell after, for example, a failed
     word expansion. */
  if (subshell_environment == 0)
    end_job_control ();
#endif /* JOB_CONTROL */

  /* Always return the exit status of the last command to our parent. */
  sh_exit (s);
}
warning: parse error {
  fflush (stdout);		/* XXX */
  fflush (stderr);

  /* Do trap[0] if defined.  Allow it to override the exit status
     passed to us. */
  if (signal_is_trapped (0))
    s = run_exit_trap ();

#if defined (PROCESS_SUBSTITUTION)
  unlink_fifo_list ();
#endif /* PROCESS_SUBSTITUTION */

#if defined (HISTORY)
  if (interactive_shell)
    maybe_save_shell_history ();
#endif /* HISTORY */

#if defined (COPROCESS_SUPPORT)
  coproc_flush ();
#endif

#if defined (JOB_CONTROL)
  /* If the user has run `shopt -s huponexit', hangup all jobs when we exit
     an interactive login shell.  ksh does this unconditionally. */
  if (interactive_shell && login_shell && hup_on_exit)
    hangup_all_jobs ();

  /* If this shell is interactive, terminate all stopped jobs and
     restore the original terminal process group.  Don't do this if we're
     in a subshell and calling exit_shell after, for example, a failed
     word expansion. */
  if (subshell_environment == 0)
    end_job_control ();
#endif /* JOB_CONTROL */

  /* Always return the exit status of the last command to our parent. */
  sh_exit (s);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\shell.c:902
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\shell.c:945
parsing error 
{
#if defined (MALLOC_DEBUG) && defined (USING_BASH_MALLOC)
  if (malloc_trace_at_exit)
    trace_malloc_stats (get_name_for_error (), (char *)NULL);
#endif

  exit (s);
}
warning: parse error {
#if defined (MALLOC_DEBUG) && defined (USING_BASH_MALLOC)
  if (malloc_trace_at_exit)
    trace_malloc_stats (get_name_for_error (), (char *)NULL);
#endif

  exit (s);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\shell.c:947
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\shell.c:984
parsing error 
{
  char *fn;

  if (env_file && *env_file)
    {
      fn = expand_string_unsplit_to_string (env_file, Q_DOUBLE_QUOTES);
      if (fn && *fn)
	maybe_execute_file (fn, 1);
      FREE (fn);
    }
}
warning: parse error {
  char *fn;

  if (env_file && *env_file)
    {
      fn = expand_string_unsplit_to_string (env_file, Q_DOUBLE_QUOTES);
      if (fn && *fn)
	maybe_execute_file (fn, 1);
      FREE (fn);
    }
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\shell.c:986
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\shell.c:1,320
parsing error 
{
  register int i;
  WORD_LIST *args;

  for (i = arg_start, args = (WORD_LIST *)NULL; i < arg_end; i++)
    args = make_word_list (make_word (argv[i]), args);
  if (args)
    {
      args = REVERSE_LIST (args, WORD_LIST *);
      if (start_index == 0)	/* bind to $0...$n for sh -c command */
	{
	  /* Posix.2 4.56.3 says that the first argument after sh -c command
	     becomes $0, and the rest of the arguments become $1...$n */
	  shell_name = savestring (args->word->word);
	  FREE (dollar_vars[0]);
	  dollar_vars[0] = savestring (args->word->word);
	  remember_args (args->next, 1);
	  push_args (args->next);	/* BASH_ARGV and BASH_ARGC */
	}
      else			/* bind to $1...$n for shell script */
        {
	  remember_args (args, 1);
	  push_args (args);		/* BASH_ARGV and BASH_ARGC */
        }

      dispose_words (args);
    }

  return (i);
}
warning: parse error {
  register int i;
  WORD_LIST *args;

  for (i = arg_start, args = (WORD_LIST *)NULL; i < arg_end; i++)
    args = make_word_list (make_word (argv[i]), args);
  if (args)
    {
      args = REVERSE_LIST (args, WORD_LIST *);
      if (start_index == 0)	/* bind to $0...$n for sh -c command */
	{
	  /* Posix.2 4.56.3 says that the first argument after sh -c command
	     becomes $0, and the rest of the arguments become $1...$n */
	  shell_name = savestring (args->word->word);
	  FREE (dollar_vars[0]);
	  dollar_vars[0] = savestring (args->word->word);
	  remember_args (args->next, 1);
	  push_args (args->next);	/* BASH_ARGV and BASH_ARGC */
	}
      else			/* bind to $1...$n for shell script */
        {
	  remember_args (args, 1);
	  push_args (args);		/* BASH_ARGV and BASH_ARGC */
        }

      dispose_words (args);
    }

  return (i);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\shell.c:1,323
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\shell.c:1,378
parsing error 
{
  int fd, e, fd_is_tty;
  char *filename, *path_filename, *t;
  char sample[80];
  int sample_len;
  struct stat sb;
#if defined (ARRAY_VARS)
  SHELL_VAR *funcname_v, *bash_source_v, *bash_lineno_v;
  ARRAY *funcname_a, *bash_source_a, *bash_lineno_a;
#endif

  filename = savestring (script_name);

  fd = open (filename, O_RDONLY);
  if ((fd < 0) && (errno == ENOENT) && (absolute_program (filename) == 0))
    {
      e = errno;
      /* If it's not in the current directory, try looking through PATH
	 for it. */
      path_filename = find_path_file (script_name);
      if (path_filename)
	{
	  free (filename);
	  filename = path_filename;
	  fd = open (filename, O_RDONLY);
	}
      else
	errno = e;
    }

  if (fd < 0)
    {
      e = errno;
      file_error (filename);
      exit ((e == ENOENT) ? EX_NOTFOUND : EX_NOINPUT);
    }

  free (dollar_vars[0]);
  dollar_vars[0] = exec_argv0 ? savestring (exec_argv0) : savestring (script_name);
  if (exec_argv0)
    {
      free (exec_argv0);
      exec_argv0 = (char *)NULL;
    }

#if defined (ARRAY_VARS)
  GET_ARRAY_FROM_VAR ("FUNCNAME", funcname_v, funcname_a);
  GET_ARRAY_FROM_VAR ("BASH_SOURCE", bash_source_v, bash_source_a);
  GET_ARRAY_FROM_VAR ("BASH_LINENO", bash_lineno_v, bash_lineno_a);

  array_push (bash_source_a, filename);
  if (bash_lineno_a)
    {
      t = itos (executing_line_number ());
      array_push (bash_lineno_a, t);
      free (t);
    }
  array_push (funcname_a, "main");
#endif

#ifdef HAVE_DEV_FD
  fd_is_tty = isatty (fd);
#else
  fd_is_tty = 0;
#endif

  /* Only do this with non-tty file descriptors we can seek on. */
  if (fd_is_tty == 0 && (lseek (fd, 0L, 1) != -1))
    {
      /* Check to see if the `file' in `bash file' is a binary file
	 according to the same tests done by execute_simple_command (),
	 and report an error and exit if it is. */
      sample_len = read (fd, sample, sizeof (sample));
      if (sample_len < 0)
	{
	  e = errno;
	  if ((fstat (fd, &sb) == 0) && S_ISDIR (sb.st_mode))
	    internal_error (_("%s: is a directory"), filename);
	  else
	    {
	      errno = e;
	      file_error (filename);
	    }
	  exit (EX_NOEXEC);
	}
      else if (sample_len > 0 && (check_binary_file (sample, sample_len)))
	{
	  internal_error (_("%s: cannot execute binary file"), filename);
	  exit (EX_BINARY_FILE);
	}
      /* Now rewind the file back to the beginning. */
      lseek (fd, 0L, 0);
    }

  /* Open the script.  But try to move the file descriptor to a randomly
     large one, in the hopes that any descriptors used by the script will
     not match with ours. */
  fd = move_to_high_fd (fd, 1, -1);

#if defined (BUFFERED_INPUT)
  default_buffered_input = fd;
  SET_CLOSE_ON_EXEC (default_buffered_input);
#else /* !BUFFERED_INPUT */
  default_input = fdopen (fd, "r");

  if (default_input == 0)
    {
      file_error (filename);
      exit (EX_NOTFOUND);
    }

  SET_CLOSE_ON_EXEC (fd);
  if (fileno (default_input) != fd)
    SET_CLOSE_ON_EXEC (fileno (default_input));
#endif /* !BUFFERED_INPUT */

  /* Just about the only way for this code to be executed is if something
     like `bash -i /dev/stdin' is executed. */
  if (interactive_shell && fd_is_tty)
    {
      dup2 (fd, 0);
      close (fd);
      fd = 0;
#if defined (BUFFERED_INPUT)
      default_buffered_input = 0;
#else
      fclose (default_input);
      default_input = stdin;
#endif
    }
  else if (forced_interactive && fd_is_tty == 0)
    /* But if a script is called with something like `bash -i scriptname',
       we need to do a non-interactive setup here, since we didn't do it
       before. */
    init_interactive_script ();

  free (filename);
  return (fd);
}
warning: parse error {
  int fd, e, fd_is_tty;
  char *filename, *path_filename, *t;
  char sample[80];
  int sample_len;
  struct stat sb;
#if defined (ARRAY_VARS)
  SHELL_VAR *funcname_v, *bash_source_v, *bash_lineno_v;
  ARRAY *funcname_a, *bash_source_a, *bash_lineno_a;
#endif

  filename = savestring (script_name);

  fd = open (filename, O_RDONLY);
  if ((fd < 0) && (errno == ENOENT) && (absolute_program (filename) == 0))
    {
      e = errno;
      /* If it's not in the current directory, try looking through PATH
	 for it. */
      path_filename = find_path_file (script_name);
      if (path_filename)
	{
	  free (filename);
	  filename = path_filename;
	  fd = open (filename, O_RDONLY);
	}
      else
	errno = e;
    }

  if (fd < 0)
    {
      e = errno;
      file_error (filename);
      exit ((e == ENOENT) ? EX_NOTFOUND : EX_NOINPUT);
    }

  free (dollar_vars[0]);
  dollar_vars[0] = exec_argv0 ? savestring (exec_argv0) : savestring (script_name);
  if (exec_argv0)
    {
      free (exec_argv0);
      exec_argv0 = (char *)NULL;
    }

#if defined (ARRAY_VARS)
  GET_ARRAY_FROM_VAR ("FUNCNAME", funcname_v, funcname_a);
  GET_ARRAY_FROM_VAR ("BASH_SOURCE", bash_source_v, bash_source_a);
  GET_ARRAY_FROM_VAR ("BASH_LINENO", bash_lineno_v, bash_lineno_a);

  array_push (bash_source_a, filename);
  if (bash_lineno_a)
    {
      t = itos (executing_line_number ());
      array_push (bash_lineno_a, t);
      free (t);
    }
  array_push (funcname_a, "main");
#endif

#ifdef HAVE_DEV_FD
  fd_is_tty = isatty (fd);
#else
  fd_is_tty = 0;
#endif

  /* Only do this with non-tty file descriptors we can seek on. */
  if (fd_is_tty == 0 && (lseek (fd, 0L, 1) != -1))
    {
      /* Check to see if the `file' in `bash file' is a binary file
	 according to the same tests done by execute_simple_command (),
	 and report an error and exit if it is. */
      sample_len = read (fd, sample, sizeof (sample));
      if (sample_len < 0)
	{
	  e = errno;
	  if ((fstat (fd, &sb) == 0) && S_ISDIR (sb.st_mode))
	    internal_error (_("%s: is a directory"), filename);
	  else
	    {
	      errno = e;
	      file_error (filename);
	    }
	  exit (EX_NOEXEC);
	}
      else if (sample_len > 0 && (check_binary_file (sample, sample_len)))
	{
	  internal_error (_("%s: cannot execute binary file"), filename);
	  exit (EX_BINARY_FILE);
	}
      /* Now rewind the file back to the beginning. */
      lseek (fd, 0L, 0);
    }

  /* Open the script.  But try to move the file descriptor to a randomly
     large one, in the hopes that any descriptors used by the script will
     not match with ours. */
  fd = move_to_high_fd (fd, 1, -1);

#if defined (BUFFERED_INPUT)
  default_buffered_input = fd;
  SET_CLOSE_ON_EXEC (default_buffered_input);
#else /* !BUFFERED_INPUT */
  default_input = fdopen (fd, "r");

  if (default_input == 0)
    {
      file_error (filename);
      exit (EX_NOTFOUND);
    }

  SET_CLOSE_ON_EXEC (fd);
  if (fileno (default_input) != fd)
    SET_CLOSE_ON_EXEC (fileno (default_input));
#endif /* !BUFFERED_INPUT */

  /* Just about the only way for this code to be executed is if something
     like `bash -i /dev/stdin' is executed. */
  if (interactive_shell && fd_is_tty)
    {
      dup2 (fd, 0);
      close (fd);
      fd = 0;
#if defined (BUFFERED_INPUT)
      default_buffered_input = 0;
#else
      fclose (default_input);
      default_input = stdin;
#endif
    }
  else if (forced_interactive && fd_is_tty == 0)
    /* But if a script is called with something like `bash -i scriptname',
       we need to do a non-interactive setup here, since we didn't do it
       before. */
    init_interactive_script ();

  free (filename);
  return (fd);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\shell.c:1,380
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\shell.c:1,549
parsing error 
{
#if defined (BUFFERED_INPUT)
  if ((check_zero && default_buffered_input >= 0) ||
      (check_zero == 0 && default_buffered_input > 0))
    {
      close_buffered_fd (default_buffered_input);
      default_buffered_input = bash_input.location.buffered_fd = -1;
      bash_input.type = st_none;		/* XXX */
    }
#else /* !BUFFERED_INPUT */
  if (default_input)
    {
      fclose (default_input);
      default_input = (FILE *)NULL;
    }
#endif /* !BUFFERED_INPUT */
}
warning: parse error {
#if defined (BUFFERED_INPUT)
  if ((check_zero && default_buffered_input >= 0) ||
      (check_zero == 0 && default_buffered_input > 0))
    {
      close_buffered_fd (default_buffered_input);
      default_buffered_input = bash_input.location.buffered_fd = -1;
      bash_input.type = st_none;		/* XXX */
    }
#else /* !BUFFERED_INPUT */
  if (default_input)
    {
      fclose (default_input);
      default_input = (FILE *)NULL;
    }
#endif /* !BUFFERED_INPUT */
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\shell.c:1,551
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\shell.c:1,575
parsing error 
{
  /* Here's a hack.  If the name of this shell is "sh", then don't do
     any startup files; just try to be more like /bin/sh. */
  shell_name = argv0 ? base_pathname (argv0) : PROGRAM;

  if (argv0 && *argv0 == '-')
    {
      if (*shell_name == '-')
	shell_name++;
      login_shell++;
    }

  if (shell_name[0] == 's' && shell_name[1] == 'h' && shell_name[2] == '\0')
    act_like_sh++;
  if (shell_name[0] == 's' && shell_name[1] == 'u' && shell_name[2] == '\0')
    su_shell++;

  shell_name = argv0 ? argv0 : PROGRAM;
  FREE (dollar_vars[0]);
  dollar_vars[0] = savestring (shell_name);

  /* A program may start an interactive shell with
	  "execl ("/bin/bash", "-", NULL)".
     If so, default the name of this shell to our name. */
  if (!shell_name || !*shell_name || (shell_name[0] == '-' && !shell_name[1]))
    shell_name = PROGRAM;
}
warning: parse error {
  /* Here's a hack.  If the name of this shell is "sh", then don't do
     any startup files; just try to be more like /bin/sh. */
  shell_name = argv0 ? base_pathname (argv0) : PROGRAM;

  if (argv0 && *argv0 == '-')
    {
      if (*shell_name == '-')
	shell_name++;
      login_shell++;
    }

  if (shell_name[0] == 's' && shell_name[1] == 'h' && shell_name[2] == '\0')
    act_like_sh++;
  if (shell_name[0] == 's' && shell_name[1] == 'u' && shell_name[2] == '\0')
    su_shell++;

  shell_name = argv0 ? argv0 : PROGRAM;
  FREE (dollar_vars[0]);
  dollar_vars[0] = savestring (shell_name);

  /* A program may start an interactive shell with
	  "execl ("/bin/bash", "-", NULL)".
     If so, default the name of this shell to our name. */
  if (!shell_name || !*shell_name || (shell_name[0] == '-' && !shell_name[1]))
    shell_name = PROGRAM;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\shell.c:1,577
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\shell.c:1,787
parsing error 
{
  int i;
  char *set_opts, *s, *t;

  if (extra)
    fprintf (fp, _("GNU bash, version %s-(%s)\n"), shell_version_string (), MACHTYPE);
  fprintf (fp, _("Usage:\t%s [GNU long option] [option] ...\n\t%s [GNU long option] [option] script-file ...\n"),
	     shell_name, shell_name);
  fputs (_("GNU long options:\n"), fp);
  for (i = 0; long_args[i].name; i++)
    fprintf (fp, "\t--%s\n", long_args[i].name);

  fputs (_("Shell options:\n"), fp);
  fputs (_("\t-irsD or -c command or -O shopt_option\t\t(invocation only)\n"), fp);

  for (i = 0, set_opts = 0; shell_builtins[i].name; i++)
    if (STREQ (shell_builtins[i].name, "set"))
      set_opts = savestring (shell_builtins[i].short_doc);
  if (set_opts)
    {
      s = strchr (set_opts, '[');
      if (s == 0)
	s = set_opts;
      while (*++s == '-')
	;
      t = strchr (s, ']');
      if (t)
	*t = '\0';
      fprintf (fp, _("\t-%s or -o option\n"), s);
      free (set_opts);
    }

  if (extra)
    {
      fprintf (fp, _("Type `%s -c \"help set\"' for more information about shell options.\n"), shell_name);
      fprintf (fp, _("Type `%s -c help' for more information about shell builtin commands.\n"), shell_name);
      fprintf (fp, _("Use the `bashbug' command to report bugs.\n"));
    }
}
warning: parse error {
  int i;
  char *set_opts, *s, *t;

  if (extra)
    fprintf (fp, _("GNU bash, version %s-(%s)\n"), shell_version_string (), MACHTYPE);
  fprintf (fp, _("Usage:\t%s [GNU long option] [option] ...\n\t%s [GNU long option] [option] script-file ...\n"),
	     shell_name, shell_name);
  fputs (_("GNU long options:\n"), fp);
  for (i = 0; long_args[i].name; i++)
    fprintf (fp, "\t--%s\n", long_args[i].name);

  fputs (_("Shell options:\n"), fp);
  fputs (_("\t-irsD or -c command or -O shopt_option\t\t(invocation only)\n"), fp);

  for (i = 0, set_opts = 0; shell_builtins[i].name; i++)
    if (STREQ (shell_builtins[i].name, "set"))
      set_opts = savestring (shell_builtins[i].short_doc);
  if (set_opts)
    {
      s = strchr (set_opts, '[');
      if (s == 0)
	s = set_opts;
      while (*++s == '-')
	;
      t = strchr (s, ']');
      if (t)
	*t = '\0';
      fprintf (fp, _("\t-%s or -o option\n"), s);
      free (set_opts);
    }

  if (extra)
    {
      fprintf (fp, _("Type `%s -c \"help set\"' for more information about shell options.\n"), shell_name);
      fprintf (fp, _("Type `%s -c help' for more information about shell builtin commands.\n"), shell_name);
      fprintf (fp, _("Use the `bashbug' command to report bugs.\n"));
    }
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\shell.c:1,790
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\shell.c:1,831
parsing error 
{
  if (shopt_ind >= shopt_len)
    {
      shopt_len += 8;
      shopt_alist = (STRING_INT_ALIST *)xrealloc (shopt_alist, shopt_len * sizeof (shopt_alist[0]));
    }
  shopt_alist[shopt_ind].word = opt;
  shopt_alist[shopt_ind].token = on_or_off;
  shopt_ind++;
}
warning: parse error {
  if (shopt_ind >= shopt_len)
    {
      shopt_len += 8;
      shopt_alist = (STRING_INT_ALIST *)xrealloc (shopt_alist, shopt_len * sizeof (shopt_alist[0]));
    }
  shopt_alist[shopt_ind].word = opt;
  shopt_alist[shopt_ind].token = on_or_off;
  shopt_ind++;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\shell.c:1,834
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\sig.c...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\bashtypes.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\bashintl.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\shell.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\jobs.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\siglist.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\sig.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\trap.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\common.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\sig.c:99
parsing error 
{
  initialize_shell_signals ();
  initialize_job_signals ();
#if !defined (HAVE_SYS_SIGLIST) && !defined (HAVE_UNDER_SYS_SIGLIST) && !defined (HAVE_STRSIGNAL)
  if (reinit == 0)
    initialize_siglist ();
#endif /* !HAVE_SYS_SIGLIST && !HAVE_UNDER_SYS_SIGLIST && !HAVE_STRSIGNAL */
}
warning: parse error {
  initialize_shell_signals ();
  initialize_job_signals ();
#if !defined (HAVE_SYS_SIGLIST) && !defined (HAVE_UNDER_SYS_SIGLIST) && !defined (HAVE_STRSIGNAL)
  if (reinit == 0)
    initialize_siglist ();
#endif /* !HAVE_SYS_SIGLIST && !HAVE_UNDER_SYS_SIGLIST && !HAVE_STRSIGNAL */
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\sig.c:101
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\sig.c:449
parsing error 
{
  longjmp (top_level, value);
}
warning: parse error {
  longjmp (top_level, value);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\sig.c:451
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\sig.c:456
parsing error 
{
  /* If we get called twice with the same signal before handling it,
     terminate right away. */
  if (
#ifdef SIGHUP
    sig != SIGHUP &&
#endif
#ifdef SIGINT
    sig != SIGINT &&
#endif
#ifdef SIGDANGER
    sig != SIGDANGER &&
#endif
#ifdef SIGPIPE
    sig != SIGPIPE &&
#endif
#ifdef SIGALRM
    sig != SIGALRM &&
#endif
#ifdef SIGTERM
    sig != SIGTERM &&
#endif
#ifdef SIGXCPU
    sig != SIGXCPU &&
#endif
#ifdef SIGXFSZ
    sig != SIGXFSZ &&
#endif
#ifdef SIGVTALRM
    sig != SIGVTALRM &&
#endif
#ifdef SIGLOST
    sig != SIGLOST &&
#endif
#ifdef SIGUSR1
    sig != SIGUSR1 &&
#endif
#ifdef SIGUSR2
   sig != SIGUSR2 &&
#endif
   sig == terminating_signal)
    terminate_immediately = 1;

  terminating_signal = sig;

  /* XXX - should this also trigger when interrupt_immediately is set? */
  if (terminate_immediately)
    {
#if defined (HISTORY)
      /* XXX - will inhibit history file being written */
      history_lines_this_session = 0;
#endif
      terminate_immediately = 0;
      termsig_handler (sig);
    }

  SIGRETURN (0);
}
warning: parse error {
  /* If we get called twice with the same signal before handling it,
     terminate right away. */
  if (
#ifdef SIGHUP
    sig != SIGHUP &&
#endif
#ifdef SIGINT
    sig != SIGINT &&
#endif
#ifdef SIGDANGER
    sig != SIGDANGER &&
#endif
#ifdef SIGPIPE
    sig != SIGPIPE &&
#endif
#ifdef SIGALRM
    sig != SIGALRM &&
#endif
#ifdef SIGTERM
    sig != SIGTERM &&
#endif
#ifdef SIGXCPU
    sig != SIGXCPU &&
#endif
#ifdef SIGXFSZ
    sig != SIGXFSZ &&
#endif
#ifdef SIGVTALRM
    sig != SIGVTALRM &&
#endif
#ifdef SIGLOST
    sig != SIGLOST &&
#endif
#ifdef SIGUSR1
    sig != SIGUSR1 &&
#endif
#ifdef SIGUSR2
   sig != SIGUSR2 &&
#endif
   sig == terminating_signal)
    terminate_immediately = 1;

  terminating_signal = sig;

  /* XXX - should this also trigger when interrupt_immediately is set? */
  if (terminate_immediately)
    {
#if defined (HISTORY)
      /* XXX - will inhibit history file being written */
      history_lines_this_session = 0;
#endif
      terminate_immediately = 0;
      termsig_handler (sig);
    }

  SIGRETURN (0);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\sig.c:458
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\sig.c:518
parsing error 
{
  static int handling_termsig = 0;

  /* Simple semaphore to keep this function from being executed multiple
     times.  Since we no longer are running as a signal handler, we don't
     block multiple occurrences of the terminating signals while running. */
  if (handling_termsig)
    return;
  handling_termsig = 1;
  terminating_signal = 0;	/* keep macro from re-testing true. */

  /* I don't believe this condition ever tests true. */
  if (sig == SIGINT && signal_is_trapped (SIGINT))
    run_interrupt_trap ();

#if defined (HISTORY)
  if (interactive_shell && sig != SIGABRT)
    maybe_save_shell_history ();
#endif /* HISTORY */

#if defined (JOB_CONTROL)
  if (sig == SIGHUP && (interactive || (subshell_environment & (SUBSHELL_COMSUB|SUBSHELL_PROCSUB))))
    hangup_all_jobs ();
  end_job_control ();
#endif /* JOB_CONTROL */

#if defined (PROCESS_SUBSTITUTION)
  unlink_fifo_list ();
#endif /* PROCESS_SUBSTITUTION */

  /* Reset execution context */
  loop_level = continuing = breaking = funcnest = 0;
  executing_list = comsub_ignore_return = return_catch_flag = 0;

  run_exit_trap ();
  set_signal_handler (sig, SIG_DFL);
  kill (getpid (), sig);
}
warning: parse error {
  static int handling_termsig = 0;

  /* Simple semaphore to keep this function from being executed multiple
     times.  Since we no longer are running as a signal handler, we don't
     block multiple occurrences of the terminating signals while running. */
  if (handling_termsig)
    return;
  handling_termsig = 1;
  terminating_signal = 0;	/* keep macro from re-testing true. */

  /* I don't believe this condition ever tests true. */
  if (sig == SIGINT && signal_is_trapped (SIGINT))
    run_interrupt_trap ();

#if defined (HISTORY)
  if (interactive_shell && sig != SIGABRT)
    maybe_save_shell_history ();
#endif /* HISTORY */

#if defined (JOB_CONTROL)
  if (sig == SIGHUP && (interactive || (subshell_environment & (SUBSHELL_COMSUB|SUBSHELL_PROCSUB))))
    hangup_all_jobs ();
  end_job_control ();
#endif /* JOB_CONTROL */

#if defined (PROCESS_SUBSTITUTION)
  unlink_fifo_list ();
#endif /* PROCESS_SUBSTITUTION */

  /* Reset execution context */
  loop_level = continuing = breaking = funcnest = 0;
  executing_list = comsub_ignore_return = return_catch_flag = 0;

  run_exit_trap ();
  set_signal_handler (sig, SIG_DFL);
  kill (getpid (), sig);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\sig.c:520
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\sig.c:561
parsing error 
{
#if defined (MUST_REINSTALL_SIGHANDLERS)
  signal (sig, sigint_sighandler);
#endif

  /* interrupt_state needs to be set for the stack of interrupts to work
     right.  Should it be set unconditionally? */
  if (interrupt_state == 0)
    ADDINTERRUPT;

  if (interrupt_immediately)
    {
      interrupt_immediately = 0;
      last_command_exit_value = 128 + sig;
      throw_to_top_level ();
    }

  SIGRETURN (0);
}
warning: parse error {
#if defined (MUST_REINSTALL_SIGHANDLERS)
  signal (sig, sigint_sighandler);
#endif

  /* interrupt_state needs to be set for the stack of interrupts to work
     right.  Should it be set unconditionally? */
  if (interrupt_state == 0)
    ADDINTERRUPT;

  if (interrupt_immediately)
    {
      interrupt_immediately = 0;
      last_command_exit_value = 128 + sig;
      throw_to_top_level ();
    }

  SIGRETURN (0);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\sig.c:563
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\siglist.c...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\bashtypes.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\siglist.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\bashintl.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\xmalloc.h...skip
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\stringlib.c...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\bashtypes.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\bashansi.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\chartypes.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\shell.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\pathexp.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\glob\glob.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\stringlib.c:51
parsing error 
{
  register int i;
  int r;

  for (i = r = 0; alist[i].word; i++)
    {
#if defined (EXTENDED_GLOB)
      if (flags)
	r = strmatch (alist[i].word, string, FNM_EXTMATCH) != FNM_NOMATCH;
      else
#endif
	r = STREQ (string, alist[i].word);

      if (r)
	return (alist[i].token);
    }
  return -1;
}
warning: parse error {
  register int i;
  int r;

  for (i = r = 0; alist[i].word; i++)
    {
#if defined (EXTENDED_GLOB)
      if (flags)
	r = strmatch (alist[i].word, string, FNM_EXTMATCH) != FNM_NOMATCH;
      else
#endif
	r = STREQ (string, alist[i].word);

      if (r)
	return (alist[i].token);
    }
  return -1;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\stringlib.c:55
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\stringlib.c:78
parsing error 
{
  register int i;

  for (i = 0; alist[i].word; i++)
    {
      if (alist[i].token == token)
        return (savestring (alist[i].word));
    }
  return ((char *)NULL);
}
warning: parse error {
  register int i;

  for (i = 0; alist[i].word; i++)
    {
      if (alist[i].token == token)
        return (savestring (alist[i].word));
    }
  return ((char *)NULL);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\stringlib.c:82
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\stringlib.c:94
parsing error 
{
  register int i;
  int r;

  for (i = r = 0; alist[i].word; i++)
    {
#if defined (EXTENDED_GLOB)
      if (flags)
	r = strmatch (alist[i].word, string, FNM_EXTMATCH) != FNM_NOMATCH;
      else
#endif
	r = STREQ (string, alist[i].word);

      if (r)
	return (i);
    }

  return -1;
}
warning: parse error {
  register int i;
  int r;

  for (i = r = 0; alist[i].word; i++)
    {
#if defined (EXTENDED_GLOB)
      if (flags)
	r = strmatch (alist[i].word, string, FNM_EXTMATCH) != FNM_NOMATCH;
      else
#endif
	r = STREQ (string, alist[i].word);

      if (r)
	return (i);
    }

  return -1;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\stringlib.c:98
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\stringlib.c:128
parsing error 
{
  register int len;
  register char *result;

  len = end - start;
  result = (char *)xmalloc (len + 1);
  strncpy (result, string + start, len);
  result[len] = '\0';
  return (result);
}
warning: parse error {
  register int len;
  register char *result;

  len = end - start;
  result = (char *)xmalloc (len + 1);
  strncpy (result, string + start, len);
  result[len] = '\0';
  return (result);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\stringlib.c:130
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\stringlib.c:145
parsing error 
{
  int patlen, replen, templen, tempsize, repl, i;
  char *temp, *r;

  patlen = strlen (pat);
  replen = strlen (rep);
  for (temp = (char *)NULL, i = templen = tempsize = 0, repl = 1; string[i]; )
    {
      if (repl && STREQN (string + i, pat, patlen))
	{
	  if (replen)
	    RESIZE_MALLOCED_BUFFER (temp, templen, replen, tempsize, (replen * 2));

	  for (r = rep; *r; )
	    temp[templen++] = *r++;

	  i += patlen ? patlen : 1;	/* avoid infinite recursion */
	  repl = global != 0;
	}
      else
	{
	  RESIZE_MALLOCED_BUFFER (temp, templen, 1, tempsize, 16);
	  temp[templen++] = string[i++];
	}
    }
  if (temp)
    temp[templen] = 0;
  else
    temp = savestring (string);
  return (temp);
}
warning: parse error {
  int patlen, replen, templen, tempsize, repl, i;
  char *temp, *r;

  patlen = strlen (pat);
  replen = strlen (rep);
  for (temp = (char *)NULL, i = templen = tempsize = 0, repl = 1; string[i]; )
    {
      if (repl && STREQN (string + i, pat, patlen))
	{
	  if (replen)
	    RESIZE_MALLOCED_BUFFER (temp, templen, replen, tempsize, (replen * 2));

	  for (r = rep; *r; )
	    temp[templen++] = *r++;

	  i += patlen ? patlen : 1;	/* avoid infinite recursion */
	  repl = global != 0;
	}
      else
	{
	  RESIZE_MALLOCED_BUFFER (temp, templen, 1, tempsize, 16);
	  temp[templen++] = string[i++];
	}
    }
  if (temp)
    temp[templen] = 0;
  else
    temp = savestring (string);
  return (temp);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\stringlib.c:148
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\stringlib.c:184
parsing error 
{
  char *ret, *p, *r, *t;
  int len, rlen, ind, tlen;

  len = STRLEN (text);
  rlen = len + strlen (string) + 2;
  ret = (char *)xmalloc (rlen);

  for (p = string, r = ret; p && *p; )
    {
      if (*p == c)
	{
	  if (len)
	    {
	      ind = r - ret;
	      if (do_glob && (glob_pattern_p (text) || strchr (text, '\\')))
		{
		  t = quote_globbing_chars (text);
		  tlen = strlen (t);
		  RESIZE_MALLOCED_BUFFER (ret, ind, tlen, rlen, rlen);
		  r = ret + ind;	/* in case reallocated */
		  strcpy (r, t);
		  r += tlen;
		  free (t);
		}
	      else
		{
		  RESIZE_MALLOCED_BUFFER (ret, ind, len, rlen, rlen);
		  r = ret + ind;	/* in case reallocated */
		  strcpy (r, text);
		  r += len;
		}
	    }
	  p++;
	  continue;
	}

      if (*p == '\\' && p[1] == c)
	p++;

      ind = r - ret;
      RESIZE_MALLOCED_BUFFER (ret, ind, 2, rlen, rlen);
      r = ret + ind;			/* in case reallocated */
      *r++ = *p++;
    }
  *r = '\0';

  return ret;
}
warning: parse error {
  char *ret, *p, *r, *t;
  int len, rlen, ind, tlen;

  len = STRLEN (text);
  rlen = len + strlen (string) + 2;
  ret = (char *)xmalloc (rlen);

  for (p = string, r = ret; p && *p; )
    {
      if (*p == c)
	{
	  if (len)
	    {
	      ind = r - ret;
	      if (do_glob && (glob_pattern_p (text) || strchr (text, '\\')))
		{
		  t = quote_globbing_chars (text);
		  tlen = strlen (t);
		  RESIZE_MALLOCED_BUFFER (ret, ind, tlen, rlen, rlen);
		  r = ret + ind;	/* in case reallocated */
		  strcpy (r, t);
		  r += tlen;
		  free (t);
		}
	      else
		{
		  RESIZE_MALLOCED_BUFFER (ret, ind, len, rlen, rlen);
		  r = ret + ind;	/* in case reallocated */
		  strcpy (r, text);
		  r += len;
		}
	    }
	  p++;
	  continue;
	}

      if (*p == '\\' && p[1] == c)
	p++;

      ind = r - ret;
      RESIZE_MALLOCED_BUFFER (ret, ind, 2, rlen, rlen);
      r = ret + ind;			/* in case reallocated */
      *r++ = *p++;
    }
  *r = '\0';

  return ret;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\stringlib.c:189
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\stringlib.c:264
parsing error 
{
  while (len >= 0)
    {
      if ((newlines_only && string[len] == '\n') ||
	  (!newlines_only && whitespace (string[len])))
	len--;
      else
	break;
    }
  string[len + 1] = '\0';
}
warning: parse error {
  while (len >= 0)
    {
      if ((newlines_only && string[len] == '\n') ||
	  (!newlines_only && whitespace (string[len])))
	len--;
      else
	break;
    }
  string[len + 1] = '\0';
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\stringlib.c:268
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\stringlib.c:282
parsing error 
{
  FASTCOPY (s, d, n);
}
warning: parse error {
  FASTCOPY (s, d, n);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\stringlib.c:285
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\subst.c...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\bashtypes.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\chartypes.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\bashansi.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\posixstat.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\bashintl.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\shell.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\parser.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\flags.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\jobs.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\execute_cmd.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\filecntl.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\trap.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\pathexp.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\mailcheck.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\shmbutil.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\typemax.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\getopt.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\common.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\tilde\tilde.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\glob\strmatch.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\subst.c:526
parsing error 
{
  register char *p;

  for (p = s; *p; p++)
    {
      if (((flags & ST_BACKSL) && *p == '\\')
	    || ((flags & ST_CTLESC) && *p == CTLESC))
	{
	  p++;
	  if (*p == '\0')
	    return ((char *)NULL);
	  continue;
	}
      else if (*p == c)
	return p;
    }
  return ((char *)NULL);
}
warning: parse error {
  register char *p;

  for (p = s; *p; p++)
    {
      if (((flags & ST_BACKSL) && *p == '\\')
	    || ((flags & ST_CTLESC) && *p == CTLESC))
	{
	  p++;
	  if (*p == '\0')
	    return ((char *)NULL);
	  continue;
	}
      else if (*p == c)
	return p;
    }
  return ((char *)NULL);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\subst.c:529
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\subst.c:551
parsing error 
{
  size_t slen;
  int sindex, c;
  DECLARE_MBSTATE;

  slen = strlen (string);
  sindex = 0;
  while (c = string[sindex])
    {
      if (c == character)
	return (1);

      switch (c)
	{
	default:
	  ADVANCE_CHAR (string, slen, sindex);
	  break;

	case '\\':
	  sindex++;
	  if (string[sindex])
	    ADVANCE_CHAR (string, slen, sindex);
	  break;

	case '\'':
	  sindex = skip_single_quoted (string, slen, ++sindex);
	  break;

	case '"':
	  sindex = skip_double_quoted (string, slen, ++sindex);
	  break;
	}
    }
  return (0);
}
warning: parse error {
  size_t slen;
  int sindex, c;
  DECLARE_MBSTATE;

  slen = strlen (string);
  sindex = 0;
  while (c = string[sindex])
    {
      if (c == character)
	return (1);

      switch (c)
	{
	default:
	  ADVANCE_CHAR (string, slen, sindex);
	  break;

	case '\\':
	  sindex++;
	  if (string[sindex])
	    ADVANCE_CHAR (string, slen, sindex);
	  break;

	case '\'':
	  sindex = skip_single_quoted (string, slen, ++sindex);
	  break;

	case '"':
	  sindex = skip_double_quoted (string, slen, ++sindex);
	  break;
	}
    }
  return (0);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\subst.c:554
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\subst.c:592
parsing error 
{
  size_t slen;
  int sindex, c, sublen;
  DECLARE_MBSTATE;

  if (substr == 0 || *substr == '\0')
    return (0);

  slen = strlen (string);
  sublen = strlen (substr);
  for (sindex = 0; c = string[sindex]; )
    {
      if (STREQN (string + sindex, substr, sublen))
	return (1);

      switch (c)
	{
	case '\\':
	  sindex++;
	  if (string[sindex])
	    ADVANCE_CHAR (string, slen, sindex);
	  break;

	case '\'':
	  sindex = skip_single_quoted (string, slen, ++sindex);
	  break;

	case '"':
	  sindex = skip_double_quoted (string, slen, ++sindex);
	  break;

	default:
	  ADVANCE_CHAR (string, slen, sindex);
	  break;
	}
    }
  return (0);
}
warning: parse error {
  size_t slen;
  int sindex, c, sublen;
  DECLARE_MBSTATE;

  if (substr == 0 || *substr == '\0')
    return (0);

  slen = strlen (string);
  sublen = strlen (substr);
  for (sindex = 0; c = string[sindex]; )
    {
      if (STREQN (string + sindex, substr, sublen))
	return (1);

      switch (c)
	{
	case '\\':
	  sindex++;
	  if (string[sindex])
	    ADVANCE_CHAR (string, slen, sindex);
	  break;

	case '\'':
	  sindex = skip_single_quoted (string, slen, ++sindex);
	  break;

	case '"':
	  sindex = skip_double_quoted (string, slen, ++sindex);
	  break;

	default:
	  ADVANCE_CHAR (string, slen, sindex);
	  break;
	}
    }
  return (0);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\subst.c:594
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\subst.c:646
parsing error 
{
  if (source)
    {
      int srclen, n;

      srclen = STRLEN (source);
      if (srclen >= (int)(*size - *indx))
	{
	  n = srclen + *indx;
	  n = (n + DEFAULT_ARRAY_SIZE) - (n % DEFAULT_ARRAY_SIZE);
	  target = (char *)xrealloc (target, (*size = n));
	}

      FASTCOPY (source, target + *indx, srclen);
      *indx += srclen;
      target[*indx] = '\0';

      free (source);
    }
  return (target);
}
warning: parse error {
  if (source)
    {
      int srclen, n;

      srclen = STRLEN (source);
      if (srclen >= (int)(*size - *indx))
	{
	  n = srclen + *indx;
	  n = (n + DEFAULT_ARRAY_SIZE) - (n % DEFAULT_ARRAY_SIZE);
	  target = (char *)xrealloc (target, (*size = n));
	}

      FASTCOPY (source, target + *indx, srclen);
      *indx += srclen;
      target[*indx] = '\0';

      free (source);
    }
  return (target);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\subst.c:649
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\subst.c:698
parsing error 
{
  register int c, i;
  int found;
  size_t slen;
  char *temp;
  DECLARE_MBSTATE;

  slen = (MB_CUR_MAX > 1) ? strlen (string + *sindex) + *sindex : 0;
  i = *sindex;
  found = 0;
  while (c = string[i])
    {
      if (c == '\\')
	{
	  if (string[i + 1])
	    i++;
	  else
	    break;
	}
#if defined (ARRAY_VARS)
      else if ((flags & SX_VARNAME) && c == '[')
	{
	  int ni;
	  /* If this is an array subscript, skip over it and continue. */
	  ni = skipsubscript (string, i, 0);
	  if (string[ni] == ']')
	    i = ni;
	}
#endif
      else if (MEMBER (c, charlist))
	{
	  found = 1;
	  break;
	}

      ADVANCE_CHAR (string, slen, i);
    }

  /* If we had to have a matching delimiter and didn't find one, return an
     error and let the caller deal with it. */
  if ((flags & SX_REQMATCH) && found == 0)
    {
      *sindex = i;
      return (&extract_string_error);
    }
  
  temp = (flags & SX_NOALLOC) ? (char *)NULL : substring (string, *sindex, i);
  *sindex = i;
  
  return (temp);
}
warning: parse error {
  register int c, i;
  int found;
  size_t slen;
  char *temp;
  DECLARE_MBSTATE;

  slen = (MB_CUR_MAX > 1) ? strlen (string + *sindex) + *sindex : 0;
  i = *sindex;
  found = 0;
  while (c = string[i])
    {
      if (c == '\\')
	{
	  if (string[i + 1])
	    i++;
	  else
	    break;
	}
#if defined (ARRAY_VARS)
      else if ((flags & SX_VARNAME) && c == '[')
	{
	  int ni;
	  /* If this is an array subscript, skip over it and continue. */
	  ni = skipsubscript (string, i, 0);
	  if (string[ni] == ']')
	    i = ni;
	}
#endif
      else if (MEMBER (c, charlist))
	{
	  found = 1;
	  break;
	}

      ADVANCE_CHAR (string, slen, i);
    }

  /* If we had to have a matching delimiter and didn't find one, return an
     error and let the caller deal with it. */
  if ((flags & SX_REQMATCH) && found == 0)
    {
      *sindex = i;
      return (&extract_string_error);
    }
  
  temp = (flags & SX_NOALLOC) ? (char *)NULL : substring (string, *sindex, i);
  *sindex = i;
  
  return (temp);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\subst.c:703
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\subst.c:763
parsing error 
{
  size_t slen;
  char *send;
  int j, i, t;
  unsigned char c;
  char *temp, *ret;		/* The new string we return. */
  int pass_next, backquote, si;	/* State variables for the machine. */
  int dquote;
  DECLARE_MBSTATE;

  slen = strlen (string + *sindex) + *sindex;
  send = string + slen;

  pass_next = backquote = dquote = 0;
  temp = (char *)xmalloc (1 + slen - *sindex);

  j = 0;
  i = *sindex;
  while (c = string[i])
    {
      /* Process a character that was quoted by a backslash. */
      if (pass_next)
	{
	  /* XXX - take another look at this in light of Interp 221 */
	  /* Posix.2 sez:

	     ``The backslash shall retain its special meaning as an escape
	     character only when followed by one of the characters:
		$	`	"	\	<newline>''.

	     If STRIPDQ is zero, we handle the double quotes here and let
	     expand_word_internal handle the rest.  If STRIPDQ is non-zero,
	     we have already been through one round of backslash stripping,
	     and want to strip these backslashes only if DQUOTE is non-zero,
	     indicating that we are inside an embedded double-quoted string. */

	     /* If we are in an embedded quoted string, then don't strip
		backslashes before characters for which the backslash
		retains its special meaning, but remove backslashes in
		front of other characters.  If we are not in an
		embedded quoted string, don't strip backslashes at all.
		This mess is necessary because the string was already
		surrounded by double quotes (and sh has some really weird
		quoting rules).
		The returned string will be run through expansion as if
		it were double-quoted. */
	  if ((stripdq == 0 && c != '"') ||
	      (stripdq && ((dquote && (sh_syntaxtab[c] & CBSDQUOTE)) || dquote == 0)))
	    temp[j++] = '\\';
	  pass_next = 0;

add_one_character:
	  COPY_CHAR_I (temp, j, string, send, i);
	  continue;
	}

      /* A backslash protects the next character.  The code just above
	 handles preserving the backslash in front of any character but
	 a double quote. */
      if (c == '\\')
	{
	  pass_next++;
	  i++;
	  continue;
	}

      /* Inside backquotes, ``the portion of the quoted string from the
	 initial backquote and the characters up to the next backquote
	 that is not preceded by a backslash, having escape characters
	 removed, defines that command''. */
      if (backquote)
	{
	  if (c == '`')
	    backquote = 0;
	  temp[j++] = c;
	  i++;
	  continue;
	}

      if (c == '`')
	{
	  temp[j++] = c;
	  backquote++;
	  i++;
	  continue;
	}

      /* Pass everything between `$(' and the matching `)' or a quoted
	 ${ ... } pair through according to the Posix.2 specification. */
      if (c == '$' && ((string[i + 1] == LPAREN) || (string[i + 1] == LBRACE)))
	{
	  int free_ret = 1;

	  si = i + 2;
	  if (string[i + 1] == LPAREN)
	    ret = extract_command_subst (string, &si, 0);
	  else
	    ret = extract_dollar_brace_string (string, &si, Q_DOUBLE_QUOTES, 0);

	  temp[j++] = '$';
	  temp[j++] = string[i + 1];

	  /* Just paranoia; ret will not be 0 unless no_longjmp_on_fatal_error
	     is set. */
	  if (ret == 0 && no_longjmp_on_fatal_error)
	    {
	      free_ret = 0;
	      ret = string + i + 2;
	    }

	  for (t = 0; ret[t]; t++, j++)
	    temp[j] = ret[t];
	  temp[j] = string[si];

	  if (string[si])
	    {
	      j++;
	      i = si + 1;
	    }
	  else
	    i = si;

	  if (free_ret)
	    free (ret);
	  continue;
	}

      /* Add any character but a double quote to the quoted string we're
	 accumulating. */
      if (c != '"')
	goto add_one_character;

      /* c == '"' */
      if (stripdq)
	{
	  dquote ^= 1;
	  i++;
	  continue;
	}

      break;
    }
  temp[j] = '\0';

  /* Point to after the closing quote. */
  if (c)
    i++;
  *sindex = i;

  return (temp);
}
warning: parse error {
  size_t slen;
  char *send;
  int j, i, t;
  unsigned char c;
  char *temp, *ret;		/* The new string we return. */
  int pass_next, backquote, si;	/* State variables for the machine. */
  int dquote;
  DECLARE_MBSTATE;

  slen = strlen (string + *sindex) + *sindex;
  send = string + slen;

  pass_next = backquote = dquote = 0;
  temp = (char *)xmalloc (1 + slen - *sindex);

  j = 0;
  i = *sindex;
  while (c = string[i])
    {
      /* Process a character that was quoted by a backslash. */
      if (pass_next)
	{
	  /* XXX - take another look at this in light of Interp 221 */
	  /* Posix.2 sez:

	     ``The backslash shall retain its special meaning as an escape
	     character only when followed by one of the characters:
		$	`	"	\	<newline>''.

	     If STRIPDQ is zero, we handle the double quotes here and let
	     expand_word_internal handle the rest.  If STRIPDQ is non-zero,
	     we have already been through one round of backslash stripping,
	     and want to strip these backslashes only if DQUOTE is non-zero,
	     indicating that we are inside an embedded double-quoted string. */

	     /* If we are in an embedded quoted string, then don't strip
		backslashes before characters for which the backslash
		retains its special meaning, but remove backslashes in
		front of other characters.  If we are not in an
		embedded quoted string, don't strip backslashes at all.
		This mess is necessary because the string was already
		surrounded by double quotes (and sh has some really weird
		quoting rules).
		The returned string will be run through expansion as if
		it were double-quoted. */
	  if ((stripdq == 0 && c != '"') ||
	      (stripdq && ((dquote && (sh_syntaxtab[c] & CBSDQUOTE)) || dquote == 0)))
	    temp[j++] = '\\';
	  pass_next = 0;

add_one_character:
	  COPY_CHAR_I (temp, j, string, send, i);
	  continue;
	}

      /* A backslash protects the next character.  The code just above
	 handles preserving the backslash in front of any character but
	 a double quote. */
      if (c == '\\')
	{
	  pass_next++;
	  i++;
	  continue;
	}

      /* Inside backquotes, ``the portion of the quoted string from the
	 initial backquote and the characters up to the next backquote
	 that is not preceded by a backslash, having escape characters
	 removed, defines that command''. */
      if (backquote)
	{
	  if (c == '`')
	    backquote = 0;
	  temp[j++] = c;
	  i++;
	  continue;
	}

      if (c == '`')
	{
	  temp[j++] = c;
	  backquote++;
	  i++;
	  continue;
	}

      /* Pass everything between `$(' and the matching `)' or a quoted
	 ${ ... } pair through according to the Posix.2 specification. */
      if (c == '$' && ((string[i + 1] == LPAREN) || (string[i + 1] == LBRACE)))
	{
	  int free_ret = 1;

	  si = i + 2;
	  if (string[i + 1] == LPAREN)
	    ret = extract_command_subst (string, &si, 0);
	  else
	    ret = extract_dollar_brace_string (string, &si, Q_DOUBLE_QUOTES, 0);

	  temp[j++] = '$';
	  temp[j++] = string[i + 1];

	  /* Just paranoia; ret will not be 0 unless no_longjmp_on_fatal_error
	     is set. */
	  if (ret == 0 && no_longjmp_on_fatal_error)
	    {
	      free_ret = 0;
	      ret = string + i + 2;
	    }

	  for (t = 0; ret[t]; t++, j++)
	    temp[j] = ret[t];
	  temp[j] = string[si];

	  if (string[si])
	    {
	      j++;
	      i = si + 1;
	    }
	  else
	    i = si;

	  if (free_ret)
	    free (ret);
	  continue;
	}

      /* Add any character but a double quote to the quoted string we're
	 accumulating. */
      if (c != '"')
	goto add_one_character;

      /* c == '"' */
      if (stripdq)
	{
	  dquote ^= 1;
	  i++;
	  continue;
	}

      break;
    }
  temp[j] = '\0';

  /* Point to after the closing quote. */
  if (c)
    i++;
  *sindex = i;

  return (temp);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\subst.c:766
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\subst.c:920
parsing error 
{
  int c, i;
  char *ret;
  int pass_next, backquote, si;
  DECLARE_MBSTATE;

  pass_next = backquote = 0;
  i = sind;
  while (c = string[i])
    {
      if (pass_next)
	{
	  pass_next = 0;
	  ADVANCE_CHAR (string, slen, i);
	  continue;
	}
      else if (c == '\\')
	{
	  pass_next++;
	  i++;
	  continue;
	}
      else if (backquote)
	{
	  if (c == '`')
	    backquote = 0;
	  ADVANCE_CHAR (string, slen, i);
	  continue;
	}
      else if (c == '`')
	{
	  backquote++;
	  i++;
	  continue;
	}
      else if (c == '$' && ((string[i + 1] == LPAREN) || (string[i + 1] == LBRACE)))
	{
	  si = i + 2;
	  if (string[i + 1] == LPAREN)
	    ret = extract_command_subst (string, &si, SX_NOALLOC);
	  else
	    ret = extract_dollar_brace_string (string, &si, Q_DOUBLE_QUOTES, SX_NOALLOC);

	  i = si + 1;
	  continue;
	}
      else if (c != '"')
	{
	  ADVANCE_CHAR (string, slen, i);
	  continue;
	}
      else
	break;
    }

  if (c)
    i++;

  return (i);
}
warning: parse error {
  int c, i;
  char *ret;
  int pass_next, backquote, si;
  DECLARE_MBSTATE;

  pass_next = backquote = 0;
  i = sind;
  while (c = string[i])
    {
      if (pass_next)
	{
	  pass_next = 0;
	  ADVANCE_CHAR (string, slen, i);
	  continue;
	}
      else if (c == '\\')
	{
	  pass_next++;
	  i++;
	  continue;
	}
      else if (backquote)
	{
	  if (c == '`')
	    backquote = 0;
	  ADVANCE_CHAR (string, slen, i);
	  continue;
	}
      else if (c == '`')
	{
	  backquote++;
	  i++;
	  continue;
	}
      else if (c == '$' && ((string[i + 1] == LPAREN) || (string[i + 1] == LBRACE)))
	{
	  si = i + 2;
	  if (string[i + 1] == LPAREN)
	    ret = extract_command_subst (string, &si, SX_NOALLOC);
	  else
	    ret = extract_dollar_brace_string (string, &si, Q_DOUBLE_QUOTES, SX_NOALLOC);

	  i = si + 1;
	  continue;
	}
      else if (c != '"')
	{
	  ADVANCE_CHAR (string, slen, i);
	  continue;
	}
      else
	break;
    }

  if (c)
    i++;

  return (i);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\subst.c:924
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\subst.c:990
parsing error 
{
  register int i;
  size_t slen;
  char *t;
  DECLARE_MBSTATE;

  /* Don't need slen for ADVANCE_CHAR unless multibyte chars possible. */
  slen = (MB_CUR_MAX > 1) ? strlen (string + *sindex) + *sindex : 0;
  i = *sindex;
  while (string[i] && string[i] != '\'')
    ADVANCE_CHAR (string, slen, i);

  t = substring (string, *sindex, i);

  if (string[i])
    i++;
  *sindex = i;

  return (t);
}
warning: parse error {
  register int i;
  size_t slen;
  char *t;
  DECLARE_MBSTATE;

  /* Don't need slen for ADVANCE_CHAR unless multibyte chars possible. */
  slen = (MB_CUR_MAX > 1) ? strlen (string + *sindex) + *sindex : 0;
  i = *sindex;
  while (string[i] && string[i] != '\'')
    ADVANCE_CHAR (string, slen, i);

  t = substring (string, *sindex, i);

  if (string[i])
    i++;
  *sindex = i;

  return (t);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\subst.c:993
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\subst.c:1,016
parsing error 
{
  register int c;
  DECLARE_MBSTATE;

  c = sind;
  while (string[c] && string[c] != '\'')
    ADVANCE_CHAR (string, slen, c);

  if (string[c])
    c++;
  return c;
}
warning: parse error {
  register int c;
  DECLARE_MBSTATE;

  c = sind;
  while (string[c] && string[c] != '\'')
    ADVANCE_CHAR (string, slen, c);

  if (string[c])
    c++;
  return c;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\subst.c:1,019
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\subst.c:1,035
parsing error 
{
  register int i;
#if defined (HANDLE_MULTIBYTE)
  size_t clen;
  wchar_t *wcharlist;
#endif
  int c;
  char *temp;
  DECLARE_MBSTATE;

  if (charlist[0] == '\'' && charlist[1] == '\0')
    {
      temp = string_extract_single_quoted (string, sindex);
      --*sindex;	/* leave *sindex at separator character */
      return temp;
    }

  i = *sindex;
#if 0
  /* See how the MBLEN and ADVANCE_CHAR macros work to understand why we need
     this only if MB_CUR_MAX > 1. */
  slen = (MB_CUR_MAX > 1) ? strlen (string + *sindex) + *sindex : 1;
#endif
#if defined (HANDLE_MULTIBYTE)
  clen = strlen (charlist);
  wcharlist = 0;
#endif
  while (c = string[i])
    {
#if defined (HANDLE_MULTIBYTE)
      size_t mblength;
#endif
      if ((flags & SX_NOCTLESC) == 0 && c == CTLESC)
	{
	  i += 2;
	  continue;
	}
      /* Even if flags contains SX_NOCTLESC, we let CTLESC quoting CTLNUL
	 through, to protect the CTLNULs from later calls to
	 remove_quoted_nulls. */
      else if ((flags & SX_NOESCCTLNUL) == 0 && c == CTLESC && string[i+1] == CTLNUL)
	{
	  i += 2;
	  continue;
	}

#if defined (HANDLE_MULTIBYTE)
      mblength = MBLEN (string + i, slen - i);
      if (mblength > 1)
	{
	  wchar_t wc;
	  mblength = mbtowc (&wc, string + i, slen - i);
	  if (MB_INVALIDCH (mblength))
	    {
	      if (MEMBER (c, charlist))
		break;
	    }
	  else
	    {
	      if (wcharlist == 0)
		{
		  size_t len;
		  len = mbstowcs (wcharlist, charlist, 0);
		  if (len == -1)
		    len = 0;
		  wcharlist = (wchar_t *)xmalloc (sizeof (wchar_t) * (len + 1));
		  mbstowcs (wcharlist, charlist, len + 1);
		}

	      if (wcschr (wcharlist, wc))
		break;
	    }
	}
      else		
#endif
      if (MEMBER (c, charlist))
	break;

      ADVANCE_CHAR (string, slen, i);
    }

#if defined (HANDLE_MULTIBYTE)
  FREE (wcharlist);
#endif

  temp = substring (string, *sindex, i);
  *sindex = i;

  return (temp);
}
warning: parse error {
  register int i;
#if defined (HANDLE_MULTIBYTE)
  size_t clen;
  wchar_t *wcharlist;
#endif
  int c;
  char *temp;
  DECLARE_MBSTATE;

  if (charlist[0] == '\'' && charlist[1] == '\0')
    {
      temp = string_extract_single_quoted (string, sindex);
      --*sindex;	/* leave *sindex at separator character */
      return temp;
    }

  i = *sindex;
#if 0
  /* See how the MBLEN and ADVANCE_CHAR macros work to understand why we need
     this only if MB_CUR_MAX > 1. */
  slen = (MB_CUR_MAX > 1) ? strlen (string + *sindex) + *sindex : 1;
#endif
#if defined (HANDLE_MULTIBYTE)
  clen = strlen (charlist);
  wcharlist = 0;
#endif
  while (c = string[i])
    {
#if defined (HANDLE_MULTIBYTE)
      size_t mblength;
#endif
      if ((flags & SX_NOCTLESC) == 0 && c == CTLESC)
	{
	  i += 2;
	  continue;
	}
      /* Even if flags contains SX_NOCTLESC, we let CTLESC quoting CTLNUL
	 through, to protect the CTLNULs from later calls to
	 remove_quoted_nulls. */
      else if ((flags & SX_NOESCCTLNUL) == 0 && c == CTLESC && string[i+1] == CTLNUL)
	{
	  i += 2;
	  continue;
	}

#if defined (HANDLE_MULTIBYTE)
      mblength = MBLEN (string + i, slen - i);
      if (mblength > 1)
	{
	  wchar_t wc;
	  mblength = mbtowc (&wc, string + i, slen - i);
	  if (MB_INVALIDCH (mblength))
	    {
	      if (MEMBER (c, charlist))
		break;
	    }
	  else
	    {
	      if (wcharlist == 0)
		{
		  size_t len;
		  len = mbstowcs (wcharlist, charlist, 0);
		  if (len == -1)
		    len = 0;
		  wcharlist = (wchar_t *)xmalloc (sizeof (wchar_t) * (len + 1));
		  mbstowcs (wcharlist, charlist, len + 1);
		}

	      if (wcschr (wcharlist, wc))
		break;
	    }
	}
      else		
#endif
      if (MEMBER (c, charlist))
	break;

      ADVANCE_CHAR (string, slen, i);
    }

#if defined (HANDLE_MULTIBYTE)
  FREE (wcharlist);
#endif

  temp = substring (string, *sindex, i);
  *sindex = i;

  return (temp);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\subst.c:1,041
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\subst.c:1,137
parsing error 
{
  if (string[*sindex] == LPAREN)
    return (extract_delimited_string (string, sindex, "$(", "(", ")", xflags|SX_COMMAND)); /*)*/
  else
    {
      xflags |= (no_longjmp_on_fatal_error ? SX_NOLONGJMP : 0);
      return (xparse_dolparen (string, string+*sindex, sindex, xflags));
    }
}
warning: parse error {
  if (string[*sindex] == LPAREN)
    return (extract_delimited_string (string, sindex, "$(", "(", ")", xflags|SX_COMMAND)); /*)*/
  else
    {
      xflags |= (no_longjmp_on_fatal_error ? SX_NOLONGJMP : 0);
      return (xparse_dolparen (string, string+*sindex, sindex, xflags));
    }
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\subst.c:1,141
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\subst.c:1,155
parsing error 
{
  return (extract_delimited_string (string, sindex, "$[", "[", "]", 0)); /*]*/
}
warning: parse error {
  return (extract_delimited_string (string, sindex, "$[", "[", "]", 0)); /*]*/
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\subst.c:1,158
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\subst.c:1,208
parsing error 
{
  int i, c, si;
  size_t slen;
  char *t, *result;
  int pass_character, nesting_level, in_comment;
  int len_closer, len_opener, len_alt_opener;
  DECLARE_MBSTATE;

  slen = strlen (string + *sindex) + *sindex;
  len_opener = STRLEN (opener);
  len_alt_opener = STRLEN (alt_opener);
  len_closer = STRLEN (closer);

  pass_character = in_comment = 0;

  nesting_level = 1;
  i = *sindex;

  while (nesting_level)
    {
      c = string[i];

      if (c == 0)
	break;

      if (in_comment)
	{
	  if (c == '\n')
	    in_comment = 0;
	  ADVANCE_CHAR (string, slen, i);
	  continue;
	}

      if (pass_character)	/* previous char was backslash */
	{
	  pass_character = 0;
	  ADVANCE_CHAR (string, slen, i);
	  continue;
	}

      /* Not exactly right yet; should handle shell metacharacters and
	 multibyte characters, too.  See COMMENT_BEGIN define in parse.y */
      if ((flags & SX_COMMAND) && c == '#' && (i == 0 || string[i - 1] == '\n' || shellblank (string[i - 1])))
	{
          in_comment = 1;
          ADVANCE_CHAR (string, slen, i);
          continue;
	}
        
      if (c == CTLESC || c == '\\')
	{
	  pass_character++;
	  i++;
	  continue;
	}

      /* Process a nested command substitution, but only if we're parsing an
	 arithmetic substitution. */
      if ((flags & SX_COMMAND) && string[i] == '$' && string[i+1] == LPAREN)
        {
          si = i + 2;
          t = extract_command_subst (string, &si, flags|SX_NOALLOC);
          i = si + 1;
          continue;
        }

      /* Process a nested OPENER. */
      if (STREQN (string + i, opener, len_opener))
	{
	  si = i + len_opener;
	  t = extract_delimited_string (string, &si, opener, alt_opener, closer, flags|SX_NOALLOC);
	  i = si + 1;
	  continue;
	}

      /* Process a nested ALT_OPENER */
      if (len_alt_opener && STREQN (string + i, alt_opener, len_alt_opener))
	{
	  si = i + len_alt_opener;
	  t = extract_delimited_string (string, &si, alt_opener, alt_opener, closer, flags|SX_NOALLOC);
	  i = si + 1;
	  continue;
	}

      /* If the current substring terminates the delimited string, decrement
	 the nesting level. */
      if (STREQN (string + i, closer, len_closer))
	{
	  i += len_closer - 1;	/* move to last byte of the closer */
	  nesting_level--;
	  if (nesting_level == 0)
	    break;
	}

      /* Pass old-style command substitution through verbatim. */
      if (c == '`')
	{
	  si = i + 1;
	  t = string_extract (string, &si, "`", flags|SX_NOALLOC);
	  i = si + 1;
	  continue;
	}

      /* Pass single-quoted and double-quoted strings through verbatim. */
      if (c == '\'' || c == '"')
	{
	  si = i + 1;
	  i = (c == '\'') ? skip_single_quoted (string, slen, si)
			  : skip_double_quoted (string, slen, si);
	  continue;
	}

      /* move past this character, which was not special. */
      ADVANCE_CHAR (string, slen, i);
    }

  if (c == 0 && nesting_level)
    {
      if (no_longjmp_on_fatal_error == 0)
	{
	  report_error (_("bad substitution: no closing `%s' in %s"), closer, string);
	  last_command_exit_value = EXECUTION_FAILURE;
	  exp_jump_to_top_level (DISCARD);
	}
      else
	{
	  *sindex = i;
	  return (char *)NULL;
	}
    }

  si = i - *sindex - len_closer + 1;
  if (flags & SX_NOALLOC)
    result = (char *)NULL;
  else    
    {
      result = (char *)xmalloc (1 + si);
      strncpy (result, string + *sindex, si);
      result[si] = '\0';
    }
  *sindex = i;

  return (result);
}
warning: parse error {
  int i, c, si;
  size_t slen;
  char *t, *result;
  int pass_character, nesting_level, in_comment;
  int len_closer, len_opener, len_alt_opener;
  DECLARE_MBSTATE;

  slen = strlen (string + *sindex) + *sindex;
  len_opener = STRLEN (opener);
  len_alt_opener = STRLEN (alt_opener);
  len_closer = STRLEN (closer);

  pass_character = in_comment = 0;

  nesting_level = 1;
  i = *sindex;

  while (nesting_level)
    {
      c = string[i];

      if (c == 0)
	break;

      if (in_comment)
	{
	  if (c == '\n')
	    in_comment = 0;
	  ADVANCE_CHAR (string, slen, i);
	  continue;
	}

      if (pass_character)	/* previous char was backslash */
	{
	  pass_character = 0;
	  ADVANCE_CHAR (string, slen, i);
	  continue;
	}

      /* Not exactly right yet; should handle shell metacharacters and
	 multibyte characters, too.  See COMMENT_BEGIN define in parse.y */
      if ((flags & SX_COMMAND) && c == '#' && (i == 0 || string[i - 1] == '\n' || shellblank (string[i - 1])))
	{
          in_comment = 1;
          ADVANCE_CHAR (string, slen, i);
          continue;
	}
        
      if (c == CTLESC || c == '\\')
	{
	  pass_character++;
	  i++;
	  continue;
	}

      /* Process a nested command substitution, but only if we're parsing an
	 arithmetic substitution. */
      if ((flags & SX_COMMAND) && string[i] == '$' && string[i+1] == LPAREN)
        {
          si = i + 2;
          t = extract_command_subst (string, &si, flags|SX_NOALLOC);
          i = si + 1;
          continue;
        }

      /* Process a nested OPENER. */
      if (STREQN (string + i, opener, len_opener))
	{
	  si = i + len_opener;
	  t = extract_delimited_string (string, &si, opener, alt_opener, closer, flags|SX_NOALLOC);
	  i = si + 1;
	  continue;
	}

      /* Process a nested ALT_OPENER */
      if (len_alt_opener && STREQN (string + i, alt_opener, len_alt_opener))
	{
	  si = i + len_alt_opener;
	  t = extract_delimited_string (string, &si, alt_opener, alt_opener, closer, flags|SX_NOALLOC);
	  i = si + 1;
	  continue;
	}

      /* If the current substring terminates the delimited string, decrement
	 the nesting level. */
      if (STREQN (string + i, closer, len_closer))
	{
	  i += len_closer - 1;	/* move to last byte of the closer */
	  nesting_level--;
	  if (nesting_level == 0)
	    break;
	}

      /* Pass old-style command substitution through verbatim. */
      if (c == '`')
	{
	  si = i + 1;
	  t = string_extract (string, &si, "`", flags|SX_NOALLOC);
	  i = si + 1;
	  continue;
	}

      /* Pass single-quoted and double-quoted strings through verbatim. */
      if (c == '\'' || c == '"')
	{
	  si = i + 1;
	  i = (c == '\'') ? skip_single_quoted (string, slen, si)
			  : skip_double_quoted (string, slen, si);
	  continue;
	}

      /* move past this character, which was not special. */
      ADVANCE_CHAR (string, slen, i);
    }

  if (c == 0 && nesting_level)
    {
      if (no_longjmp_on_fatal_error == 0)
	{
	  report_error (_("bad substitution: no closing `%s' in %s"), closer, string);
	  last_command_exit_value = EXECUTION_FAILURE;
	  exp_jump_to_top_level (DISCARD);
	}
      else
	{
	  *sindex = i;
	  return (char *)NULL;
	}
    }

  si = i - *sindex - len_closer + 1;
  if (flags & SX_NOALLOC)
    result = (char *)NULL;
  else    
    {
      result = (char *)xmalloc (1 + si);
      strncpy (result, string + *sindex, si);
      result[si] = '\0';
    }
  *sindex = i;

  return (result);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\subst.c:1,213
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\subst.c:1,367
parsing error 
{
  register int i, c;
  size_t slen;
  int pass_character, nesting_level, si, dolbrace_state;
  char *result, *t;
  DECLARE_MBSTATE;

  pass_character = 0;
  nesting_level = 1;
  slen = strlen (string + *sindex) + *sindex;

  /* The handling of dolbrace_state needs to agree with the code in parse.y:
     parse_matched_pair() */
  dolbrace_state = 0;
  if (quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES))
    dolbrace_state = (flags & SX_POSIXEXP) ? DOLBRACE_QUOTE : DOLBRACE_PARAM;

  i = *sindex;
  while (c = string[i])
    {
      if (pass_character)
	{
	  pass_character = 0;
	  ADVANCE_CHAR (string, slen, i);
	  continue;
	}

      /* CTLESCs and backslashes quote the next character. */
      if (c == CTLESC || c == '\\')
	{
	  pass_character++;
	  i++;
	  continue;
	}

      if (string[i] == '$' && string[i+1] == LBRACE)
	{
	  nesting_level++;
	  i += 2;
	  continue;
	}

      if (c == RBRACE)
	{
	  nesting_level--;
	  if (nesting_level == 0)
	    break;
	  i++;
	  continue;
	}

      /* Pass the contents of old-style command substitutions through
	 verbatim. */
      if (c == '`')
	{
	  si = i + 1;
	  t = string_extract (string, &si, "`", flags|SX_NOALLOC);
	  i = si + 1;
	  continue;
	}

      /* Pass the contents of new-style command substitutions and
	 arithmetic substitutions through verbatim. */
      if (string[i] == '$' && string[i+1] == LPAREN)
	{
	  si = i + 2;
	  t = extract_command_subst (string, &si, flags|SX_NOALLOC);
	  i = si + 1;
	  continue;
	}

#if 0
      /* Pass the contents of single-quoted and double-quoted strings
	 through verbatim. */
      if (c == '\'' || c == '"')
	{
	  si = i + 1;
	  i = (c == '\'') ? skip_single_quoted (string, slen, si)
			  : skip_double_quoted (string, slen, si);
	  /* skip_XXX_quoted leaves index one past close quote */
	  continue;
	}
#else	/* XXX - bash-4.2 */
      /* Pass the contents of double-quoted strings through verbatim. */
      if (c == '"')
	{
	  si = i + 1;
	  i = skip_double_quoted (string, slen, si);
	  /* skip_XXX_quoted leaves index one past close quote */
	  continue;
	}

      if (c == '\'')
	{
/*itrace("extract_dollar_brace_string: c == single quote flags = %d quoted = %d dolbrace_state = %d", flags, quoted, dolbrace_state);*/
	  if (posixly_correct && shell_compatibility_level > 41 && dolbrace_state != DOLBRACE_QUOTE && (quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)))
	    ADVANCE_CHAR (string, slen, i);
	  else
	    {
	      si = i + 1;
	      i = skip_single_quoted (string, slen, si);
	    }

          continue;
	}
#endif

      /* move past this character, which was not special. */
      ADVANCE_CHAR (string, slen, i);

      /* This logic must agree with parse.y:parse_matched_pair, since they
	 share the same defines. */
      if (dolbrace_state == DOLBRACE_PARAM && c == '%' && (i - *sindex) > 1)
	dolbrace_state = DOLBRACE_QUOTE;
      else if (dolbrace_state == DOLBRACE_PARAM && c == '#' && (i - *sindex) > 1)
        dolbrace_state = DOLBRACE_QUOTE;
      else if (dolbrace_state == DOLBRACE_PARAM && c == '/' && (i - *sindex) > 1)
        dolbrace_state = DOLBRACE_QUOTE;
      else if (dolbrace_state == DOLBRACE_PARAM && c == '^' && (i - *sindex) > 1)
        dolbrace_state = DOLBRACE_QUOTE;
      else if (dolbrace_state == DOLBRACE_PARAM && c == ',' && (i - *sindex) > 1)
        dolbrace_state = DOLBRACE_QUOTE;
      else if (dolbrace_state == DOLBRACE_PARAM && strchr ("#%^,~:-=?+/", c) != 0)
	dolbrace_state = DOLBRACE_OP;
      else if (dolbrace_state == DOLBRACE_OP && strchr ("#%^,~:-=?+/", c) == 0)
	dolbrace_state = DOLBRACE_WORD;
    }

  if (c == 0 && nesting_level)
    {
      if (no_longjmp_on_fatal_error == 0)
	{			/* { */
	  report_error (_("bad substitution: no closing `%s' in %s"), "}", string);
	  last_command_exit_value = EXECUTION_FAILURE;
	  exp_jump_to_top_level (DISCARD);
	}
      else
	{
	  *sindex = i;
	  return ((char *)NULL);
	}
    }

  result = (flags & SX_NOALLOC) ? (char *)NULL : substring (string, *sindex, i);
  *sindex = i;

  return (result);
}
warning: parse error {
  register int i, c;
  size_t slen;
  int pass_character, nesting_level, si, dolbrace_state;
  char *result, *t;
  DECLARE_MBSTATE;

  pass_character = 0;
  nesting_level = 1;
  slen = strlen (string + *sindex) + *sindex;

  /* The handling of dolbrace_state needs to agree with the code in parse.y:
     parse_matched_pair() */
  dolbrace_state = 0;
  if (quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES))
    dolbrace_state = (flags & SX_POSIXEXP) ? DOLBRACE_QUOTE : DOLBRACE_PARAM;

  i = *sindex;
  while (c = string[i])
    {
      if (pass_character)
	{
	  pass_character = 0;
	  ADVANCE_CHAR (string, slen, i);
	  continue;
	}

      /* CTLESCs and backslashes quote the next character. */
      if (c == CTLESC || c == '\\')
	{
	  pass_character++;
	  i++;
	  continue;
	}

      if (string[i] == '$' && string[i+1] == LBRACE)
	{
	  nesting_level++;
	  i += 2;
	  continue;
	}

      if (c == RBRACE)
	{
	  nesting_level--;
	  if (nesting_level == 0)
	    break;
	  i++;
	  continue;
	}

      /* Pass the contents of old-style command substitutions through
	 verbatim. */
      if (c == '`')
	{
	  si = i + 1;
	  t = string_extract (string, &si, "`", flags|SX_NOALLOC);
	  i = si + 1;
	  continue;
	}

      /* Pass the contents of new-style command substitutions and
	 arithmetic substitutions through verbatim. */
      if (string[i] == '$' && string[i+1] == LPAREN)
	{
	  si = i + 2;
	  t = extract_command_subst (string, &si, flags|SX_NOALLOC);
	  i = si + 1;
	  continue;
	}

#if 0
      /* Pass the contents of single-quoted and double-quoted strings
	 through verbatim. */
      if (c == '\'' || c == '"')
	{
	  si = i + 1;
	  i = (c == '\'') ? skip_single_quoted (string, slen, si)
			  : skip_double_quoted (string, slen, si);
	  /* skip_XXX_quoted leaves index one past close quote */
	  continue;
	}
#else	/* XXX - bash-4.2 */
      /* Pass the contents of double-quoted strings through verbatim. */
      if (c == '"')
	{
	  si = i + 1;
	  i = skip_double_quoted (string, slen, si);
	  /* skip_XXX_quoted leaves index one past close quote */
	  continue;
	}

      if (c == '\'')
	{
/*itrace("extract_dollar_brace_string: c == single quote flags = %d quoted = %d dolbrace_state = %d", flags, quoted, dolbrace_state);*/
	  if (posixly_correct && shell_compatibility_level > 41 && dolbrace_state != DOLBRACE_QUOTE && (quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)))
	    ADVANCE_CHAR (string, slen, i);
	  else
	    {
	      si = i + 1;
	      i = skip_single_quoted (string, slen, si);
	    }

          continue;
	}
#endif

      /* move past this character, which was not special. */
      ADVANCE_CHAR (string, slen, i);

      /* This logic must agree with parse.y:parse_matched_pair, since they
	 share the same defines. */
      if (dolbrace_state == DOLBRACE_PARAM && c == '%' && (i - *sindex) > 1)
	dolbrace_state = DOLBRACE_QUOTE;
      else if (dolbrace_state == DOLBRACE_PARAM && c == '#' && (i - *sindex) > 1)
        dolbrace_state = DOLBRACE_QUOTE;
      else if (dolbrace_state == DOLBRACE_PARAM && c == '/' && (i - *sindex) > 1)
        dolbrace_state = DOLBRACE_QUOTE;
      else if (dolbrace_state == DOLBRACE_PARAM && c == '^' && (i - *sindex) > 1)
        dolbrace_state = DOLBRACE_QUOTE;
      else if (dolbrace_state == DOLBRACE_PARAM && c == ',' && (i - *sindex) > 1)
        dolbrace_state = DOLBRACE_QUOTE;
      else if (dolbrace_state == DOLBRACE_PARAM && strchr ("#%^,~:-=?+/", c) != 0)
	dolbrace_state = DOLBRACE_OP;
      else if (dolbrace_state == DOLBRACE_OP && strchr ("#%^,~:-=?+/", c) == 0)
	dolbrace_state = DOLBRACE_WORD;
    }

  if (c == 0 && nesting_level)
    {
      if (no_longjmp_on_fatal_error == 0)
	{			/* { */
	  report_error (_("bad substitution: no closing `%s' in %s"), "}", string);
	  last_command_exit_value = EXECUTION_FAILURE;
	  exp_jump_to_top_level (DISCARD);
	}
      else
	{
	  *sindex = i;
	  return ((char *)NULL);
	}
    }

  result = (flags & SX_NOALLOC) ? (char *)NULL : substring (string, *sindex, i);
  *sindex = i;

  return (result);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\subst.c:1,370
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\subst.c:1,522
parsing error 
{
  register size_t slen;
  register int i, j, prev_i;
  DECLARE_MBSTATE;

  slen = strlen (string);
  i = j = 0;

  /* Loop copying string[i] to string[j], i >= j. */
  while (i < slen)
    {
      if (string[i] == '\\' && (string[i + 1] == '`' || string[i + 1] == '\\' ||
			      string[i + 1] == '$'))
	i++;
      prev_i = i;
      ADVANCE_CHAR (string, slen, i);
      if (j < prev_i)
	do string[j++] = string[prev_i++]; while (prev_i < i);
      else
	j = i;
    }
  string[j] = '\0';

  return (string);
}
warning: parse error {
  register size_t slen;
  register int i, j, prev_i;
  DECLARE_MBSTATE;

  slen = strlen (string);
  i = j = 0;

  /* Loop copying string[i] to string[j], i >= j. */
  while (i < slen)
    {
      if (string[i] == '\\' && (string[i + 1] == '`' || string[i + 1] == '\\' ||
			      string[i + 1] == '$'))
	i++;
      prev_i = i;
      ADVANCE_CHAR (string, slen, i);
      if (j < prev_i)
	do string[j++] = string[prev_i++]; while (prev_i < i);
      else
	j = i;
    }
  string[j] = '\0';

  return (string);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\subst.c:1,524
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\subst.c:1,584
parsing error 
{
  int i, pass_next, backq, si, c, count;
  size_t slen;
  char *temp, *ss;
  DECLARE_MBSTATE;

  slen = strlen (string + start) + start;
  no_longjmp_on_fatal_error = 1;

  i = start + 1;		/* skip over leading bracket */
  count = 1;
  pass_next = backq = 0;
  ss = (char *)string;
  while (c = string[i])
    {
      if (pass_next)
	{
	  pass_next = 0;
	  if (c == 0)
	    CQ_RETURN(i);
	  ADVANCE_CHAR (string, slen, i);
	  continue;
	}
      else if (c == '\\')
	{
	  pass_next = 1;
	  i++;
	  continue;
	}
      else if (backq)
	{
	  if (c == '`')
	    backq = 0;
	  ADVANCE_CHAR (string, slen, i);
	  continue;
	}
      else if ((flags & 1) == 0 && c == '`')
	{
	  backq = 1;
	  i++;
	  continue;
	}
      else if ((flags & 1) == 0 && c == open)
	{
	  count++;
	  i++;
	  continue;
	}
      else if (c == close)
	{
	  count--;
	  if (count == 0)
	    break;
	  i++;
	  continue;
	}
      else if ((flags & 1) == 0 && (c == '\'' || c == '"'))
	{
	  i = (c == '\'') ? skip_single_quoted (ss, slen, ++i)
			  : skip_double_quoted (ss, slen, ++i);
	  /* no increment, the skip functions increment past the closing quote. */
	}
      else if ((flags&1) == 0 && c == '$' && (string[i+1] == LPAREN || string[i+1] == LBRACE))
	{
	  si = i + 2;
	  if (string[si] == '\0')
	    CQ_RETURN(si);

	  if (string[i+1] == LPAREN)
	    temp = extract_delimited_string (ss, &si, "$(", "(", ")", SX_NOALLOC|SX_COMMAND); /* ) */
	  else
	    temp = extract_dollar_brace_string (ss, &si, 0, SX_NOALLOC);
	  i = si;
	  if (string[i] == '\0')	/* don't increment i past EOS in loop */
	    break;
	  i++;
	  continue;
	}
      else
	ADVANCE_CHAR (string, slen, i);
    }

  CQ_RETURN(i);
}
warning: parse error {
  int i, pass_next, backq, si, c, count;
  size_t slen;
  char *temp, *ss;
  DECLARE_MBSTATE;

  slen = strlen (string + start) + start;
  no_longjmp_on_fatal_error = 1;

  i = start + 1;		/* skip over leading bracket */
  count = 1;
  pass_next = backq = 0;
  ss = (char *)string;
  while (c = string[i])
    {
      if (pass_next)
	{
	  pass_next = 0;
	  if (c == 0)
	    CQ_RETURN(i);
	  ADVANCE_CHAR (string, slen, i);
	  continue;
	}
      else if (c == '\\')
	{
	  pass_next = 1;
	  i++;
	  continue;
	}
      else if (backq)
	{
	  if (c == '`')
	    backq = 0;
	  ADVANCE_CHAR (string, slen, i);
	  continue;
	}
      else if ((flags & 1) == 0 && c == '`')
	{
	  backq = 1;
	  i++;
	  continue;
	}
      else if ((flags & 1) == 0 && c == open)
	{
	  count++;
	  i++;
	  continue;
	}
      else if (c == close)
	{
	  count--;
	  if (count == 0)
	    break;
	  i++;
	  continue;
	}
      else if ((flags & 1) == 0 && (c == '\'' || c == '"'))
	{
	  i = (c == '\'') ? skip_single_quoted (ss, slen, ++i)
			  : skip_double_quoted (ss, slen, ++i);
	  /* no increment, the skip functions increment past the closing quote. */
	}
      else if ((flags&1) == 0 && c == '$' && (string[i+1] == LPAREN || string[i+1] == LBRACE))
	{
	  si = i + 2;
	  if (string[si] == '\0')
	    CQ_RETURN(si);

	  if (string[i+1] == LPAREN)
	    temp = extract_delimited_string (ss, &si, "$(", "(", ")", SX_NOALLOC|SX_COMMAND); /* ) */
	  else
	    temp = extract_dollar_brace_string (ss, &si, 0, SX_NOALLOC);
	  i = si;
	  if (string[i] == '\0')	/* don't increment i past EOS in loop */
	    break;
	  i++;
	  continue;
	}
      else
	ADVANCE_CHAR (string, slen, i);
    }

  CQ_RETURN(i);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\subst.c:1,586
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\subst.c:1,688
parsing error 
{
  int i, pass_next, backq, si, c, invert, skipquote, skipcmd;
  size_t slen;
  char *temp, open[3];
  DECLARE_MBSTATE;

  slen = strlen (string + start) + start;
  if (flags & SD_NOJMP)
    no_longjmp_on_fatal_error = 1;
  invert = (flags & SD_INVERT);
  skipcmd = (flags & SD_NOSKIPCMD) == 0;

  i = start;
  pass_next = backq = 0;
  while (c = string[i])
    {
      /* If this is non-zero, we should not let quote characters be delimiters
	 and the current character is a single or double quote.  We should not
	 test whether or not it's a delimiter until after we skip single- or
	 double-quoted strings. */
      skipquote = ((flags & SD_NOQUOTEDELIM) && (c == '\'' || c =='"'));
      if (pass_next)
	{
	  pass_next = 0;
	  if (c == 0)
	    CQ_RETURN(i);
	  ADVANCE_CHAR (string, slen, i);
	  continue;
	}
      else if (c == '\\')
	{
	  pass_next = 1;
	  i++;
	  continue;
	}
      else if (backq)
	{
	  if (c == '`')
	    backq = 0;
	  ADVANCE_CHAR (string, slen, i);
	  continue;
	}
      else if (c == '`')
	{
	  backq = 1;
	  i++;
	  continue;
	}
      else if (skipquote == 0 && invert == 0 && member (c, delims))
	break;
      else if (c == '\'' || c == '"')
	{
	  i = (c == '\'') ? skip_single_quoted (string, slen, ++i)
			  : skip_double_quoted (string, slen, ++i);
	  /* no increment, the skip functions increment past the closing quote. */
	}
      else if (c == '$' && ((skipcmd && string[i+1] == LPAREN) || string[i+1] == LBRACE))
	{
	  si = i + 2;
	  if (string[si] == '\0')
	    CQ_RETURN(si);

	  if (string[i+1] == LPAREN)
	    temp = extract_delimited_string (string, &si, "$(", "(", ")", SX_NOALLOC|SX_COMMAND); /* ) */
	  else
	    temp = extract_dollar_brace_string (string, &si, 0, SX_NOALLOC);
	  i = si;
	  if (string[i] == '\0')	/* don't increment i past EOS in loop */
	    break;
	  i++;
	  continue;
	}
#if defined (PROCESS_SUBSTITUTION)
      else if (skipcmd && (c == '<' || c == '>') && string[i+1] == LPAREN)
	{
	  si = i + 2;
	  if (string[si] == '\0')
	    CQ_RETURN(si);
	  temp = extract_process_subst (string, (c == '<') ? "<(" : ">(", &si);
	  i = si;
	  if (string[i] == '\0')
	    break;
	  i++;
	  continue;
	}
#endif /* PROCESS_SUBSTITUTION */
#if defined (EXTENDED_GLOB)
      else if ((flags & SD_EXTGLOB) && extended_glob && string[i+1] == LPAREN && member (c, "?*+!@"))
	{
	  si = i + 2;
	  if (string[si] == '\0')
	    CQ_RETURN(si);

	  open[0] = c;
	  open[1] = LPAREN;
	  open[2] = '\0';
	  temp = extract_delimited_string (string, &si, open, "(", ")", SX_NOALLOC); /* ) */

	  i = si;
	  if (string[i] == '\0')	/* don't increment i past EOS in loop */
	    break;
	  i++;
	  continue;
	}
#endif
      else if ((skipquote || invert) && (member (c, delims) == 0))
	break;
      else
	ADVANCE_CHAR (string, slen, i);
    }

  CQ_RETURN(i);
}
warning: parse error {
  int i, pass_next, backq, si, c, invert, skipquote, skipcmd;
  size_t slen;
  char *temp, open[3];
  DECLARE_MBSTATE;

  slen = strlen (string + start) + start;
  if (flags & SD_NOJMP)
    no_longjmp_on_fatal_error = 1;
  invert = (flags & SD_INVERT);
  skipcmd = (flags & SD_NOSKIPCMD) == 0;

  i = start;
  pass_next = backq = 0;
  while (c = string[i])
    {
      /* If this is non-zero, we should not let quote characters be delimiters
	 and the current character is a single or double quote.  We should not
	 test whether or not it's a delimiter until after we skip single- or
	 double-quoted strings. */
      skipquote = ((flags & SD_NOQUOTEDELIM) && (c == '\'' || c =='"'));
      if (pass_next)
	{
	  pass_next = 0;
	  if (c == 0)
	    CQ_RETURN(i);
	  ADVANCE_CHAR (string, slen, i);
	  continue;
	}
      else if (c == '\\')
	{
	  pass_next = 1;
	  i++;
	  continue;
	}
      else if (backq)
	{
	  if (c == '`')
	    backq = 0;
	  ADVANCE_CHAR (string, slen, i);
	  continue;
	}
      else if (c == '`')
	{
	  backq = 1;
	  i++;
	  continue;
	}
      else if (skipquote == 0 && invert == 0 && member (c, delims))
	break;
      else if (c == '\'' || c == '"')
	{
	  i = (c == '\'') ? skip_single_quoted (string, slen, ++i)
			  : skip_double_quoted (string, slen, ++i);
	  /* no increment, the skip functions increment past the closing quote. */
	}
      else if (c == '$' && ((skipcmd && string[i+1] == LPAREN) || string[i+1] == LBRACE))
	{
	  si = i + 2;
	  if (string[si] == '\0')
	    CQ_RETURN(si);

	  if (string[i+1] == LPAREN)
	    temp = extract_delimited_string (string, &si, "$(", "(", ")", SX_NOALLOC|SX_COMMAND); /* ) */
	  else
	    temp = extract_dollar_brace_string (string, &si, 0, SX_NOALLOC);
	  i = si;
	  if (string[i] == '\0')	/* don't increment i past EOS in loop */
	    break;
	  i++;
	  continue;
	}
#if defined (PROCESS_SUBSTITUTION)
      else if (skipcmd && (c == '<' || c == '>') && string[i+1] == LPAREN)
	{
	  si = i + 2;
	  if (string[si] == '\0')
	    CQ_RETURN(si);
	  temp = extract_process_subst (string, (c == '<') ? "<(" : ">(", &si);
	  i = si;
	  if (string[i] == '\0')
	    break;
	  i++;
	  continue;
	}
#endif /* PROCESS_SUBSTITUTION */
#if defined (EXTENDED_GLOB)
      else if ((flags & SD_EXTGLOB) && extended_glob && string[i+1] == LPAREN && member (c, "?*+!@"))
	{
	  si = i + 2;
	  if (string[si] == '\0')
	    CQ_RETURN(si);

	  open[0] = c;
	  open[1] = LPAREN;
	  open[2] = '\0';
	  temp = extract_delimited_string (string, &si, open, "(", ")", SX_NOALLOC); /* ) */

	  i = si;
	  if (string[i] == '\0')	/* don't increment i past EOS in loop */
	    break;
	  i++;
	  continue;
	}
#endif
      else if ((skipquote || invert) && (member (c, delims) == 0))
	break;
      else
	ADVANCE_CHAR (string, slen, i);
    }

  CQ_RETURN(i);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\subst.c:1,693
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\subst.c:2,101
parsing error 
{
  register WORD_LIST *t;
  char *result, *r;
  int word_len, sep_len, result_size;

  if (list == 0)
    return ((char *)NULL);

  /* Short-circuit quickly if we don't need to separate anything. */
  if (list->next == 0)
    return (savestring (list->word->word));

  /* This is nearly always called with either sep[0] == 0 or sep[1] == 0. */
  sep_len = STRLEN (sep);
  result_size = 0;

  for (t = list; t; t = t->next)
    {
      if (t != list)
	result_size += sep_len;
      result_size += strlen (t->word->word);
    }

  r = result = (char *)xmalloc (result_size + 1);

  for (t = list; t; t = t->next)
    {
      if (t != list && sep_len)
	{
	  if (sep_len > 1)
	    {
	      FASTCOPY (sep, r, sep_len);
	      r += sep_len;
	    }
	  else
	    *r++ = sep[0];
	}

      word_len = strlen (t->word->word);
      FASTCOPY (t->word->word, r, word_len);
      r += word_len;
    }

  *r = '\0';
  return (result);
}
warning: parse error {
  register WORD_LIST *t;
  char *result, *r;
  int word_len, sep_len, result_size;

  if (list == 0)
    return ((char *)NULL);

  /* Short-circuit quickly if we don't need to separate anything. */
  if (list->next == 0)
    return (savestring (list->word->word));

  /* This is nearly always called with either sep[0] == 0 or sep[1] == 0. */
  sep_len = STRLEN (sep);
  result_size = 0;

  for (t = list; t; t = t->next)
    {
      if (t != list)
	result_size += sep_len;
      result_size += strlen (t->word->word);
    }

  r = result = (char *)xmalloc (result_size + 1);

  for (t = list; t; t = t->next)
    {
      if (t != list && sep_len)
	{
	  if (sep_len > 1)
	    {
	      FASTCOPY (sep, r, sep_len);
	      r += sep_len;
	    }
	  else
	    *r++ = sep[0];
	}

      word_len = strlen (t->word->word);
      FASTCOPY (t->word->word, r, word_len);
      r += word_len;
    }

  *r = '\0';
  return (result);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\subst.c:2,104
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\subst.c:2,154
parsing error 
{
  return (string_list_internal (list, " "));
}
warning: parse error {
  return (string_list_internal (list, " "));
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\subst.c:2,156
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\subst.c:2,165
parsing error 
{
  char *ret;
  int len;

  ret = xmalloc (MB_LEN_MAX + 1);
#if defined (HANDLE_MULTIBYTE)
  if (ifs_firstc_len == 1)
    {
      ret[0] = ifs_firstc[0];
      ret[1] = '\0';
      len = ret[0] ? 1 : 0;
    }
  else
    {
      memcpy (ret, ifs_firstc, ifs_firstc_len);
      ret[len = ifs_firstc_len] = '\0';
    }
#else
  ret[0] = ifs_firstc;
  ret[1] = '\0';
  len = ret[0] ? 0 : 1;
#endif

  if (lenp)
    *lenp = len;

  return ret;
}
warning: parse error {
  char *ret;
  int len;

  ret = xmalloc (MB_LEN_MAX + 1);
#if defined (HANDLE_MULTIBYTE)
  if (ifs_firstc_len == 1)
    {
      ret[0] = ifs_firstc[0];
      ret[1] = '\0';
      len = ret[0] ? 1 : 0;
    }
  else
    {
      memcpy (ret, ifs_firstc, ifs_firstc_len);
      ret[len = ifs_firstc_len] = '\0';
    }
#else
  ret[0] = ifs_firstc;
  ret[1] = '\0';
  len = ret[0] ? 0 : 1;
#endif

  if (lenp)
    *lenp = len;

  return ret;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\subst.c:2,167
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\subst.c:2,202
parsing error 
{
  char *ret;
#if defined (HANDLE_MULTIBYTE)
#  if defined (__GNUC__)
  char sep[MB_CUR_MAX + 1];
#  else
  char *sep = 0;
#  endif
#else
  char sep[2];
#endif

#if defined (HANDLE_MULTIBYTE)
#  if !defined (__GNUC__)
  sep = (char *)xmalloc (MB_CUR_MAX + 1);
#  endif /* !__GNUC__ */
  if (ifs_firstc_len == 1)
    {
      sep[0] = ifs_firstc[0];
      sep[1] = '\0';
    }
  else
    {
      memcpy (sep, ifs_firstc, ifs_firstc_len);
      sep[ifs_firstc_len] = '\0';
    }
#else
  sep[0] = ifs_firstc;
  sep[1] = '\0';
#endif

  ret = string_list_internal (list, sep);
#if defined (HANDLE_MULTIBYTE) && !defined (__GNUC__)
  free (sep);
#endif
  return ret;
}
warning: parse error {
  char *ret;
#if defined (HANDLE_MULTIBYTE)
#  if defined (__GNUC__)
  char sep[MB_CUR_MAX + 1];
#  else
  char *sep = 0;
#  endif
#else
  char sep[2];
#endif

#if defined (HANDLE_MULTIBYTE)
#  if !defined (__GNUC__)
  sep = (char *)xmalloc (MB_CUR_MAX + 1);
#  endif /* !__GNUC__ */
  if (ifs_firstc_len == 1)
    {
      sep[0] = ifs_firstc[0];
      sep[1] = '\0';
    }
  else
    {
      memcpy (sep, ifs_firstc, ifs_firstc_len);
      sep[ifs_firstc_len] = '\0';
    }
#else
  sep[0] = ifs_firstc;
  sep[1] = '\0';
#endif

  ret = string_list_internal (list, sep);
#if defined (HANDLE_MULTIBYTE) && !defined (__GNUC__)
  free (sep);
#endif
  return ret;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\subst.c:2,204
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\subst.c:2,252
parsing error 
{
  char *ifs, *ret;
#if defined (HANDLE_MULTIBYTE)
#  if defined (__GNUC__)
  char sep[MB_CUR_MAX + 1];
#  else
  char *sep = 0;
#  endif /* !__GNUC__ */
#else
  char sep[2];
#endif
  WORD_LIST *tlist;

  /* XXX this could just be ifs = ifs_value; */
  ifs = ifs_var ? value_cell (ifs_var) : (char *)0;

#if defined (HANDLE_MULTIBYTE)
#  if !defined (__GNUC__)
  sep = (char *)xmalloc (MB_CUR_MAX + 1);
#  endif /* !__GNUC__ */
  if (ifs && *ifs)
    {
      if (ifs_firstc_len == 1)
	{
	  sep[0] = ifs_firstc[0];
	  sep[1] = '\0';
	}
      else
	{
	  memcpy (sep, ifs_firstc, ifs_firstc_len);
	  sep[ifs_firstc_len] = '\0';
	}
    }
  else
    {
      sep[0] = ' ';
      sep[1] = '\0';
    }
#else
  sep[0] = (ifs == 0 || *ifs == 0) ? ' ' : *ifs;
  sep[1] = '\0';
#endif

  /* XXX -- why call quote_list if ifs == 0?  we can get away without doing
     it now that quote_escapes quotes spaces */
  tlist = (quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES|Q_PATQUOTE))
		? quote_list (list)
		: list_quote_escapes (list);

  ret = string_list_internal (tlist, sep);
#if defined (HANDLE_MULTIBYTE) && !defined (__GNUC__)
  free (sep);
#endif
  return ret;
}
warning: parse error {
  char *ifs, *ret;
#if defined (HANDLE_MULTIBYTE)
#  if defined (__GNUC__)
  char sep[MB_CUR_MAX + 1];
#  else
  char *sep = 0;
#  endif /* !__GNUC__ */
#else
  char sep[2];
#endif
  WORD_LIST *tlist;

  /* XXX this could just be ifs = ifs_value; */
  ifs = ifs_var ? value_cell (ifs_var) : (char *)0;

#if defined (HANDLE_MULTIBYTE)
#  if !defined (__GNUC__)
  sep = (char *)xmalloc (MB_CUR_MAX + 1);
#  endif /* !__GNUC__ */
  if (ifs && *ifs)
    {
      if (ifs_firstc_len == 1)
	{
	  sep[0] = ifs_firstc[0];
	  sep[1] = '\0';
	}
      else
	{
	  memcpy (sep, ifs_firstc, ifs_firstc_len);
	  sep[ifs_firstc_len] = '\0';
	}
    }
  else
    {
      sep[0] = ' ';
      sep[1] = '\0';
    }
#else
  sep[0] = (ifs == 0 || *ifs == 0) ? ' ' : *ifs;
  sep[1] = '\0';
#endif

  /* XXX -- why call quote_list if ifs == 0?  we can get away without doing
     it now that quote_escapes quotes spaces */
  tlist = (quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES|Q_PATQUOTE))
		? quote_list (list)
		: list_quote_escapes (list);

  ret = string_list_internal (tlist, sep);
#if defined (HANDLE_MULTIBYTE) && !defined (__GNUC__)
  free (sep);
#endif
  return ret;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\subst.c:2,255
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\subst.c:2,316
parsing error 
{
  char *ret;
  WORD_LIST *tlist;

  if (pchar == '*' && (quoted & Q_DOUBLE_QUOTES))
    {
      tlist = quote_list (list);
      word_list_remove_quoted_nulls (tlist);
      ret = string_list_dollar_star (tlist);
    }
  else if (pchar == '*' && (quoted & Q_HERE_DOCUMENT))
    {
      tlist = quote_list (list);
      word_list_remove_quoted_nulls (tlist);
      ret = string_list (tlist);
    }
  else if (pchar == '*')
    {
      /* Even when unquoted, string_list_dollar_star does the right thing
	 making sure that the first character of $IFS is used as the
	 separator. */
      ret = string_list_dollar_star (list);
    }
  else if (pchar == '@' && (quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)))
    /* We use string_list_dollar_at, but only if the string is quoted, since
       that quotes the escapes if it's not, which we don't want.  We could
       use string_list (the old code did), but that doesn't do the right
       thing if the first character of $IFS is not a space.  We use
       string_list_dollar_star if the string is unquoted so we make sure that
       the elements of $@ are separated by the first character of $IFS for
       later splitting. */
    ret = string_list_dollar_at (list, quoted);
  else if (pchar == '@')
    ret = string_list_dollar_star (list);
  else
    ret = string_list ((quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)) ? quote_list (list) : list);

  return ret;
}
warning: parse error {
  char *ret;
  WORD_LIST *tlist;

  if (pchar == '*' && (quoted & Q_DOUBLE_QUOTES))
    {
      tlist = quote_list (list);
      word_list_remove_quoted_nulls (tlist);
      ret = string_list_dollar_star (tlist);
    }
  else if (pchar == '*' && (quoted & Q_HERE_DOCUMENT))
    {
      tlist = quote_list (list);
      word_list_remove_quoted_nulls (tlist);
      ret = string_list (tlist);
    }
  else if (pchar == '*')
    {
      /* Even when unquoted, string_list_dollar_star does the right thing
	 making sure that the first character of $IFS is used as the
	 separator. */
      ret = string_list_dollar_star (list);
    }
  else if (pchar == '@' && (quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)))
    /* We use string_list_dollar_at, but only if the string is quoted, since
       that quotes the escapes if it's not, which we don't want.  We could
       use string_list (the old code did), but that doesn't do the right
       thing if the first character of $IFS is not a space.  We use
       string_list_dollar_star if the string is unquoted so we make sure that
       the elements of $@ are separated by the first character of $IFS for
       later splitting. */
    ret = string_list_dollar_at (list, quoted);
  else if (pchar == '@')
    ret = string_list_dollar_star (list);
  else
    ret = string_list ((quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)) ? quote_list (list) : list);

  return ret;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\subst.c:2,320
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\subst.c:2,393
parsing error 
{
  WORD_LIST *result;
  WORD_DESC *t;
  char *current_word, *s;
  int sindex, sh_style_split, whitesep, xflags;
  size_t slen;

  if (!string || !*string)
    return ((WORD_LIST *)NULL);

  sh_style_split = separators && separators[0] == ' ' &&
				 separators[1] == '\t' &&
				 separators[2] == '\n' &&
				 separators[3] == '\0';
  for (xflags = 0, s = ifs_value; s && *s; s++)
    {
      if (*s == CTLESC) xflags |= SX_NOCTLESC;
      else if (*s == CTLNUL) xflags |= SX_NOESCCTLNUL;
    }

  slen = 0;
  /* Remove sequences of whitespace at the beginning of STRING, as
     long as those characters appear in IFS.  Do not do this if
     STRING is quoted or if there are no separator characters. */
  if (!quoted || !separators || !*separators)
    {
      for (s = string; *s && spctabnl (*s) && issep (*s); s++);

      if (!*s)
	return ((WORD_LIST *)NULL);

      string = s;
    }

  /* OK, now STRING points to a word that does not begin with white space.
     The splitting algorithm is:
	extract a word, stopping at a separator
	skip sequences of spc, tab, or nl as long as they are separators
     This obeys the field splitting rules in Posix.2. */
  slen = (MB_CUR_MAX > 1) ? strlen (string) : 1;
  for (result = (WORD_LIST *)NULL, sindex = 0; string[sindex]; )
    {
      /* Don't need string length in ADVANCE_CHAR or string_extract_verbatim
	 unless multibyte chars are possible. */
      current_word = string_extract_verbatim (string, slen, &sindex, separators, xflags);
      if (current_word == 0)
	break;

      /* If we have a quoted empty string, add a quoted null argument.  We
	 want to preserve the quoted null character iff this is a quoted
	 empty string; otherwise the quoted null characters are removed
	 below. */
      if (QUOTED_NULL (current_word))
	{
	  t = alloc_word_desc ();
	  t->word = make_quoted_char ('\0');
	  t->flags |= W_QUOTED|W_HASQUOTEDNULL;
	  result = make_word_list (t, result);
	}
      else if (current_word[0] != '\0')
	{
	  /* If we have something, then add it regardless.  However,
	     perform quoted null character removal on the current word. */
	  remove_quoted_nulls (current_word);
	  result = add_string_to_list (current_word, result);
	  result->word->flags &= ~W_HASQUOTEDNULL;	/* just to be sure */
	  if (quoted & (Q_DOUBLE_QUOTES|Q_HERE_DOCUMENT))
	    result->word->flags |= W_QUOTED;
	}

      /* If we're not doing sequences of separators in the traditional
	 Bourne shell style, then add a quoted null argument. */
      else if (!sh_style_split && !spctabnl (string[sindex]))
	{
	  t = alloc_word_desc ();
	  t->word = make_quoted_char ('\0');
	  t->flags |= W_QUOTED|W_HASQUOTEDNULL;
	  result = make_word_list (t, result);
	}

      free (current_word);

      /* Note whether or not the separator is IFS whitespace, used later. */
      whitesep = string[sindex] && spctabnl (string[sindex]);

      /* Move past the current separator character. */
      if (string[sindex])
	{
	  DECLARE_MBSTATE;
	  ADVANCE_CHAR (string, slen, sindex);
	}

      /* Now skip sequences of space, tab, or newline characters if they are
	 in the list of separators. */
      while (string[sindex] && spctabnl (string[sindex]) && issep (string[sindex]))
	sindex++;

      /* If the first separator was IFS whitespace and the current character
	 is a non-whitespace IFS character, it should be part of the current
	 field delimiter, not a separate delimiter that would result in an
	 empty field.  Look at POSIX.2, 3.6.5, (3)(b). */
      if (string[sindex] && whitesep && issep (string[sindex]) && !spctabnl (string[sindex]))
	{
	  sindex++;
	  /* An IFS character that is not IFS white space, along with any
	     adjacent IFS white space, shall delimit a field. (SUSv3) */
	  while (string[sindex] && spctabnl (string[sindex]) && isifs (string[sindex]))
	    sindex++;
	}
    }
  return (REVERSE_LIST (result, WORD_LIST *));
}
warning: parse error {
  WORD_LIST *result;
  WORD_DESC *t;
  char *current_word, *s;
  int sindex, sh_style_split, whitesep, xflags;
  size_t slen;

  if (!string || !*string)
    return ((WORD_LIST *)NULL);

  sh_style_split = separators && separators[0] == ' ' &&
				 separators[1] == '\t' &&
				 separators[2] == '\n' &&
				 separators[3] == '\0';
  for (xflags = 0, s = ifs_value; s && *s; s++)
    {
      if (*s == CTLESC) xflags |= SX_NOCTLESC;
      else if (*s == CTLNUL) xflags |= SX_NOESCCTLNUL;
    }

  slen = 0;
  /* Remove sequences of whitespace at the beginning of STRING, as
     long as those characters appear in IFS.  Do not do this if
     STRING is quoted or if there are no separator characters. */
  if (!quoted || !separators || !*separators)
    {
      for (s = string; *s && spctabnl (*s) && issep (*s); s++);

      if (!*s)
	return ((WORD_LIST *)NULL);

      string = s;
    }

  /* OK, now STRING points to a word that does not begin with white space.
     The splitting algorithm is:
	extract a word, stopping at a separator
	skip sequences of spc, tab, or nl as long as they are separators
     This obeys the field splitting rules in Posix.2. */
  slen = (MB_CUR_MAX > 1) ? strlen (string) : 1;
  for (result = (WORD_LIST *)NULL, sindex = 0; string[sindex]; )
    {
      /* Don't need string length in ADVANCE_CHAR or string_extract_verbatim
	 unless multibyte chars are possible. */
      current_word = string_extract_verbatim (string, slen, &sindex, separators, xflags);
      if (current_word == 0)
	break;

      /* If we have a quoted empty string, add a quoted null argument.  We
	 want to preserve the quoted null character iff this is a quoted
	 empty string; otherwise the quoted null characters are removed
	 below. */
      if (QUOTED_NULL (current_word))
	{
	  t = alloc_word_desc ();
	  t->word = make_quoted_char ('\0');
	  t->flags |= W_QUOTED|W_HASQUOTEDNULL;
	  result = make_word_list (t, result);
	}
      else if (current_word[0] != '\0')
	{
	  /* If we have something, then add it regardless.  However,
	     perform quoted null character removal on the current word. */
	  remove_quoted_nulls (current_word);
	  result = add_string_to_list (current_word, result);
	  result->word->flags &= ~W_HASQUOTEDNULL;	/* just to be sure */
	  if (quoted & (Q_DOUBLE_QUOTES|Q_HERE_DOCUMENT))
	    result->word->flags |= W_QUOTED;
	}

      /* If we're not doing sequences of separators in the traditional
	 Bourne shell style, then add a quoted null argument. */
      else if (!sh_style_split && !spctabnl (string[sindex]))
	{
	  t = alloc_word_desc ();
	  t->word = make_quoted_char ('\0');
	  t->flags |= W_QUOTED|W_HASQUOTEDNULL;
	  result = make_word_list (t, result);
	}

      free (current_word);

      /* Note whether or not the separator is IFS whitespace, used later. */
      whitesep = string[sindex] && spctabnl (string[sindex]);

      /* Move past the current separator character. */
      if (string[sindex])
	{
	  DECLARE_MBSTATE;
	  ADVANCE_CHAR (string, slen, sindex);
	}

      /* Now skip sequences of space, tab, or newline characters if they are
	 in the list of separators. */
      while (string[sindex] && spctabnl (string[sindex]) && issep (string[sindex]))
	sindex++;

      /* If the first separator was IFS whitespace and the current character
	 is a non-whitespace IFS character, it should be part of the current
	 field delimiter, not a separate delimiter that would result in an
	 empty field.  Look at POSIX.2, 3.6.5, (3)(b). */
      if (string[sindex] && whitesep && issep (string[sindex]) && !spctabnl (string[sindex]))
	{
	  sindex++;
	  /* An IFS character that is not IFS white space, along with any
	     adjacent IFS white space, shall delimit a field. (SUSv3) */
	  while (string[sindex] && spctabnl (string[sindex]) && isifs (string[sindex]))
	    sindex++;
	}
    }
  return (REVERSE_LIST (result, WORD_LIST *));
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\subst.c:2,396
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\subst.c:2,517
parsing error 
{
  register char *s;
  char *current_word;
  int sindex, sh_style_split, whitesep, xflags;
  size_t slen;

  if (!stringp || !*stringp || !**stringp)
    return ((char *)NULL);

  sh_style_split = separators && separators[0] == ' ' &&
				 separators[1] == '\t' &&
				 separators[2] == '\n' &&
				 separators[3] == '\0';
  for (xflags = 0, s = ifs_value; s && *s; s++)
    {
      if (*s == CTLESC) xflags |= SX_NOCTLESC;
      if (*s == CTLNUL) xflags |= SX_NOESCCTLNUL;
    }

  s = *stringp;
  slen = 0;

  /* Remove sequences of whitespace at the beginning of STRING, as
     long as those characters appear in IFS. */
  if (sh_style_split || !separators || !*separators)
    {
      for (; *s && spctabnl (*s) && isifs (*s); s++);

      /* If the string is nothing but whitespace, update it and return. */
      if (!*s)
	{
	  *stringp = s;
	  if (endptr)
	    *endptr = s;
	  return ((char *)NULL);
	}
    }

  /* OK, S points to a word that does not begin with white space.
     Now extract a word, stopping at a separator, save a pointer to
     the first character after the word, then skip sequences of spc,
     tab, or nl as long as they are separators.

     This obeys the field splitting rules in Posix.2. */
  sindex = 0;
  /* Don't need string length in ADVANCE_CHAR or string_extract_verbatim
     unless multibyte chars are possible. */
  slen = (MB_CUR_MAX > 1) ? strlen (s) : 1;
  current_word = string_extract_verbatim (s, slen, &sindex, separators, xflags);

  /* Set ENDPTR to the first character after the end of the word. */
  if (endptr)
    *endptr = s + sindex;

  /* Note whether or not the separator is IFS whitespace, used later. */
  whitesep = s[sindex] && spctabnl (s[sindex]);

  /* Move past the current separator character. */
  if (s[sindex])
    {
      DECLARE_MBSTATE;
      ADVANCE_CHAR (s, slen, sindex);
    }

  /* Now skip sequences of space, tab, or newline characters if they are
     in the list of separators. */
  while (s[sindex] && spctabnl (s[sindex]) && isifs (s[sindex]))
    sindex++;

  /* If the first separator was IFS whitespace and the current character is
     a non-whitespace IFS character, it should be part of the current field
     delimiter, not a separate delimiter that would result in an empty field.
     Look at POSIX.2, 3.6.5, (3)(b). */
  if (s[sindex] && whitesep && isifs (s[sindex]) && !spctabnl (s[sindex]))
    {
      sindex++;
      /* An IFS character that is not IFS white space, along with any adjacent
	 IFS white space, shall delimit a field. */
      while (s[sindex] && spctabnl (s[sindex]) && isifs (s[sindex]))
	sindex++;
    }

  /* Update STRING to point to the next field. */
  *stringp = s + sindex;
  return (current_word);
}
warning: parse error {
  register char *s;
  char *current_word;
  int sindex, sh_style_split, whitesep, xflags;
  size_t slen;

  if (!stringp || !*stringp || !**stringp)
    return ((char *)NULL);

  sh_style_split = separators && separators[0] == ' ' &&
				 separators[1] == '\t' &&
				 separators[2] == '\n' &&
				 separators[3] == '\0';
  for (xflags = 0, s = ifs_value; s && *s; s++)
    {
      if (*s == CTLESC) xflags |= SX_NOCTLESC;
      if (*s == CTLNUL) xflags |= SX_NOESCCTLNUL;
    }

  s = *stringp;
  slen = 0;

  /* Remove sequences of whitespace at the beginning of STRING, as
     long as those characters appear in IFS. */
  if (sh_style_split || !separators || !*separators)
    {
      for (; *s && spctabnl (*s) && isifs (*s); s++);

      /* If the string is nothing but whitespace, update it and return. */
      if (!*s)
	{
	  *stringp = s;
	  if (endptr)
	    *endptr = s;
	  return ((char *)NULL);
	}
    }

  /* OK, S points to a word that does not begin with white space.
     Now extract a word, stopping at a separator, save a pointer to
     the first character after the word, then skip sequences of spc,
     tab, or nl as long as they are separators.

     This obeys the field splitting rules in Posix.2. */
  sindex = 0;
  /* Don't need string length in ADVANCE_CHAR or string_extract_verbatim
     unless multibyte chars are possible. */
  slen = (MB_CUR_MAX > 1) ? strlen (s) : 1;
  current_word = string_extract_verbatim (s, slen, &sindex, separators, xflags);

  /* Set ENDPTR to the first character after the end of the word. */
  if (endptr)
    *endptr = s + sindex;

  /* Note whether or not the separator is IFS whitespace, used later. */
  whitesep = s[sindex] && spctabnl (s[sindex]);

  /* Move past the current separator character. */
  if (s[sindex])
    {
      DECLARE_MBSTATE;
      ADVANCE_CHAR (s, slen, sindex);
    }

  /* Now skip sequences of space, tab, or newline characters if they are
     in the list of separators. */
  while (s[sindex] && spctabnl (s[sindex]) && isifs (s[sindex]))
    sindex++;

  /* If the first separator was IFS whitespace and the current character is
     a non-whitespace IFS character, it should be part of the current field
     delimiter, not a separate delimiter that would result in an empty field.
     Look at POSIX.2, 3.6.5, (3)(b). */
  if (s[sindex] && whitesep && isifs (s[sindex]) && !spctabnl (s[sindex]))
    {
      sindex++;
      /* An IFS character that is not IFS white space, along with any adjacent
	 IFS white space, shall delimit a field. */
      while (s[sindex] && spctabnl (s[sindex]) && isifs (s[sindex]))
	sindex++;
    }

  /* Update STRING to point to the next field. */
  *stringp = s + sindex;
  return (current_word);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\subst.c:2,519
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\subst.c:2,612
parsing error 
{
  char *s;

  s = string + STRLEN (string) - 1;
  while (s > string && ((spctabnl (*s) && isifs (*s)) ||
			(saw_escape && *s == CTLESC && spctabnl (s[1]))))
    s--;
  *++s = '\0';
  return string;
}
warning: parse error {
  char *s;

  s = string + STRLEN (string) - 1;
  while (s > string && ((spctabnl (*s) && isifs (*s)) ||
			(saw_escape && *s == CTLESC && spctabnl (s[1]))))
    s--;
  *++s = '\0';
  return string;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\subst.c:2,615
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\subst.c:2,724
parsing error 
{
  int offset, appendop, assign_list, aflags, retval;
  char *name, *value, *temp;
  SHELL_VAR *entry;
#if defined (ARRAY_VARS)
  char *t;
  int ni;
#endif
  const char *string;

  if (word == 0 || word->word == 0)
    return 0;

  appendop = assign_list = aflags = 0;
  string = word->word;
  offset = assignment (string, 0);
  name = savestring (string);
  value = (char *)NULL;

  if (name[offset] == '=')
    {
      if (name[offset - 1] == '+')
	{
	  appendop = 1;
	  name[offset - 1] = '\0';
	}

      name[offset] = 0;		/* might need this set later */
      temp = name + offset + 1;

#if defined (ARRAY_VARS)
      if (expand && (word->flags & W_COMPASSIGN))
	{
	  assign_list = ni = 1;
	  value = extract_array_assignment_list (temp, &ni);
	}
      else
#endif
      if (expand && temp[0])
	value = expand_string_if_necessary (temp, 0, expand_string_assignment);
      else
	value = savestring (temp);
    }

  if (value == 0)
    {
      value = (char *)xmalloc (1);
      value[0] = '\0';
    }

  if (echo_command_at_execute)
    {
      if (appendop)
	name[offset - 1] = '+';
      xtrace_print_assignment (name, value, assign_list, 1);
      if (appendop)
	name[offset - 1] = '\0';
    }

#define ASSIGN_RETURN(r)	do { FREE (value); free (name); return (r); } while (0)

  if (appendop)
    aflags |= ASS_APPEND;

#if defined (ARRAY_VARS)
  if (t = mbschr (name, '['))	/*]*/
    {
      if (assign_list)
	{
	  report_error (_("%s: cannot assign list to array member"), name);
	  ASSIGN_RETURN (0);
	}
      entry = assign_array_element (name, value, aflags);
      if (entry == 0)
	ASSIGN_RETURN (0);
    }
  else if (assign_list)
    {
      if (word->flags & W_ASSIGNARG)
	aflags |= ASS_MKLOCAL;
      if (word->flags & W_ASSIGNASSOC)
	aflags |= ASS_MKASSOC;
      entry = do_compound_assignment (name, value, aflags);
    }
  else
#endif /* ARRAY_VARS */
  entry = bind_variable (name, value, aflags);

  stupidly_hack_special_variables (name);

#if 1
  /* Return 1 if the assignment seems to have been performed correctly. */
  if (entry == 0 || readonly_p (entry))
    retval = 0;		/* assignment failure */
  else if (noassign_p (entry))
    {
      last_command_exit_value = EXECUTION_FAILURE;
      retval = 1;	/* error status, but not assignment failure */
    }
  else
    retval = 1;

  if (entry && retval != 0 && noassign_p (entry) == 0)
    VUNSETATTR (entry, att_invisible);

  ASSIGN_RETURN (retval);
#else
  if (entry)
    VUNSETATTR (entry, att_invisible);

  ASSIGN_RETURN (entry ? ((readonly_p (entry) == 0) && noassign_p (entry) == 0) : 0);
#endif
}
warning: parse error {
  int offset, appendop, assign_list, aflags, retval;
  char *name, *value, *temp;
  SHELL_VAR *entry;
#if defined (ARRAY_VARS)
  char *t;
  int ni;
#endif
  const char *string;

  if (word == 0 || word->word == 0)
    return 0;

  appendop = assign_list = aflags = 0;
  string = word->word;
  offset = assignment (string, 0);
  name = savestring (string);
  value = (char *)NULL;

  if (name[offset] == '=')
    {
      if (name[offset - 1] == '+')
	{
	  appendop = 1;
	  name[offset - 1] = '\0';
	}

      name[offset] = 0;		/* might need this set later */
      temp = name + offset + 1;

#if defined (ARRAY_VARS)
      if (expand && (word->flags & W_COMPASSIGN))
	{
	  assign_list = ni = 1;
	  value = extract_array_assignment_list (temp, &ni);
	}
      else
#endif
      if (expand && temp[0])
	value = expand_string_if_necessary (temp, 0, expand_string_assignment);
      else
	value = savestring (temp);
    }

  if (value == 0)
    {
      value = (char *)xmalloc (1);
      value[0] = '\0';
    }

  if (echo_command_at_execute)
    {
      if (appendop)
	name[offset - 1] = '+';
      xtrace_print_assignment (name, value, assign_list, 1);
      if (appendop)
	name[offset - 1] = '\0';
    }

#define ASSIGN_RETURN(r)	do { FREE (value); free (name); return (r); } while (0)

  if (appendop)
    aflags |= ASS_APPEND;

#if defined (ARRAY_VARS)
  if (t = mbschr (name, '['))	/*]*/
    {
      if (assign_list)
	{
	  report_error (_("%s: cannot assign list to array member"), name);
	  ASSIGN_RETURN (0);
	}
      entry = assign_array_element (name, value, aflags);
      if (entry == 0)
	ASSIGN_RETURN (0);
    }
  else if (assign_list)
    {
      if (word->flags & W_ASSIGNARG)
	aflags |= ASS_MKLOCAL;
      if (word->flags & W_ASSIGNASSOC)
	aflags |= ASS_MKASSOC;
      entry = do_compound_assignment (name, value, aflags);
    }
  else
#endif /* ARRAY_VARS */
  entry = bind_variable (name, value, aflags);

  stupidly_hack_special_variables (name);

#if 1
  /* Return 1 if the assignment seems to have been performed correctly. */
  if (entry == 0 || readonly_p (entry))
    retval = 0;		/* assignment failure */
  else if (noassign_p (entry))
    {
      last_command_exit_value = EXECUTION_FAILURE;
      retval = 1;	/* error status, but not assignment failure */
    }
  else
    retval = 1;

  if (entry && retval != 0 && noassign_p (entry) == 0)
    VUNSETATTR (entry, att_invisible);

  ASSIGN_RETURN (retval);
#else
  if (entry)
    VUNSETATTR (entry, att_invisible);

  ASSIGN_RETURN (entry ? ((readonly_p (entry) == 0) && noassign_p (entry) == 0) : 0);
#endif
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\subst.c:2,726
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\subst.c:2,843
parsing error 
{
  WORD_DESC td;

  td.flags = W_ASSIGNMENT;
  td.word = string;

  return do_assignment_internal (&td, 1);
}
warning: parse error {
  WORD_DESC td;

  td.flags = W_ASSIGNMENT;
  td.word = string;

  return do_assignment_internal (&td, 1);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\subst.c:2,845
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\subst.c:2,855
parsing error 
{
  return do_assignment_internal (word, 1);
}
warning: parse error {
  return do_assignment_internal (word, 1);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\subst.c:2,858
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\subst.c:2,866
parsing error 
{
  WORD_DESC td;

  td.flags = W_ASSIGNMENT;
  td.word = string;

  return (do_assignment_internal (&td, 0));
}
warning: parse error {
  WORD_DESC td;

  td.flags = W_ASSIGNMENT;
  td.word = string;

  return (do_assignment_internal (&td, 0));
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\subst.c:2,868
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\subst.c:2,915
parsing error 
{
  char *temp;
  WORD_LIST *p;

  if (ind < 10)
    temp = dollar_vars[ind] ? savestring (dollar_vars[ind]) : (char *)NULL;
  else	/* We want something like ${11} */
    {
      ind -= 10;
      for (p = rest_of_args; p && ind--; p = p->next)
	;
      temp = p ? savestring (p->word->word) : (char *)NULL;
    }
  return (temp);
}
warning: parse error {
  char *temp;
  WORD_LIST *p;

  if (ind < 10)
    temp = dollar_vars[ind] ? savestring (dollar_vars[ind]) : (char *)NULL;
  else	/* We want something like ${11} */
    {
      ind -= 10;
      for (p = rest_of_args; p && ind--; p = p->next)
	;
      temp = p ? savestring (p->word->word) : (char *)NULL;
    }
  return (temp);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\subst.c:2,917
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\subst.c:2,937
parsing error 
{
  register WORD_LIST *list;
  char *string;

  list = list_rest_of_args ();
  string = dollar_star ? string_list_dollar_star (list) : string_list (list);
  dispose_words (list);
  return (string);
}
warning: parse error {
  register WORD_LIST *list;
  char *string;

  list = list_rest_of_args ();
  string = dollar_star ? string_list_dollar_star (list) : string_list (list);
  dispose_words (list);
  return (string);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\subst.c:2,939
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\subst.c:2,955
parsing error 
{
  WORD_LIST *save, *params, *h, *t;
  char *ret;
  int i;

  /* see if we can short-circuit.  if start == end, we want 0 parameters. */
  if (start == end)
    return ((char *)NULL);

  save = params = list_rest_of_args ();
  if (save == 0)
    return ((char *)NULL);

  if (start == 0)		/* handle ${@:0[:x]} specially */
    {
      t = make_word_list (make_word (dollar_vars[0]), params);
      save = params = t;
    }

  for (i = start ? 1 : 0; params && i < start; i++)
    params = params->next;
  if (params == 0)
    return ((char *)NULL);
  for (h = t = params; params && i < end; i++)
    {
      t = params;
      params = params->next;
    }

  t->next = (WORD_LIST *)NULL;

  ret = string_list_pos_params (string[0], h, quoted);

  if (t != params)
    t->next = params;

  dispose_words (save);
  return (ret);
}
warning: parse error {
  WORD_LIST *save, *params, *h, *t;
  char *ret;
  int i;

  /* see if we can short-circuit.  if start == end, we want 0 parameters. */
  if (start == end)
    return ((char *)NULL);

  save = params = list_rest_of_args ();
  if (save == 0)
    return ((char *)NULL);

  if (start == 0)		/* handle ${@:0[:x]} specially */
    {
      t = make_word_list (make_word (dollar_vars[0]), params);
      save = params = t;
    }

  for (i = start ? 1 : 0; params && i < start; i++)
    params = params->next;
  if (params == 0)
    return ((char *)NULL);
  for (h = t = params; params && i < end; i++)
    {
      t = params;
      params = params->next;
    }

  t->next = (WORD_LIST *)NULL;

  ret = string_list_pos_params (string[0], h, quoted);

  if (t != params)
    t->next = params;

  dispose_words (save);
  return (ret);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\subst.c:2,958
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\subst.c:3,014
parsing error 
{
  WORD_LIST *list;
  size_t slen;
  int i, saw_quote;
  char *ret;
  DECLARE_MBSTATE;

  /* Don't need string length for ADVANCE_CHAR unless multibyte chars possible. */
  slen = (MB_CUR_MAX > 1) ? strlen (string) : 0;
  i = saw_quote = 0;
  while (string[i])
    {
      if (EXP_CHAR (string[i]))
	break;
      else if (string[i] == '\'' || string[i] == '\\' || string[i] == '"')
	saw_quote = 1;
      ADVANCE_CHAR (string, slen, i);
    }

  if (string[i])
    {
      list = (*func) (string, quoted);
      if (list)
	{
	  ret = string_list (list);
	  dispose_words (list);
	}
      else
	ret = (char *)NULL;
    }
  else if (saw_quote && ((quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)) == 0))
    ret = string_quote_removal (string, quoted);
  else
    ret = savestring (string);

  return ret;
}
warning: parse error {
  WORD_LIST *list;
  size_t slen;
  int i, saw_quote;
  char *ret;
  DECLARE_MBSTATE;

  /* Don't need string length for ADVANCE_CHAR unless multibyte chars possible. */
  slen = (MB_CUR_MAX > 1) ? strlen (string) : 0;
  i = saw_quote = 0;
  while (string[i])
    {
      if (EXP_CHAR (string[i]))
	break;
      else if (string[i] == '\'' || string[i] == '\\' || string[i] == '"')
	saw_quote = 1;
      ADVANCE_CHAR (string, slen, i);
    }

  if (string[i])
    {
      list = (*func) (string, quoted);
      if (list)
	{
	  ret = string_list (list);
	  dispose_words (list);
	}
      else
	ret = (char *)NULL;
    }
  else if (saw_quote && ((quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)) == 0))
    ret = string_quote_removal (string, quoted);
  else
    ret = savestring (string);

  return ret;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\subst.c:3,018
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\subst.c:3,057
parsing error 
{
  WORD_LIST *list;
  char *ret;

  if (string == 0 || *string == '\0')
    return ((char *)NULL);

  list = (*func) (string, quoted);
  if (list)
    {
      ret = string_list (list);
      dispose_words (list);
    }
  else
    ret = (char *)NULL;

  return (ret);
}
warning: parse error {
  WORD_LIST *list;
  char *ret;

  if (string == 0 || *string == '\0')
    return ((char *)NULL);

  list = (*func) (string, quoted);
  if (list)
    {
      ret = string_list (list);
      dispose_words (list);
    }
  else
    ret = (char *)NULL;

  return (ret);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\subst.c:3,061
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\subst.c:3,081
parsing error 
{
  return (expand_string_to_string_internal (string, quoted, expand_string));
}
warning: parse error {
  return (expand_string_to_string_internal (string, quoted, expand_string));
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\subst.c:3,084
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\subst.c:3,089
parsing error 
{
  return (expand_string_to_string_internal (string, quoted, expand_string_unsplit));
}
warning: parse error {
  return (expand_string_to_string_internal (string, quoted, expand_string_unsplit));
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\subst.c:3,092
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\subst.c:3,097
parsing error 
{
  return (expand_string_to_string_internal (string, quoted, expand_string_assignment));
}
warning: parse error {
  return (expand_string_to_string_internal (string, quoted, expand_string_assignment));
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\subst.c:3,100
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\subst.c:3,105
parsing error 
{
  return (expand_string_if_necessary (string, quoted, expand_string));
}
warning: parse error {
  return (expand_string_if_necessary (string, quoted, expand_string));
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\subst.c:3,108
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\subst.c:3,184
parsing error 
{
  WORD_LIST *result;

  result = expand_word_internal (w, q, i, c, e);
  if (result == &expand_word_error || result == &expand_word_fatal)
    {
      /* By convention, each time this error is returned, w->word has
	 already been freed (it sometimes may not be in the fatal case,
	 but that doesn't result in a memory leak because we're going
	 to exit in most cases). */
      w->word = (char *)NULL;
      last_command_exit_value = EXECUTION_FAILURE;
      exp_jump_to_top_level ((result == &expand_word_error) ? DISCARD : FORCE_EOF);
      /* NOTREACHED */
    }
  else
    return (result);
}
warning: parse error {
  WORD_LIST *result;

  result = expand_word_internal (w, q, i, c, e);
  if (result == &expand_word_error || result == &expand_word_fatal)
    {
      /* By convention, each time this error is returned, w->word has
	 already been freed (it sometimes may not be in the fatal case,
	 but that doesn't result in a memory leak because we're going
	 to exit in most cases). */
      w->word = (char *)NULL;
      last_command_exit_value = EXECUTION_FAILURE;
      exp_jump_to_top_level ((result == &expand_word_error) ? DISCARD : FORCE_EOF);
      /* NOTREACHED */
    }
  else
    return (result);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\subst.c:3,187
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\subst.c:3,209
parsing error 
{
  WORD_DESC td;
  WORD_LIST *tresult;

  if (string == 0 || *string == 0)
    return ((WORD_LIST *)NULL);

  td.flags = 0;
  td.word = savestring (string);

  tresult = call_expand_word_internal (&td, quoted, 0, (int *)NULL, (int *)NULL);

  FREE (td.word);
  return (tresult);
}
warning: parse error {
  WORD_DESC td;
  WORD_LIST *tresult;

  if (string == 0 || *string == 0)
    return ((WORD_LIST *)NULL);

  td.flags = 0;
  td.word = savestring (string);

  tresult = call_expand_word_internal (&td, quoted, 0, (int *)NULL, (int *)NULL);

  FREE (td.word);
  return (tresult);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\subst.c:3,212
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\subst.c:3,234
parsing error 
{
  WORD_LIST *value;

  if (string == 0 || *string == '\0')
    return ((WORD_LIST *)NULL);

  expand_no_split_dollar_star = 1;
  value = expand_string_internal (string, quoted);
  expand_no_split_dollar_star = 0;

  if (value)
    {
      if (value->word)
	{
	  remove_quoted_nulls (value->word->word);
	  value->word->flags &= ~W_HASQUOTEDNULL;
	}
      dequote_list (value);
    }
  return (value);
}
warning: parse error {
  WORD_LIST *value;

  if (string == 0 || *string == '\0')
    return ((WORD_LIST *)NULL);

  expand_no_split_dollar_star = 1;
  value = expand_string_internal (string, quoted);
  expand_no_split_dollar_star = 0;

  if (value)
    {
      if (value->word)
	{
	  remove_quoted_nulls (value->word->word);
	  value->word->flags &= ~W_HASQUOTEDNULL;
	}
      dequote_list (value);
    }
  return (value);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\subst.c:3,237
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\subst.c:3,261
parsing error 
{
  WORD_DESC td;
  WORD_LIST *value;

  if (string == 0 || *string == '\0')
    return ((WORD_LIST *)NULL);

  expand_no_split_dollar_star = 1;

  td.flags = W_ASSIGNRHS;
  td.word = savestring (string);
  value = call_expand_word_internal (&td, quoted, 0, (int *)NULL, (int *)NULL);
  FREE (td.word);

  expand_no_split_dollar_star = 0;

  if (value)
    {
      if (value->word)
	{
	  remove_quoted_nulls (value->word->word);
	  value->word->flags &= ~W_HASQUOTEDNULL;
	}
      dequote_list (value);
    }
  return (value);
}
warning: parse error {
  WORD_DESC td;
  WORD_LIST *value;

  if (string == 0 || *string == '\0')
    return ((WORD_LIST *)NULL);

  expand_no_split_dollar_star = 1;

  td.flags = W_ASSIGNRHS;
  td.word = savestring (string);
  value = call_expand_word_internal (&td, quoted, 0, (int *)NULL, (int *)NULL);
  FREE (td.word);

  expand_no_split_dollar_star = 0;

  if (value)
    {
      if (value->word)
	{
	  remove_quoted_nulls (value->word->word);
	  value->word->flags &= ~W_HASQUOTEDNULL;
	}
      dequote_list (value);
    }
  return (value);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\subst.c:3,264
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\subst.c:3,298
parsing error 
{
  WORD_LIST *value;
  WORD_DESC td;

  if (string == 0 || *string == 0)
    return ((WORD_LIST *)NULL);

  td.flags = wflags;
  td.word = savestring (string);

  no_longjmp_on_fatal_error = 1;
  value = expand_word_internal (&td, quoted, 0, (int *)NULL, (int *)NULL);
  no_longjmp_on_fatal_error = 0;

  if (value == &expand_word_error || value == &expand_word_fatal)
    {
      value = make_word_list (make_bare_word (string), (WORD_LIST *)NULL);
      return value;
    }
  FREE (td.word);
  if (value)
    {
      if (value->word)
	{
	  remove_quoted_nulls (value->word->word);
	  value->word->flags &= ~W_HASQUOTEDNULL;
	}
      dequote_list (value);
    }
  return (value);
}
warning: parse error {
  WORD_LIST *value;
  WORD_DESC td;

  if (string == 0 || *string == 0)
    return ((WORD_LIST *)NULL);

  td.flags = wflags;
  td.word = savestring (string);

  no_longjmp_on_fatal_error = 1;
  value = expand_word_internal (&td, quoted, 0, (int *)NULL, (int *)NULL);
  no_longjmp_on_fatal_error = 0;

  if (value == &expand_word_error || value == &expand_word_fatal)
    {
      value = make_word_list (make_bare_word (string), (WORD_LIST *)NULL);
      return value;
    }
  FREE (td.word);
  if (value)
    {
      if (value->word)
	{
	  remove_quoted_nulls (value->word->word);
	  value->word->flags &= ~W_HASQUOTEDNULL;
	}
      dequote_list (value);
    }
  return (value);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\subst.c:3,302
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\subst.c:3,340
parsing error 
{
  WORD_LIST *tlist;
  WORD_LIST *tresult;

  if (string == 0 || *string == '\0')
    return ((WORD_LIST *)NULL);

  tlist = expand_string_internal (string, quoted);

  if (tlist)
    {
      tresult = word_list_split (tlist);
      dispose_words (tlist);
      return (tresult);
    }
  return ((WORD_LIST *)NULL);
}
warning: parse error {
  WORD_LIST *tlist;
  WORD_LIST *tresult;

  if (string == 0 || *string == '\0')
    return ((WORD_LIST *)NULL);

  tlist = expand_string_internal (string, quoted);

  if (tlist)
    {
      tresult = word_list_split (tlist);
      dispose_words (tlist);
      return (tresult);
    }
  return ((WORD_LIST *)NULL);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\subst.c:3,343
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\subst.c:3,364
parsing error 
{
  WORD_DESC td;
  WORD_LIST *tresult;

  if (string == 0 || *string == '\0')
    return (WORD_LIST *)NULL;

  td.flags = 0;
  td.word = string;
  tresult = call_expand_word_internal (&td, quoted, 1, dollar_at_p, has_dollar_at);
  return (tresult);
}
warning: parse error {
  WORD_DESC td;
  WORD_LIST *tresult;

  if (string == 0 || *string == '\0')
    return (WORD_LIST *)NULL;

  td.flags = 0;
  td.word = string;
  tresult = call_expand_word_internal (&td, quoted, 1, dollar_at_p, has_dollar_at);
  return (tresult);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\subst.c:3,367
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\subst.c:3,386
parsing error 
{
  WORD_LIST *result;

  if (string == 0 || *string == '\0')
    return ((WORD_LIST *)NULL);

  result = expand_string_leave_quoted (string, quoted);
  return (result ? dequote_list (result) : result);
}
warning: parse error {
  WORD_LIST *result;

  if (string == 0 || *string == '\0')
    return ((WORD_LIST *)NULL);

  result = expand_string_leave_quoted (string, quoted);
  return (result ? dequote_list (result) : result);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\subst.c:3,389
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\subst.c:3,421
parsing error 
{
  register char *s, *t;
  size_t slen;
  char *result, *send;
  int quote_spaces, skip_ctlesc, skip_ctlnul;
  DECLARE_MBSTATE; 

  slen = strlen (string);
  send = string + slen;

  quote_spaces = (ifs_value && *ifs_value == 0);

  for (skip_ctlesc = skip_ctlnul = 0, s = ifs_value; s && *s; s++)
    skip_ctlesc |= *s == CTLESC, skip_ctlnul |= *s == CTLNUL;

  t = result = (char *)xmalloc ((slen * 2) + 1);
  s = string;

  while (*s)
    {
      if ((skip_ctlesc == 0 && *s == CTLESC) || (skip_ctlnul == 0 && *s == CTLNUL) || (quote_spaces && *s == ' '))
	*t++ = CTLESC;
      COPY_CHAR_P (t, s, send);
    }
  *t = '\0';
  return (result);
}
warning: parse error {
  register char *s, *t;
  size_t slen;
  char *result, *send;
  int quote_spaces, skip_ctlesc, skip_ctlnul;
  DECLARE_MBSTATE; 

  slen = strlen (string);
  send = string + slen;

  quote_spaces = (ifs_value && *ifs_value == 0);

  for (skip_ctlesc = skip_ctlnul = 0, s = ifs_value; s && *s; s++)
    skip_ctlesc |= *s == CTLESC, skip_ctlnul |= *s == CTLNUL;

  t = result = (char *)xmalloc ((slen * 2) + 1);
  s = string;

  while (*s)
    {
      if ((skip_ctlesc == 0 && *s == CTLESC) || (skip_ctlnul == 0 && *s == CTLNUL) || (quote_spaces && *s == ' '))
	*t++ = CTLESC;
      COPY_CHAR_P (t, s, send);
    }
  *t = '\0';
  return (result);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\subst.c:3,423
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\subst.c:3,452
parsing error 
{
  register WORD_LIST *w;
  char *t;

  for (w = list; w; w = w->next)
    {
      t = w->word->word;
      w->word->word = quote_escapes (t);
      free (t);
    }
  return list;
}
warning: parse error {
  register WORD_LIST *w;
  char *t;

  for (w = list; w; w = w->next)
    {
      t = w->word->word;
      w->word->word = quote_escapes (t);
      free (t);
    }
  return list;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\subst.c:3,454
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\subst.c:3,479
parsing error 
{
  register char *s, *t, *s1;
  size_t slen;
  char *result, *send;
  int quote_spaces;
  DECLARE_MBSTATE;

  if (string == 0)
    return string;

  slen = strlen (string);
  send = string + slen;

  t = result = (char *)xmalloc (slen + 1);

  if (strchr (string, CTLESC) == 0)
    return (strcpy (result, string));

  quote_spaces = (ifs_value && *ifs_value == 0);

  s = string;
  while (*s)
    {
      if (*s == CTLESC && (s[1] == CTLESC || s[1] == CTLNUL || (quote_spaces && s[1] == ' ')))
	{
	  s++;
	  if (*s == '\0')
	    break;
	}
      COPY_CHAR_P (t, s, send);
    }
  *t = '\0';
  return result;
}
warning: parse error {
  register char *s, *t, *s1;
  size_t slen;
  char *result, *send;
  int quote_spaces;
  DECLARE_MBSTATE;

  if (string == 0)
    return string;

  slen = strlen (string);
  send = string + slen;

  t = result = (char *)xmalloc (slen + 1);

  if (strchr (string, CTLESC) == 0)
    return (strcpy (result, string));

  quote_spaces = (ifs_value && *ifs_value == 0);

  s = string;
  while (*s)
    {
      if (*s == CTLESC && (s[1] == CTLESC || s[1] == CTLNUL || (quote_spaces && s[1] == ' ')))
	{
	  s++;
	  if (*s == '\0')
	    break;
	}
      COPY_CHAR_P (t, s, send);
    }
  *t = '\0';
  return result;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\subst.c:3,481
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\subst.c:3,520
parsing error 
{
  char *temp;

  temp = (char *)xmalloc (3);
  if (c == 0)
    {
      temp[0] = CTLNUL;
      temp[1] = '\0';
    }
  else
    {
      temp[0] = CTLESC;
      temp[1] = c;
      temp[2] = '\0';
    }
  return (temp);
}
warning: parse error {
  char *temp;

  temp = (char *)xmalloc (3);
  if (c == 0)
    {
      temp[0] = CTLNUL;
      temp[1] = '\0';
    }
  else
    {
      temp[0] = CTLESC;
      temp[1] = c;
      temp[2] = '\0';
    }
  return (temp);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\subst.c:3,522
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\subst.c:3,544
parsing error 
{
  register char *t;
  size_t slen;
  char *result, *send;

  if (*string == 0)
    {
      result = (char *)xmalloc (2);
      result[0] = CTLNUL;
      result[1] = '\0';
    }
  else
    {
      DECLARE_MBSTATE;

      slen = strlen (string);
      send = string + slen;

      result = (char *)xmalloc ((slen * 2) + 1);

      for (t = result; string < send; )
	{
	  *t++ = CTLESC;
	  COPY_CHAR_P (t, string, send);
	}
      *t = '\0';
    }
  return (result);
}
warning: parse error {
  register char *t;
  size_t slen;
  char *result, *send;

  if (*string == 0)
    {
      result = (char *)xmalloc (2);
      result[0] = CTLNUL;
      result[1] = '\0';
    }
  else
    {
      DECLARE_MBSTATE;

      slen = strlen (string);
      send = string + slen;

      result = (char *)xmalloc ((slen * 2) + 1);

      for (t = result; string < send; )
	{
	  *t++ = CTLESC;
	  COPY_CHAR_P (t, string, send);
	}
      *t = '\0';
    }
  return (result);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\subst.c:3,546
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\subst.c:3,578
parsing error 
{
  register char *s, *t;
  size_t slen;
  char *result, *send;
  DECLARE_MBSTATE;

  slen = strlen (string);

  t = result = (char *)xmalloc (slen + 1);

  if (QUOTED_NULL (string))
    {
      result[0] = '\0';
      return (result);
    }

  /* If no character in the string can be quoted, don't bother examining
     each character.  Just return a copy of the string passed to us. */
  if (strchr (string, CTLESC) == NULL)
    return (strcpy (result, string));

  send = string + slen;
  s = string;
  while (*s)
    {
      if (*s == CTLESC)
	{
	  s++;
	  if (*s == '\0')
	    break;
	}
      COPY_CHAR_P (t, s, send);
    }

  *t = '\0';
  return (result);
}
warning: parse error {
  register char *s, *t;
  size_t slen;
  char *result, *send;
  DECLARE_MBSTATE;

  slen = strlen (string);

  t = result = (char *)xmalloc (slen + 1);

  if (QUOTED_NULL (string))
    {
      result[0] = '\0';
      return (result);
    }

  /* If no character in the string can be quoted, don't bother examining
     each character.  Just return a copy of the string passed to us. */
  if (strchr (string, CTLESC) == NULL)
    return (strcpy (result, string));

  send = string + slen;
  s = string;
  while (*s)
    {
      if (*s == CTLESC)
	{
	  s++;
	  if (*s == '\0')
	    break;
	}
      COPY_CHAR_P (t, s, send);
    }

  *t = '\0';
  return (result);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\subst.c:3,580
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\subst.c:3,620
parsing error 
{
  register WORD_LIST *w;
  char *t;

  for (w = list; w; w = w->next)
    {
      t = w->word->word;
      w->word->word = quote_string (t);
      if (*t == 0)
	w->word->flags |= W_HASQUOTEDNULL;	/* XXX - turn on W_HASQUOTEDNULL here? */
      w->word->flags |= W_QUOTED;
      free (t);
    }
  return list;
}
warning: parse error {
  register WORD_LIST *w;
  char *t;

  for (w = list; w; w = w->next)
    {
      t = w->word->word;
      w->word->word = quote_string (t);
      if (*t == 0)
	w->word->flags |= W_HASQUOTEDNULL;	/* XXX - turn on W_HASQUOTEDNULL here? */
      w->word->flags |= W_QUOTED;
      free (t);
    }
  return list;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\subst.c:3,622
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\subst.c:3,640
parsing error 
{
  register char *s;
  register WORD_LIST *tlist;

  for (tlist = list; tlist; tlist = tlist->next)
    {
      s = dequote_string (tlist->word->word);
      if (QUOTED_NULL (tlist->word->word))
	tlist->word->flags &= ~W_HASQUOTEDNULL;
      free (tlist->word->word);
      tlist->word->word = s;
    }
  return list;
}
warning: parse error {
  register char *s;
  register WORD_LIST *tlist;

  for (tlist = list; tlist; tlist = tlist->next)
    {
      s = dequote_string (tlist->word->word);
      if (QUOTED_NULL (tlist->word->word))
	tlist->word->flags &= ~W_HASQUOTEDNULL;
      free (tlist->word->word);
      tlist->word->word = s;
    }
  return list;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\subst.c:3,642
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\subst.c:3,660
parsing error 
{
  char *t;

  if (string)
    {
      t = dequote_escapes (string);
      strcpy (string, t);
      free (t);
    }

  return (string);
}
warning: parse error {
  char *t;

  if (string)
    {
      t = dequote_escapes (string);
      strcpy (string, t);
      free (t);
    }

  return (string);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\subst.c:3,662
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\subst.c:3,681
parsing error 
{
  register size_t slen;
  register int i, j, prev_i;
  DECLARE_MBSTATE;

  if (strchr (string, CTLNUL) == 0)		/* XXX */
    return string;				/* XXX */

  slen = strlen (string);
  i = j = 0;

  while (i < slen)
    {
      if (string[i] == CTLESC)
	{
	  /* Old code had j++, but we cannot assume that i == j at this
	     point -- what if a CTLNUL has already been removed from the
	     string?  We don't want to drop the CTLESC or recopy characters
	     that we've already copied down. */
	  i++; string[j++] = CTLESC;
	  if (i == slen)
	    break;
	}
      else if (string[i] == CTLNUL)
	i++;

      prev_i = i;
      ADVANCE_CHAR (string, slen, i);
      if (j < prev_i)
	{
	  do string[j++] = string[prev_i++]; while (prev_i < i);
	}
      else
	j = i;
    }
  string[j] = '\0';

  return (string);
}
warning: parse error {
  register size_t slen;
  register int i, j, prev_i;
  DECLARE_MBSTATE;

  if (strchr (string, CTLNUL) == 0)		/* XXX */
    return string;				/* XXX */

  slen = strlen (string);
  i = j = 0;

  while (i < slen)
    {
      if (string[i] == CTLESC)
	{
	  /* Old code had j++, but we cannot assume that i == j at this
	     point -- what if a CTLNUL has already been removed from the
	     string?  We don't want to drop the CTLESC or recopy characters
	     that we've already copied down. */
	  i++; string[j++] = CTLESC;
	  if (i == slen)
	    break;
	}
      else if (string[i] == CTLNUL)
	i++;

      prev_i = i;
      ADVANCE_CHAR (string, slen, i);
      if (j < prev_i)
	{
	  do string[j++] = string[prev_i++]; while (prev_i < i);
	}
      else
	j = i;
    }
  string[j] = '\0';

  return (string);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\subst.c:3,683
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\subst.c:3,726
parsing error 
{
  register WORD_LIST *t;

  for (t = list; t; t = t->next)
    {
      remove_quoted_nulls (t->word->word);
      t->word->flags &= ~W_HASQUOTEDNULL;
    }
}
warning: parse error {
  register WORD_LIST *t;

  for (t = list; t; t = t->next)
    {
      remove_quoted_nulls (t->word->word);
      t->word->flags &= ~W_HASQUOTEDNULL;
    }
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\subst.c:3,728
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\subst.c:3,786
parsing error 
{
  register int len;
  register char *end;
  register char *p, *ret, c;

  len = STRLEN (param);
  end = param + len;

  switch (op)
    {
      case RP_LONG_LEFT:	/* remove longest match at start */
	for (p = end; p >= param; p--)
	  {
	    c = *p; *p = '\0';
	    if (strmatch (pattern, param, FNMATCH_EXTFLAG) != FNM_NOMATCH)
	      {
		*p = c;
		return (savestring (p));
	      }
	    *p = c;

	  }
	break;

      case RP_SHORT_LEFT:	/* remove shortest match at start */
	for (p = param; p <= end; p++)
	  {
	    c = *p; *p = '\0';
	    if (strmatch (pattern, param, FNMATCH_EXTFLAG) != FNM_NOMATCH)
	      {
		*p = c;
		return (savestring (p));
	      }
	    *p = c;
	  }
	break;

      case RP_LONG_RIGHT:	/* remove longest match at end */
	for (p = param; p <= end; p++)
	  {
	    if (strmatch (pattern, p, FNMATCH_EXTFLAG) != FNM_NOMATCH)
	      {
		c = *p; *p = '\0';
		ret = savestring (param);
		*p = c;
		return (ret);
	      }
	  }
	break;

      case RP_SHORT_RIGHT:	/* remove shortest match at end */
	for (p = end; p >= param; p--)
	  {
	    if (strmatch (pattern, p, FNMATCH_EXTFLAG) != FNM_NOMATCH)
	      {
		c = *p; *p = '\0';
		ret = savestring (param);
		*p = c;
		return (ret);
	      }
	  }
	break;
    }

  return (param);	/* no match, return original string */
}
warning: parse error {
  register int len;
  register char *end;
  register char *p, *ret, c;

  len = STRLEN (param);
  end = param + len;

  switch (op)
    {
      case RP_LONG_LEFT:	/* remove longest match at start */
	for (p = end; p >= param; p--)
	  {
	    c = *p; *p = '\0';
	    if (strmatch (pattern, param, FNMATCH_EXTFLAG) != FNM_NOMATCH)
	      {
		*p = c;
		return (savestring (p));
	      }
	    *p = c;

	  }
	break;

      case RP_SHORT_LEFT:	/* remove shortest match at start */
	for (p = param; p <= end; p++)
	  {
	    c = *p; *p = '\0';
	    if (strmatch (pattern, param, FNMATCH_EXTFLAG) != FNM_NOMATCH)
	      {
		*p = c;
		return (savestring (p));
	      }
	    *p = c;
	  }
	break;

      case RP_LONG_RIGHT:	/* remove longest match at end */
	for (p = param; p <= end; p++)
	  {
	    if (strmatch (pattern, p, FNMATCH_EXTFLAG) != FNM_NOMATCH)
	      {
		c = *p; *p = '\0';
		ret = savestring (param);
		*p = c;
		return (ret);
	      }
	  }
	break;

      case RP_SHORT_RIGHT:	/* remove shortest match at end */
	for (p = end; p >= param; p--)
	  {
	    if (strmatch (pattern, p, FNMATCH_EXTFLAG) != FNM_NOMATCH)
	      {
		c = *p; *p = '\0';
		ret = savestring (param);
		*p = c;
		return (ret);
	      }
	  }
	break;
    }

  return (param);	/* no match, return original string */
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\subst.c:3,789
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\subst.c:3,928
parsing error 
{
  char *xret;

  if (param == NULL)
    return (param);
  if (*param == '\0' || pattern == NULL || *pattern == '\0')	/* minor optimization */
    return (savestring (param));

#if defined (HANDLE_MULTIBYTE)
  if (MB_CUR_MAX > 1)
    {
      wchar_t *ret, *oret;
      size_t n;
      wchar_t *wparam, *wpattern;
      mbstate_t ps;

      n = xdupmbstowcs (&wpattern, NULL, pattern);
      if (n == (size_t)-1)
	{
	  xret = remove_upattern (param, pattern, op);
	  return ((xret == param) ? savestring (param) : xret);
	}
      n = xdupmbstowcs (&wparam, NULL, param);
      if (n == (size_t)-1)
	{
	  free (wpattern);
	  xret = remove_upattern (param, pattern, op);
	  return ((xret == param) ? savestring (param) : xret);
	}
      oret = ret = remove_wpattern (wparam, n, wpattern, op);
      /* Don't bother to convert wparam back to multibyte string if nothing
	 matched; just return copy of original string */
      if (ret == wparam)
        {
          free (wparam);
          free (wpattern);
          return (savestring (param));
        }

      free (wparam);
      free (wpattern);

      n = strlen (param);
      xret = (char *)xmalloc (n + 1);
      memset (&ps, '\0', sizeof (mbstate_t));
      n = wcsrtombs (xret, (const wchar_t **)&ret, n, &ps);
      xret[n] = '\0';		/* just to make sure */
      free (oret);
      return xret;      
    }
  else
#endif
    {
      xret = remove_upattern (param, pattern, op);
      return ((xret == param) ? savestring (param) : xret);
    }
}
warning: parse error {
  char *xret;

  if (param == NULL)
    return (param);
  if (*param == '\0' || pattern == NULL || *pattern == '\0')	/* minor optimization */
    return (savestring (param));

#if defined (HANDLE_MULTIBYTE)
  if (MB_CUR_MAX > 1)
    {
      wchar_t *ret, *oret;
      size_t n;
      wchar_t *wparam, *wpattern;
      mbstate_t ps;

      n = xdupmbstowcs (&wpattern, NULL, pattern);
      if (n == (size_t)-1)
	{
	  xret = remove_upattern (param, pattern, op);
	  return ((xret == param) ? savestring (param) : xret);
	}
      n = xdupmbstowcs (&wparam, NULL, param);
      if (n == (size_t)-1)
	{
	  free (wpattern);
	  xret = remove_upattern (param, pattern, op);
	  return ((xret == param) ? savestring (param) : xret);
	}
      oret = ret = remove_wpattern (wparam, n, wpattern, op);
      /* Don't bother to convert wparam back to multibyte string if nothing
	 matched; just return copy of original string */
      if (ret == wparam)
        {
          free (wparam);
          free (wpattern);
          return (savestring (param));
        }

      free (wparam);
      free (wpattern);

      n = strlen (param);
      xret = (char *)xmalloc (n + 1);
      memset (&ps, '\0', sizeof (mbstate_t));
      n = wcsrtombs (xret, (const wchar_t **)&ret, n, &ps);
      xret[n] = '\0';		/* just to make sure */
      free (oret);
      return xret;      
    }
  else
#endif
    {
      xret = remove_upattern (param, pattern, op);
      return ((xret == param) ? savestring (param) : xret);
    }
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\subst.c:3,931
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\subst.c:3,996
parsing error 
{
  int c, len, mlen;
  register char *p, *p1, *npat;
  char *end;
  int n1;

  /* If the pattern doesn't match anywhere in the string, go ahead and
     short-circuit right away.  A minor optimization, saves a bunch of
     unnecessary calls to strmatch (up to N calls for a string of N
     characters) if the match is unsuccessful.  To preserve the semantics
     of the substring matches below, we make sure that the pattern has
     `*' as first and last character, making a new pattern if necessary. */
  /* XXX - check this later if I ever implement `**' with special meaning,
     since this will potentially result in `**' at the beginning or end */
  len = STRLEN (pat);
  if (pat[0] != '*' || (pat[0] == '*' && pat[1] == LPAREN && extended_glob) || pat[len - 1] != '*')
    {
      p = npat = (char *)xmalloc (len + 3);
      p1 = pat;
      if (*p1 != '*' || (*p1 == '*' && p1[1] == LPAREN && extended_glob))
	*p++ = '*';
      while (*p1)
	*p++ = *p1++;
      if (p1[-1] != '*' || p[-2] == '\\')
	*p++ = '*';
      *p = '\0';
    }
  else
    npat = pat;
  c = strmatch (npat, string, FNMATCH_EXTFLAG);
  if (npat != pat)
    free (npat);
  if (c == FNM_NOMATCH)
    return (0);

  len = STRLEN (string);
  end = string + len;

  mlen = umatchlen (pat, len);

  switch (mtype)
    {
    case MATCH_ANY:
      for (p = string; p <= end; p++)
	{
	  if (match_pattern_char (pat, p))
	    {
#if 0
	      for (p1 = end; p1 >= p; p1--)
#else
	      p1 = (mlen == -1) ? end : p + mlen;
	      /* p1 - p = length of portion of string to be considered
	         p = current position in string
	         mlen = number of characters consumed by match (-1 for entire string)
	         end = end of string
	         we want to break immediately if the potential match len
	         is greater than the number of characters remaining in the
	         string
	      */
	      if (p1 > end)
		break;
	      for ( ; p1 >= p; p1--)
#endif
		{
		  c = *p1; *p1 = '\0';
		  if (strmatch (pat, p, FNMATCH_EXTFLAG) == 0)
		    {
		      *p1 = c;
		      *sp = p;
		      *ep = p1;
		      return 1;
		    }
		  *p1 = c;
#if 1
		  /* If MLEN != -1, we have a fixed length pattern. */
		  if (mlen != -1)
		    break;
#endif
		}
	    }
	}

      return (0);

    case MATCH_BEG:
      if (match_pattern_char (pat, string) == 0)
	return (0);

#if 0
      for (p = end; p >= string; p--)
#else
      for (p = (mlen == -1) ? end : string + mlen; p >= string; p--)
#endif
	{
	  c = *p; *p = '\0';
	  if (strmatch (pat, string, FNMATCH_EXTFLAG) == 0)
	    {
	      *p = c;
	      *sp = string;
	      *ep = p;
	      return 1;
	    }
	  *p = c;
#if 1
	  /* If MLEN != -1, we have a fixed length pattern. */
	  if (mlen != -1)
	    break;
#endif
	}

      return (0);

    case MATCH_END:
#if 0
      for (p = string; p <= end; p++)
#else
      for (p = end - ((mlen == -1) ? len : mlen); p <= end; p++)
#endif
	{
	  if (strmatch (pat, p, FNMATCH_EXTFLAG) == 0)
	    {
	      *sp = p;
	      *ep = end;
	      return 1;
	    }
#if 1
	  /* If MLEN != -1, we have a fixed length pattern. */
	  if (mlen != -1)
	    break;
#endif
	}

      return (0);
    }

  return (0);
}
warning: parse error {
  int c, len, mlen;
  register char *p, *p1, *npat;
  char *end;
  int n1;

  /* If the pattern doesn't match anywhere in the string, go ahead and
     short-circuit right away.  A minor optimization, saves a bunch of
     unnecessary calls to strmatch (up to N calls for a string of N
     characters) if the match is unsuccessful.  To preserve the semantics
     of the substring matches below, we make sure that the pattern has
     `*' as first and last character, making a new pattern if necessary. */
  /* XXX - check this later if I ever implement `**' with special meaning,
     since this will potentially result in `**' at the beginning or end */
  len = STRLEN (pat);
  if (pat[0] != '*' || (pat[0] == '*' && pat[1] == LPAREN && extended_glob) || pat[len - 1] != '*')
    {
      p = npat = (char *)xmalloc (len + 3);
      p1 = pat;
      if (*p1 != '*' || (*p1 == '*' && p1[1] == LPAREN && extended_glob))
	*p++ = '*';
      while (*p1)
	*p++ = *p1++;
      if (p1[-1] != '*' || p[-2] == '\\')
	*p++ = '*';
      *p = '\0';
    }
  else
    npat = pat;
  c = strmatch (npat, string, FNMATCH_EXTFLAG);
  if (npat != pat)
    free (npat);
  if (c == FNM_NOMATCH)
    return (0);

  len = STRLEN (string);
  end = string + len;

  mlen = umatchlen (pat, len);

  switch (mtype)
    {
    case MATCH_ANY:
      for (p = string; p <= end; p++)
	{
	  if (match_pattern_char (pat, p))
	    {
#if 0
	      for (p1 = end; p1 >= p; p1--)
#else
	      p1 = (mlen == -1) ? end : p + mlen;
	      /* p1 - p = length of portion of string to be considered
	         p = current position in string
	         mlen = number of characters consumed by match (-1 for entire string)
	         end = end of string
	         we want to break immediately if the potential match len
	         is greater than the number of characters remaining in the
	         string
	      */
	      if (p1 > end)
		break;
	      for ( ; p1 >= p; p1--)
#endif
		{
		  c = *p1; *p1 = '\0';
		  if (strmatch (pat, p, FNMATCH_EXTFLAG) == 0)
		    {
		      *p1 = c;
		      *sp = p;
		      *ep = p1;
		      return 1;
		    }
		  *p1 = c;
#if 1
		  /* If MLEN != -1, we have a fixed length pattern. */
		  if (mlen != -1)
		    break;
#endif
		}
	    }
	}

      return (0);

    case MATCH_BEG:
      if (match_pattern_char (pat, string) == 0)
	return (0);

#if 0
      for (p = end; p >= string; p--)
#else
      for (p = (mlen == -1) ? end : string + mlen; p >= string; p--)
#endif
	{
	  c = *p; *p = '\0';
	  if (strmatch (pat, string, FNMATCH_EXTFLAG) == 0)
	    {
	      *p = c;
	      *sp = string;
	      *ep = p;
	      return 1;
	    }
	  *p = c;
#if 1
	  /* If MLEN != -1, we have a fixed length pattern. */
	  if (mlen != -1)
	    break;
#endif
	}

      return (0);

    case MATCH_END:
#if 0
      for (p = string; p <= end; p++)
#else
      for (p = end - ((mlen == -1) ? len : mlen); p <= end; p++)
#endif
	{
	  if (strmatch (pat, p, FNMATCH_EXTFLAG) == 0)
	    {
	      *sp = p;
	      *ep = end;
	      return 1;
	    }
#if 1
	  /* If MLEN != -1, we have a fixed length pattern. */
	  if (mlen != -1)
	    break;
#endif
	}

      return (0);
    }

  return (0);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\subst.c:4,000
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\subst.c:4,290
parsing error 
{
#if defined (HANDLE_MULTIBYTE)
  int ret;
  size_t n;
  wchar_t *wstring, *wpat;
  char **indices;
  size_t slen, plen, mslen, mplen;
#endif

  if (string == 0 || *string == 0 || pat == 0 || *pat == 0)
    return (0);

#if defined (HANDLE_MULTIBYTE)
  if (MB_CUR_MAX > 1)
    {
#if 0
      slen = STRLEN (string);
      mslen = MBSLEN (string);
      plen = STRLEN (pat);
      mplen = MBSLEN (pat);
      if (slen == mslen && plen == mplen)
#else
      if (mbsmbchar (string) == 0 && mbsmbchar (pat) == 0)
#endif
        return (match_upattern (string, pat, mtype, sp, ep));

      n = xdupmbstowcs (&wpat, NULL, pat);
      if (n == (size_t)-1)
	return (match_upattern (string, pat, mtype, sp, ep));
      n = xdupmbstowcs (&wstring, &indices, string);
      if (n == (size_t)-1)
	{
	  free (wpat);
	  return (match_upattern (string, pat, mtype, sp, ep));
	}
      ret = match_wpattern (wstring, indices, n, wpat, mtype, sp, ep);

      free (wpat);
      free (wstring);
      free (indices);

      return (ret);
    }
  else
#endif
    return (match_upattern (string, pat, mtype, sp, ep));
}
warning: parse error {
#if defined (HANDLE_MULTIBYTE)
  int ret;
  size_t n;
  wchar_t *wstring, *wpat;
  char **indices;
  size_t slen, plen, mslen, mplen;
#endif

  if (string == 0 || *string == 0 || pat == 0 || *pat == 0)
    return (0);

#if defined (HANDLE_MULTIBYTE)
  if (MB_CUR_MAX > 1)
    {
#if 0
      slen = STRLEN (string);
      mslen = MBSLEN (string);
      plen = STRLEN (pat);
      mplen = MBSLEN (pat);
      if (slen == mslen && plen == mplen)
#else
      if (mbsmbchar (string) == 0 && mbsmbchar (pat) == 0)
#endif
        return (match_upattern (string, pat, mtype, sp, ep));

      n = xdupmbstowcs (&wpat, NULL, pat);
      if (n == (size_t)-1)
	return (match_upattern (string, pat, mtype, sp, ep));
      n = xdupmbstowcs (&wstring, &indices, string);
      if (n == (size_t)-1)
	{
	  free (wpat);
	  return (match_upattern (string, pat, mtype, sp, ep));
	}
      ret = match_wpattern (wstring, indices, n, wpat, mtype, sp, ep);

      free (wpat);
      free (wstring);
      free (indices);

      return (ret);
    }
  else
#endif
    return (match_upattern (string, pat, mtype, sp, ep));
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\subst.c:4,294
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\subst.c:4,343
parsing error 
{
  if (c == '#')
    return ((*value == '#') ? RP_LONG_LEFT : RP_SHORT_LEFT);
  else	/* c == '%' */
    return ((*value == '%') ? RP_LONG_RIGHT : RP_SHORT_RIGHT);
}
warning: parse error {
  if (c == '#')
    return ((*value == '#') ? RP_LONG_LEFT : RP_SHORT_LEFT);
  else	/* c == '%' */
    return ((*value == '%') ? RP_LONG_RIGHT : RP_SHORT_RIGHT);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\subst.c:4,346
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\subst.c:4,362
parsing error 
{
  char *pat, *tword;
  WORD_LIST *l;
#if 0
  int i;
#endif
  /* There is a problem here:  how to handle single or double quotes in the
     pattern string when the whole expression is between double quotes?
     POSIX.2 says that enclosing double quotes do not cause the pattern to
     be quoted, but does that leave us a problem with @ and array[@] and their
     expansions inside a pattern? */
#if 0
  if (expandpat && (quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)) && *tword)
    {
      i = 0;
      pat = string_extract_double_quoted (tword, &i, 1);
      free (tword);
      tword = pat;
    }
#endif

  /* expand_string_for_rhs () leaves WORD quoted and does not perform
     word splitting. */
  l = *value ? expand_string_for_rhs (value,
				      (quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)) ? Q_PATQUOTE : quoted,
				      (int *)NULL, (int *)NULL)
	     : (WORD_LIST *)0;
  pat = string_list (l);
  dispose_words (l);
  if (pat)
    {
      tword = quote_string_for_globbing (pat, QGLOB_CVTNULL);
      free (pat);
      pat = tword;
    }
  return (pat);
}
warning: parse error {
  char *pat, *tword;
  WORD_LIST *l;
#if 0
  int i;
#endif
  /* There is a problem here:  how to handle single or double quotes in the
     pattern string when the whole expression is between double quotes?
     POSIX.2 says that enclosing double quotes do not cause the pattern to
     be quoted, but does that leave us a problem with @ and array[@] and their
     expansions inside a pattern? */
#if 0
  if (expandpat && (quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)) && *tword)
    {
      i = 0;
      pat = string_extract_double_quoted (tword, &i, 1);
      free (tword);
      tword = pat;
    }
#endif

  /* expand_string_for_rhs () leaves WORD quoted and does not perform
     word splitting. */
  l = *value ? expand_string_for_rhs (value,
				      (quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)) ? Q_PATQUOTE : quoted,
				      (int *)NULL, (int *)NULL)
	     : (WORD_LIST *)0;
  pat = string_list (l);
  dispose_words (l);
  if (pat)
    {
      tword = quote_string_for_globbing (pat, QGLOB_CVTNULL);
      free (pat);
      pat = tword;
    }
  return (pat);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\subst.c:4,365
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\subst.c:4,420
parsing error 
{
  WORD_LIST *new, *l;
  WORD_DESC *w;
  char *tword;

  for (new = (WORD_LIST *)NULL, l = list; l; l = l->next)
    {
      tword = remove_pattern (l->word->word, pattern, patspec);
      w = alloc_word_desc ();
      w->word = tword ? tword : savestring ("");
      new = make_word_list (w, new);
    }

  l = REVERSE_LIST (new, WORD_LIST *);
  tword = string_list_pos_params (itype, l, quoted);
  dispose_words (l);

  return (tword);
}
warning: parse error {
  WORD_LIST *new, *l;
  WORD_DESC *w;
  char *tword;

  for (new = (WORD_LIST *)NULL, l = list; l; l = l->next)
    {
      tword = remove_pattern (l->word->word, pattern, patspec);
      w = alloc_word_desc ();
      w->word = tword ? tword : savestring ("");
      new = make_word_list (w, new);
    }

  l = REVERSE_LIST (new, WORD_LIST *);
  tword = string_list_pos_params (itype, l, quoted);
  dispose_words (l);

  return (tword);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\subst.c:4,424
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\subst.c:4,445
parsing error 
{
  char *ret;
  WORD_LIST *list;

  list = list_rest_of_args ();
  if (list == 0)
    return ((char *)NULL);
  ret = list_remove_pattern (list, pattern, patspec, itype, quoted);
  dispose_words (list);
  return (ret);
}
warning: parse error {
  char *ret;
  WORD_LIST *list;

  list = list_rest_of_args ();
  if (list == 0)
    return ((char *)NULL);
  ret = list_remove_pattern (list, pattern, patspec, itype, quoted);
  dispose_words (list);
  return (ret);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\subst.c:4,449
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\subst.c:4,495
parsing error 
{
  int vtype, patspec, starsub;
  char *temp1, *val, *pattern;
  SHELL_VAR *v;

  if (value == 0)
    return ((char *)NULL);

  this_command_name = varname;

  vtype = get_var_and_type (varname, value, ind, quoted, flags, &v, &val);
  if (vtype == -1)
    return ((char *)NULL);

  starsub = vtype & VT_STARSUB;
  vtype &= ~VT_STARSUB;

  patspec = getpatspec (rtype, patstr);
  if (patspec == RP_LONG_LEFT || patspec == RP_LONG_RIGHT)
    patstr++;

  /* Need to pass getpattern newly-allocated memory in case of expansion --
     the expansion code will free the passed string on an error. */
  temp1 = savestring (patstr);
  pattern = getpattern (temp1, quoted, 1);
  free (temp1);

  temp1 = (char *)NULL;		/* shut up gcc */
  switch (vtype)
    {
    case VT_VARIABLE:
    case VT_ARRAYMEMBER:
      temp1 = remove_pattern (val, pattern, patspec);
      if (vtype == VT_VARIABLE)
	FREE (val);
      if (temp1)
	{
	  val = (quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES))
			? quote_string (temp1)
			: quote_escapes (temp1);
	  free (temp1);
	  temp1 = val;
	}
      break;
#if defined (ARRAY_VARS)
    case VT_ARRAYVAR:
      temp1 = array_remove_pattern (v, pattern, patspec, varname, quoted);
      if (temp1 && ((quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)) == 0))
	{
	  val = quote_escapes (temp1);
	  free (temp1);
	  temp1 = val;
	}
      break;
#endif
    case VT_POSPARMS:
      temp1 = parameter_list_remove_pattern (varname[0], pattern, patspec, quoted);
      if (temp1 && ((quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)) == 0))
	{
	  val = quote_escapes (temp1);
	  free (temp1);
	  temp1 = val;
	}
      break;
    }

  FREE (pattern);
  return temp1;
}
warning: parse error {
  int vtype, patspec, starsub;
  char *temp1, *val, *pattern;
  SHELL_VAR *v;

  if (value == 0)
    return ((char *)NULL);

  this_command_name = varname;

  vtype = get_var_and_type (varname, value, ind, quoted, flags, &v, &val);
  if (vtype == -1)
    return ((char *)NULL);

  starsub = vtype & VT_STARSUB;
  vtype &= ~VT_STARSUB;

  patspec = getpatspec (rtype, patstr);
  if (patspec == RP_LONG_LEFT || patspec == RP_LONG_RIGHT)
    patstr++;

  /* Need to pass getpattern newly-allocated memory in case of expansion --
     the expansion code will free the passed string on an error. */
  temp1 = savestring (patstr);
  pattern = getpattern (temp1, quoted, 1);
  free (temp1);

  temp1 = (char *)NULL;		/* shut up gcc */
  switch (vtype)
    {
    case VT_VARIABLE:
    case VT_ARRAYMEMBER:
      temp1 = remove_pattern (val, pattern, patspec);
      if (vtype == VT_VARIABLE)
	FREE (val);
      if (temp1)
	{
	  val = (quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES))
			? quote_string (temp1)
			: quote_escapes (temp1);
	  free (temp1);
	  temp1 = val;
	}
      break;
#if defined (ARRAY_VARS)
    case VT_ARRAYVAR:
      temp1 = array_remove_pattern (v, pattern, patspec, varname, quoted);
      if (temp1 && ((quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)) == 0))
	{
	  val = quote_escapes (temp1);
	  free (temp1);
	  temp1 = val;
	}
      break;
#endif
    case VT_POSPARMS:
      temp1 = parameter_list_remove_pattern (varname[0], pattern, patspec, quoted);
      if (temp1 && ((quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)) == 0))
	{
	  val = quote_escapes (temp1);
	  free (temp1);
	  temp1 = val;
	}
      break;
    }

  FREE (pattern);
  return temp1;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\subst.c:4,500
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\subst.c:4,581
parsing error 
{
  WORD_LIST *result, *tresult;

  tresult = call_expand_word_internal (word, quoted, 0, (int *)NULL, (int *)NULL);
  result = word_list_split (tresult);
  dispose_words (tresult);
  return (result ? dequote_list (result) : result);
}
warning: parse error {
  WORD_LIST *result, *tresult;

  tresult = call_expand_word_internal (word, quoted, 0, (int *)NULL, (int *)NULL);
  result = word_list_split (tresult);
  dispose_words (tresult);
  return (result ? dequote_list (result) : result);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\subst.c:4,584
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\subst.c:4,597
parsing error 
{
  WORD_LIST *result;

  expand_no_split_dollar_star = 1;
#if defined (HANDLE_MULTIBYTE)
  if (ifs_firstc[0] == 0)
#else
  if (ifs_firstc == 0)
#endif
    word->flags |= W_NOSPLIT;
  result = call_expand_word_internal (word, quoted, 0, (int *)NULL, (int *)NULL);
  expand_no_split_dollar_star = 0;

  return (result ? dequote_list (result) : result);
}
warning: parse error {
  WORD_LIST *result;

  expand_no_split_dollar_star = 1;
#if defined (HANDLE_MULTIBYTE)
  if (ifs_firstc[0] == 0)
#else
  if (ifs_firstc == 0)
#endif
    word->flags |= W_NOSPLIT;
  result = call_expand_word_internal (word, quoted, 0, (int *)NULL, (int *)NULL);
  expand_no_split_dollar_star = 0;

  return (result ? dequote_list (result) : result);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\subst.c:4,600
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\subst.c:4,620
parsing error 
{
  WORD_LIST *result;

  expand_no_split_dollar_star = 1;
#if defined (HANDLE_MULTIBYTE)
  if (ifs_firstc[0] == 0)
#else
  if (ifs_firstc == 0)
#endif
    word->flags |= W_NOSPLIT;
  word->flags |= W_NOSPLIT2;
  result = call_expand_word_internal (word, quoted, 0, (int *)NULL, (int *)NULL);
  expand_no_split_dollar_star = 0;

  return result;
}
warning: parse error {
  WORD_LIST *result;

  expand_no_split_dollar_star = 1;
#if defined (HANDLE_MULTIBYTE)
  if (ifs_firstc[0] == 0)
#else
  if (ifs_firstc == 0)
#endif
    word->flags |= W_NOSPLIT;
  word->flags |= W_NOSPLIT2;
  result = call_expand_word_internal (word, quoted, 0, (int *)NULL, (int *)NULL);
  expand_no_split_dollar_star = 0;

  return result;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\subst.c:4,623
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\subst.c:5,135
parsing error 
{
  char *istring, buf[128], *bufp, *s;
  int istring_index, istring_size, c, tflag, skip_ctlesc, skip_ctlnul;
  ssize_t bufn;

  istring = (char *)NULL;
  istring_index = istring_size = bufn = tflag = 0;

  for (skip_ctlesc = skip_ctlnul = 0, s = ifs_value; s && *s; s++)
    skip_ctlesc |= *s == CTLESC, skip_ctlnul |= *s == CTLNUL;

  /* Read the output of the command through the pipe.  This may need to be
     changed to understand multibyte characters in the future. */
  while (1)
    {
      if (fd < 0)
	break;
      if (--bufn <= 0)
	{
	  bufn = zread (fd, buf, sizeof (buf));
	  if (bufn <= 0) 
	    break;
	  bufp = buf;
	}
      c = *bufp++;

      if (c == 0)
	{
#if 0
	  internal_warning ("read_comsub: ignored null byte in input");
#endif
	  continue;
	}

      /* Add the character to ISTRING, possibly after resizing it. */
      RESIZE_MALLOCED_BUFFER (istring, istring_index, 2, istring_size, DEFAULT_ARRAY_SIZE);

      /* This is essentially quote_string inline */
      if ((quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)) /* || c == CTLESC || c == CTLNUL */)
	istring[istring_index++] = CTLESC;
      /* Escape CTLESC and CTLNUL in the output to protect those characters
	 from the rest of the word expansions (word splitting and globbing.)
	 This is essentially quote_escapes inline. */
      else if (skip_ctlesc == 0 && c == CTLESC)
	{
	  tflag |= W_HASCTLESC;
	  istring[istring_index++] = CTLESC;
	}
      else if ((skip_ctlnul == 0 && c == CTLNUL) || (c == ' ' && (ifs_value && *ifs_value == 0)))
	istring[istring_index++] = CTLESC;

      istring[istring_index++] = c;

#if 0
#if defined (__CYGWIN__)
      if (c == '\n' && istring_index > 1 && istring[istring_index - 2] == '\r')
	{
	  istring_index--;
	  istring[istring_index - 1] = '\n';
	}
#endif
#endif
    }

  if (istring)
    istring[istring_index] = '\0';

  /* If we read no output, just return now and save ourselves some
     trouble. */
  if (istring_index == 0)
    {
      FREE (istring);
      if (rflag)
	*rflag = tflag;
      return (char *)NULL;
    }

  /* Strip trailing newlines from the output of the command. */
  if (quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES))
    {
      while (istring_index > 0)
	{
	  if (istring[istring_index - 1] == '\n')
	    {
	      --istring_index;

	      /* If the newline was quoted, remove the quoting char. */
	      if (istring[istring_index - 1] == CTLESC)
		--istring_index;
	    }
	  else
	    break;
	}
      istring[istring_index] = '\0';
    }
  else
    strip_trailing (istring, istring_index - 1, 1);

  if (rflag)
    *rflag = tflag;
  return istring;
}
warning: parse error {
  char *istring, buf[128], *bufp, *s;
  int istring_index, istring_size, c, tflag, skip_ctlesc, skip_ctlnul;
  ssize_t bufn;

  istring = (char *)NULL;
  istring_index = istring_size = bufn = tflag = 0;

  for (skip_ctlesc = skip_ctlnul = 0, s = ifs_value; s && *s; s++)
    skip_ctlesc |= *s == CTLESC, skip_ctlnul |= *s == CTLNUL;

  /* Read the output of the command through the pipe.  This may need to be
     changed to understand multibyte characters in the future. */
  while (1)
    {
      if (fd < 0)
	break;
      if (--bufn <= 0)
	{
	  bufn = zread (fd, buf, sizeof (buf));
	  if (bufn <= 0) 
	    break;
	  bufp = buf;
	}
      c = *bufp++;

      if (c == 0)
	{
#if 0
	  internal_warning ("read_comsub: ignored null byte in input");
#endif
	  continue;
	}

      /* Add the character to ISTRING, possibly after resizing it. */
      RESIZE_MALLOCED_BUFFER (istring, istring_index, 2, istring_size, DEFAULT_ARRAY_SIZE);

      /* This is essentially quote_string inline */
      if ((quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)) /* || c == CTLESC || c == CTLNUL */)
	istring[istring_index++] = CTLESC;
      /* Escape CTLESC and CTLNUL in the output to protect those characters
	 from the rest of the word expansions (word splitting and globbing.)
	 This is essentially quote_escapes inline. */
      else if (skip_ctlesc == 0 && c == CTLESC)
	{
	  tflag |= W_HASCTLESC;
	  istring[istring_index++] = CTLESC;
	}
      else if ((skip_ctlnul == 0 && c == CTLNUL) || (c == ' ' && (ifs_value && *ifs_value == 0)))
	istring[istring_index++] = CTLESC;

      istring[istring_index++] = c;

#if 0
#if defined (__CYGWIN__)
      if (c == '\n' && istring_index > 1 && istring[istring_index - 2] == '\r')
	{
	  istring_index--;
	  istring[istring_index - 1] = '\n';
	}
#endif
#endif
    }

  if (istring)
    istring[istring_index] = '\0';

  /* If we read no output, just return now and save ourselves some
     trouble. */
  if (istring_index == 0)
    {
      FREE (istring);
      if (rflag)
	*rflag = tflag;
      return (char *)NULL;
    }

  /* Strip trailing newlines from the output of the command. */
  if (quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES))
    {
      while (istring_index > 0)
	{
	  if (istring[istring_index - 1] == '\n')
	    {
	      --istring_index;

	      /* If the newline was quoted, remove the quoting char. */
	      if (istring[istring_index - 1] == CTLESC)
		--istring_index;
	    }
	  else
	    break;
	}
      istring[istring_index] = '\0';
    }
  else
    strip_trailing (istring, istring_index - 1, 1);

  if (rflag)
    *rflag = tflag;
  return istring;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\subst.c:5,138
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\subst.c:5,244
parsing error 
{
  pid_t pid, old_pid, old_pipeline_pgrp, old_async_pid;
  char *istring;
  int result, fildes[2], function_value, pflags, rc, tflag;
  WORD_DESC *ret;

  istring = (char *)NULL;

  /* Don't fork () if there is no need to.  In the case of no command to
     run, just return NULL. */
  if (!string || !*string || (string[0] == '\n' && !string[1]))
    return ((WORD_DESC *)NULL);

  if (wordexp_only && read_but_dont_execute)
    {
      last_command_exit_value = EX_WEXPCOMSUB;
      jump_to_top_level (EXITPROG);
    }

  /* We're making the assumption here that the command substitution will
     eventually run a command from the file system.  Since we'll run
     maybe_make_export_env in this subshell before executing that command,
     the parent shell and any other shells it starts will have to remake
     the environment.  If we make it before we fork, other shells won't
     have to.  Don't bother if we have any temporary variable assignments,
     though, because the export environment will be remade after this
     command completes anyway, but do it if all the words to be expanded
     are variable assignments. */
  if (subst_assign_varlist == 0 || garglist == 0)
    maybe_make_export_env ();	/* XXX */

  /* Flags to pass to parse_and_execute() */
  pflags = (interactive && sourcelevel == 0) ? SEVAL_RESETLINE : 0;

  /* Pipe the output of executing STRING into the current shell. */
  if (pipe (fildes) < 0)
    {
      sys_error (_("cannot make pipe for command substitution"));
      goto error_exit;
    }

  old_pid = last_made_pid;
#if defined (JOB_CONTROL)
  old_pipeline_pgrp = pipeline_pgrp;
  /* Don't reset the pipeline pgrp if we're already a subshell in a pipeline. */
  if ((subshell_environment & SUBSHELL_PIPE) == 0)
    pipeline_pgrp = shell_pgrp;
  cleanup_the_pipeline ();
#endif /* JOB_CONTROL */

  old_async_pid = last_asynchronous_pid;
  pid = make_child ((char *)NULL, subshell_environment&SUBSHELL_ASYNC);
  last_asynchronous_pid = old_async_pid;

  if (pid == 0)
    {
      /* Reset the signal handlers in the child, but don't free the
	 trap strings.  Set a flag noting that we have to free the
	 trap strings if we run trap to change a signal disposition. */
      reset_signal_handlers ();
      subshell_environment |= SUBSHELL_RESETTRAP;
    }

#if defined (JOB_CONTROL)
  /* XXX DO THIS ONLY IN PARENT ? XXX */
  set_sigchld_handler ();
  stop_making_children ();
  if (pid != 0)
    pipeline_pgrp = old_pipeline_pgrp;
#else
  stop_making_children ();
#endif /* JOB_CONTROL */

  if (pid < 0)
    {
      sys_error (_("cannot make child for command substitution"));
    error_exit:

      FREE (istring);
      close (fildes[0]);
      close (fildes[1]);
      return ((WORD_DESC *)NULL);
    }

  if (pid == 0)
    {
      set_sigint_handler ();	/* XXX */

      free_pushed_string_input ();

      if (dup2 (fildes[1], 1) < 0)
	{
	  sys_error (_("command_substitute: cannot duplicate pipe as fd 1"));
	  exit (EXECUTION_FAILURE);
	}

      /* If standard output is closed in the parent shell
	 (such as after `exec >&-'), file descriptor 1 will be
	 the lowest available file descriptor, and end up in
	 fildes[0].  This can happen for stdin and stderr as well,
	 but stdout is more important -- it will cause no output
	 to be generated from this command. */
      if ((fildes[1] != fileno (stdin)) &&
	  (fildes[1] != fileno (stdout)) &&
	  (fildes[1] != fileno (stderr)))
	close (fildes[1]);

      if ((fildes[0] != fileno (stdin)) &&
	  (fildes[0] != fileno (stdout)) &&
	  (fildes[0] != fileno (stderr)))
	close (fildes[0]);

#ifdef __CYGWIN__
      /* Let stdio know the fd may have changed from text to binary mode, and
	 make sure to preserve stdout line buffering. */
      freopen (NULL, "w", stdout);
      sh_setlinebuf (stdout);
#endif /* __CYGWIN__ */

      /* The currently executing shell is not interactive. */
      interactive = 0;

      /* This is a subshell environment. */
      subshell_environment |= SUBSHELL_COMSUB;

      /* When not in POSIX mode, command substitution does not inherit
	 the -e flag. */
      if (posixly_correct == 0)
	exit_immediately_on_error = 0;

      remove_quoted_escapes (string);

      startup_state = 2;	/* see if we can avoid a fork */
      /* Give command substitution a place to jump back to on failure,
	 so we don't go back up to main (). */
      result = setjmp (top_level);

      /* If we're running a command substitution inside a shell function,
	 trap `return' so we don't return from the function in the subshell
	 and go off to never-never land. */
      if (result == 0 && return_catch_flag)
	function_value = setjmp (return_catch);
      else
	function_value = 0;

      if (result == ERREXIT)
	rc = last_command_exit_value;
      else if (result == EXITPROG)
	rc = last_command_exit_value;
      else if (result)
	rc = EXECUTION_FAILURE;
      else if (function_value)
	rc = return_catch_value;
      else
	{
	  subshell_level++;
	  rc = parse_and_execute (string, "command substitution", pflags|SEVAL_NOHIST);
	  subshell_level--;
	}

      last_command_exit_value = rc;
      rc = run_exit_trap ();
#if defined (PROCESS_SUBSTITUTION)
      unlink_fifo_list ();
#endif
      exit (rc);
    }
  else
    {
#if defined (JOB_CONTROL) && defined (PGRP_PIPE)
      close_pgrp_pipe ();
#endif /* JOB_CONTROL && PGRP_PIPE */

      close (fildes[1]);

      tflag = 0;
      istring = read_comsub (fildes[0], quoted, &tflag);

      close (fildes[0]);

      current_command_subst_pid = pid;
      last_command_exit_value = wait_for (pid);
      last_command_subst_pid = pid;
      last_made_pid = old_pid;

#if defined (JOB_CONTROL)
      /* If last_command_exit_value > 128, then the substituted command
	 was terminated by a signal.  If that signal was SIGINT, then send
	 SIGINT to ourselves.  This will break out of loops, for instance. */
      if (last_command_exit_value == (128 + SIGINT) && last_command_exit_signal == SIGINT)
	kill (getpid (), SIGINT);

      /* wait_for gives the terminal back to shell_pgrp.  If some other
	 process group should have it, give it away to that group here.
	 pipeline_pgrp is non-zero only while we are constructing a
	 pipline, so what we are concerned about is whether or not that
	 pipeline was started in the background.  A pipeline started in
	 the background should never get the tty back here. */
      if (interactive && pipeline_pgrp != (pid_t)0 && (subshell_environment & SUBSHELL_ASYNC) == 0)
	give_terminal_to (pipeline_pgrp, 0);
#endif /* JOB_CONTROL */

      ret = alloc_word_desc ();
      ret->word = istring;
      ret->flags = tflag;

      return ret;
    }
}
warning: parse error {
  pid_t pid, old_pid, old_pipeline_pgrp, old_async_pid;
  char *istring;
  int result, fildes[2], function_value, pflags, rc, tflag;
  WORD_DESC *ret;

  istring = (char *)NULL;

  /* Don't fork () if there is no need to.  In the case of no command to
     run, just return NULL. */
  if (!string || !*string || (string[0] == '\n' && !string[1]))
    return ((WORD_DESC *)NULL);

  if (wordexp_only && read_but_dont_execute)
    {
      last_command_exit_value = EX_WEXPCOMSUB;
      jump_to_top_level (EXITPROG);
    }

  /* We're making the assumption here that the command substitution will
     eventually run a command from the file system.  Since we'll run
     maybe_make_export_env in this subshell before executing that command,
     the parent shell and any other shells it starts will have to remake
     the environment.  If we make it before we fork, other shells won't
     have to.  Don't bother if we have any temporary variable assignments,
     though, because the export environment will be remade after this
     command completes anyway, but do it if all the words to be expanded
     are variable assignments. */
  if (subst_assign_varlist == 0 || garglist == 0)
    maybe_make_export_env ();	/* XXX */

  /* Flags to pass to parse_and_execute() */
  pflags = (interactive && sourcelevel == 0) ? SEVAL_RESETLINE : 0;

  /* Pipe the output of executing STRING into the current shell. */
  if (pipe (fildes) < 0)
    {
      sys_error (_("cannot make pipe for command substitution"));
      goto error_exit;
    }

  old_pid = last_made_pid;
#if defined (JOB_CONTROL)
  old_pipeline_pgrp = pipeline_pgrp;
  /* Don't reset the pipeline pgrp if we're already a subshell in a pipeline. */
  if ((subshell_environment & SUBSHELL_PIPE) == 0)
    pipeline_pgrp = shell_pgrp;
  cleanup_the_pipeline ();
#endif /* JOB_CONTROL */

  old_async_pid = last_asynchronous_pid;
  pid = make_child ((char *)NULL, subshell_environment&SUBSHELL_ASYNC);
  last_asynchronous_pid = old_async_pid;

  if (pid == 0)
    {
      /* Reset the signal handlers in the child, but don't free the
	 trap strings.  Set a flag noting that we have to free the
	 trap strings if we run trap to change a signal disposition. */
      reset_signal_handlers ();
      subshell_environment |= SUBSHELL_RESETTRAP;
    }

#if defined (JOB_CONTROL)
  /* XXX DO THIS ONLY IN PARENT ? XXX */
  set_sigchld_handler ();
  stop_making_children ();
  if (pid != 0)
    pipeline_pgrp = old_pipeline_pgrp;
#else
  stop_making_children ();
#endif /* JOB_CONTROL */

  if (pid < 0)
    {
      sys_error (_("cannot make child for command substitution"));
    error_exit:

      FREE (istring);
      close (fildes[0]);
      close (fildes[1]);
      return ((WORD_DESC *)NULL);
    }

  if (pid == 0)
    {
      set_sigint_handler ();	/* XXX */

      free_pushed_string_input ();

      if (dup2 (fildes[1], 1) < 0)
	{
	  sys_error (_("command_substitute: cannot duplicate pipe as fd 1"));
	  exit (EXECUTION_FAILURE);
	}

      /* If standard output is closed in the parent shell
	 (such as after `exec >&-'), file descriptor 1 will be
	 the lowest available file descriptor, and end up in
	 fildes[0].  This can happen for stdin and stderr as well,
	 but stdout is more important -- it will cause no output
	 to be generated from this command. */
      if ((fildes[1] != fileno (stdin)) &&
	  (fildes[1] != fileno (stdout)) &&
	  (fildes[1] != fileno (stderr)))
	close (fildes[1]);

      if ((fildes[0] != fileno (stdin)) &&
	  (fildes[0] != fileno (stdout)) &&
	  (fildes[0] != fileno (stderr)))
	close (fildes[0]);

#ifdef __CYGWIN__
      /* Let stdio know the fd may have changed from text to binary mode, and
	 make sure to preserve stdout line buffering. */
      freopen (NULL, "w", stdout);
      sh_setlinebuf (stdout);
#endif /* __CYGWIN__ */

      /* The currently executing shell is not interactive. */
      interactive = 0;

      /* This is a subshell environment. */
      subshell_environment |= SUBSHELL_COMSUB;

      /* When not in POSIX mode, command substitution does not inherit
	 the -e flag. */
      if (posixly_correct == 0)
	exit_immediately_on_error = 0;

      remove_quoted_escapes (string);

      startup_state = 2;	/* see if we can avoid a fork */
      /* Give command substitution a place to jump back to on failure,
	 so we don't go back up to main (). */
      result = setjmp (top_level);

      /* If we're running a command substitution inside a shell function,
	 trap `return' so we don't return from the function in the subshell
	 and go off to never-never land. */
      if (result == 0 && return_catch_flag)
	function_value = setjmp (return_catch);
      else
	function_value = 0;

      if (result == ERREXIT)
	rc = last_command_exit_value;
      else if (result == EXITPROG)
	rc = last_command_exit_value;
      else if (result)
	rc = EXECUTION_FAILURE;
      else if (function_value)
	rc = return_catch_value;
      else
	{
	  subshell_level++;
	  rc = parse_and_execute (string, "command substitution", pflags|SEVAL_NOHIST);
	  subshell_level--;
	}

      last_command_exit_value = rc;
      rc = run_exit_trap ();
#if defined (PROCESS_SUBSTITUTION)
      unlink_fifo_list ();
#endif
      exit (rc);
    }
  else
    {
#if defined (JOB_CONTROL) && defined (PGRP_PIPE)
      close_pgrp_pipe ();
#endif /* JOB_CONTROL && PGRP_PIPE */

      close (fildes[1]);

      tflag = 0;
      istring = read_comsub (fildes[0], quoted, &tflag);

      close (fildes[0]);

      current_command_subst_pid = pid;
      last_command_exit_value = wait_for (pid);
      last_command_subst_pid = pid;
      last_made_pid = old_pid;

#if defined (JOB_CONTROL)
      /* If last_command_exit_value > 128, then the substituted command
	 was terminated by a signal.  If that signal was SIGINT, then send
	 SIGINT to ourselves.  This will break out of loops, for instance. */
      if (last_command_exit_value == (128 + SIGINT) && last_command_exit_signal == SIGINT)
	kill (getpid (), SIGINT);

      /* wait_for gives the terminal back to shell_pgrp.  If some other
	 process group should have it, give it away to that group here.
	 pipeline_pgrp is non-zero only while we are constructing a
	 pipline, so what we are concerned about is whether or not that
	 pipeline was started in the background.  A pipeline started in
	 the background should never get the tty back here. */
      if (interactive && pipeline_pgrp != (pid_t)0 && (subshell_environment & SUBSHELL_ASYNC) == 0)
	give_terminal_to (pipeline_pgrp, 0);
#endif /* JOB_CONTROL */

      ret = alloc_word_desc ();
      ret->word = istring;
      ret->flags = tflag;

      return ret;
    }
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\subst.c:5,247
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\subst.c:5,542
parsing error 
{
  if (DIGIT (*name) && all_digits (name))
    return 1;
  else if (var_is_special)
    return 1;
#if defined (ARRAY_VARS)
  else if (valid_array_reference (name))
    return 1;
#endif /* ARRAY_VARS */
  else if (legal_identifier (name))
    return 1;
  else
    return 0;
}
warning: parse error {
  if (DIGIT (*name) && all_digits (name))
    return 1;
  else if (var_is_special)
    return 1;
#if defined (ARRAY_VARS)
  else if (valid_array_reference (name))
    return 1;
#endif /* ARRAY_VARS */
  else if (legal_identifier (name))
    return 1;
  else
    return 0;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\subst.c:5,545
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\subst.c:5,561
parsing error 
{
  char *temp1;

  if (name == 0)
    {
      if (quoted_dollar_atp)
	*quoted_dollar_atp = 0;
      if (contains_dollar_at)
	*contains_dollar_at = 0;
      return 0;
    }

  /* check for $@ and $* */
  if (name[0] == '@' && name[1] == 0)
    {
      if ((quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)) && quoted_dollar_atp)
	*quoted_dollar_atp = 1;
      if (contains_dollar_at)
	*contains_dollar_at = 1;
      return 1;
    }
  else if (name[0] == '*' && name[1] == '\0' && quoted == 0)
    {
      if (contains_dollar_at)
	*contains_dollar_at = 1;
      return 1;
    }

  /* Now check for ${array[@]} and ${array[*]} */
#if defined (ARRAY_VARS)
  else if (valid_array_reference (name))
    {
      temp1 = mbschr (name, '[');
      if (temp1 && temp1[1] == '@' && temp1[2] == ']')
	{
	  if ((quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)) && quoted_dollar_atp)
	    *quoted_dollar_atp = 1;
	  if (contains_dollar_at)
	    *contains_dollar_at = 1;
	  return 1;
	}	/* [ */
      /* ${array[*]}, when unquoted, should be treated like ${array[@]},
	 which should result in separate words even when IFS is unset. */
      if (temp1 && temp1[1] == '*' && temp1[2] == ']' && quoted == 0)
	{
	  if (contains_dollar_at)
	    *contains_dollar_at = 1;
	  return 1;
	}
    }
#endif
  return 0;
}
warning: parse error {
  char *temp1;

  if (name == 0)
    {
      if (quoted_dollar_atp)
	*quoted_dollar_atp = 0;
      if (contains_dollar_at)
	*contains_dollar_at = 0;
      return 0;
    }

  /* check for $@ and $* */
  if (name[0] == '@' && name[1] == 0)
    {
      if ((quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)) && quoted_dollar_atp)
	*quoted_dollar_atp = 1;
      if (contains_dollar_at)
	*contains_dollar_at = 1;
      return 1;
    }
  else if (name[0] == '*' && name[1] == '\0' && quoted == 0)
    {
      if (contains_dollar_at)
	*contains_dollar_at = 1;
      return 1;
    }

  /* Now check for ${array[@]} and ${array[*]} */
#if defined (ARRAY_VARS)
  else if (valid_array_reference (name))
    {
      temp1 = mbschr (name, '[');
      if (temp1 && temp1[1] == '@' && temp1[2] == ']')
	{
	  if ((quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)) && quoted_dollar_atp)
	    *quoted_dollar_atp = 1;
	  if (contains_dollar_at)
	    *contains_dollar_at = 1;
	  return 1;
	}	/* [ */
      /* ${array[*]}, when unquoted, should be treated like ${array[@]},
	 which should result in separate words even when IFS is unset. */
      if (temp1 && temp1[1] == '*' && temp1[2] == ']' && quoted == 0)
	{
	  if (contains_dollar_at)
	    *contains_dollar_at = 1;
	  return 1;
	}
    }
#endif
  return 0;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\subst.c:5,565
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\subst.c:5,625
parsing error 
{
  WORD_DESC *ret;
  char *temp, *tt;
  intmax_t arg_index;
  SHELL_VAR *var;
  int atype, rflags;
  arrayind_t ind;

  ret = 0;
  temp = 0;
  rflags = 0;

  if (indp)
    *indp = INTMAX_MIN;

  /* Handle multiple digit arguments, as in ${11}. */  
  if (legal_number (name, &arg_index))
    {
      tt = get_dollar_var_value (arg_index);
      if (tt)
 	temp = (*tt && (quoted & (Q_DOUBLE_QUOTES|Q_HERE_DOCUMENT)))
 		  ? quote_string (tt)
 		  : quote_escapes (tt);
      else
        temp = (char *)NULL;
      FREE (tt);
    }
  else if (var_is_special)      /* ${@} */
    {
      int sindex;
      tt = (char *)xmalloc (2 + strlen (name));
      tt[sindex = 0] = '$';
      strcpy (tt + 1, name);

      ret = param_expand (tt, &sindex, quoted, (int *)NULL, (int *)NULL,
			  (int *)NULL, (int *)NULL, pflags);
      free (tt);
    }
#if defined (ARRAY_VARS)
  else if (valid_array_reference (name))
    {
      temp = array_value (name, quoted, 0, &atype, &ind);
      if (atype == 0 && temp)
	{
	  temp = (*temp && (quoted & (Q_DOUBLE_QUOTES|Q_HERE_DOCUMENT)))
		    ? quote_string (temp)
		    : quote_escapes (temp);
	  rflags |= W_ARRAYIND;
	  if (indp)
	    *indp = ind;
	} 		  
      else if (atype == 1 && temp && QUOTED_NULL (temp) && (quoted & (Q_DOUBLE_QUOTES|Q_HERE_DOCUMENT)))
	rflags |= W_HASQUOTEDNULL;
    }
#endif
  else if (var = find_variable (name))
    {
      if (var_isset (var) && invisible_p (var) == 0)
	{
#if defined (ARRAY_VARS)
	  if (assoc_p (var))
	    temp = assoc_reference (assoc_cell (var), "0");
	  else if (array_p (var))
	    temp = array_reference (array_cell (var), 0);
	  else
	    temp = value_cell (var);
#else
	  temp = value_cell (var);
#endif

	  if (temp)
	    temp = (*temp && (quoted & (Q_DOUBLE_QUOTES|Q_HERE_DOCUMENT)))
		      ? quote_string (temp)
		      : quote_escapes (temp);
	}
      else
	temp = (char *)NULL;
    }
  else
    temp = (char *)NULL;

  if (ret == 0)
    {
      ret = alloc_word_desc ();
      ret->word = temp;
      ret->flags |= rflags;
    }
  return ret;
}
warning: parse error {
  WORD_DESC *ret;
  char *temp, *tt;
  intmax_t arg_index;
  SHELL_VAR *var;
  int atype, rflags;
  arrayind_t ind;

  ret = 0;
  temp = 0;
  rflags = 0;

  if (indp)
    *indp = INTMAX_MIN;

  /* Handle multiple digit arguments, as in ${11}. */  
  if (legal_number (name, &arg_index))
    {
      tt = get_dollar_var_value (arg_index);
      if (tt)
 	temp = (*tt && (quoted & (Q_DOUBLE_QUOTES|Q_HERE_DOCUMENT)))
 		  ? quote_string (tt)
 		  : quote_escapes (tt);
      else
        temp = (char *)NULL;
      FREE (tt);
    }
  else if (var_is_special)      /* ${@} */
    {
      int sindex;
      tt = (char *)xmalloc (2 + strlen (name));
      tt[sindex = 0] = '$';
      strcpy (tt + 1, name);

      ret = param_expand (tt, &sindex, quoted, (int *)NULL, (int *)NULL,
			  (int *)NULL, (int *)NULL, pflags);
      free (tt);
    }
#if defined (ARRAY_VARS)
  else if (valid_array_reference (name))
    {
      temp = array_value (name, quoted, 0, &atype, &ind);
      if (atype == 0 && temp)
	{
	  temp = (*temp && (quoted & (Q_DOUBLE_QUOTES|Q_HERE_DOCUMENT)))
		    ? quote_string (temp)
		    : quote_escapes (temp);
	  rflags |= W_ARRAYIND;
	  if (indp)
	    *indp = ind;
	} 		  
      else if (atype == 1 && temp && QUOTED_NULL (temp) && (quoted & (Q_DOUBLE_QUOTES|Q_HERE_DOCUMENT)))
	rflags |= W_HASQUOTEDNULL;
    }
#endif
  else if (var = find_variable (name))
    {
      if (var_isset (var) && invisible_p (var) == 0)
	{
#if defined (ARRAY_VARS)
	  if (assoc_p (var))
	    temp = assoc_reference (assoc_cell (var), "0");
	  else if (array_p (var))
	    temp = array_reference (array_cell (var), 0);
	  else
	    temp = value_cell (var);
#else
	  temp = value_cell (var);
#endif

	  if (temp)
	    temp = (*temp && (quoted & (Q_DOUBLE_QUOTES|Q_HERE_DOCUMENT)))
		      ? quote_string (temp)
		      : quote_escapes (temp);
	}
      else
	temp = (char *)NULL;
    }
  else
    temp = (char *)NULL;

  if (ret == 0)
    {
      ret = alloc_word_desc ();
      ret->word = temp;
      ret->flags |= rflags;
    }
  return ret;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\subst.c:5,629
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\subst.c:5,722
parsing error 
{
  char *temp, *t;
  WORD_DESC *w;

  w = parameter_brace_expand_word (name, var_is_special, quoted, PF_IGNUNBOUND, 0);
  t = w->word;
  /* Have to dequote here if necessary */
  if (t)
    {
      temp = (quoted & (Q_DOUBLE_QUOTES|Q_HERE_DOCUMENT))
		? dequote_string (t)
		: dequote_escapes (t);
      free (t);
      t = temp;
    }
  dispose_word_desc (w);

  chk_atstar (t, quoted, quoted_dollar_atp, contains_dollar_at);
  if (t == 0)
    return (WORD_DESC *)NULL;

  w = parameter_brace_expand_word (t, SPECIAL_VAR(t, 0), quoted, 0, 0);
  free (t);

  return w;
}
warning: parse error {
  char *temp, *t;
  WORD_DESC *w;

  w = parameter_brace_expand_word (name, var_is_special, quoted, PF_IGNUNBOUND, 0);
  t = w->word;
  /* Have to dequote here if necessary */
  if (t)
    {
      temp = (quoted & (Q_DOUBLE_QUOTES|Q_HERE_DOCUMENT))
		? dequote_string (t)
		: dequote_escapes (t);
      free (t);
      t = temp;
    }
  dispose_word_desc (w);

  chk_atstar (t, quoted, quoted_dollar_atp, contains_dollar_at);
  if (t == 0)
    return (WORD_DESC *)NULL;

  w = parameter_brace_expand_word (t, SPECIAL_VAR(t, 0), quoted, 0, 0);
  free (t);

  return w;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\subst.c:5,726
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\subst.c:5,758
parsing error 
{
  WORD_DESC *w;
  WORD_LIST *l;
  char *t, *t1, *temp;
  int hasdol;

  /* If the entire expression is between double quotes, we want to treat
     the value as a double-quoted string, with the exception that we strip
     embedded unescaped double quotes (for sh backwards compatibility). */
  if ((quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)) && *value)
    {
      hasdol = 0;
      temp = string_extract_double_quoted (value, &hasdol, 1);
    }
  else
    temp = value;

  w = alloc_word_desc ();
  hasdol = 0;
  /* XXX was 0 not quoted */
  l = *temp ? expand_string_for_rhs (temp, quoted, &hasdol, (int *)NULL)
	    : (WORD_LIST *)0;
  if (hasdollarat)
    *hasdollarat = hasdol || (l && l->next);
  if (temp != value)
    free (temp);
  if (l)
    {
      /* The expansion of TEMP returned something.  We need to treat things
	  slightly differently if HASDOL is non-zero.  If we have "$@", the
	  individual words have already been quoted.  We need to turn them
	  into a string with the words separated by the first character of
	  $IFS without any additional quoting, so string_list_dollar_at won't
	  do the right thing.  We use string_list_dollar_star instead. */
      temp = (hasdol || l->next) ? string_list_dollar_star (l) : string_list (l);

      /* If l->next is not null, we know that TEMP contained "$@", since that
	 is the only expansion that creates more than one word. */
      if (qdollaratp && ((hasdol && quoted) || l->next))
	*qdollaratp = 1;
      dispose_words (l);
    }
  else if ((quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)) && hasdol)
    {
      /* The brace expansion occurred between double quotes and there was
	 a $@ in TEMP.  It does not matter if the $@ is quoted, as long as
	 it does not expand to anything.  In this case, we want to return
	 a quoted empty string. */
      temp = make_quoted_char ('\0');
      w->flags |= W_HASQUOTEDNULL;
    }
  else
    temp = (char *)NULL;

  if (c == '-' || c == '+')
    {
      w->word = temp;
      return w;
    }

  /* c == '=' */
  t = temp ? savestring (temp) : savestring ("");
  t1 = dequote_string (t);
  free (t);
#if defined (ARRAY_VARS)
  if (valid_array_reference (name))
    assign_array_element (name, t1, 0);
  else
#endif /* ARRAY_VARS */
  bind_variable (name, t1, 0);

  /* From Posix group discussion Feb-March 2010.  Issue 7 0000221 */
  free (temp);

  w->word = t1;
  return w;
}
warning: parse error {
  WORD_DESC *w;
  WORD_LIST *l;
  char *t, *t1, *temp;
  int hasdol;

  /* If the entire expression is between double quotes, we want to treat
     the value as a double-quoted string, with the exception that we strip
     embedded unescaped double quotes (for sh backwards compatibility). */
  if ((quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)) && *value)
    {
      hasdol = 0;
      temp = string_extract_double_quoted (value, &hasdol, 1);
    }
  else
    temp = value;

  w = alloc_word_desc ();
  hasdol = 0;
  /* XXX was 0 not quoted */
  l = *temp ? expand_string_for_rhs (temp, quoted, &hasdol, (int *)NULL)
	    : (WORD_LIST *)0;
  if (hasdollarat)
    *hasdollarat = hasdol || (l && l->next);
  if (temp != value)
    free (temp);
  if (l)
    {
      /* The expansion of TEMP returned something.  We need to treat things
	  slightly differently if HASDOL is non-zero.  If we have "$@", the
	  individual words have already been quoted.  We need to turn them
	  into a string with the words separated by the first character of
	  $IFS without any additional quoting, so string_list_dollar_at won't
	  do the right thing.  We use string_list_dollar_star instead. */
      temp = (hasdol || l->next) ? string_list_dollar_star (l) : string_list (l);

      /* If l->next is not null, we know that TEMP contained "$@", since that
	 is the only expansion that creates more than one word. */
      if (qdollaratp && ((hasdol && quoted) || l->next))
	*qdollaratp = 1;
      dispose_words (l);
    }
  else if ((quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)) && hasdol)
    {
      /* The brace expansion occurred between double quotes and there was
	 a $@ in TEMP.  It does not matter if the $@ is quoted, as long as
	 it does not expand to anything.  In this case, we want to return
	 a quoted empty string. */
      temp = make_quoted_char ('\0');
      w->flags |= W_HASQUOTEDNULL;
    }
  else
    temp = (char *)NULL;

  if (c == '-' || c == '+')
    {
      w->word = temp;
      return w;
    }

  /* c == '=' */
  t = temp ? savestring (temp) : savestring ("");
  t1 = dequote_string (t);
  free (t);
#if defined (ARRAY_VARS)
  if (valid_array_reference (name))
    assign_array_element (name, t1, 0);
  else
#endif /* ARRAY_VARS */
  bind_variable (name, t1, 0);

  /* From Posix group discussion Feb-March 2010.  Issue 7 0000221 */
  free (temp);

  w->word = t1;
  return w;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\subst.c:5,761
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\subst.c:5,844
parsing error 
{
  WORD_LIST *l;
  char *temp;

  if (value && *value)
    {
      l = expand_string (value, 0);
      temp =  string_list (l);
      report_error ("%s: %s", name, temp ? temp : "");	/* XXX was value not "" */
      FREE (temp);
      dispose_words (l);
    }
  else
    report_error (_("%s: parameter null or not set"), name);

  /* Free the data we have allocated during this expansion, since we
     are about to longjmp out. */
  free (name);
  FREE (value);
}
warning: parse error {
  WORD_LIST *l;
  char *temp;

  if (value && *value)
    {
      l = expand_string (value, 0);
      temp =  string_list (l);
      report_error ("%s: %s", name, temp ? temp : "");	/* XXX was value not "" */
      FREE (temp);
      dispose_words (l);
    }
  else
    report_error (_("%s: parameter null or not set"), name);

  /* Free the data we have allocated during this expansion, since we
     are about to longjmp out. */
  free (name);
  FREE (value);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\subst.c:5,846
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\subst.c:5,870
parsing error 
{
  return (name[1] == '\0' ||					/* ${#} */
	  ((sh_syntaxtab[(unsigned char) name[1]] & CSPECVAR) && name[2] == '\0') ||  /* special param */
	  (DIGIT (name[1]) && all_digits (name + 1)) ||	/* ${#11} */
#if defined (ARRAY_VARS)
	  valid_array_reference (name + 1) ||			/* ${#a[7]} */
#endif
	  legal_identifier (name + 1));				/* ${#PS1} */
}
warning: parse error {
  return (name[1] == '\0' ||					/* ${#} */
	  ((sh_syntaxtab[(unsigned char) name[1]] & CSPECVAR) && name[2] == '\0') ||  /* special param */
	  (DIGIT (name[1]) && all_digits (name + 1)) ||	/* ${#11} */
#if defined (ARRAY_VARS)
	  valid_array_reference (name + 1) ||			/* ${#a[7]} */
#endif
	  legal_identifier (name + 1));				/* ${#PS1} */
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\subst.c:5,872
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\subst.c:5,885
parsing error 
{
  char *t, *newname;
  intmax_t number, arg_index;
  WORD_LIST *list;
#if defined (ARRAY_VARS)
  SHELL_VAR *var;
#endif

  if (name[1] == '\0')			/* ${#} */
    number = number_of_args ();
  else if ((name[1] == '@' || name[1] == '*') && name[2] == '\0')	/* ${#@}, ${#*} */
    number = number_of_args ();
  else if ((sh_syntaxtab[(unsigned char) name[1]] & CSPECVAR) && name[2] == '\0')
    {
      /* Take the lengths of some of the shell's special parameters. */
      switch (name[1])
	{
	case '-':
	  t = which_set_flags ();
	  break;
	case '?':
	  t = itos (last_command_exit_value);
	  break;
	case '$':
	  t = itos (dollar_dollar_pid);
	  break;
	case '!':
	  if (last_asynchronous_pid == NO_PID)
	    t = (char *)NULL;	/* XXX - error if set -u set? */
	  else
	    t = itos (last_asynchronous_pid);
	  break;
	case '#':
	  t = itos (number_of_args ());
	  break;
	}
      number = STRLEN (t);
      FREE (t);
    }
#if defined (ARRAY_VARS)
  else if (valid_array_reference (name + 1))
    number = array_length_reference (name + 1);
#endif /* ARRAY_VARS */
  else
    {
      number = 0;

      if (legal_number (name + 1, &arg_index))		/* ${#1} */
	{
	  t = get_dollar_var_value (arg_index);
	  if (t == 0 && unbound_vars_is_error)
	    return INTMAX_MIN;
	  number = MB_STRLEN (t);
	  FREE (t);
	}
#if defined (ARRAY_VARS)
      else if ((var = find_variable (name + 1)) && (invisible_p (var) == 0) && (array_p (var) || assoc_p (var)))
	{
	  if (assoc_p (var))
	    t = assoc_reference (assoc_cell (var), "0");
	  else
	    t = array_reference (array_cell (var), 0);
	  if (t == 0 && unbound_vars_is_error)
	    return INTMAX_MIN;
	  number = MB_STRLEN (t);
	}
#endif
      else				/* ${#PS1} */
	{
	  newname = savestring (name);
	  newname[0] = '$';
	  list = expand_string (newname, Q_DOUBLE_QUOTES);
	  t = list ? string_list (list) : (char *)NULL;
	  free (newname);
	  if (list)
	    dispose_words (list);

	  number = t ? MB_STRLEN (t) : 0;
	  FREE (t);
	}
    }

  return (number);
}
warning: parse error {
  char *t, *newname;
  intmax_t number, arg_index;
  WORD_LIST *list;
#if defined (ARRAY_VARS)
  SHELL_VAR *var;
#endif

  if (name[1] == '\0')			/* ${#} */
    number = number_of_args ();
  else if ((name[1] == '@' || name[1] == '*') && name[2] == '\0')	/* ${#@}, ${#*} */
    number = number_of_args ();
  else if ((sh_syntaxtab[(unsigned char) name[1]] & CSPECVAR) && name[2] == '\0')
    {
      /* Take the lengths of some of the shell's special parameters. */
      switch (name[1])
	{
	case '-':
	  t = which_set_flags ();
	  break;
	case '?':
	  t = itos (last_command_exit_value);
	  break;
	case '$':
	  t = itos (dollar_dollar_pid);
	  break;
	case '!':
	  if (last_asynchronous_pid == NO_PID)
	    t = (char *)NULL;	/* XXX - error if set -u set? */
	  else
	    t = itos (last_asynchronous_pid);
	  break;
	case '#':
	  t = itos (number_of_args ());
	  break;
	}
      number = STRLEN (t);
      FREE (t);
    }
#if defined (ARRAY_VARS)
  else if (valid_array_reference (name + 1))
    number = array_length_reference (name + 1);
#endif /* ARRAY_VARS */
  else
    {
      number = 0;

      if (legal_number (name + 1, &arg_index))		/* ${#1} */
	{
	  t = get_dollar_var_value (arg_index);
	  if (t == 0 && unbound_vars_is_error)
	    return INTMAX_MIN;
	  number = MB_STRLEN (t);
	  FREE (t);
	}
#if defined (ARRAY_VARS)
      else if ((var = find_variable (name + 1)) && (invisible_p (var) == 0) && (array_p (var) || assoc_p (var)))
	{
	  if (assoc_p (var))
	    t = assoc_reference (assoc_cell (var), "0");
	  else
	    t = array_reference (array_cell (var), 0);
	  if (t == 0 && unbound_vars_is_error)
	    return INTMAX_MIN;
	  number = MB_STRLEN (t);
	}
#endif
      else				/* ${#PS1} */
	{
	  newname = savestring (name);
	  newname[0] = '$';
	  list = expand_string (newname, Q_DOUBLE_QUOTES);
	  t = list ? string_list (list) : (char *)NULL;
	  free (newname);
	  if (list)
	    dispose_words (list);

	  number = t ? MB_STRLEN (t) : 0;
	  FREE (t);
	}
    }

  return (number);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\subst.c:5,887
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\subst.c:5,980
parsing error 
{
  size_t sublen;
  int skipcol, pcount, i;
  DECLARE_MBSTATE;

  sublen = strlen (substr);
  i = skipcol = pcount = 0;
  while (substr[i])
    {
      /* Balance parens */
      if (substr[i] == LPAREN)
	{
	  pcount++;
	  i++;
	  continue;
	}
      if (substr[i] == RPAREN && pcount)
	{
	  pcount--;
	  i++;
	  continue;
	}
      if (pcount)
	{
	  ADVANCE_CHAR (substr, sublen, i);
	  continue;
	}

      /* Skip one `:' for each `?' */
      if (substr[i] == ':' && skipcol)
	{
	  skipcol--;
	  i++;
	  continue;
	}
      if (substr[i] == delim)
	break;
      if (substr[i] == '?')
	{
	  skipcol++;
	  i++;
	  continue;
	}
      ADVANCE_CHAR (substr, sublen, i);
    }

  return (substr + i);
}
warning: parse error {
  size_t sublen;
  int skipcol, pcount, i;
  DECLARE_MBSTATE;

  sublen = strlen (substr);
  i = skipcol = pcount = 0;
  while (substr[i])
    {
      /* Balance parens */
      if (substr[i] == LPAREN)
	{
	  pcount++;
	  i++;
	  continue;
	}
      if (substr[i] == RPAREN && pcount)
	{
	  pcount--;
	  i++;
	  continue;
	}
      if (pcount)
	{
	  ADVANCE_CHAR (substr, sublen, i);
	  continue;
	}

      /* Skip one `:' for each `?' */
      if (substr[i] == ':' && skipcol)
	{
	  skipcol--;
	  i++;
	  continue;
	}
      if (substr[i] == delim)
	break;
      if (substr[i] == '?')
	{
	  skipcol++;
	  i++;
	  continue;
	}
      ADVANCE_CHAR (substr, sublen, i);
    }

  return (substr + i);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\subst.c:5,983
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\subst.c:6,039
parsing error 
{
  char *t, *temp1, *temp2;
  arrayind_t len;
  int expok;
#if defined (ARRAY_VARS)
 ARRAY *a;
 HASH_TABLE *h;
#endif

  /* duplicate behavior of strchr(3) */
  t = skiparith (substr, ':');
  if (*t && *t == ':')
    *t = '\0';
  else
    t = (char *)0;

  temp1 = expand_arith_string (substr, Q_DOUBLE_QUOTES);
  *e1p = evalexp (temp1, &expok);
  free (temp1);
  if (expok == 0)
    return (0);

  len = -1;	/* paranoia */
  switch (vtype)
    {
    case VT_VARIABLE:
    case VT_ARRAYMEMBER:
      len = MB_STRLEN (value);
      break;
    case VT_POSPARMS:
      len = number_of_args () + 1;
      if (*e1p == 0)
	len++;		/* add one arg if counting from $0 */
      break;
#if defined (ARRAY_VARS)
    case VT_ARRAYVAR:
      /* For arrays, the first value deals with array indices.  Negative
	 offsets count from one past the array's maximum index.  Associative
	 arrays treat the number of elements as the maximum index. */
      if (assoc_p (v))
	{
	  h = assoc_cell (v);
	  len = assoc_num_elements (h) + (*e1p < 0);
	}
      else
	{
	  a = (ARRAY *)value;
	  len = array_max_index (a) + (*e1p < 0);	/* arrays index from 0 to n - 1 */
	}
      break;
#endif
    }

  if (len == -1)	/* paranoia */
    return -1;

  if (*e1p < 0)		/* negative offsets count from end */
    *e1p += len;

  if (*e1p > len || *e1p < 0)
    return (-1);

#if defined (ARRAY_VARS)
  /* For arrays, the second offset deals with the number of elements. */
  if (vtype == VT_ARRAYVAR)
    len = assoc_p (v) ? assoc_num_elements (h) : array_num_elements (a);
#endif

  if (t)
    {
      t++;
      temp2 = savestring (t);
      temp1 = expand_arith_string (temp2, Q_DOUBLE_QUOTES);
      free (temp2);
      t[-1] = ':';
      *e2p = evalexp (temp1, &expok);
      free (temp1);
      if (expok == 0)
	return (0);
      if ((vtype == VT_ARRAYVAR || vtype == VT_POSPARMS) && *e2p < 0)
	{
	  internal_error (_("%s: substring expression < 0"), t);
	  return (0);
	}
#if defined (ARRAY_VARS)
      /* In order to deal with sparse arrays, push the intelligence about how
	 to deal with the number of elements desired down to the array-
	 specific functions.  */
      if (vtype != VT_ARRAYVAR)
#endif
	{
	  if (*e2p < 0)
	    {
	      *e2p += len;
	      if (*e2p < 0 || *e2p < *e1p)
		{
		  internal_error (_("%s: substring expression < 0"), t);
		  return (0);
		}
	    }
	  else
	    *e2p += *e1p;		/* want E2 chars starting at E1 */
	  if (*e2p > len)
	    *e2p = len;
	}
    }
  else
    *e2p = len;

  return (1);
}
warning: parse error {
  char *t, *temp1, *temp2;
  arrayind_t len;
  int expok;
#if defined (ARRAY_VARS)
 ARRAY *a;
 HASH_TABLE *h;
#endif

  /* duplicate behavior of strchr(3) */
  t = skiparith (substr, ':');
  if (*t && *t == ':')
    *t = '\0';
  else
    t = (char *)0;

  temp1 = expand_arith_string (substr, Q_DOUBLE_QUOTES);
  *e1p = evalexp (temp1, &expok);
  free (temp1);
  if (expok == 0)
    return (0);

  len = -1;	/* paranoia */
  switch (vtype)
    {
    case VT_VARIABLE:
    case VT_ARRAYMEMBER:
      len = MB_STRLEN (value);
      break;
    case VT_POSPARMS:
      len = number_of_args () + 1;
      if (*e1p == 0)
	len++;		/* add one arg if counting from $0 */
      break;
#if defined (ARRAY_VARS)
    case VT_ARRAYVAR:
      /* For arrays, the first value deals with array indices.  Negative
	 offsets count from one past the array's maximum index.  Associative
	 arrays treat the number of elements as the maximum index. */
      if (assoc_p (v))
	{
	  h = assoc_cell (v);
	  len = assoc_num_elements (h) + (*e1p < 0);
	}
      else
	{
	  a = (ARRAY *)value;
	  len = array_max_index (a) + (*e1p < 0);	/* arrays index from 0 to n - 1 */
	}
      break;
#endif
    }

  if (len == -1)	/* paranoia */
    return -1;

  if (*e1p < 0)		/* negative offsets count from end */
    *e1p += len;

  if (*e1p > len || *e1p < 0)
    return (-1);

#if defined (ARRAY_VARS)
  /* For arrays, the second offset deals with the number of elements. */
  if (vtype == VT_ARRAYVAR)
    len = assoc_p (v) ? assoc_num_elements (h) : array_num_elements (a);
#endif

  if (t)
    {
      t++;
      temp2 = savestring (t);
      temp1 = expand_arith_string (temp2, Q_DOUBLE_QUOTES);
      free (temp2);
      t[-1] = ':';
      *e2p = evalexp (temp1, &expok);
      free (temp1);
      if (expok == 0)
	return (0);
      if ((vtype == VT_ARRAYVAR || vtype == VT_POSPARMS) && *e2p < 0)
	{
	  internal_error (_("%s: substring expression < 0"), t);
	  return (0);
	}
#if defined (ARRAY_VARS)
      /* In order to deal with sparse arrays, push the intelligence about how
	 to deal with the number of elements desired down to the array-
	 specific functions.  */
      if (vtype != VT_ARRAYVAR)
#endif
	{
	  if (*e2p < 0)
	    {
	      *e2p += len;
	      if (*e2p < 0 || *e2p < *e1p)
		{
		  internal_error (_("%s: substring expression < 0"), t);
		  return (0);
		}
	    }
	  else
	    *e2p += *e1p;		/* want E2 chars starting at E1 */
	  if (*e2p > len)
	    *e2p = len;
	}
    }
  else
    *e2p = len;

  return (1);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\subst.c:6,044
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\subst.c:6,167
parsing error 
{
  int vtype;
  char *temp;
#if defined (ARRAY_VARS)
  SHELL_VAR *v;
#endif
  arrayind_t lind;

  /* This sets vtype to VT_VARIABLE or VT_POSPARMS */
  vtype = (varname[0] == '@' || varname[0] == '*') && varname[1] == '\0';
  if (vtype == VT_POSPARMS && varname[0] == '*')
    vtype |= VT_STARSUB;
  *varp = (SHELL_VAR *)NULL;

#if defined (ARRAY_VARS)
  if (valid_array_reference (varname))
    {
      v = array_variable_part (varname, &temp, (int *)0);
      /* If we want to signal array_value to use an already-computed index,
	 set LIND to that index */
      lind = (ind != INTMAX_MIN && (flags & AV_USEIND)) ? ind : 0;
      if (v && (array_p (v) || assoc_p (v)))
	{ /* [ */
	  if (ALL_ELEMENT_SUB (temp[0]) && temp[1] == ']')
	    {
	      /* Callers have to differentiate betwen indexed and associative */
	      vtype = VT_ARRAYVAR;
	      if (temp[0] == '*')
		vtype |= VT_STARSUB;
	      *valp = array_p (v) ? (char *)array_cell (v) : (char *)assoc_cell (v);
	    }
	  else
	    {
	      vtype = VT_ARRAYMEMBER;
	      *valp = array_value (varname, Q_DOUBLE_QUOTES, flags, (int *)NULL, &lind);
	    }
	  *varp = v;
	}
      else if (v && (ALL_ELEMENT_SUB (temp[0]) && temp[1] == ']'))
	{
	  vtype = VT_VARIABLE;
	  *varp = v;
	  if (quoted & (Q_DOUBLE_QUOTES|Q_HERE_DOCUMENT))
	    *valp = dequote_string (value);
	  else
	    *valp = dequote_escapes (value);
	}
      else
	{
	  vtype = VT_ARRAYMEMBER;
	  *varp = v;
	  *valp = array_value (varname, Q_DOUBLE_QUOTES, flags, (int *)NULL, &lind);
	}
    }
  else if ((v = find_variable (varname)) && (invisible_p (v) == 0) && (assoc_p (v) || array_p (v)))
    {
      vtype = VT_ARRAYMEMBER;
      *varp = v;
      *valp = assoc_p (v) ? assoc_reference (assoc_cell (v), "0") : array_reference (array_cell (v), 0);
    }
  else
#endif
    {
      if (value && vtype == VT_VARIABLE)
	{
	  if (quoted & (Q_DOUBLE_QUOTES|Q_HERE_DOCUMENT))
	    *valp = dequote_string (value);
	  else
	    *valp = dequote_escapes (value);
	}
      else
	*valp = value;
    }

  return vtype;
}
warning: parse error {
  int vtype;
  char *temp;
#if defined (ARRAY_VARS)
  SHELL_VAR *v;
#endif
  arrayind_t lind;

  /* This sets vtype to VT_VARIABLE or VT_POSPARMS */
  vtype = (varname[0] == '@' || varname[0] == '*') && varname[1] == '\0';
  if (vtype == VT_POSPARMS && varname[0] == '*')
    vtype |= VT_STARSUB;
  *varp = (SHELL_VAR *)NULL;

#if defined (ARRAY_VARS)
  if (valid_array_reference (varname))
    {
      v = array_variable_part (varname, &temp, (int *)0);
      /* If we want to signal array_value to use an already-computed index,
	 set LIND to that index */
      lind = (ind != INTMAX_MIN && (flags & AV_USEIND)) ? ind : 0;
      if (v && (array_p (v) || assoc_p (v)))
	{ /* [ */
	  if (ALL_ELEMENT_SUB (temp[0]) && temp[1] == ']')
	    {
	      /* Callers have to differentiate betwen indexed and associative */
	      vtype = VT_ARRAYVAR;
	      if (temp[0] == '*')
		vtype |= VT_STARSUB;
	      *valp = array_p (v) ? (char *)array_cell (v) : (char *)assoc_cell (v);
	    }
	  else
	    {
	      vtype = VT_ARRAYMEMBER;
	      *valp = array_value (varname, Q_DOUBLE_QUOTES, flags, (int *)NULL, &lind);
	    }
	  *varp = v;
	}
      else if (v && (ALL_ELEMENT_SUB (temp[0]) && temp[1] == ']'))
	{
	  vtype = VT_VARIABLE;
	  *varp = v;
	  if (quoted & (Q_DOUBLE_QUOTES|Q_HERE_DOCUMENT))
	    *valp = dequote_string (value);
	  else
	    *valp = dequote_escapes (value);
	}
      else
	{
	  vtype = VT_ARRAYMEMBER;
	  *varp = v;
	  *valp = array_value (varname, Q_DOUBLE_QUOTES, flags, (int *)NULL, &lind);
	}
    }
  else if ((v = find_variable (varname)) && (invisible_p (v) == 0) && (assoc_p (v) || array_p (v)))
    {
      vtype = VT_ARRAYMEMBER;
      *varp = v;
      *valp = assoc_p (v) ? assoc_reference (assoc_cell (v), "0") : array_reference (array_cell (v), 0);
    }
  else
#endif
    {
      if (value && vtype == VT_VARIABLE)
	{
	  if (quoted & (Q_DOUBLE_QUOTES|Q_HERE_DOCUMENT))
	    *valp = dequote_string (value);
	  else
	    *valp = dequote_escapes (value);
	}
      else
	*valp = value;
    }

  return vtype;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\subst.c:6,173
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\subst.c:6,291
parsing error 
{
  intmax_t e1, e2;
  int vtype, r, starsub;
  char *temp, *val, *tt, *oname;
  SHELL_VAR *v;

  if (value == 0)
    return ((char *)NULL);

  oname = this_command_name;
  this_command_name = varname;

  vtype = get_var_and_type (varname, value, ind, quoted, flags, &v, &val);
  if (vtype == -1)
    {
      this_command_name = oname;
      return ((char *)NULL);
    }

  starsub = vtype & VT_STARSUB;
  vtype &= ~VT_STARSUB;

  r = verify_substring_values (v, val, substr, vtype, &e1, &e2);
  this_command_name = oname;
  if (r <= 0)
    return ((r == 0) ? &expand_param_error : (char *)NULL);

  switch (vtype)
    {
    case VT_VARIABLE:
    case VT_ARRAYMEMBER:
#if defined (HANDLE_MULTIBYTE)
      if (MB_CUR_MAX > 1)
	tt = mb_substring (val, e1, e2);
      else
#endif
      tt = substring (val, e1, e2);

      if (vtype == VT_VARIABLE)
	FREE (val);
      if (quoted & (Q_DOUBLE_QUOTES|Q_HERE_DOCUMENT))
	temp = quote_string (tt);
      else
	temp = tt ? quote_escapes (tt) : (char *)NULL;
      FREE (tt);
      break;
    case VT_POSPARMS:
      tt = pos_params (varname, e1, e2, quoted);
      if ((quoted & (Q_DOUBLE_QUOTES|Q_HERE_DOCUMENT)) == 0)
	{
	  temp = tt ? quote_escapes (tt) : (char *)NULL;
	  FREE (tt);
	}
      else
	temp = tt;
      break;
#if defined (ARRAY_VARS)
    case VT_ARRAYVAR:
      if (assoc_p (v))
	/* we convert to list and take first e2 elements starting at e1th
	   element -- officially undefined for now */	
	temp = assoc_subrange (assoc_cell (v), e1, e2, starsub, quoted);
      else
      /* We want E2 to be the number of elements desired (arrays can be sparse,
	 so verify_substring_values just returns the numbers specified and we
	 rely on array_subrange to understand how to deal with them). */
	temp = array_subrange (array_cell (v), e1, e2, starsub, quoted);
      /* array_subrange now calls array_quote_escapes as appropriate, so the
	 caller no longer needs to. */
      break;
#endif
    default:
      temp = (char *)NULL;
    }

  return temp;
}
warning: parse error {
  intmax_t e1, e2;
  int vtype, r, starsub;
  char *temp, *val, *tt, *oname;
  SHELL_VAR *v;

  if (value == 0)
    return ((char *)NULL);

  oname = this_command_name;
  this_command_name = varname;

  vtype = get_var_and_type (varname, value, ind, quoted, flags, &v, &val);
  if (vtype == -1)
    {
      this_command_name = oname;
      return ((char *)NULL);
    }

  starsub = vtype & VT_STARSUB;
  vtype &= ~VT_STARSUB;

  r = verify_substring_values (v, val, substr, vtype, &e1, &e2);
  this_command_name = oname;
  if (r <= 0)
    return ((r == 0) ? &expand_param_error : (char *)NULL);

  switch (vtype)
    {
    case VT_VARIABLE:
    case VT_ARRAYMEMBER:
#if defined (HANDLE_MULTIBYTE)
      if (MB_CUR_MAX > 1)
	tt = mb_substring (val, e1, e2);
      else
#endif
      tt = substring (val, e1, e2);

      if (vtype == VT_VARIABLE)
	FREE (val);
      if (quoted & (Q_DOUBLE_QUOTES|Q_HERE_DOCUMENT))
	temp = quote_string (tt);
      else
	temp = tt ? quote_escapes (tt) : (char *)NULL;
      FREE (tt);
      break;
    case VT_POSPARMS:
      tt = pos_params (varname, e1, e2, quoted);
      if ((quoted & (Q_DOUBLE_QUOTES|Q_HERE_DOCUMENT)) == 0)
	{
	  temp = tt ? quote_escapes (tt) : (char *)NULL;
	  FREE (tt);
	}
      else
	temp = tt;
      break;
#if defined (ARRAY_VARS)
    case VT_ARRAYVAR:
      if (assoc_p (v))
	/* we convert to list and take first e2 elements starting at e1th
	   element -- officially undefined for now */	
	temp = assoc_subrange (assoc_cell (v), e1, e2, starsub, quoted);
      else
      /* We want E2 to be the number of elements desired (arrays can be sparse,
	 so verify_substring_values just returns the numbers specified and we
	 rely on array_subrange to understand how to deal with them). */
	temp = array_subrange (array_cell (v), e1, e2, starsub, quoted);
      /* array_subrange now calls array_quote_escapes as appropriate, so the
	 caller no longer needs to. */
      break;
#endif
    default:
      temp = (char *)NULL;
    }

  return temp;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\subst.c:6,296
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\subst.c:6,381
parsing error 
{
  register char *p;

  for (p = s; p && *p; p++)
    {
      if (*p == '\\')
	p++;
      else if (*p == '&')
	return 1;
    }
  return 0;
}
warning: parse error {
  register char *p;

  for (p = s; p && *p; p++)
    {
      if (*p == '\\')
	p++;
      else if (*p == '&')
	return 1;
    }
  return 0;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\subst.c:6,383
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\subst.c:6,397
parsing error 
{
  char *ret, *s, *e, *str, *rstr, *mstr;
  int rsize, rptr, l, replen, mtype, rxpand, rslen, mlen;

  if (string  == 0)
    return (savestring (""));

  mtype = mflags & MATCH_TYPEMASK;

#if 0	/* bash-4.2 ? */
  rxpand = (rep && *rep) ? shouldexp_replacement (rep) : 0;
#else
  rxpand = 0;
#endif

  /* Special cases:
   * 	1.  A null pattern with mtype == MATCH_BEG means to prefix STRING
   *	    with REP and return the result.
   *	2.  A null pattern with mtype == MATCH_END means to append REP to
   *	    STRING and return the result.
   * These don't understand or process `&' in the replacement string.
   */
  if ((pat == 0 || *pat == 0) && (mtype == MATCH_BEG || mtype == MATCH_END))
    {
      replen = STRLEN (rep);
      l = STRLEN (string);
      ret = (char *)xmalloc (replen + l + 2);
      if (replen == 0)
	strcpy (ret, string);
      else if (mtype == MATCH_BEG)
	{
	  strcpy (ret, rep);
	  strcpy (ret + replen, string);
	}
      else
	{
	  strcpy (ret, string);
	  strcpy (ret + l, rep);
	}
      return (ret);
    }

  ret = (char *)xmalloc (rsize = 64);
  ret[0] = '\0';

  for (replen = STRLEN (rep), rptr = 0, str = string;;)
    {
      if (match_pattern (str, pat, mtype, &s, &e) == 0)
	break;
      l = s - str;

      if (rxpand)
        {
          int x;
          mlen = e - s;
          mstr = xmalloc (mlen + 1);
	  for (x = 0; x < mlen; x++)
	    mstr[x] = s[x];
          mstr[mlen] = '\0';
          rstr = strcreplace (rep, '&', mstr, 0);
          rslen = strlen (rstr);
        }
      else
        {
          rstr = rep;
          rslen = replen;
        }
        
      RESIZE_MALLOCED_BUFFER (ret, rptr, (l + rslen), rsize, 64);

      /* OK, now copy the leading unmatched portion of the string (from
	 str to s) to ret starting at rptr (the current offset).  Then copy
	 the replacement string at ret + rptr + (s - str).  Increment
	 rptr (if necessary) and str and go on. */
      if (l)
	{
	  strncpy (ret + rptr, str, l);
	  rptr += l;
	}
      if (replen)
	{
	  strncpy (ret + rptr, rstr, rslen);
	  rptr += rslen;
	}
      str = e;		/* e == end of match */

      if (rstr != rep)
	free (rstr);

      if (((mflags & MATCH_GLOBREP) == 0) || mtype != MATCH_ANY)
	break;

      if (s == e)
	{
	  /* On a zero-length match, make sure we copy one character, since
	     we increment one character to avoid infinite recursion. */
	  RESIZE_MALLOCED_BUFFER (ret, rptr, 1, rsize, 64);
	  ret[rptr++] = *str++;
	  e++;		/* avoid infinite recursion on zero-length match */
	}
    }

  /* Now copy the unmatched portion of the input string */
  if (str && *str)
    {
      RESIZE_MALLOCED_BUFFER (ret, rptr, STRLEN(str) + 1, rsize, 64);
      strcpy (ret + rptr, str);
    }
  else
    ret[rptr] = '\0';

  return ret;
}
warning: parse error {
  char *ret, *s, *e, *str, *rstr, *mstr;
  int rsize, rptr, l, replen, mtype, rxpand, rslen, mlen;

  if (string  == 0)
    return (savestring (""));

  mtype = mflags & MATCH_TYPEMASK;

#if 0	/* bash-4.2 ? */
  rxpand = (rep && *rep) ? shouldexp_replacement (rep) : 0;
#else
  rxpand = 0;
#endif

  /* Special cases:
   * 	1.  A null pattern with mtype == MATCH_BEG means to prefix STRING
   *	    with REP and return the result.
   *	2.  A null pattern with mtype == MATCH_END means to append REP to
   *	    STRING and return the result.
   * These don't understand or process `&' in the replacement string.
   */
  if ((pat == 0 || *pat == 0) && (mtype == MATCH_BEG || mtype == MATCH_END))
    {
      replen = STRLEN (rep);
      l = STRLEN (string);
      ret = (char *)xmalloc (replen + l + 2);
      if (replen == 0)
	strcpy (ret, string);
      else if (mtype == MATCH_BEG)
	{
	  strcpy (ret, rep);
	  strcpy (ret + replen, string);
	}
      else
	{
	  strcpy (ret, string);
	  strcpy (ret + l, rep);
	}
      return (ret);
    }

  ret = (char *)xmalloc (rsize = 64);
  ret[0] = '\0';

  for (replen = STRLEN (rep), rptr = 0, str = string;;)
    {
      if (match_pattern (str, pat, mtype, &s, &e) == 0)
	break;
      l = s - str;

      if (rxpand)
        {
          int x;
          mlen = e - s;
          mstr = xmalloc (mlen + 1);
	  for (x = 0; x < mlen; x++)
	    mstr[x] = s[x];
          mstr[mlen] = '\0';
          rstr = strcreplace (rep, '&', mstr, 0);
          rslen = strlen (rstr);
        }
      else
        {
          rstr = rep;
          rslen = replen;
        }
        
      RESIZE_MALLOCED_BUFFER (ret, rptr, (l + rslen), rsize, 64);

      /* OK, now copy the leading unmatched portion of the string (from
	 str to s) to ret starting at rptr (the current offset).  Then copy
	 the replacement string at ret + rptr + (s - str).  Increment
	 rptr (if necessary) and str and go on. */
      if (l)
	{
	  strncpy (ret + rptr, str, l);
	  rptr += l;
	}
      if (replen)
	{
	  strncpy (ret + rptr, rstr, rslen);
	  rptr += rslen;
	}
      str = e;		/* e == end of match */

      if (rstr != rep)
	free (rstr);

      if (((mflags & MATCH_GLOBREP) == 0) || mtype != MATCH_ANY)
	break;

      if (s == e)
	{
	  /* On a zero-length match, make sure we copy one character, since
	     we increment one character to avoid infinite recursion. */
	  RESIZE_MALLOCED_BUFFER (ret, rptr, 1, rsize, 64);
	  ret[rptr++] = *str++;
	  e++;		/* avoid infinite recursion on zero-length match */
	}
    }

  /* Now copy the unmatched portion of the input string */
  if (str && *str)
    {
      RESIZE_MALLOCED_BUFFER (ret, rptr, STRLEN(str) + 1, rsize, 64);
      strcpy (ret + rptr, str);
    }
  else
    ret[rptr] = '\0';

  return ret;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\subst.c:6,400
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\subst.c:6,516
parsing error 
{
  WORD_LIST *save, *params;
  WORD_DESC *w;
  char *ret;
  int pchar, qflags;

  save = params = list_rest_of_args ();
  if (save == 0)
    return ((char *)NULL);

  for ( ; params; params = params->next)
    {
      ret = pat_subst (params->word->word, pat, rep, mflags);
      w = alloc_word_desc ();
      w->word = ret ? ret : savestring ("");
      dispose_word (params->word);
      params->word = w;
    }

  pchar = (mflags & MATCH_STARSUB) == MATCH_STARSUB ? '*' : '@';
  qflags = (mflags & MATCH_QUOTED) == MATCH_QUOTED ? Q_DOUBLE_QUOTES : 0;

#if 0
  if ((mflags & (MATCH_QUOTED|MATCH_STARSUB)) == (MATCH_QUOTED|MATCH_STARSUB))
    ret = string_list_dollar_star (quote_list (save));
  else if ((mflags & MATCH_STARSUB) == MATCH_STARSUB)
    ret = string_list_dollar_star (save);
  else if ((mflags & MATCH_QUOTED) == MATCH_QUOTED)
    ret = string_list_dollar_at (save, qflags);
  else
    ret = string_list_dollar_star (save);
#else
  ret = string_list_pos_params (pchar, save, qflags);
#endif

  dispose_words (save);

  return (ret);
}
warning: parse error {
  WORD_LIST *save, *params;
  WORD_DESC *w;
  char *ret;
  int pchar, qflags;

  save = params = list_rest_of_args ();
  if (save == 0)
    return ((char *)NULL);

  for ( ; params; params = params->next)
    {
      ret = pat_subst (params->word->word, pat, rep, mflags);
      w = alloc_word_desc ();
      w->word = ret ? ret : savestring ("");
      dispose_word (params->word);
      params->word = w;
    }

  pchar = (mflags & MATCH_STARSUB) == MATCH_STARSUB ? '*' : '@';
  qflags = (mflags & MATCH_QUOTED) == MATCH_QUOTED ? Q_DOUBLE_QUOTES : 0;

#if 0
  if ((mflags & (MATCH_QUOTED|MATCH_STARSUB)) == (MATCH_QUOTED|MATCH_STARSUB))
    ret = string_list_dollar_star (quote_list (save));
  else if ((mflags & MATCH_STARSUB) == MATCH_STARSUB)
    ret = string_list_dollar_star (save);
  else if ((mflags & MATCH_QUOTED) == MATCH_QUOTED)
    ret = string_list_dollar_at (save, qflags);
  else
    ret = string_list_dollar_star (save);
#else
  ret = string_list_pos_params (pchar, save, qflags);
#endif

  dispose_words (save);

  return (ret);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\subst.c:6,519
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\subst.c:6,564
parsing error 
{
  int vtype, mflags, starsub, delim;
  char *val, *temp, *pat, *rep, *p, *lpatsub, *tt;
  SHELL_VAR *v;

  if (value == 0)
    return ((char *)NULL);

  this_command_name = varname;

  vtype = get_var_and_type (varname, value, ind, quoted, flags, &v, &val);
  if (vtype == -1)
    return ((char *)NULL);

  starsub = vtype & VT_STARSUB;
  vtype &= ~VT_STARSUB;

  mflags = 0;
  if (patsub && *patsub == '/')
    {
      mflags |= MATCH_GLOBREP;
      patsub++;
    }

  /* Malloc this because expand_string_if_necessary or one of the expansion
     functions in its call chain may free it on a substitution error. */
  lpatsub = savestring (patsub);

  if (quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES))
    mflags |= MATCH_QUOTED;

  if (starsub)
    mflags |= MATCH_STARSUB;

  /* If the pattern starts with a `/', make sure we skip over it when looking
     for the replacement delimiter. */
#if 0
  if (rep = quoted_strchr ((*patsub == '/') ? lpatsub+1 : lpatsub, '/', ST_BACKSL))
    *rep++ = '\0';
  else
    rep = (char *)NULL;
#else
  delim = skip_to_delim (lpatsub, ((*patsub == '/') ? 1 : 0), "/", 0);
  if (lpatsub[delim] == '/')
    {
      lpatsub[delim] = 0;
      rep = lpatsub + delim + 1;
    }
  else
    rep = (char *)NULL;
#endif

  if (rep && *rep == '\0')
    rep = (char *)NULL;

  /* Perform the same expansions on the pattern as performed by the
     pattern removal expansions. */
  pat = getpattern (lpatsub, quoted, 1);

  if (rep)
    {
      if ((mflags & MATCH_QUOTED) == 0)
	rep = expand_string_if_necessary (rep, quoted, expand_string_unsplit);
      else
	rep = expand_string_to_string_internal (rep, quoted, expand_string_unsplit);
    }

  /* ksh93 doesn't allow the match specifier to be a part of the expanded
     pattern.  This is an extension.  Make sure we don't anchor the pattern
     at the beginning or end of the string if we're doing global replacement,
     though. */
  p = pat;
  if (mflags & MATCH_GLOBREP)
    mflags |= MATCH_ANY;
  else if (pat && pat[0] == '#')
    {
      mflags |= MATCH_BEG;
      p++;
    }
  else if (pat && pat[0] == '%')
    {
      mflags |= MATCH_END;
      p++;
    }
  else
    mflags |= MATCH_ANY;

  /* OK, we now want to substitute REP for PAT in VAL.  If
     flags & MATCH_GLOBREP is non-zero, the substitution is done
     everywhere, otherwise only the first occurrence of PAT is
     replaced.  The pattern matching code doesn't understand
     CTLESC quoting CTLESC and CTLNUL so we use the dequoted variable
     values passed in (VT_VARIABLE) so the pattern substitution
     code works right.  We need to requote special chars after
     we're done for VT_VARIABLE and VT_ARRAYMEMBER, and for the
     other cases if QUOTED == 0, since the posparams and arrays
     indexed by * or @ do special things when QUOTED != 0. */

  switch (vtype)
    {
    case VT_VARIABLE:
    case VT_ARRAYMEMBER:
      temp = pat_subst (val, p, rep, mflags);
      if (vtype == VT_VARIABLE)
	FREE (val);
      if (temp)
	{
	  tt = (mflags & MATCH_QUOTED) ? quote_string (temp) : quote_escapes (temp);
	  free (temp);
	  temp = tt;
	}
      break;
    case VT_POSPARMS:
      temp = pos_params_pat_subst (val, p, rep, mflags);
      if (temp && (mflags & MATCH_QUOTED) == 0)
	{
	  tt = quote_escapes (temp);
	  free (temp);
	  temp = tt;
	}
      break;
#if defined (ARRAY_VARS)
    case VT_ARRAYVAR:
      temp = assoc_p (v) ? assoc_patsub (assoc_cell (v), p, rep, mflags)
			 : array_patsub (array_cell (v), p, rep, mflags);
      /* Don't call quote_escapes anymore; array_patsub calls
	 array_quote_escapes as appropriate before adding the
	 space separators; ditto for assoc_patsub. */
      break;
#endif
    }

  FREE (pat);
  FREE (rep);
  free (lpatsub);

  return temp;
}
warning: parse error {
  int vtype, mflags, starsub, delim;
  char *val, *temp, *pat, *rep, *p, *lpatsub, *tt;
  SHELL_VAR *v;

  if (value == 0)
    return ((char *)NULL);

  this_command_name = varname;

  vtype = get_var_and_type (varname, value, ind, quoted, flags, &v, &val);
  if (vtype == -1)
    return ((char *)NULL);

  starsub = vtype & VT_STARSUB;
  vtype &= ~VT_STARSUB;

  mflags = 0;
  if (patsub && *patsub == '/')
    {
      mflags |= MATCH_GLOBREP;
      patsub++;
    }

  /* Malloc this because expand_string_if_necessary or one of the expansion
     functions in its call chain may free it on a substitution error. */
  lpatsub = savestring (patsub);

  if (quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES))
    mflags |= MATCH_QUOTED;

  if (starsub)
    mflags |= MATCH_STARSUB;

  /* If the pattern starts with a `/', make sure we skip over it when looking
     for the replacement delimiter. */
#if 0
  if (rep = quoted_strchr ((*patsub == '/') ? lpatsub+1 : lpatsub, '/', ST_BACKSL))
    *rep++ = '\0';
  else
    rep = (char *)NULL;
#else
  delim = skip_to_delim (lpatsub, ((*patsub == '/') ? 1 : 0), "/", 0);
  if (lpatsub[delim] == '/')
    {
      lpatsub[delim] = 0;
      rep = lpatsub + delim + 1;
    }
  else
    rep = (char *)NULL;
#endif

  if (rep && *rep == '\0')
    rep = (char *)NULL;

  /* Perform the same expansions on the pattern as performed by the
     pattern removal expansions. */
  pat = getpattern (lpatsub, quoted, 1);

  if (rep)
    {
      if ((mflags & MATCH_QUOTED) == 0)
	rep = expand_string_if_necessary (rep, quoted, expand_string_unsplit);
      else
	rep = expand_string_to_string_internal (rep, quoted, expand_string_unsplit);
    }

  /* ksh93 doesn't allow the match specifier to be a part of the expanded
     pattern.  This is an extension.  Make sure we don't anchor the pattern
     at the beginning or end of the string if we're doing global replacement,
     though. */
  p = pat;
  if (mflags & MATCH_GLOBREP)
    mflags |= MATCH_ANY;
  else if (pat && pat[0] == '#')
    {
      mflags |= MATCH_BEG;
      p++;
    }
  else if (pat && pat[0] == '%')
    {
      mflags |= MATCH_END;
      p++;
    }
  else
    mflags |= MATCH_ANY;

  /* OK, we now want to substitute REP for PAT in VAL.  If
     flags & MATCH_GLOBREP is non-zero, the substitution is done
     everywhere, otherwise only the first occurrence of PAT is
     replaced.  The pattern matching code doesn't understand
     CTLESC quoting CTLESC and CTLNUL so we use the dequoted variable
     values passed in (VT_VARIABLE) so the pattern substitution
     code works right.  We need to requote special chars after
     we're done for VT_VARIABLE and VT_ARRAYMEMBER, and for the
     other cases if QUOTED == 0, since the posparams and arrays
     indexed by * or @ do special things when QUOTED != 0. */

  switch (vtype)
    {
    case VT_VARIABLE:
    case VT_ARRAYMEMBER:
      temp = pat_subst (val, p, rep, mflags);
      if (vtype == VT_VARIABLE)
	FREE (val);
      if (temp)
	{
	  tt = (mflags & MATCH_QUOTED) ? quote_string (temp) : quote_escapes (temp);
	  free (temp);
	  temp = tt;
	}
      break;
    case VT_POSPARMS:
      temp = pos_params_pat_subst (val, p, rep, mflags);
      if (temp && (mflags & MATCH_QUOTED) == 0)
	{
	  tt = quote_escapes (temp);
	  free (temp);
	  temp = tt;
	}
      break;
#if defined (ARRAY_VARS)
    case VT_ARRAYVAR:
      temp = assoc_p (v) ? assoc_patsub (assoc_cell (v), p, rep, mflags)
			 : array_patsub (array_cell (v), p, rep, mflags);
      /* Don't call quote_escapes anymore; array_patsub calls
	 array_quote_escapes as appropriate before adding the
	 space separators; ditto for assoc_patsub. */
      break;
#endif
    }

  FREE (pat);
  FREE (rep);
  free (lpatsub);

  return temp;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\subst.c:6,569
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\subst.c:6,717
parsing error 
{
  WORD_LIST *save, *params;
  WORD_DESC *w;
  char *ret;
  int pchar, qflags;

  save = params = list_rest_of_args ();
  if (save == 0)
    return ((char *)NULL);

  for ( ; params; params = params->next)
    {
      ret = sh_modcase (params->word->word, pat, modop);
      w = alloc_word_desc ();
      w->word = ret ? ret : savestring ("");
      dispose_word (params->word);
      params->word = w;
    }

  pchar = (mflags & MATCH_STARSUB) == MATCH_STARSUB ? '*' : '@';
  qflags = (mflags & MATCH_QUOTED) == MATCH_QUOTED ? Q_DOUBLE_QUOTES : 0;

  ret = string_list_pos_params (pchar, save, qflags);
  dispose_words (save);

  return (ret);
}
warning: parse error {
  WORD_LIST *save, *params;
  WORD_DESC *w;
  char *ret;
  int pchar, qflags;

  save = params = list_rest_of_args ();
  if (save == 0)
    return ((char *)NULL);

  for ( ; params; params = params->next)
    {
      ret = sh_modcase (params->word->word, pat, modop);
      w = alloc_word_desc ();
      w->word = ret ? ret : savestring ("");
      dispose_word (params->word);
      params->word = w;
    }

  pchar = (mflags & MATCH_STARSUB) == MATCH_STARSUB ? '*' : '@';
  qflags = (mflags & MATCH_QUOTED) == MATCH_QUOTED ? Q_DOUBLE_QUOTES : 0;

  ret = string_list_pos_params (pchar, save, qflags);
  dispose_words (save);

  return (ret);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\subst.c:6,721
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\subst.c:6,754
parsing error 
{
  int vtype, starsub, modop, mflags, x;
  char *val, *temp, *pat, *p, *lpat, *tt;
  SHELL_VAR *v;

  if (value == 0)
    return ((char *)NULL);

  this_command_name = varname;

  vtype = get_var_and_type (varname, value, ind, quoted, flags, &v, &val);
  if (vtype == -1)
    return ((char *)NULL);

  starsub = vtype & VT_STARSUB;
  vtype &= ~VT_STARSUB;

  modop = 0;
  mflags = 0;
  if (quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES))
    mflags |= MATCH_QUOTED;
  if (starsub)
    mflags |= MATCH_STARSUB;
  
  p = patspec;
  if (modspec == '^')
    {
      x = p && p[0] == modspec;
      modop = x ? CASE_UPPER : CASE_UPFIRST;
      p += x;
    }
  else if (modspec == ',')
    {
      x = p && p[0] == modspec;
      modop = x ? CASE_LOWER : CASE_LOWFIRST;
      p += x;
    }
  else if (modspec == '~')
    {
      x = p && p[0] == modspec;
      modop = x ? CASE_TOGGLEALL : CASE_TOGGLE;
      p += x;
    }
    
  lpat = p ? savestring (p) : 0;
  /* Perform the same expansions on the pattern as performed by the
     pattern removal expansions.  FOR LATER */
  pat = lpat ? getpattern (lpat, quoted, 1) : 0;

  /* OK, now we do the case modification. */
  switch (vtype)
    {
    case VT_VARIABLE:
    case VT_ARRAYMEMBER:
      temp = sh_modcase (val, pat, modop);
      if (vtype == VT_VARIABLE)
	FREE (val);
      if (temp)
	{
	  tt = (mflags & MATCH_QUOTED) ? quote_string (temp) : quote_escapes (temp);
	  free (temp);
	  temp = tt;
	}
      break;

    case VT_POSPARMS:
      temp = pos_params_modcase (val, pat, modop, mflags);
      if (temp && (mflags & MATCH_QUOTED)  == 0)
	{
	  tt = quote_escapes (temp);
	  free (temp);
	  temp = tt;
	}
      break;

#if defined (ARRAY_VARS)
    case VT_ARRAYVAR:
      temp = assoc_p (v) ? assoc_modcase (assoc_cell (v), pat, modop, mflags)
			 : array_modcase (array_cell (v), pat, modop, mflags);
      /* Don't call quote_escapes; array_modcase calls array_quote_escapes
	 as appropriate before adding the space separators; ditto for
	 assoc_modcase. */
      break;
#endif
    }

  FREE (pat);
  free (lpat);

  return temp;
}
warning: parse error {
  int vtype, starsub, modop, mflags, x;
  char *val, *temp, *pat, *p, *lpat, *tt;
  SHELL_VAR *v;

  if (value == 0)
    return ((char *)NULL);

  this_command_name = varname;

  vtype = get_var_and_type (varname, value, ind, quoted, flags, &v, &val);
  if (vtype == -1)
    return ((char *)NULL);

  starsub = vtype & VT_STARSUB;
  vtype &= ~VT_STARSUB;

  modop = 0;
  mflags = 0;
  if (quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES))
    mflags |= MATCH_QUOTED;
  if (starsub)
    mflags |= MATCH_STARSUB;
  
  p = patspec;
  if (modspec == '^')
    {
      x = p && p[0] == modspec;
      modop = x ? CASE_UPPER : CASE_UPFIRST;
      p += x;
    }
  else if (modspec == ',')
    {
      x = p && p[0] == modspec;
      modop = x ? CASE_LOWER : CASE_LOWFIRST;
      p += x;
    }
  else if (modspec == '~')
    {
      x = p && p[0] == modspec;
      modop = x ? CASE_TOGGLEALL : CASE_TOGGLE;
      p += x;
    }
    
  lpat = p ? savestring (p) : 0;
  /* Perform the same expansions on the pattern as performed by the
     pattern removal expansions.  FOR LATER */
  pat = lpat ? getpattern (lpat, quoted, 1) : 0;

  /* OK, now we do the case modification. */
  switch (vtype)
    {
    case VT_VARIABLE:
    case VT_ARRAYMEMBER:
      temp = sh_modcase (val, pat, modop);
      if (vtype == VT_VARIABLE)
	FREE (val);
      if (temp)
	{
	  tt = (mflags & MATCH_QUOTED) ? quote_string (temp) : quote_escapes (temp);
	  free (temp);
	  temp = tt;
	}
      break;

    case VT_POSPARMS:
      temp = pos_params_modcase (val, pat, modop, mflags);
      if (temp && (mflags & MATCH_QUOTED)  == 0)
	{
	  tt = quote_escapes (temp);
	  free (temp);
	  temp = tt;
	}
      break;

#if defined (ARRAY_VARS)
    case VT_ARRAYVAR:
      temp = assoc_p (v) ? assoc_modcase (assoc_cell (v), pat, modop, mflags)
			 : array_modcase (array_cell (v), pat, modop, mflags);
      /* Don't call quote_escapes; array_modcase calls array_quote_escapes
	 as appropriate before adding the space separators; ditto for
	 assoc_modcase. */
      break;
#endif
    }

  FREE (pat);
  free (lpat);

  return temp;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\subst.c:6,759
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\subst.c:6,859
parsing error 
{
  int i, count;
  DECLARE_MBSTATE;

  i = count = 0;
  while (i < len)
    {
      if (s[i] == LPAREN)
	count++;
      else if (s[i] == RPAREN)
	{
	  count--;
	  if (count < 0)
	    return 0;
	}

      switch (s[i])
	{
	default:
	  ADVANCE_CHAR (s, len, i);
	  break;

	case '\\':
	  i++;
	  if (s[i])
	    ADVANCE_CHAR (s, len, i);
	  break;

	case '\'':
	  i = skip_single_quoted (s, len, ++i);
	  break;

	case '"':
	  i = skip_double_quoted ((char *)s, len, ++i);
	  break;
	}
    }

  return (count == 0);
}
warning: parse error {
  int i, count;
  DECLARE_MBSTATE;

  i = count = 0;
  while (i < len)
    {
      if (s[i] == LPAREN)
	count++;
      else if (s[i] == RPAREN)
	{
	  count--;
	  if (count < 0)
	    return 0;
	}

      switch (s[i])
	{
	default:
	  ADVANCE_CHAR (s, len, i);
	  break;

	case '\\':
	  i++;
	  if (s[i])
	    ADVANCE_CHAR (s, len, i);
	  break;

	case '\'':
	  i = skip_single_quoted (s, len, ++i);
	  break;

	case '"':
	  i = skip_double_quoted ((char *)s, len, ++i);
	  break;
	}
    }

  return (count == 0);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\subst.c:6,861
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\subst.c:6,910
parsing error 
{
  int check_nullness, var_is_set, var_is_null, var_is_special;
  int want_substring, want_indir, want_patsub, want_casemod;
  char *name, *value, *temp, *temp1;
  WORD_DESC *tdesc, *ret;
  int t_index, sindex, c, tflag, modspec;
  intmax_t number;
  arrayind_t ind;

  temp = temp1 = value = (char *)NULL;
  var_is_set = var_is_null = var_is_special = check_nullness = 0;
  want_substring = want_indir = want_patsub = want_casemod = 0;

  sindex = *indexp;
  t_index = ++sindex;
  /* ${#var} doesn't have any of the other parameter expansions on it. */
  if (string[t_index] == '#' && legal_variable_starter (string[t_index+1]))		/* {{ */
    name = string_extract (string, &t_index, "}", SX_VARNAME);
  else
#if defined (CASEMOD_EXPANSIONS)
    /* To enable case-toggling expansions using the `~' operator character
       change the 1 to 0. */
#  if defined (CASEMOD_CAPCASE)
    name = string_extract (string, &t_index, "#%^,~:-=?+/}", SX_VARNAME);
#  else
    name = string_extract (string, &t_index, "#%^,:-=?+/}", SX_VARNAME);
#  endif /* CASEMOD_CAPCASE */
#else
    name = string_extract (string, &t_index, "#%:-=?+/}", SX_VARNAME);
#endif /* CASEMOD_EXPANSIONS */

  ret = 0;
  tflag = 0;

  ind = INTMAX_MIN;

  /* If the name really consists of a special variable, then make sure
     that we have the entire name.  We don't allow indirect references
     to special variables except `#', `?', `@' and `*'. */
  if ((sindex == t_index && VALID_SPECIAL_LENGTH_PARAM (string[t_index])) ||
      (sindex == t_index - 1 && string[sindex] == '!' && VALID_INDIR_PARAM (string[t_index])))
    {
      t_index++;
      free (name);
      temp1 = string_extract (string, &t_index, "#%:-=?+/}", 0);
      name = (char *)xmalloc (3 + (strlen (temp1)));
      *name = string[sindex];
      if (string[sindex] == '!')
	{
	  /* indirect reference of $#, $?, $@, or $* */
	  name[1] = string[sindex + 1];
	  strcpy (name + 2, temp1);
	}
      else	
	strcpy (name + 1, temp1);
      free (temp1);
    }
  sindex = t_index;

  /* Find out what character ended the variable name.  Then
     do the appropriate thing. */
  if (c = string[sindex])
    sindex++;

  /* If c is followed by one of the valid parameter expansion
     characters, move past it as normal.  If not, assume that
     a substring specification is being given, and do not move
     past it. */
  if (c == ':' && VALID_PARAM_EXPAND_CHAR (string[sindex]))
    {
      check_nullness++;
      if (c = string[sindex])
	sindex++;
    }
  else if (c == ':' && string[sindex] != RBRACE)
    want_substring = 1;
  else if (c == '/' && string[sindex] != RBRACE)
    want_patsub = 1;
#if defined (CASEMOD_EXPANSIONS)
  else if (c == '^' || c == ',' || c == '~')
    {
      modspec = c;
      want_casemod = 1;
    }
#endif

  /* Catch the valid and invalid brace expressions that made it through the
     tests above. */
  /* ${#-} is a valid expansion and means to take the length of $-.
     Similarly for ${#?} and ${##}... */
  if (name[0] == '#' && name[1] == '\0' && check_nullness == 0 &&
	VALID_SPECIAL_LENGTH_PARAM (c) && string[sindex] == RBRACE)
    {
      name = (char *)xrealloc (name, 3);
      name[1] = c;
      name[2] = '\0';
      c = string[sindex++];
    }

  /* ...but ${#%}, ${#:}, ${#=}, ${#+}, and ${#/} are errors. */
  if (name[0] == '#' && name[1] == '\0' && check_nullness == 0 &&
	member (c, "%:=+/") && string[sindex] == RBRACE)
    {
      temp = (char *)NULL;
      goto bad_substitution;
    }

  /* Indirect expansion begins with a `!'.  A valid indirect expansion is
     either a variable name, one of the positional parameters or a special
     variable that expands to one of the positional parameters. */
  want_indir = *name == '!' &&
    (legal_variable_starter ((unsigned char)name[1]) || DIGIT (name[1])
					|| VALID_INDIR_PARAM (name[1]));

  /* Determine the value of this variable. */

  /* Check for special variables, directly referenced. */
  if (SPECIAL_VAR (name, want_indir))
    var_is_special++;

  /* Check for special expansion things, like the length of a parameter */
  if (*name == '#' && name[1])
    {
      /* If we are not pointing at the character just after the
	 closing brace, then we haven't gotten all of the name.
	 Since it begins with a special character, this is a bad
	 substitution.  Also check NAME for validity before trying
	 to go on. */
      if (string[sindex - 1] != RBRACE || (valid_length_expression (name) == 0))
	{
	  temp = (char *)NULL;
	  goto bad_substitution;
	}

      number = parameter_brace_expand_length (name);
      if (number == INTMAX_MIN && unbound_vars_is_error)
	{
	  last_command_exit_value = EXECUTION_FAILURE;
	  err_unboundvar (name+1);
	  free (name);
	  return (interactive_shell ? &expand_wdesc_error : &expand_wdesc_fatal);
	}
      free (name);

      *indexp = sindex;
      if (number < 0)
        return (&expand_wdesc_error);
      else
	{
	  ret = alloc_word_desc ();
	  ret->word = itos (number);
	  return ret;
	}
    }

  /* ${@} is identical to $@. */
  if (name[0] == '@' && name[1] == '\0')
    {
      if ((quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)) && quoted_dollar_atp)
	*quoted_dollar_atp = 1;

      if (contains_dollar_at)
	*contains_dollar_at = 1;
    }

  /* Process ${!PREFIX*} expansion. */
  if (want_indir && string[sindex - 1] == RBRACE &&
      (string[sindex - 2] == '*' || string[sindex - 2] == '@') &&
      legal_variable_starter ((unsigned char) name[1]))
    {
      char **x;
      WORD_LIST *xlist;

      temp1 = savestring (name + 1);
      number = strlen (temp1);
      temp1[number - 1] = '\0';
      x = all_variables_matching_prefix (temp1);
      xlist = strvec_to_word_list (x, 0, 0);
      if (string[sindex - 2] == '*')
	temp = string_list_dollar_star (xlist);
      else
	{
	  temp = string_list_dollar_at (xlist, quoted);
	  if ((quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)) && quoted_dollar_atp)
	    *quoted_dollar_atp = 1;
	  if (contains_dollar_at)
	    *contains_dollar_at = 1;
	}
      free (x);
      dispose_words (xlist);
      free (temp1);
      *indexp = sindex;

      ret = alloc_word_desc ();
      ret->word = temp;
      return ret;
    }

#if defined (ARRAY_VARS)      
  /* Process ${!ARRAY[@]} and ${!ARRAY[*]} expansion. */ /* [ */
  if (want_indir && string[sindex - 1] == RBRACE &&
      string[sindex - 2] == ']' && valid_array_reference (name+1))
    {
      char *x, *x1;

      temp1 = savestring (name + 1);
      x = array_variable_name (temp1, &x1, (int *)0);	/* [ */
      FREE (x);
      if (ALL_ELEMENT_SUB (x1[0]) && x1[1] == ']')
	{
	  temp = array_keys (temp1, quoted);	/* handles assoc vars too */
	  if (x1[0] == '@')
	    {
	      if ((quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)) && quoted_dollar_atp)
		*quoted_dollar_atp = 1;
	      if (contains_dollar_at)
		*contains_dollar_at = 1;
	    }	    

	  free (temp1);
	  *indexp = sindex;

	  ret = alloc_word_desc ();
	  ret->word = temp;
	  return ret;
	}

      free (temp1);
    }
#endif /* ARRAY_VARS */
      
  /* Make sure that NAME is valid before trying to go on. */
  if (valid_brace_expansion_word (want_indir ? name + 1 : name,
					var_is_special) == 0)
    {
      temp = (char *)NULL;
      goto bad_substitution;
    }

  if (want_indir)
    tdesc = parameter_brace_expand_indir (name + 1, var_is_special, quoted, quoted_dollar_atp, contains_dollar_at);
  else
    tdesc = parameter_brace_expand_word (name, var_is_special, quoted, PF_IGNUNBOUND|(pflags&PF_NOSPLIT2), &ind);

  if (tdesc)
    {
      temp = tdesc->word;
      tflag = tdesc->flags;
      dispose_word_desc (tdesc);
    }
  else
    temp = (char  *)0;

#if defined (ARRAY_VARS)
  if (valid_array_reference (name))
    chk_atstar (name, quoted, quoted_dollar_atp, contains_dollar_at);
#endif

  var_is_set = temp != (char *)0;
  var_is_null = check_nullness && (var_is_set == 0 || *temp == 0);

  /* Get the rest of the stuff inside the braces. */
  if (c && c != RBRACE)
    {
      /* Extract the contents of the ${ ... } expansion
	 according to the Posix.2 rules. */
      value = extract_dollar_brace_string (string, &sindex, quoted, (c == '%' || c == '#') ? SX_POSIXEXP : 0);
      if (string[sindex] == RBRACE)
	sindex++;
      else
	goto bad_substitution;
    }
  else
    value = (char *)NULL;

  *indexp = sindex;

  /* All the cases where an expansion can possibly generate an unbound
     variable error. */
  if (want_substring || want_patsub || want_casemod || c == '#' || c == '%' || c == RBRACE)
    {
      if (var_is_set == 0 && unbound_vars_is_error && ((name[0] != '@' && name[0] != '*') || name[1]))
	{
	  last_command_exit_value = EXECUTION_FAILURE;
	  err_unboundvar (name);
	  FREE (value);
	  FREE (temp);
	  free (name);
	  return (interactive_shell ? &expand_wdesc_error : &expand_wdesc_fatal);
	}
    }
    
  /* If this is a substring spec, process it and add the result. */
  if (want_substring)
    {
      temp1 = parameter_brace_substring (name, temp, ind, value, quoted, (tflag & W_ARRAYIND) ? AV_USEIND : 0);
      FREE (name);
      FREE (value);
      FREE (temp);

      if (temp1 == &expand_param_error)
	return (&expand_wdesc_error);
      else if (temp1 == &expand_param_fatal)
	return (&expand_wdesc_fatal);

      ret = alloc_word_desc ();
      ret->word = temp1;
      if (temp1 && QUOTED_NULL (temp1) && (quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)))
	ret->flags |= W_QUOTED|W_HASQUOTEDNULL;
      return ret;
    }
  else if (want_patsub)
    {
      temp1 = parameter_brace_patsub (name, temp, ind, value, quoted, (tflag & W_ARRAYIND) ? AV_USEIND : 0);
      FREE (name);
      FREE (value);
      FREE (temp);

      if (temp1 == &expand_param_error)
	return (&expand_wdesc_error);
      else if (temp1 == &expand_param_fatal)
	return (&expand_wdesc_fatal);

      ret = alloc_word_desc ();
      ret->word = temp1;
      ret = alloc_word_desc ();
      ret->word = temp1;
      if (temp1 && QUOTED_NULL (temp1) && (quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)))
	ret->flags |= W_QUOTED|W_HASQUOTEDNULL;
      return ret;
    }
#if defined (CASEMOD_EXPANSIONS)
  else if (want_casemod)
    {
      temp1 = parameter_brace_casemod (name, temp, ind, modspec, value, quoted, (tflag & W_ARRAYIND) ? AV_USEIND : 0);
      FREE (name);
      FREE (value);
      FREE (temp);

      if (temp1 == &expand_param_error)
	return (&expand_wdesc_error);
      else if (temp1 == &expand_param_fatal)
	return (&expand_wdesc_fatal);

      ret = alloc_word_desc ();
      ret->word = temp1;
      if (temp1 && QUOTED_NULL (temp1) && (quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)))
	ret->flags |= W_QUOTED|W_HASQUOTEDNULL;
      return ret;
    }
#endif

  /* Do the right thing based on which character ended the variable name. */
  switch (c)
    {
    default:
    case '\0':
    bad_substitution:
      report_error (_("%s: bad substitution"), string ? string : "??");
      FREE (value);
      FREE (temp);
      free (name);
      return &expand_wdesc_error;

    case RBRACE:
      break;

    case '#':	/* ${param#[#]pattern} */
    case '%':	/* ${param%[%]pattern} */
      if (value == 0 || *value == '\0' || temp == 0 || *temp == '\0')
	{
	  FREE (value);
	  break;
	}
      temp1 = parameter_brace_remove_pattern (name, temp, ind, value, c, quoted, (tflag & W_ARRAYIND) ? AV_USEIND : 0);
      free (temp);
      free (value);
      free (name);

      ret = alloc_word_desc ();
      ret->word = temp1;
      if (temp1 && QUOTED_NULL (temp1) && (quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)))
	ret->flags |= W_QUOTED|W_HASQUOTEDNULL;
      return ret;

    case '-':
    case '=':
    case '?':
    case '+':
      if (var_is_set && var_is_null == 0)
	{
	  /* If the operator is `+', we don't want the value of the named
	     variable for anything, just the value of the right hand side. */
	  if (c == '+')
	    {
	      /* XXX -- if we're double-quoted and the named variable is "$@",
			we want to turn off any special handling of "$@" --
			we're not using it, so whatever is on the rhs applies. */
	      if ((quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)) && quoted_dollar_atp)
		*quoted_dollar_atp = 0;
	      if (contains_dollar_at)
		*contains_dollar_at = 0;

	      FREE (temp);
	      if (value)
		{
		  /* From Posix discussion on austin-group list.  Issue 221
		     requires that backslashes escaping `}' inside
		     double-quoted ${...} be removed. */
		  if (quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES))
		    quoted |= Q_DOLBRACE;
		  ret = parameter_brace_expand_rhs (name, value, c,
						    quoted,
						    quoted_dollar_atp,
						    contains_dollar_at);
		  /* XXX - fix up later, esp. noting presence of
			   W_HASQUOTEDNULL in ret->flags */
		  free (value);
		}
	      else
		temp = (char *)NULL;
	    }
	  else
	    {
	      FREE (value);
	    }
	  /* Otherwise do nothing; just use the value in TEMP. */
	}
      else	/* VAR not set or VAR is NULL. */
	{
	  FREE (temp);
	  temp = (char *)NULL;
	  if (c == '=' && var_is_special)
	    {
	      report_error (_("$%s: cannot assign in this way"), name);
	      free (name);
	      free (value);
	      return &expand_wdesc_error;
	    }
	  else if (c == '?')
	    {
	      parameter_brace_expand_error (name, value);
	      return (interactive_shell ? &expand_wdesc_error : &expand_wdesc_fatal);
	    }
	  else if (c != '+')
	    {
	      /* XXX -- if we're double-quoted and the named variable is "$@",
			we want to turn off any special handling of "$@" --
			we're not using it, so whatever is on the rhs applies. */
	      if ((quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)) && quoted_dollar_atp)
		*quoted_dollar_atp = 0;
	      if (contains_dollar_at)
		*contains_dollar_at = 0;

	      /* From Posix discussion on austin-group list.  Issue 221 requires
		 that backslashes escaping `}' inside double-quoted ${...} be
		 removed. */
	      if (quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES))
		quoted |= Q_DOLBRACE;
	      ret = parameter_brace_expand_rhs (name, value, c, quoted,
						quoted_dollar_atp,
						contains_dollar_at);
	      /* XXX - fix up later, esp. noting presence of
		       W_HASQUOTEDNULL in tdesc->flags */
	    }
	  free (value);
	}

      break;
    }
  free (name);

  if (ret == 0)
    {
      ret = alloc_word_desc ();
      ret->flags = tflag;
      ret->word = temp;
    }
  return (ret);
}
warning: parse error {
  int check_nullness, var_is_set, var_is_null, var_is_special;
  int want_substring, want_indir, want_patsub, want_casemod;
  char *name, *value, *temp, *temp1;
  WORD_DESC *tdesc, *ret;
  int t_index, sindex, c, tflag, modspec;
  intmax_t number;
  arrayind_t ind;

  temp = temp1 = value = (char *)NULL;
  var_is_set = var_is_null = var_is_special = check_nullness = 0;
  want_substring = want_indir = want_patsub = want_casemod = 0;

  sindex = *indexp;
  t_index = ++sindex;
  /* ${#var} doesn't have any of the other parameter expansions on it. */
  if (string[t_index] == '#' && legal_variable_starter (string[t_index+1]))		/* {{ */
    name = string_extract (string, &t_index, "}", SX_VARNAME);
  else
#if defined (CASEMOD_EXPANSIONS)
    /* To enable case-toggling expansions using the `~' operator character
       change the 1 to 0. */
#  if defined (CASEMOD_CAPCASE)
    name = string_extract (string, &t_index, "#%^,~:-=?+/}", SX_VARNAME);
#  else
    name = string_extract (string, &t_index, "#%^,:-=?+/}", SX_VARNAME);
#  endif /* CASEMOD_CAPCASE */
#else
    name = string_extract (string, &t_index, "#%:-=?+/}", SX_VARNAME);
#endif /* CASEMOD_EXPANSIONS */

  ret = 0;
  tflag = 0;

  ind = INTMAX_MIN;

  /* If the name really consists of a special variable, then make sure
     that we have the entire name.  We don't allow indirect references
     to special variables except `#', `?', `@' and `*'. */
  if ((sindex == t_index && VALID_SPECIAL_LENGTH_PARAM (string[t_index])) ||
      (sindex == t_index - 1 && string[sindex] == '!' && VALID_INDIR_PARAM (string[t_index])))
    {
      t_index++;
      free (name);
      temp1 = string_extract (string, &t_index, "#%:-=?+/}", 0);
      name = (char *)xmalloc (3 + (strlen (temp1)));
      *name = string[sindex];
      if (string[sindex] == '!')
	{
	  /* indirect reference of $#, $?, $@, or $* */
	  name[1] = string[sindex + 1];
	  strcpy (name + 2, temp1);
	}
      else	
	strcpy (name + 1, temp1);
      free (temp1);
    }
  sindex = t_index;

  /* Find out what character ended the variable name.  Then
     do the appropriate thing. */
  if (c = string[sindex])
    sindex++;

  /* If c is followed by one of the valid parameter expansion
     characters, move past it as normal.  If not, assume that
     a substring specification is being given, and do not move
     past it. */
  if (c == ':' && VALID_PARAM_EXPAND_CHAR (string[sindex]))
    {
      check_nullness++;
      if (c = string[sindex])
	sindex++;
    }
  else if (c == ':' && string[sindex] != RBRACE)
    want_substring = 1;
  else if (c == '/' && string[sindex] != RBRACE)
    want_patsub = 1;
#if defined (CASEMOD_EXPANSIONS)
  else if (c == '^' || c == ',' || c == '~')
    {
      modspec = c;
      want_casemod = 1;
    }
#endif

  /* Catch the valid and invalid brace expressions that made it through the
     tests above. */
  /* ${#-} is a valid expansion and means to take the length of $-.
     Similarly for ${#?} and ${##}... */
  if (name[0] == '#' && name[1] == '\0' && check_nullness == 0 &&
	VALID_SPECIAL_LENGTH_PARAM (c) && string[sindex] == RBRACE)
    {
      name = (char *)xrealloc (name, 3);
      name[1] = c;
      name[2] = '\0';
      c = string[sindex++];
    }

  /* ...but ${#%}, ${#:}, ${#=}, ${#+}, and ${#/} are errors. */
  if (name[0] == '#' && name[1] == '\0' && check_nullness == 0 &&
	member (c, "%:=+/") && string[sindex] == RBRACE)
    {
      temp = (char *)NULL;
      goto bad_substitution;
    }

  /* Indirect expansion begins with a `!'.  A valid indirect expansion is
     either a variable name, one of the positional parameters or a special
     variable that expands to one of the positional parameters. */
  want_indir = *name == '!' &&
    (legal_variable_starter ((unsigned char)name[1]) || DIGIT (name[1])
					|| VALID_INDIR_PARAM (name[1]));

  /* Determine the value of this variable. */

  /* Check for special variables, directly referenced. */
  if (SPECIAL_VAR (name, want_indir))
    var_is_special++;

  /* Check for special expansion things, like the length of a parameter */
  if (*name == '#' && name[1])
    {
      /* If we are not pointing at the character just after the
	 closing brace, then we haven't gotten all of the name.
	 Since it begins with a special character, this is a bad
	 substitution.  Also check NAME for validity before trying
	 to go on. */
      if (string[sindex - 1] != RBRACE || (valid_length_expression (name) == 0))
	{
	  temp = (char *)NULL;
	  goto bad_substitution;
	}

      number = parameter_brace_expand_length (name);
      if (number == INTMAX_MIN && unbound_vars_is_error)
	{
	  last_command_exit_value = EXECUTION_FAILURE;
	  err_unboundvar (name+1);
	  free (name);
	  return (interactive_shell ? &expand_wdesc_error : &expand_wdesc_fatal);
	}
      free (name);

      *indexp = sindex;
      if (number < 0)
        return (&expand_wdesc_error);
      else
	{
	  ret = alloc_word_desc ();
	  ret->word = itos (number);
	  return ret;
	}
    }

  /* ${@} is identical to $@. */
  if (name[0] == '@' && name[1] == '\0')
    {
      if ((quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)) && quoted_dollar_atp)
	*quoted_dollar_atp = 1;

      if (contains_dollar_at)
	*contains_dollar_at = 1;
    }

  /* Process ${!PREFIX*} expansion. */
  if (want_indir && string[sindex - 1] == RBRACE &&
      (string[sindex - 2] == '*' || string[sindex - 2] == '@') &&
      legal_variable_starter ((unsigned char) name[1]))
    {
      char **x;
      WORD_LIST *xlist;

      temp1 = savestring (name + 1);
      number = strlen (temp1);
      temp1[number - 1] = '\0';
      x = all_variables_matching_prefix (temp1);
      xlist = strvec_to_word_list (x, 0, 0);
      if (string[sindex - 2] == '*')
	temp = string_list_dollar_star (xlist);
      else
	{
	  temp = string_list_dollar_at (xlist, quoted);
	  if ((quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)) && quoted_dollar_atp)
	    *quoted_dollar_atp = 1;
	  if (contains_dollar_at)
	    *contains_dollar_at = 1;
	}
      free (x);
      dispose_words (xlist);
      free (temp1);
      *indexp = sindex;

      ret = alloc_word_desc ();
      ret->word = temp;
      return ret;
    }

#if defined (ARRAY_VARS)      
  /* Process ${!ARRAY[@]} and ${!ARRAY[*]} expansion. */ /* [ */
  if (want_indir && string[sindex - 1] == RBRACE &&
      string[sindex - 2] == ']' && valid_array_reference (name+1))
    {
      char *x, *x1;

      temp1 = savestring (name + 1);
      x = array_variable_name (temp1, &x1, (int *)0);	/* [ */
      FREE (x);
      if (ALL_ELEMENT_SUB (x1[0]) && x1[1] == ']')
	{
	  temp = array_keys (temp1, quoted);	/* handles assoc vars too */
	  if (x1[0] == '@')
	    {
	      if ((quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)) && quoted_dollar_atp)
		*quoted_dollar_atp = 1;
	      if (contains_dollar_at)
		*contains_dollar_at = 1;
	    }	    

	  free (temp1);
	  *indexp = sindex;

	  ret = alloc_word_desc ();
	  ret->word = temp;
	  return ret;
	}

      free (temp1);
    }
#endif /* ARRAY_VARS */
      
  /* Make sure that NAME is valid before trying to go on. */
  if (valid_brace_expansion_word (want_indir ? name + 1 : name,
					var_is_special) == 0)
    {
      temp = (char *)NULL;
      goto bad_substitution;
    }

  if (want_indir)
    tdesc = parameter_brace_expand_indir (name + 1, var_is_special, quoted, quoted_dollar_atp, contains_dollar_at);
  else
    tdesc = parameter_brace_expand_word (name, var_is_special, quoted, PF_IGNUNBOUND|(pflags&PF_NOSPLIT2), &ind);

  if (tdesc)
    {
      temp = tdesc->word;
      tflag = tdesc->flags;
      dispose_word_desc (tdesc);
    }
  else
    temp = (char  *)0;

#if defined (ARRAY_VARS)
  if (valid_array_reference (name))
    chk_atstar (name, quoted, quoted_dollar_atp, contains_dollar_at);
#endif

  var_is_set = temp != (char *)0;
  var_is_null = check_nullness && (var_is_set == 0 || *temp == 0);

  /* Get the rest of the stuff inside the braces. */
  if (c && c != RBRACE)
    {
      /* Extract the contents of the ${ ... } expansion
	 according to the Posix.2 rules. */
      value = extract_dollar_brace_string (string, &sindex, quoted, (c == '%' || c == '#') ? SX_POSIXEXP : 0);
      if (string[sindex] == RBRACE)
	sindex++;
      else
	goto bad_substitution;
    }
  else
    value = (char *)NULL;

  *indexp = sindex;

  /* All the cases where an expansion can possibly generate an unbound
     variable error. */
  if (want_substring || want_patsub || want_casemod || c == '#' || c == '%' || c == RBRACE)
    {
      if (var_is_set == 0 && unbound_vars_is_error && ((name[0] != '@' && name[0] != '*') || name[1]))
	{
	  last_command_exit_value = EXECUTION_FAILURE;
	  err_unboundvar (name);
	  FREE (value);
	  FREE (temp);
	  free (name);
	  return (interactive_shell ? &expand_wdesc_error : &expand_wdesc_fatal);
	}
    }
    
  /* If this is a substring spec, process it and add the result. */
  if (want_substring)
    {
      temp1 = parameter_brace_substring (name, temp, ind, value, quoted, (tflag & W_ARRAYIND) ? AV_USEIND : 0);
      FREE (name);
      FREE (value);
      FREE (temp);

      if (temp1 == &expand_param_error)
	return (&expand_wdesc_error);
      else if (temp1 == &expand_param_fatal)
	return (&expand_wdesc_fatal);

      ret = alloc_word_desc ();
      ret->word = temp1;
      if (temp1 && QUOTED_NULL (temp1) && (quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)))
	ret->flags |= W_QUOTED|W_HASQUOTEDNULL;
      return ret;
    }
  else if (want_patsub)
    {
      temp1 = parameter_brace_patsub (name, temp, ind, value, quoted, (tflag & W_ARRAYIND) ? AV_USEIND : 0);
      FREE (name);
      FREE (value);
      FREE (temp);

      if (temp1 == &expand_param_error)
	return (&expand_wdesc_error);
      else if (temp1 == &expand_param_fatal)
	return (&expand_wdesc_fatal);

      ret = alloc_word_desc ();
      ret->word = temp1;
      ret = alloc_word_desc ();
      ret->word = temp1;
      if (temp1 && QUOTED_NULL (temp1) && (quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)))
	ret->flags |= W_QUOTED|W_HASQUOTEDNULL;
      return ret;
    }
#if defined (CASEMOD_EXPANSIONS)
  else if (want_casemod)
    {
      temp1 = parameter_brace_casemod (name, temp, ind, modspec, value, quoted, (tflag & W_ARRAYIND) ? AV_USEIND : 0);
      FREE (name);
      FREE (value);
      FREE (temp);

      if (temp1 == &expand_param_error)
	return (&expand_wdesc_error);
      else if (temp1 == &expand_param_fatal)
	return (&expand_wdesc_fatal);

      ret = alloc_word_desc ();
      ret->word = temp1;
      if (temp1 && QUOTED_NULL (temp1) && (quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)))
	ret->flags |= W_QUOTED|W_HASQUOTEDNULL;
      return ret;
    }
#endif

  /* Do the right thing based on which character ended the variable name. */
  switch (c)
    {
    default:
    case '\0':
    bad_substitution:
      report_error (_("%s: bad substitution"), string ? string : "??");
      FREE (value);
      FREE (temp);
      free (name);
      return &expand_wdesc_error;

    case RBRACE:
      break;

    case '#':	/* ${param#[#]pattern} */
    case '%':	/* ${param%[%]pattern} */
      if (value == 0 || *value == '\0' || temp == 0 || *temp == '\0')
	{
	  FREE (value);
	  break;
	}
      temp1 = parameter_brace_remove_pattern (name, temp, ind, value, c, quoted, (tflag & W_ARRAYIND) ? AV_USEIND : 0);
      free (temp);
      free (value);
      free (name);

      ret = alloc_word_desc ();
      ret->word = temp1;
      if (temp1 && QUOTED_NULL (temp1) && (quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)))
	ret->flags |= W_QUOTED|W_HASQUOTEDNULL;
      return ret;

    case '-':
    case '=':
    case '?':
    case '+':
      if (var_is_set && var_is_null == 0)
	{
	  /* If the operator is `+', we don't want the value of the named
	     variable for anything, just the value of the right hand side. */
	  if (c == '+')
	    {
	      /* XXX -- if we're double-quoted and the named variable is "$@",
			we want to turn off any special handling of "$@" --
			we're not using it, so whatever is on the rhs applies. */
	      if ((quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)) && quoted_dollar_atp)
		*quoted_dollar_atp = 0;
	      if (contains_dollar_at)
		*contains_dollar_at = 0;

	      FREE (temp);
	      if (value)
		{
		  /* From Posix discussion on austin-group list.  Issue 221
		     requires that backslashes escaping `}' inside
		     double-quoted ${...} be removed. */
		  if (quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES))
		    quoted |= Q_DOLBRACE;
		  ret = parameter_brace_expand_rhs (name, value, c,
						    quoted,
						    quoted_dollar_atp,
						    contains_dollar_at);
		  /* XXX - fix up later, esp. noting presence of
			   W_HASQUOTEDNULL in ret->flags */
		  free (value);
		}
	      else
		temp = (char *)NULL;
	    }
	  else
	    {
	      FREE (value);
	    }
	  /* Otherwise do nothing; just use the value in TEMP. */
	}
      else	/* VAR not set or VAR is NULL. */
	{
	  FREE (temp);
	  temp = (char *)NULL;
	  if (c == '=' && var_is_special)
	    {
	      report_error (_("$%s: cannot assign in this way"), name);
	      free (name);
	      free (value);
	      return &expand_wdesc_error;
	    }
	  else if (c == '?')
	    {
	      parameter_brace_expand_error (name, value);
	      return (interactive_shell ? &expand_wdesc_error : &expand_wdesc_fatal);
	    }
	  else if (c != '+')
	    {
	      /* XXX -- if we're double-quoted and the named variable is "$@",
			we want to turn off any special handling of "$@" --
			we're not using it, so whatever is on the rhs applies. */
	      if ((quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)) && quoted_dollar_atp)
		*quoted_dollar_atp = 0;
	      if (contains_dollar_at)
		*contains_dollar_at = 0;

	      /* From Posix discussion on austin-group list.  Issue 221 requires
		 that backslashes escaping `}' inside double-quoted ${...} be
		 removed. */
	      if (quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES))
		quoted |= Q_DOLBRACE;
	      ret = parameter_brace_expand_rhs (name, value, c, quoted,
						quoted_dollar_atp,
						contains_dollar_at);
	      /* XXX - fix up later, esp. noting presence of
		       W_HASQUOTEDNULL in tdesc->flags */
	    }
	  free (value);
	}

      break;
    }
  free (name);

  if (ret == 0)
    {
      ret = alloc_word_desc ();
      ret->flags = tflag;
      ret->word = temp;
    }
  return (ret);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\subst.c:6,913
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\subst.c:7,400
parsing error 
{
  char *temp, *temp1, uerror[3];
  int zindex, t_index, expok;
  unsigned char c;
  intmax_t number;
  SHELL_VAR *var;
  WORD_LIST *list;
  WORD_DESC *tdesc, *ret;
  int tflag;

  zindex = *sindex;
  c = string[++zindex];

  temp = (char *)NULL;
  ret = tdesc = (WORD_DESC *)NULL;
  tflag = 0;

  /* Do simple cases first. Switch on what follows '$'. */
  switch (c)
    {
    /* $0 .. $9? */
    case '0':
    case '1':
    case '2':
    case '3':
    case '4':
    case '5':
    case '6':
    case '7':
    case '8':
    case '9':
      temp1 = dollar_vars[TODIGIT (c)];
      if (unbound_vars_is_error && temp1 == (char *)NULL)
	{
	  uerror[0] = '$';
	  uerror[1] = c;
	  uerror[2] = '\0';
	  last_command_exit_value = EXECUTION_FAILURE;
	  err_unboundvar (uerror);
	  return (interactive_shell ? &expand_wdesc_error : &expand_wdesc_fatal);
	}
      if (temp1)
	temp = (*temp1 && (quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)))
		  ? quote_string (temp1)
		  : quote_escapes (temp1);
      else
	temp = (char *)NULL;

      break;

    /* $$ -- pid of the invoking shell. */
    case '$':
      temp = itos (dollar_dollar_pid);
      break;

    /* $# -- number of positional parameters. */
    case '#':
      temp = itos (number_of_args ());
      break;

    /* $? -- return value of the last synchronous command. */
    case '?':
      temp = itos (last_command_exit_value);
      break;

    /* $- -- flags supplied to the shell on invocation or by `set'. */
    case '-':
      temp = which_set_flags ();
      break;

      /* $! -- Pid of the last asynchronous command. */
    case '!':
      /* If no asynchronous pids have been created, expand to nothing.
	 If `set -u' has been executed, and no async processes have
	 been created, this is an expansion error. */
      if (last_asynchronous_pid == NO_PID)
	{
	  if (expanded_something)
	    *expanded_something = 0;
	  temp = (char *)NULL;
	  if (unbound_vars_is_error)
	    {
	      uerror[0] = '$';
	      uerror[1] = c;
	      uerror[2] = '\0';
	      last_command_exit_value = EXECUTION_FAILURE;
	      err_unboundvar (uerror);
	      return (interactive_shell ? &expand_wdesc_error : &expand_wdesc_fatal);
	    }
	}
      else
	temp = itos (last_asynchronous_pid);
      break;

    /* The only difference between this and $@ is when the arg is quoted. */
    case '*':		/* `$*' */
      list = list_rest_of_args ();

#if 0
      /* According to austin-group posix proposal by Geoff Clare in
	 <20090505091501.GA10097@squonk.masqnet> of 5 May 2009:

 	"The shell shall write a message to standard error and
 	 immediately exit when it tries to expand an unset parameter
 	 other than the '@' and '*' special parameters."
      */

      if (list == 0 && unbound_vars_is_error && (pflags & PF_IGNUNBOUND) == 0)
	{
	  uerror[0] = '$';
	  uerror[1] = '*';
	  uerror[2] = '\0';
	  last_command_exit_value = EXECUTION_FAILURE;
	  err_unboundvar (uerror);
	  return (interactive_shell ? &expand_wdesc_error : &expand_wdesc_fatal);
	}
#endif

      /* If there are no command-line arguments, this should just
	 disappear if there are other characters in the expansion,
	 even if it's quoted. */
      if ((quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)) && list == 0)
	temp = (char *)NULL;
      else if (quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES|Q_PATQUOTE))
	{
	  /* If we have "$*" we want to make a string of the positional
	     parameters, separated by the first character of $IFS, and
	     quote the whole string, including the separators.  If IFS
	     is unset, the parameters are separated by ' '; if $IFS is
	     null, the parameters are concatenated. */
	  temp = (quoted & (Q_DOUBLE_QUOTES|Q_PATQUOTE)) ? string_list_dollar_star (list) : string_list (list);
	  if (temp)
	    {
	      temp1 = quote_string (temp);
	      if (*temp == 0)
		tflag |= W_HASQUOTEDNULL;
	      free (temp);
	      temp = temp1;
	    }
	}
      else
	{
	  /* We check whether or not we're eventually going to split $* here,
	     for example when IFS is empty and we are processing the rhs of
	     an assignment statement.  In that case, we don't separate the
	     arguments at all.  Otherwise, if the $* is not quoted it is
	     identical to $@ */
#if 1
#  if defined (HANDLE_MULTIBYTE)
	  if (expand_no_split_dollar_star && ifs_firstc[0] == 0)
#  else
	  if (expand_no_split_dollar_star && ifs_firstc == 0)
#  endif
	    temp = string_list_dollar_star (list);
	  else
	    temp = string_list_dollar_at (list, quoted);
#else
	  temp = string_list_dollar_at (list, quoted);
#endif
	  if (expand_no_split_dollar_star == 0 && contains_dollar_at)
	    *contains_dollar_at = 1;
	}

      dispose_words (list);
      break;

    /* When we have "$@" what we want is "$1" "$2" "$3" ... This
       means that we have to turn quoting off after we split into
       the individually quoted arguments so that the final split
       on the first character of $IFS is still done.  */
    case '@':		/* `$@' */
      list = list_rest_of_args ();

#if 0
      /* According to austin-group posix proposal by Geoff Clare in
	 <20090505091501.GA10097@squonk.masqnet> of 5 May 2009:

 	"The shell shall write a message to standard error and
 	 immediately exit when it tries to expand an unset parameter
 	 other than the '@' and '*' special parameters."
      */

      if (list == 0 && unbound_vars_is_error && (pflags & PF_IGNUNBOUND) == 0)
	{
	  uerror[0] = '$';
	  uerror[1] = '@';
	  uerror[2] = '\0';
	  last_command_exit_value = EXECUTION_FAILURE;
	  err_unboundvar (uerror);
	  return (interactive_shell ? &expand_wdesc_error : &expand_wdesc_fatal);
	}
#endif

      /* We want to flag the fact that we saw this.  We can't turn
	 off quoting entirely, because other characters in the
	 string might need it (consider "\"$@\""), but we need some
	 way to signal that the final split on the first character
	 of $IFS should be done, even though QUOTED is 1. */
      /* XXX - should this test include Q_PATQUOTE? */
      if (quoted_dollar_at_p && (quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)))
	*quoted_dollar_at_p = 1;
      if (contains_dollar_at)
	*contains_dollar_at = 1;

#if 0
      if (pflags & PF_NOSPLIT2)
	temp = string_list_internal (quoted ? quote_list (list) : list, " ");
      else
#endif
      /* We want to separate the positional parameters with the first
	 character of $IFS in case $IFS is something other than a space.
	 We also want to make sure that splitting is done no matter what --
	 according to POSIX.2, this expands to a list of the positional
	 parameters no matter what IFS is set to. */
      temp = string_list_dollar_at (list, quoted);

      dispose_words (list);
      break;

    case LBRACE:
      tdesc = parameter_brace_expand (string, &zindex, quoted, pflags,
				      quoted_dollar_at_p,
				      contains_dollar_at);

      if (tdesc == &expand_wdesc_error || tdesc == &expand_wdesc_fatal)
	return (tdesc);
      temp = tdesc ? tdesc->word : (char *)0;

      /* XXX */
      /* Quoted nulls should be removed if there is anything else
	 in the string. */
      /* Note that we saw the quoted null so we can add one back at
	 the end of this function if there are no other characters
	 in the string, discard TEMP, and go on.  The exception to
	 this is when we have "${@}" and $1 is '', since $@ needs
	 special handling. */
      if (tdesc && tdesc->word && (tdesc->flags & W_HASQUOTEDNULL) && QUOTED_NULL (temp))
	{
	  if (had_quoted_null_p)
	    *had_quoted_null_p = 1;
	  if (*quoted_dollar_at_p == 0)
	    {
	      free (temp);
	      tdesc->word = temp = (char *)NULL;
	    }
	    
	}

      ret = tdesc;
      goto return0;

    /* Do command or arithmetic substitution. */
    case LPAREN:
      /* We have to extract the contents of this paren substitution. */
      t_index = zindex + 1;
      temp = extract_command_subst (string, &t_index, 0);
      zindex = t_index;

      /* For Posix.2-style `$(( ))' arithmetic substitution,
	 extract the expression and pass it to the evaluator. */
      if (temp && *temp == LPAREN)
	{
	  char *temp2;
	  temp1 = temp + 1;
	  temp2 = savestring (temp1);
	  t_index = strlen (temp2) - 1;

	  if (temp2[t_index] != RPAREN)
	    {
	      free (temp2);
	      goto comsub;
	    }

	  /* Cut off ending `)' */
	  temp2[t_index] = '\0';

	  if (chk_arithsub (temp2, t_index) == 0)
	    {
	      free (temp2);
#if 0
	      internal_warning (_("future versions of the shell will force evaluation as an arithmetic substitution"));
#endif
	      goto comsub;
	    }

	  /* Expand variables found inside the expression. */
	  temp1 = expand_arith_string (temp2, Q_DOUBLE_QUOTES);
	  free (temp2);

arithsub:
	  /* No error messages. */
	  this_command_name = (char *)NULL;
	  number = evalexp (temp1, &expok);
	  free (temp);
	  free (temp1);
	  if (expok == 0)
	    {
	      if (interactive_shell == 0 && posixly_correct)
		{
		  last_command_exit_value = EXECUTION_FAILURE;
		  return (&expand_wdesc_fatal);
		}
	      else
		return (&expand_wdesc_error);
	    }
	  temp = itos (number);
	  break;
	}

comsub:
      if (pflags & PF_NOCOMSUB)
	/* we need zindex+1 because string[zindex] == RPAREN */
	temp1 = substring (string, *sindex, zindex+1);
      else
	{
	  tdesc = command_substitute (temp, quoted);
	  temp1 = tdesc ? tdesc->word : (char *)NULL;
	  if (tdesc)
	    dispose_word_desc (tdesc);
	}
      FREE (temp);
      temp = temp1;
      break;

    /* Do POSIX.2d9-style arithmetic substitution.  This will probably go
       away in a future bash release. */
    case '[':
      /* Extract the contents of this arithmetic substitution. */
      t_index = zindex + 1;
      temp = extract_arithmetic_subst (string, &t_index);
      zindex = t_index;
      if (temp == 0)
	{
	  temp = savestring (string);
	  if (expanded_something)
	    *expanded_something = 0;
	  goto return0;
	}	  

       /* Do initial variable expansion. */
      temp1 = expand_arith_string (temp, Q_DOUBLE_QUOTES);

      goto arithsub;

    default:
      /* Find the variable in VARIABLE_LIST. */
      temp = (char *)NULL;

      for (t_index = zindex; (c = string[zindex]) && legal_variable_char (c); zindex++)
	;
      temp1 = (zindex > t_index) ? substring (string, t_index, zindex) : (char *)NULL;

      /* If this isn't a variable name, then just output the `$'. */
      if (temp1 == 0 || *temp1 == '\0')
	{
	  FREE (temp1);
	  temp = (char *)xmalloc (2);
	  temp[0] = '$';
	  temp[1] = '\0';
	  if (expanded_something)
	    *expanded_something = 0;
	  goto return0;
	}

      /* If the variable exists, return its value cell. */
      var = find_variable (temp1);

      if (var && invisible_p (var) == 0 && var_isset (var))
	{
#if defined (ARRAY_VARS)
	  if (assoc_p (var) || array_p (var))
	    {
	      temp = array_p (var) ? array_reference (array_cell (var), 0)
				   : assoc_reference (assoc_cell (var), "0");
	      if (temp)
		temp = (*temp && (quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)))
			  ? quote_string (temp)
			  : quote_escapes (temp);
	      else if (unbound_vars_is_error)
		goto unbound_variable;
	    }
	  else
#endif
	    {
	      temp = value_cell (var);

	      temp = (*temp && (quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)))
			? quote_string (temp)
			: quote_escapes (temp);
	    }

	  free (temp1);

	  goto return0;
	}

      temp = (char *)NULL;

unbound_variable:
      if (unbound_vars_is_error)
	{
	  last_command_exit_value = EXECUTION_FAILURE;
	  err_unboundvar (temp1);
	}
      else
	{
	  free (temp1);
	  goto return0;
	}

      free (temp1);
      last_command_exit_value = EXECUTION_FAILURE;
      return ((unbound_vars_is_error && interactive_shell == 0)
		? &expand_wdesc_fatal
		: &expand_wdesc_error);
    }

  if (string[zindex])
    zindex++;

return0:
  *sindex = zindex;

  if (ret == 0)
    {
      ret = alloc_word_desc ();
      ret->flags = tflag;	/* XXX */
      ret->word = temp;
    }
  return ret;
}
warning: parse error {
  char *temp, *temp1, uerror[3];
  int zindex, t_index, expok;
  unsigned char c;
  intmax_t number;
  SHELL_VAR *var;
  WORD_LIST *list;
  WORD_DESC *tdesc, *ret;
  int tflag;

  zindex = *sindex;
  c = string[++zindex];

  temp = (char *)NULL;
  ret = tdesc = (WORD_DESC *)NULL;
  tflag = 0;

  /* Do simple cases first. Switch on what follows '$'. */
  switch (c)
    {
    /* $0 .. $9? */
    case '0':
    case '1':
    case '2':
    case '3':
    case '4':
    case '5':
    case '6':
    case '7':
    case '8':
    case '9':
      temp1 = dollar_vars[TODIGIT (c)];
      if (unbound_vars_is_error && temp1 == (char *)NULL)
	{
	  uerror[0] = '$';
	  uerror[1] = c;
	  uerror[2] = '\0';
	  last_command_exit_value = EXECUTION_FAILURE;
	  err_unboundvar (uerror);
	  return (interactive_shell ? &expand_wdesc_error : &expand_wdesc_fatal);
	}
      if (temp1)
	temp = (*temp1 && (quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)))
		  ? quote_string (temp1)
		  : quote_escapes (temp1);
      else
	temp = (char *)NULL;

      break;

    /* $$ -- pid of the invoking shell. */
    case '$':
      temp = itos (dollar_dollar_pid);
      break;

    /* $# -- number of positional parameters. */
    case '#':
      temp = itos (number_of_args ());
      break;

    /* $? -- return value of the last synchronous command. */
    case '?':
      temp = itos (last_command_exit_value);
      break;

    /* $- -- flags supplied to the shell on invocation or by `set'. */
    case '-':
      temp = which_set_flags ();
      break;

      /* $! -- Pid of the last asynchronous command. */
    case '!':
      /* If no asynchronous pids have been created, expand to nothing.
	 If `set -u' has been executed, and no async processes have
	 been created, this is an expansion error. */
      if (last_asynchronous_pid == NO_PID)
	{
	  if (expanded_something)
	    *expanded_something = 0;
	  temp = (char *)NULL;
	  if (unbound_vars_is_error)
	    {
	      uerror[0] = '$';
	      uerror[1] = c;
	      uerror[2] = '\0';
	      last_command_exit_value = EXECUTION_FAILURE;
	      err_unboundvar (uerror);
	      return (interactive_shell ? &expand_wdesc_error : &expand_wdesc_fatal);
	    }
	}
      else
	temp = itos (last_asynchronous_pid);
      break;

    /* The only difference between this and $@ is when the arg is quoted. */
    case '*':		/* `$*' */
      list = list_rest_of_args ();

#if 0
      /* According to austin-group posix proposal by Geoff Clare in
	 <20090505091501.GA10097@squonk.masqnet> of 5 May 2009:

 	"The shell shall write a message to standard error and
 	 immediately exit when it tries to expand an unset parameter
 	 other than the '@' and '*' special parameters."
      */

      if (list == 0 && unbound_vars_is_error && (pflags & PF_IGNUNBOUND) == 0)
	{
	  uerror[0] = '$';
	  uerror[1] = '*';
	  uerror[2] = '\0';
	  last_command_exit_value = EXECUTION_FAILURE;
	  err_unboundvar (uerror);
	  return (interactive_shell ? &expand_wdesc_error : &expand_wdesc_fatal);
	}
#endif

      /* If there are no command-line arguments, this should just
	 disappear if there are other characters in the expansion,
	 even if it's quoted. */
      if ((quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)) && list == 0)
	temp = (char *)NULL;
      else if (quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES|Q_PATQUOTE))
	{
	  /* If we have "$*" we want to make a string of the positional
	     parameters, separated by the first character of $IFS, and
	     quote the whole string, including the separators.  If IFS
	     is unset, the parameters are separated by ' '; if $IFS is
	     null, the parameters are concatenated. */
	  temp = (quoted & (Q_DOUBLE_QUOTES|Q_PATQUOTE)) ? string_list_dollar_star (list) : string_list (list);
	  if (temp)
	    {
	      temp1 = quote_string (temp);
	      if (*temp == 0)
		tflag |= W_HASQUOTEDNULL;
	      free (temp);
	      temp = temp1;
	    }
	}
      else
	{
	  /* We check whether or not we're eventually going to split $* here,
	     for example when IFS is empty and we are processing the rhs of
	     an assignment statement.  In that case, we don't separate the
	     arguments at all.  Otherwise, if the $* is not quoted it is
	     identical to $@ */
#if 1
#  if defined (HANDLE_MULTIBYTE)
	  if (expand_no_split_dollar_star && ifs_firstc[0] == 0)
#  else
	  if (expand_no_split_dollar_star && ifs_firstc == 0)
#  endif
	    temp = string_list_dollar_star (list);
	  else
	    temp = string_list_dollar_at (list, quoted);
#else
	  temp = string_list_dollar_at (list, quoted);
#endif
	  if (expand_no_split_dollar_star == 0 && contains_dollar_at)
	    *contains_dollar_at = 1;
	}

      dispose_words (list);
      break;

    /* When we have "$@" what we want is "$1" "$2" "$3" ... This
       means that we have to turn quoting off after we split into
       the individually quoted arguments so that the final split
       on the first character of $IFS is still done.  */
    case '@':		/* `$@' */
      list = list_rest_of_args ();

#if 0
      /* According to austin-group posix proposal by Geoff Clare in
	 <20090505091501.GA10097@squonk.masqnet> of 5 May 2009:

 	"The shell shall write a message to standard error and
 	 immediately exit when it tries to expand an unset parameter
 	 other than the '@' and '*' special parameters."
      */

      if (list == 0 && unbound_vars_is_error && (pflags & PF_IGNUNBOUND) == 0)
	{
	  uerror[0] = '$';
	  uerror[1] = '@';
	  uerror[2] = '\0';
	  last_command_exit_value = EXECUTION_FAILURE;
	  err_unboundvar (uerror);
	  return (interactive_shell ? &expand_wdesc_error : &expand_wdesc_fatal);
	}
#endif

      /* We want to flag the fact that we saw this.  We can't turn
	 off quoting entirely, because other characters in the
	 string might need it (consider "\"$@\""), but we need some
	 way to signal that the final split on the first character
	 of $IFS should be done, even though QUOTED is 1. */
      /* XXX - should this test include Q_PATQUOTE? */
      if (quoted_dollar_at_p && (quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)))
	*quoted_dollar_at_p = 1;
      if (contains_dollar_at)
	*contains_dollar_at = 1;

#if 0
      if (pflags & PF_NOSPLIT2)
	temp = string_list_internal (quoted ? quote_list (list) : list, " ");
      else
#endif
      /* We want to separate the positional parameters with the first
	 character of $IFS in case $IFS is something other than a space.
	 We also want to make sure that splitting is done no matter what --
	 according to POSIX.2, this expands to a list of the positional
	 parameters no matter what IFS is set to. */
      temp = string_list_dollar_at (list, quoted);

      dispose_words (list);
      break;

    case LBRACE:
      tdesc = parameter_brace_expand (string, &zindex, quoted, pflags,
				      quoted_dollar_at_p,
				      contains_dollar_at);

      if (tdesc == &expand_wdesc_error || tdesc == &expand_wdesc_fatal)
	return (tdesc);
      temp = tdesc ? tdesc->word : (char *)0;

      /* XXX */
      /* Quoted nulls should be removed if there is anything else
	 in the string. */
      /* Note that we saw the quoted null so we can add one back at
	 the end of this function if there are no other characters
	 in the string, discard TEMP, and go on.  The exception to
	 this is when we have "${@}" and $1 is '', since $@ needs
	 special handling. */
      if (tdesc && tdesc->word && (tdesc->flags & W_HASQUOTEDNULL) && QUOTED_NULL (temp))
	{
	  if (had_quoted_null_p)
	    *had_quoted_null_p = 1;
	  if (*quoted_dollar_at_p == 0)
	    {
	      free (temp);
	      tdesc->word = temp = (char *)NULL;
	    }
	    
	}

      ret = tdesc;
      goto return0;

    /* Do command or arithmetic substitution. */
    case LPAREN:
      /* We have to extract the contents of this paren substitution. */
      t_index = zindex + 1;
      temp = extract_command_subst (string, &t_index, 0);
      zindex = t_index;

      /* For Posix.2-style `$(( ))' arithmetic substitution,
	 extract the expression and pass it to the evaluator. */
      if (temp && *temp == LPAREN)
	{
	  char *temp2;
	  temp1 = temp + 1;
	  temp2 = savestring (temp1);
	  t_index = strlen (temp2) - 1;

	  if (temp2[t_index] != RPAREN)
	    {
	      free (temp2);
	      goto comsub;
	    }

	  /* Cut off ending `)' */
	  temp2[t_index] = '\0';

	  if (chk_arithsub (temp2, t_index) == 0)
	    {
	      free (temp2);
#if 0
	      internal_warning (_("future versions of the shell will force evaluation as an arithmetic substitution"));
#endif
	      goto comsub;
	    }

	  /* Expand variables found inside the expression. */
	  temp1 = expand_arith_string (temp2, Q_DOUBLE_QUOTES);
	  free (temp2);

arithsub:
	  /* No error messages. */
	  this_command_name = (char *)NULL;
	  number = evalexp (temp1, &expok);
	  free (temp);
	  free (temp1);
	  if (expok == 0)
	    {
	      if (interactive_shell == 0 && posixly_correct)
		{
		  last_command_exit_value = EXECUTION_FAILURE;
		  return (&expand_wdesc_fatal);
		}
	      else
		return (&expand_wdesc_error);
	    }
	  temp = itos (number);
	  break;
	}

comsub:
      if (pflags & PF_NOCOMSUB)
	/* we need zindex+1 because string[zindex] == RPAREN */
	temp1 = substring (string, *sindex, zindex+1);
      else
	{
	  tdesc = command_substitute (temp, quoted);
	  temp1 = tdesc ? tdesc->word : (char *)NULL;
	  if (tdesc)
	    dispose_word_desc (tdesc);
	}
      FREE (temp);
      temp = temp1;
      break;

    /* Do POSIX.2d9-style arithmetic substitution.  This will probably go
       away in a future bash release. */
    case '[':
      /* Extract the contents of this arithmetic substitution. */
      t_index = zindex + 1;
      temp = extract_arithmetic_subst (string, &t_index);
      zindex = t_index;
      if (temp == 0)
	{
	  temp = savestring (string);
	  if (expanded_something)
	    *expanded_something = 0;
	  goto return0;
	}	  

       /* Do initial variable expansion. */
      temp1 = expand_arith_string (temp, Q_DOUBLE_QUOTES);

      goto arithsub;

    default:
      /* Find the variable in VARIABLE_LIST. */
      temp = (char *)NULL;

      for (t_index = zindex; (c = string[zindex]) && legal_variable_char (c); zindex++)
	;
      temp1 = (zindex > t_index) ? substring (string, t_index, zindex) : (char *)NULL;

      /* If this isn't a variable name, then just output the `$'. */
      if (temp1 == 0 || *temp1 == '\0')
	{
	  FREE (temp1);
	  temp = (char *)xmalloc (2);
	  temp[0] = '$';
	  temp[1] = '\0';
	  if (expanded_something)
	    *expanded_something = 0;
	  goto return0;
	}

      /* If the variable exists, return its value cell. */
      var = find_variable (temp1);

      if (var && invisible_p (var) == 0 && var_isset (var))
	{
#if defined (ARRAY_VARS)
	  if (assoc_p (var) || array_p (var))
	    {
	      temp = array_p (var) ? array_reference (array_cell (var), 0)
				   : assoc_reference (assoc_cell (var), "0");
	      if (temp)
		temp = (*temp && (quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)))
			  ? quote_string (temp)
			  : quote_escapes (temp);
	      else if (unbound_vars_is_error)
		goto unbound_variable;
	    }
	  else
#endif
	    {
	      temp = value_cell (var);

	      temp = (*temp && (quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)))
			? quote_string (temp)
			: quote_escapes (temp);
	    }

	  free (temp1);

	  goto return0;
	}

      temp = (char *)NULL;

unbound_variable:
      if (unbound_vars_is_error)
	{
	  last_command_exit_value = EXECUTION_FAILURE;
	  err_unboundvar (temp1);
	}
      else
	{
	  free (temp1);
	  goto return0;
	}

      free (temp1);
      last_command_exit_value = EXECUTION_FAILURE;
      return ((unbound_vars_is_error && interactive_shell == 0)
		? &expand_wdesc_fatal
		: &expand_wdesc_error);
    }

  if (string[zindex])
    zindex++;

return0:
  *sindex = zindex;

  if (ret == 0)
    {
      ret = alloc_word_desc ();
      ret->flags = tflag;	/* XXX */
      ret->word = temp;
    }
  return ret;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\subst.c:7,404
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\subst.c:7,863
parsing error 
{
  WORD_LIST *list;
  WORD_DESC *tword;

  /* The intermediate string that we build while expanding. */
  char *istring;

  /* The current size of the above object. */
  int istring_size;

  /* Index into ISTRING. */
  int istring_index;

  /* Temporary string storage. */
  char *temp, *temp1;

  /* The text of WORD. */
  register char *string;

  /* The size of STRING. */
  size_t string_size;

  /* The index into STRING. */
  int sindex;

  /* This gets 1 if we see a $@ while quoted. */
  int quoted_dollar_at;

  /* One of UNQUOTED, PARTIALLY_QUOTED, or WHOLLY_QUOTED, depending on
     whether WORD contains no quoting characters, a partially quoted
     string (e.g., "xx"ab), or is fully quoted (e.g., "xxab"). */
  int quoted_state;

  /* State flags */
  int had_quoted_null;
  int has_dollar_at;
  int tflag;
  int pflags;			/* flags passed to param_expand */

  int assignoff;		/* If assignment, offset of `=' */

  register unsigned char c;	/* Current character. */
  int t_index;			/* For calls to string_extract_xxx. */

  char twochars[2];

  DECLARE_MBSTATE;

  istring = (char *)xmalloc (istring_size = DEFAULT_INITIAL_ARRAY_SIZE);
  istring[istring_index = 0] = '\0';
  quoted_dollar_at = had_quoted_null = has_dollar_at = 0;
  quoted_state = UNQUOTED;

  string = word->word;
  if (string == 0)
    goto finished_with_string;
  /* Don't need the string length for the SADD... and COPY_ macros unless
     multibyte characters are possible. */
  string_size = (MB_CUR_MAX > 1) ? strlen (string) : 1;

  if (contains_dollar_at)
    *contains_dollar_at = 0;

  assignoff = -1;

  /* Begin the expansion. */

  for (sindex = 0; ;)
    {
      c = string[sindex];

      /* Case on toplevel character. */
      switch (c)
	{
	case '\0':
	  goto finished_with_string;

	case CTLESC:
	  sindex++;
#if HANDLE_MULTIBYTE
	  if (MB_CUR_MAX > 1 && string[sindex])
	    {
	      SADD_MBQCHAR_BODY(temp, string, sindex, string_size);
	    }
	  else
#endif
	    {
	      temp = (char *)xmalloc (3);
	      temp[0] = CTLESC;
	      temp[1] = c = string[sindex];
	      temp[2] = '\0';
	    }

dollar_add_string:
	  if (string[sindex])
	    sindex++;

add_string:
	  if (temp)
	    {
	      istring = sub_append_string (temp, istring, &istring_index, &istring_size);
	      temp = (char *)0;
	    }

	  break;

#if defined (PROCESS_SUBSTITUTION)
	  /* Process substitution. */
	case '<':
	case '>':
	  {
	    if (string[++sindex] != LPAREN || (quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)) || (word->flags & (W_DQUOTE|W_NOPROCSUB)) || posixly_correct)
	      {
		sindex--;	/* add_character: label increments sindex */
		goto add_character;
	      }
	    else
	      t_index = sindex + 1; /* skip past both '<' and LPAREN */

	    temp1 = extract_process_subst (string, (c == '<') ? "<(" : ">(", &t_index); /*))*/
	    sindex = t_index;

	    /* If the process substitution specification is `<()', we want to
	       open the pipe for writing in the child and produce output; if
	       it is `>()', we want to open the pipe for reading in the child
	       and consume input. */
	    temp = temp1 ? process_substitute (temp1, (c == '>')) : (char *)0;

	    FREE (temp1);

	    goto dollar_add_string;
	  }
#endif /* PROCESS_SUBSTITUTION */

	case '=':
	  /* Posix.2 section 3.6.1 says that tildes following `=' in words
	     which are not assignment statements are not expanded.  If the
	     shell isn't in posix mode, though, we perform tilde expansion
	     on `likely candidate' unquoted assignment statements (flags
	     include W_ASSIGNMENT but not W_QUOTED).  A likely candidate
	     contains an unquoted :~ or =~.  Something to think about: we
	     now have a flag that says  to perform tilde expansion on arguments
	     to `assignment builtins' like declare and export that look like
	     assignment statements.  We now do tilde expansion on such words
	     even in POSIX mode. */	
	  if (word->flags & (W_ASSIGNRHS|W_NOTILDE))
	    {
	      if (isexp == 0 && (word->flags & (W_NOSPLIT|W_NOSPLIT2)) == 0 && isifs (c))
		goto add_ifs_character;
	      else
		goto add_character;
	    }
	  /* If we're not in posix mode or forcing assignment-statement tilde
	     expansion, note where the `=' appears in the word and prepare to
	     do tilde expansion following the first `='. */
	  if ((word->flags & W_ASSIGNMENT) &&
	      (posixly_correct == 0 || (word->flags & W_TILDEEXP)) &&
	      assignoff == -1 && sindex > 0)
	    assignoff = sindex;
	  if (sindex == assignoff && string[sindex+1] == '~')	/* XXX */
	    word->flags |= W_ITILDE;
#if 0
	  else if ((word->flags & W_ASSIGNMENT) &&
		   (posixly_correct == 0 || (word->flags & W_TILDEEXP)) &&
		   string[sindex+1] == '~')
	    word->flags |= W_ITILDE;
#endif
	  if (isexp == 0 && (word->flags & (W_NOSPLIT|W_NOSPLIT2)) == 0 && isifs (c))
	    goto add_ifs_character;
	  else
	    goto add_character;

	case ':':
	  if (word->flags & W_NOTILDE)
	    {
	      if (isexp == 0 && (word->flags & (W_NOSPLIT|W_NOSPLIT2)) == 0 && isifs (c))
		goto add_ifs_character;
	      else
		goto add_character;
	    }

	  if ((word->flags & (W_ASSIGNMENT|W_ASSIGNRHS|W_TILDEEXP)) &&
	      string[sindex+1] == '~')
	    word->flags |= W_ITILDE;

	  if (isexp == 0 && (word->flags & (W_NOSPLIT|W_NOSPLIT2)) == 0 && isifs (c))
	    goto add_ifs_character;
	  else
	    goto add_character;

	case '~':
	  /* If the word isn't supposed to be tilde expanded, or we're not
	     at the start of a word or after an unquoted : or = in an
	     assignment statement, we don't do tilde expansion. */
	  if ((word->flags & (W_NOTILDE|W_DQUOTE)) ||
	      (sindex > 0 && ((word->flags & W_ITILDE) == 0)) ||
	      (quoted & (Q_DOUBLE_QUOTES|Q_HERE_DOCUMENT)))
	    {
	      word->flags &= ~W_ITILDE;
	      if (isexp == 0 && (word->flags & (W_NOSPLIT|W_NOSPLIT2)) == 0 && isifs (c) && (quoted & (Q_DOUBLE_QUOTES|Q_HERE_DOCUMENT)) == 0)
		goto add_ifs_character;
	      else
		goto add_character;
	    }

	  if (word->flags & W_ASSIGNRHS)
	    tflag = 2;
	  else if (word->flags & (W_ASSIGNMENT|W_TILDEEXP))
	    tflag = 1;
	  else
	    tflag = 0;

	  temp = bash_tilde_find_word (string + sindex, tflag, &t_index);
	    
	  word->flags &= ~W_ITILDE;

	  if (temp && *temp && t_index > 0)
	    {
	      temp1 = bash_tilde_expand (temp, tflag);
	      if  (temp1 && *temp1 == '~' && STREQ (temp, temp1))
		{
		  FREE (temp);
		  FREE (temp1);
		  goto add_character;		/* tilde expansion failed */
		}
	      free (temp);
	      temp = temp1;
	      sindex += t_index;
	      goto add_quoted_string;		/* XXX was add_string */
	    }
	  else
	    {
	      FREE (temp);
	      goto add_character;
	    }
	
	case '$':
	  if (expanded_something)
	    *expanded_something = 1;

	  has_dollar_at = 0;
	  pflags = (word->flags & W_NOCOMSUB) ? PF_NOCOMSUB : 0;
	  if (word->flags & W_NOSPLIT2)
	    pflags |= PF_NOSPLIT2;
	  tword = param_expand (string, &sindex, quoted, expanded_something,
			       &has_dollar_at, &quoted_dollar_at,
			       &had_quoted_null, pflags);

	  if (tword == &expand_wdesc_error || tword == &expand_wdesc_fatal)
	    {
	      free (string);
	      free (istring);
	      return ((tword == &expand_wdesc_error) ? &expand_word_error
						     : &expand_word_fatal);
	    }
	  if (contains_dollar_at && has_dollar_at)
	    *contains_dollar_at = 1;

	  if (tword && (tword->flags & W_HASQUOTEDNULL))
	    had_quoted_null = 1;

	  temp = tword->word;
	  dispose_word_desc (tword);

	  goto add_string;
	  break;

	case '`':		/* Backquoted command substitution. */
	  {
	    t_index = sindex++;

	    temp = string_extract (string, &sindex, "`", SX_REQMATCH);
	    /* The test of sindex against t_index is to allow bare instances of
	       ` to pass through, for backwards compatibility. */
	    if (temp == &extract_string_error || temp == &extract_string_fatal)
	      {
		if (sindex - 1 == t_index)
		  {
		    sindex = t_index;
		    goto add_character;
		  }
		report_error (_("bad substitution: no closing \"`\" in %s") , string+t_index);
		free (string);
		free (istring);
		return ((temp == &extract_string_error) ? &expand_word_error
							: &expand_word_fatal);
	      }
		
	    if (expanded_something)
	      *expanded_something = 1;

	    if (word->flags & W_NOCOMSUB)
	      /* sindex + 1 because string[sindex] == '`' */
	      temp1 = substring (string, t_index, sindex + 1);
	    else
	      {
		de_backslash (temp);
		tword = command_substitute (temp, quoted);
		temp1 = tword ? tword->word : (char *)NULL;
		if (tword)
		  dispose_word_desc (tword);
	      }
	    FREE (temp);
	    temp = temp1;
	    goto dollar_add_string;
	  }

	case '\\':
	  if (string[sindex + 1] == '\n')
	    {
	      sindex += 2;
	      continue;
	    }

	  c = string[++sindex];

	  if (quoted & Q_HERE_DOCUMENT)
	    tflag = CBSHDOC;
	  else if (quoted & Q_DOUBLE_QUOTES)
	    tflag = CBSDQUOTE;
	  else
	    tflag = 0;

	  /* From Posix discussion on austin-group list:  Backslash escaping
	     a } in ${...} is removed.  Issue 0000221 */
	  if ((quoted & Q_DOLBRACE) && c == RBRACE)
	    {
	      SCOPY_CHAR_I (twochars, CTLESC, c, string, sindex, string_size);
	    }
	  else if ((quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)) && ((sh_syntaxtab[c] & tflag) == 0))
	    {
	      SCOPY_CHAR_I (twochars, '\\', c, string, sindex, string_size);
	    }
	  else if (c == 0)
	    {
	      c = CTLNUL;
	      sindex--;		/* add_character: label increments sindex */
	      goto add_character;
	    }
	  else
	    {
	      SCOPY_CHAR_I (twochars, CTLESC, c, string, sindex, string_size);
	    }

	  sindex++;
add_twochars:
	  /* BEFORE jumping here, we need to increment sindex if appropriate */
	  RESIZE_MALLOCED_BUFFER (istring, istring_index, 2, istring_size,
				  DEFAULT_ARRAY_SIZE);
	  istring[istring_index++] = twochars[0];
	  istring[istring_index++] = twochars[1];
	  istring[istring_index] = '\0';

	  break;

	case '"':
#if 0
	  if ((quoted & (Q_DOUBLE_QUOTES|Q_HERE_DOCUMENT)) || (word->flags & W_DQUOTE))
#else
	  if ((quoted & (Q_DOUBLE_QUOTES|Q_HERE_DOCUMENT)))
#endif
	    goto add_character;

	  t_index = ++sindex;
	  temp = string_extract_double_quoted (string, &sindex, 0);

	  /* If the quotes surrounded the entire string, then the
	     whole word was quoted. */
	  quoted_state = (t_index == 1 && string[sindex] == '\0')
			    ? WHOLLY_QUOTED
			    : PARTIALLY_QUOTED;

	  if (temp && *temp)
	    {
	      tword = alloc_word_desc ();
	      tword->word = temp;

	      temp = (char *)NULL;

	      has_dollar_at = 0;
	      /* Need to get W_HASQUOTEDNULL flag through this function. */
	      list = expand_word_internal (tword, Q_DOUBLE_QUOTES, 0, &has_dollar_at, (int *)NULL);

	      if (list == &expand_word_error || list == &expand_word_fatal)
		{
		  free (istring);
		  free (string);
		  /* expand_word_internal has already freed temp_word->word
		     for us because of the way it prints error messages. */
		  tword->word = (char *)NULL;
		  dispose_word (tword);
		  return list;
		}

	      dispose_word (tword);

	      /* "$@" (a double-quoted dollar-at) expands into nothing,
		 not even a NULL word, when there are no positional
		 parameters. */
	      if (list == 0 && has_dollar_at)
		{
		  quoted_dollar_at++;
		  break;
		}

	      /* If we get "$@", we know we have expanded something, so we
		 need to remember it for the final split on $IFS.  This is
		 a special case; it's the only case where a quoted string
		 can expand into more than one word.  It's going to come back
		 from the above call to expand_word_internal as a list with
		 a single word, in which all characters are quoted and
		 separated by blanks.  What we want to do is to turn it back
		 into a list for the next piece of code. */
	      if (list)
		dequote_list (list);

	      if (list && list->word && (list->word->flags & W_HASQUOTEDNULL))
		had_quoted_null = 1;

	      if (has_dollar_at)
		{
		  quoted_dollar_at++;
		  if (contains_dollar_at)
		    *contains_dollar_at = 1;
		  if (expanded_something)
		    *expanded_something = 1;
		}
	    }
	  else
	    {
	      /* What we have is "".  This is a minor optimization. */
	      FREE (temp);
	      list = (WORD_LIST *)NULL;
	    }

	  /* The code above *might* return a list (consider the case of "$@",
	     where it returns "$1", "$2", etc.).  We can't throw away the
	     rest of the list, and we have to make sure each word gets added
	     as quoted.  We test on tresult->next:  if it is non-NULL, we
	     quote the whole list, save it to a string with string_list, and
	     add that string. We don't need to quote the results of this
	     (and it would be wrong, since that would quote the separators
	     as well), so we go directly to add_string. */
	  if (list)
	    {
	      if (list->next)
		{
#if 0
		  if (quoted_dollar_at && (word->flags & W_NOSPLIT2))
		    temp = string_list_internal (quote_list (list), " ");
		  else
#endif
		  /* Testing quoted_dollar_at makes sure that "$@" is
		     split correctly when $IFS does not contain a space. */
		  temp = quoted_dollar_at
				? string_list_dollar_at (list, Q_DOUBLE_QUOTES)
				: string_list (quote_list (list));
		  dispose_words (list);
		  goto add_string;
		}
	      else
		{
		  temp = savestring (list->word->word);
		  tflag = list->word->flags;
		  dispose_words (list);

		  /* If the string is not a quoted null string, we want
		     to remove any embedded unquoted CTLNUL characters.
		     We do not want to turn quoted null strings back into
		     the empty string, though.  We do this because we
		     want to remove any quoted nulls from expansions that
		     contain other characters.  For example, if we have
		     x"$*"y or "x$*y" and there are no positional parameters,
		     the $* should expand into nothing. */
		  /* We use the W_HASQUOTEDNULL flag to differentiate the
		     cases:  a quoted null character as above and when
		     CTLNUL is contained in the (non-null) expansion
		     of some variable.  We use the had_quoted_null flag to
		     pass the value through this function to its caller. */
		  if ((tflag & W_HASQUOTEDNULL) && QUOTED_NULL (temp) == 0)
		    remove_quoted_nulls (temp);	/* XXX */
		}
	    }
	  else
	    temp = (char *)NULL;

	  /* We do not want to add quoted nulls to strings that are only
	     partially quoted; we can throw them away. */
	  if (temp == 0 && quoted_state == PARTIALLY_QUOTED && (word->flags & (W_NOSPLIT|W_NOSPLIT2)))
	    continue;

	add_quoted_string:

	  if (temp)
	    {
	      temp1 = temp;
	      temp = quote_string (temp);
	      free (temp1);
	      goto add_string;
	    }
	  else
	    {
	      /* Add NULL arg. */
	      c = CTLNUL;
	      sindex--;		/* add_character: label increments sindex */
	      goto add_character;
	    }

	  /* break; */

	case '\'':
#if 0
	  if ((quoted & (Q_DOUBLE_QUOTES|Q_HERE_DOCUMENT)) || (word->flags & W_DQUOTE))
#else
	  if ((quoted & (Q_DOUBLE_QUOTES|Q_HERE_DOCUMENT)))
#endif
	    goto add_character;

	  t_index = ++sindex;
	  temp = string_extract_single_quoted (string, &sindex);

	  /* If the entire STRING was surrounded by single quotes,
	     then the string is wholly quoted. */
	  quoted_state = (t_index == 1 && string[sindex] == '\0')
			    ? WHOLLY_QUOTED
			    : PARTIALLY_QUOTED;

	  /* If all we had was '', it is a null expansion. */
	  if (*temp == '\0')
	    {
	      free (temp);
	      temp = (char *)NULL;
	    }
	  else
	    remove_quoted_escapes (temp);	/* ??? */

	  /* We do not want to add quoted nulls to strings that are only
	     partially quoted; such nulls are discarded. */
	  if (temp == 0 && (quoted_state == PARTIALLY_QUOTED))
	    continue;

	  /* If we have a quoted null expansion, add a quoted NULL to istring. */
	  if (temp == 0)
	    {
	      c = CTLNUL;
	      sindex--;		/* add_character: label increments sindex */
	      goto add_character;
	    }
	  else
	    goto add_quoted_string;

	  /* break; */

	default:
	  /* This is the fix for " $@ " */
	add_ifs_character:
	  if ((quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)) || (isexp == 0 && isifs (c)))
	    {
	      if (string[sindex])	/* from old goto dollar_add_string */
		sindex++;
	      if (c == 0)
		{
		  c = CTLNUL;
		  goto add_character;
		}
	      else
		{
#if HANDLE_MULTIBYTE
		  if (MB_CUR_MAX > 1)
		    sindex--;

		  if (MB_CUR_MAX > 1)
		    {
		      SADD_MBQCHAR_BODY(temp, string, sindex, string_size);
		    }
		  else
#endif
		    {
		      twochars[0] = CTLESC;
		      twochars[1] = c;
		      goto add_twochars;
		    }
		}
	    }

	  SADD_MBCHAR (temp, string, sindex, string_size);

	add_character:
	  RESIZE_MALLOCED_BUFFER (istring, istring_index, 1, istring_size,
				  DEFAULT_ARRAY_SIZE);
	  istring[istring_index++] = c;
	  istring[istring_index] = '\0';

	  /* Next character. */
	  sindex++;
	}
    }

finished_with_string:
  /* OK, we're ready to return.  If we have a quoted string, and
     quoted_dollar_at is not set, we do no splitting at all; otherwise
     we split on ' '.  The routines that call this will handle what to
     do if nothing has been expanded. */

  /* Partially and wholly quoted strings which expand to the empty
     string are retained as an empty arguments.  Unquoted strings
     which expand to the empty string are discarded.  The single
     exception is the case of expanding "$@" when there are no
     positional parameters.  In that case, we discard the expansion. */

  /* Because of how the code that handles "" and '' in partially
     quoted strings works, we need to make ISTRING into a QUOTED_NULL
     if we saw quoting characters, but the expansion was empty.
     "" and '' are tossed away before we get to this point when
     processing partially quoted strings.  This makes "" and $xxx""
     equivalent when xxx is unset.  We also look to see whether we
     saw a quoted null from a ${} expansion and add one back if we
     need to. */

  /* If we expand to nothing and there were no single or double quotes
     in the word, we throw it away.  Otherwise, we return a NULL word.
     The single exception is for $@ surrounded by double quotes when
     there are no positional parameters.  In that case, we also throw
     the word away. */

  if (*istring == '\0')
    {
      if (quoted_dollar_at == 0 && (had_quoted_null || quoted_state == PARTIALLY_QUOTED))
	{
	  istring[0] = CTLNUL;
	  istring[1] = '\0';
	  tword = make_bare_word (istring);
	  tword->flags |= W_HASQUOTEDNULL;		/* XXX */
	  list = make_word_list (tword, (WORD_LIST *)NULL);
	  if (quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES))
	    tword->flags |= W_QUOTED;
	}
      /* According to sh, ksh, and Posix.2, if a word expands into nothing
	 and a double-quoted "$@" appears anywhere in it, then the entire
	 word is removed. */
      else  if (quoted_state == UNQUOTED || quoted_dollar_at)
	list = (WORD_LIST *)NULL;
#if 0
      else
	{
	  tword = make_bare_word (istring);
	  if (quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES))
	    tword->flags |= W_QUOTED;
	  list = make_word_list (tword, (WORD_LIST *)NULL);
	}
#else
      else
	list = (WORD_LIST *)NULL;
#endif
    }
  else if (word->flags & W_NOSPLIT)
    {
      tword = make_bare_word (istring);
      if (word->flags & W_ASSIGNMENT)
	tword->flags |= W_ASSIGNMENT;	/* XXX */
      if (word->flags & W_COMPASSIGN)
	tword->flags |= W_COMPASSIGN;	/* XXX */
      if (word->flags & W_NOGLOB)
	tword->flags |= W_NOGLOB;	/* XXX */
      if (word->flags & W_NOEXPAND)
	tword->flags |= W_NOEXPAND;	/* XXX */
      if (quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES))
	tword->flags |= W_QUOTED;
      if (had_quoted_null)
	tword->flags |= W_HASQUOTEDNULL;
      list = make_word_list (tword, (WORD_LIST *)NULL);
    }
  else
    {
      char *ifs_chars;

      ifs_chars = (quoted_dollar_at || has_dollar_at) ? ifs_value : (char *)NULL;

      /* If we have $@, we need to split the results no matter what.  If
	 IFS is unset or NULL, string_list_dollar_at has separated the
	 positional parameters with a space, so we split on space (we have
	 set ifs_chars to " \t\n" above if ifs is unset).  If IFS is set,
	 string_list_dollar_at has separated the positional parameters
	 with the first character of $IFS, so we split on $IFS. */
      if (has_dollar_at && ifs_chars)
	list = list_string (istring, *ifs_chars ? ifs_chars : " ", 1);
      else
	{
	  tword = make_bare_word (istring);
	  if ((quoted & (Q_DOUBLE_QUOTES|Q_HERE_DOCUMENT)) || (quoted_state == WHOLLY_QUOTED))
	    tword->flags |= W_QUOTED;
	  if (word->flags & W_ASSIGNMENT)
	    tword->flags |= W_ASSIGNMENT;
	  if (word->flags & W_COMPASSIGN)
	    tword->flags |= W_COMPASSIGN;
	  if (word->flags & W_NOGLOB)
	    tword->flags |= W_NOGLOB;
	  if (word->flags & W_NOEXPAND)
	    tword->flags |= W_NOEXPAND;
	  if (had_quoted_null)
	    tword->flags |= W_HASQUOTEDNULL;	/* XXX */
	  list = make_word_list (tword, (WORD_LIST *)NULL);
	}
    }

  free (istring);
  return (list);
}
warning: parse error {
  WORD_LIST *list;
  WORD_DESC *tword;

  /* The intermediate string that we build while expanding. */
  char *istring;

  /* The current size of the above object. */
  int istring_size;

  /* Index into ISTRING. */
  int istring_index;

  /* Temporary string storage. */
  char *temp, *temp1;

  /* The text of WORD. */
  register char *string;

  /* The size of STRING. */
  size_t string_size;

  /* The index into STRING. */
  int sindex;

  /* This gets 1 if we see a $@ while quoted. */
  int quoted_dollar_at;

  /* One of UNQUOTED, PARTIALLY_QUOTED, or WHOLLY_QUOTED, depending on
     whether WORD contains no quoting characters, a partially quoted
     string (e.g., "xx"ab), or is fully quoted (e.g., "xxab"). */
  int quoted_state;

  /* State flags */
  int had_quoted_null;
  int has_dollar_at;
  int tflag;
  int pflags;			/* flags passed to param_expand */

  int assignoff;		/* If assignment, offset of `=' */

  register unsigned char c;	/* Current character. */
  int t_index;			/* For calls to string_extract_xxx. */

  char twochars[2];

  DECLARE_MBSTATE;

  istring = (char *)xmalloc (istring_size = DEFAULT_INITIAL_ARRAY_SIZE);
  istring[istring_index = 0] = '\0';
  quoted_dollar_at = had_quoted_null = has_dollar_at = 0;
  quoted_state = UNQUOTED;

  string = word->word;
  if (string == 0)
    goto finished_with_string;
  /* Don't need the string length for the SADD... and COPY_ macros unless
     multibyte characters are possible. */
  string_size = (MB_CUR_MAX > 1) ? strlen (string) : 1;

  if (contains_dollar_at)
    *contains_dollar_at = 0;

  assignoff = -1;

  /* Begin the expansion. */

  for (sindex = 0; ;)
    {
      c = string[sindex];

      /* Case on toplevel character. */
      switch (c)
	{
	case '\0':
	  goto finished_with_string;

	case CTLESC:
	  sindex++;
#if HANDLE_MULTIBYTE
	  if (MB_CUR_MAX > 1 && string[sindex])
	    {
	      SADD_MBQCHAR_BODY(temp, string, sindex, string_size);
	    }
	  else
#endif
	    {
	      temp = (char *)xmalloc (3);
	      temp[0] = CTLESC;
	      temp[1] = c = string[sindex];
	      temp[2] = '\0';
	    }

dollar_add_string:
	  if (string[sindex])
	    sindex++;

add_string:
	  if (temp)
	    {
	      istring = sub_append_string (temp, istring, &istring_index, &istring_size);
	      temp = (char *)0;
	    }

	  break;

#if defined (PROCESS_SUBSTITUTION)
	  /* Process substitution. */
	case '<':
	case '>':
	  {
	    if (string[++sindex] != LPAREN || (quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)) || (word->flags & (W_DQUOTE|W_NOPROCSUB)) || posixly_correct)
	      {
		sindex--;	/* add_character: label increments sindex */
		goto add_character;
	      }
	    else
	      t_index = sindex + 1; /* skip past both '<' and LPAREN */

	    temp1 = extract_process_subst (string, (c == '<') ? "<(" : ">(", &t_index); /*))*/
	    sindex = t_index;

	    /* If the process substitution specification is `<()', we want to
	       open the pipe for writing in the child and produce output; if
	       it is `>()', we want to open the pipe for reading in the child
	       and consume input. */
	    temp = temp1 ? process_substitute (temp1, (c == '>')) : (char *)0;

	    FREE (temp1);

	    goto dollar_add_string;
	  }
#endif /* PROCESS_SUBSTITUTION */

	case '=':
	  /* Posix.2 section 3.6.1 says that tildes following `=' in words
	     which are not assignment statements are not expanded.  If the
	     shell isn't in posix mode, though, we perform tilde expansion
	     on `likely candidate' unquoted assignment statements (flags
	     include W_ASSIGNMENT but not W_QUOTED).  A likely candidate
	     contains an unquoted :~ or =~.  Something to think about: we
	     now have a flag that says  to perform tilde expansion on arguments
	     to `assignment builtins' like declare and export that look like
	     assignment statements.  We now do tilde expansion on such words
	     even in POSIX mode. */	
	  if (word->flags & (W_ASSIGNRHS|W_NOTILDE))
	    {
	      if (isexp == 0 && (word->flags & (W_NOSPLIT|W_NOSPLIT2)) == 0 && isifs (c))
		goto add_ifs_character;
	      else
		goto add_character;
	    }
	  /* If we're not in posix mode or forcing assignment-statement tilde
	     expansion, note where the `=' appears in the word and prepare to
	     do tilde expansion following the first `='. */
	  if ((word->flags & W_ASSIGNMENT) &&
	      (posixly_correct == 0 || (word->flags & W_TILDEEXP)) &&
	      assignoff == -1 && sindex > 0)
	    assignoff = sindex;
	  if (sindex == assignoff && string[sindex+1] == '~')	/* XXX */
	    word->flags |= W_ITILDE;
#if 0
	  else if ((word->flags & W_ASSIGNMENT) &&
		   (posixly_correct == 0 || (word->flags & W_TILDEEXP)) &&
		   string[sindex+1] == '~')
	    word->flags |= W_ITILDE;
#endif
	  if (isexp == 0 && (word->flags & (W_NOSPLIT|W_NOSPLIT2)) == 0 && isifs (c))
	    goto add_ifs_character;
	  else
	    goto add_character;

	case ':':
	  if (word->flags & W_NOTILDE)
	    {
	      if (isexp == 0 && (word->flags & (W_NOSPLIT|W_NOSPLIT2)) == 0 && isifs (c))
		goto add_ifs_character;
	      else
		goto add_character;
	    }

	  if ((word->flags & (W_ASSIGNMENT|W_ASSIGNRHS|W_TILDEEXP)) &&
	      string[sindex+1] == '~')
	    word->flags |= W_ITILDE;

	  if (isexp == 0 && (word->flags & (W_NOSPLIT|W_NOSPLIT2)) == 0 && isifs (c))
	    goto add_ifs_character;
	  else
	    goto add_character;

	case '~':
	  /* If the word isn't supposed to be tilde expanded, or we're not
	     at the start of a word or after an unquoted : or = in an
	     assignment statement, we don't do tilde expansion. */
	  if ((word->flags & (W_NOTILDE|W_DQUOTE)) ||
	      (sindex > 0 && ((word->flags & W_ITILDE) == 0)) ||
	      (quoted & (Q_DOUBLE_QUOTES|Q_HERE_DOCUMENT)))
	    {
	      word->flags &= ~W_ITILDE;
	      if (isexp == 0 && (word->flags & (W_NOSPLIT|W_NOSPLIT2)) == 0 && isifs (c) && (quoted & (Q_DOUBLE_QUOTES|Q_HERE_DOCUMENT)) == 0)
		goto add_ifs_character;
	      else
		goto add_character;
	    }

	  if (word->flags & W_ASSIGNRHS)
	    tflag = 2;
	  else if (word->flags & (W_ASSIGNMENT|W_TILDEEXP))
	    tflag = 1;
	  else
	    tflag = 0;

	  temp = bash_tilde_find_word (string + sindex, tflag, &t_index);
	    
	  word->flags &= ~W_ITILDE;

	  if (temp && *temp && t_index > 0)
	    {
	      temp1 = bash_tilde_expand (temp, tflag);
	      if  (temp1 && *temp1 == '~' && STREQ (temp, temp1))
		{
		  FREE (temp);
		  FREE (temp1);
		  goto add_character;		/* tilde expansion failed */
		}
	      free (temp);
	      temp = temp1;
	      sindex += t_index;
	      goto add_quoted_string;		/* XXX was add_string */
	    }
	  else
	    {
	      FREE (temp);
	      goto add_character;
	    }
	
	case '$':
	  if (expanded_something)
	    *expanded_something = 1;

	  has_dollar_at = 0;
	  pflags = (word->flags & W_NOCOMSUB) ? PF_NOCOMSUB : 0;
	  if (word->flags & W_NOSPLIT2)
	    pflags |= PF_NOSPLIT2;
	  tword = param_expand (string, &sindex, quoted, expanded_something,
			       &has_dollar_at, &quoted_dollar_at,
			       &had_quoted_null, pflags);

	  if (tword == &expand_wdesc_error || tword == &expand_wdesc_fatal)
	    {
	      free (string);
	      free (istring);
	      return ((tword == &expand_wdesc_error) ? &expand_word_error
						     : &expand_word_fatal);
	    }
	  if (contains_dollar_at && has_dollar_at)
	    *contains_dollar_at = 1;

	  if (tword && (tword->flags & W_HASQUOTEDNULL))
	    had_quoted_null = 1;

	  temp = tword->word;
	  dispose_word_desc (tword);

	  goto add_string;
	  break;

	case '`':		/* Backquoted command substitution. */
	  {
	    t_index = sindex++;

	    temp = string_extract (string, &sindex, "`", SX_REQMATCH);
	    /* The test of sindex against t_index is to allow bare instances of
	       ` to pass through, for backwards compatibility. */
	    if (temp == &extract_string_error || temp == &extract_string_fatal)
	      {
		if (sindex - 1 == t_index)
		  {
		    sindex = t_index;
		    goto add_character;
		  }
		report_error (_("bad substitution: no closing \"`\" in %s") , string+t_index);
		free (string);
		free (istring);
		return ((temp == &extract_string_error) ? &expand_word_error
							: &expand_word_fatal);
	      }
		
	    if (expanded_something)
	      *expanded_something = 1;

	    if (word->flags & W_NOCOMSUB)
	      /* sindex + 1 because string[sindex] == '`' */
	      temp1 = substring (string, t_index, sindex + 1);
	    else
	      {
		de_backslash (temp);
		tword = command_substitute (temp, quoted);
		temp1 = tword ? tword->word : (char *)NULL;
		if (tword)
		  dispose_word_desc (tword);
	      }
	    FREE (temp);
	    temp = temp1;
	    goto dollar_add_string;
	  }

	case '\\':
	  if (string[sindex + 1] == '\n')
	    {
	      sindex += 2;
	      continue;
	    }

	  c = string[++sindex];

	  if (quoted & Q_HERE_DOCUMENT)
	    tflag = CBSHDOC;
	  else if (quoted & Q_DOUBLE_QUOTES)
	    tflag = CBSDQUOTE;
	  else
	    tflag = 0;

	  /* From Posix discussion on austin-group list:  Backslash escaping
	     a } in ${...} is removed.  Issue 0000221 */
	  if ((quoted & Q_DOLBRACE) && c == RBRACE)
	    {
	      SCOPY_CHAR_I (twochars, CTLESC, c, string, sindex, string_size);
	    }
	  else if ((quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)) && ((sh_syntaxtab[c] & tflag) == 0))
	    {
	      SCOPY_CHAR_I (twochars, '\\', c, string, sindex, string_size);
	    }
	  else if (c == 0)
	    {
	      c = CTLNUL;
	      sindex--;		/* add_character: label increments sindex */
	      goto add_character;
	    }
	  else
	    {
	      SCOPY_CHAR_I (twochars, CTLESC, c, string, sindex, string_size);
	    }

	  sindex++;
add_twochars:
	  /* BEFORE jumping here, we need to increment sindex if appropriate */
	  RESIZE_MALLOCED_BUFFER (istring, istring_index, 2, istring_size,
				  DEFAULT_ARRAY_SIZE);
	  istring[istring_index++] = twochars[0];
	  istring[istring_index++] = twochars[1];
	  istring[istring_index] = '\0';

	  break;

	case '"':
#if 0
	  if ((quoted & (Q_DOUBLE_QUOTES|Q_HERE_DOCUMENT)) || (word->flags & W_DQUOTE))
#else
	  if ((quoted & (Q_DOUBLE_QUOTES|Q_HERE_DOCUMENT)))
#endif
	    goto add_character;

	  t_index = ++sindex;
	  temp = string_extract_double_quoted (string, &sindex, 0);

	  /* If the quotes surrounded the entire string, then the
	     whole word was quoted. */
	  quoted_state = (t_index == 1 && string[sindex] == '\0')
			    ? WHOLLY_QUOTED
			    : PARTIALLY_QUOTED;

	  if (temp && *temp)
	    {
	      tword = alloc_word_desc ();
	      tword->word = temp;

	      temp = (char *)NULL;

	      has_dollar_at = 0;
	      /* Need to get W_HASQUOTEDNULL flag through this function. */
	      list = expand_word_internal (tword, Q_DOUBLE_QUOTES, 0, &has_dollar_at, (int *)NULL);

	      if (list == &expand_word_error || list == &expand_word_fatal)
		{
		  free (istring);
		  free (string);
		  /* expand_word_internal has already freed temp_word->word
		     for us because of the way it prints error messages. */
		  tword->word = (char *)NULL;
		  dispose_word (tword);
		  return list;
		}

	      dispose_word (tword);

	      /* "$@" (a double-quoted dollar-at) expands into nothing,
		 not even a NULL word, when there are no positional
		 parameters. */
	      if (list == 0 && has_dollar_at)
		{
		  quoted_dollar_at++;
		  break;
		}

	      /* If we get "$@", we know we have expanded something, so we
		 need to remember it for the final split on $IFS.  This is
		 a special case; it's the only case where a quoted string
		 can expand into more than one word.  It's going to come back
		 from the above call to expand_word_internal as a list with
		 a single word, in which all characters are quoted and
		 separated by blanks.  What we want to do is to turn it back
		 into a list for the next piece of code. */
	      if (list)
		dequote_list (list);

	      if (list && list->word && (list->word->flags & W_HASQUOTEDNULL))
		had_quoted_null = 1;

	      if (has_dollar_at)
		{
		  quoted_dollar_at++;
		  if (contains_dollar_at)
		    *contains_dollar_at = 1;
		  if (expanded_something)
		    *expanded_something = 1;
		}
	    }
	  else
	    {
	      /* What we have is "".  This is a minor optimization. */
	      FREE (temp);
	      list = (WORD_LIST *)NULL;
	    }

	  /* The code above *might* return a list (consider the case of "$@",
	     where it returns "$1", "$2", etc.).  We can't throw away the
	     rest of the list, and we have to make sure each word gets added
	     as quoted.  We test on tresult->next:  if it is non-NULL, we
	     quote the whole list, save it to a string with string_list, and
	     add that string. We don't need to quote the results of this
	     (and it would be wrong, since that would quote the separators
	     as well), so we go directly to add_string. */
	  if (list)
	    {
	      if (list->next)
		{
#if 0
		  if (quoted_dollar_at && (word->flags & W_NOSPLIT2))
		    temp = string_list_internal (quote_list (list), " ");
		  else
#endif
		  /* Testing quoted_dollar_at makes sure that "$@" is
		     split correctly when $IFS does not contain a space. */
		  temp = quoted_dollar_at
				? string_list_dollar_at (list, Q_DOUBLE_QUOTES)
				: string_list (quote_list (list));
		  dispose_words (list);
		  goto add_string;
		}
	      else
		{
		  temp = savestring (list->word->word);
		  tflag = list->word->flags;
		  dispose_words (list);

		  /* If the string is not a quoted null string, we want
		     to remove any embedded unquoted CTLNUL characters.
		     We do not want to turn quoted null strings back into
		     the empty string, though.  We do this because we
		     want to remove any quoted nulls from expansions that
		     contain other characters.  For example, if we have
		     x"$*"y or "x$*y" and there are no positional parameters,
		     the $* should expand into nothing. */
		  /* We use the W_HASQUOTEDNULL flag to differentiate the
		     cases:  a quoted null character as above and when
		     CTLNUL is contained in the (non-null) expansion
		     of some variable.  We use the had_quoted_null flag to
		     pass the value through this function to its caller. */
		  if ((tflag & W_HASQUOTEDNULL) && QUOTED_NULL (temp) == 0)
		    remove_quoted_nulls (temp);	/* XXX */
		}
	    }
	  else
	    temp = (char *)NULL;

	  /* We do not want to add quoted nulls to strings that are only
	     partially quoted; we can throw them away. */
	  if (temp == 0 && quoted_state == PARTIALLY_QUOTED && (word->flags & (W_NOSPLIT|W_NOSPLIT2)))
	    continue;

	add_quoted_string:

	  if (temp)
	    {
	      temp1 = temp;
	      temp = quote_string (temp);
	      free (temp1);
	      goto add_string;
	    }
	  else
	    {
	      /* Add NULL arg. */
	      c = CTLNUL;
	      sindex--;		/* add_character: label increments sindex */
	      goto add_character;
	    }

	  /* break; */

	case '\'':
#if 0
	  if ((quoted & (Q_DOUBLE_QUOTES|Q_HERE_DOCUMENT)) || (word->flags & W_DQUOTE))
#else
	  if ((quoted & (Q_DOUBLE_QUOTES|Q_HERE_DOCUMENT)))
#endif
	    goto add_character;

	  t_index = ++sindex;
	  temp = string_extract_single_quoted (string, &sindex);

	  /* If the entire STRING was surrounded by single quotes,
	     then the string is wholly quoted. */
	  quoted_state = (t_index == 1 && string[sindex] == '\0')
			    ? WHOLLY_QUOTED
			    : PARTIALLY_QUOTED;

	  /* If all we had was '', it is a null expansion. */
	  if (*temp == '\0')
	    {
	      free (temp);
	      temp = (char *)NULL;
	    }
	  else
	    remove_quoted_escapes (temp);	/* ??? */

	  /* We do not want to add quoted nulls to strings that are only
	     partially quoted; such nulls are discarded. */
	  if (temp == 0 && (quoted_state == PARTIALLY_QUOTED))
	    continue;

	  /* If we have a quoted null expansion, add a quoted NULL to istring. */
	  if (temp == 0)
	    {
	      c = CTLNUL;
	      sindex--;		/* add_character: label increments sindex */
	      goto add_character;
	    }
	  else
	    goto add_quoted_string;

	  /* break; */

	default:
	  /* This is the fix for " $@ " */
	add_ifs_character:
	  if ((quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)) || (isexp == 0 && isifs (c)))
	    {
	      if (string[sindex])	/* from old goto dollar_add_string */
		sindex++;
	      if (c == 0)
		{
		  c = CTLNUL;
		  goto add_character;
		}
	      else
		{
#if HANDLE_MULTIBYTE
		  if (MB_CUR_MAX > 1)
		    sindex--;

		  if (MB_CUR_MAX > 1)
		    {
		      SADD_MBQCHAR_BODY(temp, string, sindex, string_size);
		    }
		  else
#endif
		    {
		      twochars[0] = CTLESC;
		      twochars[1] = c;
		      goto add_twochars;
		    }
		}
	    }

	  SADD_MBCHAR (temp, string, sindex, string_size);

	add_character:
	  RESIZE_MALLOCED_BUFFER (istring, istring_index, 1, istring_size,
				  DEFAULT_ARRAY_SIZE);
	  istring[istring_index++] = c;
	  istring[istring_index] = '\0';

	  /* Next character. */
	  sindex++;
	}
    }

finished_with_string:
  /* OK, we're ready to return.  If we have a quoted string, and
     quoted_dollar_at is not set, we do no splitting at all; otherwise
     we split on ' '.  The routines that call this will handle what to
     do if nothing has been expanded. */

  /* Partially and wholly quoted strings which expand to the empty
     string are retained as an empty arguments.  Unquoted strings
     which expand to the empty string are discarded.  The single
     exception is the case of expanding "$@" when there are no
     positional parameters.  In that case, we discard the expansion. */

  /* Because of how the code that handles "" and '' in partially
     quoted strings works, we need to make ISTRING into a QUOTED_NULL
     if we saw quoting characters, but the expansion was empty.
     "" and '' are tossed away before we get to this point when
     processing partially quoted strings.  This makes "" and $xxx""
     equivalent when xxx is unset.  We also look to see whether we
     saw a quoted null from a ${} expansion and add one back if we
     need to. */

  /* If we expand to nothing and there were no single or double quotes
     in the word, we throw it away.  Otherwise, we return a NULL word.
     The single exception is for $@ surrounded by double quotes when
     there are no positional parameters.  In that case, we also throw
     the word away. */

  if (*istring == '\0')
    {
      if (quoted_dollar_at == 0 && (had_quoted_null || quoted_state == PARTIALLY_QUOTED))
	{
	  istring[0] = CTLNUL;
	  istring[1] = '\0';
	  tword = make_bare_word (istring);
	  tword->flags |= W_HASQUOTEDNULL;		/* XXX */
	  list = make_word_list (tword, (WORD_LIST *)NULL);
	  if (quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES))
	    tword->flags |= W_QUOTED;
	}
      /* According to sh, ksh, and Posix.2, if a word expands into nothing
	 and a double-quoted "$@" appears anywhere in it, then the entire
	 word is removed. */
      else  if (quoted_state == UNQUOTED || quoted_dollar_at)
	list = (WORD_LIST *)NULL;
#if 0
      else
	{
	  tword = make_bare_word (istring);
	  if (quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES))
	    tword->flags |= W_QUOTED;
	  list = make_word_list (tword, (WORD_LIST *)NULL);
	}
#else
      else
	list = (WORD_LIST *)NULL;
#endif
    }
  else if (word->flags & W_NOSPLIT)
    {
      tword = make_bare_word (istring);
      if (word->flags & W_ASSIGNMENT)
	tword->flags |= W_ASSIGNMENT;	/* XXX */
      if (word->flags & W_COMPASSIGN)
	tword->flags |= W_COMPASSIGN;	/* XXX */
      if (word->flags & W_NOGLOB)
	tword->flags |= W_NOGLOB;	/* XXX */
      if (word->flags & W_NOEXPAND)
	tword->flags |= W_NOEXPAND;	/* XXX */
      if (quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES))
	tword->flags |= W_QUOTED;
      if (had_quoted_null)
	tword->flags |= W_HASQUOTEDNULL;
      list = make_word_list (tword, (WORD_LIST *)NULL);
    }
  else
    {
      char *ifs_chars;

      ifs_chars = (quoted_dollar_at || has_dollar_at) ? ifs_value : (char *)NULL;

      /* If we have $@, we need to split the results no matter what.  If
	 IFS is unset or NULL, string_list_dollar_at has separated the
	 positional parameters with a space, so we split on space (we have
	 set ifs_chars to " \t\n" above if ifs is unset).  If IFS is set,
	 string_list_dollar_at has separated the positional parameters
	 with the first character of $IFS, so we split on $IFS. */
      if (has_dollar_at && ifs_chars)
	list = list_string (istring, *ifs_chars ? ifs_chars : " ", 1);
      else
	{
	  tword = make_bare_word (istring);
	  if ((quoted & (Q_DOUBLE_QUOTES|Q_HERE_DOCUMENT)) || (quoted_state == WHOLLY_QUOTED))
	    tword->flags |= W_QUOTED;
	  if (word->flags & W_ASSIGNMENT)
	    tword->flags |= W_ASSIGNMENT;
	  if (word->flags & W_COMPASSIGN)
	    tword->flags |= W_COMPASSIGN;
	  if (word->flags & W_NOGLOB)
	    tword->flags |= W_NOGLOB;
	  if (word->flags & W_NOEXPAND)
	    tword->flags |= W_NOEXPAND;
	  if (had_quoted_null)
	    tword->flags |= W_HASQUOTEDNULL;	/* XXX */
	  list = make_word_list (tword, (WORD_LIST *)NULL);
	}
    }

  free (istring);
  return (list);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\subst.c:7,868
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\subst.c:8,586
parsing error 
{
  size_t slen;
  char *r, *result_string, *temp, *send;
  int sindex, tindex, dquote;
  unsigned char c;
  DECLARE_MBSTATE;

  /* The result can be no longer than the original string. */
  slen = strlen (string);
  send = string + slen;

  r = result_string = (char *)xmalloc (slen + 1);

  for (dquote = sindex = 0; c = string[sindex];)
    {
      switch (c)
	{
	case '\\':
	  c = string[++sindex];
	  if (c == 0)
	    {
	      *r++ = '\\';
	      break;
	    }
	  if (((quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)) || dquote) && (sh_syntaxtab[c] & CBSDQUOTE) == 0)
	    *r++ = '\\';
	  /* FALLTHROUGH */

	default:
	  SCOPY_CHAR_M (r, string, send, sindex);
	  break;

	case '\'':
	  if ((quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)) || dquote)
	    {
	      *r++ = c;
	      sindex++;
	      break;
	    }
	  tindex = sindex + 1;
	  temp = string_extract_single_quoted (string, &tindex);
	  if (temp)
	    {
	      strcpy (r, temp);
	      r += strlen (r);
	      free (temp);
	    }
	  sindex = tindex;
	  break;

	case '"':
	  dquote = 1 - dquote;
	  sindex++;
	  break;
	}
    }
    *r = '\0';
    return (result_string);
}
warning: parse error {
  size_t slen;
  char *r, *result_string, *temp, *send;
  int sindex, tindex, dquote;
  unsigned char c;
  DECLARE_MBSTATE;

  /* The result can be no longer than the original string. */
  slen = strlen (string);
  send = string + slen;

  r = result_string = (char *)xmalloc (slen + 1);

  for (dquote = sindex = 0; c = string[sindex];)
    {
      switch (c)
	{
	case '\\':
	  c = string[++sindex];
	  if (c == 0)
	    {
	      *r++ = '\\';
	      break;
	    }
	  if (((quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)) || dquote) && (sh_syntaxtab[c] & CBSDQUOTE) == 0)
	    *r++ = '\\';
	  /* FALLTHROUGH */

	default:
	  SCOPY_CHAR_M (r, string, send, sindex);
	  break;

	case '\'':
	  if ((quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)) || dquote)
	    {
	      *r++ = c;
	      sindex++;
	      break;
	    }
	  tindex = sindex + 1;
	  temp = string_extract_single_quoted (string, &tindex);
	  if (temp)
	    {
	      strcpy (r, temp);
	      r += strlen (r);
	      free (temp);
	    }
	  sindex = tindex;
	  break;

	case '"':
	  dquote = 1 - dquote;
	  sindex++;
	  break;
	}
    }
    *r = '\0';
    return (result_string);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\subst.c:8,589
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\subst.c:8,704
parsing error 
{
  char *t;
  unsigned char uc;

  ifs_var = v;
  ifs_value = (v && value_cell (v)) ? value_cell (v) : " \t\n";

  /* Should really merge ifs_cmap with sh_syntaxtab.  XXX - doesn't yet
     handle multibyte chars in IFS */
  memset (ifs_cmap, '\0', sizeof (ifs_cmap));
  for (t = ifs_value ; t && *t; t++)
    {
      uc = *t;
      ifs_cmap[uc] = 1;
    }

#if defined (HANDLE_MULTIBYTE)
  if (ifs_value == 0)
    {
      ifs_firstc[0] = '\0';
      ifs_firstc_len = 1;
    }
  else
    {
      size_t ifs_len;
      ifs_len = strnlen (ifs_value, MB_CUR_MAX);
      ifs_firstc_len = MBLEN (ifs_value, ifs_len);
      if (ifs_firstc_len == 1 || ifs_firstc_len == 0 || MB_INVALIDCH (ifs_firstc_len))
	{
	  ifs_firstc[0] = ifs_value[0];
	  ifs_firstc[1] = '\0';
	  ifs_firstc_len = 1;
	}
      else
	memcpy (ifs_firstc, ifs_value, ifs_firstc_len);
    }
#else
  ifs_firstc = ifs_value ? *ifs_value : 0;
#endif
}
warning: parse error {
  char *t;
  unsigned char uc;

  ifs_var = v;
  ifs_value = (v && value_cell (v)) ? value_cell (v) : " \t\n";

  /* Should really merge ifs_cmap with sh_syntaxtab.  XXX - doesn't yet
     handle multibyte chars in IFS */
  memset (ifs_cmap, '\0', sizeof (ifs_cmap));
  for (t = ifs_value ; t && *t; t++)
    {
      uc = *t;
      ifs_cmap[uc] = 1;
    }

#if defined (HANDLE_MULTIBYTE)
  if (ifs_value == 0)
    {
      ifs_firstc[0] = '\0';
      ifs_firstc_len = 1;
    }
  else
    {
      size_t ifs_len;
      ifs_len = strnlen (ifs_value, MB_CUR_MAX);
      ifs_firstc_len = MBLEN (ifs_value, ifs_len);
      if (ifs_firstc_len == 1 || ifs_firstc_len == 0 || MB_INVALIDCH (ifs_firstc_len))
	{
	  ifs_firstc[0] = ifs_value[0];
	  ifs_firstc[1] = '\0';
	  ifs_firstc_len = 1;
	}
      else
	memcpy (ifs_firstc, ifs_value, ifs_firstc_len);
    }
#else
  ifs_firstc = ifs_value ? *ifs_value : 0;
#endif
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\subst.c:8,706
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\subst.c:8,757
parsing error 
{
  WORD_LIST *result;

  if (w)
    {
      char *xifs;

      xifs = ((w->flags & W_QUOTED) || ifs_chars == 0) ? "" : ifs_chars;
      result = list_string (w->word, xifs, w->flags & W_QUOTED);
    }
  else
    result = (WORD_LIST *)NULL;

  return (result);
}
warning: parse error {
  WORD_LIST *result;

  if (w)
    {
      char *xifs;

      xifs = ((w->flags & W_QUOTED) || ifs_chars == 0) ? "" : ifs_chars;
      result = list_string (w->word, xifs, w->flags & W_QUOTED);
    }
  else
    result = (WORD_LIST *)NULL;

  return (result);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\subst.c:8,760
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\subst.c:8,779
parsing error 
{
  WORD_LIST *result, *t, *tresult, *e;

  for (t = list, result = (WORD_LIST *)NULL; t; t = t->next)
    {
      tresult = word_split (t->word, ifs_value);
      if (result == 0)
        result = e = tresult;
      else
	{
	  e->next = tresult;
	  while (e->next)
	    e = e->next;
	}
    }
  return (result);
}
warning: parse error {
  WORD_LIST *result, *t, *tresult, *e;

  for (t = list, result = (WORD_LIST *)NULL; t; t = t->next)
    {
      tresult = word_split (t->word, ifs_value);
      if (result == 0)
        result = e = tresult;
      else
	{
	  e->next = tresult;
	  while (e->next)
	    e = e->next;
	}
    }
  return (result);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\subst.c:8,781
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\subst.c:8,807
parsing error 
{
  set_pipestatus_from_exit (last_command_exit_value);

  /* Cleanup code goes here. */
  expand_no_split_dollar_star = 0;	/* XXX */
  expanding_redir = 0;
  assigning_in_environment = 0;

  if (parse_and_execute_level == 0)
    top_level_cleanup ();			/* from sig.c */

  jump_to_top_level (v);
}
warning: parse error {
  set_pipestatus_from_exit (last_command_exit_value);

  /* Cleanup code goes here. */
  expand_no_split_dollar_star = 0;	/* XXX */
  expanding_redir = 0;
  assigning_in_environment = 0;

  if (parse_and_execute_level == 0)
    top_level_cleanup ();			/* from sig.c */

  jump_to_top_level (v);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\subst.c:8,809
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\subst.c:8,833
parsing error 
{
  register WORD_LIST *vp, *lp;

  if (tlist == 0)
    return ((WORD_LIST *)NULL);

  if (subst_assign_varlist)
    dispose_words (subst_assign_varlist);	/* Clean up after previous error */

  subst_assign_varlist = (WORD_LIST *)NULL;
  vp = lp = tlist;

  /* Separate out variable assignments at the start of the command.
     Loop invariant: vp->next == lp
     Loop postcondition:
	lp = list of words left after assignment statements skipped
	tlist = original list of words
  */
  while (lp && (lp->word->flags & W_ASSIGNMENT))
    {
      vp = lp;
      lp = lp->next;
    }

  /* If lp != tlist, we have some initial assignment statements.
     We make SUBST_ASSIGN_VARLIST point to the list of assignment
     words and TLIST point to the remaining words.  */
  if (lp != tlist)
    {
      subst_assign_varlist = tlist;
      /* ASSERT(vp->next == lp); */
      vp->next = (WORD_LIST *)NULL;	/* terminate variable list */
      tlist = lp;			/* remainder of word list */
    }

  /* vp == end of variable list */
  /* tlist == remainder of original word list without variable assignments */
  if (!tlist)
    /* All the words in tlist were assignment statements */
    return ((WORD_LIST *)NULL);

  /* ASSERT(tlist != NULL); */
  /* ASSERT((tlist->word->flags & W_ASSIGNMENT) == 0); */

  /* If the -k option is in effect, we need to go through the remaining
     words, separate out the assignment words, and place them on
     SUBST_ASSIGN_VARLIST. */
  if (place_keywords_in_env)
    {
      WORD_LIST *tp;	/* tp == running pointer into tlist */

      tp = tlist;
      lp = tlist->next;

      /* Loop Invariant: tp->next == lp */
      /* Loop postcondition: tlist == word list without assignment statements */
      while (lp)
	{
	  if (lp->word->flags & W_ASSIGNMENT)
	    {
	      /* Found an assignment statement, add this word to end of
		 subst_assign_varlist (vp). */
	      if (!subst_assign_varlist)
		subst_assign_varlist = vp = lp;
	      else
		{
		  vp->next = lp;
		  vp = lp;
		}

	      /* Remove the word pointed to by LP from TLIST. */
	      tp->next = lp->next;
	      /* ASSERT(vp == lp); */
	      lp->next = (WORD_LIST *)NULL;
	      lp = tp->next;
	    }
	  else
	    {
	      tp = lp;
	      lp = lp->next;
	    }
	}
    }
  return (tlist);
}
warning: parse error {
  register WORD_LIST *vp, *lp;

  if (tlist == 0)
    return ((WORD_LIST *)NULL);

  if (subst_assign_varlist)
    dispose_words (subst_assign_varlist);	/* Clean up after previous error */

  subst_assign_varlist = (WORD_LIST *)NULL;
  vp = lp = tlist;

  /* Separate out variable assignments at the start of the command.
     Loop invariant: vp->next == lp
     Loop postcondition:
	lp = list of words left after assignment statements skipped
	tlist = original list of words
  */
  while (lp && (lp->word->flags & W_ASSIGNMENT))
    {
      vp = lp;
      lp = lp->next;
    }

  /* If lp != tlist, we have some initial assignment statements.
     We make SUBST_ASSIGN_VARLIST point to the list of assignment
     words and TLIST point to the remaining words.  */
  if (lp != tlist)
    {
      subst_assign_varlist = tlist;
      /* ASSERT(vp->next == lp); */
      vp->next = (WORD_LIST *)NULL;	/* terminate variable list */
      tlist = lp;			/* remainder of word list */
    }

  /* vp == end of variable list */
  /* tlist == remainder of original word list without variable assignments */
  if (!tlist)
    /* All the words in tlist were assignment statements */
    return ((WORD_LIST *)NULL);

  /* ASSERT(tlist != NULL); */
  /* ASSERT((tlist->word->flags & W_ASSIGNMENT) == 0); */

  /* If the -k option is in effect, we need to go through the remaining
     words, separate out the assignment words, and place them on
     SUBST_ASSIGN_VARLIST. */
  if (place_keywords_in_env)
    {
      WORD_LIST *tp;	/* tp == running pointer into tlist */

      tp = tlist;
      lp = tlist->next;

      /* Loop Invariant: tp->next == lp */
      /* Loop postcondition: tlist == word list without assignment statements */
      while (lp)
	{
	  if (lp->word->flags & W_ASSIGNMENT)
	    {
	      /* Found an assignment statement, add this word to end of
		 subst_assign_varlist (vp). */
	      if (!subst_assign_varlist)
		subst_assign_varlist = vp = lp;
	      else
		{
		  vp->next = lp;
		  vp = lp;
		}

	      /* Remove the word pointed to by LP from TLIST. */
	      tp->next = lp->next;
	      /* ASSERT(vp == lp); */
	      lp->next = (WORD_LIST *)NULL;
	      lp = tp->next;
	    }
	  else
	    {
	      tp = lp;
	      lp = lp->next;
	    }
	}
    }
  return (tlist);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\subst.c:8,835
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\subst.c:8,945
parsing error 
{
  return (expand_word_list_internal (list, WEXP_ALL));
}
warning: parse error {
  return (expand_word_list_internal (list, WEXP_ALL));
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\subst.c:8,947
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\subst.c:8,954
parsing error 
{
  return (expand_word_list_internal (list, WEXP_NOVARS));
}
warning: parse error {
  return (expand_word_list_internal (list, WEXP_NOVARS));
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\subst.c:8,956
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\subst.c:8,961
parsing error 
{
  return (expand_word_list_internal (list, WEXP_SHELLEXP));
}
warning: parse error {
  return (expand_word_list_internal (list, WEXP_SHELLEXP));
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\subst.c:8,963
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\subst.c:8,968
parsing error 
{
  char **glob_array, *temp_string;
  register int glob_index;
  WORD_LIST *glob_list, *output_list, *disposables, *next;
  WORD_DESC *tword;

  output_list = disposables = (WORD_LIST *)NULL;
  glob_array = (char **)NULL;
  while (tlist)
    {
      /* For each word, either globbing is attempted or the word is
	 added to orig_list.  If globbing succeeds, the results are
	 added to orig_list and the word (tlist) is added to the list
	 of disposable words.  If globbing fails and failed glob
	 expansions are left unchanged (the shell default), the
	 original word is added to orig_list.  If globbing fails and
	 failed glob expansions are removed, the original word is
	 added to the list of disposable words.  orig_list ends up
	 in reverse order and requires a call to REVERSE_LIST to
	 be set right.  After all words are examined, the disposable
	 words are freed. */
      next = tlist->next;

      /* If the word isn't an assignment and contains an unquoted
	 pattern matching character, then glob it. */
      if ((tlist->word->flags & W_NOGLOB) == 0 &&
	  unquoted_glob_pattern_p (tlist->word->word))
	{
	  glob_array = shell_glob_filename (tlist->word->word);

	  /* Handle error cases.
	     I don't think we should report errors like "No such file
	     or directory".  However, I would like to report errors
	     like "Read failed". */

	  if (glob_array == 0 || GLOB_FAILED (glob_array))
	    {
	      glob_array = (char **)xmalloc (sizeof (char *));
	      glob_array[0] = (char *)NULL;
	    }

	  /* Dequote the current word in case we have to use it. */
	  if (glob_array[0] == NULL)
	    {
	      temp_string = dequote_string (tlist->word->word);
	      free (tlist->word->word);
	      tlist->word->word = temp_string;
	    }

	  /* Make the array into a word list. */
	  glob_list = (WORD_LIST *)NULL;
	  for (glob_index = 0; glob_array[glob_index]; glob_index++)
	    {
	      tword = make_bare_word (glob_array[glob_index]);
	      tword->flags |= W_GLOBEXP;	/* XXX */
	      glob_list = make_word_list (tword, glob_list);
	    }

	  if (glob_list)
	    {
	      output_list = (WORD_LIST *)list_append (glob_list, output_list);
	      PREPEND_LIST (tlist, disposables);
	    }
	  else if (fail_glob_expansion != 0)
	    {
	      report_error (_("no match: %s"), tlist->word->word);
	      exp_jump_to_top_level (DISCARD);
	    }
	  else if (allow_null_glob_expansion == 0)
	    {
	      /* Failed glob expressions are left unchanged. */
	      PREPEND_LIST (tlist, output_list);
	    }
	  else
	    {
	      /* Failed glob expressions are removed. */
	      PREPEND_LIST (tlist, disposables);
	    }
	}
      else
	{
	  /* Dequote the string. */
	  temp_string = dequote_string (tlist->word->word);
	  free (tlist->word->word);
	  tlist->word->word = temp_string;
	  PREPEND_LIST (tlist, output_list);
	}

      strvec_dispose (glob_array);
      glob_array = (char **)NULL;

      tlist = next;
    }

  if (disposables)
    dispose_words (disposables);

  if (output_list)
    output_list = REVERSE_LIST (output_list, WORD_LIST *);

  return (output_list);
}
warning: parse error {
  char **glob_array, *temp_string;
  register int glob_index;
  WORD_LIST *glob_list, *output_list, *disposables, *next;
  WORD_DESC *tword;

  output_list = disposables = (WORD_LIST *)NULL;
  glob_array = (char **)NULL;
  while (tlist)
    {
      /* For each word, either globbing is attempted or the word is
	 added to orig_list.  If globbing succeeds, the results are
	 added to orig_list and the word (tlist) is added to the list
	 of disposable words.  If globbing fails and failed glob
	 expansions are left unchanged (the shell default), the
	 original word is added to orig_list.  If globbing fails and
	 failed glob expansions are removed, the original word is
	 added to the list of disposable words.  orig_list ends up
	 in reverse order and requires a call to REVERSE_LIST to
	 be set right.  After all words are examined, the disposable
	 words are freed. */
      next = tlist->next;

      /* If the word isn't an assignment and contains an unquoted
	 pattern matching character, then glob it. */
      if ((tlist->word->flags & W_NOGLOB) == 0 &&
	  unquoted_glob_pattern_p (tlist->word->word))
	{
	  glob_array = shell_glob_filename (tlist->word->word);

	  /* Handle error cases.
	     I don't think we should report errors like "No such file
	     or directory".  However, I would like to report errors
	     like "Read failed". */

	  if (glob_array == 0 || GLOB_FAILED (glob_array))
	    {
	      glob_array = (char **)xmalloc (sizeof (char *));
	      glob_array[0] = (char *)NULL;
	    }

	  /* Dequote the current word in case we have to use it. */
	  if (glob_array[0] == NULL)
	    {
	      temp_string = dequote_string (tlist->word->word);
	      free (tlist->word->word);
	      tlist->word->word = temp_string;
	    }

	  /* Make the array into a word list. */
	  glob_list = (WORD_LIST *)NULL;
	  for (glob_index = 0; glob_array[glob_index]; glob_index++)
	    {
	      tword = make_bare_word (glob_array[glob_index]);
	      tword->flags |= W_GLOBEXP;	/* XXX */
	      glob_list = make_word_list (tword, glob_list);
	    }

	  if (glob_list)
	    {
	      output_list = (WORD_LIST *)list_append (glob_list, output_list);
	      PREPEND_LIST (tlist, disposables);
	    }
	  else if (fail_glob_expansion != 0)
	    {
	      report_error (_("no match: %s"), tlist->word->word);
	      exp_jump_to_top_level (DISCARD);
	    }
	  else if (allow_null_glob_expansion == 0)
	    {
	      /* Failed glob expressions are left unchanged. */
	      PREPEND_LIST (tlist, output_list);
	    }
	  else
	    {
	      /* Failed glob expressions are removed. */
	      PREPEND_LIST (tlist, disposables);
	    }
	}
      else
	{
	  /* Dequote the string. */
	  temp_string = dequote_string (tlist->word->word);
	  free (tlist->word->word);
	  tlist->word->word = temp_string;
	  PREPEND_LIST (tlist, output_list);
	}

      strvec_dispose (glob_array);
      glob_array = (char **)NULL;

      tlist = next;
    }

  if (disposables)
    dispose_words (disposables);

  if (output_list)
    output_list = REVERSE_LIST (output_list, WORD_LIST *);

  return (output_list);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\subst.c:8,971
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\subst.c:9,164
parsing error 
{
  WORD_LIST *expanded, *orig_list, *new_list, *next, *temp_list;
  int expanded_something, has_dollar_at;
  char *temp_string;

  /* We do tilde expansion all the time.  This is what 1003.2 says. */
  new_list = (WORD_LIST *)NULL;
  for (orig_list = tlist; tlist; tlist = next)
    {
      temp_string = tlist->word->word;

      next = tlist->next;

#if defined (ARRAY_VARS)
      /* If this is a compound array assignment to a builtin that accepts
         such assignments (e.g., `declare'), take the assignment and perform
         it separately, handling the semantics of declarations inside shell
         functions.  This avoids the double-evaluation of such arguments,
         because `declare' does some evaluation of compound assignments on
         its own. */
      if ((tlist->word->flags & (W_COMPASSIGN|W_ASSIGNARG)) == (W_COMPASSIGN|W_ASSIGNARG))
	{
	  int t;

	  if (tlist->word->flags & W_ASSIGNASSOC)
	    make_internal_declare (tlist->word->word, "-A");

	  t = do_word_assignment (tlist->word, 0);
	  if (t == 0)
	    {
	      last_command_exit_value = EXECUTION_FAILURE;
	      exp_jump_to_top_level (DISCARD);
	    }

	  /* Now transform the word as ksh93 appears to do and go on */
	  t = assignment (tlist->word->word, 0);
	  tlist->word->word[t] = '\0';
	  tlist->word->flags &= ~(W_ASSIGNMENT|W_NOSPLIT|W_COMPASSIGN|W_ASSIGNARG|W_ASSIGNASSOC);
	}
#endif

      expanded_something = 0;
      expanded = expand_word_internal
	(tlist->word, 0, 0, &has_dollar_at, &expanded_something);

      if (expanded == &expand_word_error || expanded == &expand_word_fatal)
	{
	  /* By convention, each time this error is returned,
	     tlist->word->word has already been freed. */
	  tlist->word->word = (char *)NULL;

	  /* Dispose our copy of the original list. */
	  dispose_words (orig_list);
	  /* Dispose the new list we're building. */
	  dispose_words (new_list);

	  last_command_exit_value = EXECUTION_FAILURE;
	  if (expanded == &expand_word_error)
	    exp_jump_to_top_level (DISCARD);
	  else
	    exp_jump_to_top_level (FORCE_EOF);
	}

      /* Don't split words marked W_NOSPLIT. */
      if (expanded_something && (tlist->word->flags & W_NOSPLIT) == 0)
	{
	  temp_list = word_list_split (expanded);
	  dispose_words (expanded);
	}
      else
	{
	  /* If no parameter expansion, command substitution, process
	     substitution, or arithmetic substitution took place, then
	     do not do word splitting.  We still have to remove quoted
	     null characters from the result. */
	  word_list_remove_quoted_nulls (expanded);
	  temp_list = expanded;
	}

      expanded = REVERSE_LIST (temp_list, WORD_LIST *);
      new_list = (WORD_LIST *)list_append (expanded, new_list);
    }

  if (orig_list)  
    dispose_words (orig_list);

  if (new_list)
    new_list = REVERSE_LIST (new_list, WORD_LIST *);

  return (new_list);
}
warning: parse error {
  WORD_LIST *expanded, *orig_list, *new_list, *next, *temp_list;
  int expanded_something, has_dollar_at;
  char *temp_string;

  /* We do tilde expansion all the time.  This is what 1003.2 says. */
  new_list = (WORD_LIST *)NULL;
  for (orig_list = tlist; tlist; tlist = next)
    {
      temp_string = tlist->word->word;

      next = tlist->next;

#if defined (ARRAY_VARS)
      /* If this is a compound array assignment to a builtin that accepts
         such assignments (e.g., `declare'), take the assignment and perform
         it separately, handling the semantics of declarations inside shell
         functions.  This avoids the double-evaluation of such arguments,
         because `declare' does some evaluation of compound assignments on
         its own. */
      if ((tlist->word->flags & (W_COMPASSIGN|W_ASSIGNARG)) == (W_COMPASSIGN|W_ASSIGNARG))
	{
	  int t;

	  if (tlist->word->flags & W_ASSIGNASSOC)
	    make_internal_declare (tlist->word->word, "-A");

	  t = do_word_assignment (tlist->word, 0);
	  if (t == 0)
	    {
	      last_command_exit_value = EXECUTION_FAILURE;
	      exp_jump_to_top_level (DISCARD);
	    }

	  /* Now transform the word as ksh93 appears to do and go on */
	  t = assignment (tlist->word->word, 0);
	  tlist->word->word[t] = '\0';
	  tlist->word->flags &= ~(W_ASSIGNMENT|W_NOSPLIT|W_COMPASSIGN|W_ASSIGNARG|W_ASSIGNASSOC);
	}
#endif

      expanded_something = 0;
      expanded = expand_word_internal
	(tlist->word, 0, 0, &has_dollar_at, &expanded_something);

      if (expanded == &expand_word_error || expanded == &expand_word_fatal)
	{
	  /* By convention, each time this error is returned,
	     tlist->word->word has already been freed. */
	  tlist->word->word = (char *)NULL;

	  /* Dispose our copy of the original list. */
	  dispose_words (orig_list);
	  /* Dispose the new list we're building. */
	  dispose_words (new_list);

	  last_command_exit_value = EXECUTION_FAILURE;
	  if (expanded == &expand_word_error)
	    exp_jump_to_top_level (DISCARD);
	  else
	    exp_jump_to_top_level (FORCE_EOF);
	}

      /* Don't split words marked W_NOSPLIT. */
      if (expanded_something && (tlist->word->flags & W_NOSPLIT) == 0)
	{
	  temp_list = word_list_split (expanded);
	  dispose_words (expanded);
	}
      else
	{
	  /* If no parameter expansion, command substitution, process
	     substitution, or arithmetic substitution took place, then
	     do not do word splitting.  We still have to remove quoted
	     null characters from the result. */
	  word_list_remove_quoted_nulls (expanded);
	  temp_list = expanded;
	}

      expanded = REVERSE_LIST (temp_list, WORD_LIST *);
      new_list = (WORD_LIST *)list_append (expanded, new_list);
    }

  if (orig_list)  
    dispose_words (orig_list);

  if (new_list)
    new_list = REVERSE_LIST (new_list, WORD_LIST *);

  return (new_list);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\subst.c:9,167
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\subst.c:9,271
parsing error 
{
  WORD_LIST *new_list, *temp_list;
  int tint;

  if (list == 0)
    return ((WORD_LIST *)NULL);

  garglist = new_list = copy_word_list (list);
  if (eflags & WEXP_VARASSIGN)
    {
      garglist = new_list = separate_out_assignments (new_list);
      if (new_list == 0)
	{
	  if (subst_assign_varlist)
	    {
	      /* All the words were variable assignments, so they are placed
		 into the shell's environment. */
	      for (temp_list = subst_assign_varlist; temp_list; temp_list = temp_list->next)
		{
		  this_command_name = (char *)NULL;	/* no arithmetic errors */
		  tint = do_word_assignment (temp_list->word, 0);
		  /* Variable assignment errors in non-interactive shells
		     running in Posix.2 mode cause the shell to exit. */
		  if (tint == 0)
		    {
		      last_command_exit_value = EXECUTION_FAILURE;
		      if (interactive_shell == 0 && posixly_correct)
			exp_jump_to_top_level (FORCE_EOF);
		      else
			exp_jump_to_top_level (DISCARD);
		    }
		}
	      dispose_words (subst_assign_varlist);
	      subst_assign_varlist = (WORD_LIST *)NULL;
	    }
	  return ((WORD_LIST *)NULL);
	}
    }

  /* Begin expanding the words that remain.  The expansions take place on
     things that aren't really variable assignments. */

#if defined (BRACE_EXPANSION)
  /* Do brace expansion on this word if there are any brace characters
     in the string. */
  if ((eflags & WEXP_BRACEEXP) && brace_expansion && new_list)
    new_list = brace_expand_word_list (new_list, eflags);
#endif /* BRACE_EXPANSION */

  /* Perform the `normal' shell expansions: tilde expansion, parameter and
     variable substitution, command substitution, arithmetic expansion,
     and word splitting. */
  new_list = shell_expand_word_list (new_list, eflags);

  /* Okay, we're almost done.  Now let's just do some filename
     globbing. */
  if (new_list)
    {
      if ((eflags & WEXP_PATHEXP) && disallow_filename_globbing == 0)
	/* Glob expand the word list unless globbing has been disabled. */
	new_list = glob_expand_word_list (new_list, eflags);
      else
	/* Dequote the words, because we're not performing globbing. */
	new_list = dequote_list (new_list);
    }

  if ((eflags & WEXP_VARASSIGN) && subst_assign_varlist)
    {
      sh_wassign_func_t *assign_func;
      int is_special_builtin, is_builtin_or_func;

      /* If the remainder of the words expand to nothing, Posix.2 requires
	 that the variable and environment assignments affect the shell's
	 environment. */
      assign_func = new_list ? assign_in_env : do_word_assignment;
      tempenv_assign_error = 0;

      is_builtin_or_func = (new_list && new_list->word && (find_shell_builtin (new_list->word->word) || find_function (new_list->word->word)));
      /* Posix says that special builtins exit if a variable assignment error
	 occurs in an assignment preceding it. */
      is_special_builtin = (posixly_correct && new_list && new_list->word && find_special_builtin (new_list->word->word));
      
      for (temp_list = subst_assign_varlist; temp_list; temp_list = temp_list->next)
	{
	  this_command_name = (char *)NULL;
	  assigning_in_environment = (assign_func == assign_in_env);
	  tint = (*assign_func) (temp_list->word, is_builtin_or_func);
	  assigning_in_environment = 0;
	  /* Variable assignment errors in non-interactive shells running
	     in Posix.2 mode cause the shell to exit. */
	  if (tint == 0)
	    {
	      if (assign_func == do_word_assignment)
		{
		  last_command_exit_value = EXECUTION_FAILURE;
		  if (interactive_shell == 0 && posixly_correct && is_special_builtin)
		    exp_jump_to_top_level (FORCE_EOF);
		  else
		    exp_jump_to_top_level (DISCARD);
		}
	      else
		tempenv_assign_error++;
	    }
	}

      dispose_words (subst_assign_varlist);
      subst_assign_varlist = (WORD_LIST *)NULL;
    }

#if 0
  tint = list_length (new_list) + 1;
  RESIZE_MALLOCED_BUFFER (glob_argv_flags, 0, tint, glob_argv_flags_size, 16);
  for (tint = 0, temp_list = new_list; temp_list; temp_list = temp_list->next)
    glob_argv_flags[tint++] = (temp_list->word->flags & W_GLOBEXP) ? '1' : '0';
  glob_argv_flags[tint] = '\0';
#endif

  return (new_list);
}
warning: parse error {
  WORD_LIST *new_list, *temp_list;
  int tint;

  if (list == 0)
    return ((WORD_LIST *)NULL);

  garglist = new_list = copy_word_list (list);
  if (eflags & WEXP_VARASSIGN)
    {
      garglist = new_list = separate_out_assignments (new_list);
      if (new_list == 0)
	{
	  if (subst_assign_varlist)
	    {
	      /* All the words were variable assignments, so they are placed
		 into the shell's environment. */
	      for (temp_list = subst_assign_varlist; temp_list; temp_list = temp_list->next)
		{
		  this_command_name = (char *)NULL;	/* no arithmetic errors */
		  tint = do_word_assignment (temp_list->word, 0);
		  /* Variable assignment errors in non-interactive shells
		     running in Posix.2 mode cause the shell to exit. */
		  if (tint == 0)
		    {
		      last_command_exit_value = EXECUTION_FAILURE;
		      if (interactive_shell == 0 && posixly_correct)
			exp_jump_to_top_level (FORCE_EOF);
		      else
			exp_jump_to_top_level (DISCARD);
		    }
		}
	      dispose_words (subst_assign_varlist);
	      subst_assign_varlist = (WORD_LIST *)NULL;
	    }
	  return ((WORD_LIST *)NULL);
	}
    }

  /* Begin expanding the words that remain.  The expansions take place on
     things that aren't really variable assignments. */

#if defined (BRACE_EXPANSION)
  /* Do brace expansion on this word if there are any brace characters
     in the string. */
  if ((eflags & WEXP_BRACEEXP) && brace_expansion && new_list)
    new_list = brace_expand_word_list (new_list, eflags);
#endif /* BRACE_EXPANSION */

  /* Perform the `normal' shell expansions: tilde expansion, parameter and
     variable substitution, command substitution, arithmetic expansion,
     and word splitting. */
  new_list = shell_expand_word_list (new_list, eflags);

  /* Okay, we're almost done.  Now let's just do some filename
     globbing. */
  if (new_list)
    {
      if ((eflags & WEXP_PATHEXP) && disallow_filename_globbing == 0)
	/* Glob expand the word list unless globbing has been disabled. */
	new_list = glob_expand_word_list (new_list, eflags);
      else
	/* Dequote the words, because we're not performing globbing. */
	new_list = dequote_list (new_list);
    }

  if ((eflags & WEXP_VARASSIGN) && subst_assign_varlist)
    {
      sh_wassign_func_t *assign_func;
      int is_special_builtin, is_builtin_or_func;

      /* If the remainder of the words expand to nothing, Posix.2 requires
	 that the variable and environment assignments affect the shell's
	 environment. */
      assign_func = new_list ? assign_in_env : do_word_assignment;
      tempenv_assign_error = 0;

      is_builtin_or_func = (new_list && new_list->word && (find_shell_builtin (new_list->word->word) || find_function (new_list->word->word)));
      /* Posix says that special builtins exit if a variable assignment error
	 occurs in an assignment preceding it. */
      is_special_builtin = (posixly_correct && new_list && new_list->word && find_special_builtin (new_list->word->word));
      
      for (temp_list = subst_assign_varlist; temp_list; temp_list = temp_list->next)
	{
	  this_command_name = (char *)NULL;
	  assigning_in_environment = (assign_func == assign_in_env);
	  tint = (*assign_func) (temp_list->word, is_builtin_or_func);
	  assigning_in_environment = 0;
	  /* Variable assignment errors in non-interactive shells running
	     in Posix.2 mode cause the shell to exit. */
	  if (tint == 0)
	    {
	      if (assign_func == do_word_assignment)
		{
		  last_command_exit_value = EXECUTION_FAILURE;
		  if (interactive_shell == 0 && posixly_correct && is_special_builtin)
		    exp_jump_to_top_level (FORCE_EOF);
		  else
		    exp_jump_to_top_level (DISCARD);
		}
	      else
		tempenv_assign_error++;
	    }
	}

      dispose_words (subst_assign_varlist);
      subst_assign_varlist = (WORD_LIST *)NULL;
    }

#if 0
  tint = list_length (new_list) + 1;
  RESIZE_MALLOCED_BUFFER (glob_argv_flags, 0, tint, glob_argv_flags_size, 16);
  for (tint = 0, temp_list = new_list; temp_list; temp_list = temp_list->next)
    glob_argv_flags[tint++] = (temp_list->word->flags & W_GLOBEXP) ? '1' : '0';
  glob_argv_flags[tint] = '\0';
#endif

  return (new_list);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\subst.c:9,274
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\support\bashversion.c...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\stdc.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\bashansi.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\conftypes.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\support\bashversion.c:63
parsing error 
{
  int opt, oflags;
  char dv[128], *rv;

  if (progname = strrchr (argv[0], '/'))
    progname++;
  else
    progname = argv[0];

  oflags = 0;
  while ((opt = getopt(argc, argv, "hrvmpslx")) != EOF)
    {
      switch (opt)
	{
	case 'h':
	  usage ();
	  exit (0);
	case 'r':
	  oflags |= RFLAG;	/* release */
	  break;
	case 'v':
	  oflags |= VFLAG;	/* version */
	  break;
	case 'm':
	  oflags |= MFLAG;	/* machtype */
	  break;
	case 'p':
	  oflags |= PFLAG;	/* patchlevel */
	  break;
	case 's':		/* short version string */
	  oflags |= SFLAG;
	  break;
	case 'l':		/* long version string */
	  oflags |= LFLAG;
	  break;
	case 'x':		/* extended version information */
	  oflags |= XFLAG;
	  break;
	default:
	  usage ();
	  exit (2);
	}
    }

  argc -= optind;
  argv += optind;

  if (argc > 0)
    {
      usage ();
      exit (2);
    }

  /* default behavior */  
  if (oflags == 0)
    oflags = SFLAG;

  if (oflags & (RFLAG|VFLAG))
    {
      strcpy (dv, dist_version);
      rv = strchr (dv, '.');
      if (rv)
        *rv++ = '\0';
      else
        rv = "00";
    }
  if (oflags & RFLAG)
    printf ("%s\n", dv);
  else if (oflags & VFLAG)
    printf ("%s\n", rv);
  else if (oflags & MFLAG)
    printf ("%s\n", MACHTYPE);
  else if (oflags & PFLAG)
    printf ("%d\n", patch_level);
  else if (oflags & SFLAG)
    printf ("%s\n", shell_version_string ());
  else if (oflags & LFLAG)
    show_shell_version (0);
  else if (oflags & XFLAG)
    show_shell_version (1);

  exit (0);
}
warning: parse error {
  int opt, oflags;
  char dv[128], *rv;

  if (progname = strrchr (argv[0], '/'))
    progname++;
  else
    progname = argv[0];

  oflags = 0;
  while ((opt = getopt(argc, argv, "hrvmpslx")) != EOF)
    {
      switch (opt)
	{
	case 'h':
	  usage ();
	  exit (0);
	case 'r':
	  oflags |= RFLAG;	/* release */
	  break;
	case 'v':
	  oflags |= VFLAG;	/* version */
	  break;
	case 'm':
	  oflags |= MFLAG;	/* machtype */
	  break;
	case 'p':
	  oflags |= PFLAG;	/* patchlevel */
	  break;
	case 's':		/* short version string */
	  oflags |= SFLAG;
	  break;
	case 'l':		/* long version string */
	  oflags |= LFLAG;
	  break;
	case 'x':		/* extended version information */
	  oflags |= XFLAG;
	  break;
	default:
	  usage ();
	  exit (2);
	}
    }

  argc -= optind;
  argv += optind;

  if (argc > 0)
    {
      usage ();
      exit (2);
    }

  /* default behavior */  
  if (oflags == 0)
    oflags = SFLAG;

  if (oflags & (RFLAG|VFLAG))
    {
      strcpy (dv, dist_version);
      rv = strchr (dv, '.');
      if (rv)
        *rv++ = '\0';
      else
        rv = "00";
    }
  if (oflags & RFLAG)
    printf ("%s\n", dv);
  else if (oflags & VFLAG)
    printf ("%s\n", rv);
  else if (oflags & MFLAG)
    printf ("%s\n", MACHTYPE);
  else if (oflags & PFLAG)
    printf ("%d\n", patch_level);
  else if (oflags & SFLAG)
    printf ("%s\n", shell_version_string ());
  else if (oflags & LFLAG)
    show_shell_version (0);
  else if (oflags & XFLAG)
    show_shell_version (1);

  exit (0);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\support\bashversion.c:66
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\support\man2html.c...
parsing error 
main(int argc, char **argv)
{
	FILE   *f;
	char   *t;
	int     l, i;
	char   *buf;
	char   *h, *fullname;
	STRDEF *stdf;

	t = NULL;
	while ((i = getopt(argc, argv, "")) != EOF) {
		switch (i) {
		default:
			usage();
			exit(EXIT_USAGE);
		}
	}

	if (argc != 2) {
		usage();
		exit(EXIT_USAGE);
	}
	manpage = h = t = argv[1];
	i = 0;

	buf = read_man_page(h);
	if (!buf) {
		fprintf(stderr, "man2html: cannot read %s: %s\n", h, strerror(errno));
		exit(1);
	}
#ifdef MAKEINDEX
	idxfile = fopen(INDEXFILE, "a");
#endif
	stdf = &standardchar[0];
	i = 0;
	while (stdf->nr) {
		stdf->next = &standardchar[i];
		stdf = stdf->next;
		i++;
	}
	chardef = &standardchar[0];

	stdf = &standardstring[0];
	i = 0;
	while (stdf->nr) {
		stdf->next = &standardstring[i];
		stdf = stdf->next;
		i++;
	}
	strdef = &standardstring[0];

	intdef = &standardint[0];
	i = 0;
	while (intdef->nr) {
		intdef->next = &standardint[i];
		intdef = intdef->next;
		i++;
	}
	intdef = &standardint[0];

	defdef = NULL;

	scan_troff(buf + 1, 0, NULL);

	while (itemdepth || dl_set[itemdepth]) {
		out_html("</DL>\n");
		if (dl_set[itemdepth])
			dl_set[itemdepth] = 0;
		else if (itemdepth > 0)
			itemdepth--;
	}

	out_html(change_to_font(0));
	out_html(change_to_size(0));
	if (!fillout) {
		fillout = 1;
		out_html("</PRE>");
	}
	out_html(NEWLINE);

	if (output_possible) {
		outputPageFooter(th_version, th_datestr, th_page_and_sec);
		/* &nbsp; for mosaic users */
		fputs("<HR>\n<A NAME=\"index\">&nbsp;</A><H2>Index</H2>\n<DL>\n", stdout);
		manidx[mip] = 0;
		fputs(manidx, stdout);
		if (subs)
			fputs("</DL>\n", stdout);
		fputs("</DL>\n", stdout);
		print_sig();
		fputs("</BODY>\n</HTML>\n", stdout);
	} else
		fprintf(stderr, "man2html: no output produced\n");
#ifdef MAKEINDEX
	if (idxfile)
		fclose(idxfile);
#endif
	exit(EXIT_SUCCESS);
}
warning: parse error main(int argc, char **argv)
{
	FILE   *f;
	char   *t;
	int     l, i;
	char   *buf;
	char   *h, *fullname;
	STRDEF *stdf;

	t = NULL;
	while ((i = getopt(argc, argv, "")) != EOF) {
		switch (i) {
		default:
			usage();
			exit(EXIT_USAGE);
		}
	}

	if (argc != 2) {
		usage();
		exit(EXIT_USAGE);
	}
	manpage = h = t = argv[1];
	i = 0;

	buf = read_man_page(h);
	if (!buf) {
		fprintf(stderr, "man2html: cannot read %s: %s\n", h, strerror(errno));
		exit(1);
	}
#ifdef MAKEINDEX
	idxfile = fopen(INDEXFILE, "a");
#endif
	stdf = &standardchar[0];
	i = 0;
	while (stdf->nr) {
		stdf->next = &standardchar[i];
		stdf = stdf->next;
		i++;
	}
	chardef = &standardchar[0];

	stdf = &standardstring[0];
	i = 0;
	while (stdf->nr) {
		stdf->next = &standardstring[i];
		stdf = stdf->next;
		i++;
	}
	strdef = &standardstring[0];

	intdef = &standardint[0];
	i = 0;
	while (intdef->nr) {
		intdef->next = &standardint[i];
		intdef = intdef->next;
		i++;
	}
	intdef = &standardint[0];

	defdef = NULL;

	scan_troff(buf + 1, 0, NULL);

	while (itemdepth || dl_set[itemdepth]) {
		out_html("</DL>\n");
		if (dl_set[itemdepth])
			dl_set[itemdepth] = 0;
		else if (itemdepth > 0)
			itemdepth--;
	}

	out_html(change_to_font(0));
	out_html(change_to_size(0));
	if (!fillout) {
		fillout = 1;
		out_html("</PRE>");
	}
	out_html(NEWLINE);

	if (output_possible) {
		outputPageFooter(th_version, th_datestr, th_page_and_sec);
		/* &nbsp; for mosaic users */
		fputs("<HR>\n<A NAME=\"index\">&nbsp;</A><H2>Index</H2>\n<DL>\n", stdout);
		manidx[mip] = 0;
		fputs(manidx, stdout);
		if (subs)
			fputs("</DL>\n", stdout);
		fputs("</DL>\n", stdout);
		print_sig();
		fputs("</BODY>\n</HTML>\n", stdout);
	} else
		fprintf(stderr, "man2html: no output produced\n");
#ifdef MAKEINDEX
	if (idxfile)
		fclose(idxfile);
#endif
	exit(EXIT_SUCCESS);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\support\man2html.c:3,975
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\support\mksignames.c...
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\support\mksignames.c:48
parsing error 
{
  register int i;

  fprintf (stream, "/* This file was automatically created by %s.\n",
	   progname);
  fprintf (stream, "   Do not edit.  Edit support/mksignames.c instead. */\n\n");
  fprintf (stream,
	   "/* A translation list so we can be polite to our users. */\n");
#if defined (CROSS_COMPILING)
  fprintf (stream, "extern char *signal_names[];\n\n");
  fprintf (stream, "extern void initialize_signames __P((void));\n\n");
#else
  fprintf (stream, "char *signal_names[NSIG + 4] = {\n");

  for (i = 0; i <= LASTSIG; i++)
    fprintf (stream, "    \"%s\",\n", signal_names[i]);

  fprintf (stream, "    (char *)0x0\n");
  fprintf (stream, "};\n\n");
  fprintf (stream, "#define initialize_signames()\n\n");
#endif
}
warning: parse error {
  register int i;

  fprintf (stream, "/* This file was automatically created by %s.\n",
	   progname);
  fprintf (stream, "   Do not edit.  Edit support/mksignames.c instead. */\n\n");
  fprintf (stream,
	   "/* A translation list so we can be polite to our users. */\n");
#if defined (CROSS_COMPILING)
  fprintf (stream, "extern char *signal_names[];\n\n");
  fprintf (stream, "extern void initialize_signames __P((void));\n\n");
#else
  fprintf (stream, "char *signal_names[NSIG + 4] = {\n");

  for (i = 0; i <= LASTSIG; i++)
    fprintf (stream, "    \"%s\",\n", signal_names[i]);

  fprintf (stream, "    (char *)0x0\n");
  fprintf (stream, "};\n\n");
  fprintf (stream, "#define initialize_signames()\n\n");
#endif
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\support\mksignames.c:50
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\support\mksignames.c:74
parsing error 
{
  char *stream_name;
  FILE *stream;

  progname = argv[0];

  if (argc == 1)
    {
      stream_name = "stdout";
      stream = stdout;
    }
  else if (argc == 2)
    {
      stream_name = argv[1];
      stream = fopen (stream_name, "w");
    }
  else
    {
      fprintf (stderr, "Usage: %s [output-file]\n", progname);
      exit (1);
    }

  if (!stream)
    {
      fprintf (stderr, "%s: %s: cannot open for writing\n",
	       progname, stream_name);
      exit (2);
    }

#if !defined (CROSS_COMPILING)
  initialize_signames ();
#endif
  write_signames (stream);
  exit (0);
}
warning: parse error {
  char *stream_name;
  FILE *stream;

  progname = argv[0];

  if (argc == 1)
    {
      stream_name = "stdout";
      stream = stdout;
    }
  else if (argc == 2)
    {
      stream_name = argv[1];
      stream = fopen (stream_name, "w");
    }
  else
    {
      fprintf (stderr, "Usage: %s [output-file]\n", progname);
      exit (1);
    }

  if (!stream)
    {
      fprintf (stderr, "%s: %s: cannot open for writing\n",
	       progname, stream_name);
      exit (2);
    }

#if !defined (CROSS_COMPILING)
  initialize_signames ();
#endif
  write_signames (stream);
  exit (0);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\support\mksignames.c:77
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\support\printenv.c...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\bashansi.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\support\printenv.c:36
parsing error 
{
  register char **envp, *eval;
  int len;

  argv++;
  argc--;

  /* printenv */
  if (argc == 0)
    {
      for (envp = environ; *envp; envp++)
	puts (*envp);
      exit (0);
    }

  /* printenv varname */
  len = strlen (*argv);
  for (envp = environ; *envp; envp++)
    {
      if (**argv == **envp && strncmp (*envp, *argv, len) == 0)
	{
	  eval = *envp + len;
	  /* If the environment variable doesn't have an `=', ignore it. */
	  if (*eval == '=')
	    {
	      puts (eval + 1);
	      exit (0);
	    }
	}
    }
  exit (1);
}
warning: parse error {
  register char **envp, *eval;
  int len;

  argv++;
  argc--;

  /* printenv */
  if (argc == 0)
    {
      for (envp = environ; *envp; envp++)
	puts (*envp);
      exit (0);
    }

  /* printenv varname */
  len = strlen (*argv);
  for (envp = environ; *envp; envp++)
    {
      if (**argv == **envp && strncmp (*envp, *argv, len) == 0)
	{
	  eval = *envp + len;
	  /* If the environment variable doesn't have an `=', ignore it. */
	  if (*eval == '=')
	    {
	      puts (eval + 1);
	      exit (0);
	    }
	}
    }
  exit (1);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\support\printenv.c:39
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\support\recho.c...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\bashansi.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\support\recho.c:37
parsing error 
{
	register int	i;

	for (i = 1; i < argc; i++) {
		printf("argv[%d] = <", i);
		strprint(argv[i]);
		printf(">\n");
	}
	exit(0);
}
warning: parse error {
	register int	i;

	for (i = 1; i < argc; i++) {
		printf("argv[%d] = <", i);
		strprint(argv[i]);
		printf(">\n");
	}
	exit(0);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\support\recho.c:40
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\support\recho.c:52
parsing error 
{
	register unsigned char *s;

	for (s = (unsigned char *)str; s && *s; s++) {
		if (*s < ' ') {
			putchar('^');
			putchar(*s+64);
		} else if (*s == 127) {
			putchar('^');
			putchar('?');
		} else
			putchar(*s);
	}
}
warning: parse error {
	register unsigned char *s;

	for (s = (unsigned char *)str; s && *s; s++) {
		if (*s < ' ') {
			putchar('^');
			putchar(*s+64);
		} else if (*s == 127) {
			putchar('^');
			putchar('?');
		} else
			putchar(*s);
	}
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\support\recho.c:54
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\support\signames.c...
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\support\xcase.c...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\bashansi.h...skip
parsing error 
main(ac, av)
int	ac;
warning: parse error main(ac, av)
int	ac;Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\support\xcase.c:42
parsing error 
{
	int	c, x;
	int	op;
	FILE	*inf;

	op = 0;
	while ((c = getopt(ac, av, "lnu")) != EOF) {
		switch (c) {
		case 'n':
			setbuf (stdout, (char *)NULL);
			break;
		case 'u':
			op = UPPER;
			break;
		case 'l':
			op = LOWER;
			break;
		default:
			fprintf(stderr, "casemod: usage: casemod [-lnu] [file]\n");
			exit(2);
		}
	}
	av += optind;
	ac -= optind;

	if (av[0] && (av[0][0] != '-' || av[0][1])) {
		inf = fopen(av[0], "r");
		if (inf == 0) {
			fprintf(stderr, "casemod: %s: cannot open: %s\n", av[0], strerror(errno));
			exit(1);
		}
	} else
		inf = stdin;

	while ((c = getc(inf)) != EOF) {
		switch (op) {
		case UPPER:
			x = islower(c) ? toupper(c) : c;
			break;
		case LOWER:
			x = isupper(c) ? tolower(c) : c;
			break;
		default:
			x = c;
			break;
		}
		putchar(x);
	}
			
	exit(0);
}
warning: parse error {
	int	c, x;
	int	op;
	FILE	*inf;

	op = 0;
	while ((c = getopt(ac, av, "lnu")) != EOF) {
		switch (c) {
		case 'n':
			setbuf (stdout, (char *)NULL);
			break;
		case 'u':
			op = UPPER;
			break;
		case 'l':
			op = LOWER;
			break;
		default:
			fprintf(stderr, "casemod: usage: casemod [-lnu] [file]\n");
			exit(2);
		}
	}
	av += optind;
	ac -= optind;

	if (av[0] && (av[0][0] != '-' || av[0][1])) {
		inf = fopen(av[0], "r");
		if (inf == 0) {
			fprintf(stderr, "casemod: %s: cannot open: %s\n", av[0], strerror(errno));
			exit(1);
		}
	} else
		inf = stdin;

	while ((c = getc(inf)) != EOF) {
		switch (op) {
		case UPPER:
			x = islower(c) ? toupper(c) : c;
			break;
		case LOWER:
			x = isupper(c) ? tolower(c) : c;
			break;
		default:
			x = c;
			break;
		}
		putchar(x);
	}
			
	exit(0);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\support\xcase.c:45
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\support\zecho.c...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\bashansi.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\support\zecho.c:29
parsing error 
{
	argv++;

	while (*argv) {
		(void)printf("%s", *argv);
		if (*++argv)
			putchar(' ');
	}

	putchar('\n');
	exit(0);
}
warning: parse error {
	argv++;

	while (*argv) {
		(void)printf("%s", *argv);
		if (*++argv)
			putchar(' ');
	}

	putchar('\n');
	exit(0);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\support\zecho.c:32
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\test.c...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\bashtypes.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\posixstat.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\filecntl.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\bashintl.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\shell.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\pathexp.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\test.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\common.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\glob\strmatch.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\test.c:132
parsing error 
{
  builtin_error (format, arg);
  test_exit (TEST_ERREXIT_STATUS);
}
warning: parse error {
  builtin_error (format, arg);
  test_exit (TEST_ERREXIT_STATUS);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\test.c:134
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\test.c:152
parsing error 
{
  test_syntax_error (_("%s: integer expression expected"), pch);
}
warning: parse error {
  test_syntax_error (_("%s: integer expression expected"), pch);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\test.c:154
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\test.c:292
parsing error 
{
  struct stat st1, st2;
  int r1, r2;

  if ((r1 = sh_stat (s, &st1)) < 0)
    {
      if (op == EF)
	return (FALSE);
    }
  if ((r2 = sh_stat (t, &st2)) < 0)
    {
      if (op == EF)
	return (FALSE);
    }
  
  switch (op)
    {
    case OT: return (r1 < r2 || (r2 == 0 && st1.st_mtime < st2.st_mtime));
    case NT: return (r1 > r2 || (r1 == 0 && st1.st_mtime > st2.st_mtime));
    case EF: return (same_file (s, t, &st1, &st2));
    }
  return (FALSE);
}
warning: parse error {
  struct stat st1, st2;
  int r1, r2;

  if ((r1 = sh_stat (s, &st1)) < 0)
    {
      if (op == EF)
	return (FALSE);
    }
  if ((r2 = sh_stat (t, &st2)) < 0)
    {
      if (op == EF)
	return (FALSE);
    }
  
  switch (op)
    {
    case OT: return (r1 < r2 || (r2 == 0 && st1.st_mtime < st2.st_mtime));
    case NT: return (r1 > r2 || (r1 == 0 && st1.st_mtime > st2.st_mtime));
    case EF: return (same_file (s, t, &st1, &st2));
    }
  return (FALSE);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\test.c:295
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\test.c:320
parsing error 
{
  intmax_t l, r;
  int expok;

  if (flags & TEST_ARITHEXP)
    {
      l = evalexp (s, &expok);
      if (expok == 0)
	return (FALSE);		/* should probably longjmp here */
      r = evalexp (t, &expok);
      if (expok == 0)
	return (FALSE);		/* ditto */
    }
  else
    {
      if (legal_number (s, &l) == 0)
	integer_expected_error (s);
      if (legal_number (t, &r) == 0)
	integer_expected_error (t);
    }

  switch (op)
    {
    case EQ: return (l == r);
    case NE: return (l != r);
    case LT: return (l < r);
    case GT: return (l > r);
    case LE: return (l <= r);
    case GE: return (l >= r);
    }

  return (FALSE);
}
warning: parse error {
  intmax_t l, r;
  int expok;

  if (flags & TEST_ARITHEXP)
    {
      l = evalexp (s, &expok);
      if (expok == 0)
	return (FALSE);		/* should probably longjmp here */
      r = evalexp (t, &expok);
      if (expok == 0)
	return (FALSE);		/* ditto */
    }
  else
    {
      if (legal_number (s, &l) == 0)
	integer_expected_error (s);
      if (legal_number (t, &r) == 0)
	integer_expected_error (t);
    }

  switch (op)
    {
    case EQ: return (l == r);
    case NE: return (l != r);
    case LT: return (l < r);
    case GT: return (l > r);
    case LE: return (l <= r);
    case GE: return (l >= r);
    }

  return (FALSE);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\test.c:323
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\test.c:358
parsing error 
{
  int m;

  m = strmatch (pat, string, FNMATCH_EXTFLAG|FNMATCH_IGNCASE);
  return ((op == EQ) ? (m == 0) : (m != 0));
}
warning: parse error {
  int m;

  m = strmatch (pat, string, FNMATCH_EXTFLAG|FNMATCH_IGNCASE);
  return ((op == EQ) ? (m == 0) : (m != 0));
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\test.c:361
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\test.c:369
parsing error 
{
  int patmatch;

  patmatch = (flags & TEST_PATMATCH);

  if (op[0] == '=' && (op[1] == '\0' || (op[1] == '=' && op[2] == '\0')))
    return (patmatch ? patcomp (arg1, arg2, EQ) : STREQ (arg1, arg2));
  else if ((op[0] == '>' || op[0] == '<') && op[1] == '\0')
    {
      if (shell_compatibility_level > 40 && flags & TEST_LOCALE)
	return ((op[0] == '>') ? (strcoll (arg1, arg2) > 0) : (strcoll (arg1, arg2) < 0));
      else
	return ((op[0] == '>') ? (strcmp (arg1, arg2) > 0) : (strcmp (arg1, arg2) < 0));
    }
  else if (op[0] == '!' && op[1] == '=' && op[2] == '\0')
    return (patmatch ? patcomp (arg1, arg2, NE) : (STREQ (arg1, arg2) == 0));
    

  else if (op[2] == 't')
    {
      switch (op[1])
	{
	case 'n': return (filecomp (arg1, arg2, NT));		/* -nt */
	case 'o': return (filecomp (arg1, arg2, OT));		/* -ot */
	case 'l': return (arithcomp (arg1, arg2, LT, flags));	/* -lt */
	case 'g': return (arithcomp (arg1, arg2, GT, flags));	/* -gt */
	}
    }
  else if (op[1] == 'e')
    {
      switch (op[2])
	{
	case 'f': return (filecomp (arg1, arg2, EF));		/* -ef */
	case 'q': return (arithcomp (arg1, arg2, EQ, flags));	/* -eq */
	}
    }
  else if (op[2] == 'e')
    {
      switch (op[1])
	{
	case 'n': return (arithcomp (arg1, arg2, NE, flags));	/* -ne */
	case 'g': return (arithcomp (arg1, arg2, GE, flags));	/* -ge */
	case 'l': return (arithcomp (arg1, arg2, LE, flags));	/* -le */
	}
    }

  return (FALSE);	/* should never get here */
}
warning: parse error {
  int patmatch;

  patmatch = (flags & TEST_PATMATCH);

  if (op[0] == '=' && (op[1] == '\0' || (op[1] == '=' && op[2] == '\0')))
    return (patmatch ? patcomp (arg1, arg2, EQ) : STREQ (arg1, arg2));
  else if ((op[0] == '>' || op[0] == '<') && op[1] == '\0')
    {
      if (shell_compatibility_level > 40 && flags & TEST_LOCALE)
	return ((op[0] == '>') ? (strcoll (arg1, arg2) > 0) : (strcoll (arg1, arg2) < 0));
      else
	return ((op[0] == '>') ? (strcmp (arg1, arg2) > 0) : (strcmp (arg1, arg2) < 0));
    }
  else if (op[0] == '!' && op[1] == '=' && op[2] == '\0')
    return (patmatch ? patcomp (arg1, arg2, NE) : (STREQ (arg1, arg2) == 0));
    

  else if (op[2] == 't')
    {
      switch (op[1])
	{
	case 'n': return (filecomp (arg1, arg2, NT));		/* -nt */
	case 'o': return (filecomp (arg1, arg2, OT));		/* -ot */
	case 'l': return (arithcomp (arg1, arg2, LT, flags));	/* -lt */
	case 'g': return (arithcomp (arg1, arg2, GT, flags));	/* -gt */
	}
    }
  else if (op[1] == 'e')
    {
      switch (op[2])
	{
	case 'f': return (filecomp (arg1, arg2, EF));		/* -ef */
	case 'q': return (arithcomp (arg1, arg2, EQ, flags));	/* -eq */
	}
    }
  else if (op[2] == 'e')
    {
      switch (op[1])
	{
	case 'n': return (arithcomp (arg1, arg2, NE, flags));	/* -ne */
	case 'g': return (arithcomp (arg1, arg2, GE, flags));	/* -ge */
	case 'l': return (arithcomp (arg1, arg2, LE, flags));	/* -le */
	}
    }

  return (FALSE);	/* should never get here */
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\test.c:372
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\test.c:496
parsing error 
{
  intmax_t r;
  struct stat stat_buf;
  SHELL_VAR *v;
     
  switch (op[1])
    {
    case 'a':			/* file exists in the file system? */
    case 'e':
      return (sh_stat (arg, &stat_buf) == 0);

    case 'r':			/* file is readable? */
      return (sh_eaccess (arg, R_OK) == 0);

    case 'w':			/* File is writeable? */
      return (sh_eaccess (arg, W_OK) == 0);

    case 'x':			/* File is executable? */
      return (sh_eaccess (arg, X_OK) == 0);

    case 'O':			/* File is owned by you? */
      return (sh_stat (arg, &stat_buf) == 0 &&
	      (uid_t) current_user.euid == (uid_t) stat_buf.st_uid);

    case 'G':			/* File is owned by your group? */
      return (sh_stat (arg, &stat_buf) == 0 &&
	      (gid_t) current_user.egid == (gid_t) stat_buf.st_gid);

    case 'N':
      return (sh_stat (arg, &stat_buf) == 0 &&
	      stat_buf.st_atime <= stat_buf.st_mtime);

    case 'f':			/* File is a file? */
      if (sh_stat (arg, &stat_buf) < 0)
	return (FALSE);

      /* -f is true if the given file exists and is a regular file. */
#if defined (S_IFMT)
      return (S_ISREG (stat_buf.st_mode) || (stat_buf.st_mode & S_IFMT) == 0);
#else
      return (S_ISREG (stat_buf.st_mode));
#endif /* !S_IFMT */

    case 'd':			/* File is a directory? */
      return (sh_stat (arg, &stat_buf) == 0 && (S_ISDIR (stat_buf.st_mode)));

    case 's':			/* File has something in it? */
      return (sh_stat (arg, &stat_buf) == 0 && stat_buf.st_size > (off_t) 0);

    case 'S':			/* File is a socket? */
#if !defined (S_ISSOCK)
      return (FALSE);
#else
      return (sh_stat (arg, &stat_buf) == 0 && S_ISSOCK (stat_buf.st_mode));
#endif /* S_ISSOCK */

    case 'c':			/* File is character special? */
      return (sh_stat (arg, &stat_buf) == 0 && S_ISCHR (stat_buf.st_mode));

    case 'b':			/* File is block special? */
      return (sh_stat (arg, &stat_buf) == 0 && S_ISBLK (stat_buf.st_mode));

    case 'p':			/* File is a named pipe? */
#ifndef S_ISFIFO
      return (FALSE);
#else
      return (sh_stat (arg, &stat_buf) == 0 && S_ISFIFO (stat_buf.st_mode));
#endif /* S_ISFIFO */

    case 'L':			/* Same as -h  */
    case 'h':			/* File is a symbolic link? */
#if !defined (S_ISLNK) || !defined (HAVE_LSTAT)
      return (FALSE);
#else
      return ((arg[0] != '\0') &&
	      (lstat (arg, &stat_buf) == 0) && S_ISLNK (stat_buf.st_mode));
#endif /* S_IFLNK && HAVE_LSTAT */

    case 'u':			/* File is setuid? */
      return (sh_stat (arg, &stat_buf) == 0 && (stat_buf.st_mode & S_ISUID) != 0);

    case 'g':			/* File is setgid? */
      return (sh_stat (arg, &stat_buf) == 0 && (stat_buf.st_mode & S_ISGID) != 0);

    case 'k':			/* File has sticky bit set? */
#if !defined (S_ISVTX)
      /* This is not Posix, and is not defined on some Posix systems. */
      return (FALSE);
#else
      return (sh_stat (arg, &stat_buf) == 0 && (stat_buf.st_mode & S_ISVTX) != 0);
#endif

    case 't':	/* File fd is a terminal? */
      if (legal_number (arg, &r) == 0)
	return (FALSE);
      return ((r == (int)r) && isatty ((int)r));

    case 'n':			/* True if arg has some length. */
      return (arg[0] != '\0');

    case 'z':			/* True if arg has no length. */
      return (arg[0] == '\0');

    case 'o':			/* True if option `arg' is set. */
      return (minus_o_option_value (arg) == 1);

    case 'v':
      v = find_variable (arg);
      return (v && var_isset (v) ? TRUE : FALSE);
    }

  /* We can't actually get here, but this shuts up gcc. */
  return (FALSE);
}
warning: parse error {
  intmax_t r;
  struct stat stat_buf;
  SHELL_VAR *v;
     
  switch (op[1])
    {
    case 'a':			/* file exists in the file system? */
    case 'e':
      return (sh_stat (arg, &stat_buf) == 0);

    case 'r':			/* file is readable? */
      return (sh_eaccess (arg, R_OK) == 0);

    case 'w':			/* File is writeable? */
      return (sh_eaccess (arg, W_OK) == 0);

    case 'x':			/* File is executable? */
      return (sh_eaccess (arg, X_OK) == 0);

    case 'O':			/* File is owned by you? */
      return (sh_stat (arg, &stat_buf) == 0 &&
	      (uid_t) current_user.euid == (uid_t) stat_buf.st_uid);

    case 'G':			/* File is owned by your group? */
      return (sh_stat (arg, &stat_buf) == 0 &&
	      (gid_t) current_user.egid == (gid_t) stat_buf.st_gid);

    case 'N':
      return (sh_stat (arg, &stat_buf) == 0 &&
	      stat_buf.st_atime <= stat_buf.st_mtime);

    case 'f':			/* File is a file? */
      if (sh_stat (arg, &stat_buf) < 0)
	return (FALSE);

      /* -f is true if the given file exists and is a regular file. */
#if defined (S_IFMT)
      return (S_ISREG (stat_buf.st_mode) || (stat_buf.st_mode & S_IFMT) == 0);
#else
      return (S_ISREG (stat_buf.st_mode));
#endif /* !S_IFMT */

    case 'd':			/* File is a directory? */
      return (sh_stat (arg, &stat_buf) == 0 && (S_ISDIR (stat_buf.st_mode)));

    case 's':			/* File has something in it? */
      return (sh_stat (arg, &stat_buf) == 0 && stat_buf.st_size > (off_t) 0);

    case 'S':			/* File is a socket? */
#if !defined (S_ISSOCK)
      return (FALSE);
#else
      return (sh_stat (arg, &stat_buf) == 0 && S_ISSOCK (stat_buf.st_mode));
#endif /* S_ISSOCK */

    case 'c':			/* File is character special? */
      return (sh_stat (arg, &stat_buf) == 0 && S_ISCHR (stat_buf.st_mode));

    case 'b':			/* File is block special? */
      return (sh_stat (arg, &stat_buf) == 0 && S_ISBLK (stat_buf.st_mode));

    case 'p':			/* File is a named pipe? */
#ifndef S_ISFIFO
      return (FALSE);
#else
      return (sh_stat (arg, &stat_buf) == 0 && S_ISFIFO (stat_buf.st_mode));
#endif /* S_ISFIFO */

    case 'L':			/* Same as -h  */
    case 'h':			/* File is a symbolic link? */
#if !defined (S_ISLNK) || !defined (HAVE_LSTAT)
      return (FALSE);
#else
      return ((arg[0] != '\0') &&
	      (lstat (arg, &stat_buf) == 0) && S_ISLNK (stat_buf.st_mode));
#endif /* S_IFLNK && HAVE_LSTAT */

    case 'u':			/* File is setuid? */
      return (sh_stat (arg, &stat_buf) == 0 && (stat_buf.st_mode & S_ISUID) != 0);

    case 'g':			/* File is setgid? */
      return (sh_stat (arg, &stat_buf) == 0 && (stat_buf.st_mode & S_ISGID) != 0);

    case 'k':			/* File has sticky bit set? */
#if !defined (S_ISVTX)
      /* This is not Posix, and is not defined on some Posix systems. */
      return (FALSE);
#else
      return (sh_stat (arg, &stat_buf) == 0 && (stat_buf.st_mode & S_ISVTX) != 0);
#endif

    case 't':	/* File fd is a terminal? */
      if (legal_number (arg, &r) == 0)
	return (FALSE);
      return ((r == (int)r) && isatty ((int)r));

    case 'n':			/* True if arg has some length. */
      return (arg[0] != '\0');

    case 'z':			/* True if arg has no length. */
      return (arg[0] == '\0');

    case 'o':			/* True if option `arg' is set. */
      return (minus_o_option_value (arg) == 1);

    case 'v':
      v = find_variable (arg);
      return (v && var_isset (v) ? TRUE : FALSE);
    }

  /* We can't actually get here, but this shuts up gcc. */
  return (FALSE);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\test.c:498
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\test.c:615
parsing error 
{
  if (op[0] == '=' && op[1] == '\0')
    return (1);		/* '=' */
  else if ((op[0] == '<' || op[0] == '>') && op[1] == '\0')  /* string <, > */
    return (1);
  else if ((op[0] == '=' || op[0] == '!') && op[1] == '=' && op[2] == '\0')
    return (1);		/* `==' and `!=' */
#if defined (PATTERN_MATCHING)
  else if (op[2] == '\0' && op[1] == '~' && (op[0] == '=' || op[0] == '!'))
    return (1);
#endif
  else if (op[0] != '-' || op[2] == '\0' || op[3] != '\0')
    return (0);
  else
    {
      if (op[2] == 't')
	switch (op[1])
	  {
	  case 'n':		/* -nt */
	  case 'o':		/* -ot */
	  case 'l':		/* -lt */
	  case 'g':		/* -gt */
	    return (1);
	  default:
	    return (0);
	  }
      else if (op[1] == 'e')
	switch (op[2])
	  {
	  case 'q':		/* -eq */
	  case 'f':		/* -ef */
	    return (1);
	  default:
	    return (0);
	  }
      else if (op[2] == 'e')
	switch (op[1])
	  {
	  case 'n':		/* -ne */
	  case 'g':		/* -ge */
	  case 'l':		/* -le */
	    return (1);
	  default:
	    return (0);
	  }
      else
	return (0);
    }
}
warning: parse error {
  if (op[0] == '=' && op[1] == '\0')
    return (1);		/* '=' */
  else if ((op[0] == '<' || op[0] == '>') && op[1] == '\0')  /* string <, > */
    return (1);
  else if ((op[0] == '=' || op[0] == '!') && op[1] == '=' && op[2] == '\0')
    return (1);		/* `==' and `!=' */
#if defined (PATTERN_MATCHING)
  else if (op[2] == '\0' && op[1] == '~' && (op[0] == '=' || op[0] == '!'))
    return (1);
#endif
  else if (op[0] != '-' || op[2] == '\0' || op[3] != '\0')
    return (0);
  else
    {
      if (op[2] == 't')
	switch (op[1])
	  {
	  case 'n':		/* -nt */
	  case 'o':		/* -ot */
	  case 'l':		/* -lt */
	  case 'g':		/* -gt */
	    return (1);
	  default:
	    return (0);
	  }
      else if (op[1] == 'e')
	switch (op[2])
	  {
	  case 'q':		/* -eq */
	  case 'f':		/* -ef */
	    return (1);
	  default:
	    return (0);
	  }
      else if (op[2] == 'e')
	switch (op[1])
	  {
	  case 'n':		/* -ne */
	  case 'g':		/* -ge */
	  case 'l':		/* -le */
	    return (1);
	  default:
	    return (0);
	  }
      else
	return (0);
    }
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\test.c:617
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\test.c:669
parsing error 
{
  if (op[0] != '-' || op[2] != 0)
    return (0);

  switch (op[1])
    {
    case 'a': case 'b': case 'c': case 'd': case 'e':
    case 'f': case 'g': case 'h': case 'k': case 'n':
    case 'o': case 'p': case 'r': case 's': case 't':
    case 'u': case 'v': case 'w': case 'x': case 'z':
    case 'G': case 'L': case 'O': case 'S': case 'N':
      return (1);
    }

  return (0);
}
warning: parse error {
  if (op[0] != '-' || op[2] != 0)
    return (0);

  switch (op[1])
    {
    case 'a': case 'b': case 'c': case 'd': case 'e':
    case 'f': case 'g': case 'h': case 'k': case 'n':
    case 'o': case 'p': case 'r': case 's': case 't':
    case 'u': case 'v': case 'w': case 'x': case 'z':
    case 'G': case 'L': case 'O': case 'S': case 'N':
      return (1);
    }

  return (0);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\test.c:671
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\test.c:795
parsing error 
{
  int value;
  int code;

  USE_VAR(margc);

  code = setjmp (test_exit_buf);

  if (code)
    return (test_error_return);

  argv = margv;

  if (margv[0] && margv[0][0] == '[' && margv[0][1] == '\0')
    {
      --margc;

      if (margv[margc] && (margv[margc][0] != ']' || margv[margc][1]))
	test_syntax_error (_("missing `]'"), (char *)NULL);

      if (margc < 2)
	test_exit (SHELL_BOOLEAN (FALSE));
    }

  argc = margc;
  pos = 1;

  if (pos >= argc)
    test_exit (SHELL_BOOLEAN (FALSE));

  noeval = 0;
  value = posixtest ();

  if (pos != argc)
    test_syntax_error (_("too many arguments"), (char *)NULL);

  test_exit (SHELL_BOOLEAN (value));
}
warning: parse error {
  int value;
  int code;

  USE_VAR(margc);

  code = setjmp (test_exit_buf);

  if (code)
    return (test_error_return);

  argv = margv;

  if (margv[0] && margv[0][0] == '[' && margv[0][1] == '\0')
    {
      --margc;

      if (margv[margc] && (margv[margc][0] != ']' || margv[margc][1]))
	test_syntax_error (_("missing `]'"), (char *)NULL);

      if (margc < 2)
	test_exit (SHELL_BOOLEAN (FALSE));
    }

  argc = margc;
  pos = 1;

  if (pos >= argc)
    test_exit (SHELL_BOOLEAN (FALSE));

  noeval = 0;
  value = posixtest ();

  if (pos != argc)
    test_syntax_error (_("too many arguments"), (char *)NULL);

  test_exit (SHELL_BOOLEAN (value));
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\test.c:798
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\trap.c...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\bashtypes.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\bashansi.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\bashintl.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\trap.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\shell.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\flags.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\input.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\jobs.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\common.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\trap.c:200
parsing error 
{
  char *ret;

  /* on cygwin32, signal_names[sig] could be null */
  ret = (sig >= BASH_NSIG || sig < 0 || signal_names[sig] == NULL)
	? _("invalid signal number")
	: signal_names[sig];

  return ret;
}
warning: parse error {
  char *ret;

  /* on cygwin32, signal_names[sig] could be null */
  ret = (sig >= BASH_NSIG || sig < 0 || signal_names[sig] == NULL)
	? _("invalid signal number")
	: signal_names[sig];

  return ret;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\trap.c:202
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\trap.c:218
parsing error 
{
  intmax_t sig;
  char *name;

  if (legal_number (string, &sig))
    return ((sig >= 0 && sig < NSIG) ? (int)sig : NO_SIG);

  /* A leading `SIG' may be omitted. */
  for (sig = 0; sig < BASH_NSIG; sig++)
    {
      name = signal_names[sig];
      if (name == 0 || name[0] == '\0')
	continue;

      /* Check name without the SIG prefix first case sensitivly or
	 insensitively depending on whether flags includes DSIG_NOCASE */
      if (STREQN (name, "SIG", 3))
	{
	  name += 3;

	  if ((flags & DSIG_NOCASE) && strcasecmp (string, name) == 0)
	    return ((int)sig);
	  else if ((flags & DSIG_NOCASE) == 0 && strcmp (string, name) == 0)
	    return ((int)sig);
	  /* If we can't use the `SIG' prefix to match, punt on this
	     name now. */
	  else if ((flags & DSIG_SIGPREFIX) == 0)
	    continue;
	}

      /* Check name with SIG prefix case sensitively or insensitively
	 depending on whether flags includes DSIG_NOCASE */
      name = signal_names[sig];
      if ((flags & DSIG_NOCASE) && strcasecmp (string, name) == 0)
	return ((int)sig);
      else if ((flags & DSIG_NOCASE) == 0 && strcmp (string, name) == 0)
	return ((int)sig);
    }

  return (NO_SIG);
}
warning: parse error {
  intmax_t sig;
  char *name;

  if (legal_number (string, &sig))
    return ((sig >= 0 && sig < NSIG) ? (int)sig : NO_SIG);

  /* A leading `SIG' may be omitted. */
  for (sig = 0; sig < BASH_NSIG; sig++)
    {
      name = signal_names[sig];
      if (name == 0 || name[0] == '\0')
	continue;

      /* Check name without the SIG prefix first case sensitivly or
	 insensitively depending on whether flags includes DSIG_NOCASE */
      if (STREQN (name, "SIG", 3))
	{
	  name += 3;

	  if ((flags & DSIG_NOCASE) && strcasecmp (string, name) == 0)
	    return ((int)sig);
	  else if ((flags & DSIG_NOCASE) == 0 && strcmp (string, name) == 0)
	    return ((int)sig);
	  /* If we can't use the `SIG' prefix to match, punt on this
	     name now. */
	  else if ((flags & DSIG_SIGPREFIX) == 0)
	    continue;
	}

      /* Check name with SIG prefix case sensitively or insensitively
	 depending on whether flags includes DSIG_NOCASE */
      name = signal_names[sig];
      if ((flags & DSIG_NOCASE) && strcasecmp (string, name) == 0)
	return ((int)sig);
      else if ((flags & DSIG_NOCASE) == 0 && strcmp (string, name) == 0)
	return ((int)sig);
    }

  return (NO_SIG);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\trap.c:221
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\trap.c:377
parsing error 
{
  int oerrno;

  if ((sigmodes[sig] & SIG_TRAPPED) == 0)
    {
#if defined (DEBUG)
      internal_warning ("trap_handler: signal %d: signal not trapped", sig);
#endif
      SIGRETURN (0);
    }

  if ((sig >= NSIG) ||
      (trap_list[sig] == (char *)DEFAULT_SIG) ||
      (trap_list[sig] == (char *)IGNORE_SIG))
    programming_error (_("trap_handler: bad signal %d"), sig);
  else
    {
      oerrno = errno;
#if defined (MUST_REINSTALL_SIGHANDLERS)
#  if defined (JOB_CONTROL) && defined (SIGCHLD)
      if (sig != SIGCHLD)
#  endif /* JOB_CONTROL && SIGCHLD */
      set_signal_handler (sig, trap_handler);
#endif /* MUST_REINSTALL_SIGHANDLERS */

      catch_flag = 1;
      pending_traps[sig]++;

      if (interrupt_immediately && this_shell_builtin && (this_shell_builtin == wait_builtin))
	{
	  wait_signal_received = sig;
	  longjmp (wait_intr_buf, 1);
	}

      if (interrupt_immediately)
	run_pending_traps ();

      errno = oerrno;
    }

  SIGRETURN (0);
}
warning: parse error {
  int oerrno;

  if ((sigmodes[sig] & SIG_TRAPPED) == 0)
    {
#if defined (DEBUG)
      internal_warning ("trap_handler: signal %d: signal not trapped", sig);
#endif
      SIGRETURN (0);
    }

  if ((sig >= NSIG) ||
      (trap_list[sig] == (char *)DEFAULT_SIG) ||
      (trap_list[sig] == (char *)IGNORE_SIG))
    programming_error (_("trap_handler: bad signal %d"), sig);
  else
    {
      oerrno = errno;
#if defined (MUST_REINSTALL_SIGHANDLERS)
#  if defined (JOB_CONTROL) && defined (SIGCHLD)
      if (sig != SIGCHLD)
#  endif /* JOB_CONTROL && SIGCHLD */
      set_signal_handler (sig, trap_handler);
#endif /* MUST_REINSTALL_SIGHANDLERS */

      catch_flag = 1;
      pending_traps[sig]++;

      if (interrupt_immediately && this_shell_builtin && (this_shell_builtin == wait_builtin))
	{
	  wait_signal_received = sig;
	  longjmp (wait_intr_buf, 1);
	}

      if (interrupt_immediately)
	run_pending_traps ();

      errno = oerrno;
    }

  SIGRETURN (0);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\trap.c:379
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\trap.c:460
parsing error 
{
  set_signal (DEBUG_TRAP, command);
}
warning: parse error {
  set_signal (DEBUG_TRAP, command);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\trap.c:462
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\trap.c:467
parsing error 
{
  set_signal (ERROR_TRAP, command);
}
warning: parse error {
  set_signal (ERROR_TRAP, command);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\trap.c:469
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\trap.c:474
parsing error 
{
  set_signal (RETURN_TRAP, command);
}
warning: parse error {
  set_signal (RETURN_TRAP, command);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\trap.c:476
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\trap.c:515
parsing error 
{
  if (sigmodes[sig] & (SIG_IGNORED|SIG_HARD_IGNORE))
    return (SIG_IGN);
  else if (sigmodes[sig] & SIG_TRAPPED)
    return (trap_handler);
  else
    return (SIG_DFL);
}
warning: parse error {
  if (sigmodes[sig] & (SIG_IGNORED|SIG_HARD_IGNORE))
    return (SIG_IGN);
  else if (sigmodes[sig] & SIG_TRAPPED)
    return (trap_handler);
  else
    return (SIG_DFL);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\trap.c:517
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\trap.c:528
parsing error 
{
  if (SPECIAL_TRAP (sig))
    {
      change_signal (sig, savestring (string));
      if (sig == EXIT_TRAP && interactive == 0)
	initialize_terminating_signals ();
      return;
    }

  /* A signal ignored on entry to the shell cannot be trapped or reset, but
     no error is reported when attempting to do so.  -- Posix.2 */
  if (sigmodes[sig] & SIG_HARD_IGNORE)
    return;

  /* Make sure we have original_signals[sig] if the signal has not yet
     been trapped. */
  if ((sigmodes[sig] & SIG_TRAPPED) == 0)
    {
      /* If we aren't sure of the original value, check it. */
      if (original_signals[sig] == IMPOSSIBLE_TRAP_HANDLER)
        GETORIGSIG (sig);
      if (original_signals[sig] == SIG_IGN)
	return;
    }

  /* Only change the system signal handler if SIG_NO_TRAP is not set.
     The trap command string is changed in either case.  The shell signal
     handlers for SIGINT and SIGCHLD run the user specified traps in an
     environment in which it is safe to do so. */
  if ((sigmodes[sig] & SIG_NO_TRAP) == 0)
    {
      set_signal_handler (sig, SIG_IGN);
      change_signal (sig, savestring (string));
      set_signal_handler (sig, trap_handler);
    }
  else
    change_signal (sig, savestring (string));
}
warning: parse error {
  if (SPECIAL_TRAP (sig))
    {
      change_signal (sig, savestring (string));
      if (sig == EXIT_TRAP && interactive == 0)
	initialize_terminating_signals ();
      return;
    }

  /* A signal ignored on entry to the shell cannot be trapped or reset, but
     no error is reported when attempting to do so.  -- Posix.2 */
  if (sigmodes[sig] & SIG_HARD_IGNORE)
    return;

  /* Make sure we have original_signals[sig] if the signal has not yet
     been trapped. */
  if ((sigmodes[sig] & SIG_TRAPPED) == 0)
    {
      /* If we aren't sure of the original value, check it. */
      if (original_signals[sig] == IMPOSSIBLE_TRAP_HANDLER)
        GETORIGSIG (sig);
      if (original_signals[sig] == SIG_IGN)
	return;
    }

  /* Only change the system signal handler if SIG_NO_TRAP is not set.
     The trap command string is changed in either case.  The shell signal
     handlers for SIGINT and SIGCHLD run the user specified traps in an
     environment in which it is safe to do so. */
  if ((sigmodes[sig] & SIG_NO_TRAP) == 0)
    {
      set_signal_handler (sig, SIG_IGN);
      change_signal (sig, savestring (string));
      set_signal_handler (sig, trap_handler);
    }
  else
    change_signal (sig, savestring (string));
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\trap.c:531
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\trap.c:571
parsing error 
{
  if ((sigmodes[sig] & SIG_TRAPPED) && trap_list[sig] &&
      (trap_list[sig] != (char *)IGNORE_SIG) &&
      (trap_list[sig] != (char *)DEFAULT_SIG) &&
      (trap_list[sig] != (char *)IMPOSSIBLE_TRAP_HANDLER))
    free (trap_list[sig]);
}
warning: parse error {
  if ((sigmodes[sig] & SIG_TRAPPED) && trap_list[sig] &&
      (trap_list[sig] != (char *)IGNORE_SIG) &&
      (trap_list[sig] != (char *)DEFAULT_SIG) &&
      (trap_list[sig] != (char *)IMPOSSIBLE_TRAP_HANDLER))
    free (trap_list[sig]);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\trap.c:573
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\trap.c:584
parsing error 
{
  if ((sigmodes[sig] & SIG_INPROGRESS) == 0)
    free_trap_command (sig);
  trap_list[sig] = value;

  sigmodes[sig] |= SIG_TRAPPED;
  if (value == (char *)IGNORE_SIG)
    sigmodes[sig] |= SIG_IGNORED;
  else
    sigmodes[sig] &= ~SIG_IGNORED;
  if (sigmodes[sig] & SIG_INPROGRESS)
    sigmodes[sig] |= SIG_CHANGED;
}
warning: parse error {
  if ((sigmodes[sig] & SIG_INPROGRESS) == 0)
    free_trap_command (sig);
  trap_list[sig] = value;

  sigmodes[sig] |= SIG_TRAPPED;
  if (value == (char *)IGNORE_SIG)
    sigmodes[sig] |= SIG_IGNORED;
  else
    sigmodes[sig] &= ~SIG_IGNORED;
  if (sigmodes[sig] & SIG_INPROGRESS)
    sigmodes[sig] |= SIG_CHANGED;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\trap.c:587
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\trap.c:602
parsing error 
{
  /* If we aren't sure the of the original value, then get it. */
  if (sig > 0 && sig < NSIG && original_signals[sig] == (SigHandler *)IMPOSSIBLE_TRAP_HANDLER)
    GETORIGSIG (sig);
}
warning: parse error {
  /* If we aren't sure the of the original value, then get it. */
  if (sig > 0 && sig < NSIG && original_signals[sig] == (SigHandler *)IMPOSSIBLE_TRAP_HANDLER)
    GETORIGSIG (sig);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\trap.c:604
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\trap.c:620
parsing error 
{
  if (sig > 0 && sig < NSIG && original_signals[sig] == (SigHandler *)IMPOSSIBLE_TRAP_HANDLER)
    SETORIGSIG (sig, handler);
}
warning: parse error {
  if (sig > 0 && sig < NSIG && original_signals[sig] == (SigHandler *)IMPOSSIBLE_TRAP_HANDLER)
    SETORIGSIG (sig, handler);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\trap.c:623
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\trap.c:633
parsing error 
{
  if (SPECIAL_TRAP (sig))
    {
      if ((sig != DEBUG_TRAP && sig != ERROR_TRAP && sig != RETURN_TRAP) ||
	  (sigmodes[sig] & SIG_INPROGRESS) == 0)
	free_trap_command (sig);
      trap_list[sig] = (char *)NULL;
      sigmodes[sig] &= ~SIG_TRAPPED;
      if (sigmodes[sig] & SIG_INPROGRESS)
	sigmodes[sig] |= SIG_CHANGED;
      return;
    }

  GET_ORIGINAL_SIGNAL (sig);

  /* A signal ignored on entry to the shell cannot be trapped or reset, but
     no error is reported when attempting to do so.  Thanks Posix.2. */
  if (sigmodes[sig] & SIG_HARD_IGNORE)
    return;

  /* If we aren't trapping this signal, don't bother doing anything else. */
  if ((sigmodes[sig] & SIG_TRAPPED) == 0)
    return;

  /* Only change the signal handler for SIG if it allows it. */
  if ((sigmodes[sig] & SIG_NO_TRAP) == 0)
    set_signal_handler (sig, original_signals[sig]);

  /* Change the trap command in either case. */
  change_signal (sig, (char *)DEFAULT_SIG);

  /* Mark the signal as no longer trapped. */
  sigmodes[sig] &= ~SIG_TRAPPED;
}
warning: parse error {
  if (SPECIAL_TRAP (sig))
    {
      if ((sig != DEBUG_TRAP && sig != ERROR_TRAP && sig != RETURN_TRAP) ||
	  (sigmodes[sig] & SIG_INPROGRESS) == 0)
	free_trap_command (sig);
      trap_list[sig] = (char *)NULL;
      sigmodes[sig] &= ~SIG_TRAPPED;
      if (sigmodes[sig] & SIG_INPROGRESS)
	sigmodes[sig] |= SIG_CHANGED;
      return;
    }

  GET_ORIGINAL_SIGNAL (sig);

  /* A signal ignored on entry to the shell cannot be trapped or reset, but
     no error is reported when attempting to do so.  Thanks Posix.2. */
  if (sigmodes[sig] & SIG_HARD_IGNORE)
    return;

  /* If we aren't trapping this signal, don't bother doing anything else. */
  if ((sigmodes[sig] & SIG_TRAPPED) == 0)
    return;

  /* Only change the signal handler for SIG if it allows it. */
  if ((sigmodes[sig] & SIG_NO_TRAP) == 0)
    set_signal_handler (sig, original_signals[sig]);

  /* Change the trap command in either case. */
  change_signal (sig, (char *)DEFAULT_SIG);

  /* Mark the signal as no longer trapped. */
  sigmodes[sig] &= ~SIG_TRAPPED;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\trap.c:635
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\trap.c:672
parsing error 
{
  if (SPECIAL_TRAP (sig) && ((sigmodes[sig] & SIG_IGNORED) == 0))
    {
      change_signal (sig, (char *)IGNORE_SIG);
      return;
    }

  GET_ORIGINAL_SIGNAL (sig);

  /* A signal ignored on entry to the shell cannot be trapped or reset.
     No error is reported when the user attempts to do so. */
  if (sigmodes[sig] & SIG_HARD_IGNORE)
    return;

  /* If already trapped and ignored, no change necessary. */
  if (sigmodes[sig] & SIG_IGNORED)
    return;

  /* Only change the signal handler for SIG if it allows it. */
  if ((sigmodes[sig] & SIG_NO_TRAP) == 0)
    set_signal_handler (sig, SIG_IGN);

  /* Change the trap command in either case. */
  change_signal (sig, (char *)IGNORE_SIG);
}
warning: parse error {
  if (SPECIAL_TRAP (sig) && ((sigmodes[sig] & SIG_IGNORED) == 0))
    {
      change_signal (sig, (char *)IGNORE_SIG);
      return;
    }

  GET_ORIGINAL_SIGNAL (sig);

  /* A signal ignored on entry to the shell cannot be trapped or reset.
     No error is reported when the user attempts to do so. */
  if (sigmodes[sig] & SIG_HARD_IGNORE)
    return;

  /* If already trapped and ignored, no change necessary. */
  if (sigmodes[sig] & SIG_IGNORED)
    return;

  /* Only change the signal handler for SIG if it allows it. */
  if ((sigmodes[sig] & SIG_NO_TRAP) == 0)
    set_signal_handler (sig, SIG_IGN);

  /* Change the trap command in either case. */
  change_signal (sig, (char *)IGNORE_SIG);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\trap.c:674
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\trap.c:762
parsing error 
{
  sigmodes[sig] &= ~(SIG_INPROGRESS|SIG_CHANGED);
}
warning: parse error {
  sigmodes[sig] &= ~(SIG_INPROGRESS|SIG_CHANGED);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\trap.c:764
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\trap.c:771
parsing error 
{
  char *trap_command, *old_trap;
  int trap_exit_value, *token_state;
  int save_return_catch_flag, function_code, flags;
  procenv_t save_return_catch;
  WORD_LIST *save_subst_varlist;
#if defined (ARRAY_VARS)
  ARRAY *ps;
#endif

  trap_exit_value = function_code = 0;
  /* Run the trap only if SIG is trapped and not ignored, and we are not
     currently executing in the trap handler. */
  if ((sigmodes[sig] & SIG_TRAPPED) && ((sigmodes[sig] & SIG_IGNORED) == 0) &&
      (trap_list[sig] != (char *)IMPOSSIBLE_TRAP_HANDLER) &&
      ((sigmodes[sig] & SIG_INPROGRESS) == 0))
    {
      old_trap = trap_list[sig];
      sigmodes[sig] |= SIG_INPROGRESS;
      sigmodes[sig] &= ~SIG_CHANGED;		/* just to be sure */
      trap_command =  savestring (old_trap);

      running_trap = sig + 1;
      trap_saved_exit_value = last_command_exit_value;
#if defined (ARRAY_VARS)
      ps = save_pipestatus_array ();
#endif

      token_state = save_token_state ();
      save_subst_varlist = subst_assign_varlist;
      subst_assign_varlist = 0;

      /* If we're in a function, make sure return longjmps come here, too. */
      save_return_catch_flag = return_catch_flag;
      if (return_catch_flag)
	{
	  COPY_PROCENV (return_catch, save_return_catch);
	  function_code = setjmp (return_catch);
	}

      flags = SEVAL_NONINT|SEVAL_NOHIST;
      if (sig != DEBUG_TRAP && sig != RETURN_TRAP && sig != ERROR_TRAP)
	flags |= SEVAL_RESETLINE;
      if (function_code == 0)
	parse_and_execute (trap_command, tag, flags);

      restore_token_state (token_state);
      free (token_state);

      subst_assign_varlist = save_subst_varlist;

      trap_exit_value = last_command_exit_value;
      last_command_exit_value = trap_saved_exit_value;
#if defined (ARRAY_VARS)
      restore_pipestatus_array (ps);
#endif
      running_trap = 0;

      sigmodes[sig] &= ~SIG_INPROGRESS;

      if (sigmodes[sig] & SIG_CHANGED)
	{
#if 0
	  /* Special traps like EXIT, DEBUG, RETURN are handled explicitly in
	     the places where they can be changed using unwind-protects.  For
	     example, look at execute_cmd.c:execute_function(). */
	  if (SPECIAL_TRAP (sig) == 0)
#endif
	    free (old_trap);
	  sigmodes[sig] &= ~SIG_CHANGED;
	}

      if (save_return_catch_flag)
	{
	  return_catch_flag = save_return_catch_flag;
	  return_catch_value = trap_exit_value;
	  COPY_PROCENV (save_return_catch, return_catch);
	  if (function_code)
	    longjmp (return_catch, 1);
	}
    }

  return trap_exit_value;
}
warning: parse error {
  char *trap_command, *old_trap;
  int trap_exit_value, *token_state;
  int save_return_catch_flag, function_code, flags;
  procenv_t save_return_catch;
  WORD_LIST *save_subst_varlist;
#if defined (ARRAY_VARS)
  ARRAY *ps;
#endif

  trap_exit_value = function_code = 0;
  /* Run the trap only if SIG is trapped and not ignored, and we are not
     currently executing in the trap handler. */
  if ((sigmodes[sig] & SIG_TRAPPED) && ((sigmodes[sig] & SIG_IGNORED) == 0) &&
      (trap_list[sig] != (char *)IMPOSSIBLE_TRAP_HANDLER) &&
      ((sigmodes[sig] & SIG_INPROGRESS) == 0))
    {
      old_trap = trap_list[sig];
      sigmodes[sig] |= SIG_INPROGRESS;
      sigmodes[sig] &= ~SIG_CHANGED;		/* just to be sure */
      trap_command =  savestring (old_trap);

      running_trap = sig + 1;
      trap_saved_exit_value = last_command_exit_value;
#if defined (ARRAY_VARS)
      ps = save_pipestatus_array ();
#endif

      token_state = save_token_state ();
      save_subst_varlist = subst_assign_varlist;
      subst_assign_varlist = 0;

      /* If we're in a function, make sure return longjmps come here, too. */
      save_return_catch_flag = return_catch_flag;
      if (return_catch_flag)
	{
	  COPY_PROCENV (return_catch, save_return_catch);
	  function_code = setjmp (return_catch);
	}

      flags = SEVAL_NONINT|SEVAL_NOHIST;
      if (sig != DEBUG_TRAP && sig != RETURN_TRAP && sig != ERROR_TRAP)
	flags |= SEVAL_RESETLINE;
      if (function_code == 0)
	parse_and_execute (trap_command, tag, flags);

      restore_token_state (token_state);
      free (token_state);

      subst_assign_varlist = save_subst_varlist;

      trap_exit_value = last_command_exit_value;
      last_command_exit_value = trap_saved_exit_value;
#if defined (ARRAY_VARS)
      restore_pipestatus_array (ps);
#endif
      running_trap = 0;

      sigmodes[sig] &= ~SIG_INPROGRESS;

      if (sigmodes[sig] & SIG_CHANGED)
	{
#if 0
	  /* Special traps like EXIT, DEBUG, RETURN are handled explicitly in
	     the places where they can be changed using unwind-protects.  For
	     example, look at execute_cmd.c:execute_function(). */
	  if (SPECIAL_TRAP (sig) == 0)
#endif
	    free (old_trap);
	  sigmodes[sig] &= ~SIG_CHANGED;
	}

      if (save_return_catch_flag)
	{
	  return_catch_flag = save_return_catch_flag;
	  return_catch_value = trap_exit_value;
	  COPY_PROCENV (save_return_catch, return_catch);
	  if (function_code)
	    longjmp (return_catch, 1);
	}
    }

  return trap_exit_value;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\trap.c:774
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\trap.c:957
parsing error 
{
  change_signal (sig, (char *)DEFAULT_SIG);
  sigmodes[sig] &= ~SIG_TRAPPED;
}
warning: parse error {
  change_signal (sig, (char *)DEFAULT_SIG);
  sigmodes[sig] &= ~SIG_TRAPPED;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\trap.c:959
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\trap.c:967
parsing error 
{
  set_signal_handler (sig, original_signals[sig]);
  sigmodes[sig] &= ~SIG_TRAPPED;
}
warning: parse error {
  set_signal_handler (sig, original_signals[sig]);
  sigmodes[sig] &= ~SIG_TRAPPED;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\trap.c:969
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\trap.c:977
parsing error 
{
  set_signal_handler (sig, original_signals[sig]);
  change_signal (sig, (char *)DEFAULT_SIG);
  sigmodes[sig] &= ~SIG_TRAPPED;
}
warning: parse error {
  set_signal_handler (sig, original_signals[sig]);
  change_signal (sig, (char *)DEFAULT_SIG);
  sigmodes[sig] &= ~SIG_TRAPPED;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\trap.c:979
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\trap.c:986
parsing error 
{
  register int i;

  /* Take care of the exit trap first */
  if (sigmodes[EXIT_TRAP] & SIG_TRAPPED)
    {
      sigmodes[EXIT_TRAP] &= ~SIG_TRAPPED;
      if (reset != reset_signal)
	{
	  free_trap_command (EXIT_TRAP);
	  trap_list[EXIT_TRAP] = (char *)NULL;
	}
    }

  for (i = 1; i < NSIG; i++)
    {
      if (sigmodes[i] & SIG_TRAPPED)
	{
	  if (trap_list[i] == (char *)IGNORE_SIG)
	    set_signal_handler (i, SIG_IGN);
	  else
	    (*reset) (i);
	}
      else if (sigmodes[i] & SIG_SPECIAL)
	(*reset) (i);
    }

  /* Command substitution and other child processes don't inherit the
     debug, error, or return traps.  If we're in the debugger, and the
     `functrace' or `errtrace' options have been set, then let command
     substitutions inherit them.  Let command substitution inherit the
     RETURN trap if we're in the debugger and tracing functions. */
  if (function_trace_mode == 0)
    {
      sigmodes[DEBUG_TRAP] &= ~SIG_TRAPPED;
      sigmodes[RETURN_TRAP] &= ~SIG_TRAPPED;
    }
  if (error_trace_mode == 0)
    sigmodes[ERROR_TRAP] &= ~SIG_TRAPPED;
}
warning: parse error {
  register int i;

  /* Take care of the exit trap first */
  if (sigmodes[EXIT_TRAP] & SIG_TRAPPED)
    {
      sigmodes[EXIT_TRAP] &= ~SIG_TRAPPED;
      if (reset != reset_signal)
	{
	  free_trap_command (EXIT_TRAP);
	  trap_list[EXIT_TRAP] = (char *)NULL;
	}
    }

  for (i = 1; i < NSIG; i++)
    {
      if (sigmodes[i] & SIG_TRAPPED)
	{
	  if (trap_list[i] == (char *)IGNORE_SIG)
	    set_signal_handler (i, SIG_IGN);
	  else
	    (*reset) (i);
	}
      else if (sigmodes[i] & SIG_SPECIAL)
	(*reset) (i);
    }

  /* Command substitution and other child processes don't inherit the
     debug, error, or return traps.  If we're in the debugger, and the
     `functrace' or `errtrace' options have been set, then let command
     substitutions inherit them.  Let command substitution inherit the
     RETURN trap if we're in the debugger and tracing functions. */
  if (function_trace_mode == 0)
    {
      sigmodes[DEBUG_TRAP] &= ~SIG_TRAPPED;
      sigmodes[RETURN_TRAP] &= ~SIG_TRAPPED;
    }
  if (error_trace_mode == 0)
    sigmodes[ERROR_TRAP] &= ~SIG_TRAPPED;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\trap.c:988
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\trap.c:1,050
parsing error 
{
  /* Call the trap handler for SIG if the signal is trapped and not ignored. */
  if ((sigmodes[sig] & SIG_TRAPPED) && ((sigmodes[sig] & SIG_IGNORED) == 0))
    {
      switch (sig)
	{
	case SIGINT:
	  run_interrupt_trap ();
	  break;
	case EXIT_TRAP:
	  run_exit_trap ();
	  break;
	case DEBUG_TRAP:
	  run_debug_trap ();
	  break;
	case ERROR_TRAP:
	  run_error_trap ();
	  break;
	default:
	  trap_handler (sig);
	  break;
	}
      return (1);
    }
  else
    return (0);
}
warning: parse error {
  /* Call the trap handler for SIG if the signal is trapped and not ignored. */
  if ((sigmodes[sig] & SIG_TRAPPED) && ((sigmodes[sig] & SIG_IGNORED) == 0))
    {
      switch (sig)
	{
	case SIGINT:
	  run_interrupt_trap ();
	  break;
	case EXIT_TRAP:
	  run_exit_trap ();
	  break;
	case DEBUG_TRAP:
	  run_debug_trap ();
	  break;
	case ERROR_TRAP:
	  run_error_trap ();
	  break;
	default:
	  trap_handler (sig);
	  break;
	}
      return (1);
    }
  else
    return (0);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\trap.c:1,052
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\trap.c:1,081
parsing error 
{
  return (sigmodes[sig] & SIG_TRAPPED);
}
warning: parse error {
  return (sigmodes[sig] & SIG_TRAPPED);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\trap.c:1,083
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\trap.c:1,088
parsing error 
{
  return (sigmodes[sig] & SIG_SPECIAL);
}
warning: parse error {
  return (sigmodes[sig] & SIG_SPECIAL);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\trap.c:1,090
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\trap.c:1,095
parsing error 
{
  return (sigmodes[sig] & SIG_IGNORED);
}
warning: parse error {
  return (sigmodes[sig] & SIG_IGNORED);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\trap.c:1,097
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\trap.c:1,102
parsing error 
{
  return (sigmodes[sig] & SIG_HARD_IGNORE);
}
warning: parse error {
  return (sigmodes[sig] & SIG_HARD_IGNORE);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\trap.c:1,104
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\trap.c:1,109
parsing error 
{
  sigmodes[sig] |= SIG_HARD_IGNORE;
  original_signals[sig] = SIG_IGN;
}
warning: parse error {
  sigmodes[sig] |= SIG_HARD_IGNORE;
  original_signals[sig] = SIG_IGN;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\trap.c:1,111
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\trap.c:1,117
parsing error 
{
  return (sigmodes[sig] & SIG_INPROGRESS);
}
warning: parse error {
  return (sigmodes[sig] & SIG_INPROGRESS);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\trap.c:1,119
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\unwind_prot.c...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\bashtypes.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\bashansi.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\command.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\general.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\unwind_prot.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\quit.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\sig.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\error.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\unwind_prot.c:98
parsing error 
{
  int old_interrupt_immediately;

  old_interrupt_immediately = interrupt_immediately;
  interrupt_immediately = 0;

  (*function)(arg1, arg2);

  interrupt_immediately = old_interrupt_immediately;
}
warning: parse error {
  int old_interrupt_immediately;

  old_interrupt_immediately = interrupt_immediately;
  interrupt_immediately = 0;

  (*function)(arg1, arg2);

  interrupt_immediately = old_interrupt_immediately;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\unwind_prot.c:101
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\unwind_prot.c:114
parsing error 
{
  add_unwind_protect ((Function *)NULL, tag);
}
warning: parse error {
  add_unwind_protect ((Function *)NULL, tag);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\unwind_prot.c:116
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\unwind_prot.c:122
parsing error 
{
  if (unwind_protect_list)
    without_interrupts (unwind_frame_discard_internal, tag, (char *)NULL);
}
warning: parse error {
  if (unwind_protect_list)
    without_interrupts (unwind_frame_discard_internal, tag, (char *)NULL);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\unwind_prot.c:124
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\unwind_prot.c:131
parsing error 
{
  if (unwind_protect_list)
    without_interrupts (unwind_frame_run_internal, tag, (char *)NULL);
}
warning: parse error {
  if (unwind_protect_list)
    without_interrupts (unwind_frame_run_internal, tag, (char *)NULL);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\unwind_prot.c:133
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\unwind_prot.c:140
parsing error 
{
  without_interrupts (add_unwind_protect_internal, (char *)cleanup, arg);
}
warning: parse error {
  without_interrupts (add_unwind_protect_internal, (char *)cleanup, arg);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\unwind_prot.c:143
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\unwind_prot.c:167
parsing error 
{
  char *flag;

  if (unwind_protect_list)
    {
      flag = flags ? "" : (char *)NULL;
      without_interrupts
        (clear_unwind_protects_internal, flag, (char *)NULL);
    }
}
warning: parse error {
  char *flag;

  if (unwind_protect_list)
    {
      flag = flags ? "" : (char *)NULL;
      without_interrupts
        (clear_unwind_protects_internal, flag, (char *)NULL);
    }
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\unwind_prot.c:169
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\unwind_prot.c:193
parsing error 
{
  UNWIND_ELT *elt;

  uwpalloc (elt);
  elt->head.next = unwind_protect_list;
  elt->head.cleanup = cleanup;
  elt->arg.v = arg;
  unwind_protect_list = elt;
}
warning: parse error {
  UNWIND_ELT *elt;

  uwpalloc (elt);
  elt->head.next = unwind_protect_list;
  elt->head.cleanup = cleanup;
  elt->arg.v = arg;
  unwind_protect_list = elt;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\unwind_prot.c:196
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\unwind_prot.c:207
parsing error 
{
  UNWIND_ELT *elt;

  elt = unwind_protect_list;
  if (elt)
    {
      unwind_protect_list = unwind_protect_list->head.next;
      uwpfree (elt);
    }
}
warning: parse error {
  UNWIND_ELT *elt;

  elt = unwind_protect_list;
  if (elt)
    {
      unwind_protect_list = unwind_protect_list->head.next;
      uwpfree (elt);
    }
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\unwind_prot.c:209
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\unwind_prot.c:221
parsing error 
{
  unwind_frame_run_internal ((char *) NULL, (char *) NULL);
}
warning: parse error {
  unwind_frame_run_internal ((char *) NULL, (char *) NULL);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\unwind_prot.c:223
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\unwind_prot.c:228
parsing error 
{
  if (flag)
    {
      while (unwind_protect_list)
	remove_unwind_protect_internal ((char *)NULL, (char *)NULL);
    }
  unwind_protect_list = (UNWIND_ELT *)NULL;
}
warning: parse error {
  if (flag)
    {
      while (unwind_protect_list)
	remove_unwind_protect_internal ((char *)NULL, (char *)NULL);
    }
  unwind_protect_list = (UNWIND_ELT *)NULL;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\unwind_prot.c:230
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\unwind_prot.c:240
parsing error 
{
  UNWIND_ELT *elt;
  int found;

  found = 0;
  while (elt = unwind_protect_list)
    {
      unwind_protect_list = unwind_protect_list->head.next;
      if (elt->head.cleanup == 0 && (STREQ (elt->arg.v, tag)))
	{
	  uwpfree (elt);
	  found = 1;
	  break;
	}
      else
	uwpfree (elt);
    }

  if (found == 0)
    internal_warning ("unwind_frame_discard: %s: frame not found", tag);
}
warning: parse error {
  UNWIND_ELT *elt;
  int found;

  found = 0;
  while (elt = unwind_protect_list)
    {
      unwind_protect_list = unwind_protect_list->head.next;
      if (elt->head.cleanup == 0 && (STREQ (elt->arg.v, tag)))
	{
	  uwpfree (elt);
	  found = 1;
	  break;
	}
      else
	uwpfree (elt);
    }

  if (found == 0)
    internal_warning ("unwind_frame_discard: %s: frame not found", tag);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\unwind_prot.c:242
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\unwind_prot.c:268
parsing error 
{
  FASTCOPY (sv->desired_setting, sv->variable, sv->size);
}
warning: parse error {
  FASTCOPY (sv->desired_setting, sv->variable, sv->size);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\unwind_prot.c:270
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\unwind_prot.c:275
parsing error 
{
  UNWIND_ELT *elt;
  int found;

  found = 0;
  while (elt = unwind_protect_list)
    {
      unwind_protect_list = elt->head.next;

      /* If tag, then compare. */
      if (elt->head.cleanup == 0)
	{
	  if (tag && STREQ (elt->arg.v, tag))
	    {
	      uwpfree (elt);
	      found = 1;
	      break;
	    }
	}
      else
	{
	  if (elt->head.cleanup == (Function *) restore_variable)
	    restore_variable (&elt->sv.v);
	  else
	    (*(elt->head.cleanup)) (elt->arg.v);
	}

      uwpfree (elt);
    }
  if (tag && found == 0)
    internal_warning ("unwind_frame_run: %s: frame not found", tag);
}
warning: parse error {
  UNWIND_ELT *elt;
  int found;

  found = 0;
  while (elt = unwind_protect_list)
    {
      unwind_protect_list = elt->head.next;

      /* If tag, then compare. */
      if (elt->head.cleanup == 0)
	{
	  if (tag && STREQ (elt->arg.v, tag))
	    {
	      uwpfree (elt);
	      found = 1;
	      break;
	    }
	}
      else
	{
	  if (elt->head.cleanup == (Function *) restore_variable)
	    restore_variable (&elt->sv.v);
	  else
	    (*(elt->head.cleanup)) (elt->arg.v);
	}

      uwpfree (elt);
    }
  if (tag && found == 0)
    internal_warning ("unwind_frame_run: %s: frame not found", tag);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\unwind_prot.c:277
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\unwind_prot.c:311
parsing error 
{
  int size, allocated;
  UNWIND_ELT *elt;

  size = *(int *) psize;
  allocated = size + offsetof (UNWIND_ELT, sv.v.desired_setting[0]);
  elt = (UNWIND_ELT *)xmalloc (allocated);
  elt->head.next = unwind_protect_list;
  elt->head.cleanup = (Function *) restore_variable;
  elt->sv.v.variable = var;
  elt->sv.v.size = size;
  FASTCOPY (var, elt->sv.v.desired_setting, size);
  unwind_protect_list = elt;
}
warning: parse error {
  int size, allocated;
  UNWIND_ELT *elt;

  size = *(int *) psize;
  allocated = size + offsetof (UNWIND_ELT, sv.v.desired_setting[0]);
  elt = (UNWIND_ELT *)xmalloc (allocated);
  elt->head.next = unwind_protect_list;
  elt->head.cleanup = (Function *) restore_variable;
  elt->sv.v.variable = var;
  elt->sv.v.size = size;
  FASTCOPY (var, elt->sv.v.desired_setting, size);
  unwind_protect_list = elt;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\unwind_prot.c:314
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\unwind_prot.c:333
parsing error 
{
  without_interrupts (unwind_protect_mem_internal, var, (char *) &size);
}
warning: parse error {
  without_interrupts (unwind_protect_mem_internal, var, (char *) &size);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\unwind_prot.c:336
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.c...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\bashtypes.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\posixstat.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\posixtime.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\chartypes.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\bashansi.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\bashintl.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\shell.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\flags.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\execute_cmd.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\findcmd.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\mailcheck.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\input.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\hashcmd.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\pathexp.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\alias.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\getopt.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\common.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.c:308
parsing error 
{
  char *name, *string, *temp_string;
  int c, char_index, string_index, string_length;
  SHELL_VAR *temp_var;

  create_variable_tables ();

  for (string_index = 0; string = env[string_index++]; )
    {
      char_index = 0;
      name = string;
      while ((c = *string++) && c != '=')
	;
      if (string[-1] == '=')
	char_index = string - name - 1;

      /* If there are weird things in the environment, like `=xxx' or a
	 string without an `=', just skip them. */
      if (char_index == 0)
	continue;

      /* ASSERT(name[char_index] == '=') */
      name[char_index] = '\0';
      /* Now, name = env variable name, string = env variable value, and
	 char_index == strlen (name) */

      temp_var = (SHELL_VAR *)NULL;

      /* If exported function, define it now.  Don't import functions from
	 the environment in privileged mode. */
      if (privmode == 0 && read_but_dont_execute == 0 && STREQN ("() {", string, 4))
	{
	  string_length = strlen (string);
	  temp_string = (char *)xmalloc (3 + string_length + char_index);

	  strcpy (temp_string, name);
	  temp_string[char_index] = ' ';
	  strcpy (temp_string + char_index + 1, string);

	  parse_and_execute (temp_string, name, SEVAL_NONINT|SEVAL_NOHIST);

	  /* Ancient backwards compatibility.  Old versions of bash exported
	     functions like name()=() {...} */
	  if (name[char_index - 1] == ')' && name[char_index - 2] == '(')
	    name[char_index - 2] = '\0';

	  if (temp_var = find_function (name))
	    {
	      VSETATTR (temp_var, (att_exported|att_imported));
	      array_needs_making = 1;
	    }
	  else
	    report_error (_("error importing function definition for `%s'"), name);

	  /* ( */
	  if (name[char_index - 1] == ')' && name[char_index - 2] == '\0')
	    name[char_index - 2] = '(';		/* ) */
	}
#if defined (ARRAY_VARS)
#  if 0
      /* Array variables may not yet be exported. */
      else if (*string == '(' && string[1] == '[' && string[strlen (string) - 1] == ')')
	{
	  string_length = 1;
	  temp_string = extract_array_assignment_list (string, &string_length);
	  temp_var = assign_array_from_string (name, temp_string);
	  FREE (temp_string);
	  VSETATTR (temp_var, (att_exported | att_imported));
	  array_needs_making = 1;
	}
#  endif
#endif
#if 0
      else if (legal_identifier (name))
#else
      else
#endif
	{
	  temp_var = bind_variable (name, string, 0);
	  if (temp_var)
	    {
	      if (legal_identifier (name))
		VSETATTR (temp_var, (att_exported | att_imported));
	      else
		VSETATTR (temp_var, (att_exported | att_imported | att_invisible));
	      array_needs_making = 1;
	    }
	}

      name[char_index] = '=';
      /* temp_var can be NULL if it was an exported function with a syntax
	 error (a different bug, but it still shouldn't dump core). */
      if (temp_var && function_p (temp_var) == 0)	/* XXX not yet */
	{
	  CACHE_IMPORTSTR (temp_var, name);
	}
    }

  set_pwd ();

  /* Set up initial value of $_ */
  temp_var = set_if_not ("_", dollar_vars[0]);

  /* Remember this pid. */
  dollar_dollar_pid = getpid ();

  /* Now make our own defaults in case the vars that we think are
     important are missing. */
  temp_var = set_if_not ("PATH", DEFAULT_PATH_VALUE);
#if 0
  set_auto_export (temp_var);	/* XXX */
#endif

  temp_var = set_if_not ("TERM", "dumb");
#if 0
  set_auto_export (temp_var);	/* XXX */
#endif

#if defined (__QNX__)
  /* set node id -- don't import it from the environment */
  {
    char node_name[22];
#  if defined (__QNXNTO__)
    netmgr_ndtostr(ND2S_LOCAL_STR, ND_LOCAL_NODE, node_name, sizeof(node_name));
#  else
    qnx_nidtostr (getnid (), node_name, sizeof (node_name));
#  endif
    temp_var = bind_variable ("NODE", node_name, 0);
    set_auto_export (temp_var);
  }
#endif

  /* set up the prompts. */
  if (interactive_shell)
    {
#if defined (PROMPT_STRING_DECODE)
      set_if_not ("PS1", primary_prompt);
#else
      if (current_user.uid == -1)
	get_current_user_info ();
      set_if_not ("PS1", current_user.euid == 0 ? "# " : primary_prompt);
#endif
      set_if_not ("PS2", secondary_prompt);
    }
  set_if_not ("PS4", "+ ");

  /* Don't allow IFS to be imported from the environment. */
  temp_var = bind_variable ("IFS", " \t\n", 0);
  setifs (temp_var);

  /* Magic machine types.  Pretty convenient. */
  set_machine_vars ();

  /* Default MAILCHECK for interactive shells.  Defer the creation of a
     default MAILPATH until the startup files are read, because MAIL
     names a mail file if MAILPATH is not set, and we should provide a
     default only if neither is set. */
  if (interactive_shell)
    {
      temp_var = set_if_not ("MAILCHECK", posixly_correct ? "600" : "60");
      VSETATTR (temp_var, att_integer);
    }

  /* Do some things with shell level. */
  initialize_shell_level ();

  set_ppid ();

  /* Initialize the `getopts' stuff. */
  temp_var = bind_variable ("OPTIND", "1", 0);
  VSETATTR (temp_var, att_integer);
  getopts_reset (0);
  bind_variable ("OPTERR", "1", 0);
  sh_opterr = 1;

  if (login_shell == 1 && posixly_correct == 0)
    set_home_var ();

  /* Get the full pathname to THIS shell, and set the BASH variable
     to it. */
  name = get_bash_name ();
  temp_var = bind_variable ("BASH", name, 0);
  free (name);

  /* Make the exported environment variable SHELL be the user's login
     shell.  Note that the `tset' command looks at this variable
     to determine what style of commands to output; if it ends in "csh",
     then C-shell commands are output, else Bourne shell commands. */
  set_shell_var ();

  /* Make a variable called BASH_VERSION which contains the version info. */
  bind_variable ("BASH_VERSION", shell_version_string (), 0);
#if defined (ARRAY_VARS)
  make_vers_array ();
#endif

  if (command_execution_string)
    bind_variable ("BASH_EXECUTION_STRING", command_execution_string, 0);

  /* Find out if we're supposed to be in Posix.2 mode via an
     environment variable. */
  temp_var = find_variable ("POSIXLY_CORRECT");
  if (!temp_var)
    temp_var = find_variable ("POSIX_PEDANTIC");
  if (temp_var && imported_p (temp_var))
    sv_strict_posix (temp_var->name);

#if defined (HISTORY)
  /* Set history variables to defaults, and then do whatever we would
     do if the variable had just been set.  Do this only in the case
     that we are remembering commands on the history list. */
  if (remember_on_history)
    {
      name = bash_tilde_expand (posixly_correct ? "~/.sh_history" : "~/.bash_history", 0);

      set_if_not ("HISTFILE", name);
      free (name);

#if 0
      set_if_not ("HISTSIZE", "500");
      sv_histsize ("HISTSIZE");
#endif
    }
#endif /* HISTORY */

  /* Seed the random number generator. */
  seedrand ();

  /* Handle some "special" variables that we may have inherited from a
     parent shell. */
  if (interactive_shell)
    {
      temp_var = find_variable ("IGNOREEOF");
      if (!temp_var)
	temp_var = find_variable ("ignoreeof");
      if (temp_var && imported_p (temp_var))
	sv_ignoreeof (temp_var->name);
    }

#if defined (HISTORY)
  if (interactive_shell && remember_on_history)
    {
      sv_history_control ("HISTCONTROL");
      sv_histignore ("HISTIGNORE");
      sv_histtimefmt ("HISTTIMEFORMAT");
    }
#endif /* HISTORY */

#if defined (READLINE) && defined (STRICT_POSIX)
  /* POSIXLY_CORRECT will only be 1 here if the shell was compiled
     -DSTRICT_POSIX */
  if (interactive_shell && posixly_correct && no_line_editing == 0)
    rl_prefer_env_winsize = 1;
#endif /* READLINE && STRICT_POSIX */

     /*
      * 24 October 2001
      *
      * I'm tired of the arguing and bug reports.  Bash now leaves SSH_CLIENT
      * and SSH2_CLIENT alone.  I'm going to rely on the shell_level check in
      * isnetconn() to avoid running the startup files more often than wanted.
      * That will, of course, only work if the user's login shell is bash, so
      * I've made that behavior conditional on SSH_SOURCE_BASHRC being defined
      * in config-top.h.
      */
#if 0
  temp_var = find_variable ("SSH_CLIENT");
  if (temp_var && imported_p (temp_var))
    {
      VUNSETATTR (temp_var, att_exported);
      array_needs_making = 1;
    }
  temp_var = find_variable ("SSH2_CLIENT");
  if (temp_var && imported_p (temp_var))
    {
      VUNSETATTR (temp_var, att_exported);
      array_needs_making = 1;
    }
#endif

  /* Get the user's real and effective user ids. */
  uidset ();

  temp_var = find_variable ("BASH_XTRACEFD");
  if (temp_var && imported_p (temp_var))
    sv_xtracefd (temp_var->name);

  /* Initialize the dynamic variables, and seed their values. */
  initialize_dynamic_variables ();
}
warning: parse error {
  char *name, *string, *temp_string;
  int c, char_index, string_index, string_length;
  SHELL_VAR *temp_var;

  create_variable_tables ();

  for (string_index = 0; string = env[string_index++]; )
    {
      char_index = 0;
      name = string;
      while ((c = *string++) && c != '=')
	;
      if (string[-1] == '=')
	char_index = string - name - 1;

      /* If there are weird things in the environment, like `=xxx' or a
	 string without an `=', just skip them. */
      if (char_index == 0)
	continue;

      /* ASSERT(name[char_index] == '=') */
      name[char_index] = '\0';
      /* Now, name = env variable name, string = env variable value, and
	 char_index == strlen (name) */

      temp_var = (SHELL_VAR *)NULL;

      /* If exported function, define it now.  Don't import functions from
	 the environment in privileged mode. */
      if (privmode == 0 && read_but_dont_execute == 0 && STREQN ("() {", string, 4))
	{
	  string_length = strlen (string);
	  temp_string = (char *)xmalloc (3 + string_length + char_index);

	  strcpy (temp_string, name);
	  temp_string[char_index] = ' ';
	  strcpy (temp_string + char_index + 1, string);

	  parse_and_execute (temp_string, name, SEVAL_NONINT|SEVAL_NOHIST);

	  /* Ancient backwards compatibility.  Old versions of bash exported
	     functions like name()=() {...} */
	  if (name[char_index - 1] == ')' && name[char_index - 2] == '(')
	    name[char_index - 2] = '\0';

	  if (temp_var = find_function (name))
	    {
	      VSETATTR (temp_var, (att_exported|att_imported));
	      array_needs_making = 1;
	    }
	  else
	    report_error (_("error importing function definition for `%s'"), name);

	  /* ( */
	  if (name[char_index - 1] == ')' && name[char_index - 2] == '\0')
	    name[char_index - 2] = '(';		/* ) */
	}
#if defined (ARRAY_VARS)
#  if 0
      /* Array variables may not yet be exported. */
      else if (*string == '(' && string[1] == '[' && string[strlen (string) - 1] == ')')
	{
	  string_length = 1;
	  temp_string = extract_array_assignment_list (string, &string_length);
	  temp_var = assign_array_from_string (name, temp_string);
	  FREE (temp_string);
	  VSETATTR (temp_var, (att_exported | att_imported));
	  array_needs_making = 1;
	}
#  endif
#endif
#if 0
      else if (legal_identifier (name))
#else
      else
#endif
	{
	  temp_var = bind_variable (name, string, 0);
	  if (temp_var)
	    {
	      if (legal_identifier (name))
		VSETATTR (temp_var, (att_exported | att_imported));
	      else
		VSETATTR (temp_var, (att_exported | att_imported | att_invisible));
	      array_needs_making = 1;
	    }
	}

      name[char_index] = '=';
      /* temp_var can be NULL if it was an exported function with a syntax
	 error (a different bug, but it still shouldn't dump core). */
      if (temp_var && function_p (temp_var) == 0)	/* XXX not yet */
	{
	  CACHE_IMPORTSTR (temp_var, name);
	}
    }

  set_pwd ();

  /* Set up initial value of $_ */
  temp_var = set_if_not ("_", dollar_vars[0]);

  /* Remember this pid. */
  dollar_dollar_pid = getpid ();

  /* Now make our own defaults in case the vars that we think are
     important are missing. */
  temp_var = set_if_not ("PATH", DEFAULT_PATH_VALUE);
#if 0
  set_auto_export (temp_var);	/* XXX */
#endif

  temp_var = set_if_not ("TERM", "dumb");
#if 0
  set_auto_export (temp_var);	/* XXX */
#endif

#if defined (__QNX__)
  /* set node id -- don't import it from the environment */
  {
    char node_name[22];
#  if defined (__QNXNTO__)
    netmgr_ndtostr(ND2S_LOCAL_STR, ND_LOCAL_NODE, node_name, sizeof(node_name));
#  else
    qnx_nidtostr (getnid (), node_name, sizeof (node_name));
#  endif
    temp_var = bind_variable ("NODE", node_name, 0);
    set_auto_export (temp_var);
  }
#endif

  /* set up the prompts. */
  if (interactive_shell)
    {
#if defined (PROMPT_STRING_DECODE)
      set_if_not ("PS1", primary_prompt);
#else
      if (current_user.uid == -1)
	get_current_user_info ();
      set_if_not ("PS1", current_user.euid == 0 ? "# " : primary_prompt);
#endif
      set_if_not ("PS2", secondary_prompt);
    }
  set_if_not ("PS4", "+ ");

  /* Don't allow IFS to be imported from the environment. */
  temp_var = bind_variable ("IFS", " \t\n", 0);
  setifs (temp_var);

  /* Magic machine types.  Pretty convenient. */
  set_machine_vars ();

  /* Default MAILCHECK for interactive shells.  Defer the creation of a
     default MAILPATH until the startup files are read, because MAIL
     names a mail file if MAILPATH is not set, and we should provide a
     default only if neither is set. */
  if (interactive_shell)
    {
      temp_var = set_if_not ("MAILCHECK", posixly_correct ? "600" : "60");
      VSETATTR (temp_var, att_integer);
    }

  /* Do some things with shell level. */
  initialize_shell_level ();

  set_ppid ();

  /* Initialize the `getopts' stuff. */
  temp_var = bind_variable ("OPTIND", "1", 0);
  VSETATTR (temp_var, att_integer);
  getopts_reset (0);
  bind_variable ("OPTERR", "1", 0);
  sh_opterr = 1;

  if (login_shell == 1 && posixly_correct == 0)
    set_home_var ();

  /* Get the full pathname to THIS shell, and set the BASH variable
     to it. */
  name = get_bash_name ();
  temp_var = bind_variable ("BASH", name, 0);
  free (name);

  /* Make the exported environment variable SHELL be the user's login
     shell.  Note that the `tset' command looks at this variable
     to determine what style of commands to output; if it ends in "csh",
     then C-shell commands are output, else Bourne shell commands. */
  set_shell_var ();

  /* Make a variable called BASH_VERSION which contains the version info. */
  bind_variable ("BASH_VERSION", shell_version_string (), 0);
#if defined (ARRAY_VARS)
  make_vers_array ();
#endif

  if (command_execution_string)
    bind_variable ("BASH_EXECUTION_STRING", command_execution_string, 0);

  /* Find out if we're supposed to be in Posix.2 mode via an
     environment variable. */
  temp_var = find_variable ("POSIXLY_CORRECT");
  if (!temp_var)
    temp_var = find_variable ("POSIX_PEDANTIC");
  if (temp_var && imported_p (temp_var))
    sv_strict_posix (temp_var->name);

#if defined (HISTORY)
  /* Set history variables to defaults, and then do whatever we would
     do if the variable had just been set.  Do this only in the case
     that we are remembering commands on the history list. */
  if (remember_on_history)
    {
      name = bash_tilde_expand (posixly_correct ? "~/.sh_history" : "~/.bash_history", 0);

      set_if_not ("HISTFILE", name);
      free (name);

#if 0
      set_if_not ("HISTSIZE", "500");
      sv_histsize ("HISTSIZE");
#endif
    }
#endif /* HISTORY */

  /* Seed the random number generator. */
  seedrand ();

  /* Handle some "special" variables that we may have inherited from a
     parent shell. */
  if (interactive_shell)
    {
      temp_var = find_variable ("IGNOREEOF");
      if (!temp_var)
	temp_var = find_variable ("ignoreeof");
      if (temp_var && imported_p (temp_var))
	sv_ignoreeof (temp_var->name);
    }

#if defined (HISTORY)
  if (interactive_shell && remember_on_history)
    {
      sv_history_control ("HISTCONTROL");
      sv_histignore ("HISTIGNORE");
      sv_histtimefmt ("HISTTIMEFORMAT");
    }
#endif /* HISTORY */

#if defined (READLINE) && defined (STRICT_POSIX)
  /* POSIXLY_CORRECT will only be 1 here if the shell was compiled
     -DSTRICT_POSIX */
  if (interactive_shell && posixly_correct && no_line_editing == 0)
    rl_prefer_env_winsize = 1;
#endif /* READLINE && STRICT_POSIX */

     /*
      * 24 October 2001
      *
      * I'm tired of the arguing and bug reports.  Bash now leaves SSH_CLIENT
      * and SSH2_CLIENT alone.  I'm going to rely on the shell_level check in
      * isnetconn() to avoid running the startup files more often than wanted.
      * That will, of course, only work if the user's login shell is bash, so
      * I've made that behavior conditional on SSH_SOURCE_BASHRC being defined
      * in config-top.h.
      */
#if 0
  temp_var = find_variable ("SSH_CLIENT");
  if (temp_var && imported_p (temp_var))
    {
      VUNSETATTR (temp_var, att_exported);
      array_needs_making = 1;
    }
  temp_var = find_variable ("SSH2_CLIENT");
  if (temp_var && imported_p (temp_var))
    {
      VUNSETATTR (temp_var, att_exported);
      array_needs_making = 1;
    }
#endif

  /* Get the user's real and effective user ids. */
  uidset ();

  temp_var = find_variable ("BASH_XTRACEFD");
  if (temp_var && imported_p (temp_var))
    sv_xtracefd (temp_var->name);

  /* Initialize the dynamic variables, and seed their values. */
  initialize_dynamic_variables ();
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.c:311
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.c:739
parsing error 
{
  char new_level[5], *old_SHLVL;
  intmax_t old_level;
  SHELL_VAR *temp_var;

  old_SHLVL = get_string_value ("SHLVL");
  if (old_SHLVL == 0 || *old_SHLVL == '\0' || legal_number (old_SHLVL, &old_level) == 0)
    old_level = 0;

  shell_level = old_level + change;
  if (shell_level < 0)
    shell_level = 0;
  else if (shell_level > 1000)
    {
      internal_warning (_("shell level (%d) too high, resetting to 1"), shell_level);
      shell_level = 1;
    }

  /* We don't need the full generality of itos here. */
  if (shell_level < 10)
    {
      new_level[0] = shell_level + '0';
      new_level[1] = '\0';
    }
  else if (shell_level < 100)
    {
      new_level[0] = (shell_level / 10) + '0';
      new_level[1] = (shell_level % 10) + '0';
      new_level[2] = '\0';
    }
  else if (shell_level < 1000)
    {
      new_level[0] = (shell_level / 100) + '0';
      old_level = shell_level % 100;
      new_level[1] = (old_level / 10) + '0';
      new_level[2] = (old_level % 10) + '0';
      new_level[3] = '\0';
    }

  temp_var = bind_variable ("SHLVL", new_level, 0);
  set_auto_export (temp_var);
}
warning: parse error {
  char new_level[5], *old_SHLVL;
  intmax_t old_level;
  SHELL_VAR *temp_var;

  old_SHLVL = get_string_value ("SHLVL");
  if (old_SHLVL == 0 || *old_SHLVL == '\0' || legal_number (old_SHLVL, &old_level) == 0)
    old_level = 0;

  shell_level = old_level + change;
  if (shell_level < 0)
    shell_level = 0;
  else if (shell_level > 1000)
    {
      internal_warning (_("shell level (%d) too high, resetting to 1"), shell_level);
      shell_level = 1;
    }

  /* We don't need the full generality of itos here. */
  if (shell_level < 10)
    {
      new_level[0] = shell_level + '0';
      new_level[1] = '\0';
    }
  else if (shell_level < 100)
    {
      new_level[0] = (shell_level / 10) + '0';
      new_level[1] = (shell_level % 10) + '0';
      new_level[2] = '\0';
    }
  else if (shell_level < 1000)
    {
      new_level[0] = (shell_level / 100) + '0';
      old_level = shell_level % 100;
      new_level[1] = (old_level / 10) + '0';
      new_level[2] = (old_level % 10) + '0';
      new_level[3] = '\0';
    }

  temp_var = bind_variable ("SHLVL", new_level, 0);
  set_auto_export (temp_var);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.c:741
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.c:908
parsing error 
{
  char val[INT_STRLEN_BOUND(int) + 1], *v;

#if defined (READLINE)
  /* If we are currently assigning to LINES or COLUMNS, don't do anything. */
  if (winsize_assignment)
    return;
#endif

  v = inttostr (lines, val, sizeof (val));
  bind_variable ("LINES", v, 0);

  v = inttostr (cols, val, sizeof (val));
  bind_variable ("COLUMNS", v, 0);
}
warning: parse error {
  char val[INT_STRLEN_BOUND(int) + 1], *v;

#if defined (READLINE)
  /* If we are currently assigning to LINES or COLUMNS, don't do anything. */
  if (winsize_assignment)
    return;
#endif

  v = inttostr (lines, val, sizeof (val));
  bind_variable ("LINES", v, 0);

  v = inttostr (cols, val, sizeof (val));
  bind_variable ("COLUMNS", v, 0);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.c:910
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.c:935
parsing error 
{
  register int i;
  register SHELL_VAR *var;

  for (i = 0; list && (var = list[i]); i++)
    if (invisible_p (var) == 0)
      print_assignment (var);
}
warning: parse error {
  register int i;
  register SHELL_VAR *var;

  for (i = 0; list && (var = list[i]); i++)
    if (invisible_p (var) == 0)
      print_assignment (var);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.c:937
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.c:949
parsing error 
{
  register int i;
  register SHELL_VAR *var;

  for (i = 0; list && (var = list[i]); i++)
    {
      printf ("%s ", var->name);
      print_var_function (var);
      printf ("\n");
    }
}
warning: parse error {
  register int i;
  register SHELL_VAR *var;

  for (i = 0; list && (var = list[i]); i++)
    {
      printf ("%s ", var->name);
      print_var_function (var);
      printf ("\n");
    }
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.c:951
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.c:967
parsing error 
{
  if (var_isset (var) == 0)
    return;

  if (function_p (var))
    {
      printf ("%s", var->name);
      print_var_function (var);
      printf ("\n");
    }
#if defined (ARRAY_VARS)
  else if (array_p (var))
    print_array_assignment (var, 0);
  else if (assoc_p (var))
    print_assoc_assignment (var, 0);
#endif /* ARRAY_VARS */
  else
    {
      printf ("%s=", var->name);
      print_var_value (var, 1);
      printf ("\n");
    }
}
warning: parse error {
  if (var_isset (var) == 0)
    return;

  if (function_p (var))
    {
      printf ("%s", var->name);
      print_var_function (var);
      printf ("\n");
    }
#if defined (ARRAY_VARS)
  else if (array_p (var))
    print_array_assignment (var, 0);
  else if (assoc_p (var))
    print_assoc_assignment (var, 0);
#endif /* ARRAY_VARS */
  else
    {
      printf ("%s=", var->name);
      print_var_value (var, 1);
      printf ("\n");
    }
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.c:969
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.c:998
parsing error 
{
  char *t;

  if (var_isset (var) == 0)
    return;

  if (quote && posixly_correct == 0 && ansic_shouldquote (value_cell (var)))
    {
      t = ansic_quote (value_cell (var), 0, (int *)0);
      printf ("%s", t);
      free (t);
    }
  else if (quote && sh_contains_shell_metas (value_cell (var)))
    {
      t = sh_single_quote (value_cell (var));
      printf ("%s", t);
      free (t);
    }
  else
    printf ("%s", value_cell (var));
}
warning: parse error {
  char *t;

  if (var_isset (var) == 0)
    return;

  if (quote && posixly_correct == 0 && ansic_shouldquote (value_cell (var)))
    {
      t = ansic_quote (value_cell (var), 0, (int *)0);
      printf ("%s", t);
      free (t);
    }
  else if (quote && sh_contains_shell_metas (value_cell (var)))
    {
      t = sh_single_quote (value_cell (var));
      printf ("%s", t);
      free (t);
    }
  else
    printf ("%s", value_cell (var));
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.c:1,001
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.c:1,026
parsing error 
{
  char *x;

  if (function_p (var) && var_isset (var))
    {
      x = named_function_string ((char *)NULL, function_cell(var), FUNC_MULTILINE|FUNC_EXTERNAL);
      printf ("%s", x);
    }
}
warning: parse error {
  char *x;

  if (function_p (var) && var_isset (var))
    {
      x = named_function_string ((char *)NULL, function_cell(var), FUNC_MULTILINE|FUNC_EXTERNAL);
      printf ("%s", x);
    }
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.c:1,028
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.c:1,105
parsing error 
{
  return (self);
}
warning: parse error {
  return (self);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.c:1,110
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.c:1,129
parsing error 
{
  return (self);
}
warning: parse error {
  return (self);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.c:1,131
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.c:1,181
parsing error 
{
  if (legal_number (value, &seconds_value_assigned) == 0)
    seconds_value_assigned = 0;
  shell_start_time = NOW;
  return (self);
}
warning: parse error {
  if (legal_number (value, &seconds_value_assigned) == 0)
    seconds_value_assigned = 0;
  shell_start_time = NOW;
  return (self);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.c:1,186
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.c:1,194
parsing error 
{
  time_t time_since_start;
  char *p;

  time_since_start = NOW - shell_start_time;
  p = itos(seconds_value_assigned + time_since_start);

  FREE (value_cell (var));

  VSETATTR (var, att_integer);
  var_setvalue (var, p);
  return (var);
}
warning: parse error {
  time_t time_since_start;
  char *p;

  time_since_start = NOW - shell_start_time;
  p = itos(seconds_value_assigned + time_since_start);

  FREE (value_cell (var));

  VSETATTR (var, att_integer);
  var_setvalue (var, p);
  return (var);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.c:1,196
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.c:1,258
parsing error 
{
  rseed = seed;
  last_random_value = 0;
}
warning: parse error {
  rseed = seed;
  last_random_value = 0;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.c:1,260
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.c:1,275
parsing error 
{
  sbrand (strtoul (value, (char **)NULL, 10));
  if (subshell_environment)
    seeded_subshell = getpid ();
  return (self);
}
warning: parse error {
  sbrand (strtoul (value, (char **)NULL, 10));
  if (subshell_environment)
    seeded_subshell = getpid ();
  return (self);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.c:1,280
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.c:1,307
parsing error 
{
  int rv;
  char *p;

  rv = get_random_number ();
  last_random_value = rv;
  p = itos (rv);

  FREE (value_cell (var));

  VSETATTR (var, att_integer);
  var_setvalue (var, p);
  return (var);
}
warning: parse error {
  int rv;
  char *p;

  rv = get_random_number ();
  last_random_value = rv;
  p = itos (rv);

  FREE (value_cell (var));

  VSETATTR (var, att_integer);
  var_setvalue (var, p);
  return (var);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.c:1,309
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.c:1,325
parsing error 
{
  intmax_t new_value;

  if (value == 0 || *value == '\0' || legal_number (value, &new_value) == 0)
    new_value = 0;
  line_number = line_number_base = new_value;
  return var;
}
warning: parse error {
  intmax_t new_value;

  if (value == 0 || *value == '\0' || legal_number (value, &new_value) == 0)
    new_value = 0;
  line_number = line_number_base = new_value;
  return var;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.c:1,330
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.c:1,341
parsing error 
{
  char *p;
  int ln;

  ln = executing_line_number ();
  p = itos (ln);
  FREE (value_cell (var));
  var_setvalue (var, p);
  return (var);
}
warning: parse error {
  char *p;
  int ln;

  ln = executing_line_number ();
  p = itos (ln);
  FREE (value_cell (var));
  var_setvalue (var, p);
  return (var);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.c:1,343
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.c:1,355
parsing error 
{
  intmax_t new_value;

  if (value == 0 || *value == '\0' || legal_number (value, &new_value) == 0)
    new_value = 0;
  subshell_level = new_value;
  return var;
}
warning: parse error {
  intmax_t new_value;

  if (value == 0 || *value == '\0' || legal_number (value, &new_value) == 0)
    new_value = 0;
  subshell_level = new_value;
  return var;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.c:1,360
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.c:1,370
parsing error 
{
  char *p;

  p = itos (subshell_level);
  FREE (value_cell (var));
  var_setvalue (var, p);
  return (var);
}
warning: parse error {
  char *p;

  p = itos (subshell_level);
  FREE (value_cell (var));
  var_setvalue (var, p);
  return (var);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.c:1,372
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.c:1,382
parsing error 
{
  int pid;
  char *p;

  pid = getpid ();
  p = itos (pid);

  FREE (value_cell (var));
  VSETATTR (var, att_integer|att_readonly);
  var_setvalue (var, p);
  return (var);
}
warning: parse error {
  int pid;
  char *p;

  pid = getpid ();
  p = itos (pid);

  FREE (value_cell (var));
  VSETATTR (var, att_integer|att_readonly);
  var_setvalue (var, p);
  return (var);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.c:1,384
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.c:1,398
parsing error 
{
  char *p;

  if (the_printed_command_except_trap)
    p = savestring (the_printed_command_except_trap);
  else
    {
      p = (char *)xmalloc (1);
      p[0] = '\0';
    }
  FREE (value_cell (var));
  var_setvalue (var, p);
  return (var);
}
warning: parse error {
  char *p;

  if (the_printed_command_except_trap)
    p = savestring (the_printed_command_except_trap);
  else
    {
      p = (char *)xmalloc (1);
      p[0] = '\0';
    }
  FREE (value_cell (var));
  var_setvalue (var, p);
  return (var);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.c:1,400
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.c:1,626
parsing error 
{
#if ! defined (ARRAY_VARS)
  char *t;
  if (variable_context && this_shell_function)
    {
      FREE (value_cell (self));
      t = savestring (this_shell_function->name);
      var_setvalue (self, t);
    }
#endif
  return (self);
}
warning: parse error {
#if ! defined (ARRAY_VARS)
  char *t;
  if (variable_context && this_shell_function)
    {
      FREE (value_cell (self));
      t = savestring (this_shell_function->name);
      var_setvalue (self, t);
    }
#endif
  return (self);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.c:1,628
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.c:1,642
parsing error 
{
  SHELL_VAR *v;

  v = find_variable ("FUNCNAME");
  if (v == 0 || v->dynamic_value == 0)
    return;

  if (on_or_off)
    VUNSETATTR (v, att_invisible);
  else
    VSETATTR (v, att_invisible);
}
warning: parse error {
  SHELL_VAR *v;

  v = find_variable ("FUNCNAME");
  if (v == 0 || v->dynamic_value == 0)
    return;

  if (on_or_off)
    VUNSETATTR (v, att_invisible);
  else
    VSETATTR (v, att_invisible);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.c:1,644
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.c:1,736
parsing error 
{
  BUCKET_CONTENTS *bucket;

  bucket = hash_search (name, hashed_vars, 0);
  return (bucket ? (SHELL_VAR *)bucket->data : (SHELL_VAR *)NULL);
}
warning: parse error {
  BUCKET_CONTENTS *bucket;

  bucket = hash_search (name, hashed_vars, 0);
  return (bucket ? (SHELL_VAR *)bucket->data : (SHELL_VAR *)NULL);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.c:1,738
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.c:1,747
parsing error 
{
  VAR_CONTEXT *vc;
  SHELL_VAR *v;

  v = (SHELL_VAR *)NULL;
  for (vc = vcontext; vc; vc = vc->down)
    if (v = hash_lookup (name, vc->table))
      break;

  return v;
}
warning: parse error {
  VAR_CONTEXT *vc;
  SHELL_VAR *v;

  v = (SHELL_VAR *)NULL;
  for (vc = vcontext; vc; vc = vc->down)
    if (v = hash_lookup (name, vc->table))
      break;

  return v;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.c:1,749
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.c:1,770
parsing error 
{
  SHELL_VAR *var;
  int search_tempenv;

  var = (SHELL_VAR *)NULL;

  /* If explicitly requested, first look in the temporary environment for
     the variable.  This allows constructs such as "foo=x eval 'echo $foo'"
     to get the `exported' value of $foo.  This happens if we are executing
     a function or builtin, or if we are looking up a variable in a
     "subshell environment". */
  search_tempenv = force_tempenv || (expanding_redir == 0 && subshell_environment);

  if (search_tempenv && temporary_env)		
    var = hash_lookup (name, temporary_env);

  if (var == 0)
    var = var_lookup (name, shell_variables);

  if (var == 0)
    return ((SHELL_VAR *)NULL);

  return (var->dynamic_value ? (*(var->dynamic_value)) (var) : var);
}
warning: parse error {
  SHELL_VAR *var;
  int search_tempenv;

  var = (SHELL_VAR *)NULL;

  /* If explicitly requested, first look in the temporary environment for
     the variable.  This allows constructs such as "foo=x eval 'echo $foo'"
     to get the `exported' value of $foo.  This happens if we are executing
     a function or builtin, or if we are looking up a variable in a
     "subshell environment". */
  search_tempenv = force_tempenv || (expanding_redir == 0 && subshell_environment);

  if (search_tempenv && temporary_env)		
    var = hash_lookup (name, temporary_env);

  if (var == 0)
    var = var_lookup (name, shell_variables);

  if (var == 0)
    return ((SHELL_VAR *)NULL);

  return (var->dynamic_value ? (*(var->dynamic_value)) (var) : var);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.c:1,772
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.c:1,799
parsing error 
{
  SHELL_VAR *var;

  var = var_lookup (name, global_variables);

  if (var == 0)
    return ((SHELL_VAR *)NULL);

  return (var->dynamic_value ? (*(var->dynamic_value)) (var) : var);
}
warning: parse error {
  SHELL_VAR *var;

  var = var_lookup (name, global_variables);

  if (var == 0)
    return ((SHELL_VAR *)NULL);

  return (var->dynamic_value ? (*(var->dynamic_value)) (var) : var);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.c:1,800
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.c:1,814
parsing error 
{
  return (find_variable_internal (name, (expanding_redir == 0 && (assigning_in_environment || executing_builtin))));
}
warning: parse error {
  return (find_variable_internal (name, (expanding_redir == 0 && (assigning_in_environment || executing_builtin))));
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.c:1,815
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.c:1,823
parsing error 
{
  return (hash_lookup (name, shell_functions));
}
warning: parse error {
  return (hash_lookup (name, shell_functions));
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.c:1,824
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.c:1,832
parsing error 
{
#if defined (DEBUGGER)
  return ((FUNCTION_DEF *)hash_lookup (name, shell_function_defs));
#else
  return ((FUNCTION_DEF *)0);
#endif
}
warning: parse error {
#if defined (DEBUGGER)
  return ((FUNCTION_DEF *)hash_lookup (name, shell_function_defs));
#else
  return ((FUNCTION_DEF *)0);
#endif
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.c:1,833
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.c:1,844
parsing error 
{
  if (var == 0)
    return ((char *)NULL);
#if defined (ARRAY_VARS)
  else if (array_p (var))
    return (array_reference (array_cell (var), 0));
  else if (assoc_p (var))
    return (assoc_reference (assoc_cell (var), "0"));
#endif
  else
    return (value_cell (var));
}
warning: parse error {
  if (var == 0)
    return ((char *)NULL);
#if defined (ARRAY_VARS)
  else if (array_p (var))
    return (array_reference (array_cell (var), 0));
  else if (assoc_p (var))
    return (assoc_reference (assoc_cell (var), "0"));
#endif
  else
    return (value_cell (var));
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.c:1,846
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.c:1,866
parsing error 
{
  SHELL_VAR *var;

  var = find_variable (var_name);
  return ((var) ? get_variable_value (var) : (char *)NULL);
}
warning: parse error {
  SHELL_VAR *var;

  var = find_variable (var_name);
  return ((var) ? get_variable_value (var) : (char *)NULL);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.c:1,867
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.c:1,877
parsing error 
{
  return get_string_value (v);
}
warning: parse error {
  return get_string_value (v);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.c:1,878
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.c:1,890
parsing error 
{
  SHELL_VAR *v;

  if (shell_variables == 0)
    create_variable_tables ();

  v = find_variable (name);
  if (v == 0)
    v = bind_variable_internal (name, value, global_variables->table, HASH_NOSRCH, 0);
  return (v);
}
warning: parse error {
  SHELL_VAR *v;

  if (shell_variables == 0)
    create_variable_tables ();

  v = find_variable (name);
  if (v == 0)
    v = bind_variable_internal (name, value, global_variables->table, HASH_NOSRCH, 0);
  return (v);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.c:1,892
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.c:1,907
parsing error 
{
  SHELL_VAR *new_var, *old_var;
  VAR_CONTEXT *vc;
  int was_tmpvar;
  char *tmp_value;

  /* local foo; local foo;  is a no-op. */
  old_var = find_variable (name);
  if (old_var && local_p (old_var) && old_var->context == variable_context)
    {
      VUNSETATTR (old_var, att_invisible);
      return (old_var);
    }

  was_tmpvar = old_var && tempvar_p (old_var);
  if (was_tmpvar)
    tmp_value = value_cell (old_var);

  for (vc = shell_variables; vc; vc = vc->down)
    if (vc_isfuncenv (vc) && vc->scope == variable_context)
      break;

  if (vc == 0)
    {
      internal_error (_("make_local_variable: no function context at current scope"));
      return ((SHELL_VAR *)NULL);
    }
  else if (vc->table == 0)
    vc->table = hash_create (TEMPENV_HASH_BUCKETS);

  /* Since this is called only from the local/declare/typeset code, we can
     call builtin_error here without worry (of course, it will also work
     for anything that sets this_command_name).  Variables with the `noassign'
     attribute may not be made local.  The test against old_var's context
     level is to disallow local copies of readonly global variables (since I
     believe that this could be a security hole).  Readonly copies of calling
     function local variables are OK. */
  if (old_var && (noassign_p (old_var) ||
		 (readonly_p (old_var) && old_var->context == 0)))
    {
      if (readonly_p (old_var))
	sh_readonly (name);
      return ((SHELL_VAR *)NULL);
    }

  if (old_var == 0)
    new_var = make_new_variable (name, vc->table);
  else
    {
      new_var = make_new_variable (name, vc->table);

      /* If we found this variable in one of the temporary environments,
	 inherit its value.  Watch to see if this causes problems with
	 things like `x=4 local x'. */
      if (was_tmpvar)
	var_setvalue (new_var, savestring (tmp_value));

      new_var->attributes = exported_p (old_var) ? att_exported : 0;
    }

  vc->flags |= VC_HASLOCAL;

  new_var->context = variable_context;
  VSETATTR (new_var, att_local);

  if (ifsname (name))
    setifs (new_var);

  return (new_var);
}
warning: parse error {
  SHELL_VAR *new_var, *old_var;
  VAR_CONTEXT *vc;
  int was_tmpvar;
  char *tmp_value;

  /* local foo; local foo;  is a no-op. */
  old_var = find_variable (name);
  if (old_var && local_p (old_var) && old_var->context == variable_context)
    {
      VUNSETATTR (old_var, att_invisible);
      return (old_var);
    }

  was_tmpvar = old_var && tempvar_p (old_var);
  if (was_tmpvar)
    tmp_value = value_cell (old_var);

  for (vc = shell_variables; vc; vc = vc->down)
    if (vc_isfuncenv (vc) && vc->scope == variable_context)
      break;

  if (vc == 0)
    {
      internal_error (_("make_local_variable: no function context at current scope"));
      return ((SHELL_VAR *)NULL);
    }
  else if (vc->table == 0)
    vc->table = hash_create (TEMPENV_HASH_BUCKETS);

  /* Since this is called only from the local/declare/typeset code, we can
     call builtin_error here without worry (of course, it will also work
     for anything that sets this_command_name).  Variables with the `noassign'
     attribute may not be made local.  The test against old_var's context
     level is to disallow local copies of readonly global variables (since I
     believe that this could be a security hole).  Readonly copies of calling
     function local variables are OK. */
  if (old_var && (noassign_p (old_var) ||
		 (readonly_p (old_var) && old_var->context == 0)))
    {
      if (readonly_p (old_var))
	sh_readonly (name);
      return ((SHELL_VAR *)NULL);
    }

  if (old_var == 0)
    new_var = make_new_variable (name, vc->table);
  else
    {
      new_var = make_new_variable (name, vc->table);

      /* If we found this variable in one of the temporary environments,
	 inherit its value.  Watch to see if this causes problems with
	 things like `x=4 local x'. */
      if (was_tmpvar)
	var_setvalue (new_var, savestring (tmp_value));

      new_var->attributes = exported_p (old_var) ? att_exported : 0;
    }

  vc->flags |= VC_HASLOCAL;

  new_var->context = variable_context;
  VSETATTR (new_var, att_local);

  if (ifsname (name))
    setifs (new_var);

  return (new_var);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.c:1,908
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.c:1,982
parsing error 
{
  SHELL_VAR *entry;

  entry = (SHELL_VAR *)xmalloc (sizeof (SHELL_VAR));

  entry->name = savestring (name);
  var_setvalue (entry, (char *)NULL);
  CLEAR_EXPORTSTR (entry);

  entry->dynamic_value = (sh_var_value_func_t *)NULL;
  entry->assign_func = (sh_var_assign_func_t *)NULL;

  entry->attributes = 0;

  /* Always assume variables are to be made at toplevel!
     make_local_variable has the responsibilty of changing the
     variable context. */
  entry->context = 0;

  return (entry);
}
warning: parse error {
  SHELL_VAR *entry;

  entry = (SHELL_VAR *)xmalloc (sizeof (SHELL_VAR));

  entry->name = savestring (name);
  var_setvalue (entry, (char *)NULL);
  CLEAR_EXPORTSTR (entry);

  entry->dynamic_value = (sh_var_value_func_t *)NULL;
  entry->assign_func = (sh_var_assign_func_t *)NULL;

  entry->attributes = 0;

  /* Always assume variables are to be made at toplevel!
     make_local_variable has the responsibilty of changing the
     variable context. */
  entry->context = 0;

  return (entry);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.c:1,983
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.c:2,009
parsing error 
{
  SHELL_VAR *entry;
  BUCKET_CONTENTS *elt;

  entry = new_shell_variable (name);

  /* Make sure we have a shell_variables hash table to add to. */
  if (shell_variables == 0)
    create_variable_tables ();

  elt = hash_insert (savestring (name), table, HASH_NOSRCH);
  elt->data = (PTR_T)entry;

  return entry;
}
warning: parse error {
  SHELL_VAR *entry;
  BUCKET_CONTENTS *elt;

  entry = new_shell_variable (name);

  /* Make sure we have a shell_variables hash table to add to. */
  if (shell_variables == 0)
    create_variable_tables ();

  elt = hash_insert (savestring (name), table, HASH_NOSRCH);
  elt->data = (PTR_T)entry;

  return entry;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.c:2,011
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.c:2,098
parsing error 
{
  char *retval, *oval;
  intmax_t lval, rval;
  int expok, olen, op;

  /* If this variable has had its type set to integer (via `declare -i'),
     then do expression evaluation on it and store the result.  The
     functions in expr.c (evalexp()) and bind_int_variable() are responsible
     for turning off the integer flag if they don't want further
     evaluation done. */
  if (integer_p (var))
    {
      if (flags & ASS_APPEND)
	{
	  oval = value_cell (var);
	  lval = evalexp (oval, &expok);	/* ksh93 seems to do this */
	  if (expok == 0)
	    {
	      top_level_cleanup ();
	      jump_to_top_level (DISCARD);
	    }
	}
      rval = evalexp (value, &expok);
      if (expok == 0)
	{
	  top_level_cleanup ();
	  jump_to_top_level (DISCARD);
	}
      if (flags & ASS_APPEND)
	rval += lval;
      retval = itos (rval);
    }
#if defined (CASEMOD_ATTRS)
  else if (capcase_p (var) || uppercase_p (var) || lowercase_p (var))
    {
      if (flags & ASS_APPEND)
	{
	  oval = get_variable_value (var);
	  if (oval == 0)	/* paranoia */
	    oval = "";
	  olen = STRLEN (oval);
	  retval = (char *)xmalloc (olen + (value ? STRLEN (value) : 0) + 1);
	  strcpy (retval, oval);
	  if (value)
	    strcpy (retval+olen, value);
	}
      else if (*value)
	retval = savestring (value);
      else
	{
	  retval = (char *)xmalloc (1);
	  retval[0] = '\0';
	}
      op = capcase_p (var) ? CASE_CAPITALIZE
			 : (uppercase_p (var) ? CASE_UPPER : CASE_LOWER);
      oval = sh_modcase (retval, (char *)0, op);
      free (retval);
      retval = oval;
    }
#endif /* CASEMOD_ATTRS */
  else if (value)
    {
      if (flags & ASS_APPEND)
	{
	  oval = get_variable_value (var);
	  if (oval == 0)	/* paranoia */
	    oval = "";
	  olen = STRLEN (oval);
	  retval = (char *)xmalloc (olen + (value ? STRLEN (value) : 0) + 1);
	  strcpy (retval, oval);
	  if (value)
	    strcpy (retval+olen, value);
	}
      else if (*value)
	retval = savestring (value);
      else
	{
	  retval = (char *)xmalloc (1);
	  retval[0] = '\0';
	}
    }
  else
    retval = (char *)NULL;

  return retval;
}
warning: parse error {
  char *retval, *oval;
  intmax_t lval, rval;
  int expok, olen, op;

  /* If this variable has had its type set to integer (via `declare -i'),
     then do expression evaluation on it and store the result.  The
     functions in expr.c (evalexp()) and bind_int_variable() are responsible
     for turning off the integer flag if they don't want further
     evaluation done. */
  if (integer_p (var))
    {
      if (flags & ASS_APPEND)
	{
	  oval = value_cell (var);
	  lval = evalexp (oval, &expok);	/* ksh93 seems to do this */
	  if (expok == 0)
	    {
	      top_level_cleanup ();
	      jump_to_top_level (DISCARD);
	    }
	}
      rval = evalexp (value, &expok);
      if (expok == 0)
	{
	  top_level_cleanup ();
	  jump_to_top_level (DISCARD);
	}
      if (flags & ASS_APPEND)
	rval += lval;
      retval = itos (rval);
    }
#if defined (CASEMOD_ATTRS)
  else if (capcase_p (var) || uppercase_p (var) || lowercase_p (var))
    {
      if (flags & ASS_APPEND)
	{
	  oval = get_variable_value (var);
	  if (oval == 0)	/* paranoia */
	    oval = "";
	  olen = STRLEN (oval);
	  retval = (char *)xmalloc (olen + (value ? STRLEN (value) : 0) + 1);
	  strcpy (retval, oval);
	  if (value)
	    strcpy (retval+olen, value);
	}
      else if (*value)
	retval = savestring (value);
      else
	{
	  retval = (char *)xmalloc (1);
	  retval[0] = '\0';
	}
      op = capcase_p (var) ? CASE_CAPITALIZE
			 : (uppercase_p (var) ? CASE_UPPER : CASE_LOWER);
      oval = sh_modcase (retval, (char *)0, op);
      free (retval);
      retval = oval;
    }
#endif /* CASEMOD_ATTRS */
  else if (value)
    {
      if (flags & ASS_APPEND)
	{
	  oval = get_variable_value (var);
	  if (oval == 0)	/* paranoia */
	    oval = "";
	  olen = STRLEN (oval);
	  retval = (char *)xmalloc (olen + (value ? STRLEN (value) : 0) + 1);
	  strcpy (retval, oval);
	  if (value)
	    strcpy (retval+olen, value);
	}
      else if (*value)
	retval = savestring (value);
      else
	{
	  retval = (char *)xmalloc (1);
	  retval[0] = '\0';
	}
    }
  else
    retval = (char *)NULL;

  return retval;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.c:2,102
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.c:2,193
parsing error 
{
  char *newval;
  SHELL_VAR *entry;

  entry = (hflags & HASH_NOSRCH) ? (SHELL_VAR *)NULL : hash_lookup (name, table);

  if (entry == 0)
    {
      entry = make_new_variable (name, table);
      var_setvalue (entry, make_variable_value (entry, value, 0)); /* XXX */
    }
  else if (entry->assign_func)	/* array vars have assign functions now */
    {
      INVALIDATE_EXPORTSTR (entry);
      newval = (aflags & ASS_APPEND) ? make_variable_value (entry, value, aflags) : value;
      if (assoc_p (entry))
	entry = (*(entry->assign_func)) (entry, newval, -1, savestring ("0"));
      else if (array_p (entry))
	entry = (*(entry->assign_func)) (entry, newval, 0, 0);
      else
	entry = (*(entry->assign_func)) (entry, newval, -1, 0);
      if (newval != value)
	free (newval);
      return (entry);
    }
  else
    {
      if (readonly_p (entry) || noassign_p (entry))
	{
	  if (readonly_p (entry))
	    err_readonly (name);
	  return (entry);
	}

      /* Variables which are bound are visible. */
      VUNSETATTR (entry, att_invisible);

      newval = make_variable_value (entry, value, aflags);	/* XXX */

      /* Invalidate any cached export string */
      INVALIDATE_EXPORTSTR (entry);

#if defined (ARRAY_VARS)
      /* XXX -- this bears looking at again -- XXX */
      /* If an existing array variable x is being assigned to with x=b or
	 `read x' or something of that nature, silently convert it to
	 x[0]=b or `read x[0]'. */
      if (array_p (entry))
	{
	  array_insert (array_cell (entry), 0, newval);
	  free (newval);
	}
      else if (assoc_p (entry))
	{
	  assoc_insert (assoc_cell (entry), savestring ("0"), newval);
	  free (newval);
	}
      else
#endif
	{
	  FREE (value_cell (entry));
	  var_setvalue (entry, newval);
	}
    }

  if (mark_modified_vars)
    VSETATTR (entry, att_exported);

  if (exported_p (entry))
    array_needs_making = 1;

  return (entry);
}
warning: parse error {
  char *newval;
  SHELL_VAR *entry;

  entry = (hflags & HASH_NOSRCH) ? (SHELL_VAR *)NULL : hash_lookup (name, table);

  if (entry == 0)
    {
      entry = make_new_variable (name, table);
      var_setvalue (entry, make_variable_value (entry, value, 0)); /* XXX */
    }
  else if (entry->assign_func)	/* array vars have assign functions now */
    {
      INVALIDATE_EXPORTSTR (entry);
      newval = (aflags & ASS_APPEND) ? make_variable_value (entry, value, aflags) : value;
      if (assoc_p (entry))
	entry = (*(entry->assign_func)) (entry, newval, -1, savestring ("0"));
      else if (array_p (entry))
	entry = (*(entry->assign_func)) (entry, newval, 0, 0);
      else
	entry = (*(entry->assign_func)) (entry, newval, -1, 0);
      if (newval != value)
	free (newval);
      return (entry);
    }
  else
    {
      if (readonly_p (entry) || noassign_p (entry))
	{
	  if (readonly_p (entry))
	    err_readonly (name);
	  return (entry);
	}

      /* Variables which are bound are visible. */
      VUNSETATTR (entry, att_invisible);

      newval = make_variable_value (entry, value, aflags);	/* XXX */

      /* Invalidate any cached export string */
      INVALIDATE_EXPORTSTR (entry);

#if defined (ARRAY_VARS)
      /* XXX -- this bears looking at again -- XXX */
      /* If an existing array variable x is being assigned to with x=b or
	 `read x' or something of that nature, silently convert it to
	 x[0]=b or `read x[0]'. */
      if (array_p (entry))
	{
	  array_insert (array_cell (entry), 0, newval);
	  free (newval);
	}
      else if (assoc_p (entry))
	{
	  assoc_insert (assoc_cell (entry), savestring ("0"), newval);
	  free (newval);
	}
      else
#endif
	{
	  FREE (value_cell (entry));
	  var_setvalue (entry, newval);
	}
    }

  if (mark_modified_vars)
    VSETATTR (entry, att_exported);

  if (exported_p (entry))
    array_needs_making = 1;

  return (entry);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.c:2,197
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.c:2,277
parsing error 
{
  SHELL_VAR *v;
  VAR_CONTEXT *vc;

  if (shell_variables == 0)
    create_variable_tables ();

  /* If we have a temporary environment, look there first for the variable,
     and, if found, modify the value there before modifying it in the
     shell_variables table.  This allows sourced scripts to modify values
     given to them in a temporary environment while modifying the variable
     value that the caller sees. */
  if (temporary_env)
    bind_tempenv_variable (name, value);

  /* XXX -- handle local variables here. */
  for (vc = shell_variables; vc; vc = vc->down)
    {
      if (vc_isfuncenv (vc) || vc_isbltnenv (vc))
	{
	  v = hash_lookup (name, vc->table);
	  if (v)
	    return (bind_variable_internal (name, value, vc->table, 0, flags));
	}
    }
  return (bind_variable_internal (name, value, global_variables->table, 0, flags));
}
warning: parse error {
  SHELL_VAR *v;
  VAR_CONTEXT *vc;

  if (shell_variables == 0)
    create_variable_tables ();

  /* If we have a temporary environment, look there first for the variable,
     and, if found, modify the value there before modifying it in the
     shell_variables table.  This allows sourced scripts to modify values
     given to them in a temporary environment while modifying the variable
     value that the caller sees. */
  if (temporary_env)
    bind_tempenv_variable (name, value);

  /* XXX -- handle local variables here. */
  for (vc = shell_variables; vc; vc = vc->down)
    {
      if (vc_isfuncenv (vc) || vc_isbltnenv (vc))
	{
	  v = hash_lookup (name, vc->table);
	  if (v)
	    return (bind_variable_internal (name, value, vc->table, 0, flags));
	}
    }
  return (bind_variable_internal (name, value, global_variables->table, 0, flags));
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.c:2,280
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.c:2,314
parsing error 
{
  char *t;

  VUNSETATTR (var, att_invisible);

  if (var->assign_func)
    {
      /* If we're appending, we need the old value, so use
	 make_variable_value */
      t = (aflags & ASS_APPEND) ? make_variable_value (var, value, aflags) : value;
      (*(var->assign_func)) (var, t, -1, 0);
      if (t != value && t)
	free (t);      
    }
  else
    {
      t = make_variable_value (var, value, aflags);
      FREE (value_cell (var));
      var_setvalue (var, t);
    }

  INVALIDATE_EXPORTSTR (var);

  if (mark_modified_vars)
    VSETATTR (var, att_exported);

  if (exported_p (var))
    array_needs_making = 1;

  return (var);
}
warning: parse error {
  char *t;

  VUNSETATTR (var, att_invisible);

  if (var->assign_func)
    {
      /* If we're appending, we need the old value, so use
	 make_variable_value */
      t = (aflags & ASS_APPEND) ? make_variable_value (var, value, aflags) : value;
      (*(var->assign_func)) (var, t, -1, 0);
      if (t != value && t)
	free (t);      
    }
  else
    {
      t = make_variable_value (var, value, aflags);
      FREE (value_cell (var));
      var_setvalue (var, t);
    }

  INVALIDATE_EXPORTSTR (var);

  if (mark_modified_vars)
    VSETATTR (var, att_exported);

  if (exported_p (var))
    array_needs_making = 1;

  return (var);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.c:2,318
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.c:2,361
parsing error 
{
  register SHELL_VAR *v;
  int isint, isarr;

  isint = isarr = 0;
#if defined (ARRAY_VARS)
  if (valid_array_reference (lhs))
    {
      isarr = 1;
      v = array_variable_part (lhs, (char **)0, (int *)0);
    }
  else
#endif
    v = find_variable (lhs);

  if (v)
    {
      isint = integer_p (v);
      VUNSETATTR (v, att_integer);
    }

#if defined (ARRAY_VARS)
  if (isarr)
    v = assign_array_element (lhs, rhs, 0);
  else
#endif
    v = bind_variable (lhs, rhs, 0);

  if (v && isint)
    VSETATTR (v, att_integer);

  return (v);
}
warning: parse error {
  register SHELL_VAR *v;
  int isint, isarr;

  isint = isarr = 0;
#if defined (ARRAY_VARS)
  if (valid_array_reference (lhs))
    {
      isarr = 1;
      v = array_variable_part (lhs, (char **)0, (int *)0);
    }
  else
#endif
    v = find_variable (lhs);

  if (v)
    {
      isint = integer_p (v);
      VUNSETATTR (v, att_integer);
    }

#if defined (ARRAY_VARS)
  if (isarr)
    v = assign_array_element (lhs, rhs, 0);
  else
#endif
    v = bind_variable (lhs, rhs, 0);

  if (v && isint)
    VSETATTR (v, att_integer);

  return (v);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.c:2,363
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.c:2,398
parsing error 
{
  char ibuf[INT_STRLEN_BOUND (intmax_t) + 1], *p;

  p = fmtulong (val, 10, ibuf, sizeof (ibuf), 0);
  return (bind_int_variable (var, p));
}
warning: parse error {
  char ibuf[INT_STRLEN_BOUND (intmax_t) + 1], *p;

  p = fmtulong (val, 10, ibuf, sizeof (ibuf), 0);
  return (bind_int_variable (var, p));
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.c:2,401
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.c:2,412
parsing error 
{
  SHELL_VAR *entry;

  entry = find_function (name);
  if (entry == 0)
    {
      BUCKET_CONTENTS *elt;

      elt = hash_insert (savestring (name), shell_functions, HASH_NOSRCH);
      entry = new_shell_variable (name);
      elt->data = (PTR_T)entry;
    }
  else
    INVALIDATE_EXPORTSTR (entry);

  if (var_isset (entry))
    dispose_command (function_cell (entry));

  if (value)
    var_setfunc (entry, copy_command (value));
  else
    var_setfunc (entry, 0);

  VSETATTR (entry, att_function);

  if (mark_modified_vars)
    VSETATTR (entry, att_exported);

  VUNSETATTR (entry, att_invisible);		/* Just to be sure */

  if (exported_p (entry))
    array_needs_making = 1;

#if defined (PROGRAMMABLE_COMPLETION)
  set_itemlist_dirty (&it_functions);
#endif

  return (entry);
}
warning: parse error {
  SHELL_VAR *entry;

  entry = find_function (name);
  if (entry == 0)
    {
      BUCKET_CONTENTS *elt;

      elt = hash_insert (savestring (name), shell_functions, HASH_NOSRCH);
      entry = new_shell_variable (name);
      elt->data = (PTR_T)entry;
    }
  else
    INVALIDATE_EXPORTSTR (entry);

  if (var_isset (entry))
    dispose_command (function_cell (entry));

  if (value)
    var_setfunc (entry, copy_command (value));
  else
    var_setfunc (entry, 0);

  VSETATTR (entry, att_function);

  if (mark_modified_vars)
    VSETATTR (entry, att_exported);

  VUNSETATTR (entry, att_invisible);		/* Just to be sure */

  if (exported_p (entry))
    array_needs_making = 1;

#if defined (PROGRAMMABLE_COMPLETION)
  set_itemlist_dirty (&it_functions);
#endif

  return (entry);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.c:2,414
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.c:2,490
parsing error 
{
  int offset;
  char *name, *temp, *value;
  SHELL_VAR *var;
  const char *string;

  string = word->word;

  offset = assignment (string, 0);
  name = savestring (string);
  value = (char *)NULL;

  if (name[offset] == '=')
    {
      name[offset] = 0;

      /* ignore the `+' when assigning temporary environment */
      if (name[offset - 1] == '+')
	name[offset - 1] = '\0';

      var = find_variable (name);
      if (var && (readonly_p (var) || noassign_p (var)))
	{
	  if (readonly_p (var))
	    err_readonly (name);
	  free (name);
  	  return (0);
	}

      temp = name + offset + 1;
      value = expand_assignment_string_to_string (temp, 0);
    }

  if (temporary_env == 0)
    temporary_env = hash_create (TEMPENV_HASH_BUCKETS);

  var = hash_lookup (name, temporary_env);
  if (var == 0)
    var = make_new_variable (name, temporary_env);
  else
    FREE (value_cell (var));

  if (value == 0)
    {
      value = (char *)xmalloc (1);	/* like do_assignment_internal */
      value[0] = '\0';
    }

  var_setvalue (var, value);
  var->attributes |= (att_exported|att_tempvar);
  var->context = variable_context;	/* XXX */

  INVALIDATE_EXPORTSTR (var);
  var->exportstr = mk_env_string (name, value);

  array_needs_making = 1;

#if 0
  if (ifsname (name))
    setifs (var);
else
#endif
  if (flags)
    stupidly_hack_special_variables (name);

  if (echo_command_at_execute)
    /* The Korn shell prints the `+ ' in front of assignment statements,
	so we do too. */
    xtrace_print_assignment (name, value, 0, 1);

  free (name);
  return 1;
}
warning: parse error {
  int offset;
  char *name, *temp, *value;
  SHELL_VAR *var;
  const char *string;

  string = word->word;

  offset = assignment (string, 0);
  name = savestring (string);
  value = (char *)NULL;

  if (name[offset] == '=')
    {
      name[offset] = 0;

      /* ignore the `+' when assigning temporary environment */
      if (name[offset - 1] == '+')
	name[offset - 1] = '\0';

      var = find_variable (name);
      if (var && (readonly_p (var) || noassign_p (var)))
	{
	  if (readonly_p (var))
	    err_readonly (name);
	  free (name);
  	  return (0);
	}

      temp = name + offset + 1;
      value = expand_assignment_string_to_string (temp, 0);
    }

  if (temporary_env == 0)
    temporary_env = hash_create (TEMPENV_HASH_BUCKETS);

  var = hash_lookup (name, temporary_env);
  if (var == 0)
    var = make_new_variable (name, temporary_env);
  else
    FREE (value_cell (var));

  if (value == 0)
    {
      value = (char *)xmalloc (1);	/* like do_assignment_internal */
      value[0] = '\0';
    }

  var_setvalue (var, value);
  var->attributes |= (att_exported|att_tempvar);
  var->context = variable_context;	/* XXX */

  INVALIDATE_EXPORTSTR (var);
  var->exportstr = mk_env_string (name, value);

  array_needs_making = 1;

#if 0
  if (ifsname (name))
    setifs (var);
else
#endif
  if (flags)
    stupidly_hack_special_variables (name);

  if (echo_command_at_execute)
    /* The Korn shell prints the `+ ' in front of assignment statements,
	so we do too. */
    xtrace_print_assignment (name, value, 0, 1);

  free (name);
  return 1;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.c:2,493
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.c:2,620
parsing error 
{
  if (function_p (var))
    dispose_command (function_cell (var));
#if defined (ARRAY_VARS)
  else if (array_p (var))
    array_dispose (array_cell (var));
  else if (assoc_p (var))
    assoc_dispose (assoc_cell (var));
#endif
  else
    FREE (value_cell (var));
}
warning: parse error {
  if (function_p (var))
    dispose_command (function_cell (var));
#if defined (ARRAY_VARS)
  else if (array_p (var))
    array_dispose (array_cell (var));
  else if (assoc_p (var))
    assoc_dispose (assoc_cell (var));
#endif
  else
    FREE (value_cell (var));
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.c:2,622
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.c:2,636
parsing error 
{
  if (var == 0)
    return;

  if (nofree_p (var) == 0)
    dispose_variable_value (var);

  FREE_EXPORTSTR (var);

  free (var->name);

  if (exported_p (var))
    array_needs_making = 1;

  free (var);
}
warning: parse error {
  if (var == 0)
    return;

  if (nofree_p (var) == 0)
    dispose_variable_value (var);

  FREE_EXPORTSTR (var);

  free (var->name);

  if (exported_p (var))
    array_needs_making = 1;

  free (var);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.c:2,638
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.c:2,658
parsing error 
{
  return makunbound (name, shell_variables);
}
warning: parse error {
  return makunbound (name, shell_variables);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.c:2,659
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.c:2,666
parsing error 
{
  BUCKET_CONTENTS *elt;
  SHELL_VAR *func;

  elt = hash_remove (name, shell_functions, 0);

  if (elt == 0)
    return -1;

#if defined (PROGRAMMABLE_COMPLETION)
  set_itemlist_dirty (&it_functions);
#endif

  func = (SHELL_VAR *)elt->data;
  if (func)
    {
      if (exported_p (func))
	array_needs_making++;
      dispose_variable (func);
    }

  free (elt->key);
  free (elt);

  return 0;  
}
warning: parse error {
  BUCKET_CONTENTS *elt;
  SHELL_VAR *func;

  elt = hash_remove (name, shell_functions, 0);

  if (elt == 0)
    return -1;

#if defined (PROGRAMMABLE_COMPLETION)
  set_itemlist_dirty (&it_functions);
#endif

  func = (SHELL_VAR *)elt->data;
  if (func)
    {
      if (exported_p (func))
	array_needs_making++;
      dispose_variable (func);
    }

  free (elt->key);
  free (elt);

  return 0;  
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.c:2,667
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.c:2,724
parsing error 
{
  BUCKET_CONTENTS *elt, *new_elt;
  SHELL_VAR *old_var;
  VAR_CONTEXT *v;
  char *t;

  for (elt = (BUCKET_CONTENTS *)NULL, v = vc; v; v = v->down)
    if (elt = hash_remove (name, v->table, 0))
      break;

  if (elt == 0)
    return (-1);

  old_var = (SHELL_VAR *)elt->data;

  if (old_var && exported_p (old_var))
    array_needs_making++;

  /* If we're unsetting a local variable and we're still executing inside
     the function, just mark the variable as invisible.  The function
     eventually called by pop_var_context() will clean it up later.  This
     must be done so that if the variable is subsequently assigned a new
     value inside the function, the `local' attribute is still present.
     We also need to add it back into the correct hash table. */
  if (old_var && local_p (old_var) && variable_context == old_var->context)
    {
      if (nofree_p (old_var))
	var_setvalue (old_var, (char *)NULL);
#if defined (ARRAY_VARS)
      else if (array_p (old_var))
	array_dispose (array_cell (old_var));
      else if (assoc_p (old_var))
	assoc_dispose (assoc_cell (old_var));
#endif
      else
	FREE (value_cell (old_var));
      /* Reset the attributes.  Preserve the export attribute if the variable
	 came from a temporary environment.  Make sure it stays local, and
	 make it invisible. */ 
      old_var->attributes = (exported_p (old_var) && tempvar_p (old_var)) ? att_exported : 0;
      VSETATTR (old_var, att_local);
      VSETATTR (old_var, att_invisible);
      var_setvalue (old_var, (char *)NULL);
      INVALIDATE_EXPORTSTR (old_var);

      new_elt = hash_insert (savestring (old_var->name), v->table, 0);
      new_elt->data = (PTR_T)old_var;
      stupidly_hack_special_variables (old_var->name);

      free (elt->key);
      free (elt);
      return (0);
    }

  /* Have to save a copy of name here, because it might refer to
     old_var->name.  If so, stupidly_hack_special_variables will
     reference freed memory. */
  t = savestring (name);

  free (elt->key);
  free (elt);

  dispose_variable (old_var);
  stupidly_hack_special_variables (t);
  free (t);

  return (0);
}
warning: parse error {
  BUCKET_CONTENTS *elt, *new_elt;
  SHELL_VAR *old_var;
  VAR_CONTEXT *v;
  char *t;

  for (elt = (BUCKET_CONTENTS *)NULL, v = vc; v; v = v->down)
    if (elt = hash_remove (name, v->table, 0))
      break;

  if (elt == 0)
    return (-1);

  old_var = (SHELL_VAR *)elt->data;

  if (old_var && exported_p (old_var))
    array_needs_making++;

  /* If we're unsetting a local variable and we're still executing inside
     the function, just mark the variable as invisible.  The function
     eventually called by pop_var_context() will clean it up later.  This
     must be done so that if the variable is subsequently assigned a new
     value inside the function, the `local' attribute is still present.
     We also need to add it back into the correct hash table. */
  if (old_var && local_p (old_var) && variable_context == old_var->context)
    {
      if (nofree_p (old_var))
	var_setvalue (old_var, (char *)NULL);
#if defined (ARRAY_VARS)
      else if (array_p (old_var))
	array_dispose (array_cell (old_var));
      else if (assoc_p (old_var))
	assoc_dispose (assoc_cell (old_var));
#endif
      else
	FREE (value_cell (old_var));
      /* Reset the attributes.  Preserve the export attribute if the variable
	 came from a temporary environment.  Make sure it stays local, and
	 make it invisible. */ 
      old_var->attributes = (exported_p (old_var) && tempvar_p (old_var)) ? att_exported : 0;
      VSETATTR (old_var, att_local);
      VSETATTR (old_var, att_invisible);
      var_setvalue (old_var, (char *)NULL);
      INVALIDATE_EXPORTSTR (old_var);

      new_elt = hash_insert (savestring (old_var->name), v->table, 0);
      new_elt->data = (PTR_T)old_var;
      stupidly_hack_special_variables (old_var->name);

      free (elt->key);
      free (elt);
      return (0);
    }

  /* Have to save a copy of name here, because it might refer to
     old_var->name.  If so, stupidly_hack_special_variables will
     reference freed memory. */
  t = savestring (name);

  free (elt->key);
  free (elt);

  dispose_variable (old_var);
  stupidly_hack_special_variables (t);
  free (t);

  return (0);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.c:2,726
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.c:2,816
parsing error 
{
  SHELL_VAR *var;

  var = (SHELL_VAR *)data;
  dispose_variable (var);
}
warning: parse error {
  SHELL_VAR *var;

  var = (SHELL_VAR *)data;
  dispose_variable (var);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.c:2,818
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.c:2,827
parsing error 
{
  hash_flush (hashed_vars, free_variable_hash_data);
}
warning: parse error {
  hash_flush (hashed_vars, free_variable_hash_data);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.c:2,829
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.c:2,854
parsing error 
{
  SHELL_VAR *entry;

  FIND_OR_MAKE_VARIABLE (name, entry);
  VSETATTR (entry, att_readonly);
}
warning: parse error {
  SHELL_VAR *entry;

  FIND_OR_MAKE_VARIABLE (name, entry);
  VSETATTR (entry, att_readonly);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.c:2,856
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.c:2,909
parsing error 
{
  VARLIST  *vlist;

  vlist = (VARLIST *)xmalloc (sizeof (VARLIST));
  vlist->list = (SHELL_VAR **)xmalloc ((nentries + 1) * sizeof (SHELL_VAR *));
  vlist->list_size = nentries;
  vlist->list_len = 0;
  vlist->list[0] = (SHELL_VAR *)NULL;

  return vlist;
}
warning: parse error {
  VARLIST  *vlist;

  vlist = (VARLIST *)xmalloc (sizeof (VARLIST));
  vlist->list = (SHELL_VAR **)xmalloc ((nentries + 1) * sizeof (SHELL_VAR *));
  vlist->list_size = nentries;
  vlist->list_len = 0;
  vlist->list[0] = (SHELL_VAR *)NULL;

  return vlist;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.c:2,911
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.c:2,924
parsing error 
{
  if (vlist == 0)
    return (vlist = vlist_alloc (n));
  if (n > vlist->list_size)
    {
      vlist->list_size = n;
      vlist->list = (SHELL_VAR **)xrealloc (vlist->list, (vlist->list_size + 1) * sizeof (SHELL_VAR *));
    }
  return vlist;
}
warning: parse error {
  if (vlist == 0)
    return (vlist = vlist_alloc (n));
  if (n > vlist->list_size)
    {
      vlist->list_size = n;
      vlist->list = (SHELL_VAR **)xrealloc (vlist->list, (vlist->list_size + 1) * sizeof (SHELL_VAR *));
    }
  return vlist;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.c:2,927
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.c:2,939
parsing error 
{
  register int i;

  for (i = 0; i < vlist->list_len; i++)
    if (STREQ (var->name, vlist->list[i]->name))
      break;
  if (i < vlist->list_len)
    return;

  if (i >= vlist->list_size)
    vlist = vlist_realloc (vlist, vlist->list_size + 16);

  vlist->list[vlist->list_len++] = var;
  vlist->list[vlist->list_len] = (SHELL_VAR *)NULL;
}
warning: parse error {
  register int i;

  for (i = 0; i < vlist->list_len; i++)
    if (STREQ (var->name, vlist->list[i]->name))
      break;
  if (i < vlist->list_len)
    return;

  if (i >= vlist->list_size)
    vlist = vlist_realloc (vlist, vlist->list_size + 16);

  vlist->list[vlist->list_len++] = var;
  vlist->list[vlist->list_len] = (SHELL_VAR *)NULL;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.c:2,943
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.c:2,963
parsing error 
{
  VAR_CONTEXT *v;
  VARLIST *vlist;
  SHELL_VAR **ret;
  int nentries;

  for (nentries = 0, v = vc; v; v = v->down)
    nentries += HASH_ENTRIES (v->table);

  if (nentries == 0)
    return (SHELL_VAR **)NULL;

  vlist = vlist_alloc (nentries);

  for (v = vc; v; v = v->down)
    flatten (v->table, function, vlist, 0);

  ret = vlist->list;
  free (vlist);
  return ret;
}
warning: parse error {
  VAR_CONTEXT *v;
  VARLIST *vlist;
  SHELL_VAR **ret;
  int nentries;

  for (nentries = 0, v = vc; v; v = v->down)
    nentries += HASH_ENTRIES (v->table);

  if (nentries == 0)
    return (SHELL_VAR **)NULL;

  vlist = vlist_alloc (nentries);

  for (v = vc; v; v = v->down)
    flatten (v->table, function, vlist, 0);

  ret = vlist->list;
  free (vlist);
  return ret;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.c:2,966
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.c:2,989
parsing error 
{
  VARLIST *vlist;
  SHELL_VAR **ret;

  if (shell_functions == 0 || HASH_ENTRIES (shell_functions) == 0)
    return ((SHELL_VAR **)NULL);

  vlist = vlist_alloc (HASH_ENTRIES (shell_functions));

  flatten (shell_functions, function, vlist, 0);

  ret = vlist->list;
  free (vlist);
  return ret;
}
warning: parse error {
  VARLIST *vlist;
  SHELL_VAR **ret;

  if (shell_functions == 0 || HASH_ENTRIES (shell_functions) == 0)
    return ((SHELL_VAR **)NULL);

  vlist = vlist_alloc (HASH_ENTRIES (shell_functions));

  flatten (shell_functions, function, vlist, 0);

  ret = vlist->list;
  free (vlist);
  return ret;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.c:2,991
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.c:3,014
parsing error 
{
  register int i;
  register BUCKET_CONTENTS *tlist;
  int r;
  SHELL_VAR *var;

  if (var_hash_table == 0 || (HASH_ENTRIES (var_hash_table) == 0) || (vlist == 0 && func == 0))
    return;

  for (i = 0; i < var_hash_table->nbuckets; i++)
    {
      for (tlist = hash_items (i, var_hash_table); tlist; tlist = tlist->next)
	{
	  var = (SHELL_VAR *)tlist->data;

	  r = func ? (*func) (var) : 1;
	  if (r && vlist)
	    vlist_add (vlist, var, flags);
	}
    }
}
warning: parse error {
  register int i;
  register BUCKET_CONTENTS *tlist;
  int r;
  SHELL_VAR *var;

  if (var_hash_table == 0 || (HASH_ENTRIES (var_hash_table) == 0) || (vlist == 0 && func == 0))
    return;

  for (i = 0; i < var_hash_table->nbuckets; i++)
    {
      for (tlist = hash_items (i, var_hash_table); tlist; tlist = tlist->next)
	{
	  var = (SHELL_VAR *)tlist->data;

	  r = func ? (*func) (var) : 1;
	  if (r && vlist)
	    vlist_add (vlist, var, flags);
	}
    }
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.c:3,019
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.c:3,042
parsing error 
{
  qsort (array, strvec_len ((char **)array), sizeof (SHELL_VAR *), (QSFUNC *)qsort_var_comp);
}
warning: parse error {
  qsort (array, strvec_len ((char **)array), sizeof (SHELL_VAR *), (QSFUNC *)qsort_var_comp);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.c:3,044
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.c:3,049
parsing error 
{
  int result;

  if ((result = (*var1)->name[0] - (*var2)->name[0]) == 0)
    result = strcmp ((*var1)->name, (*var2)->name);

  return (result);
}
warning: parse error {
  int result;

  if ((result = (*var1)->name[0] - (*var2)->name[0]) == 0)
    result = strcmp ((*var1)->name, (*var2)->name);

  return (result);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.c:3,051
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.c:3,063
parsing error 
{
  SHELL_VAR **list;

  list = map_over (func, shell_variables);
  if (list /* && posixly_correct */)
    sort_variables (list);
  return (list);
}
warning: parse error {
  SHELL_VAR **list;

  list = map_over (func, shell_variables);
  if (list /* && posixly_correct */)
    sort_variables (list);
  return (list);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.c:3,065
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.c:3,077
parsing error 
{
  SHELL_VAR **list;

  list = map_over_funcs (func);
  if (list /* && posixly_correct */)
    sort_variables (list);
  return (list);
}
warning: parse error {
  SHELL_VAR **list;

  list = map_over_funcs (func);
  if (list /* && posixly_correct */)
    sort_variables (list);
  return (list);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.c:3,079
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.c:3,103
parsing error 
{
  return (invisible_p (var) == 0);
}
warning: parse error {
  return (invisible_p (var) == 0);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.c:3,105
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.c:3,124
parsing error 
{
  return (invisible_p (var) == 0 && exported_p (var));
}
warning: parse error {
  return (invisible_p (var) == 0 && exported_p (var));
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.c:3,126
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.c:3,134
parsing error 
{
  return (exported_p (var) && (invisible_p (var) == 0 || imported_p (var)));
}
warning: parse error {
  return (exported_p (var) && (invisible_p (var) == 0 || imported_p (var)));
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.c:3,136
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.c:3,143
parsing error 
{
  return (invisible_p (var) == 0 && local_p (var) && var->context == variable_context && exported_p (var));
}
warning: parse error {
  return (invisible_p (var) == 0 && local_p (var) && var->context == variable_context && exported_p (var));
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.c:3,145
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.c:3,162
parsing error 
{
  return (invisible_p (var) == 0 && local_p (var) && var->context == variable_context);
}
warning: parse error {
  return (invisible_p (var) == 0 && local_p (var) && var->context == variable_context);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.c:3,164
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.c:3,217
parsing error 
{
  SHELL_VAR **varlist;
  char **rlist;
  int vind, rind, plen;

  plen = STRLEN (prefix);
  varlist = all_visible_variables ();
  for (vind = 0; varlist && varlist[vind]; vind++)
    ;
  if (varlist == 0 || vind == 0)
    return ((char **)NULL);
  rlist = strvec_create (vind + 1);
  for (vind = rind = 0; varlist[vind]; vind++)
    {
      if (plen == 0 || STREQN (prefix, varlist[vind]->name, plen))
	rlist[rind++] = savestring (varlist[vind]->name);
    }
  rlist[rind] = (char *)0;
  free (varlist);

  return rlist;
}
warning: parse error {
  SHELL_VAR **varlist;
  char **rlist;
  int vind, rind, plen;

  plen = STRLEN (prefix);
  varlist = all_visible_variables ();
  for (vind = 0; varlist && varlist[vind]; vind++)
    ;
  if (varlist == 0 || vind == 0)
    return ((char **)NULL);
  rlist = strvec_create (vind + 1);
  for (vind = rind = 0; varlist[vind]; vind++)
    {
      if (plen == 0 || STREQN (prefix, varlist[vind]->name, plen))
	rlist[rind++] = savestring (varlist[vind]->name);
    }
  rlist[rind] = (char *)0;
  free (varlist);

  return rlist;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.c:3,218
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.c:3,250
parsing error 
{
  SHELL_VAR *var;

  var = temporary_env ? hash_lookup (name, temporary_env) : (SHELL_VAR *)NULL;

  if (var)
    {
      FREE (value_cell (var));
      var_setvalue (var, savestring (value));
      INVALIDATE_EXPORTSTR (var);
    }

  return (var);
}
warning: parse error {
  SHELL_VAR *var;

  var = temporary_env ? hash_lookup (name, temporary_env) : (SHELL_VAR *)NULL;

  if (var)
    {
      FREE (value_cell (var));
      var_setvalue (var, savestring (value));
      INVALIDATE_EXPORTSTR (var);
    }

  return (var);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.c:3,252
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.c:3,271
parsing error 
{
  return (temporary_env ? hash_lookup (name, temporary_env) : (SHELL_VAR *)NULL);
}
warning: parse error {
  return (temporary_env ? hash_lookup (name, temporary_env) : (SHELL_VAR *)NULL);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.c:3,272
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.c:3,282
parsing error 
{
  SHELL_VAR *var, *v;
  HASH_TABLE *binding_table;

  var = (SHELL_VAR *)data;

  binding_table = shell_variables->table;
  if (binding_table == 0)
    {
      if (shell_variables == global_variables)
	/* shouldn't happen */
	binding_table = shell_variables->table = global_variables->table = hash_create (0);
      else
	binding_table = shell_variables->table = hash_create (TEMPENV_HASH_BUCKETS);
    }

  v = bind_variable_internal (var->name, value_cell (var), binding_table, 0, 0);

  /* XXX - should we set the context here?  It shouldn't matter because of how
     assign_in_env works, but might want to check. */
  if (binding_table == global_variables->table)		/* XXX */
    var->attributes &= ~(att_tempvar|att_propagate);
  else
    {
      var->attributes |= att_propagate;
      if  (binding_table == shell_variables->table)
	shell_variables->flags |= VC_HASTMPVAR;
    }
  v->attributes |= var->attributes;

  if (find_special_var (var->name) >= 0)
    tempvar_list[tvlist_ind++] = savestring (var->name);

  dispose_variable (var);
}
warning: parse error {
  SHELL_VAR *var, *v;
  HASH_TABLE *binding_table;

  var = (SHELL_VAR *)data;

  binding_table = shell_variables->table;
  if (binding_table == 0)
    {
      if (shell_variables == global_variables)
	/* shouldn't happen */
	binding_table = shell_variables->table = global_variables->table = hash_create (0);
      else
	binding_table = shell_variables->table = hash_create (TEMPENV_HASH_BUCKETS);
    }

  v = bind_variable_internal (var->name, value_cell (var), binding_table, 0, 0);

  /* XXX - should we set the context here?  It shouldn't matter because of how
     assign_in_env works, but might want to check. */
  if (binding_table == global_variables->table)		/* XXX */
    var->attributes &= ~(att_tempvar|att_propagate);
  else
    {
      var->attributes |= att_propagate;
      if  (binding_table == shell_variables->table)
	shell_variables->flags |= VC_HASTMPVAR;
    }
  v->attributes |= var->attributes;

  if (find_special_var (var->name) >= 0)
    tempvar_list[tvlist_ind++] = savestring (var->name);

  dispose_variable (var);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.c:3,284
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.c:3,321
parsing error 
{
  SHELL_VAR *var;

  var = (SHELL_VAR *)data;
  if (tempvar_p (var) && (var->attributes & att_propagate))
    push_temp_var (data);
  else
    {
      if (find_special_var (var->name) >= 0)
	tempvar_list[tvlist_ind++] = savestring (var->name);
      dispose_variable (var);
    }
}
warning: parse error {
  SHELL_VAR *var;

  var = (SHELL_VAR *)data;
  if (tempvar_p (var) && (var->attributes & att_propagate))
    push_temp_var (data);
  else
    {
      if (find_special_var (var->name) >= 0)
	tempvar_list[tvlist_ind++] = savestring (var->name);
      dispose_variable (var);
    }
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.c:3,323
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.c:3,345
parsing error 
{
  int i;

  tempvar_list = strvec_create (HASH_ENTRIES (temporary_env) + 1);
  tempvar_list[tvlist_ind = 0] = 0;
    
  hash_flush (temporary_env, pushf);
  hash_dispose (temporary_env);
  temporary_env = (HASH_TABLE *)NULL;

  tempvar_list[tvlist_ind] = 0;

  array_needs_making = 1;

#if 0
  sv_ifs ("IFS");		/* XXX here for now -- check setifs in assign_in_env */  
#endif
  for (i = 0; i < tvlist_ind; i++)
    stupidly_hack_special_variables (tempvar_list[i]);

  strvec_dispose (tempvar_list);
  tempvar_list = 0;
  tvlist_ind = 0;
}
warning: parse error {
  int i;

  tempvar_list = strvec_create (HASH_ENTRIES (temporary_env) + 1);
  tempvar_list[tvlist_ind = 0] = 0;
    
  hash_flush (temporary_env, pushf);
  hash_dispose (temporary_env);
  temporary_env = (HASH_TABLE *)NULL;

  tempvar_list[tvlist_ind] = 0;

  array_needs_making = 1;

#if 0
  sv_ifs ("IFS");		/* XXX here for now -- check setifs in assign_in_env */  
#endif
  for (i = 0; i < tvlist_ind; i++)
    stupidly_hack_special_variables (tempvar_list[i]);

  strvec_dispose (tempvar_list);
  tempvar_list = 0;
  tvlist_ind = 0;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.c:3,347
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.c:3,399
parsing error 
{
  int name_len, value_len;
  char	*p;

  name_len = strlen (name);
  value_len = STRLEN (value);
  p = (char *)xmalloc (2 + name_len + value_len);
  strcpy (p, name);
  p[name_len] = '=';
  if (value && *value)
    strcpy (p + name_len + 1, value);
  else
    p[name_len + 1] = '\0';
  return (p);
}
warning: parse error {
  int name_len, value_len;
  char	*p;

  name_len = strlen (name);
  value_len = STRLEN (value);
  p = (char *)xmalloc (2 + name_len + value_len);
  strcpy (p, name);
  p[name_len] = '=';
  if (value && *value)
    strcpy (p + name_len + 1, value);
  else
    p[name_len + 1] = '\0';
  return (p);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.c:3,400
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.c:3,455
parsing error 
{
  register int i, list_index;
  register SHELL_VAR *var;
  char **list, *value;

  list = strvec_create ((1 + strvec_len ((char **)vars)));

#define USE_EXPORTSTR (value == var->exportstr)

  for (i = 0, list_index = 0; var = vars[i]; i++)
    {
#if defined (__CYGWIN__)
      /* We don't use the exportstr stuff on Cygwin at all. */
      INVALIDATE_EXPORTSTR (var);
#endif
      if (var->exportstr)
	value = var->exportstr;
      else if (function_p (var))
	value = named_function_string ((char *)NULL, function_cell (var), 0);
#if defined (ARRAY_VARS)
      else if (array_p (var))
#  if 0
	value = array_to_assignment_string (array_cell (var));
#  else
	continue;	/* XXX array vars cannot yet be exported */
#  endif
      else if (assoc_p (var))
#  if 0
	value = assoc_to_assignment_string (assoc_cell (var));
#  else
	continue;	/* XXX associative array vars cannot yet be exported */
#  endif
#endif
      else
	value = value_cell (var);

      if (value)
	{
	  /* Gee, I'd like to get away with not using savestring() if we're
	     using the cached exportstr... */
	  list[list_index] = USE_EXPORTSTR ? savestring (value)
					   : mk_env_string (var->name, value);

	  if (USE_EXPORTSTR == 0)
	    SAVE_EXPORTSTR (var, list[list_index]);

	  list_index++;
#undef USE_EXPORTSTR

#if 0	/* not yet */
#if defined (ARRAY_VARS)
	  if (array_p (var) || assoc_p (var))
	    free (value);
#endif
#endif
	}
    }

  list[list_index] = (char *)NULL;
  return (list);
}
warning: parse error {
  register int i, list_index;
  register SHELL_VAR *var;
  char **list, *value;

  list = strvec_create ((1 + strvec_len ((char **)vars)));

#define USE_EXPORTSTR (value == var->exportstr)

  for (i = 0, list_index = 0; var = vars[i]; i++)
    {
#if defined (__CYGWIN__)
      /* We don't use the exportstr stuff on Cygwin at all. */
      INVALIDATE_EXPORTSTR (var);
#endif
      if (var->exportstr)
	value = var->exportstr;
      else if (function_p (var))
	value = named_function_string ((char *)NULL, function_cell (var), 0);
#if defined (ARRAY_VARS)
      else if (array_p (var))
#  if 0
	value = array_to_assignment_string (array_cell (var));
#  else
	continue;	/* XXX array vars cannot yet be exported */
#  endif
      else if (assoc_p (var))
#  if 0
	value = assoc_to_assignment_string (assoc_cell (var));
#  else
	continue;	/* XXX associative array vars cannot yet be exported */
#  endif
#endif
      else
	value = value_cell (var);

      if (value)
	{
	  /* Gee, I'd like to get away with not using savestring() if we're
	     using the cached exportstr... */
	  list[list_index] = USE_EXPORTSTR ? savestring (value)
					   : mk_env_string (var->name, value);

	  if (USE_EXPORTSTR == 0)
	    SAVE_EXPORTSTR (var, list[list_index]);

	  list_index++;
#undef USE_EXPORTSTR

#if 0	/* not yet */
#if defined (ARRAY_VARS)
	  if (array_p (var) || assoc_p (var))
	    free (value);
#endif
#endif
	}
    }

  list[list_index] = (char *)NULL;
  return (list);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.c:3,457
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.c:3,523
parsing error 
{
  char **list;
  SHELL_VAR **vars;

#if 0
  vars = map_over (visible_and_exported, vcxt);
#else
  vars = map_over (export_environment_candidate, vcxt);
#endif

  if (vars == 0)
    return (char **)NULL;

  list = make_env_array_from_var_list (vars);

  free (vars);
  return (list);
}
warning: parse error {
  char **list;
  SHELL_VAR **vars;

#if 0
  vars = map_over (visible_and_exported, vcxt);
#else
  vars = map_over (export_environment_candidate, vcxt);
#endif

  if (vars == 0)
    return (char **)NULL;

  list = make_env_array_from_var_list (vars);

  free (vars);
  return (list);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.c:3,525
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.c:3,577
parsing error 
{
  register int i;
  int equal_offset;

  equal_offset = assignment (assign, 0);
  if (equal_offset == 0)
    return (export_env);

  /* If this is a function, then only supersede the function definition.
     We do this by including the `=() {' in the comparison, like
     initialize_shell_variables does. */
  if (assign[equal_offset + 1] == '(' &&
     strncmp (assign + equal_offset + 2, ") {", 3) == 0)		/* } */
    equal_offset += 4;

  for (i = 0; i < export_env_index; i++)
    {
      if (STREQN (assign, export_env[i], equal_offset + 1))
	{
	  free (export_env[i]);
	  export_env[i] = do_alloc ? savestring (assign) : assign;
	  return (export_env);
	}
    }
  add_to_export_env (assign, do_alloc);
  return (export_env);
}
warning: parse error {
  register int i;
  int equal_offset;

  equal_offset = assignment (assign, 0);
  if (equal_offset == 0)
    return (export_env);

  /* If this is a function, then only supersede the function definition.
     We do this by including the `=() {' in the comparison, like
     initialize_shell_variables does. */
  if (assign[equal_offset + 1] == '(' &&
     strncmp (assign + equal_offset + 2, ") {", 3) == 0)		/* } */
    equal_offset += 4;

  for (i = 0; i < export_env_index; i++)
    {
      if (STREQN (assign, export_env[i], equal_offset + 1))
	{
	  free (export_env[i]);
	  export_env[i] = do_alloc ? savestring (assign) : assign;
	  return (export_env);
	}
    }
  add_to_export_env (assign, do_alloc);
  return (export_env);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.c:3,580
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.c:3,609
parsing error 
{
  register int i;

  if (temp_array == 0)
    return;

  for (i = 0; temp_array[i]; i++)
    {
      if (do_supercede)
	export_env = add_or_supercede_exported_var (temp_array[i], do_alloc);
      else
	add_to_export_env (temp_array[i], do_alloc);
    }

  free (temp_array);
}
warning: parse error {
  register int i;

  if (temp_array == 0)
    return;

  for (i = 0; temp_array[i]; i++)
    {
      if (do_supercede)
	export_env = add_or_supercede_exported_var (temp_array[i], do_alloc);
      else
	add_to_export_env (temp_array[i], do_alloc);
    }

  free (temp_array);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.c:3,612
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.c:3,725
parsing error 
{
  char *evar;

  evar = (char *)xmalloc (STRLEN (value) + preflen + 1);
  strcpy (evar, env_prefix);
  if (value)
    strcpy (evar + preflen, value);
  export_env = add_or_supercede_exported_var (evar, 0);
}
warning: parse error {
  char *evar;

  evar = (char *)xmalloc (STRLEN (value) + preflen + 1);
  strcpy (evar, env_prefix);
  if (value)
    strcpy (evar + preflen, value);
  export_env = add_or_supercede_exported_var (evar, 0);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.c:3,729
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.c:3,741
parsing error 
{
  update_export_env_inplace ("_=", 2, command_name);
}
warning: parse error {
  update_export_env_inplace ("_=", 2, command_name);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.c:3,743
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.c:3,784
parsing error 
{
  VAR_CONTEXT *vc;

  vc = (VAR_CONTEXT *)xmalloc (sizeof (VAR_CONTEXT));
  vc->name = name ? savestring (name) : (char *)NULL;
  vc->scope = variable_context;
  vc->flags = flags;

  vc->up = vc->down = (VAR_CONTEXT *)NULL;
  vc->table = (HASH_TABLE *)NULL;

  return vc;
}
warning: parse error {
  VAR_CONTEXT *vc;

  vc = (VAR_CONTEXT *)xmalloc (sizeof (VAR_CONTEXT));
  vc->name = name ? savestring (name) : (char *)NULL;
  vc->scope = variable_context;
  vc->flags = flags;

  vc->up = vc->down = (VAR_CONTEXT *)NULL;
  vc->table = (HASH_TABLE *)NULL;

  return vc;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.c:3,787
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.c:3,804
parsing error 
{
  FREE (vc->name);

  if (vc->table)
    {
      delete_all_variables (vc->table);
      hash_dispose (vc->table);
    }

  free (vc);
}
warning: parse error {
  FREE (vc->name);

  if (vc->table)
    {
      delete_all_variables (vc->table);
      hash_dispose (vc->table);
    }

  free (vc);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.c:3,806
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.c:3,820
parsing error 
{
  return (var->context = variable_context);
}
warning: parse error {
  return (var->context = variable_context);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.c:3,822
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.c:3,830
parsing error 
{
  VAR_CONTEXT *vc;

  vc = new_var_context (name, flags);
  vc->table = tempvars;
  if (tempvars)
    {
      /* Have to do this because the temp environment was created before
	 variable_context was incremented. */
      flatten (tempvars, set_context, (VARLIST *)NULL, 0);
      vc->flags |= VC_HASTMPVAR;
    }
  vc->down = shell_variables;
  shell_variables->up = vc;

  return (shell_variables = vc);
}
warning: parse error {
  VAR_CONTEXT *vc;

  vc = new_var_context (name, flags);
  vc->table = tempvars;
  if (tempvars)
    {
      /* Have to do this because the temp environment was created before
	 variable_context was incremented. */
      flatten (tempvars, set_context, (VARLIST *)NULL, 0);
      vc->flags |= VC_HASTMPVAR;
    }
  vc->down = shell_variables;
  shell_variables->up = vc;

  return (shell_variables = vc);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.c:3,834
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.c:3,853
parsing error 
{
  SHELL_VAR *var, *v;

  var = (SHELL_VAR *)data;

  if (tempvar_p (var) && (posixly_correct || (var->attributes & att_propagate)))
    {
      /* Make sure we have a hash table to store the variable in while it is
	 being propagated down to the global variables table.  Create one if
	 we have to */
      if ((vc_isfuncenv (shell_variables) || vc_istempenv (shell_variables)) && shell_variables->table == 0)
	shell_variables->table = hash_create (0);
      /* XXX - should we set v->context here? */
      v = bind_variable_internal (var->name, value_cell (var), shell_variables->table, 0, 0);
      if (shell_variables == global_variables)
	var->attributes &= ~(att_tempvar|att_propagate);
      else
	shell_variables->flags |= VC_HASTMPVAR;
      v->attributes |= var->attributes;
    }
  else
    stupidly_hack_special_variables (var->name);	/* XXX */

  dispose_variable (var);
}
warning: parse error {
  SHELL_VAR *var, *v;

  var = (SHELL_VAR *)data;

  if (tempvar_p (var) && (posixly_correct || (var->attributes & att_propagate)))
    {
      /* Make sure we have a hash table to store the variable in while it is
	 being propagated down to the global variables table.  Create one if
	 we have to */
      if ((vc_isfuncenv (shell_variables) || vc_istempenv (shell_variables)) && shell_variables->table == 0)
	shell_variables->table = hash_create (0);
      /* XXX - should we set v->context here? */
      v = bind_variable_internal (var->name, value_cell (var), shell_variables->table, 0, 0);
      if (shell_variables == global_variables)
	var->attributes &= ~(att_tempvar|att_propagate);
      else
	shell_variables->flags |= VC_HASTMPVAR;
      v->attributes |= var->attributes;
    }
  else
    stupidly_hack_special_variables (var->name);	/* XXX */

  dispose_variable (var);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.c:3,855
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.c:3,910
parsing error 
{
  VAR_CONTEXT *v, *t;

  for (v = vcxt; v != global_variables; v = t)
    {
      t = v->down;
      dispose_var_context (v);
    }    

  delete_all_variables (global_variables->table);
  shell_variables = global_variables;
}
warning: parse error {
  VAR_CONTEXT *v, *t;

  for (v = vcxt; v != global_variables; v = t)
    {
      t = v->down;
      dispose_var_context (v);
    }    

  delete_all_variables (global_variables->table);
  shell_variables = global_variables;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.c:3,912
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.c:3,932
parsing error 
{
  return (push_var_context ((char *)NULL, flags, tmpvars));
}
warning: parse error {
  return (push_var_context ((char *)NULL, flags, tmpvars));
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.c:3,935
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.c:3,940
parsing error 
{
  SHELL_VAR *var, *v;

  var = (SHELL_VAR *)data;

  /* If a temp var had its export attribute set, or it's marked to be
     propagated, bind it in the previous scope before disposing it. */
  /* XXX - This isn't exactly right, because all tempenv variables have the
    export attribute set. */
#if 0
  if (exported_p (var) || (var->attributes & att_propagate))
#else
  if (tempvar_p (var) && exported_p (var) && (var->attributes & att_propagate))
#endif
    {
      var->attributes &= ~att_tempvar;		/* XXX */
      v = bind_variable_internal (var->name, value_cell (var), shell_variables->table, 0, 0);
      if (shell_variables == global_variables)
	var->attributes &= ~att_propagate;
      v->attributes |= var->attributes;
    }
  else
    stupidly_hack_special_variables (var->name);	/* XXX */

  dispose_variable (var);
}
warning: parse error {
  SHELL_VAR *var, *v;

  var = (SHELL_VAR *)data;

  /* If a temp var had its export attribute set, or it's marked to be
     propagated, bind it in the previous scope before disposing it. */
  /* XXX - This isn't exactly right, because all tempenv variables have the
    export attribute set. */
#if 0
  if (exported_p (var) || (var->attributes & att_propagate))
#else
  if (tempvar_p (var) && exported_p (var) && (var->attributes & att_propagate))
#endif
    {
      var->attributes &= ~att_tempvar;		/* XXX */
      v = bind_variable_internal (var->name, value_cell (var), shell_variables->table, 0, 0);
      if (shell_variables == global_variables)
	var->attributes &= ~att_propagate;
      v->attributes |= var->attributes;
    }
  else
    stupidly_hack_special_variables (var->name);	/* XXX */

  dispose_variable (var);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.c:3,942
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.c:3,970
parsing error 
{
  VAR_CONTEXT *vcxt, *ret;

  vcxt = shell_variables;
  if (vc_istempscope (vcxt) == 0)
    {
      internal_error (_("pop_scope: head of shell_variables not a temporary environment scope"));
      return;
    }

  ret = vcxt->down;
  if (ret)
    ret->up = (VAR_CONTEXT *)NULL;

  shell_variables = ret;

  /* Now we can take care of merging variables in VCXT into set of scopes
     whose head is RET (shell_variables). */
  FREE (vcxt->name);
  if (vcxt->table)
    {
      if (is_special)
	hash_flush (vcxt->table, push_func_var);
      else
	hash_flush (vcxt->table, push_exported_var);
      hash_dispose (vcxt->table);
    }
  free (vcxt);

  sv_ifs ("IFS");	/* XXX here for now */
}
warning: parse error {
  VAR_CONTEXT *vcxt, *ret;

  vcxt = shell_variables;
  if (vc_istempscope (vcxt) == 0)
    {
      internal_error (_("pop_scope: head of shell_variables not a temporary environment scope"));
      return;
    }

  ret = vcxt->down;
  if (ret)
    ret->up = (VAR_CONTEXT *)NULL;

  shell_variables = ret;

  /* Now we can take care of merging variables in VCXT into set of scopes
     whose head is RET (shell_variables). */
  FREE (vcxt->name);
  if (vcxt->table)
    {
      if (is_special)
	hash_flush (vcxt->table, push_func_var);
      else
	hash_flush (vcxt->table, push_exported_var);
      hash_dispose (vcxt->table);
    }
  free (vcxt);

  sv_ifs ("IFS");	/* XXX here for now */
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.c:3,972
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.c:4,017
parsing error 
{
  if (is_subshell == 0)
    push_dollar_vars ();
  variable_context++;
  push_var_context (name, VC_FUNCENV, tempvars);
}
warning: parse error {
  if (is_subshell == 0)
    push_dollar_vars ();
  variable_context++;
  push_var_context (name, VC_FUNCENV, tempvars);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.c:4,021
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.c:4,080
parsing error 
{
#if defined (ARRAY_VARS) && defined (DEBUGGER)
  SHELL_VAR *bash_argv_v, *bash_argc_v;
  ARRAY *bash_argv_a, *bash_argc_a;
  WORD_LIST *l;
  arrayind_t i;
  char *t;

  GET_ARRAY_FROM_VAR ("BASH_ARGV", bash_argv_v, bash_argv_a);
  GET_ARRAY_FROM_VAR ("BASH_ARGC", bash_argc_v, bash_argc_a);

  for (l = list, i = 0; l; l = l->next, i++)
    array_push (bash_argv_a, l->word->word);

  t = itos (i);
  array_push (bash_argc_a, t);
  free (t);
#endif /* ARRAY_VARS && DEBUGGER */
}
warning: parse error {
#if defined (ARRAY_VARS) && defined (DEBUGGER)
  SHELL_VAR *bash_argv_v, *bash_argc_v;
  ARRAY *bash_argv_a, *bash_argc_a;
  WORD_LIST *l;
  arrayind_t i;
  char *t;

  GET_ARRAY_FROM_VAR ("BASH_ARGV", bash_argv_v, bash_argv_a);
  GET_ARRAY_FROM_VAR ("BASH_ARGC", bash_argc_v, bash_argc_a);

  for (l = list, i = 0; l; l = l->next, i++)
    array_push (bash_argv_a, l->word->word);

  t = itos (i);
  array_push (bash_argc_a, t);
  free (t);
#endif /* ARRAY_VARS && DEBUGGER */
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.c:4,082
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.c:4,233
parsing error 
{
  int r;

  if ((r = sv1->name[0] - sv2->name[0]) == 0)
    r = strcmp (sv1->name, sv2->name);
  return r;
}
warning: parse error {
  int r;

  if ((r = sv1->name[0] - sv2->name[0]) == 0)
    r = strcmp (sv1->name, sv2->name);
  return r;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.c:4,235
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.c:4,245
parsing error 
{
  register int i, r;

  for (i = 0; special_vars[i].name; i++)
    {
      r = special_vars[i].name[0] - name[0];
      if (r == 0)
	r = strcmp (special_vars[i].name, name);
      if (r == 0)
	return i;
      else if (r > 0)
	/* Can't match any of rest of elements in sorted list.  Take this out
	   if it causes problems in certain environments. */
	break;
    }
  return -1;
}
warning: parse error {
  register int i, r;

  for (i = 0; special_vars[i].name; i++)
    {
      r = special_vars[i].name[0] - name[0];
      if (r == 0)
	r = strcmp (special_vars[i].name, name);
      if (r == 0)
	return i;
      else if (r > 0)
	/* Can't match any of rest of elements in sorted list.  Take this out
	   if it causes problems in certain environments. */
	break;
    }
  return -1;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.c:4,246
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.c:4,267
parsing error 
{
  static int sv_sorted = 0;
  int i;

  if (sv_sorted == 0)	/* shouldn't need, but it's fairly cheap. */
    {
      qsort (special_vars, N_SPECIAL_VARS, sizeof (special_vars[0]),
		(QSFUNC *)sv_compare);
      sv_sorted = 1;
    }

  i = find_special_var (name);
  if (i != -1)
    (*(special_vars[i].function)) (name);
}
warning: parse error {
  static int sv_sorted = 0;
  int i;

  if (sv_sorted == 0)	/* shouldn't need, but it's fairly cheap. */
    {
      qsort (special_vars, N_SPECIAL_VARS, sizeof (special_vars[0]),
		(QSFUNC *)sv_compare);
      sv_sorted = 1;
    }

  i = find_special_var (name);
  if (i != -1)
    (*(special_vars[i].function)) (name);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.c:4,269
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.c:4,298
parsing error 
{
  SHELL_VAR *v;

  v = find_variable ("IFS");
  setifs (v);
}
warning: parse error {
  SHELL_VAR *v;

  v = find_variable ("IFS");
  setifs (v);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.c:4,300
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.c:4,309
parsing error 
{
  /* hash -r */
  phash_flush ();
}
warning: parse error {
  /* hash -r */
  phash_flush ();
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.c:4,311
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.c:4,320
parsing error 
{
  /* If the time interval for checking the files has changed, then
     reset the mail timer.  Otherwise, one of the pathname vars
     to the users mailbox has changed, so rebuild the array of
     filenames. */
  if (name[4] == 'C')  /* if (strcmp (name, "MAILCHECK") == 0) */
    reset_mail_timer ();
  else
    {
      free_mail_files ();
      remember_mail_dates ();
    }
}
warning: parse error {
  /* If the time interval for checking the files has changed, then
     reset the mail timer.  Otherwise, one of the pathname vars
     to the users mailbox has changed, so rebuild the array of
     filenames. */
  if (name[4] == 'C')  /* if (strcmp (name, "MAILCHECK") == 0) */
    reset_mail_timer ();
  else
    {
      free_mail_files ();
      remember_mail_dates ();
    }
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.c:4,322
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.c:4,337
parsing error 
{
  SHELL_VAR *v;
  intmax_t num;

  v = find_variable (name);
  if (v == 0)
    funcnest_max = 0;
  else if (legal_number (value_cell (v), &num) == 0)
    funcnest_max = 0;
  else
    funcnest_max = num;
}
warning: parse error {
  SHELL_VAR *v;
  intmax_t num;

  v = find_variable (name);
  if (v == 0)
    funcnest_max = 0;
  else if (legal_number (value_cell (v), &num) == 0)
    funcnest_max = 0;
  else
    funcnest_max = num;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.c:4,339
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.c:4,354
parsing error 
{
  if (privileged_mode == 0)
    setup_glob_ignore (name);
}
warning: parse error {
  if (privileged_mode == 0)
    setup_glob_ignore (name);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.c:4,356
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.c:4,574
parsing error 
{
  SHELL_VAR *tmp_var;
  char *temp;

  eof_encountered = 0;

  tmp_var = find_variable (name);
  ignoreeof = tmp_var != 0;
  temp = tmp_var ? value_cell (tmp_var) : (char *)NULL;
  if (temp)
    eof_encountered_limit = (*temp && all_digits (temp)) ? atoi (temp) : 10;
  set_shellopts ();	/* make sure `ignoreeof' is/is not in $SHELLOPTS */
}
warning: parse error {
  SHELL_VAR *tmp_var;
  char *temp;

  eof_encountered = 0;

  tmp_var = find_variable (name);
  ignoreeof = tmp_var != 0;
  temp = tmp_var ? value_cell (tmp_var) : (char *)NULL;
  if (temp)
    eof_encountered_limit = (*temp && all_digits (temp)) ? atoi (temp) : 10;
  set_shellopts ();	/* make sure `ignoreeof' is/is not in $SHELLOPTS */
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.c:4,576
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.c:4,591
parsing error 
{
  char *tt;
  int s;

  tt = get_string_value ("OPTIND");
  if (tt && *tt)
    {
      s = atoi (tt);

      /* According to POSIX, setting OPTIND=1 resets the internal state
	 of getopt (). */
      if (s < 0 || s == 1)
	s = 0;
    }
  else
    s = 0;
  getopts_reset (s);
}
warning: parse error {
  char *tt;
  int s;

  tt = get_string_value ("OPTIND");
  if (tt && *tt)
    {
      s = atoi (tt);

      /* According to POSIX, setting OPTIND=1 resets the internal state
	 of getopt (). */
      if (s < 0 || s == 1)
	s = 0;
    }
  else
    s = 0;
  getopts_reset (s);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.c:4,593
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.c:4,613
parsing error 
{
  char *tt;

  tt = get_string_value ("OPTERR");
  sh_opterr = (tt && *tt) ? atoi (tt) : 1;
}
warning: parse error {
  char *tt;

  tt = get_string_value ("OPTERR");
  sh_opterr = (tt && *tt) ? atoi (tt) : 1;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.c:4,615
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.c:4,623
parsing error 
{
  SET_INT_VAR (name, posixly_correct);
  posix_initialize (posixly_correct);
#if defined (READLINE)
  if (interactive_shell)
    posix_readline_initialize (posixly_correct);
#endif /* READLINE */
  set_shellopts ();	/* make sure `posix' is/is not in $SHELLOPTS */
}
warning: parse error {
  SET_INT_VAR (name, posixly_correct);
  posix_initialize (posixly_correct);
#if defined (READLINE)
  if (interactive_shell)
    posix_readline_initialize (posixly_correct);
#endif /* READLINE */
  set_shellopts ();	/* make sure `posix' is/is not in $SHELLOPTS */
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.c:4,625
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.c:4,636
parsing error 
{
  char *v;

  v = get_string_value (name);
  if (name[0] == 'L' && name[1] == 'A')	/* LANG */
    set_lang (name, v);
  else
    set_locale_var (name, v);		/* LC_*, TEXTDOMAIN* */
}
warning: parse error {
  char *v;

  v = get_string_value (name);
  if (name[0] == 'L' && name[1] == 'A')	/* LANG */
    set_lang (name, v);
  else
    set_locale_var (name, v);		/* LC_*, TEXTDOMAIN* */
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.c:4,638
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.c:4,749
parsing error 
{
#if defined (ARRAY_VARS)
  static int v[2] = { 0, -1 };

  v[0] = s;
  set_pipestatus_array (v, 1);
#endif
}
warning: parse error {
#if defined (ARRAY_VARS)
  static int v[2] = { 0, -1 };

  v[0] = s;
  set_pipestatus_array (v, 1);
#endif
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.c:4,751
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.c:4,761
parsing error 
{
  SHELL_VAR *v;
  char *t, *e;
  int fd;
  FILE *fp;

  v = find_variable (name);
  if (v == 0)
    {
      xtrace_reset ();
      return;
    }

  t = value_cell (v);
  if (t == 0 || *t == 0)
    xtrace_reset ();
  else
    {
      fd = (int)strtol (t, &e, 10);
      if (e != t && *e == '\0' && sh_validfd (fd))
	{
	  fp = fdopen (fd, "w");
	  if (fp == 0)
	    internal_error (_("%s: %s: cannot open as FILE"), name, value_cell (v));
	  else
	    xtrace_set (fd, fp);
	}
      else
	internal_error (_("%s: %s: invalid value for trace file descriptor"), name, value_cell (v));
    }
}
warning: parse error {
  SHELL_VAR *v;
  char *t, *e;
  int fd;
  FILE *fp;

  v = find_variable (name);
  if (v == 0)
    {
      xtrace_reset ();
      return;
    }

  t = value_cell (v);
  if (t == 0 || *t == 0)
    xtrace_reset ();
  else
    {
      fd = (int)strtol (t, &e, 10);
      if (e != t && *e == '\0' && sh_validfd (fd))
	{
	  fp = fdopen (fd, "w");
	  if (fp == 0)
	    internal_error (_("%s: %s: cannot open as FILE"), name, value_cell (v));
	  else
	    xtrace_set (fd, fp);
	}
      else
	internal_error (_("%s: %s: invalid value for trace file descriptor"), name, value_cell (v));
    }
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\variables.c:4,763
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\version.c...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\stdc.h...skip
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\patchlevel.h...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\conftypes.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\bashintl.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\version.c:83
parsing error 
{
  printf (_("GNU bash, version %s (%s)\n"), shell_version_string (), MACHTYPE);
  if (extended)
    {
      printf ("%s\n", _(bash_copyright));
      printf ("%s\n", _(bash_license));
      printf (_("This is free software; you are free to change and redistribute it.\n"));
      printf (_("There is NO WARRANTY, to the extent permitted by law.\n"));
    }
}
warning: parse error {
  printf (_("GNU bash, version %s (%s)\n"), shell_version_string (), MACHTYPE);
  if (extended)
    {
      printf ("%s\n", _(bash_copyright));
      printf ("%s\n", _(bash_license));
      printf (_("This is free software; you are free to change and redistribute it.\n"));
      printf (_("There is NO WARRANTY, to the extent permitted by law.\n"));
    }
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\version.c:85
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\xmalloc.c...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\bashtypes.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\error.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\bashintl.h...skip
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\lib\malloc\shmalloc.h...
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\xmalloc.c:86
parsing error 
{
#if defined (HAVE_SBRK)
      allocated = findbrk ();
      fatal_error (_("%s: cannot allocate %lu bytes (%lu bytes allocated)"), func, (unsigned long)bytes, (unsigned long)allocated);
#else
      fatal_error (_("%s: cannot allocate %lu bytes"), func, (unsigned long)bytes);
#endif /* !HAVE_SBRK */
}
warning: parse error {
#if defined (HAVE_SBRK)
      allocated = findbrk ();
      fatal_error (_("%s: cannot allocate %lu bytes (%lu bytes allocated)"), func, (unsigned long)bytes, (unsigned long)allocated);
#else
      fatal_error (_("%s: cannot allocate %lu bytes"), func, (unsigned long)bytes);
#endif /* !HAVE_SBRK */
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\xmalloc.c:88
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\xmalloc.c:101
parsing error 
{
  PTR_T temp;

#if defined (DEBUG)
  if (bytes == 0)
    internal_warning("xmalloc: size argument is 0");
#endif

  FINDBRK();
  temp = malloc (bytes);

  if (temp == 0)
    allocerr ("xmalloc", bytes);

  return (temp);
}
warning: parse error {
  PTR_T temp;

#if defined (DEBUG)
  if (bytes == 0)
    internal_warning("xmalloc: size argument is 0");
#endif

  FINDBRK();
  temp = malloc (bytes);

  if (temp == 0)
    allocerr ("xmalloc", bytes);

  return (temp);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\xmalloc.c:103
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\xmalloc.c:121
parsing error 
{
  PTR_T temp;

#if defined (DEBUG)
  if (bytes == 0)
    internal_warning("xrealloc: size argument is 0");
#endif

  FINDBRK();
  temp = pointer ? realloc (pointer, bytes) : malloc (bytes);

  if (temp == 0)
    allocerr ("xrealloc", bytes);

  return (temp);
}
warning: parse error {
  PTR_T temp;

#if defined (DEBUG)
  if (bytes == 0)
    internal_warning("xrealloc: size argument is 0");
#endif

  FINDBRK();
  temp = pointer ? realloc (pointer, bytes) : malloc (bytes);

  if (temp == 0)
    allocerr ("xrealloc", bytes);

  return (temp);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\xmalloc.c:124
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\xmalloc.c:144
parsing error 
{
  if (string)
    free (string);
}
warning: parse error {
  if (string)
    free (string);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\xmalloc.c:146
parsing E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\y.tab.c...
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\bashtypes.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\bashansi.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\filecntl.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\chartypes.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\memalloc.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\bashintl.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\shell.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\trap.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\flags.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\parser.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\mailcheck.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\test.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\builtins\common.h...skip
already parsed E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\include\shmbutil.h...skip
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\y.tab.c:3,657
parsing error 
{
  bash_input.type = type;
  FREE (bash_input.name);
  bash_input.name = name ? savestring (name) : (char *)NULL;

  /* XXX */
#if defined (CRAY)
  memcpy((char *)&bash_input.location.string, (char *)&location.string, sizeof(location));
#else
  bash_input.location = location;
#endif
  bash_input.getter = get;
  bash_input.ungetter = unget;
}
warning: parse error {
  bash_input.type = type;
  FREE (bash_input.name);
  bash_input.name = name ? savestring (name) : (char *)NULL;

  /* XXX */
#if defined (CRAY)
  memcpy((char *)&bash_input.location.string, (char *)&location.string, sizeof(location));
#else
  bash_input.location = location;
#endif
  bash_input.getter = get;
  bash_input.ungetter = unget;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\y.tab.c:3,663
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\y.tab.c:3,694
parsing error 
{
  return (*(bash_input.ungetter)) (c);
}
warning: parse error {
  return (*(bash_input.ungetter)) (c);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\y.tab.c:3,696
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\y.tab.c:3,852
parsing error 
{
  *(--bash_input.location.string) = c;
  return (c);
}
warning: parse error {
  *(--bash_input.location.string) = c;
  return (c);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\y.tab.c:3,854
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\y.tab.c:3,860
parsing error 
{
  INPUT_STREAM location;

  location.string = string;
  init_yy_io (yy_string_get, yy_string_unget, st_string, name, location);
}
warning: parse error {
  INPUT_STREAM location;

  location.string = string;
  init_yy_io (yy_string_get, yy_string_unget, st_string, name, location);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\y.tab.c:3,863
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\y.tab.c:3,933
parsing error 
{
  return (ungetc_with_restart (c, bash_input.location.file));
}
warning: parse error {
  return (ungetc_with_restart (c, bash_input.location.file));
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\y.tab.c:3,935
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\y.tab.c:3,940
parsing error 
{
  INPUT_STREAM location;

  location.file = stream;
  init_yy_io (yy_stream_get, yy_stream_unget, st_stream, name, location);
}
warning: parse error {
  INPUT_STREAM location;

  location.file = stream;
  init_yy_io (yy_stream_get, yy_stream_unget, st_stream, name, location);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\y.tab.c:3,943
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\y.tab.c:3,973
parsing error 
{
  STREAM_SAVER *saver = (STREAM_SAVER *)xmalloc (sizeof (STREAM_SAVER));

  xbcopy ((char *)&bash_input, (char *)&(saver->bash_input), sizeof (BASH_INPUT));

#if defined (BUFFERED_INPUT)
  saver->bstream = (BUFFERED_STREAM *)NULL;
  /* If we have a buffered stream, clear out buffers[fd]. */
  if (bash_input.type == st_bstream && bash_input.location.buffered_fd >= 0)
    saver->bstream = set_buffered_stream (bash_input.location.buffered_fd,
    					  (BUFFERED_STREAM *)NULL);
#endif /* BUFFERED_INPUT */

  saver->line = line_number;
  bash_input.name = (char *)NULL;
  saver->next = stream_list;
  stream_list = saver;
  EOF_Reached = 0;
  if (reset_lineno)
    line_number = 0;
}
warning: parse error {
  STREAM_SAVER *saver = (STREAM_SAVER *)xmalloc (sizeof (STREAM_SAVER));

  xbcopy ((char *)&bash_input, (char *)&(saver->bash_input), sizeof (BASH_INPUT));

#if defined (BUFFERED_INPUT)
  saver->bstream = (BUFFERED_STREAM *)NULL;
  /* If we have a buffered stream, clear out buffers[fd]. */
  if (bash_input.type == st_bstream && bash_input.location.buffered_fd >= 0)
    saver->bstream = set_buffered_stream (bash_input.location.buffered_fd,
    					  (BUFFERED_STREAM *)NULL);
#endif /* BUFFERED_INPUT */

  saver->line = line_number;
  bash_input.name = (char *)NULL;
  saver->next = stream_list;
  stream_list = saver;
  EOF_Reached = 0;
  if (reset_lineno)
    line_number = 0;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\y.tab.c:3,975
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\y.tab.c:4,046
parsing error 
{
  register STREAM_SAVER *s;

  for (s = stream_list; s; s = s->next)
    if (s->bash_input.type == type)
      return 1;
  return 0;
}
warning: parse error {
  register STREAM_SAVER *s;

  for (s = stream_list; s; s = s->next)
    if (s->bash_input.type == type)
      return 1;
  return 0;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\y.tab.c:4,048
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\y.tab.c:4,072
parsing error 
{
  if (ts == 0)
    return;
  last_read_token = ts[0];
  token_before_that = ts[1];
  two_tokens_ago = ts[2];
  current_token = ts[3];
}
warning: parse error {
  if (ts == 0)
    return;
  last_read_token = ts[0];
  token_before_that = ts[1];
  two_tokens_ago = ts[2];
  current_token = ts[3];
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\y.tab.c:4,074
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\y.tab.c:4,229
parsing error 
{
  static char *line_buffer = (char *)NULL;
  static int buffer_size = 0;
  int indx, c, peekc, pass_next;

#if defined (READLINE)
  if (no_line_editing && SHOULD_PROMPT ())
#else
  if (SHOULD_PROMPT ())
#endif
    print_prompt ();

  pass_next = indx = 0;
  while (1)
    {
      /* Allow immediate exit if interrupted during input. */
      QUIT;

      c = yy_getc ();

      /* Ignore null bytes in input. */
      if (c == 0)
	{
#if 0
	  internal_warning ("read_a_line: ignored null byte in input");
#endif
	  continue;
	}

      /* If there is no more input, then we return NULL. */
      if (c == EOF)
	{
	  if (interactive && bash_input.type == st_stream)
	    clearerr (stdin);
	  if (indx == 0)
	    return ((char *)NULL);
	  c = '\n';
	}

      /* `+2' in case the final character in the buffer is a newline. */
      RESIZE_MALLOCED_BUFFER (line_buffer, indx, 2, buffer_size, 128);

      /* IF REMOVE_QUOTED_NEWLINES is non-zero, we are reading a
	 here document with an unquoted delimiter.  In this case,
	 the line will be expanded as if it were in double quotes.
	 We allow a backslash to escape the next character, but we
	 need to treat the backslash specially only if a backslash
	 quoting a backslash-newline pair appears in the line. */
      if (pass_next)
	{
	  line_buffer[indx++] = c;
	  pass_next = 0;
	}
      else if (c == '\\' && remove_quoted_newline)
	{
	  QUIT;
	  peekc = yy_getc ();
	  if (peekc == '\n')
	    {
	      line_number++;
	      continue;	/* Make the unquoted \<newline> pair disappear. */
	    }
	  else
	    {
	      yy_ungetc (peekc);
	      pass_next = 1;
	      line_buffer[indx++] = c;		/* Preserve the backslash. */
	    }
	}
      else
	line_buffer[indx++] = c;

      if (c == '\n')
	{
	  line_buffer[indx] = '\0';
	  return (line_buffer);
	}
    }
}
warning: parse error {
  static char *line_buffer = (char *)NULL;
  static int buffer_size = 0;
  int indx, c, peekc, pass_next;

#if defined (READLINE)
  if (no_line_editing && SHOULD_PROMPT ())
#else
  if (SHOULD_PROMPT ())
#endif
    print_prompt ();

  pass_next = indx = 0;
  while (1)
    {
      /* Allow immediate exit if interrupted during input. */
      QUIT;

      c = yy_getc ();

      /* Ignore null bytes in input. */
      if (c == 0)
	{
#if 0
	  internal_warning ("read_a_line: ignored null byte in input");
#endif
	  continue;
	}

      /* If there is no more input, then we return NULL. */
      if (c == EOF)
	{
	  if (interactive && bash_input.type == st_stream)
	    clearerr (stdin);
	  if (indx == 0)
	    return ((char *)NULL);
	  c = '\n';
	}

      /* `+2' in case the final character in the buffer is a newline. */
      RESIZE_MALLOCED_BUFFER (line_buffer, indx, 2, buffer_size, 128);

      /* IF REMOVE_QUOTED_NEWLINES is non-zero, we are reading a
	 here document with an unquoted delimiter.  In this case,
	 the line will be expanded as if it were in double quotes.
	 We allow a backslash to escape the next character, but we
	 need to treat the backslash specially only if a backslash
	 quoting a backslash-newline pair appears in the line. */
      if (pass_next)
	{
	  line_buffer[indx++] = c;
	  pass_next = 0;
	}
      else if (c == '\\' && remove_quoted_newline)
	{
	  QUIT;
	  peekc = yy_getc ();
	  if (peekc == '\n')
	    {
	      line_number++;
	      continue;	/* Make the unquoted \<newline> pair disappear. */
	    }
	  else
	    {
	      yy_ungetc (peekc);
	      pass_next = 1;
	      line_buffer[indx++] = c;		/* Preserve the backslash. */
	    }
	}
      else
	line_buffer[indx++] = c;

      if (c == '\n')
	{
	  line_buffer[indx] = '\0';
	  return (line_buffer);
	}
    }
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\y.tab.c:4,231
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\y.tab.c:4,317
parsing error 
{
  char *ret;
  int n, c;

  prompt_string_pointer = &ps2_prompt;
  if (SHOULD_PROMPT())
    prompt_again ();
  ret = read_a_line (remove_quoted_newline);
#if defined (HISTORY)
  if (ret && remember_on_history && (parser_state & PST_HEREDOC))
    {
      /* To make adding the the here-document body right, we need to rely
	 on history_delimiting_chars() returning \n for the first line of
	 the here-document body and the null string for the second and
	 subsequent lines, so we avoid double newlines.
	 current_command_line_count == 2 for the first line of the body. */

      current_command_line_count++;
      maybe_add_history (ret);
    }
#endif /* HISTORY */
  return ret;
}
warning: parse error {
  char *ret;
  int n, c;

  prompt_string_pointer = &ps2_prompt;
  if (SHOULD_PROMPT())
    prompt_again ();
  ret = read_a_line (remove_quoted_newline);
#if defined (HISTORY)
  if (ret && remember_on_history && (parser_state & PST_HEREDOC))
    {
      /* To make adding the the here-document body right, we need to rely
	 on history_delimiting_chars() returning \n for the first line of
	 the here-document body and the null string for the second and
	 subsequent lines, so we avoid double newlines.
	 current_command_line_count == 2 for the first line of the body. */

      current_command_line_count++;
      maybe_add_history (ret);
    }
#endif /* HISTORY */
  return ret;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\y.tab.c:4,319
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\y.tab.c:4,471
parsing error 
{
  register int i;
  int c;
  unsigned char uc;

  QUIT;

  if (sigwinch_received)
    {
      sigwinch_received = 0;
      get_new_window_size (0, (int *)0, (int *)0);
    }
      
  if (eol_ungetc_lookahead)
    {
      c = eol_ungetc_lookahead;
      eol_ungetc_lookahead = 0;
      return (c);
    }

#if defined (ALIAS) || defined (DPAREN_ARITHMETIC)
  /* If shell_input_line[shell_input_line_index] == 0, but there is
     something on the pushed list of strings, then we don't want to go
     off and get another line.  We let the code down below handle it. */

  if (!shell_input_line || ((!shell_input_line[shell_input_line_index]) &&
			    (pushed_string_list == (STRING_SAVER *)NULL)))
#else /* !ALIAS && !DPAREN_ARITHMETIC */
  if (!shell_input_line || !shell_input_line[shell_input_line_index])
#endif /* !ALIAS && !DPAREN_ARITHMETIC */
    {
      line_number++;

    restart_read:

      /* Allow immediate exit if interrupted during input. */
      QUIT;

      i = 0;
      shell_input_line_terminator = 0;

      /* If the shell is interatctive, but not currently printing a prompt
         (interactive_shell && interactive == 0), we don't want to print
         notifies or cleanup the jobs -- we want to defer it until we do
         print the next prompt. */
      if (interactive_shell == 0 || SHOULD_PROMPT())
	{
#if defined (JOB_CONTROL)
      /* This can cause a problem when reading a command as the result
	 of a trap, when the trap is called from flush_child.  This call
	 had better not cause jobs to disappear from the job table in
	 that case, or we will have big trouble. */
	  notify_and_cleanup ();
#else /* !JOB_CONTROL */
	  cleanup_dead_jobs ();
#endif /* !JOB_CONTROL */
	}

#if defined (READLINE)
      if (no_line_editing && SHOULD_PROMPT())
#else
      if (SHOULD_PROMPT())
#endif
	print_prompt ();

      if (bash_input.type == st_stream)
	clearerr (stdin);

      while (1)
	{
	  c = yy_getc ();

	  /* Allow immediate exit if interrupted during input. */
	  QUIT;

	  if (c == '\0')
	    {
#if 0
	      internal_warning ("shell_getc: ignored null byte in input");
#endif
	      continue;
	    }

	  RESIZE_MALLOCED_BUFFER (shell_input_line, i, 2, shell_input_line_size, 256);

	  if (c == EOF)
	    {
	      if (bash_input.type == st_stream)
		clearerr (stdin);

	      if (i == 0)
		shell_input_line_terminator = EOF;

	      shell_input_line[i] = '\0';
	      break;
	    }

	  shell_input_line[i++] = c;

	  if (c == '\n')
	    {
	      shell_input_line[--i] = '\0';
	      current_command_line_count++;
	      break;
	    }
	}

      shell_input_line_index = 0;
      shell_input_line_len = i;		/* == strlen (shell_input_line) */

      set_line_mbstate ();

#if defined (HISTORY)
      if (remember_on_history && shell_input_line && shell_input_line[0])
	{
	  char *expansions;
#  if defined (BANG_HISTORY)
	  int old_hist;

	  /* If the current delimiter is a single quote, we should not be
	     performing history expansion, even if we're on a different
	     line from the original single quote. */
	  old_hist = history_expansion_inhibited;
	  if (current_delimiter (dstack) == '\'')
	    history_expansion_inhibited = 1;
#  endif
	  expansions = pre_process_line (shell_input_line, 1, 1);
#  if defined (BANG_HISTORY)
	  history_expansion_inhibited = old_hist;
#  endif
	  if (expansions != shell_input_line)
	    {
	      free (shell_input_line);
	      shell_input_line = expansions;
	      shell_input_line_len = shell_input_line ?
					strlen (shell_input_line) : 0;
	      if (shell_input_line_len == 0)
		current_command_line_count--;

	      /* We have to force the xrealloc below because we don't know
		 the true allocated size of shell_input_line anymore. */
	      shell_input_line_size = shell_input_line_len;

	      set_line_mbstate ();
	    }
	}
      /* Try to do something intelligent with blank lines encountered while
	 entering multi-line commands.  XXX - this is grotesque */
      else if (remember_on_history && shell_input_line &&
	       shell_input_line[0] == '\0' &&
	       current_command_line_count > 1)
	{
	  if (current_delimiter (dstack))
	    /* We know shell_input_line[0] == 0 and we're reading some sort of
	       quoted string.  This means we've got a line consisting of only
	       a newline in a quoted string.  We want to make sure this line
	       gets added to the history. */
	    maybe_add_history (shell_input_line);
	  else
	    {
	      char *hdcs;
	      hdcs = history_delimiting_chars (shell_input_line);
	      if (hdcs && hdcs[0] == ';')
		maybe_add_history (shell_input_line);
	    }
	}

#endif /* HISTORY */

      if (shell_input_line)
	{
	  /* Lines that signify the end of the shell's input should not be
	     echoed. */
	  if (echo_input_at_read && (shell_input_line[0] ||
				     shell_input_line_terminator != EOF))
	    fprintf (stderr, "%s\n", shell_input_line);
	}
      else
	{
	  shell_input_line_size = 0;
	  prompt_string_pointer = &current_prompt_string;
	  if (SHOULD_PROMPT ())
	    prompt_again ();
	  goto restart_read;
	}

      /* Add the newline to the end of this string, iff the string does
	 not already end in an EOF character.  */
      if (shell_input_line_terminator != EOF)
	{
	  if (shell_input_line_len + 3 > shell_input_line_size)
	    shell_input_line = (char *)xrealloc (shell_input_line,
					1 + (shell_input_line_size += 2));

	  shell_input_line[shell_input_line_len] = '\n';
	  shell_input_line[shell_input_line_len + 1] = '\0';

	  set_line_mbstate ();
	}
    }

next_alias_char:
  uc = shell_input_line[shell_input_line_index];

  if (uc)
    shell_input_line_index++;

#if defined (ALIAS) || defined (DPAREN_ARITHMETIC)
  /* If UC is NULL, we have reached the end of the current input string.  If
     pushed_string_list is non-empty, it's time to pop to the previous string
     because we have fully consumed the result of the last alias expansion.
     Do it transparently; just return the next character of the string popped
     to. */
pop_alias:
  if (uc == 0 && (pushed_string_list != (STRING_SAVER *)NULL))
    {
      pop_string ();
      uc = shell_input_line[shell_input_line_index];
      if (uc)
	shell_input_line_index++;
    }
#endif /* ALIAS || DPAREN_ARITHMETIC */

  if MBTEST(uc == '\\' && remove_quoted_newline && shell_input_line[shell_input_line_index] == '\n')
    {
	if (SHOULD_PROMPT ())
	  prompt_again ();
	line_number++;
	/* What do we do here if we're expanding an alias whose definition
	   includes an escaped newline?  If that's the last character in the
	   alias expansion, we just pop the pushed string list (recall that
	   we inhibit the appending of a space in mk_alexpansion() if newline
	   is the last character).  If it's not the last character, we need
	   to consume the quoted newline and move to the next character in
	   the expansion. */
	if (expanding_alias () && shell_input_line[shell_input_line_index+1] == '\0')
	  {
	    uc = 0;
	    goto pop_alias;
	  }
	else if (expanding_alias () && shell_input_line[shell_input_line_index+1] != '\0')
	  {
	    shell_input_line_index++;	/* skip newline */
	    goto next_alias_char;	/* and get next character */
	  }
	else	    
	  goto restart_read;
    }

  if (uc == 0 && shell_input_line_terminator == EOF)
    return ((shell_input_line_index != 0) ? '\n' : EOF);

  return (uc);
}
warning: parse error {
  register int i;
  int c;
  unsigned char uc;

  QUIT;

  if (sigwinch_received)
    {
      sigwinch_received = 0;
      get_new_window_size (0, (int *)0, (int *)0);
    }
      
  if (eol_ungetc_lookahead)
    {
      c = eol_ungetc_lookahead;
      eol_ungetc_lookahead = 0;
      return (c);
    }

#if defined (ALIAS) || defined (DPAREN_ARITHMETIC)
  /* If shell_input_line[shell_input_line_index] == 0, but there is
     something on the pushed list of strings, then we don't want to go
     off and get another line.  We let the code down below handle it. */

  if (!shell_input_line || ((!shell_input_line[shell_input_line_index]) &&
			    (pushed_string_list == (STRING_SAVER *)NULL)))
#else /* !ALIAS && !DPAREN_ARITHMETIC */
  if (!shell_input_line || !shell_input_line[shell_input_line_index])
#endif /* !ALIAS && !DPAREN_ARITHMETIC */
    {
      line_number++;

    restart_read:

      /* Allow immediate exit if interrupted during input. */
      QUIT;

      i = 0;
      shell_input_line_terminator = 0;

      /* If the shell is interatctive, but not currently printing a prompt
         (interactive_shell && interactive == 0), we don't want to print
         notifies or cleanup the jobs -- we want to defer it until we do
         print the next prompt. */
      if (interactive_shell == 0 || SHOULD_PROMPT())
	{
#if defined (JOB_CONTROL)
      /* This can cause a problem when reading a command as the result
	 of a trap, when the trap is called from flush_child.  This call
	 had better not cause jobs to disappear from the job table in
	 that case, or we will have big trouble. */
	  notify_and_cleanup ();
#else /* !JOB_CONTROL */
	  cleanup_dead_jobs ();
#endif /* !JOB_CONTROL */
	}

#if defined (READLINE)
      if (no_line_editing && SHOULD_PROMPT())
#else
      if (SHOULD_PROMPT())
#endif
	print_prompt ();

      if (bash_input.type == st_stream)
	clearerr (stdin);

      while (1)
	{
	  c = yy_getc ();

	  /* Allow immediate exit if interrupted during input. */
	  QUIT;

	  if (c == '\0')
	    {
#if 0
	      internal_warning ("shell_getc: ignored null byte in input");
#endif
	      continue;
	    }

	  RESIZE_MALLOCED_BUFFER (shell_input_line, i, 2, shell_input_line_size, 256);

	  if (c == EOF)
	    {
	      if (bash_input.type == st_stream)
		clearerr (stdin);

	      if (i == 0)
		shell_input_line_terminator = EOF;

	      shell_input_line[i] = '\0';
	      break;
	    }

	  shell_input_line[i++] = c;

	  if (c == '\n')
	    {
	      shell_input_line[--i] = '\0';
	      current_command_line_count++;
	      break;
	    }
	}

      shell_input_line_index = 0;
      shell_input_line_len = i;		/* == strlen (shell_input_line) */

      set_line_mbstate ();

#if defined (HISTORY)
      if (remember_on_history && shell_input_line && shell_input_line[0])
	{
	  char *expansions;
#  if defined (BANG_HISTORY)
	  int old_hist;

	  /* If the current delimiter is a single quote, we should not be
	     performing history expansion, even if we're on a different
	     line from the original single quote. */
	  old_hist = history_expansion_inhibited;
	  if (current_delimiter (dstack) == '\'')
	    history_expansion_inhibited = 1;
#  endif
	  expansions = pre_process_line (shell_input_line, 1, 1);
#  if defined (BANG_HISTORY)
	  history_expansion_inhibited = old_hist;
#  endif
	  if (expansions != shell_input_line)
	    {
	      free (shell_input_line);
	      shell_input_line = expansions;
	      shell_input_line_len = shell_input_line ?
					strlen (shell_input_line) : 0;
	      if (shell_input_line_len == 0)
		current_command_line_count--;

	      /* We have to force the xrealloc below because we don't know
		 the true allocated size of shell_input_line anymore. */
	      shell_input_line_size = shell_input_line_len;

	      set_line_mbstate ();
	    }
	}
      /* Try to do something intelligent with blank lines encountered while
	 entering multi-line commands.  XXX - this is grotesque */
      else if (remember_on_history && shell_input_line &&
	       shell_input_line[0] == '\0' &&
	       current_command_line_count > 1)
	{
	  if (current_delimiter (dstack))
	    /* We know shell_input_line[0] == 0 and we're reading some sort of
	       quoted string.  This means we've got a line consisting of only
	       a newline in a quoted string.  We want to make sure this line
	       gets added to the history. */
	    maybe_add_history (shell_input_line);
	  else
	    {
	      char *hdcs;
	      hdcs = history_delimiting_chars (shell_input_line);
	      if (hdcs && hdcs[0] == ';')
		maybe_add_history (shell_input_line);
	    }
	}

#endif /* HISTORY */

      if (shell_input_line)
	{
	  /* Lines that signify the end of the shell's input should not be
	     echoed. */
	  if (echo_input_at_read && (shell_input_line[0] ||
				     shell_input_line_terminator != EOF))
	    fprintf (stderr, "%s\n", shell_input_line);
	}
      else
	{
	  shell_input_line_size = 0;
	  prompt_string_pointer = &current_prompt_string;
	  if (SHOULD_PROMPT ())
	    prompt_again ();
	  goto restart_read;
	}

      /* Add the newline to the end of this string, iff the string does
	 not already end in an EOF character.  */
      if (shell_input_line_terminator != EOF)
	{
	  if (shell_input_line_len + 3 > shell_input_line_size)
	    shell_input_line = (char *)xrealloc (shell_input_line,
					1 + (shell_input_line_size += 2));

	  shell_input_line[shell_input_line_len] = '\n';
	  shell_input_line[shell_input_line_len + 1] = '\0';

	  set_line_mbstate ();
	}
    }

next_alias_char:
  uc = shell_input_line[shell_input_line_index];

  if (uc)
    shell_input_line_index++;

#if defined (ALIAS) || defined (DPAREN_ARITHMETIC)
  /* If UC is NULL, we have reached the end of the current input string.  If
     pushed_string_list is non-empty, it's time to pop to the previous string
     because we have fully consumed the result of the last alias expansion.
     Do it transparently; just return the next character of the string popped
     to. */
pop_alias:
  if (uc == 0 && (pushed_string_list != (STRING_SAVER *)NULL))
    {
      pop_string ();
      uc = shell_input_line[shell_input_line_index];
      if (uc)
	shell_input_line_index++;
    }
#endif /* ALIAS || DPAREN_ARITHMETIC */

  if MBTEST(uc == '\\' && remove_quoted_newline && shell_input_line[shell_input_line_index] == '\n')
    {
	if (SHOULD_PROMPT ())
	  prompt_again ();
	line_number++;
	/* What do we do here if we're expanding an alias whose definition
	   includes an escaped newline?  If that's the last character in the
	   alias expansion, we just pop the pushed string list (recall that
	   we inhibit the appending of a space in mk_alexpansion() if newline
	   is the last character).  If it's not the last character, we need
	   to consume the quoted newline and move to the next character in
	   the expansion. */
	if (expanding_alias () && shell_input_line[shell_input_line_index+1] == '\0')
	  {
	    uc = 0;
	    goto pop_alias;
	  }
	else if (expanding_alias () && shell_input_line[shell_input_line_index+1] != '\0')
	  {
	    shell_input_line_index++;	/* skip newline */
	    goto next_alias_char;	/* and get next character */
	  }
	else	    
	  goto restart_read;
    }

  if (uc == 0 && shell_input_line_terminator == EOF)
    return ((shell_input_line_index != 0) ? '\n' : EOF);

  return (uc);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\y.tab.c:4,473
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\y.tab.c:4,734
parsing error 
{
  if (shell_input_line && shell_input_line_index)
    shell_input_line[--shell_input_line_index] = c;
  else
    eol_ungetc_lookahead = c;
}
warning: parse error {
  if (shell_input_line && shell_input_line_index)
    shell_input_line[--shell_input_line_index] = c;
  else
    eol_ungetc_lookahead = c;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\y.tab.c:4,736
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\y.tab.c:4,756
parsing error 
{
  int c;

  while ((c = shell_getc (0)) != EOF && c != character)
    ;

  if (c != EOF)
    shell_ungetc (c);
}
warning: parse error {
  int c;

  while ((c = shell_getc (0)) != EOF && c != character)
    ;

  if (c != EOF)
    shell_ungetc (c);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\y.tab.c:4,758
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\y.tab.c:4,769
parsing error 
{
  char *last_lastarg;
  sh_parser_state_t ps;

  save_parser_state (&ps);
  last_lastarg = get_string_value ("_");
  if (last_lastarg)
    last_lastarg = savestring (last_lastarg);

  parse_and_execute (savestring (command), vname, SEVAL_NONINT|SEVAL_NOHIST);

  restore_parser_state (&ps);
  bind_variable ("_", last_lastarg, 0);
  FREE (last_lastarg);

  if (token_to_read == '\n')	/* reset_parser was called */
    token_to_read = 0;
}
warning: parse error {
  char *last_lastarg;
  sh_parser_state_t ps;

  save_parser_state (&ps);
  last_lastarg = get_string_value ("_");
  if (last_lastarg)
    last_lastarg = savestring (last_lastarg);

  parse_and_execute (savestring (command), vname, SEVAL_NONINT|SEVAL_NOHIST);

  restore_parser_state (&ps);
  bind_variable ("_", last_lastarg, 0);
  FREE (last_lastarg);

  if (token_to_read == '\n')	/* reset_parser was called */
    token_to_read = 0;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\y.tab.c:4,771
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\y.tab.c:5,043
parsing error 
{
  if ((last_read_token == WORD) &&
#if defined (SELECT_COMMAND)
      ((token_before_that == FOR) || (token_before_that == CASE) || (token_before_that == SELECT)) &&
#else
      ((token_before_that == FOR) || (token_before_that == CASE)) &&
#endif
      (tokstr[0] == 'i' && tokstr[1] == 'n' && tokstr[2] == 0))
    {
      if (token_before_that == CASE)
	{
	  parser_state |= PST_CASEPAT;
	  esacs_needed_count++;
	}
      return (IN);
    }

  if (last_read_token == WORD &&
#if defined (SELECT_COMMAND)
      (token_before_that == FOR || token_before_that == SELECT) &&
#else
      (token_before_that == FOR) &&
#endif
      (tokstr[0] == 'd' && tokstr[1] == 'o' && tokstr[2] == '\0'))
    return (DO);

  /* Ditto for ESAC in the CASE case.
     Specifically, this handles "case word in esac", which is a legal
     construct, certainly because someone will pass an empty arg to the
     case construct, and we don't want it to barf.  Of course, we should
     insist that the case construct has at least one pattern in it, but
     the designers disagree. */
  if (esacs_needed_count)
    {
      esacs_needed_count--;
      if (STREQ (tokstr, "esac"))
	{
	  parser_state &= ~PST_CASEPAT;
	  return (ESAC);
	}
    }

  /* The start of a shell function definition. */
  if (parser_state & PST_ALLOWOPNBRC)
    {
      parser_state &= ~PST_ALLOWOPNBRC;
      if (tokstr[0] == '{' && tokstr[1] == '\0')		/* } */
	{
	  open_brace_count++;
	  function_bstart = line_number;
	  return ('{');					/* } */
	}
    }

  /* We allow a `do' after a for ((...)) without an intervening
     list_terminator */
  if (last_read_token == ARITH_FOR_EXPRS && tokstr[0] == 'd' && tokstr[1] == 'o' && !tokstr[2])
    return (DO);
  if (last_read_token == ARITH_FOR_EXPRS && tokstr[0] == '{' && tokstr[1] == '\0')	/* } */
    {
      open_brace_count++;
      return ('{');			/* } */
    }

  if (open_brace_count && reserved_word_acceptable (last_read_token) && tokstr[0] == '}' && !tokstr[1])
    {
      open_brace_count--;		/* { */
      return ('}');
    }

#if defined (COMMAND_TIMING)
  /* Handle -p after `time'. */
  if (last_read_token == TIME && tokstr[0] == '-' && tokstr[1] == 'p' && !tokstr[2])
    return (TIMEOPT);
  /* Handle -- after `time -p'. */
  if (last_read_token == TIMEOPT && tokstr[0] == '-' && tokstr[1] == '-' && !tokstr[2])
    return (TIMEIGN);
#endif

#if defined (COND_COMMAND) /* [[ */
  if ((parser_state & PST_CONDEXPR) && tokstr[0] == ']' && tokstr[1] == ']' && tokstr[2] == '\0')
    return (COND_END);
#endif

  return (-1);
}
warning: parse error {
  if ((last_read_token == WORD) &&
#if defined (SELECT_COMMAND)
      ((token_before_that == FOR) || (token_before_that == CASE) || (token_before_that == SELECT)) &&
#else
      ((token_before_that == FOR) || (token_before_that == CASE)) &&
#endif
      (tokstr[0] == 'i' && tokstr[1] == 'n' && tokstr[2] == 0))
    {
      if (token_before_that == CASE)
	{
	  parser_state |= PST_CASEPAT;
	  esacs_needed_count++;
	}
      return (IN);
    }

  if (last_read_token == WORD &&
#if defined (SELECT_COMMAND)
      (token_before_that == FOR || token_before_that == SELECT) &&
#else
      (token_before_that == FOR) &&
#endif
      (tokstr[0] == 'd' && tokstr[1] == 'o' && tokstr[2] == '\0'))
    return (DO);

  /* Ditto for ESAC in the CASE case.
     Specifically, this handles "case word in esac", which is a legal
     construct, certainly because someone will pass an empty arg to the
     case construct, and we don't want it to barf.  Of course, we should
     insist that the case construct has at least one pattern in it, but
     the designers disagree. */
  if (esacs_needed_count)
    {
      esacs_needed_count--;
      if (STREQ (tokstr, "esac"))
	{
	  parser_state &= ~PST_CASEPAT;
	  return (ESAC);
	}
    }

  /* The start of a shell function definition. */
  if (parser_state & PST_ALLOWOPNBRC)
    {
      parser_state &= ~PST_ALLOWOPNBRC;
      if (tokstr[0] == '{' && tokstr[1] == '\0')		/* } */
	{
	  open_brace_count++;
	  function_bstart = line_number;
	  return ('{');					/* } */
	}
    }

  /* We allow a `do' after a for ((...)) without an intervening
     list_terminator */
  if (last_read_token == ARITH_FOR_EXPRS && tokstr[0] == 'd' && tokstr[1] == 'o' && !tokstr[2])
    return (DO);
  if (last_read_token == ARITH_FOR_EXPRS && tokstr[0] == '{' && tokstr[1] == '\0')	/* } */
    {
      open_brace_count++;
      return ('{');			/* } */
    }

  if (open_brace_count && reserved_word_acceptable (last_read_token) && tokstr[0] == '}' && !tokstr[1])
    {
      open_brace_count--;		/* { */
      return ('}');
    }

#if defined (COMMAND_TIMING)
  /* Handle -p after `time'. */
  if (last_read_token == TIME && tokstr[0] == '-' && tokstr[1] == 'p' && !tokstr[2])
    return (TIMEOPT);
  /* Handle -- after `time -p'. */
  if (last_read_token == TIMEOPT && tokstr[0] == '-' && tokstr[1] == '-' && !tokstr[2])
    return (TIMEIGN);
#endif

#if defined (COND_COMMAND) /* [[ */
  if ((parser_state & PST_CONDEXPR) && tokstr[0] == ']' && tokstr[1] == ']' && tokstr[2] == '\0')
    return (COND_END);
#endif

  return (-1);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\y.tab.c:5,045
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\y.tab.c:5,171
parsing error 
{
  int character;		/* Current character. */
  int peek_char;		/* Temporary look-ahead character. */
  int result;			/* The thing to return. */

  if (command == RESET)
    {
      reset_parser ();
      return ('\n');
    }

  if (token_to_read)
    {
      result = token_to_read;
      if (token_to_read == WORD || token_to_read == ASSIGNMENT_WORD)
	{
	  yylval.word = word_desc_to_read;
	  word_desc_to_read = (WORD_DESC *)NULL;
	}
      token_to_read = 0;
      return (result);
    }

#if defined (COND_COMMAND)
  if ((parser_state & (PST_CONDCMD|PST_CONDEXPR)) == PST_CONDCMD)
    {
      cond_lineno = line_number;
      parser_state |= PST_CONDEXPR;
      yylval.command = parse_cond_command ();
      if (cond_token != COND_END)
	{
	  cond_error ();
	  return (-1);
	}
      token_to_read = COND_END;
      parser_state &= ~(PST_CONDEXPR|PST_CONDCMD);
      return (COND_CMD);
    }
#endif

#if defined (ALIAS)
  /* This is a place to jump back to once we have successfully expanded a
     token with an alias and pushed the string with push_string () */
 re_read_token:
#endif /* ALIAS */

  /* Read a single word from input.  Start by skipping blanks. */
  while ((character = shell_getc (1)) != EOF && shellblank (character))
    ;

  if (character == EOF)
    {
      EOF_Reached = 1;
      return (yacc_EOF);
    }

  if MBTEST(character == '#' && (!interactive || interactive_comments))
    {
      /* A comment.  Discard until EOL or EOF, and then return a newline. */
      discard_until ('\n');
      shell_getc (0);
      character = '\n';	/* this will take the next if statement and return. */
    }

  if (character == '\n')
    {
      /* If we're about to return an unquoted newline, we can go and collect
	 the text of any pending here document. */
      if (need_here_doc)
	gather_here_documents ();

#if defined (ALIAS)
      parser_state &= ~PST_ALEXPNEXT;
#endif /* ALIAS */

      parser_state &= ~PST_ASSIGNOK;

      return (character);
    }

  if (parser_state & PST_REGEXP)
    goto tokword;

  /* Shell meta-characters. */
  if MBTEST(shellmeta (character) && ((parser_state & PST_DBLPAREN) == 0))
    {
#if defined (ALIAS)
      /* Turn off alias tokenization iff this character sequence would
	 not leave us ready to read a command. */
      if (character == '<' || character == '>')
	parser_state &= ~PST_ALEXPNEXT;
#endif /* ALIAS */

      parser_state &= ~PST_ASSIGNOK;

      peek_char = shell_getc (1);
      if (character == peek_char)
	{
	  switch (character)
	    {
	    case '<':
	      /* If '<' then we could be at "<<" or at "<<-".  We have to
		 look ahead one more character. */
	      peek_char = shell_getc (1);
	      if MBTEST(peek_char == '-')
		return (LESS_LESS_MINUS);
	      else if MBTEST(peek_char == '<')
		return (LESS_LESS_LESS);
	      else
		{
		  shell_ungetc (peek_char);
		  return (LESS_LESS);
		}

	    case '>':
	      return (GREATER_GREATER);

	    case ';':
	      parser_state |= PST_CASEPAT;
#if defined (ALIAS)
	      parser_state &= ~PST_ALEXPNEXT;
#endif /* ALIAS */

	      peek_char = shell_getc (1);
	      if MBTEST(peek_char == '&')
		return (SEMI_SEMI_AND);
	      else
		{
		  shell_ungetc (peek_char);
		  return (SEMI_SEMI);
		}

	    case '&':
	      return (AND_AND);

	    case '|':
	      return (OR_OR);

#if defined (DPAREN_ARITHMETIC) || defined (ARITH_FOR_COMMAND)
	    case '(':		/* ) */
	      result = parse_dparen (character);
	      if (result == -2)
	        break;
	      else
	        return result;
#endif
	    }
	}
      else if MBTEST(character == '<' && peek_char == '&')
	return (LESS_AND);
      else if MBTEST(character == '>' && peek_char == '&')
	return (GREATER_AND);
      else if MBTEST(character == '<' && peek_char == '>')
	return (LESS_GREATER);
      else if MBTEST(character == '>' && peek_char == '|')
	return (GREATER_BAR);
      else if MBTEST(character == '&' && peek_char == '>')
	{
	  peek_char = shell_getc (1);
	  if MBTEST(peek_char == '>')
	    return (AND_GREATER_GREATER);
	  else
	    {
	      shell_ungetc (peek_char);
	      return (AND_GREATER);
	    }
	}
      else if MBTEST(character == '|' && peek_char == '&')
	return (BAR_AND);
      else if MBTEST(character == ';' && peek_char == '&')
	{
	  parser_state |= PST_CASEPAT;
#if defined (ALIAS)
	  parser_state &= ~PST_ALEXPNEXT;
#endif /* ALIAS */
	  return (SEMI_AND);
	}

      shell_ungetc (peek_char);

      /* If we look like we are reading the start of a function
	 definition, then let the reader know about it so that
	 we will do the right thing with `{'. */
      if MBTEST(character == ')' && last_read_token == '(' && token_before_that == WORD)
	{
	  parser_state |= PST_ALLOWOPNBRC;
#if defined (ALIAS)
	  parser_state &= ~PST_ALEXPNEXT;
#endif /* ALIAS */
	  function_dstart = line_number;
	}

      /* case pattern lists may be preceded by an optional left paren.  If
	 we're not trying to parse a case pattern list, the left paren
	 indicates a subshell. */
      if MBTEST(character == '(' && (parser_state & PST_CASEPAT) == 0) /* ) */
	parser_state |= PST_SUBSHELL;
      /*(*/
      else if MBTEST((parser_state & PST_CASEPAT) && character == ')')
	parser_state &= ~PST_CASEPAT;
      /*(*/
      else if MBTEST((parser_state & PST_SUBSHELL) && character == ')')
	parser_state &= ~PST_SUBSHELL;

#if defined (PROCESS_SUBSTITUTION)
      /* Check for the constructs which introduce process substitution.
	 Shells running in `posix mode' don't do process substitution. */
      if MBTEST(posixly_correct || ((character != '>' && character != '<') || peek_char != '(')) /*)*/
#endif /* PROCESS_SUBSTITUTION */
	return (character);
    }

  /* Hack <&- (close stdin) case.  Also <&N- (dup and close). */
  if MBTEST(character == '-' && (last_read_token == LESS_AND || last_read_token == GREATER_AND))
    return (character);

tokword:
  /* Okay, if we got this far, we have to read a word.  Read one,
     and then check it against the known ones. */
  result = read_token_word (character);
#if defined (ALIAS)
  if (result == RE_READ_TOKEN)
    goto re_read_token;
#endif
  return result;
}
warning: parse error {
  int character;		/* Current character. */
  int peek_char;		/* Temporary look-ahead character. */
  int result;			/* The thing to return. */

  if (command == RESET)
    {
      reset_parser ();
      return ('\n');
    }

  if (token_to_read)
    {
      result = token_to_read;
      if (token_to_read == WORD || token_to_read == ASSIGNMENT_WORD)
	{
	  yylval.word = word_desc_to_read;
	  word_desc_to_read = (WORD_DESC *)NULL;
	}
      token_to_read = 0;
      return (result);
    }

#if defined (COND_COMMAND)
  if ((parser_state & (PST_CONDCMD|PST_CONDEXPR)) == PST_CONDCMD)
    {
      cond_lineno = line_number;
      parser_state |= PST_CONDEXPR;
      yylval.command = parse_cond_command ();
      if (cond_token != COND_END)
	{
	  cond_error ();
	  return (-1);
	}
      token_to_read = COND_END;
      parser_state &= ~(PST_CONDEXPR|PST_CONDCMD);
      return (COND_CMD);
    }
#endif

#if defined (ALIAS)
  /* This is a place to jump back to once we have successfully expanded a
     token with an alias and pushed the string with push_string () */
 re_read_token:
#endif /* ALIAS */

  /* Read a single word from input.  Start by skipping blanks. */
  while ((character = shell_getc (1)) != EOF && shellblank (character))
    ;

  if (character == EOF)
    {
      EOF_Reached = 1;
      return (yacc_EOF);
    }

  if MBTEST(character == '#' && (!interactive || interactive_comments))
    {
      /* A comment.  Discard until EOL or EOF, and then return a newline. */
      discard_until ('\n');
      shell_getc (0);
      character = '\n';	/* this will take the next if statement and return. */
    }

  if (character == '\n')
    {
      /* If we're about to return an unquoted newline, we can go and collect
	 the text of any pending here document. */
      if (need_here_doc)
	gather_here_documents ();

#if defined (ALIAS)
      parser_state &= ~PST_ALEXPNEXT;
#endif /* ALIAS */

      parser_state &= ~PST_ASSIGNOK;

      return (character);
    }

  if (parser_state & PST_REGEXP)
    goto tokword;

  /* Shell meta-characters. */
  if MBTEST(shellmeta (character) && ((parser_state & PST_DBLPAREN) == 0))
    {
#if defined (ALIAS)
      /* Turn off alias tokenization iff this character sequence would
	 not leave us ready to read a command. */
      if (character == '<' || character == '>')
	parser_state &= ~PST_ALEXPNEXT;
#endif /* ALIAS */

      parser_state &= ~PST_ASSIGNOK;

      peek_char = shell_getc (1);
      if (character == peek_char)
	{
	  switch (character)
	    {
	    case '<':
	      /* If '<' then we could be at "<<" or at "<<-".  We have to
		 look ahead one more character. */
	      peek_char = shell_getc (1);
	      if MBTEST(peek_char == '-')
		return (LESS_LESS_MINUS);
	      else if MBTEST(peek_char == '<')
		return (LESS_LESS_LESS);
	      else
		{
		  shell_ungetc (peek_char);
		  return (LESS_LESS);
		}

	    case '>':
	      return (GREATER_GREATER);

	    case ';':
	      parser_state |= PST_CASEPAT;
#if defined (ALIAS)
	      parser_state &= ~PST_ALEXPNEXT;
#endif /* ALIAS */

	      peek_char = shell_getc (1);
	      if MBTEST(peek_char == '&')
		return (SEMI_SEMI_AND);
	      else
		{
		  shell_ungetc (peek_char);
		  return (SEMI_SEMI);
		}

	    case '&':
	      return (AND_AND);

	    case '|':
	      return (OR_OR);

#if defined (DPAREN_ARITHMETIC) || defined (ARITH_FOR_COMMAND)
	    case '(':		/* ) */
	      result = parse_dparen (character);
	      if (result == -2)
	        break;
	      else
	        return result;
#endif
	    }
	}
      else if MBTEST(character == '<' && peek_char == '&')
	return (LESS_AND);
      else if MBTEST(character == '>' && peek_char == '&')
	return (GREATER_AND);
      else if MBTEST(character == '<' && peek_char == '>')
	return (LESS_GREATER);
      else if MBTEST(character == '>' && peek_char == '|')
	return (GREATER_BAR);
      else if MBTEST(character == '&' && peek_char == '>')
	{
	  peek_char = shell_getc (1);
	  if MBTEST(peek_char == '>')
	    return (AND_GREATER_GREATER);
	  else
	    {
	      shell_ungetc (peek_char);
	      return (AND_GREATER);
	    }
	}
      else if MBTEST(character == '|' && peek_char == '&')
	return (BAR_AND);
      else if MBTEST(character == ';' && peek_char == '&')
	{
	  parser_state |= PST_CASEPAT;
#if defined (ALIAS)
	  parser_state &= ~PST_ALEXPNEXT;
#endif /* ALIAS */
	  return (SEMI_AND);
	}

      shell_ungetc (peek_char);

      /* If we look like we are reading the start of a function
	 definition, then let the reader know about it so that
	 we will do the right thing with `{'. */
      if MBTEST(character == ')' && last_read_token == '(' && token_before_that == WORD)
	{
	  parser_state |= PST_ALLOWOPNBRC;
#if defined (ALIAS)
	  parser_state &= ~PST_ALEXPNEXT;
#endif /* ALIAS */
	  function_dstart = line_number;
	}

      /* case pattern lists may be preceded by an optional left paren.  If
	 we're not trying to parse a case pattern list, the left paren
	 indicates a subshell. */
      if MBTEST(character == '(' && (parser_state & PST_CASEPAT) == 0) /* ) */
	parser_state |= PST_SUBSHELL;
      /*(*/
      else if MBTEST((parser_state & PST_CASEPAT) && character == ')')
	parser_state &= ~PST_CASEPAT;
      /*(*/
      else if MBTEST((parser_state & PST_SUBSHELL) && character == ')')
	parser_state &= ~PST_SUBSHELL;

#if defined (PROCESS_SUBSTITUTION)
      /* Check for the constructs which introduce process substitution.
	 Shells running in `posix mode' don't do process substitution. */
      if MBTEST(posixly_correct || ((character != '>' && character != '<') || peek_char != '(')) /*)*/
#endif /* PROCESS_SUBSTITUTION */
	return (character);
    }

  /* Hack <&- (close stdin) case.  Also <&N- (dup and close). */
  if MBTEST(character == '-' && (last_read_token == LESS_AND || last_read_token == GREATER_AND))
    return (character);

tokword:
  /* Okay, if we got this far, we have to read a word.  Read one,
     and then check it against the known ones. */
  result = read_token_word (character);
#if defined (ALIAS)
  if (result == RE_READ_TOKEN)
    goto re_read_token;
#endif
  return result;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\y.tab.c:5,173
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\y.tab.c:5,451
parsing error 
{
  int count, ch, tflags;
  int nestlen, ttranslen, start_lineno;
  char *ret, *nestret, *ttrans;
  int retind, retsize, rflags;
  int dolbrace_state;

  dolbrace_state = (flags & P_DOLBRACE) ? DOLBRACE_PARAM : 0;

/*itrace("parse_matched_pair[%d]: open = %c close = %c flags = %d", line_number, open, close, flags);*/
  count = 1;
  tflags = 0;

  if ((flags & P_COMMAND) && qc != '`' && qc != '\'' && qc != '"' && (flags & P_DQUOTE) == 0)
    tflags |= LEX_CKCOMMENT;

  /* RFLAGS is the set of flags we want to pass to recursive calls. */
  rflags = (qc == '"') ? P_DQUOTE : (flags & P_DQUOTE);

  ret = (char *)xmalloc (retsize = 64);
  retind = 0;

  start_lineno = line_number;
  while (count)
    {
      ch = shell_getc (qc != '\'' && (tflags & (LEX_PASSNEXT)) == 0);

      if (ch == EOF)
	{
	  free (ret);
	  parser_error (start_lineno, _("unexpected EOF while looking for matching `%c'"), close);
	  EOF_Reached = 1;	/* XXX */
	  return (&matched_pair_error);
	}

      /* Possible reprompting. */
      if (ch == '\n' && SHOULD_PROMPT ())
	prompt_again ();

      /* Don't bother counting parens or doing anything else if in a comment
	 or part of a case statement */
      if (tflags & LEX_INCOMMENT)
	{
	  /* Add this character. */
	  RESIZE_MALLOCED_BUFFER (ret, retind, 1, retsize, 64);
	  ret[retind++] = ch;

	  if (ch == '\n')
	    tflags &= ~LEX_INCOMMENT;

	  continue;
	}

      /* Not exactly right yet, should handle shell metacharacters, too.  If
	 any changes are made to this test, make analogous changes to subst.c:
	 extract_delimited_string(). */
      else if MBTEST((tflags & LEX_CKCOMMENT) && (tflags & LEX_INCOMMENT) == 0 && ch == '#' && (retind == 0 || ret[retind-1] == '\n' || shellblank (ret[retind - 1])))
	tflags |= LEX_INCOMMENT;

      if (tflags & LEX_PASSNEXT)		/* last char was backslash */
	{
	  tflags &= ~LEX_PASSNEXT;
	  if (qc != '\'' && ch == '\n')	/* double-quoted \<newline> disappears. */
	    {
	      if (retind > 0)
		retind--;	/* swallow previously-added backslash */
	      continue;
	    }

	  RESIZE_MALLOCED_BUFFER (ret, retind, 2, retsize, 64);
	  if MBTEST(ch == CTLESC || ch == CTLNUL)
	    ret[retind++] = CTLESC;
	  ret[retind++] = ch;
	  continue;
	}
      /* If we're reparsing the input (e.g., from parse_string_to_word_list),
	 we've already prepended CTLESC to single-quoted results of $'...'.
	 We may want to do this for other CTLESC-quoted characters in
	 reparse, too. */
      else if MBTEST((parser_state & PST_REPARSE) && open == '\'' && (ch == CTLESC || ch == CTLNUL))
	{
	  RESIZE_MALLOCED_BUFFER (ret, retind, 1, retsize, 64);
	  ret[retind++] = ch;
	  continue;
	}
      else if MBTEST(ch == CTLESC || ch == CTLNUL)	/* special shell escapes */
	{
	  RESIZE_MALLOCED_BUFFER (ret, retind, 2, retsize, 64);
	  ret[retind++] = CTLESC;
	  ret[retind++] = ch;
	  continue;
	}
      else if MBTEST(ch == close)		/* ending delimiter */
	count--;
      /* handle nested ${...} specially. */
      else if MBTEST(open != close && (tflags & LEX_WASDOL) && open == '{' && ch == open) /* } */
	count++;
      else if MBTEST(((flags & P_FIRSTCLOSE) == 0) && ch == open)	/* nested begin */
	count++;

      /* Add this character. */
      RESIZE_MALLOCED_BUFFER (ret, retind, 1, retsize, 64);
      ret[retind++] = ch;

      /* If we just read the ending character, don't bother continuing. */
      if (count == 0)
	break;

      if (open == '\'')			/* '' inside grouping construct */
	{
	  if MBTEST((flags & P_ALLOWESC) && ch == '\\')
	    tflags |= LEX_PASSNEXT;
	  continue;
	}

      if MBTEST(ch == '\\')			/* backslashes */
	tflags |= LEX_PASSNEXT;

      /* Based on which dolstate is currently in (param, op, or word),
	 decide what the op is.  We're really only concerned if it's % or
	 #, so we can turn on a flag that says whether or not we should
	 treat single quotes as special when inside a double-quoted
	 ${...}. This logic must agree with subst.c:extract_dollar_brace_string
	 since they share the same defines. */
      if (flags & P_DOLBRACE)
        {
          /* ${param%[%]word} */
	  if MBTEST(dolbrace_state == DOLBRACE_PARAM && ch == '%' && retind > 1)
	    dolbrace_state = DOLBRACE_QUOTE;
          /* ${param#[#]word} */
	  else if MBTEST(dolbrace_state == DOLBRACE_PARAM && ch == '#' && retind > 1)
	    dolbrace_state = DOLBRACE_QUOTE;
          /* ${param/[/]pat/rep} */
	  else if MBTEST(dolbrace_state == DOLBRACE_PARAM && ch == '/' && retind > 1)
	    dolbrace_state = DOLBRACE_QUOTE;
          /* ${param^[^]pat} */
	  else if MBTEST(dolbrace_state == DOLBRACE_PARAM && ch == '^' && retind > 1)
	    dolbrace_state = DOLBRACE_QUOTE;
          /* ${param,[,]pat} */
	  else if MBTEST(dolbrace_state == DOLBRACE_PARAM && ch == ',' && retind > 1)
	    dolbrace_state = DOLBRACE_QUOTE;
	  else if MBTEST(dolbrace_state == DOLBRACE_PARAM && strchr ("#%^,~:-=?+/", ch) != 0)
	    dolbrace_state = DOLBRACE_OP;
	  else if MBTEST(dolbrace_state == DOLBRACE_OP && strchr ("#%^,~:-=?+/", ch) == 0)
	    dolbrace_state = DOLBRACE_WORD;
        }

      /* The big hammer.  Single quotes aren't special in double quotes.  The
         problem is that Posix used to say the single quotes are semi-special:
         within a double-quoted ${...} construct "an even number of
         unescaped double-quotes or single-quotes, if any, shall occur." */
      /* This was changed in Austin Group Interp 221 */
      if MBTEST(posixly_correct && shell_compatibility_level > 41 && dolbrace_state != DOLBRACE_QUOTE && (flags & P_DQUOTE) && (flags & P_DOLBRACE) && ch == '\'')
	continue;

      /* Could also check open == '`' if we want to parse grouping constructs
	 inside old-style command substitution. */
      if (open != close)		/* a grouping construct */
	{
	  if MBTEST(shellquote (ch))
	    {
	      /* '', ``, or "" inside $(...) or other grouping construct. */
	      push_delimiter (dstack, ch);
	      if MBTEST((tflags & LEX_WASDOL) && ch == '\'')	/* $'...' inside group */
		nestret = parse_matched_pair (ch, ch, ch, &nestlen, P_ALLOWESC|rflags);
	      else
		nestret = parse_matched_pair (ch, ch, ch, &nestlen, rflags);
	      pop_delimiter (dstack);
	      CHECK_NESTRET_ERROR ();

	      if MBTEST((tflags & LEX_WASDOL) && ch == '\'' && (extended_quote || (rflags & P_DQUOTE) == 0))
		{
		  /* Translate $'...' here. */
		  ttrans = ansiexpand (nestret, 0, nestlen - 1, &ttranslen);
		  xfree (nestret);

		  if ((rflags & P_DQUOTE) == 0)
		    {
		      nestret = sh_single_quote (ttrans);
		      free (ttrans);
		      nestlen = strlen (nestret);
		    }
		  else
		    {
		      nestret = ttrans;
		      nestlen = ttranslen;
		    }
		  retind -= 2;		/* back up before the $' */
		}
	      else if MBTEST((tflags & LEX_WASDOL) && ch == '"' && (extended_quote || (rflags & P_DQUOTE) == 0))
		{
		  /* Locale expand $"..." here. */
		  ttrans = localeexpand (nestret, 0, nestlen - 1, start_lineno, &ttranslen);
		  xfree (nestret);

		  nestret = sh_mkdoublequoted (ttrans, ttranslen, 0);
		  free (ttrans);
		  nestlen = ttranslen + 2;
		  retind -= 2;		/* back up before the $" */
		}

	      APPEND_NESTRET ();
	      FREE (nestret);
	    }
	  else if ((flags & P_ARRAYSUB) && (tflags & LEX_WASDOL) && (ch == '(' || ch == '{' || ch == '['))	/* ) } ] */
	    goto parse_dollar_word;
	}
      /* Parse an old-style command substitution within double quotes as a
	 single word. */
      /* XXX - sh and ksh93 don't do this - XXX */
      else if MBTEST(open == '"' && ch == '`')
	{
	  nestret = parse_matched_pair (0, '`', '`', &nestlen, rflags);

	  CHECK_NESTRET_ERROR ();
	  APPEND_NESTRET ();

	  FREE (nestret);
	}
      else if MBTEST(open != '`' && (tflags & LEX_WASDOL) && (ch == '(' || ch == '{' || ch == '['))	/* ) } ] */
	/* check for $(), $[], or ${} inside quoted string. */
	{
parse_dollar_word:
	  if (open == ch)	/* undo previous increment */
	    count--;
	  if (ch == '(')		/* ) */
	    nestret = parse_comsub (0, '(', ')', &nestlen, (rflags|P_COMMAND) & ~P_DQUOTE);
	  else if (ch == '{')		/* } */
	    nestret = parse_matched_pair (0, '{', '}', &nestlen, P_FIRSTCLOSE|P_DOLBRACE|rflags);
	  else if (ch == '[')		/* ] */
	    nestret = parse_matched_pair (0, '[', ']', &nestlen, rflags);

	  CHECK_NESTRET_ERROR ();
	  APPEND_NESTRET ();

	  FREE (nestret);
	}
      if MBTEST(ch == '$')
	tflags |= LEX_WASDOL;
      else
	tflags &= ~LEX_WASDOL;
    }

  ret[retind] = '\0';
  if (lenp)
    *lenp = retind;
/*itrace("parse_matched_pair[%d]: returning %s", line_number, ret);*/
  return ret;
}
warning: parse error {
  int count, ch, tflags;
  int nestlen, ttranslen, start_lineno;
  char *ret, *nestret, *ttrans;
  int retind, retsize, rflags;
  int dolbrace_state;

  dolbrace_state = (flags & P_DOLBRACE) ? DOLBRACE_PARAM : 0;

/*itrace("parse_matched_pair[%d]: open = %c close = %c flags = %d", line_number, open, close, flags);*/
  count = 1;
  tflags = 0;

  if ((flags & P_COMMAND) && qc != '`' && qc != '\'' && qc != '"' && (flags & P_DQUOTE) == 0)
    tflags |= LEX_CKCOMMENT;

  /* RFLAGS is the set of flags we want to pass to recursive calls. */
  rflags = (qc == '"') ? P_DQUOTE : (flags & P_DQUOTE);

  ret = (char *)xmalloc (retsize = 64);
  retind = 0;

  start_lineno = line_number;
  while (count)
    {
      ch = shell_getc (qc != '\'' && (tflags & (LEX_PASSNEXT)) == 0);

      if (ch == EOF)
	{
	  free (ret);
	  parser_error (start_lineno, _("unexpected EOF while looking for matching `%c'"), close);
	  EOF_Reached = 1;	/* XXX */
	  return (&matched_pair_error);
	}

      /* Possible reprompting. */
      if (ch == '\n' && SHOULD_PROMPT ())
	prompt_again ();

      /* Don't bother counting parens or doing anything else if in a comment
	 or part of a case statement */
      if (tflags & LEX_INCOMMENT)
	{
	  /* Add this character. */
	  RESIZE_MALLOCED_BUFFER (ret, retind, 1, retsize, 64);
	  ret[retind++] = ch;

	  if (ch == '\n')
	    tflags &= ~LEX_INCOMMENT;

	  continue;
	}

      /* Not exactly right yet, should handle shell metacharacters, too.  If
	 any changes are made to this test, make analogous changes to subst.c:
	 extract_delimited_string(). */
      else if MBTEST((tflags & LEX_CKCOMMENT) && (tflags & LEX_INCOMMENT) == 0 && ch == '#' && (retind == 0 || ret[retind-1] == '\n' || shellblank (ret[retind - 1])))
	tflags |= LEX_INCOMMENT;

      if (tflags & LEX_PASSNEXT)		/* last char was backslash */
	{
	  tflags &= ~LEX_PASSNEXT;
	  if (qc != '\'' && ch == '\n')	/* double-quoted \<newline> disappears. */
	    {
	      if (retind > 0)
		retind--;	/* swallow previously-added backslash */
	      continue;
	    }

	  RESIZE_MALLOCED_BUFFER (ret, retind, 2, retsize, 64);
	  if MBTEST(ch == CTLESC || ch == CTLNUL)
	    ret[retind++] = CTLESC;
	  ret[retind++] = ch;
	  continue;
	}
      /* If we're reparsing the input (e.g., from parse_string_to_word_list),
	 we've already prepended CTLESC to single-quoted results of $'...'.
	 We may want to do this for other CTLESC-quoted characters in
	 reparse, too. */
      else if MBTEST((parser_state & PST_REPARSE) && open == '\'' && (ch == CTLESC || ch == CTLNUL))
	{
	  RESIZE_MALLOCED_BUFFER (ret, retind, 1, retsize, 64);
	  ret[retind++] = ch;
	  continue;
	}
      else if MBTEST(ch == CTLESC || ch == CTLNUL)	/* special shell escapes */
	{
	  RESIZE_MALLOCED_BUFFER (ret, retind, 2, retsize, 64);
	  ret[retind++] = CTLESC;
	  ret[retind++] = ch;
	  continue;
	}
      else if MBTEST(ch == close)		/* ending delimiter */
	count--;
      /* handle nested ${...} specially. */
      else if MBTEST(open != close && (tflags & LEX_WASDOL) && open == '{' && ch == open) /* } */
	count++;
      else if MBTEST(((flags & P_FIRSTCLOSE) == 0) && ch == open)	/* nested begin */
	count++;

      /* Add this character. */
      RESIZE_MALLOCED_BUFFER (ret, retind, 1, retsize, 64);
      ret[retind++] = ch;

      /* If we just read the ending character, don't bother continuing. */
      if (count == 0)
	break;

      if (open == '\'')			/* '' inside grouping construct */
	{
	  if MBTEST((flags & P_ALLOWESC) && ch == '\\')
	    tflags |= LEX_PASSNEXT;
	  continue;
	}

      if MBTEST(ch == '\\')			/* backslashes */
	tflags |= LEX_PASSNEXT;

      /* Based on which dolstate is currently in (param, op, or word),
	 decide what the op is.  We're really only concerned if it's % or
	 #, so we can turn on a flag that says whether or not we should
	 treat single quotes as special when inside a double-quoted
	 ${...}. This logic must agree with subst.c:extract_dollar_brace_string
	 since they share the same defines. */
      if (flags & P_DOLBRACE)
        {
          /* ${param%[%]word} */
	  if MBTEST(dolbrace_state == DOLBRACE_PARAM && ch == '%' && retind > 1)
	    dolbrace_state = DOLBRACE_QUOTE;
          /* ${param#[#]word} */
	  else if MBTEST(dolbrace_state == DOLBRACE_PARAM && ch == '#' && retind > 1)
	    dolbrace_state = DOLBRACE_QUOTE;
          /* ${param/[/]pat/rep} */
	  else if MBTEST(dolbrace_state == DOLBRACE_PARAM && ch == '/' && retind > 1)
	    dolbrace_state = DOLBRACE_QUOTE;
          /* ${param^[^]pat} */
	  else if MBTEST(dolbrace_state == DOLBRACE_PARAM && ch == '^' && retind > 1)
	    dolbrace_state = DOLBRACE_QUOTE;
          /* ${param,[,]pat} */
	  else if MBTEST(dolbrace_state == DOLBRACE_PARAM && ch == ',' && retind > 1)
	    dolbrace_state = DOLBRACE_QUOTE;
	  else if MBTEST(dolbrace_state == DOLBRACE_PARAM && strchr ("#%^,~:-=?+/", ch) != 0)
	    dolbrace_state = DOLBRACE_OP;
	  else if MBTEST(dolbrace_state == DOLBRACE_OP && strchr ("#%^,~:-=?+/", ch) == 0)
	    dolbrace_state = DOLBRACE_WORD;
        }

      /* The big hammer.  Single quotes aren't special in double quotes.  The
         problem is that Posix used to say the single quotes are semi-special:
         within a double-quoted ${...} construct "an even number of
         unescaped double-quotes or single-quotes, if any, shall occur." */
      /* This was changed in Austin Group Interp 221 */
      if MBTEST(posixly_correct && shell_compatibility_level > 41 && dolbrace_state != DOLBRACE_QUOTE && (flags & P_DQUOTE) && (flags & P_DOLBRACE) && ch == '\'')
	continue;

      /* Could also check open == '`' if we want to parse grouping constructs
	 inside old-style command substitution. */
      if (open != close)		/* a grouping construct */
	{
	  if MBTEST(shellquote (ch))
	    {
	      /* '', ``, or "" inside $(...) or other grouping construct. */
	      push_delimiter (dstack, ch);
	      if MBTEST((tflags & LEX_WASDOL) && ch == '\'')	/* $'...' inside group */
		nestret = parse_matched_pair (ch, ch, ch, &nestlen, P_ALLOWESC|rflags);
	      else
		nestret = parse_matched_pair (ch, ch, ch, &nestlen, rflags);
	      pop_delimiter (dstack);
	      CHECK_NESTRET_ERROR ();

	      if MBTEST((tflags & LEX_WASDOL) && ch == '\'' && (extended_quote || (rflags & P_DQUOTE) == 0))
		{
		  /* Translate $'...' here. */
		  ttrans = ansiexpand (nestret, 0, nestlen - 1, &ttranslen);
		  xfree (nestret);

		  if ((rflags & P_DQUOTE) == 0)
		    {
		      nestret = sh_single_quote (ttrans);
		      free (ttrans);
		      nestlen = strlen (nestret);
		    }
		  else
		    {
		      nestret = ttrans;
		      nestlen = ttranslen;
		    }
		  retind -= 2;		/* back up before the $' */
		}
	      else if MBTEST((tflags & LEX_WASDOL) && ch == '"' && (extended_quote || (rflags & P_DQUOTE) == 0))
		{
		  /* Locale expand $"..." here. */
		  ttrans = localeexpand (nestret, 0, nestlen - 1, start_lineno, &ttranslen);
		  xfree (nestret);

		  nestret = sh_mkdoublequoted (ttrans, ttranslen, 0);
		  free (ttrans);
		  nestlen = ttranslen + 2;
		  retind -= 2;		/* back up before the $" */
		}

	      APPEND_NESTRET ();
	      FREE (nestret);
	    }
	  else if ((flags & P_ARRAYSUB) && (tflags & LEX_WASDOL) && (ch == '(' || ch == '{' || ch == '['))	/* ) } ] */
	    goto parse_dollar_word;
	}
      /* Parse an old-style command substitution within double quotes as a
	 single word. */
      /* XXX - sh and ksh93 don't do this - XXX */
      else if MBTEST(open == '"' && ch == '`')
	{
	  nestret = parse_matched_pair (0, '`', '`', &nestlen, rflags);

	  CHECK_NESTRET_ERROR ();
	  APPEND_NESTRET ();

	  FREE (nestret);
	}
      else if MBTEST(open != '`' && (tflags & LEX_WASDOL) && (ch == '(' || ch == '{' || ch == '['))	/* ) } ] */
	/* check for $(), $[], or ${} inside quoted string. */
	{
parse_dollar_word:
	  if (open == ch)	/* undo previous increment */
	    count--;
	  if (ch == '(')		/* ) */
	    nestret = parse_comsub (0, '(', ')', &nestlen, (rflags|P_COMMAND) & ~P_DQUOTE);
	  else if (ch == '{')		/* } */
	    nestret = parse_matched_pair (0, '{', '}', &nestlen, P_FIRSTCLOSE|P_DOLBRACE|rflags);
	  else if (ch == '[')		/* ] */
	    nestret = parse_matched_pair (0, '[', ']', &nestlen, rflags);

	  CHECK_NESTRET_ERROR ();
	  APPEND_NESTRET ();

	  FREE (nestret);
	}
      if MBTEST(ch == '$')
	tflags |= LEX_WASDOL;
      else
	tflags &= ~LEX_WASDOL;
    }

  ret[retind] = '\0';
  if (lenp)
    *lenp = retind;
/*itrace("parse_matched_pair[%d]: returning %s", line_number, ret);*/
  return ret;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\y.tab.c:5,455
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\y.tab.c:5,708
parsing error 
{
  int count, ch, peekc, tflags, lex_rwlen, lex_wlen, lex_firstind;
  int nestlen, ttranslen, start_lineno;
  char *ret, *nestret, *ttrans, *heredelim;
  int retind, retsize, rflags, hdlen;

  /* Posix interp 217 says arithmetic expressions have precedence, so
     assume $(( introduces arithmetic expansion and parse accordingly. */
  peekc = shell_getc (0);
  shell_ungetc (peekc);
  if (peekc == '(')
    return (parse_matched_pair (qc, open, close, lenp, 0));

/*itrace("parse_comsub: qc = `%c' open = %c close = %c", qc, open, close);*/
  count = 1;
  tflags = LEX_RESWDOK;

  if ((flags & P_COMMAND) && qc != '\'' && qc != '"' && (flags & P_DQUOTE) == 0)
    tflags |= LEX_CKCASE;
  if ((tflags & LEX_CKCASE) && (interactive == 0 || interactive_comments))
    tflags |= LEX_CKCOMMENT;

  /* RFLAGS is the set of flags we want to pass to recursive calls. */
  rflags = (flags & P_DQUOTE);

  ret = (char *)xmalloc (retsize = 64);
  retind = 0;

  start_lineno = line_number;
  lex_rwlen = lex_wlen = 0;

  heredelim = 0;
  lex_firstind = -1;

  while (count)
    {
comsub_readchar:
      ch = shell_getc (qc != '\'' && (tflags & (LEX_INCOMMENT|LEX_PASSNEXT)) == 0);

      if (ch == EOF)
	{
eof_error:
	  free (ret);
	  FREE (heredelim);
	  parser_error (start_lineno, _("unexpected EOF while looking for matching `%c'"), close);
	  EOF_Reached = 1;	/* XXX */
	  return (&matched_pair_error);
	}

      /* If we hit the end of a line and are reading the contents of a here
	 document, and it's not the same line that the document starts on,
	 check for this line being the here doc delimiter.  Otherwise, if
	 we're in a here document, mark the next character as the beginning
	 of a line. */
      if (ch == '\n')
	{
	  if ((tflags & LEX_HEREDELIM) && heredelim)
	    {
	      tflags &= ~LEX_HEREDELIM;
	      tflags |= LEX_INHEREDOC;
	      lex_firstind = retind + 1;
	    }
	  else if (tflags & LEX_INHEREDOC)
	    {
	      int tind;
	      tind = lex_firstind;
	      while ((tflags & LEX_STRIPDOC) && ret[tind] == '\t')
		tind++;
	      if (STREQN (ret + tind, heredelim, hdlen))
		{
		  tflags &= ~(LEX_STRIPDOC|LEX_INHEREDOC);
/*itrace("parse_comsub:%d: found here doc end `%s'", line_number, ret + tind);*/
		  free (heredelim);
		  heredelim = 0;
		  lex_firstind = -1;
		}
	      else
		lex_firstind = retind + 1;
	    }
	}

      /* Possible reprompting. */
      if (ch == '\n' && SHOULD_PROMPT ())
	prompt_again ();

      /* XXX -- possibly allow here doc to be delimited by ending right
	 paren. */
      if ((tflags & LEX_INHEREDOC) && ch == close && count == 1)
	{
	  int tind;
/*itrace("parse_comsub: in here doc, ch == close, retind - firstind = %d hdlen = %d retind = %d", retind-lex_firstind, hdlen, retind);*/
	  tind = lex_firstind;
	  while ((tflags & LEX_STRIPDOC) && ret[tind] == '\t')
	    tind++;
	  if (retind-tind == hdlen && STREQN (ret + tind, heredelim, hdlen))
	    {
	      tflags &= ~(LEX_STRIPDOC|LEX_INHEREDOC);
/*itrace("parse_comsub:%d: found here doc end `%s'", line_number, ret + tind);*/
	      free (heredelim);
	      heredelim = 0;
	      lex_firstind = -1;
	    }
	}

      /* Don't bother counting parens or doing anything else if in a comment */
      if (tflags & (LEX_INCOMMENT|LEX_INHEREDOC))
	{
	  /* Add this character. */
	  RESIZE_MALLOCED_BUFFER (ret, retind, 1, retsize, 64);
	  ret[retind++] = ch;

	  if ((tflags & LEX_INCOMMENT) && ch == '\n')
{
/*itrace("parse_comsub:%d: lex_incomment -> 0 ch = `%c'", line_number, ch);*/
	    tflags &= ~LEX_INCOMMENT;
}

	  continue;
	}

      if (tflags & LEX_PASSNEXT)		/* last char was backslash */
	{
/*itrace("parse_comsub:%d: lex_passnext -> 0 ch = `%c' (%d)", line_number, ch, __LINE__);*/
	  tflags &= ~LEX_PASSNEXT;
	  if (qc != '\'' && ch == '\n')	/* double-quoted \<newline> disappears. */
	    {
	      if (retind > 0)
		retind--;	/* swallow previously-added backslash */
	      continue;
	    }

	  RESIZE_MALLOCED_BUFFER (ret, retind, 2, retsize, 64);
	  if MBTEST(ch == CTLESC || ch == CTLNUL)
	    ret[retind++] = CTLESC;
	  ret[retind++] = ch;
	  continue;
	}

      /* If this is a shell break character, we are not in a word.  If not,
	 we either start or continue a word. */
      if MBTEST(shellbreak (ch))
	{
	  tflags &= ~LEX_INWORD;
/*itrace("parse_comsub:%d: lex_inword -> 0 ch = `%c' (%d)", line_number, ch, __LINE__);*/
	}
      else
	{
	  if (tflags & LEX_INWORD)
	    {
	      lex_wlen++;
/*itrace("parse_comsub:%d: lex_inword == 1 ch = `%c' lex_wlen = %d (%d)", line_number, ch, lex_wlen, __LINE__);*/
	    }	      
	  else
	    {
/*itrace("parse_comsub:%d: lex_inword -> 1 ch = `%c' (%d)", line_number, ch, __LINE__);*/
	      tflags |= LEX_INWORD;
	      lex_wlen = 0;
	    }
	}

      /* Skip whitespace */
      if MBTEST(shellblank (ch) && (tflags & LEX_HEREDELIM) == 0 && lex_rwlen == 0)
        {
	  /* Add this character. */
	  RESIZE_MALLOCED_BUFFER (ret, retind, 1, retsize, 64);
	  ret[retind++] = ch;
	  continue;
        }

      /* Either we are looking for the start of the here-doc delimiter
	 (lex_firstind == -1) or we are reading one (lex_firstind >= 0).
	 If this character is a shell break character and we are reading
	 the delimiter, save it and note that we are now reading a here
	 document.  If we've found the start of the delimiter, note it by
	 setting lex_firstind.  Backslashes can quote shell metacharacters
	 in here-doc delimiters. */
      if (tflags & LEX_HEREDELIM)
	{
	  if (lex_firstind == -1 && shellbreak (ch) == 0)
	    lex_firstind = retind;
#if 0
	  else if (heredelim && (tflags & LEX_PASSNEXT) == 0 && ch == '\n')
	    {
	      tflags |= LEX_INHEREDOC;
	      tflags &= ~LEX_HEREDELIM;
	      lex_firstind = retind + 1;
	    }
#endif
	  else if (lex_firstind >= 0 && (tflags & LEX_PASSNEXT) == 0 && shellbreak (ch))
	    {
	      if (heredelim == 0)
		{
		  nestret = substring (ret, lex_firstind, retind);
		  heredelim = string_quote_removal (nestret, 0);
		  free (nestret);
		  hdlen = STRLEN(heredelim);
/*itrace("parse_comsub:%d: found here doc delimiter `%s' (%d)", line_number, heredelim, hdlen);*/
		}
	      if (ch == '\n')
		{
		  tflags |= LEX_INHEREDOC;
		  tflags &= ~LEX_HEREDELIM;
		  lex_firstind = retind + 1;
		}
	      else
		lex_firstind = -1;
	    }
	}

      /* Meta-characters that can introduce a reserved word.  Not perfect yet. */
      if MBTEST((tflags & LEX_RESWDOK) == 0 && (tflags & LEX_CKCASE) && (tflags & LEX_INCOMMENT) == 0 && (shellmeta(ch) || ch == '\n'))
	{
	  /* Add this character. */
	  RESIZE_MALLOCED_BUFFER (ret, retind, 1, retsize, 64);
	  ret[retind++] = ch;
	  peekc = shell_getc (1);
	  if (ch == peekc && (ch == '&' || ch == '|' || ch == ';'))	/* two-character tokens */
	    {
	      RESIZE_MALLOCED_BUFFER (ret, retind, 1, retsize, 64);
	      ret[retind++] = peekc;
/*itrace("parse_comsub:%d: set lex_reswordok = 1, ch = `%c'", line_number, ch);*/
	      tflags |= LEX_RESWDOK;
	      lex_rwlen = 0;
	      continue;
	    }
	  else if (ch == '\n' || COMSUB_META(ch))
	    {
	      shell_ungetc (peekc);
/*itrace("parse_comsub:%d: set lex_reswordok = 1, ch = `%c'", line_number, ch);*/
	      tflags |= LEX_RESWDOK;
	      lex_rwlen = 0;
	      continue;
	    }
	  else if (ch == EOF)
	    goto eof_error;
	  else
	    {
	      /* `unget' the character we just added and fall through */
	      retind--;
	      shell_ungetc (peekc);
	    }
	}

      /* If we can read a reserved word, try to read one. */
      if (tflags & LEX_RESWDOK)
	{
	  if MBTEST(islower (ch))
	    {
	      /* Add this character. */
	      RESIZE_MALLOCED_BUFFER (ret, retind, 1, retsize, 64);
	      ret[retind++] = ch;
	      lex_rwlen++;
	      continue;
	    }
	  else if MBTEST(lex_rwlen == 4 && shellbreak (ch))
	    {
	      if (STREQN (ret + retind - 4, "case", 4))
{
		tflags |= LEX_INCASE;
/*itrace("parse_comsub:%d: found `case', lex_incase -> 1 lex_reswdok -> 0", line_number);*/
}
	      else if (STREQN (ret + retind - 4, "esac", 4))
{
		tflags &= ~LEX_INCASE;
/*itrace("parse_comsub:%d: found `esac', lex_incase -> 0 lex_reswdok -> 0", line_number);*/
}	        
	      tflags &= ~LEX_RESWDOK;
	    }
	  else if MBTEST((tflags & LEX_CKCOMMENT) && ch == '#' && (lex_rwlen == 0 || ((tflags & LEX_INWORD) && lex_wlen == 0)))
	    ;	/* don't modify LEX_RESWDOK if we're starting a comment */
	  else if MBTEST((tflags & LEX_INCASE) && ch != '\n')
	    /* If we can read a reserved word and we're in case, we're at the
	       point where we can read a new pattern list or an esac.  We
	       handle the esac case above.  If we read a newline, we want to
	       leave LEX_RESWDOK alone.  If we read anything else, we want to
	       turn off LEX_RESWDOK, since we're going to read a pattern list. */
{
	    tflags &= ~LEX_RESWDOK;
/*itrace("parse_comsub:%d: lex_incase == 1 found `%c', lex_reswordok -> 0", line_number, ch);*/
}
	  else if MBTEST(shellbreak (ch) == 0)
{
	    tflags &= ~LEX_RESWDOK;
/*itrace("parse_comsub:%d: found `%c', lex_reswordok -> 0", line_number, ch);*/
}
	}

      /* Might be the start of a here-doc delimiter */
      if MBTEST((tflags & LEX_INCOMMENT) == 0 && (tflags & LEX_CKCASE) && ch == '<')
	{
	  /* Add this character. */
	  RESIZE_MALLOCED_BUFFER (ret, retind, 1, retsize, 64);
	  ret[retind++] = ch;
	  peekc = shell_getc (1);
	  if (peekc == EOF)
	    goto eof_error;
	  if (peekc == ch)
	    {
	      RESIZE_MALLOCED_BUFFER (ret, retind, 1, retsize, 64);
	      ret[retind++] = peekc;
	      peekc = shell_getc (1);
	      if (peekc == EOF)
		goto eof_error;
	      if (peekc == '-')
		{
		  RESIZE_MALLOCED_BUFFER (ret, retind, 1, retsize, 64);
		  ret[retind++] = peekc;
		  tflags |= LEX_STRIPDOC;
		}
	      else
		shell_ungetc (peekc);
	      if (peekc != '<')
		{
		  tflags |= LEX_HEREDELIM;
		  lex_firstind = -1;
		}
	      continue;
	    }
	  else
	    ch = peekc;		/* fall through and continue XXX */
	}
      else if MBTEST((tflags & LEX_CKCOMMENT) && (tflags & LEX_INCOMMENT) == 0 && ch == '#' && (((tflags & LEX_RESWDOK) && lex_rwlen == 0) || ((tflags & LEX_INWORD) && lex_wlen == 0)))
{
/*itrace("parse_comsub:%d: lex_incomment -> 1 (%d)", line_number, __LINE__);*/
	tflags |= LEX_INCOMMENT;
}

      if MBTEST(ch == CTLESC || ch == CTLNUL)	/* special shell escapes */
	{
	  RESIZE_MALLOCED_BUFFER (ret, retind, 2, retsize, 64);
	  ret[retind++] = CTLESC;
	  ret[retind++] = ch;
	  continue;
	}
#if 0
      else if MBTEST((tflags & LEX_INCASE) && ch == close && close == ')')
        tflags &= ~LEX_INCASE;		/* XXX */
#endif
      else if MBTEST(ch == close && (tflags & LEX_INCASE) == 0)		/* ending delimiter */
{
	count--;
/*itrace("parse_comsub:%d: found close: count = %d", line_number, count);*/
}
      else if MBTEST(((flags & P_FIRSTCLOSE) == 0) && (tflags & LEX_INCASE) == 0 && ch == open)	/* nested begin */
{
	count++;
/*itrace("parse_comsub:%d: found open: count = %d", line_number, count);*/
}

      /* Add this character. */
      RESIZE_MALLOCED_BUFFER (ret, retind, 1, retsize, 64);
      ret[retind++] = ch;

      /* If we just read the ending character, don't bother continuing. */
      if (count == 0)
	break;

      if MBTEST(ch == '\\')			/* backslashes */
	tflags |= LEX_PASSNEXT;

      if MBTEST(shellquote (ch))
        {
          /* '', ``, or "" inside $(...). */
          push_delimiter (dstack, ch);
          if MBTEST((tflags & LEX_WASDOL) && ch == '\'')	/* $'...' inside group */
	    nestret = parse_matched_pair (ch, ch, ch, &nestlen, P_ALLOWESC|rflags);
	  else
	    nestret = parse_matched_pair (ch, ch, ch, &nestlen, rflags);
	  pop_delimiter (dstack);
	  CHECK_NESTRET_ERROR ();

	  if MBTEST((tflags & LEX_WASDOL) && ch == '\'' && (extended_quote || (rflags & P_DQUOTE) == 0))
	    {
	      /* Translate $'...' here. */
	      ttrans = ansiexpand (nestret, 0, nestlen - 1, &ttranslen);
	      xfree (nestret);

	      if ((rflags & P_DQUOTE) == 0)
		{
		  nestret = sh_single_quote (ttrans);
		  free (ttrans);
		  nestlen = strlen (nestret);
		}
	      else
		{
		  nestret = ttrans;
		  nestlen = ttranslen;
		}
	      retind -= 2;		/* back up before the $' */
	    }
	  else if MBTEST((tflags & LEX_WASDOL) && ch == '"' && (extended_quote || (rflags & P_DQUOTE) == 0))
	    {
	      /* Locale expand $"..." here. */
	      ttrans = localeexpand (nestret, 0, nestlen - 1, start_lineno, &ttranslen);
	      xfree (nestret);

	      nestret = sh_mkdoublequoted (ttrans, ttranslen, 0);
	      free (ttrans);
	      nestlen = ttranslen + 2;
	      retind -= 2;		/* back up before the $" */
	    }

	  APPEND_NESTRET ();
	  FREE (nestret);
	}
      else if MBTEST((tflags & LEX_WASDOL) && (ch == '(' || ch == '{' || ch == '['))	/* ) } ] */
	/* check for $(), $[], or ${} inside command substitution. */
	{
	  if ((tflags & LEX_INCASE) == 0 && open == ch)	/* undo previous increment */
	    count--;
	  if (ch == '(')		/* ) */
	    nestret = parse_comsub (0, '(', ')', &nestlen, (rflags|P_COMMAND) & ~P_DQUOTE);
	  else if (ch == '{')		/* } */
	    nestret = parse_matched_pair (0, '{', '}', &nestlen, P_FIRSTCLOSE|P_DOLBRACE|rflags);
	  else if (ch == '[')		/* ] */
	    nestret = parse_matched_pair (0, '[', ']', &nestlen, rflags);

	  CHECK_NESTRET_ERROR ();
	  APPEND_NESTRET ();

	  FREE (nestret);
	}
      if MBTEST(ch == '$')
	tflags |= LEX_WASDOL;
      else
	tflags &= ~LEX_WASDOL;
    }

  FREE (heredelim);
  ret[retind] = '\0';
  if (lenp)
    *lenp = retind;
/*itrace("parse_comsub:%d: returning `%s'", line_number, ret);*/
  return ret;
}
warning: parse error {
  int count, ch, peekc, tflags, lex_rwlen, lex_wlen, lex_firstind;
  int nestlen, ttranslen, start_lineno;
  char *ret, *nestret, *ttrans, *heredelim;
  int retind, retsize, rflags, hdlen;

  /* Posix interp 217 says arithmetic expressions have precedence, so
     assume $(( introduces arithmetic expansion and parse accordingly. */
  peekc = shell_getc (0);
  shell_ungetc (peekc);
  if (peekc == '(')
    return (parse_matched_pair (qc, open, close, lenp, 0));

/*itrace("parse_comsub: qc = `%c' open = %c close = %c", qc, open, close);*/
  count = 1;
  tflags = LEX_RESWDOK;

  if ((flags & P_COMMAND) && qc != '\'' && qc != '"' && (flags & P_DQUOTE) == 0)
    tflags |= LEX_CKCASE;
  if ((tflags & LEX_CKCASE) && (interactive == 0 || interactive_comments))
    tflags |= LEX_CKCOMMENT;

  /* RFLAGS is the set of flags we want to pass to recursive calls. */
  rflags = (flags & P_DQUOTE);

  ret = (char *)xmalloc (retsize = 64);
  retind = 0;

  start_lineno = line_number;
  lex_rwlen = lex_wlen = 0;

  heredelim = 0;
  lex_firstind = -1;

  while (count)
    {
comsub_readchar:
      ch = shell_getc (qc != '\'' && (tflags & (LEX_INCOMMENT|LEX_PASSNEXT)) == 0);

      if (ch == EOF)
	{
eof_error:
	  free (ret);
	  FREE (heredelim);
	  parser_error (start_lineno, _("unexpected EOF while looking for matching `%c'"), close);
	  EOF_Reached = 1;	/* XXX */
	  return (&matched_pair_error);
	}

      /* If we hit the end of a line and are reading the contents of a here
	 document, and it's not the same line that the document starts on,
	 check for this line being the here doc delimiter.  Otherwise, if
	 we're in a here document, mark the next character as the beginning
	 of a line. */
      if (ch == '\n')
	{
	  if ((tflags & LEX_HEREDELIM) && heredelim)
	    {
	      tflags &= ~LEX_HEREDELIM;
	      tflags |= LEX_INHEREDOC;
	      lex_firstind = retind + 1;
	    }
	  else if (tflags & LEX_INHEREDOC)
	    {
	      int tind;
	      tind = lex_firstind;
	      while ((tflags & LEX_STRIPDOC) && ret[tind] == '\t')
		tind++;
	      if (STREQN (ret + tind, heredelim, hdlen))
		{
		  tflags &= ~(LEX_STRIPDOC|LEX_INHEREDOC);
/*itrace("parse_comsub:%d: found here doc end `%s'", line_number, ret + tind);*/
		  free (heredelim);
		  heredelim = 0;
		  lex_firstind = -1;
		}
	      else
		lex_firstind = retind + 1;
	    }
	}

      /* Possible reprompting. */
      if (ch == '\n' && SHOULD_PROMPT ())
	prompt_again ();

      /* XXX -- possibly allow here doc to be delimited by ending right
	 paren. */
      if ((tflags & LEX_INHEREDOC) && ch == close && count == 1)
	{
	  int tind;
/*itrace("parse_comsub: in here doc, ch == close, retind - firstind = %d hdlen = %d retind = %d", retind-lex_firstind, hdlen, retind);*/
	  tind = lex_firstind;
	  while ((tflags & LEX_STRIPDOC) && ret[tind] == '\t')
	    tind++;
	  if (retind-tind == hdlen && STREQN (ret + tind, heredelim, hdlen))
	    {
	      tflags &= ~(LEX_STRIPDOC|LEX_INHEREDOC);
/*itrace("parse_comsub:%d: found here doc end `%s'", line_number, ret + tind);*/
	      free (heredelim);
	      heredelim = 0;
	      lex_firstind = -1;
	    }
	}

      /* Don't bother counting parens or doing anything else if in a comment */
      if (tflags & (LEX_INCOMMENT|LEX_INHEREDOC))
	{
	  /* Add this character. */
	  RESIZE_MALLOCED_BUFFER (ret, retind, 1, retsize, 64);
	  ret[retind++] = ch;

	  if ((tflags & LEX_INCOMMENT) && ch == '\n')
{
/*itrace("parse_comsub:%d: lex_incomment -> 0 ch = `%c'", line_number, ch);*/
	    tflags &= ~LEX_INCOMMENT;
}

	  continue;
	}

      if (tflags & LEX_PASSNEXT)		/* last char was backslash */
	{
/*itrace("parse_comsub:%d: lex_passnext -> 0 ch = `%c' (%d)", line_number, ch, __LINE__);*/
	  tflags &= ~LEX_PASSNEXT;
	  if (qc != '\'' && ch == '\n')	/* double-quoted \<newline> disappears. */
	    {
	      if (retind > 0)
		retind--;	/* swallow previously-added backslash */
	      continue;
	    }

	  RESIZE_MALLOCED_BUFFER (ret, retind, 2, retsize, 64);
	  if MBTEST(ch == CTLESC || ch == CTLNUL)
	    ret[retind++] = CTLESC;
	  ret[retind++] = ch;
	  continue;
	}

      /* If this is a shell break character, we are not in a word.  If not,
	 we either start or continue a word. */
      if MBTEST(shellbreak (ch))
	{
	  tflags &= ~LEX_INWORD;
/*itrace("parse_comsub:%d: lex_inword -> 0 ch = `%c' (%d)", line_number, ch, __LINE__);*/
	}
      else
	{
	  if (tflags & LEX_INWORD)
	    {
	      lex_wlen++;
/*itrace("parse_comsub:%d: lex_inword == 1 ch = `%c' lex_wlen = %d (%d)", line_number, ch, lex_wlen, __LINE__);*/
	    }	      
	  else
	    {
/*itrace("parse_comsub:%d: lex_inword -> 1 ch = `%c' (%d)", line_number, ch, __LINE__);*/
	      tflags |= LEX_INWORD;
	      lex_wlen = 0;
	    }
	}

      /* Skip whitespace */
      if MBTEST(shellblank (ch) && (tflags & LEX_HEREDELIM) == 0 && lex_rwlen == 0)
        {
	  /* Add this character. */
	  RESIZE_MALLOCED_BUFFER (ret, retind, 1, retsize, 64);
	  ret[retind++] = ch;
	  continue;
        }

      /* Either we are looking for the start of the here-doc delimiter
	 (lex_firstind == -1) or we are reading one (lex_firstind >= 0).
	 If this character is a shell break character and we are reading
	 the delimiter, save it and note that we are now reading a here
	 document.  If we've found the start of the delimiter, note it by
	 setting lex_firstind.  Backslashes can quote shell metacharacters
	 in here-doc delimiters. */
      if (tflags & LEX_HEREDELIM)
	{
	  if (lex_firstind == -1 && shellbreak (ch) == 0)
	    lex_firstind = retind;
#if 0
	  else if (heredelim && (tflags & LEX_PASSNEXT) == 0 && ch == '\n')
	    {
	      tflags |= LEX_INHEREDOC;
	      tflags &= ~LEX_HEREDELIM;
	      lex_firstind = retind + 1;
	    }
#endif
	  else if (lex_firstind >= 0 && (tflags & LEX_PASSNEXT) == 0 && shellbreak (ch))
	    {
	      if (heredelim == 0)
		{
		  nestret = substring (ret, lex_firstind, retind);
		  heredelim = string_quote_removal (nestret, 0);
		  free (nestret);
		  hdlen = STRLEN(heredelim);
/*itrace("parse_comsub:%d: found here doc delimiter `%s' (%d)", line_number, heredelim, hdlen);*/
		}
	      if (ch == '\n')
		{
		  tflags |= LEX_INHEREDOC;
		  tflags &= ~LEX_HEREDELIM;
		  lex_firstind = retind + 1;
		}
	      else
		lex_firstind = -1;
	    }
	}

      /* Meta-characters that can introduce a reserved word.  Not perfect yet. */
      if MBTEST((tflags & LEX_RESWDOK) == 0 && (tflags & LEX_CKCASE) && (tflags & LEX_INCOMMENT) == 0 && (shellmeta(ch) || ch == '\n'))
	{
	  /* Add this character. */
	  RESIZE_MALLOCED_BUFFER (ret, retind, 1, retsize, 64);
	  ret[retind++] = ch;
	  peekc = shell_getc (1);
	  if (ch == peekc && (ch == '&' || ch == '|' || ch == ';'))	/* two-character tokens */
	    {
	      RESIZE_MALLOCED_BUFFER (ret, retind, 1, retsize, 64);
	      ret[retind++] = peekc;
/*itrace("parse_comsub:%d: set lex_reswordok = 1, ch = `%c'", line_number, ch);*/
	      tflags |= LEX_RESWDOK;
	      lex_rwlen = 0;
	      continue;
	    }
	  else if (ch == '\n' || COMSUB_META(ch))
	    {
	      shell_ungetc (peekc);
/*itrace("parse_comsub:%d: set lex_reswordok = 1, ch = `%c'", line_number, ch);*/
	      tflags |= LEX_RESWDOK;
	      lex_rwlen = 0;
	      continue;
	    }
	  else if (ch == EOF)
	    goto eof_error;
	  else
	    {
	      /* `unget' the character we just added and fall through */
	      retind--;
	      shell_ungetc (peekc);
	    }
	}

      /* If we can read a reserved word, try to read one. */
      if (tflags & LEX_RESWDOK)
	{
	  if MBTEST(islower (ch))
	    {
	      /* Add this character. */
	      RESIZE_MALLOCED_BUFFER (ret, retind, 1, retsize, 64);
	      ret[retind++] = ch;
	      lex_rwlen++;
	      continue;
	    }
	  else if MBTEST(lex_rwlen == 4 && shellbreak (ch))
	    {
	      if (STREQN (ret + retind - 4, "case", 4))
{
		tflags |= LEX_INCASE;
/*itrace("parse_comsub:%d: found `case', lex_incase -> 1 lex_reswdok -> 0", line_number);*/
}
	      else if (STREQN (ret + retind - 4, "esac", 4))
{
		tflags &= ~LEX_INCASE;
/*itrace("parse_comsub:%d: found `esac', lex_incase -> 0 lex_reswdok -> 0", line_number);*/
}	        
	      tflags &= ~LEX_RESWDOK;
	    }
	  else if MBTEST((tflags & LEX_CKCOMMENT) && ch == '#' && (lex_rwlen == 0 || ((tflags & LEX_INWORD) && lex_wlen == 0)))
	    ;	/* don't modify LEX_RESWDOK if we're starting a comment */
	  else if MBTEST((tflags & LEX_INCASE) && ch != '\n')
	    /* If we can read a reserved word and we're in case, we're at the
	       point where we can read a new pattern list or an esac.  We
	       handle the esac case above.  If we read a newline, we want to
	       leave LEX_RESWDOK alone.  If we read anything else, we want to
	       turn off LEX_RESWDOK, since we're going to read a pattern list. */
{
	    tflags &= ~LEX_RESWDOK;
/*itrace("parse_comsub:%d: lex_incase == 1 found `%c', lex_reswordok -> 0", line_number, ch);*/
}
	  else if MBTEST(shellbreak (ch) == 0)
{
	    tflags &= ~LEX_RESWDOK;
/*itrace("parse_comsub:%d: found `%c', lex_reswordok -> 0", line_number, ch);*/
}
	}

      /* Might be the start of a here-doc delimiter */
      if MBTEST((tflags & LEX_INCOMMENT) == 0 && (tflags & LEX_CKCASE) && ch == '<')
	{
	  /* Add this character. */
	  RESIZE_MALLOCED_BUFFER (ret, retind, 1, retsize, 64);
	  ret[retind++] = ch;
	  peekc = shell_getc (1);
	  if (peekc == EOF)
	    goto eof_error;
	  if (peekc == ch)
	    {
	      RESIZE_MALLOCED_BUFFER (ret, retind, 1, retsize, 64);
	      ret[retind++] = peekc;
	      peekc = shell_getc (1);
	      if (peekc == EOF)
		goto eof_error;
	      if (peekc == '-')
		{
		  RESIZE_MALLOCED_BUFFER (ret, retind, 1, retsize, 64);
		  ret[retind++] = peekc;
		  tflags |= LEX_STRIPDOC;
		}
	      else
		shell_ungetc (peekc);
	      if (peekc != '<')
		{
		  tflags |= LEX_HEREDELIM;
		  lex_firstind = -1;
		}
	      continue;
	    }
	  else
	    ch = peekc;		/* fall through and continue XXX */
	}
      else if MBTEST((tflags & LEX_CKCOMMENT) && (tflags & LEX_INCOMMENT) == 0 && ch == '#' && (((tflags & LEX_RESWDOK) && lex_rwlen == 0) || ((tflags & LEX_INWORD) && lex_wlen == 0)))
{
/*itrace("parse_comsub:%d: lex_incomment -> 1 (%d)", line_number, __LINE__);*/
	tflags |= LEX_INCOMMENT;
}

      if MBTEST(ch == CTLESC || ch == CTLNUL)	/* special shell escapes */
	{
	  RESIZE_MALLOCED_BUFFER (ret, retind, 2, retsize, 64);
	  ret[retind++] = CTLESC;
	  ret[retind++] = ch;
	  continue;
	}
#if 0
      else if MBTEST((tflags & LEX_INCASE) && ch == close && close == ')')
        tflags &= ~LEX_INCASE;		/* XXX */
#endif
      else if MBTEST(ch == close && (tflags & LEX_INCASE) == 0)		/* ending delimiter */
{
	count--;
/*itrace("parse_comsub:%d: found close: count = %d", line_number, count);*/
}
      else if MBTEST(((flags & P_FIRSTCLOSE) == 0) && (tflags & LEX_INCASE) == 0 && ch == open)	/* nested begin */
{
	count++;
/*itrace("parse_comsub:%d: found open: count = %d", line_number, count);*/
}

      /* Add this character. */
      RESIZE_MALLOCED_BUFFER (ret, retind, 1, retsize, 64);
      ret[retind++] = ch;

      /* If we just read the ending character, don't bother continuing. */
      if (count == 0)
	break;

      if MBTEST(ch == '\\')			/* backslashes */
	tflags |= LEX_PASSNEXT;

      if MBTEST(shellquote (ch))
        {
          /* '', ``, or "" inside $(...). */
          push_delimiter (dstack, ch);
          if MBTEST((tflags & LEX_WASDOL) && ch == '\'')	/* $'...' inside group */
	    nestret = parse_matched_pair (ch, ch, ch, &nestlen, P_ALLOWESC|rflags);
	  else
	    nestret = parse_matched_pair (ch, ch, ch, &nestlen, rflags);
	  pop_delimiter (dstack);
	  CHECK_NESTRET_ERROR ();

	  if MBTEST((tflags & LEX_WASDOL) && ch == '\'' && (extended_quote || (rflags & P_DQUOTE) == 0))
	    {
	      /* Translate $'...' here. */
	      ttrans = ansiexpand (nestret, 0, nestlen - 1, &ttranslen);
	      xfree (nestret);

	      if ((rflags & P_DQUOTE) == 0)
		{
		  nestret = sh_single_quote (ttrans);
		  free (ttrans);
		  nestlen = strlen (nestret);
		}
	      else
		{
		  nestret = ttrans;
		  nestlen = ttranslen;
		}
	      retind -= 2;		/* back up before the $' */
	    }
	  else if MBTEST((tflags & LEX_WASDOL) && ch == '"' && (extended_quote || (rflags & P_DQUOTE) == 0))
	    {
	      /* Locale expand $"..." here. */
	      ttrans = localeexpand (nestret, 0, nestlen - 1, start_lineno, &ttranslen);
	      xfree (nestret);

	      nestret = sh_mkdoublequoted (ttrans, ttranslen, 0);
	      free (ttrans);
	      nestlen = ttranslen + 2;
	      retind -= 2;		/* back up before the $" */
	    }

	  APPEND_NESTRET ();
	  FREE (nestret);
	}
      else if MBTEST((tflags & LEX_WASDOL) && (ch == '(' || ch == '{' || ch == '['))	/* ) } ] */
	/* check for $(), $[], or ${} inside command substitution. */
	{
	  if ((tflags & LEX_INCASE) == 0 && open == ch)	/* undo previous increment */
	    count--;
	  if (ch == '(')		/* ) */
	    nestret = parse_comsub (0, '(', ')', &nestlen, (rflags|P_COMMAND) & ~P_DQUOTE);
	  else if (ch == '{')		/* } */
	    nestret = parse_matched_pair (0, '{', '}', &nestlen, P_FIRSTCLOSE|P_DOLBRACE|rflags);
	  else if (ch == '[')		/* ] */
	    nestret = parse_matched_pair (0, '[', ']', &nestlen, rflags);

	  CHECK_NESTRET_ERROR ();
	  APPEND_NESTRET ();

	  FREE (nestret);
	}
      if MBTEST(ch == '$')
	tflags |= LEX_WASDOL;
      else
	tflags &= ~LEX_WASDOL;
    }

  FREE (heredelim);
  ret[retind] = '\0';
  if (lenp)
    *lenp = retind;
/*itrace("parse_comsub:%d: returning `%s'", line_number, ret);*/
  return ret;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\y.tab.c:5,712
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\y.tab.c:6,150
parsing error 
{
  sh_parser_state_t ps;
  int orig_ind, nc, sflags;
  char *ret, *s, *ep, *ostring;

  /*yydebug = 1;*/
  orig_ind = *indp;
  ostring = string;

  sflags = SEVAL_NONINT|SEVAL_NOHIST|SEVAL_NOFREE;
  if (flags & SX_NOLONGJMP)
    sflags |= SEVAL_NOLONGJMP;
  save_parser_state (&ps);

  /*(*/
  parser_state |= PST_CMDSUBST|PST_EOFTOKEN;	/* allow instant ')' */ /*(*/
  shell_eof_token = ')';
  parse_string (string, "command substitution", sflags, &ep);

  restore_parser_state (&ps);
  reset_parser ();
  if (interactive)
    token_to_read = 0;

  /* Need to find how many characters parse_and_execute consumed, update
     *indp, if flags != 0, copy the portion of the string parsed into RET
     and return it.  If flags & 1 (EX_NOALLOC) we can return NULL. */

  /*(*/
  if (ep[-1] != ')')
    {
#if DEBUG
      if (ep[-1] != '\n')
	itrace("xparse_dolparen:%d: ep[-1] != RPAREN (%d), ep = `%s'", line_number, ep[-1], ep);
#endif
      while (ep > ostring && ep[-1] == '\n') ep--;
    }

  nc = ep - ostring;
  *indp = ep - base - 1;

  /*(*/
#if DEBUG
  if (base[*indp] != ')')
    itrace("xparse_dolparen:%d: base[%d] != RPAREN (%d), base = `%s'", line_number, *indp, base[*indp], base);
#endif

  if (flags & SX_NOALLOC) 
    return (char *)NULL;

  if (nc == 0)
    {
      ret = xmalloc (1);
      ret[0] = '\0';
    }
  else
    ret = substring (ostring, 0, nc - 1);

  return ret;
}
warning: parse error {
  sh_parser_state_t ps;
  int orig_ind, nc, sflags;
  char *ret, *s, *ep, *ostring;

  /*yydebug = 1;*/
  orig_ind = *indp;
  ostring = string;

  sflags = SEVAL_NONINT|SEVAL_NOHIST|SEVAL_NOFREE;
  if (flags & SX_NOLONGJMP)
    sflags |= SEVAL_NOLONGJMP;
  save_parser_state (&ps);

  /*(*/
  parser_state |= PST_CMDSUBST|PST_EOFTOKEN;	/* allow instant ')' */ /*(*/
  shell_eof_token = ')';
  parse_string (string, "command substitution", sflags, &ep);

  restore_parser_state (&ps);
  reset_parser ();
  if (interactive)
    token_to_read = 0;

  /* Need to find how many characters parse_and_execute consumed, update
     *indp, if flags != 0, copy the portion of the string parsed into RET
     and return it.  If flags & 1 (EX_NOALLOC) we can return NULL. */

  /*(*/
  if (ep[-1] != ')')
    {
#if DEBUG
      if (ep[-1] != '\n')
	itrace("xparse_dolparen:%d: ep[-1] != RPAREN (%d), ep = `%s'", line_number, ep[-1], ep);
#endif
      while (ep > ostring && ep[-1] == '\n') ep--;
    }

  nc = ep - ostring;
  *indp = ep - base - 1;

  /*(*/
#if DEBUG
  if (base[*indp] != ')')
    itrace("xparse_dolparen:%d: base[%d] != RPAREN (%d), base = `%s'", line_number, *indp, base[*indp], base);
#endif

  if (flags & SX_NOALLOC) 
    return (char *)NULL;

  if (nc == 0)
    {
      ret = xmalloc (1);
      ret[0] = '\0';
    }
  else
    ret = substring (ostring, 0, nc - 1);

  return ret;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\y.tab.c:6,155
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\y.tab.c:6,609
parsing error 
{
  /* The value for YYLVAL when a WORD is read. */
  WORD_DESC *the_word;

  /* Index into the token that we are building. */
  int token_index;

  /* ALL_DIGITS becomes zero when we see a non-digit. */
  int all_digit_token;

  /* DOLLAR_PRESENT becomes non-zero if we see a `$'. */
  int dollar_present;

  /* COMPOUND_ASSIGNMENT becomes non-zero if we are parsing a compound
     assignment. */
  int compound_assignment;

  /* QUOTED becomes non-zero if we see one of ("), ('), (`), or (\). */
  int quoted;

  /* Non-zero means to ignore the value of the next character, and just
     to add it no matter what. */
 int pass_next_character;

  /* The current delimiting character. */
  int cd;
  int result, peek_char;
  char *ttok, *ttrans;
  int ttoklen, ttranslen;
  intmax_t lvalue;

  if (token_buffer_size < TOKEN_DEFAULT_INITIAL_SIZE)
    token = (char *)xrealloc (token, token_buffer_size = TOKEN_DEFAULT_INITIAL_SIZE);

  token_index = 0;
  all_digit_token = DIGIT (character);
  dollar_present = quoted = pass_next_character = compound_assignment = 0;

  for (;;)
    {
      if (character == EOF)
	goto got_token;

      if (pass_next_character)
	{
	  pass_next_character = 0;
	  goto got_escaped_character;
	}

      cd = current_delimiter (dstack);

      /* Handle backslashes.  Quote lots of things when not inside of
	 double-quotes, quote some things inside of double-quotes. */
      if MBTEST(character == '\\')
	{
	  peek_char = shell_getc (0);

	  /* Backslash-newline is ignored in all cases except
	     when quoted with single quotes. */
	  if (peek_char == '\n')
	    {
	      character = '\n';
	      goto next_character;
	    }
	  else
	    {
	      shell_ungetc (peek_char);

	      /* If the next character is to be quoted, note it now. */
	      if (cd == 0 || cd == '`' ||
		  (cd == '"' && peek_char >= 0 && (sh_syntaxtab[peek_char] & CBSDQUOTE)))
		pass_next_character++;

	      quoted = 1;
	      goto got_character;
	    }
	}

      /* Parse a matched pair of quote characters. */
      if MBTEST(shellquote (character))
	{
	  push_delimiter (dstack, character);
	  ttok = parse_matched_pair (character, character, character, &ttoklen, (character == '`') ? P_COMMAND : 0);
	  pop_delimiter (dstack);
	  if (ttok == &matched_pair_error)
	    return -1;		/* Bail immediately. */
	  RESIZE_MALLOCED_BUFFER (token, token_index, ttoklen + 2,
				  token_buffer_size, TOKEN_DEFAULT_GROW_SIZE);
	  token[token_index++] = character;
	  strcpy (token + token_index, ttok);
	  token_index += ttoklen;
	  all_digit_token = 0;
	  quoted = 1;
	  dollar_present |= (character == '"' && strchr (ttok, '$') != 0);
	  FREE (ttok);
	  goto next_character;
	}

#ifdef COND_REGEXP
      /* When parsing a regexp as a single word inside a conditional command,
	 we need to special-case characters special to both the shell and
	 regular expressions.  Right now, that is only '(' and '|'. */ /*)*/
      if MBTEST((parser_state & PST_REGEXP) && (character == '(' || character == '|'))		/*)*/
	{
	  if (character == '|')
	    goto got_character;

	  push_delimiter (dstack, character);
	  ttok = parse_matched_pair (cd, '(', ')', &ttoklen, 0);
	  pop_delimiter (dstack);
	  if (ttok == &matched_pair_error)
	    return -1;		/* Bail immediately. */
	  RESIZE_MALLOCED_BUFFER (token, token_index, ttoklen + 2,
				  token_buffer_size, TOKEN_DEFAULT_GROW_SIZE);
	  token[token_index++] = character;
	  strcpy (token + token_index, ttok);
	  token_index += ttoklen;
	  FREE (ttok);
	  dollar_present = all_digit_token = 0;
	  goto next_character;
	}
#endif /* COND_REGEXP */

#ifdef EXTENDED_GLOB
      /* Parse a ksh-style extended pattern matching specification. */
      if MBTEST(extended_glob && PATTERN_CHAR (character))
	{
	  peek_char = shell_getc (1);
	  if MBTEST(peek_char == '(')		/* ) */
	    {
	      push_delimiter (dstack, peek_char);
	      ttok = parse_matched_pair (cd, '(', ')', &ttoklen, 0);
	      pop_delimiter (dstack);
	      if (ttok == &matched_pair_error)
		return -1;		/* Bail immediately. */
	      RESIZE_MALLOCED_BUFFER (token, token_index, ttoklen + 2,
				      token_buffer_size,
				      TOKEN_DEFAULT_GROW_SIZE);
	      token[token_index++] = character;
	      token[token_index++] = peek_char;
	      strcpy (token + token_index, ttok);
	      token_index += ttoklen;
	      FREE (ttok);
	      dollar_present = all_digit_token = 0;
	      goto next_character;
	    }
	  else
	    shell_ungetc (peek_char);
	}
#endif /* EXTENDED_GLOB */

      /* If the delimiter character is not single quote, parse some of
	 the shell expansions that must be read as a single word. */
      if (shellexp (character))
	{
	  peek_char = shell_getc (1);
	  /* $(...), <(...), >(...), $((...)), ${...}, and $[...] constructs */
	  if MBTEST(peek_char == '(' || \
		((peek_char == '{' || peek_char == '[') && character == '$'))	/* ) ] } */
	    {
	      if (peek_char == '{')		/* } */
		ttok = parse_matched_pair (cd, '{', '}', &ttoklen, P_FIRSTCLOSE|P_DOLBRACE);
	      else if (peek_char == '(')		/* ) */
		{
		  /* XXX - push and pop the `(' as a delimiter for use by
		     the command-oriented-history code.  This way newlines
		     appearing in the $(...) string get added to the
		     history literally rather than causing a possibly-
		     incorrect `;' to be added. ) */
		  push_delimiter (dstack, peek_char);
		  ttok = parse_comsub (cd, '(', ')', &ttoklen, P_COMMAND);
		  pop_delimiter (dstack);
		}
	      else
		ttok = parse_matched_pair (cd, '[', ']', &ttoklen, 0);
	      if (ttok == &matched_pair_error)
		return -1;		/* Bail immediately. */
	      RESIZE_MALLOCED_BUFFER (token, token_index, ttoklen + 2,
				      token_buffer_size,
				      TOKEN_DEFAULT_GROW_SIZE);
	      token[token_index++] = character;
	      token[token_index++] = peek_char;
	      strcpy (token + token_index, ttok);
	      token_index += ttoklen;
	      FREE (ttok);
	      dollar_present = 1;
	      all_digit_token = 0;
	      goto next_character;
	    }
	  /* This handles $'...' and $"..." new-style quoted strings. */
	  else if MBTEST(character == '$' && (peek_char == '\'' || peek_char == '"'))
	    {
	      int first_line;

	      first_line = line_number;
	      push_delimiter (dstack, peek_char);
	      ttok = parse_matched_pair (peek_char, peek_char, peek_char,
					 &ttoklen,
					 (peek_char == '\'') ? P_ALLOWESC : 0);
	      pop_delimiter (dstack);
	      if (ttok == &matched_pair_error)
		return -1;
	      if (peek_char == '\'')
		{
		  ttrans = ansiexpand (ttok, 0, ttoklen - 1, &ttranslen);
		  free (ttok);

		  /* Insert the single quotes and correctly quote any
		     embedded single quotes (allowed because P_ALLOWESC was
		     passed to parse_matched_pair). */
		  ttok = sh_single_quote (ttrans);
		  free (ttrans);
		  ttranslen = strlen (ttok);
		  ttrans = ttok;
		}
	      else
		{
		  /* Try to locale-expand the converted string. */
		  ttrans = localeexpand (ttok, 0, ttoklen - 1, first_line, &ttranslen);
		  free (ttok);

		  /* Add the double quotes back */
		  ttok = sh_mkdoublequoted (ttrans, ttranslen, 0);
		  free (ttrans);
		  ttranslen += 2;
		  ttrans = ttok;
		}

	      RESIZE_MALLOCED_BUFFER (token, token_index, ttranslen + 2,
				      token_buffer_size,
				      TOKEN_DEFAULT_GROW_SIZE);
	      strcpy (token + token_index, ttrans);
	      token_index += ttranslen;
	      FREE (ttrans);
	      quoted = 1;
	      all_digit_token = 0;
	      goto next_character;
	    }
	  /* This could eventually be extended to recognize all of the
	     shell's single-character parameter expansions, and set flags.*/
	  else if MBTEST(character == '$' && peek_char == '$')
	    {
	      ttok = (char *)xmalloc (3);
	      ttok[0] = ttok[1] = '$';
	      ttok[2] = '\0';
	      RESIZE_MALLOCED_BUFFER (token, token_index, 3,
				      token_buffer_size,
				      TOKEN_DEFAULT_GROW_SIZE);
	      strcpy (token + token_index, ttok);
	      token_index += 2;
	      dollar_present = 1;
	      all_digit_token = 0;
	      FREE (ttok);
	      goto next_character;
	    }
	  else
	    shell_ungetc (peek_char);
	}

#if defined (ARRAY_VARS)
      /* Identify possible array subscript assignment; match [...].  If
	 parser_state&PST_COMPASSIGN, we need to parse [sub]=words treating
	 `sub' as if it were enclosed in double quotes. */
      else if MBTEST(character == '[' &&		/* ] */
		     ((token_index > 0 && assignment_acceptable (last_read_token) && token_is_ident (token, token_index)) ||
		      (token_index == 0 && (parser_state&PST_COMPASSIGN))))
        {
	  ttok = parse_matched_pair (cd, '[', ']', &ttoklen, P_ARRAYSUB);
	  if (ttok == &matched_pair_error)
	    return -1;		/* Bail immediately. */
	  RESIZE_MALLOCED_BUFFER (token, token_index, ttoklen + 2,
				  token_buffer_size,
				  TOKEN_DEFAULT_GROW_SIZE);
	  token[token_index++] = character;
	  strcpy (token + token_index, ttok);
	  token_index += ttoklen;
	  FREE (ttok);
	  all_digit_token = 0;
	  goto next_character;
        }
      /* Identify possible compound array variable assignment. */
      else if MBTEST(character == '=' && token_index > 0 && (assignment_acceptable (last_read_token) || (parser_state & PST_ASSIGNOK)) && token_is_assignment (token, token_index))
	{
	  peek_char = shell_getc (1);
	  if MBTEST(peek_char == '(')		/* ) */
	    {
	      ttok = parse_compound_assignment (&ttoklen);

	      RESIZE_MALLOCED_BUFFER (token, token_index, ttoklen + 4,
				      token_buffer_size,
				      TOKEN_DEFAULT_GROW_SIZE);

	      token[token_index++] = '=';
	      token[token_index++] = '(';
	      if (ttok)
		{
		  strcpy (token + token_index, ttok);
		  token_index += ttoklen;
		}
	      token[token_index++] = ')';
	      FREE (ttok);
	      all_digit_token = 0;
	      compound_assignment = 1;
#if 1
	      goto next_character;
#else
	      goto got_token;		/* ksh93 seems to do this */
#endif
	    }
	  else
	    shell_ungetc (peek_char);
	}
#endif

      /* When not parsing a multi-character word construct, shell meta-
	 characters break words. */
      if MBTEST(shellbreak (character))
	{
	  shell_ungetc (character);
	  goto got_token;
	}

    got_character:

      if (character == CTLESC || character == CTLNUL)
	token[token_index++] = CTLESC;

    got_escaped_character:

      all_digit_token &= DIGIT (character);
      dollar_present |= character == '$';

      token[token_index++] = character;

      RESIZE_MALLOCED_BUFFER (token, token_index, 1, token_buffer_size,
			      TOKEN_DEFAULT_GROW_SIZE);

    next_character:
      if (character == '\n' && SHOULD_PROMPT ())
	prompt_again ();

      /* We want to remove quoted newlines (that is, a \<newline> pair)
	 unless we are within single quotes or pass_next_character is
	 set (the shell equivalent of literal-next). */
      cd = current_delimiter (dstack);
      character = shell_getc (cd != '\'' && pass_next_character == 0);
    }	/* end for (;;) */

got_token:

  token[token_index] = '\0';

  /* Check to see what thing we should return.  If the last_read_token
     is a `<', or a `&', or the character which ended this token is
     a '>' or '<', then, and ONLY then, is this input token a NUMBER.
     Otherwise, it is just a word, and should be returned as such. */
  if MBTEST(all_digit_token && (character == '<' || character == '>' || \
		    last_read_token == LESS_AND || \
		    last_read_token == GREATER_AND))
      {
	if (legal_number (token, &lvalue) && (int)lvalue == lvalue)
	  yylval.number = lvalue;
	else
	  yylval.number = -1;
	return (NUMBER);
      }

  /* Check for special case tokens. */
  result = (last_shell_getc_is_singlebyte) ? special_case_tokens (token) : -1;
  if (result >= 0)
    return result;

#if defined (ALIAS)
  /* Posix.2 does not allow reserved words to be aliased, so check for all
     of them, including special cases, before expanding the current token
     as an alias. */
  if MBTEST(posixly_correct)
    CHECK_FOR_RESERVED_WORD (token);

  /* Aliases are expanded iff EXPAND_ALIASES is non-zero, and quoting
     inhibits alias expansion. */
  if (expand_aliases && quoted == 0)
    {
      result = alias_expand_token (token);
      if (result == RE_READ_TOKEN)
	return (RE_READ_TOKEN);
      else if (result == NO_EXPANSION)
	parser_state &= ~PST_ALEXPNEXT;
    }

  /* If not in Posix.2 mode, check for reserved words after alias
     expansion. */
  if MBTEST(posixly_correct == 0)
#endif
    CHECK_FOR_RESERVED_WORD (token);

  the_word = (WORD_DESC *)xmalloc (sizeof (WORD_DESC));
  the_word->word = (char *)xmalloc (1 + token_index);
  the_word->flags = 0;
  strcpy (the_word->word, token);
  if (dollar_present)
    the_word->flags |= W_HASDOLLAR;
  if (quoted)
    the_word->flags |= W_QUOTED;		/*(*/
  if (compound_assignment && token[token_index-1] == ')')
    the_word->flags |= W_COMPASSIGN;
  /* A word is an assignment if it appears at the beginning of a
     simple command, or after another assignment word.  This is
     context-dependent, so it cannot be handled in the grammar. */
  if (assignment (token, (parser_state & PST_COMPASSIGN) != 0))
    {
      the_word->flags |= W_ASSIGNMENT;
      /* Don't perform word splitting on assignment statements. */
      if (assignment_acceptable (last_read_token) || (parser_state & PST_COMPASSIGN) != 0)
	the_word->flags |= W_NOSPLIT;
    }

  if (command_token_position (last_read_token))
    {
      struct builtin *b;
      b = builtin_address_internal (token, 0);
      if (b && (b->flags & ASSIGNMENT_BUILTIN))
	parser_state |= PST_ASSIGNOK;
      else if (STREQ (token, "eval") || STREQ (token, "let"))
	parser_state |= PST_ASSIGNOK;
    }

  yylval.word = the_word;

  if (token[0] == '{' && token[token_index-1] == '}' &&
      (character == '<' || character == '>'))
    {
      /* can use token; already copied to the_word */
      token[token_index-1] = '\0';
      if (legal_identifier (token+1))
	{
	  strcpy (the_word->word, token+1);
/*itrace("read_token_word: returning REDIR_WORD for %s", the_word->word);*/
	  return (REDIR_WORD);
	}
    }

  result = ((the_word->flags & (W_ASSIGNMENT|W_NOSPLIT)) == (W_ASSIGNMENT|W_NOSPLIT))
		? ASSIGNMENT_WORD : WORD;

  switch (last_read_token)
    {
    case FUNCTION:
      parser_state |= PST_ALLOWOPNBRC;
      function_dstart = line_number;
      break;
    case CASE:
    case SELECT:
    case FOR:
      if (word_top < MAX_CASE_NEST)
	word_top++;
      word_lineno[word_top] = line_number;
      break;
    }

  return (result);
}
warning: parse error {
  /* The value for YYLVAL when a WORD is read. */
  WORD_DESC *the_word;

  /* Index into the token that we are building. */
  int token_index;

  /* ALL_DIGITS becomes zero when we see a non-digit. */
  int all_digit_token;

  /* DOLLAR_PRESENT becomes non-zero if we see a `$'. */
  int dollar_present;

  /* COMPOUND_ASSIGNMENT becomes non-zero if we are parsing a compound
     assignment. */
  int compound_assignment;

  /* QUOTED becomes non-zero if we see one of ("), ('), (`), or (\). */
  int quoted;

  /* Non-zero means to ignore the value of the next character, and just
     to add it no matter what. */
 int pass_next_character;

  /* The current delimiting character. */
  int cd;
  int result, peek_char;
  char *ttok, *ttrans;
  int ttoklen, ttranslen;
  intmax_t lvalue;

  if (token_buffer_size < TOKEN_DEFAULT_INITIAL_SIZE)
    token = (char *)xrealloc (token, token_buffer_size = TOKEN_DEFAULT_INITIAL_SIZE);

  token_index = 0;
  all_digit_token = DIGIT (character);
  dollar_present = quoted = pass_next_character = compound_assignment = 0;

  for (;;)
    {
      if (character == EOF)
	goto got_token;

      if (pass_next_character)
	{
	  pass_next_character = 0;
	  goto got_escaped_character;
	}

      cd = current_delimiter (dstack);

      /* Handle backslashes.  Quote lots of things when not inside of
	 double-quotes, quote some things inside of double-quotes. */
      if MBTEST(character == '\\')
	{
	  peek_char = shell_getc (0);

	  /* Backslash-newline is ignored in all cases except
	     when quoted with single quotes. */
	  if (peek_char == '\n')
	    {
	      character = '\n';
	      goto next_character;
	    }
	  else
	    {
	      shell_ungetc (peek_char);

	      /* If the next character is to be quoted, note it now. */
	      if (cd == 0 || cd == '`' ||
		  (cd == '"' && peek_char >= 0 && (sh_syntaxtab[peek_char] & CBSDQUOTE)))
		pass_next_character++;

	      quoted = 1;
	      goto got_character;
	    }
	}

      /* Parse a matched pair of quote characters. */
      if MBTEST(shellquote (character))
	{
	  push_delimiter (dstack, character);
	  ttok = parse_matched_pair (character, character, character, &ttoklen, (character == '`') ? P_COMMAND : 0);
	  pop_delimiter (dstack);
	  if (ttok == &matched_pair_error)
	    return -1;		/* Bail immediately. */
	  RESIZE_MALLOCED_BUFFER (token, token_index, ttoklen + 2,
				  token_buffer_size, TOKEN_DEFAULT_GROW_SIZE);
	  token[token_index++] = character;
	  strcpy (token + token_index, ttok);
	  token_index += ttoklen;
	  all_digit_token = 0;
	  quoted = 1;
	  dollar_present |= (character == '"' && strchr (ttok, '$') != 0);
	  FREE (ttok);
	  goto next_character;
	}

#ifdef COND_REGEXP
      /* When parsing a regexp as a single word inside a conditional command,
	 we need to special-case characters special to both the shell and
	 regular expressions.  Right now, that is only '(' and '|'. */ /*)*/
      if MBTEST((parser_state & PST_REGEXP) && (character == '(' || character == '|'))		/*)*/
	{
	  if (character == '|')
	    goto got_character;

	  push_delimiter (dstack, character);
	  ttok = parse_matched_pair (cd, '(', ')', &ttoklen, 0);
	  pop_delimiter (dstack);
	  if (ttok == &matched_pair_error)
	    return -1;		/* Bail immediately. */
	  RESIZE_MALLOCED_BUFFER (token, token_index, ttoklen + 2,
				  token_buffer_size, TOKEN_DEFAULT_GROW_SIZE);
	  token[token_index++] = character;
	  strcpy (token + token_index, ttok);
	  token_index += ttoklen;
	  FREE (ttok);
	  dollar_present = all_digit_token = 0;
	  goto next_character;
	}
#endif /* COND_REGEXP */

#ifdef EXTENDED_GLOB
      /* Parse a ksh-style extended pattern matching specification. */
      if MBTEST(extended_glob && PATTERN_CHAR (character))
	{
	  peek_char = shell_getc (1);
	  if MBTEST(peek_char == '(')		/* ) */
	    {
	      push_delimiter (dstack, peek_char);
	      ttok = parse_matched_pair (cd, '(', ')', &ttoklen, 0);
	      pop_delimiter (dstack);
	      if (ttok == &matched_pair_error)
		return -1;		/* Bail immediately. */
	      RESIZE_MALLOCED_BUFFER (token, token_index, ttoklen + 2,
				      token_buffer_size,
				      TOKEN_DEFAULT_GROW_SIZE);
	      token[token_index++] = character;
	      token[token_index++] = peek_char;
	      strcpy (token + token_index, ttok);
	      token_index += ttoklen;
	      FREE (ttok);
	      dollar_present = all_digit_token = 0;
	      goto next_character;
	    }
	  else
	    shell_ungetc (peek_char);
	}
#endif /* EXTENDED_GLOB */

      /* If the delimiter character is not single quote, parse some of
	 the shell expansions that must be read as a single word. */
      if (shellexp (character))
	{
	  peek_char = shell_getc (1);
	  /* $(...), <(...), >(...), $((...)), ${...}, and $[...] constructs */
	  if MBTEST(peek_char == '(' || \
		((peek_char == '{' || peek_char == '[') && character == '$'))	/* ) ] } */
	    {
	      if (peek_char == '{')		/* } */
		ttok = parse_matched_pair (cd, '{', '}', &ttoklen, P_FIRSTCLOSE|P_DOLBRACE);
	      else if (peek_char == '(')		/* ) */
		{
		  /* XXX - push and pop the `(' as a delimiter for use by
		     the command-oriented-history code.  This way newlines
		     appearing in the $(...) string get added to the
		     history literally rather than causing a possibly-
		     incorrect `;' to be added. ) */
		  push_delimiter (dstack, peek_char);
		  ttok = parse_comsub (cd, '(', ')', &ttoklen, P_COMMAND);
		  pop_delimiter (dstack);
		}
	      else
		ttok = parse_matched_pair (cd, '[', ']', &ttoklen, 0);
	      if (ttok == &matched_pair_error)
		return -1;		/* Bail immediately. */
	      RESIZE_MALLOCED_BUFFER (token, token_index, ttoklen + 2,
				      token_buffer_size,
				      TOKEN_DEFAULT_GROW_SIZE);
	      token[token_index++] = character;
	      token[token_index++] = peek_char;
	      strcpy (token + token_index, ttok);
	      token_index += ttoklen;
	      FREE (ttok);
	      dollar_present = 1;
	      all_digit_token = 0;
	      goto next_character;
	    }
	  /* This handles $'...' and $"..." new-style quoted strings. */
	  else if MBTEST(character == '$' && (peek_char == '\'' || peek_char == '"'))
	    {
	      int first_line;

	      first_line = line_number;
	      push_delimiter (dstack, peek_char);
	      ttok = parse_matched_pair (peek_char, peek_char, peek_char,
					 &ttoklen,
					 (peek_char == '\'') ? P_ALLOWESC : 0);
	      pop_delimiter (dstack);
	      if (ttok == &matched_pair_error)
		return -1;
	      if (peek_char == '\'')
		{
		  ttrans = ansiexpand (ttok, 0, ttoklen - 1, &ttranslen);
		  free (ttok);

		  /* Insert the single quotes and correctly quote any
		     embedded single quotes (allowed because P_ALLOWESC was
		     passed to parse_matched_pair). */
		  ttok = sh_single_quote (ttrans);
		  free (ttrans);
		  ttranslen = strlen (ttok);
		  ttrans = ttok;
		}
	      else
		{
		  /* Try to locale-expand the converted string. */
		  ttrans = localeexpand (ttok, 0, ttoklen - 1, first_line, &ttranslen);
		  free (ttok);

		  /* Add the double quotes back */
		  ttok = sh_mkdoublequoted (ttrans, ttranslen, 0);
		  free (ttrans);
		  ttranslen += 2;
		  ttrans = ttok;
		}

	      RESIZE_MALLOCED_BUFFER (token, token_index, ttranslen + 2,
				      token_buffer_size,
				      TOKEN_DEFAULT_GROW_SIZE);
	      strcpy (token + token_index, ttrans);
	      token_index += ttranslen;
	      FREE (ttrans);
	      quoted = 1;
	      all_digit_token = 0;
	      goto next_character;
	    }
	  /* This could eventually be extended to recognize all of the
	     shell's single-character parameter expansions, and set flags.*/
	  else if MBTEST(character == '$' && peek_char == '$')
	    {
	      ttok = (char *)xmalloc (3);
	      ttok[0] = ttok[1] = '$';
	      ttok[2] = '\0';
	      RESIZE_MALLOCED_BUFFER (token, token_index, 3,
				      token_buffer_size,
				      TOKEN_DEFAULT_GROW_SIZE);
	      strcpy (token + token_index, ttok);
	      token_index += 2;
	      dollar_present = 1;
	      all_digit_token = 0;
	      FREE (ttok);
	      goto next_character;
	    }
	  else
	    shell_ungetc (peek_char);
	}

#if defined (ARRAY_VARS)
      /* Identify possible array subscript assignment; match [...].  If
	 parser_state&PST_COMPASSIGN, we need to parse [sub]=words treating
	 `sub' as if it were enclosed in double quotes. */
      else if MBTEST(character == '[' &&		/* ] */
		     ((token_index > 0 && assignment_acceptable (last_read_token) && token_is_ident (token, token_index)) ||
		      (token_index == 0 && (parser_state&PST_COMPASSIGN))))
        {
	  ttok = parse_matched_pair (cd, '[', ']', &ttoklen, P_ARRAYSUB);
	  if (ttok == &matched_pair_error)
	    return -1;		/* Bail immediately. */
	  RESIZE_MALLOCED_BUFFER (token, token_index, ttoklen + 2,
				  token_buffer_size,
				  TOKEN_DEFAULT_GROW_SIZE);
	  token[token_index++] = character;
	  strcpy (token + token_index, ttok);
	  token_index += ttoklen;
	  FREE (ttok);
	  all_digit_token = 0;
	  goto next_character;
        }
      /* Identify possible compound array variable assignment. */
      else if MBTEST(character == '=' && token_index > 0 && (assignment_acceptable (last_read_token) || (parser_state & PST_ASSIGNOK)) && token_is_assignment (token, token_index))
	{
	  peek_char = shell_getc (1);
	  if MBTEST(peek_char == '(')		/* ) */
	    {
	      ttok = parse_compound_assignment (&ttoklen);

	      RESIZE_MALLOCED_BUFFER (token, token_index, ttoklen + 4,
				      token_buffer_size,
				      TOKEN_DEFAULT_GROW_SIZE);

	      token[token_index++] = '=';
	      token[token_index++] = '(';
	      if (ttok)
		{
		  strcpy (token + token_index, ttok);
		  token_index += ttoklen;
		}
	      token[token_index++] = ')';
	      FREE (ttok);
	      all_digit_token = 0;
	      compound_assignment = 1;
#if 1
	      goto next_character;
#else
	      goto got_token;		/* ksh93 seems to do this */
#endif
	    }
	  else
	    shell_ungetc (peek_char);
	}
#endif

      /* When not parsing a multi-character word construct, shell meta-
	 characters break words. */
      if MBTEST(shellbreak (character))
	{
	  shell_ungetc (character);
	  goto got_token;
	}

    got_character:

      if (character == CTLESC || character == CTLNUL)
	token[token_index++] = CTLESC;

    got_escaped_character:

      all_digit_token &= DIGIT (character);
      dollar_present |= character == '$';

      token[token_index++] = character;

      RESIZE_MALLOCED_BUFFER (token, token_index, 1, token_buffer_size,
			      TOKEN_DEFAULT_GROW_SIZE);

    next_character:
      if (character == '\n' && SHOULD_PROMPT ())
	prompt_again ();

      /* We want to remove quoted newlines (that is, a \<newline> pair)
	 unless we are within single quotes or pass_next_character is
	 set (the shell equivalent of literal-next). */
      cd = current_delimiter (dstack);
      character = shell_getc (cd != '\'' && pass_next_character == 0);
    }	/* end for (;;) */

got_token:

  token[token_index] = '\0';

  /* Check to see what thing we should return.  If the last_read_token
     is a `<', or a `&', or the character which ended this token is
     a '>' or '<', then, and ONLY then, is this input token a NUMBER.
     Otherwise, it is just a word, and should be returned as such. */
  if MBTEST(all_digit_token && (character == '<' || character == '>' || \
		    last_read_token == LESS_AND || \
		    last_read_token == GREATER_AND))
      {
	if (legal_number (token, &lvalue) && (int)lvalue == lvalue)
	  yylval.number = lvalue;
	else
	  yylval.number = -1;
	return (NUMBER);
      }

  /* Check for special case tokens. */
  result = (last_shell_getc_is_singlebyte) ? special_case_tokens (token) : -1;
  if (result >= 0)
    return result;

#if defined (ALIAS)
  /* Posix.2 does not allow reserved words to be aliased, so check for all
     of them, including special cases, before expanding the current token
     as an alias. */
  if MBTEST(posixly_correct)
    CHECK_FOR_RESERVED_WORD (token);

  /* Aliases are expanded iff EXPAND_ALIASES is non-zero, and quoting
     inhibits alias expansion. */
  if (expand_aliases && quoted == 0)
    {
      result = alias_expand_token (token);
      if (result == RE_READ_TOKEN)
	return (RE_READ_TOKEN);
      else if (result == NO_EXPANSION)
	parser_state &= ~PST_ALEXPNEXT;
    }

  /* If not in Posix.2 mode, check for reserved words after alias
     expansion. */
  if MBTEST(posixly_correct == 0)
#endif
    CHECK_FOR_RESERVED_WORD (token);

  the_word = (WORD_DESC *)xmalloc (sizeof (WORD_DESC));
  the_word->word = (char *)xmalloc (1 + token_index);
  the_word->flags = 0;
  strcpy (the_word->word, token);
  if (dollar_present)
    the_word->flags |= W_HASDOLLAR;
  if (quoted)
    the_word->flags |= W_QUOTED;		/*(*/
  if (compound_assignment && token[token_index-1] == ')')
    the_word->flags |= W_COMPASSIGN;
  /* A word is an assignment if it appears at the beginning of a
     simple command, or after another assignment word.  This is
     context-dependent, so it cannot be handled in the grammar. */
  if (assignment (token, (parser_state & PST_COMPASSIGN) != 0))
    {
      the_word->flags |= W_ASSIGNMENT;
      /* Don't perform word splitting on assignment statements. */
      if (assignment_acceptable (last_read_token) || (parser_state & PST_COMPASSIGN) != 0)
	the_word->flags |= W_NOSPLIT;
    }

  if (command_token_position (last_read_token))
    {
      struct builtin *b;
      b = builtin_address_internal (token, 0);
      if (b && (b->flags & ASSIGNMENT_BUILTIN))
	parser_state |= PST_ASSIGNOK;
      else if (STREQ (token, "eval") || STREQ (token, "let"))
	parser_state |= PST_ASSIGNOK;
    }

  yylval.word = the_word;

  if (token[0] == '{' && token[token_index-1] == '}' &&
      (character == '<' || character == '>'))
    {
      /* can use token; already copied to the_word */
      token[token_index-1] = '\0';
      if (legal_identifier (token+1))
	{
	  strcpy (the_word->word, token+1);
/*itrace("read_token_word: returning REDIR_WORD for %s", the_word->word);*/
	  return (REDIR_WORD);
	}
    }

  result = ((the_word->flags & (W_ASSIGNMENT|W_NOSPLIT)) == (W_ASSIGNMENT|W_NOSPLIT))
		? ASSIGNMENT_WORD : WORD;

  switch (last_read_token)
    {
    case FUNCTION:
      parser_state |= PST_ALLOWOPNBRC;
      function_dstart = line_number;
      break;
    case CASE:
    case SELECT:
    case FOR:
      if (word_top < MAX_CASE_NEST)
	word_top++;
      word_lineno[word_top] = line_number;
      break;
    }

  return (result);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\y.tab.c:6,611
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\y.tab.c:7,077
parsing error 
{
  switch (toksym)
    {
    case '\n':
    case ';':
    case '(':
    case ')':
    case '|':
    case '&':
    case '{':
    case '}':		/* XXX */
    case AND_AND:
    case BANG:
    case BAR_AND:
    case DO:
    case DONE:
    case ELIF:
    case ELSE:
    case ESAC:
    case FI:
    case IF:
    case OR_OR:
    case SEMI_SEMI:
    case SEMI_AND:
    case SEMI_SEMI_AND:
    case THEN:
    case TIME:
    case TIMEOPT:
    case TIMEIGN:
    case COPROC:
    case UNTIL:
    case WHILE:
    case 0:
      return 1;
    default:
#if defined (COPROCESS_SUPPORT)
      if (last_read_token == WORD && token_before_that == COPROC)
	return 1;
#endif
      if (last_read_token == WORD && token_before_that == FUNCTION)
	return 1;
      return 0;
    }
}
warning: parse error {
  switch (toksym)
    {
    case '\n':
    case ';':
    case '(':
    case ')':
    case '|':
    case '&':
    case '{':
    case '}':		/* XXX */
    case AND_AND:
    case BANG:
    case BAR_AND:
    case DO:
    case DONE:
    case ELIF:
    case ELSE:
    case ESAC:
    case FI:
    case IF:
    case OR_OR:
    case SEMI_SEMI:
    case SEMI_AND:
    case SEMI_SEMI_AND:
    case THEN:
    case TIME:
    case TIMEOPT:
    case TIMEIGN:
    case COPROC:
    case UNTIL:
    case WHILE:
    case 0:
      return 1;
    default:
#if defined (COPROCESS_SUPPORT)
      if (last_read_token == WORD && token_before_that == COPROC)
	return 1;
#endif
      if (last_read_token == WORD && token_before_that == FUNCTION)
	return 1;
      return 0;
    }
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\y.tab.c:7,079
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\y.tab.c:7,127
parsing error 
{
  int i;
  for (i = 0; word_token_alist[i].word; i++)
    if (STREQ (tokstr, word_token_alist[i].word))
      return i;
  return -1;
}
warning: parse error {
  int i;
  for (i = 0; word_token_alist[i].word; i++)
    if (STREQ (tokstr, word_token_alist[i].word))
      return i;
  return -1;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\y.tab.c:7,129
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\y.tab.c:7,313
parsing error 
{
  prompt_string_pointer = (x == 2) ? &ps2_prompt : &ps1_prompt;
  current_prompt_string = *prompt_string_pointer;
}
warning: parse error {
  prompt_string_pointer = (x == 2) ? &ps2_prompt : &ps1_prompt;
  current_prompt_string = *prompt_string_pointer;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\y.tab.c:7,315
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\y.tab.c:7,360
parsing error 
{
  WORD_LIST *list;
  char *result, *t;
  struct dstack save_dstack;
  int last_exit_value, last_comsub_pid;
#if defined (PROMPT_STRING_DECODE)
  int result_size, result_index;
  int c, n, i;
  char *temp, octal_string[4];
  struct tm *tm;  
  time_t the_time;
  char timebuf[128];
  char *timefmt;

  result = (char *)xmalloc (result_size = PROMPT_GROWTH);
  result[result_index = 0] = 0;
  temp = (char *)NULL;

  while (c = *string++)
    {
      if (posixly_correct && c == '!')
	{
	  if (*string == '!')
	    {
	      temp = savestring ("!");
	      goto add_string;
	    }
	  else
	    {
#if !defined (HISTORY)
		temp = savestring ("1");
#else /* HISTORY */
		temp = itos (history_number ());
#endif /* HISTORY */
		string--;	/* add_string increments string again. */
		goto add_string;
	    }
	}
      if (c == '\\')
	{
	  c = *string;

	  switch (c)
	    {
	    case '0':
	    case '1':
	    case '2':
	    case '3':
	    case '4':
	    case '5':
	    case '6':
	    case '7':
	      strncpy (octal_string, string, 3);
	      octal_string[3] = '\0';

	      n = read_octal (octal_string);
	      temp = (char *)xmalloc (3);

	      if (n == CTLESC || n == CTLNUL)
		{
		  temp[0] = CTLESC;
		  temp[1] = n;
		  temp[2] = '\0';
		}
	      else if (n == -1)
		{
		  temp[0] = '\\';
		  temp[1] = '\0';
		}
	      else
		{
		  temp[0] = n;
		  temp[1] = '\0';
		}

	      for (c = 0; n != -1 && c < 3 && ISOCTAL (*string); c++)
		string++;

	      c = 0;		/* tested at add_string: */
	      goto add_string;

	    case 'd':
	    case 't':
	    case 'T':
	    case '@':
	    case 'A':
	      /* Make the current time/date into a string. */
	      (void) time (&the_time);
	      tm = localtime (&the_time);

	      if (c == 'd')
		n = strftime (timebuf, sizeof (timebuf), "%a %b %d", tm);
	      else if (c == 't')
		n = strftime (timebuf, sizeof (timebuf), "%H:%M:%S", tm);
	      else if (c == 'T')
		n = strftime (timebuf, sizeof (timebuf), "%I:%M:%S", tm);
	      else if (c == '@')
		n = strftime (timebuf, sizeof (timebuf), "%I:%M %p", tm);
	      else if (c == 'A')
		n = strftime (timebuf, sizeof (timebuf), "%H:%M", tm);

	      if (n == 0)
		timebuf[0] = '\0';
	      else
		timebuf[sizeof(timebuf) - 1] = '\0';

	      temp = savestring (timebuf);
	      goto add_string;

	    case 'D':		/* strftime format */
	      if (string[1] != '{')		/* } */
		goto not_escape;

	      (void) time (&the_time);
	      tm = localtime (&the_time);
	      string += 2;			/* skip { */
	      timefmt = xmalloc (strlen (string) + 3);
	      for (t = timefmt; *string && *string != '}'; )
		*t++ = *string++;
	      *t = '\0';
	      c = *string;	/* tested at add_string */
	      if (timefmt[0] == '\0')
		{
		  timefmt[0] = '%';
		  timefmt[1] = 'X';	/* locale-specific current time */
		  timefmt[2] = '\0';
		}
	      n = strftime (timebuf, sizeof (timebuf), timefmt, tm);
	      free (timefmt);

	      if (n == 0)
		timebuf[0] = '\0';
	      else
		timebuf[sizeof(timebuf) - 1] = '\0';

	      if (promptvars || posixly_correct)
		/* Make sure that expand_prompt_string is called with a
		   second argument of Q_DOUBLE_QUOTES if we use this
		   function here. */
		temp = sh_backslash_quote_for_double_quotes (timebuf);
	      else
		temp = savestring (timebuf);
	      goto add_string;
	      
	    case 'n':
	      temp = (char *)xmalloc (3);
	      temp[0] = no_line_editing ? '\n' : '\r';
	      temp[1] = no_line_editing ? '\0' : '\n';
	      temp[2] = '\0';
	      goto add_string;

	    case 's':
	      temp = base_pathname (shell_name);
	      temp = savestring (temp);
	      goto add_string;

	    case 'v':
	    case 'V':
	      temp = (char *)xmalloc (16);
	      if (c == 'v')
		strcpy (temp, dist_version);
	      else
		sprintf (temp, "%s.%d", dist_version, patch_level);
	      goto add_string;

	    case 'w':
	    case 'W':
	      {
		/* Use the value of PWD because it is much more efficient. */
		char t_string[PATH_MAX];
		int tlen;

		temp = get_string_value ("PWD");

		if (temp == 0)
		  {
		    if (getcwd (t_string, sizeof(t_string)) == 0)
		      {
			t_string[0] = '.';
			tlen = 1;
		      }
		    else
		      tlen = strlen (t_string);
		  }
		else
		  {
		    tlen = sizeof (t_string) - 1;
		    strncpy (t_string, temp, tlen);
		  }
		t_string[tlen] = '\0';

#if defined (MACOSX)
		/* Convert from "fs" format to "input" format */
		temp = fnx_fromfs (t_string, strlen (t_string));
		if (temp != t_string)
		  strcpy (t_string, temp);
#endif

#define ROOT_PATH(x)	((x)[0] == '/' && (x)[1] == 0)
#define DOUBLE_SLASH_ROOT(x)	((x)[0] == '/' && (x)[1] == '/' && (x)[2] == 0)
		/* Abbreviate \W as ~ if $PWD == $HOME */
		if (c == 'W' && (((t = get_string_value ("HOME")) == 0) || STREQ (t, t_string) == 0))
		  {
		    if (ROOT_PATH (t_string) == 0 && DOUBLE_SLASH_ROOT (t_string) == 0)
		      {
			t = strrchr (t_string, '/');
			if (t)
			  memmove (t_string, t + 1, strlen (t));	/* strlen(t) to copy NULL */
		      }
		  }
#undef ROOT_PATH
#undef DOUBLE_SLASH_ROOT
		else
		  /* polite_directory_format is guaranteed to return a string
		     no longer than PATH_MAX - 1 characters. */
		  strcpy (t_string, polite_directory_format (t_string));

		temp = trim_pathname (t_string, PATH_MAX - 1);
		/* If we're going to be expanding the prompt string later,
		   quote the directory name. */
		if (promptvars || posixly_correct)
		  /* Make sure that expand_prompt_string is called with a
		     second argument of Q_DOUBLE_QUOTES if we use this
		     function here. */
		  temp = sh_backslash_quote_for_double_quotes (t_string);
		else
		  temp = savestring (t_string);

		goto add_string;
	      }

	    case 'u':
	      if (current_user.user_name == 0)
		get_current_user_info ();
	      temp = savestring (current_user.user_name);
	      goto add_string;

	    case 'h':
	    case 'H':
	      temp = savestring (current_host_name);
	      if (c == 'h' && (t = (char *)strchr (temp, '.')))
		*t = '\0';
	      goto add_string;

	    case '#':
	      temp = itos (current_command_number);
	      goto add_string;

	    case '!':
#if !defined (HISTORY)
	      temp = savestring ("1");
#else /* HISTORY */
	      temp = itos (history_number ());
#endif /* HISTORY */
	      goto add_string;

	    case '$':
	      t = temp = (char *)xmalloc (3);
	      if ((promptvars || posixly_correct) && (current_user.euid != 0))
		*t++ = '\\';
	      *t++ = current_user.euid == 0 ? '#' : '$';
	      *t = '\0';
	      goto add_string;

	    case 'j':
	      temp = itos (count_all_jobs ());
	      goto add_string;

	    case 'l':
#if defined (HAVE_TTYNAME)
	      temp = (char *)ttyname (fileno (stdin));
	      t = temp ? base_pathname (temp) : "tty";
	      temp = savestring (t);
#else
	      temp = savestring ("tty");
#endif /* !HAVE_TTYNAME */
	      goto add_string;

#if defined (READLINE)
	    case '[':
	    case ']':
	      if (no_line_editing)
		{
		  string++;
		  break;
		}
	      temp = (char *)xmalloc (3);
	      n = (c == '[') ? RL_PROMPT_START_IGNORE : RL_PROMPT_END_IGNORE;
	      i = 0;
	      if (n == CTLESC || n == CTLNUL)
		temp[i++] = CTLESC;
	      temp[i++] = n;
	      temp[i] = '\0';
	      goto add_string;
#endif /* READLINE */

	    case '\\':
	    case 'a':
	    case 'e':
	    case 'r':
	      temp = (char *)xmalloc (2);
	      if (c == 'a')
		temp[0] = '\07';
	      else if (c == 'e')
		temp[0] = '\033';
	      else if (c == 'r')
		temp[0] = '\r';
	      else			/* (c == '\\') */
	        temp[0] = c;
	      temp[1] = '\0';
	      goto add_string;

	    default:
not_escape:
	      temp = (char *)xmalloc (3);
	      temp[0] = '\\';
	      temp[1] = c;
	      temp[2] = '\0';

	    add_string:
	      if (c)
		string++;
	      result =
		sub_append_string (temp, result, &result_index, &result_size);
	      temp = (char *)NULL; /* Freed in sub_append_string (). */
	      result[result_index] = '\0';
	      break;
	    }
	}
      else
	{
	  RESIZE_MALLOCED_BUFFER (result, result_index, 3, result_size, PROMPT_GROWTH);
	  result[result_index++] = c;
	  result[result_index] = '\0';
	}
    }
#else /* !PROMPT_STRING_DECODE */
  result = savestring (string);
#endif /* !PROMPT_STRING_DECODE */

  /* Save the delimiter stack and point `dstack' to temp space so any
     command substitutions in the prompt string won't result in screwing
     up the parser's quoting state. */
  save_dstack = dstack;
  dstack = temp_dstack;
  dstack.delimiter_depth = 0;

  /* Perform variable and parameter expansion and command substitution on
     the prompt string. */
  if (promptvars || posixly_correct)
    {
      last_exit_value = last_command_exit_value;
      last_comsub_pid = last_command_subst_pid;
      list = expand_prompt_string (result, Q_DOUBLE_QUOTES, 0);
      free (result);
      result = string_list (list);
      dispose_words (list);
      last_command_exit_value = last_exit_value;
      last_command_subst_pid = last_comsub_pid;
    }
  else
    {
      t = dequote_string (result);
      free (result);
      result = t;
    }

  dstack = save_dstack;

  return (result);
}
warning: parse error {
  WORD_LIST *list;
  char *result, *t;
  struct dstack save_dstack;
  int last_exit_value, last_comsub_pid;
#if defined (PROMPT_STRING_DECODE)
  int result_size, result_index;
  int c, n, i;
  char *temp, octal_string[4];
  struct tm *tm;  
  time_t the_time;
  char timebuf[128];
  char *timefmt;

  result = (char *)xmalloc (result_size = PROMPT_GROWTH);
  result[result_index = 0] = 0;
  temp = (char *)NULL;

  while (c = *string++)
    {
      if (posixly_correct && c == '!')
	{
	  if (*string == '!')
	    {
	      temp = savestring ("!");
	      goto add_string;
	    }
	  else
	    {
#if !defined (HISTORY)
		temp = savestring ("1");
#else /* HISTORY */
		temp = itos (history_number ());
#endif /* HISTORY */
		string--;	/* add_string increments string again. */
		goto add_string;
	    }
	}
      if (c == '\\')
	{
	  c = *string;

	  switch (c)
	    {
	    case '0':
	    case '1':
	    case '2':
	    case '3':
	    case '4':
	    case '5':
	    case '6':
	    case '7':
	      strncpy (octal_string, string, 3);
	      octal_string[3] = '\0';

	      n = read_octal (octal_string);
	      temp = (char *)xmalloc (3);

	      if (n == CTLESC || n == CTLNUL)
		{
		  temp[0] = CTLESC;
		  temp[1] = n;
		  temp[2] = '\0';
		}
	      else if (n == -1)
		{
		  temp[0] = '\\';
		  temp[1] = '\0';
		}
	      else
		{
		  temp[0] = n;
		  temp[1] = '\0';
		}

	      for (c = 0; n != -1 && c < 3 && ISOCTAL (*string); c++)
		string++;

	      c = 0;		/* tested at add_string: */
	      goto add_string;

	    case 'd':
	    case 't':
	    case 'T':
	    case '@':
	    case 'A':
	      /* Make the current time/date into a string. */
	      (void) time (&the_time);
	      tm = localtime (&the_time);

	      if (c == 'd')
		n = strftime (timebuf, sizeof (timebuf), "%a %b %d", tm);
	      else if (c == 't')
		n = strftime (timebuf, sizeof (timebuf), "%H:%M:%S", tm);
	      else if (c == 'T')
		n = strftime (timebuf, sizeof (timebuf), "%I:%M:%S", tm);
	      else if (c == '@')
		n = strftime (timebuf, sizeof (timebuf), "%I:%M %p", tm);
	      else if (c == 'A')
		n = strftime (timebuf, sizeof (timebuf), "%H:%M", tm);

	      if (n == 0)
		timebuf[0] = '\0';
	      else
		timebuf[sizeof(timebuf) - 1] = '\0';

	      temp = savestring (timebuf);
	      goto add_string;

	    case 'D':		/* strftime format */
	      if (string[1] != '{')		/* } */
		goto not_escape;

	      (void) time (&the_time);
	      tm = localtime (&the_time);
	      string += 2;			/* skip { */
	      timefmt = xmalloc (strlen (string) + 3);
	      for (t = timefmt; *string && *string != '}'; )
		*t++ = *string++;
	      *t = '\0';
	      c = *string;	/* tested at add_string */
	      if (timefmt[0] == '\0')
		{
		  timefmt[0] = '%';
		  timefmt[1] = 'X';	/* locale-specific current time */
		  timefmt[2] = '\0';
		}
	      n = strftime (timebuf, sizeof (timebuf), timefmt, tm);
	      free (timefmt);

	      if (n == 0)
		timebuf[0] = '\0';
	      else
		timebuf[sizeof(timebuf) - 1] = '\0';

	      if (promptvars || posixly_correct)
		/* Make sure that expand_prompt_string is called with a
		   second argument of Q_DOUBLE_QUOTES if we use this
		   function here. */
		temp = sh_backslash_quote_for_double_quotes (timebuf);
	      else
		temp = savestring (timebuf);
	      goto add_string;
	      
	    case 'n':
	      temp = (char *)xmalloc (3);
	      temp[0] = no_line_editing ? '\n' : '\r';
	      temp[1] = no_line_editing ? '\0' : '\n';
	      temp[2] = '\0';
	      goto add_string;

	    case 's':
	      temp = base_pathname (shell_name);
	      temp = savestring (temp);
	      goto add_string;

	    case 'v':
	    case 'V':
	      temp = (char *)xmalloc (16);
	      if (c == 'v')
		strcpy (temp, dist_version);
	      else
		sprintf (temp, "%s.%d", dist_version, patch_level);
	      goto add_string;

	    case 'w':
	    case 'W':
	      {
		/* Use the value of PWD because it is much more efficient. */
		char t_string[PATH_MAX];
		int tlen;

		temp = get_string_value ("PWD");

		if (temp == 0)
		  {
		    if (getcwd (t_string, sizeof(t_string)) == 0)
		      {
			t_string[0] = '.';
			tlen = 1;
		      }
		    else
		      tlen = strlen (t_string);
		  }
		else
		  {
		    tlen = sizeof (t_string) - 1;
		    strncpy (t_string, temp, tlen);
		  }
		t_string[tlen] = '\0';

#if defined (MACOSX)
		/* Convert from "fs" format to "input" format */
		temp = fnx_fromfs (t_string, strlen (t_string));
		if (temp != t_string)
		  strcpy (t_string, temp);
#endif

#define ROOT_PATH(x)	((x)[0] == '/' && (x)[1] == 0)
#define DOUBLE_SLASH_ROOT(x)	((x)[0] == '/' && (x)[1] == '/' && (x)[2] == 0)
		/* Abbreviate \W as ~ if $PWD == $HOME */
		if (c == 'W' && (((t = get_string_value ("HOME")) == 0) || STREQ (t, t_string) == 0))
		  {
		    if (ROOT_PATH (t_string) == 0 && DOUBLE_SLASH_ROOT (t_string) == 0)
		      {
			t = strrchr (t_string, '/');
			if (t)
			  memmove (t_string, t + 1, strlen (t));	/* strlen(t) to copy NULL */
		      }
		  }
#undef ROOT_PATH
#undef DOUBLE_SLASH_ROOT
		else
		  /* polite_directory_format is guaranteed to return a string
		     no longer than PATH_MAX - 1 characters. */
		  strcpy (t_string, polite_directory_format (t_string));

		temp = trim_pathname (t_string, PATH_MAX - 1);
		/* If we're going to be expanding the prompt string later,
		   quote the directory name. */
		if (promptvars || posixly_correct)
		  /* Make sure that expand_prompt_string is called with a
		     second argument of Q_DOUBLE_QUOTES if we use this
		     function here. */
		  temp = sh_backslash_quote_for_double_quotes (t_string);
		else
		  temp = savestring (t_string);

		goto add_string;
	      }

	    case 'u':
	      if (current_user.user_name == 0)
		get_current_user_info ();
	      temp = savestring (current_user.user_name);
	      goto add_string;

	    case 'h':
	    case 'H':
	      temp = savestring (current_host_name);
	      if (c == 'h' && (t = (char *)strchr (temp, '.')))
		*t = '\0';
	      goto add_string;

	    case '#':
	      temp = itos (current_command_number);
	      goto add_string;

	    case '!':
#if !defined (HISTORY)
	      temp = savestring ("1");
#else /* HISTORY */
	      temp = itos (history_number ());
#endif /* HISTORY */
	      goto add_string;

	    case '$':
	      t = temp = (char *)xmalloc (3);
	      if ((promptvars || posixly_correct) && (current_user.euid != 0))
		*t++ = '\\';
	      *t++ = current_user.euid == 0 ? '#' : '$';
	      *t = '\0';
	      goto add_string;

	    case 'j':
	      temp = itos (count_all_jobs ());
	      goto add_string;

	    case 'l':
#if defined (HAVE_TTYNAME)
	      temp = (char *)ttyname (fileno (stdin));
	      t = temp ? base_pathname (temp) : "tty";
	      temp = savestring (t);
#else
	      temp = savestring ("tty");
#endif /* !HAVE_TTYNAME */
	      goto add_string;

#if defined (READLINE)
	    case '[':
	    case ']':
	      if (no_line_editing)
		{
		  string++;
		  break;
		}
	      temp = (char *)xmalloc (3);
	      n = (c == '[') ? RL_PROMPT_START_IGNORE : RL_PROMPT_END_IGNORE;
	      i = 0;
	      if (n == CTLESC || n == CTLNUL)
		temp[i++] = CTLESC;
	      temp[i++] = n;
	      temp[i] = '\0';
	      goto add_string;
#endif /* READLINE */

	    case '\\':
	    case 'a':
	    case 'e':
	    case 'r':
	      temp = (char *)xmalloc (2);
	      if (c == 'a')
		temp[0] = '\07';
	      else if (c == 'e')
		temp[0] = '\033';
	      else if (c == 'r')
		temp[0] = '\r';
	      else			/* (c == '\\') */
	        temp[0] = c;
	      temp[1] = '\0';
	      goto add_string;

	    default:
not_escape:
	      temp = (char *)xmalloc (3);
	      temp[0] = '\\';
	      temp[1] = c;
	      temp[2] = '\0';

	    add_string:
	      if (c)
		string++;
	      result =
		sub_append_string (temp, result, &result_index, &result_size);
	      temp = (char *)NULL; /* Freed in sub_append_string (). */
	      result[result_index] = '\0';
	      break;
	    }
	}
      else
	{
	  RESIZE_MALLOCED_BUFFER (result, result_index, 3, result_size, PROMPT_GROWTH);
	  result[result_index++] = c;
	  result[result_index] = '\0';
	}
    }
#else /* !PROMPT_STRING_DECODE */
  result = savestring (string);
#endif /* !PROMPT_STRING_DECODE */

  /* Save the delimiter stack and point `dstack' to temp space so any
     command substitutions in the prompt string won't result in screwing
     up the parser's quoting state. */
  save_dstack = dstack;
  dstack = temp_dstack;
  dstack.delimiter_depth = 0;

  /* Perform variable and parameter expansion and command substitution on
     the prompt string. */
  if (promptvars || posixly_correct)
    {
      last_exit_value = last_command_exit_value;
      last_comsub_pid = last_command_subst_pid;
      list = expand_prompt_string (result, Q_DOUBLE_QUOTES, 0);
      free (result);
      result = string_list (list);
      dispose_words (list);
      last_command_exit_value = last_exit_value;
      last_command_subst_pid = last_comsub_pid;
    }
  else
    {
      t = dequote_string (result);
      free (result);
      result = t;
    }

  dstack = save_dstack;

  return (result);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\y.tab.c:7,362
parsing error 
t
warning: parse error tMissing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\y.tab.c:7,744
parsing error 
{
  report_syntax_error ((char *)NULL);
  reset_parser ();
  return (0);
}
warning: parse error {
  report_syntax_error ((char *)NULL);
  reset_parser ();
  return (0);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\y.tab.c:7,745
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\y.tab.c:7,752
parsing error 
{
  char *t;

  if (t = find_token_in_alist (tok, word_token_alist, 0))
    return t;

  if (t = find_token_in_alist (tok, other_token_alist, 0))
    return t;

  t = (char *)NULL;
  /* This stuff is dicy and needs closer inspection */
  switch (current_token)
    {
    case WORD:
    case ASSIGNMENT_WORD:
      if (yylval.word)
	t = savestring (yylval.word->word);
      break;
    case NUMBER:
      t = itos (yylval.number);
      break;
    case ARITH_CMD:
      if (yylval.word_list)
        t = string_list (yylval.word_list);
      break;
    case ARITH_FOR_EXPRS:
      if (yylval.word_list)
	t = string_list_internal (yylval.word_list, " ; ");
      break;
    case COND_CMD:
      t = (char *)NULL;		/* punt */
      break;
    }

  return t;
}
warning: parse error {
  char *t;

  if (t = find_token_in_alist (tok, word_token_alist, 0))
    return t;

  if (t = find_token_in_alist (tok, other_token_alist, 0))
    return t;

  t = (char *)NULL;
  /* This stuff is dicy and needs closer inspection */
  switch (current_token)
    {
    case WORD:
    case ASSIGNMENT_WORD:
      if (yylval.word)
	t = savestring (yylval.word->word);
      break;
    case NUMBER:
      t = itos (yylval.number);
      break;
    case ARITH_CMD:
      if (yylval.word_list)
        t = string_list (yylval.word_list);
      break;
    case ARITH_FOR_EXPRS:
      if (yylval.word_list)
	t = string_list_internal (yylval.word_list, " ; ");
      break;
    case COND_CMD:
      t = (char *)NULL;		/* punt */
      break;
    }

  return t;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\y.tab.c:7,754
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\y.tab.c:7,853
parsing error 
{
  char *msg, *p;

  if (message)
    {
      parser_error (line_number, "%s", message);
      if (interactive && EOF_Reached)
	EOF_Reached = 0;
      last_command_exit_value = parse_and_execute_level ? EX_BADSYNTAX : EX_BADUSAGE;
      return;
    }

  /* If the line of input we're reading is not null, try to find the
     objectionable token.  First, try to figure out what token the
     parser's complaining about by looking at current_token. */
  if (current_token != 0 && EOF_Reached == 0 && (msg = error_token_from_token (current_token)))
    {
      if (ansic_shouldquote (msg))
	{
	  p = ansic_quote (msg, 0, NULL);
	  free (msg);
	  msg = p;
	}
      parser_error (line_number, _("syntax error near unexpected token `%s'"), msg);
      free (msg);

      if (interactive == 0)
	print_offending_line ();

      last_command_exit_value = parse_and_execute_level ? EX_BADSYNTAX : EX_BADUSAGE;
      return;
    }

  /* If looking at the current token doesn't prove fruitful, try to find the
     offending token by analyzing the text of the input line near the current
     input line index and report what we find. */
  if (shell_input_line && *shell_input_line)
    {
      msg = error_token_from_text ();
      if (msg)
	{
	  parser_error (line_number, _("syntax error near `%s'"), msg);
	  free (msg);
	}

      /* If not interactive, print the line containing the error. */
      if (interactive == 0)
        print_offending_line ();
    }
  else
    {
      msg = EOF_Reached ? _("syntax error: unexpected end of file") : _("syntax error");
      parser_error (line_number, "%s", msg);
      /* When the shell is interactive, this file uses EOF_Reached
	 only for error reporting.  Other mechanisms are used to
	 decide whether or not to exit. */
      if (interactive && EOF_Reached)
	EOF_Reached = 0;
    }

  last_command_exit_value = parse_and_execute_level ? EX_BADSYNTAX : EX_BADUSAGE;
}
warning: parse error {
  char *msg, *p;

  if (message)
    {
      parser_error (line_number, "%s", message);
      if (interactive && EOF_Reached)
	EOF_Reached = 0;
      last_command_exit_value = parse_and_execute_level ? EX_BADSYNTAX : EX_BADUSAGE;
      return;
    }

  /* If the line of input we're reading is not null, try to find the
     objectionable token.  First, try to figure out what token the
     parser's complaining about by looking at current_token. */
  if (current_token != 0 && EOF_Reached == 0 && (msg = error_token_from_token (current_token)))
    {
      if (ansic_shouldquote (msg))
	{
	  p = ansic_quote (msg, 0, NULL);
	  free (msg);
	  msg = p;
	}
      parser_error (line_number, _("syntax error near unexpected token `%s'"), msg);
      free (msg);

      if (interactive == 0)
	print_offending_line ();

      last_command_exit_value = parse_and_execute_level ? EX_BADSYNTAX : EX_BADUSAGE;
      return;
    }

  /* If looking at the current token doesn't prove fruitful, try to find the
     offending token by analyzing the text of the input line near the current
     input line index and report what we find. */
  if (shell_input_line && *shell_input_line)
    {
      msg = error_token_from_text ();
      if (msg)
	{
	  parser_error (line_number, _("syntax error near `%s'"), msg);
	  free (msg);
	}

      /* If not interactive, print the line containing the error. */
      if (interactive == 0)
        print_offending_line ();
    }
  else
    {
      msg = EOF_Reached ? _("syntax error: unexpected end of file") : _("syntax error");
      parser_error (line_number, "%s", msg);
      /* When the shell is interactive, this file uses EOF_Reached
	 only for error reporting.  Other mechanisms are used to
	 decide whether or not to exit. */
      if (interactive && EOF_Reached)
	EOF_Reached = 0;
    }

  last_command_exit_value = parse_and_execute_level ? EX_BADSYNTAX : EX_BADUSAGE;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\y.tab.c:7,855
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\y.tab.c:7,924
parsing error 
{
}
warning: parse error {
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\y.tab.c:7,926
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\y.tab.c:8,005
parsing error 
{
  WORD_LIST *wl;
  int tok, orig_current_token, orig_line_number, orig_input_terminator;
  int orig_line_count;
  int old_echo_input, old_expand_aliases;
#if defined (HISTORY)
  int old_remember_on_history, old_history_expansion_inhibited;
#endif

#if defined (HISTORY)
  old_remember_on_history = remember_on_history;
#  if defined (BANG_HISTORY)
  old_history_expansion_inhibited = history_expansion_inhibited;
#  endif
  bash_history_disable ();
#endif

  orig_line_number = line_number;
  orig_line_count = current_command_line_count;
  orig_input_terminator = shell_input_line_terminator;
  old_echo_input = echo_input_at_read;
  old_expand_aliases = expand_aliases;

  push_stream (1);
  last_read_token = WORD;		/* WORD to allow reserved words here */
  current_command_line_count = 0;
  echo_input_at_read = expand_aliases = 0;

  with_input_from_string (s, whom);
  wl = (WORD_LIST *)NULL;

  if (flags & 1)
    parser_state |= PST_COMPASSIGN|PST_REPARSE;

  while ((tok = read_token (READ)) != yacc_EOF)
    {
      if (tok == '\n' && *bash_input.location.string == '\0')
	break;
      if (tok == '\n')		/* Allow newlines in compound assignments */
	continue;
      if (tok != WORD && tok != ASSIGNMENT_WORD)
	{
	  line_number = orig_line_number + line_number - 1;
	  orig_current_token = current_token;
	  current_token = tok;
	  yyerror (NULL);	/* does the right thing */
	  current_token = orig_current_token;
	  if (wl)
	    dispose_words (wl);
	  wl = &parse_string_error;
	  break;
	}
      wl = make_word_list (yylval.word, wl);
    }
  
  last_read_token = '\n';
  pop_stream ();

#if defined (HISTORY)
  remember_on_history = old_remember_on_history;
#  if defined (BANG_HISTORY)
  history_expansion_inhibited = old_history_expansion_inhibited;
#  endif /* BANG_HISTORY */
#endif /* HISTORY */

  echo_input_at_read = old_echo_input;
  expand_aliases = old_expand_aliases;

  current_command_line_count = orig_line_count;
  shell_input_line_terminator = orig_input_terminator;

  if (flags & 1)
    parser_state &= ~(PST_COMPASSIGN|PST_REPARSE);

  if (wl == &parse_string_error)
    {
      last_command_exit_value = EXECUTION_FAILURE;
      if (interactive_shell == 0 && posixly_correct)
	jump_to_top_level (FORCE_EOF);
      else
	jump_to_top_level (DISCARD);
    }

  return (REVERSE_LIST (wl, WORD_LIST *));
}
warning: parse error {
  WORD_LIST *wl;
  int tok, orig_current_token, orig_line_number, orig_input_terminator;
  int orig_line_count;
  int old_echo_input, old_expand_aliases;
#if defined (HISTORY)
  int old_remember_on_history, old_history_expansion_inhibited;
#endif

#if defined (HISTORY)
  old_remember_on_history = remember_on_history;
#  if defined (BANG_HISTORY)
  old_history_expansion_inhibited = history_expansion_inhibited;
#  endif
  bash_history_disable ();
#endif

  orig_line_number = line_number;
  orig_line_count = current_command_line_count;
  orig_input_terminator = shell_input_line_terminator;
  old_echo_input = echo_input_at_read;
  old_expand_aliases = expand_aliases;

  push_stream (1);
  last_read_token = WORD;		/* WORD to allow reserved words here */
  current_command_line_count = 0;
  echo_input_at_read = expand_aliases = 0;

  with_input_from_string (s, whom);
  wl = (WORD_LIST *)NULL;

  if (flags & 1)
    parser_state |= PST_COMPASSIGN|PST_REPARSE;

  while ((tok = read_token (READ)) != yacc_EOF)
    {
      if (tok == '\n' && *bash_input.location.string == '\0')
	break;
      if (tok == '\n')		/* Allow newlines in compound assignments */
	continue;
      if (tok != WORD && tok != ASSIGNMENT_WORD)
	{
	  line_number = orig_line_number + line_number - 1;
	  orig_current_token = current_token;
	  current_token = tok;
	  yyerror (NULL);	/* does the right thing */
	  current_token = orig_current_token;
	  if (wl)
	    dispose_words (wl);
	  wl = &parse_string_error;
	  break;
	}
      wl = make_word_list (yylval.word, wl);
    }
  
  last_read_token = '\n';
  pop_stream ();

#if defined (HISTORY)
  remember_on_history = old_remember_on_history;
#  if defined (BANG_HISTORY)
  history_expansion_inhibited = old_history_expansion_inhibited;
#  endif /* BANG_HISTORY */
#endif /* HISTORY */

  echo_input_at_read = old_echo_input;
  expand_aliases = old_expand_aliases;

  current_command_line_count = orig_line_count;
  shell_input_line_terminator = orig_input_terminator;

  if (flags & 1)
    parser_state &= ~(PST_COMPASSIGN|PST_REPARSE);

  if (wl == &parse_string_error)
    {
      last_command_exit_value = EXECUTION_FAILURE;
      if (interactive_shell == 0 && posixly_correct)
	jump_to_top_level (FORCE_EOF);
      else
	jump_to_top_level (DISCARD);
    }

  return (REVERSE_LIST (wl, WORD_LIST *));
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\y.tab.c:8,009
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\y.tab.c:8,096
parsing error 
{
  WORD_LIST *wl, *rl;
  int tok, orig_line_number, orig_token_size, orig_last_token, assignok;
  char *saved_token, *ret;

  saved_token = token;
  orig_token_size = token_buffer_size;
  orig_line_number = line_number;
  orig_last_token = last_read_token;

  last_read_token = WORD;	/* WORD to allow reserved words here */

  token = (char *)NULL;
  token_buffer_size = 0;

  assignok = parser_state&PST_ASSIGNOK;		/* XXX */

  wl = (WORD_LIST *)NULL;	/* ( */
  parser_state |= PST_COMPASSIGN;

  while ((tok = read_token (READ)) != ')')
    {
      if (tok == '\n')			/* Allow newlines in compound assignments */
	{
	  if (SHOULD_PROMPT ())
	    prompt_again ();
	  continue;
	}
      if (tok != WORD && tok != ASSIGNMENT_WORD)
	{
	  current_token = tok;	/* for error reporting */
	  if (tok == yacc_EOF)	/* ( */
	    parser_error (orig_line_number, _("unexpected EOF while looking for matching `)'"));
	  else
	    yyerror(NULL);	/* does the right thing */
	  if (wl)
	    dispose_words (wl);
	  wl = &parse_string_error;
	  break;
	}
      wl = make_word_list (yylval.word, wl);
    }

  FREE (token);
  token = saved_token;
  token_buffer_size = orig_token_size;

  parser_state &= ~PST_COMPASSIGN;

  if (wl == &parse_string_error)
    {
      last_command_exit_value = EXECUTION_FAILURE;
      last_read_token = '\n';	/* XXX */
      if (interactive_shell == 0 && posixly_correct)
	jump_to_top_level (FORCE_EOF);
      else
	jump_to_top_level (DISCARD);
    }

  last_read_token = orig_last_token;		/* XXX - was WORD? */

  if (wl)
    {
      rl = REVERSE_LIST (wl, WORD_LIST *);
      ret = string_list (rl);
      dispose_words (rl);
    }
  else
    ret = (char *)NULL;

  if (retlenp)
    *retlenp = (ret && *ret) ? strlen (ret) : 0;

  if (assignok)
    parser_state |= PST_ASSIGNOK;

  return ret;
}
warning: parse error {
  WORD_LIST *wl, *rl;
  int tok, orig_line_number, orig_token_size, orig_last_token, assignok;
  char *saved_token, *ret;

  saved_token = token;
  orig_token_size = token_buffer_size;
  orig_line_number = line_number;
  orig_last_token = last_read_token;

  last_read_token = WORD;	/* WORD to allow reserved words here */

  token = (char *)NULL;
  token_buffer_size = 0;

  assignok = parser_state&PST_ASSIGNOK;		/* XXX */

  wl = (WORD_LIST *)NULL;	/* ( */
  parser_state |= PST_COMPASSIGN;

  while ((tok = read_token (READ)) != ')')
    {
      if (tok == '\n')			/* Allow newlines in compound assignments */
	{
	  if (SHOULD_PROMPT ())
	    prompt_again ();
	  continue;
	}
      if (tok != WORD && tok != ASSIGNMENT_WORD)
	{
	  current_token = tok;	/* for error reporting */
	  if (tok == yacc_EOF)	/* ( */
	    parser_error (orig_line_number, _("unexpected EOF while looking for matching `)'"));
	  else
	    yyerror(NULL);	/* does the right thing */
	  if (wl)
	    dispose_words (wl);
	  wl = &parse_string_error;
	  break;
	}
      wl = make_word_list (yylval.word, wl);
    }

  FREE (token);
  token = saved_token;
  token_buffer_size = orig_token_size;

  parser_state &= ~PST_COMPASSIGN;

  if (wl == &parse_string_error)
    {
      last_command_exit_value = EXECUTION_FAILURE;
      last_read_token = '\n';	/* XXX */
      if (interactive_shell == 0 && posixly_correct)
	jump_to_top_level (FORCE_EOF);
      else
	jump_to_top_level (DISCARD);
    }

  last_read_token = orig_last_token;		/* XXX - was WORD? */

  if (wl)
    {
      rl = REVERSE_LIST (wl, WORD_LIST *);
      ret = string_list (rl);
      dispose_words (rl);
    }
  else
    ret = (char *)NULL;

  if (retlenp)
    *retlenp = (ret && *ret) ? strlen (ret) : 0;

  if (assignok)
    parser_state |= PST_ASSIGNOK;

  return ret;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\y.tab.c:8,098
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\y.tab.c:8,184
parsing error 
{
  if (ps == 0)
    ps = (sh_parser_state_t *)xmalloc (sizeof (sh_parser_state_t));
  if (ps == 0)
    return ((sh_parser_state_t *)NULL);

  ps->parser_state = parser_state;
  ps->token_state = save_token_state ();

  ps->input_line_terminator = shell_input_line_terminator;
  ps->eof_encountered = eof_encountered;

  ps->prompt_string_pointer = prompt_string_pointer;

  ps->current_command_line_count = current_command_line_count;

#if defined (HISTORY)
  ps->remember_on_history = remember_on_history;
#  if defined (BANG_HISTORY)
  ps->history_expansion_inhibited = history_expansion_inhibited;
#  endif
#endif

  ps->last_command_exit_value = last_command_exit_value;
#if defined (ARRAY_VARS)
  ps->pipestatus = save_pipestatus_array ();
#endif
    
  ps->last_shell_builtin = last_shell_builtin;
  ps->this_shell_builtin = this_shell_builtin;

  ps->expand_aliases = expand_aliases;
  ps->echo_input_at_read = echo_input_at_read;

  return (ps);
}
warning: parse error {
  if (ps == 0)
    ps = (sh_parser_state_t *)xmalloc (sizeof (sh_parser_state_t));
  if (ps == 0)
    return ((sh_parser_state_t *)NULL);

  ps->parser_state = parser_state;
  ps->token_state = save_token_state ();

  ps->input_line_terminator = shell_input_line_terminator;
  ps->eof_encountered = eof_encountered;

  ps->prompt_string_pointer = prompt_string_pointer;

  ps->current_command_line_count = current_command_line_count;

#if defined (HISTORY)
  ps->remember_on_history = remember_on_history;
#  if defined (BANG_HISTORY)
  ps->history_expansion_inhibited = history_expansion_inhibited;
#  endif
#endif

  ps->last_command_exit_value = last_command_exit_value;
#if defined (ARRAY_VARS)
  ps->pipestatus = save_pipestatus_array ();
#endif
    
  ps->last_shell_builtin = last_shell_builtin;
  ps->this_shell_builtin = this_shell_builtin;

  ps->expand_aliases = expand_aliases;
  ps->echo_input_at_read = echo_input_at_read;

  return (ps);
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\y.tab.c:8,186
parsing error 
)
warning: parse error )Missing ';' in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\y.tab.c:8,224
parsing error 
{
  if (ps == 0)
    return;

  parser_state = ps->parser_state;
  if (ps->token_state)
    {
      restore_token_state (ps->token_state);
      free (ps->token_state);
    }

  shell_input_line_terminator = ps->input_line_terminator;
  eof_encountered = ps->eof_encountered;

  prompt_string_pointer = ps->prompt_string_pointer;

  current_command_line_count = ps->current_command_line_count;

#if defined (HISTORY)
  remember_on_history = ps->remember_on_history;
#  if defined (BANG_HISTORY)
  history_expansion_inhibited = ps->history_expansion_inhibited;
#  endif
#endif

  last_command_exit_value = ps->last_command_exit_value;
#if defined (ARRAY_VARS)
  restore_pipestatus_array (ps->pipestatus);
#endif

  last_shell_builtin = ps->last_shell_builtin;
  this_shell_builtin = ps->this_shell_builtin;

  expand_aliases = ps->expand_aliases;
  echo_input_at_read = ps->echo_input_at_read;
}
warning: parse error {
  if (ps == 0)
    return;

  parser_state = ps->parser_state;
  if (ps->token_state)
    {
      restore_token_state (ps->token_state);
      free (ps->token_state);
    }

  shell_input_line_terminator = ps->input_line_terminator;
  eof_encountered = ps->eof_encountered;

  prompt_string_pointer = ps->prompt_string_pointer;

  current_command_line_count = ps->current_command_line_count;

#if defined (HISTORY)
  remember_on_history = ps->remember_on_history;
#  if defined (BANG_HISTORY)
  history_expansion_inhibited = ps->history_expansion_inhibited;
#  endif
#endif

  last_command_exit_value = ps->last_command_exit_value;
#if defined (ARRAY_VARS)
  restore_pipestatus_array (ps->pipestatus);
#endif

  last_shell_builtin = ps->last_shell_builtin;
  this_shell_builtin = ps->this_shell_builtin;

  expand_aliases = ps->expand_aliases;
  echo_input_at_read = ps->echo_input_at_read;
}Syntax error in file: E:\XJTU\架构逆向\架构逆向2025投稿\Data\TSE2025SemArc\demo\bash-4.2\y.tab.c:8,226
all files procceed successfully...
Resolve types and bindings of variables, methods and expressions....
Resolve type bindings....
Dependency analaysing....
types and bindings resolved successfully...
Dependency done....
dependencie data generating...
Start create dependencies matrix....
Finish create dependencies matrix....
reorder dependency matrix...
Dependencies data generating done successfully...
Consumed time: 9.446 s,  or 0.15743333 min.
